e 24:
	    if (pDepth->depth >= 24)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_r8g8b8, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_b8g8r8, pDepth->depth);
	    }
	    break;
	case 32:
	    if (pDepth->depth >= 24)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_x8r8g8b8, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x8b8g8r8, pDepth->depth);
	    }
	    if (pDepth->depth >= 30)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_a2r10g10b10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x2r10g10b10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a2b10g10r10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x2b10g10r10, pDepth->depth);
	    }
	    break;
	}
    }
    

    pFormats = calloc(nformats, sizeof (PictFormatRec));
    if (!pFormats)
	return 0;
    for (f = 0; f < nformats; f++)
    {
        pFormats[f].id = FakeClientID (0);
	pFormats[f].depth = formats[f].depth;
	format = formats[f].format;
	pFormats[f].format = format;
	switch (PICT_FORMAT_TYPE(format)) {
	case PICT_TYPE_ARGB:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    if (pFormats[f].direct.alphaMask)
		pFormats[f].direct.alpha = (PICT_FORMAT_R(format) +
					    PICT_FORMAT_G(format) +
					    PICT_FORMAT_B(format));
	    
	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = (PICT_FORMAT_G(format) + 
				      PICT_FORMAT_B(format));
	    
	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = PICT_FORMAT_B(format);
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = 0;
	    break;

	case PICT_TYPE_ABGR:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    if (pFormats[f].direct.alphaMask)
		pFormats[f].direct.alpha = (PICT_FORMAT_B(format) +
					    PICT_FORMAT_G(format) +
					    PICT_FORMAT_R(format));
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = (PICT_FORMAT_G(format) + 
				       PICT_FORMAT_R(format));
	    
	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = PICT_FORMAT_R(format);
	    
	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = 0;
	    break;

	case PICT_TYPE_BGRA:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format));

	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format) -
					PICT_FORMAT_G(format));

	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format) -
				      PICT_FORMAT_G(format) - PICT_FORMAT_R(format));

	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    pFormats[f].direct.alpha = 0;
	    break;

	case PICT_TYPE_A:
	    pFormats[f].type = PictTypeDirect;

	    pFormats[f].direct.alpha = 0;
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));

	    /* remaining fields already set to zero */
	    break;
	    
	case PICT_TYPE_COLOR:
	case PICT_TYPE_GRAY:
	    pFormats[f].type = PictTypeIndexed;
	    pFormats[f].index.vid = pScreen->visuals[PICT_FORMAT_VIS(format)].vid;
	    break;
	}
    }
    *nformatp = nformats;
    return pFormats;
}

static VisualPtr
PictureFindVisual (ScreenPtr pScreen, VisualID visual)
{
    int         i;
    VisualPtr   pVisual;
    for (i = 0, pVisual = pScreen->visuals;
         i < pScreen->numVisuals;
         i++, pVisual++)
    {
        if (pVisual->vid == visual)
            return pVisual;
    }
    return 0;
}

Bool
PictureInitIndexedFormat(ScreenPtr pScreen, PictFormatPtr format)
{
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    if (format->type != PictTypeIndexed || format->index.pColormap)
	return TRUE;

    if (format->index.vid == pScreen->rootVisual) {
	dixLookupResourceByType((pointer *)&format->index.pColormap,
				pScreen->defColormap, RT_COLORMAP,
				serverClient, DixGetAttrAccess);
    } else {
	VisualPtr pVisual = PictureFindVisual(pScreen, format->index.vid);
	if (CreateColormap(FakeClientID (0), pScreen, pVisual,
		    &format->index.pColormap, AllocNone, 0)
		!= Success)
	    return FALSE;
    }
    if (!ps->InitIndexed(pScreen, format))
	return FALSE;
    return TRUE;
}

static Bool
PictureInitIndexedFormats (ScreenPtr pScreen)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;

    if (!ps)
	return FALSE;
    format = ps->formats;
    nformat = ps->nformats;
    while (nformat--)
	if (!PictureInitIndexedFormat(pScreen, format++))
	    return FALSE;
    return TRUE;
}

Bool
PictureFinishInit (void)
{
    int	    s;

    for (s = 0; s < screenInfo.numScreens; s++)
    {
	if (!PictureInitIndexedFormats (screenInfo.screens[s]))
	    return FALSE;
	(void) AnimCurInit (screenInfo.screens[s]);
    }

    return TRUE;
}

Bool
PictureSetSubpixelOrder (ScreenPtr pScreen, int subpixel)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);

    if (!ps)
	return FALSE;
    ps->subpixel = subpixel;
    return TRUE;
    
}

int
PictureGetSubpixelOrder (ScreenPtr pScreen)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);

    if (!ps)
	return SubPixelUnknown;
    return ps->subpixel;
}
    
PictFormatPtr
PictureMatchVisual (ScreenPtr pScreen, int depth, VisualPtr pVisual)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;
    int			type;

    if (!ps)
	return 0;
    format = ps->formats;
    nformat = ps->nformats;
    switch (pVisual->class) {
    case StaticGray:
    case GrayScale:
    case StaticColor:
    case PseudoColor:
	type = PictTypeIndexed;
	break;
    case TrueColor:
    case DirectColor:
	type = PictTypeDirect;
	break;
    default:
	return 0;
    }
    while (nformat--)
    {
	if (format->depth == depth && format->type == type)
	{
	    if (type == PictTypeIndexed)
	    {
		if (format->index.vid == pVisual->vid)
		    return format;
	    }
	    else
	    {
		if (format->direct.redMask << format->direct.red == 
		    pVisual->redMask &&
		    format->direct.greenMask << format->direct.green == 
		    pVisual->greenMask &&
		    format->direct.blueMask << format->direct.blue == 
		    pVisual->blueMask)
		{
		    return format;
		}
	    }
	}
	format++;
    }
    return 0;
}

PictFormatPtr
PictureMatchFormat (ScreenPtr pScreen, int depth, CARD32 f)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;

    if (!ps)
	return 0;
    format = ps->formats;
    nformat = ps->nformats;
    while (nformat--)
    {
	if (format->depth == depth && format->format == (f & 0xffffff))
	    return format;
	format++;
    }
    return 0;
}

int
PictureParseCmapPolicy (const char *name)
{
    if ( strcmp (name, "default" ) == 0)
	return PictureCmapPolicyDefault;
    else if ( strcmp (name, "mono" ) == 0)
	return PictureCmapPolicyMono;
    else if ( strcmp (name, "gray" ) == 0)
	return PictureCmapPolicyGray;
    else if ( strcmp (name, "color" ) == 0)
	return PictureCmapPolicyColor;
    else if ( strcmp (name, "all" ) == 0)
	return PictureCmapPolicyAll;
    else
	return PictureCmapPolicyInvalid;
}

Bool
PictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats)
{
    PictureScreenPtr	ps;
    int			n;
    CARD32		type, a, r, g, b;
    
    if (PictureGeneration != serverGeneration)
    {
	PictureType = CreateNewResourceType (FreePicture, "PICTURE");
	if (!PictureType)
	    return FALSE;
	PictFormatType = CreateNewResourceType (FreePictFormat, "PICTFORMAT");
	if (!PictFormatType)
	    return FALSE;
	GlyphSetType = CreateNewResourceType (FreeGlyphSet, "GLYPHSET");
	if (!GlyphSetType)
	    return FALSE;
	PictureGeneration = serverGeneration;
    }
    if (!dixRegisterPrivateKey(&PictureScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;

    if (!dixRegisterPrivateKey(&PictureWindowPrivateKeyRec, PRIVATE_WINDOW, 0))
	return FALSE;

    if (!formats)
    {
	formats = PictureCreateDefaultFormats (pScreen, &nformats);
	if (!formats)
	    return FALSE;
    }
    for (n = 0; n < nformats; n++)
    {
	if (!AddResource (formats[n].id, PictFormatType, (pointer) (formats+n)))
	{
	    free(formats);
	    return FALSE;
	}
	if (formats[n].type == PictTypeIndexed)
	{
            VisualPtr   pVisual = PictureFindVisual (pScreen, formats[n].index.vid);
	    if ((pVisual->class | DynamicClass) == PseudoColor)
		type = PICT_TYPE_COLOR;
	    else
		type = PICT_TYPE_GRAY;
	    a = r = g = b = 0;
	}
	else
	{
	    if ((formats[n].direct.redMask|
		 formats[n].direct.blueMask|
		 formats[n].direct.greenMask) == 0)
		type = PICT_TYPE_A;
	    else if (formats[n].direct.red > formats[n].direct.blue)
		type = PICT_TYPE_ARGB;
	    else if (formats[n].direct.red == 0)
		type = PICT_TYPE_ABGR;
	    else
		type = PICT_TYPE_BGRA;
	    a = Ones (formats[n].direct.alphaMask);
	    r = Ones (formats[n].direct.redMask);
	    g = Ones (formats[n].direct.greenMask);
	    b = Ones (formats[n].direct.blueMask);
	}
	formats[n].format = PICT_FORMAT(0,type,a,r,g,b);
    }
    ps = (PictureScreenPtr) malloc(sizeof (PictureScreenRec));
    if (!ps)
    {
	free(formats);
	return FALSE;
    }
    SetPictureScreen(pScreen, ps);

    ps->formats = formats;
    ps->fallback = formats;
    ps->nformats = nformats;
    
    ps->filters = 0;
    ps->nfilters = 0;
    ps->filterAliases = 0;
    ps->nfilterAliases = 0;

    ps->subpixel = SubPixelUnknown;

    ps->CloseScreen = pScreen->CloseScreen;
    ps->DestroyWindow = pScreen->DestroyWindow;
    ps->StoreColors = pScreen->StoreColors;
    pScreen->DestroyWindow = PictureDestroyWindow;
    pScreen->CloseScreen = PictureCloseScreen;
    pScreen->StoreColors = PictureStoreColors;

    if (!PictureSetDefaultFilters (pScreen))
    {
	PictureResetFilters (pScreen);
	SetPictureScreen(pScreen, 0);
	free(formats);
	free(ps);
	return FALSE;
    }

    return TRUE;
}

void
SetPictureToDefaults (PicturePtr    pPicture)
{
    pPicture->refcnt = 1;
    pPicture->repeat = 0;
    pPicture->graphicsExposures = FALSE;
    pPicture->subWindowMode = ClipByChildren;
    pPicture->polyEdge = PolyEdgeSharp;
    pPicture->polyMode = PolyModePrecise;
    pPicture->freeCompClip = FALSE;
    pPicture->clientClipType = CT_NONE;
    pPicture->componentAlpha = FALSE;
    pPicture->repeatType = RepeatNone;

    pPicture->alphaMap = 0;
    pPicture->alphaOrigin.x = 0;
    pPicture->alphaOrigin.y = 0;

    pPicture->clipOrigin.x = 0;
    pPicture->clipOrigin.y = 0;
    pPicture->clientClip = 0;

    pPicture->transform = 0;

    pPicture->filter = PictureGetFilterId (FilterNearest, -1, TRUE);
    pPicture->filter_params = 0;
    pPicture->filter_nparams = 0;

    pPicture->serialNumber = GC_CHANGE_SERIAL_BIT;
    pPicture->stateChanges = -1;
    pPicture->pSourcePict = 0;
}

PicturePtr
CreatePicture (Picture		pid,
	       DrawablePtr	pDrawable,
	       PictFormatPtr	pFormat,
	       Mask		vmask,
	       XID		*vlist,
	       ClientPtr	client,
	       int		*error)
{
    PicturePtr		pPicture;
    PictureScreenPtr	ps = GetPictureScreen(pDrawable->pScreen);

    pPicture = dixAllocateObjectWithPrivates(PictureRec, PRIVATE_PICTURE);
    if (!pPicture)
    {
	*error = BadAlloc;
	return 0;
    }

    pPicture->id = pid;
    pPicture->pDrawable = pDrawable;
    pPicture->pFormat = pFormat;
    pPicture->format = pFormat->format | (pDrawable->bitsPerPixel << 24);

    /* security creation/labeling check */
    *error = XaceHook(XACE_RESOURCE_ACCESS, client, pid, PictureType, pPicture,
		      RT_PIXMAP, pDrawable, DixCreateAccess|DixSetAttrAccess);
    if (*error != Success)
	goto out;

    if (pDrawable->type == DRAWABLE_PIXMAP)
    {
	++((PixmapPtr)pDrawable)->refcnt;
	pPicture->pNext = 0;
    }
    else
    {
	pPicture->pNext = GetPictureWindow(((WindowPtr) pDrawable));
	SetPictureWindow(((WindowPtr) pDrawable), pPicture);
    }

    SetPictureToDefaults (pPicture);
    
    if (vmask)
	*error = ChangePicture (pPicture, vmask, vlist, 0, client);
    else
	*error = Success;
    if (*error == Success)
	*error = (*ps->CreatePicture) (pPicture);
out:
    if (*error != Success)
    {
	FreePicture (pPicture, (XID) 0);
	pPicture = 0;
    }
    return pPicture;
}

static CARD32 xRenderColorToCard32(xRenderColor c)
{
    return
        (c.alpha >> 8 << 24) |
        (c.red >> 8 << 16) |
        (c.green & 0xff00) |
        (c.blue >> 8);
}

static void initGradient(SourcePictPtr pGradient, int stopCount,
                         xFixed *stopPoints, xRenderColor *stopColors, int *error)
{
    int i;
    xFixed dpos;

    if (stopCount <= 0) {
        *error = BadValue;
        return;
    }

    dpos = -1;
    for (i = 0; i < stopCount; ++i) {
        if (stopPoints[i] < dpos || stopPoints[i] > (1<<16)) {
            *error = BadValue;
            return;
        }
        dpos = stopPoints[i];
    }

    pGradient->gradient.stops = malloc(stopCount*sizeof(PictGradientStop));
    if (!pGradient->gradient.stops) {
        *error = BadAlloc;
        return;
    }

    pGradient->gradient.nstops = stopCount;

    for (i = 0; i < stopCount; ++i) {
        pGradient->gradient.stops[i].x = stopPoints[i];
        pGradient->gradient.stops[i].color = stopColors[i];
    }
}

static PicturePtr createSourcePicture(void)
{
    PicturePtr pPicture;
    pPicture = dixAllocateObjectWithPrivates(PictureRec, PRIVATE_PICTURE);
    pPicture->pDrawable = 0;
    pPicture->pFormat = 0;
    pPicture->pNext = 0;
    pPicture->format = PICT_a8r8g8b8;

    SetPictureToDefaults(pPicture);
    return pPicture;
}

PicturePtr
CreateSolidPicture (Picture pid, xRenderColor *color, int *error)
{
    PicturePtr pPicture;
    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictSolidFill));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }
    pPicture->pSourcePict->type = SourcePictTypeSolidFill;
    pPicture->pSourcePict->solidFill.color = xRenderColorToCard32(*color);
    return pPicture;
}

PicturePtr
CreateLinearGradientPicture (Picture pid, xPointFixed *p1, xPointFixed *p2,
                             int nStops, xFixed *stops, xRenderColor *colors, int *error)
{
    PicturePtr pPicture;

    if (nStops < 2) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictLinearGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }

    pPicture->pSourcePict->linear.type = SourcePictTypeLinear;
    pPicture->pSourcePict->linear.p1 = *p1;
    pPicture->pSourcePict->linear.p2 = *p2;

    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

PicturePtr
CreateRadialGradientPicture (Picture pid, xPointFixed *inner, xPointFixed *outer,
                             xFixed innerRadius, xFixed outerRadius,
                             int nStops, xFixed *stops, xRenderColor *colors, int *error)
{
    PicturePtr pPicture;
    PictRadialGradient *radial;

    if (nStops < 2) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictRadialGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }
    radial = &pPicture->pSourcePict->radial;

    radial->type = SourcePictTypeRadial;
    radial->c1.x = inner->x;
    radial->c1.y = inner->y;
    radial->c1.radius = innerRadius;
    radial->c2.x = outer->x;
    radial->c2.y = outer->y;
    radial->c2.radius = outerRadius;
    
    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

PicturePtr
CreateConicalGradientPicture (Picture pid, xPointFixed *center, xFixed angle,
                              int nStops, xFixed *stops, xRenderColor *colors, int *error)
{
    PicturePtr pPicture;

    if (nStops < 2) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictConicalGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }

    pPicture->pSourcePict->conical.type = SourcePictTypeConical;
    pPicture->pSourcePict->conical.center = *center;
    pPicture->pSourcePict->conical.angle = angle;

    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

#define NEXT_VAL(_type) (vlist ? (_type) *vlist++ : (_type) ulist++->val)

#define NEXT_PTR(_type) ((_type) ulist++->ptr)

int
ChangePicture (PicturePtr	pPicture,
	       Mask		vmask,
	       XID		*vlist,
	       DevUnion		*ulist,
	       ClientPtr	client)
{
    ScreenPtr pScreen = pPicture->pDrawable ? pPicture->pDrawable->pScreen : 0;
    PictureScreenPtr ps = pScreen ? GetPictureScreen(pScreen) : 0;
    BITS32		index2;
    int			error = 0;
    BITS32		maskQ;
    
    pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    maskQ = vmask;
    while (vmask && !error)
    {
	index2 = (BITS32) lowbit (vmask);
	vmask &= ~index2;
	pPicture->stateChanges |= index2;
	switch (index2)
	{
	case CPRepeat:
	    {
		unsigned int	newr;
		newr = NEXT_VAL(unsigned int);
		if (newr <= RepeatReflect)
		{
		    pPicture->repeat = (newr != RepeatNone);
		    pPicture->repeatType = newr;
		}
		else
		{
		    client->errorValue = newr;
		    error = BadValue;
		}
	    }
	    break;
	case CPAlphaMap:
	    {
		PicturePtr  pAlpha;
		
		if (vlist)
		{
		    Picture	pid = NEXT_VAL(Picture);

		    if (pid == None)
			pAlpha = 0;
		    else
		    {
			error = dixLookupResourceByType((pointer *)&pAlpha, pid,
						  PictureType, client,
						  DixReadAccess);
			if (error != Success)
			{
			    client->errorValue = pid;
			    break;
			}
			if (pAlpha->pDrawable == NULL ||
			    pAlpha->pDrawable->type != DRAWABLE_PIXMAP)
			{
			    client->errorValue = pid;
			    error = BadMatch;
			    break;
			}
		    }
		}
		else
		    pAlpha = NEXT_PTR(PicturePtr);
		if (!error)
		{
		    if (pAlpha && pAlpha->pDrawable->type == DRAWABLE_PIXMAP)
			pAlpha->refcnt++;
		    if (pPicture->alphaMap)
			FreePicture ((pointer) pPicture->alphaMap, (XID) 0);
		    pPicture->alphaMap = pAlpha;
		}
	    }
	    break;
	case CPAlphaXOrigin:
	    pPicture->alphaOrigin.x = NEXT_VAL(INT16);
	    break;
	case CPAlphaYOrigin:
	    pPicture->alphaOrigin.y = NEXT_VAL(INT16);
	    break;
	case CPClipXOrigin:
	    pPicture->clipOrigin.x = NEXT_VAL(INT16);
	    break;
	case CPClipYOrigin:
	    pPicture->clipOrigin.y = NEXT_VAL(INT16);
	    break;
	case CPClipMask:
	    {
		Pixmap	    pid;
		PixmapPtr   pPixmap;
		int	    clipType;
                if (!pScreen)
                    return BadDrawable;

		if (vlist)
		{
		    pid = NEXT_VAL(Pixmap);
		    if (pid == None)
		    {
			clipType = CT_NONE;
			pPixmap = NullPixmap;
		    }
		    else
		    {
			clipType = CT_PIXMAP;
			error = dixLookupResourceByType((pointer *)&pPixmap, pid,
						  RT_PIXMAP, client,
						  DixReadAccess);
			if (error != Success)
			{
			    client->errorValue = pid;
			    break;
			}
		    }
		}
		else
		{
		    pPixmap = NEXT_PTR(PixmapPtr);
		    if (pPixmap)
			clipType = CT_PIXMAP;
		    else
			clipType = CT_NONE;
		}

		if (pPixmap)
		{
		    if ((pPixmap->drawable.depth != 1) ||
			(pPixmap->drawable.pScreen != pScreen))
		    {
			error = BadMatch;
			break;
		    }
		    else
		    {
			clipType = CT_PIXMAP;
			pPixmap->refcnt++;
		    }
		}
		error = (*ps->ChangePictureClip)(pPicture, clipType,
						 (pointer)pPixmap, 0);
		break;
	    }
	case CPGraphicsExposure:
	    {
		unsigned int	newe;
		newe = NEXT_VAL(unsigned int);
		if (newe <= xTrue)
		    pPicture->graphicsExposures = newe;
		else
		{
		    client->errorValue = newe;
		    error = BadValue;
		}
	    }
	    break;
	case CPSubwindowMode:
	    {
		unsigned int	news;
		news = NEXT_VAL(unsigned int);
		if (news == ClipByChildren || news == IncludeInferiors)
		    pPicture->subWindowMode = news;
		else
		{
		    client->errorValue = news;
		    error = BadValue;
		}
	    }
	    break;
	case CPPolyEdge:
	    {
		unsigned int	newe;
		newe = NEXT_VAL(unsigned int);
		if (newe == PolyEdgeSharp || newe == PolyEdgeSmooth)
		    pPicture->polyEdge = newe;
		else
		{
		    client->errorValue = newe;
		    error = BadValue;
		}
	    }
	    break;
	case CPPolyMode:
	    {
		unsigned int	newm;
		newm = NEXT_VAL(unsigned int);
		if (newm == PolyModePrecise || newm == PolyModeImprecise)
		    pPicture->polyMode = newm;
		else
		{
		    client->errorValue = newm;
		    error = BadValue;
		}
	    }
	    break;
	case CPDither:
	    (void) NEXT_VAL(Atom); /* unimplemented */
	    break;
	case CPComponentAlpha:
	    {
		unsigned int	newca;

		newca = NEXT_VAL (unsigned int);
		if (newca <= xTrue)
		    pPicture->componentAlpha = newca;
		else
		{
		    client->errorValue = newca;
		    error = BadValue;
		}
	    }
	    break;
	default:
	    client->errorValue = maskQ;
	    error = BadValue;
	    break;
	}
    }
    if (ps)
        (*ps->ChangePicture) (pPicture, maskQ);
    return error;
}

int
SetPictureClipRects (PicturePtr	pPicture,
		     int	xOrigin,
		     int	yOrigin,
		     int	nRect,
		     xRectangle	*rects)
{
    ScreenPtr		pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
    RegionPtr		clientClip;
    int			result;

    clientClip = RegionFromRects(nRect, rects, CT_UNSORTED);
    if (!clientClip)
	return BadAlloc;
    result =(*ps->ChangePictureClip) (pPicture, CT_REGION, 
				      (pointer) clientClip, 0);
    if (result == Success)
    {
	pPicture->clipOrigin.x = xOrigin;
	pPicture->clipOrigin.y = yOrigin;
	pPicture->stateChanges |= CPClipXOrigin|CPClipYOrigin|CPClipMask;
	pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    }
    return result;
}

int
SetPictureClipRegion (PicturePtr    pPicture,
                      int           xOrigin,
                      int           yOrigin,
                      RegionPtr     pRegion)
{
    ScreenPtr           pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    RegionPtr           clientClip;
    int                 result;
    int                 type;

    if (pRegion)
    {
        type = CT_REGION;
        clientClip = RegionCreate(RegionExtents(pRegion),
                                  RegionNumRects(pRegion));
        if (!clientClip)
            return BadAlloc;
        if (!RegionCopy(clientClip, pRegion))
        {
            RegionDestroy(clientClip);
            return BadAlloc;
        }
    }
    else
    {
        type = CT_NONE;
        clientClip = 0;
    }

    result =(*ps->ChangePictureClip) (pPicture, type,
                                      (pointer) clientClip, 0);
    if (result == Success)
    {
        pPicture->clipOrigin.x = xOrigin;
        pPicture->clipOrigin.y = yOrigin;
        pPicture->stateChanges |= CPClipXOrigin|CPClipYOrigin|CPClipMask;
        pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    }
    return result;
}

static Bool
transformIsIdentity(PictTransform *t)
{
    return ((t->matrix[0][0] == t->matrix[1][1]) &&
            (t->matrix[0][0] == t->matrix[2][2]) &&
            (t->matrix[0][0] != 0) &&
            (t->matrix[0][1] == 0) &&
            (t->matrix[0][2] == 0) &&
            (t->matrix[1][0] == 0) &&
            (t->matrix[1][2] == 0) &&
            (t->matrix[2][0] == 0) &&
            (t->matrix[2][1] == 0));
}

int
SetPictureTransform (PicturePtr	    pPicture,
		     PictTransform  *transform)
{
    if (transform && transformIsIdentity (transform))
	transform = 0;
    
    if (transform)
    {
	if (!pPicture->transform)
	{
	    pPicture->transform = (PictTransform *) malloc(sizeof (PictTransform));
	    if (!pPicture->transform)
		return BadAlloc;
	}
	*pPicture->transform = *transform;
    }
    else
    {
	free(pPicture->transform);
	pPicture->transform = NULL;
    }
    pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;

    if (pPicture->pDrawable != NULL) {
	int result;
	PictureScreenPtr ps = GetPictureScreen(pPicture->pDrawable->pScreen);

	result = (*ps->ChangePictureTransform) (pPicture, transform);

	return result;
    }

    return Success;
}

void
CopyPicture (PicturePtr	pSrc,
	     Mask	mask,
	     PicturePtr	pDst)
{
    PictureScreenPtr ps = GetPictureScreen(pSrc->pDrawable->pScreen);
    Mask origMask = mask;

    pDst->serialNumber |= GC_CHANGE_SERIAL_BIT;
    pDst->stateChanges |= mask;

    while (mask) {
	Mask bit = lowbit(mask);

	switch (bit)
	{
	case CPRepeat:
	    pDst->repeat = pSrc->repeat;
	    pDst->repeatType = pSrc->repeatType;
	    break;
	case CPAlphaMap:
	    if (pSrc->alphaMap && pSrc->alphaMap->pDrawable->type == DRAWABLE_PIXMAP)
		pSrc->alphaMap->refcnt++;
	    if (pDst->alphaMap)
		FreePicture ((pointer) pDst->alphaMap, (XID) 0);
	    pDst->alphaMap = pSrc->alphaMap;
	    break;
	case CPAlphaXOrigin:
	    pDst->alphaOrigin.x = pSrc->alphaOrigin.x;
	    break;
	case CPAlphaYOrigin:
	    pDst->alphaOrigin.y = pSrc->alphaOrigin.y;
	    break;
	case CPClipXOrigin:
	    pDst->clipOrigin.x = pSrc->clipOrigin.x;
	    break;
	case CPClipYOrigin:
	    pDst->clipOrigin.y = pSrc->clipOrigin.y;
	    break;
	case CPClipMask:
	    switch (pSrc->clientClipType) {
	    case CT_NONE:
		(*ps->ChangePictureClip)(pDst, CT_NONE, NULL, 0);
		break;
	    case CT_REGION:
		if (!pSrc->clientClip) {
		    (*ps->ChangePictureClip)(pDst, CT_NONE, NULL, 0);
		} else {
		    RegionPtr clientClip;
		    RegionPtr srcClientClip = (RegionPtr)pSrc->clientClip;

		    clientClip = RegionCreate(
			RegionExtents(srcClientClip),
			RegionNumRects(srcClientClip));
		    (*ps->ChangePictureClip)(pDst, CT_REGION, clientClip, 0);
		}
		break;
	    default:
		/* XXX: CT_PIXMAP unimplemented */
		break;
	    }
	    break;
	case CPGraphicsExposure:
	    pDst->graphicsExposures = pSrc->graphicsExposures;
	    break;
	case CPPolyEdge:
	    pDst->polyEdge = pSrc->polyEdge;
	    break;
	case CPPolyMode:
	    pDst->polyMode = pSrc->polyMode;
	    break;
	case CPDither:
	    break;
	case CPComponentAlpha:
	    pDst->componentAlpha = pSrc->componentAlpha;
	    break;
	}
	mask &= ~bit;
    }

    (*ps->ChangePicture)(pDst, origMask);
}

static void
ValidateOnePicture (PicturePtr pPicture)
{
    if (pPicture->pDrawable && pPicture->serialNumber != pPicture->pDrawable->serialNumber)
    {
	PictureScreenPtr    ps = GetPictureScreen(pPicture->pDrawable->pScreen);

	(*ps->ValidatePicture) (pPicture, pPicture->stateChanges);
	pPicture->stateChanges = 0;
	pPicture->serialNumber = pPicture->pDrawable->serialNumber;
    }
}

void
ValidatePicture(PicturePtr pPicture)
{
    ValidateOnePicture (pPicture);
    if (pPicture->alphaMap)
	ValidateOnePicture (pPicture->alphaMap);
}

int
FreePicture (pointer	value,
	     XID	pid)
{
    PicturePtr	pPicture = (PicturePtr) value;

    if (--pPicture->refcnt == 0)
    {
	free(pPicture->transform);

	if (pPicture->pSourcePict)
	{
	    if (pPicture->pSourcePict->type != SourcePictTypeSolidFill)
		free(pPicture->pSourcePict->linear.stops);

	    free(pPicture->pSourcePict);
	}

	if (pPicture->pDrawable)
	{
            ScreenPtr	    pScreen = pPicture->pDrawable->pScreen;
            PictureScreenPtr    ps = GetPictureScreen(pScreen);
	
            if (pPicture->alphaMap)
                FreePicture ((pointer) pPicture->alphaMap, (XID) 0);
            (*ps->DestroyPicture) (pPicture);
            (*ps->DestroyPictureClip) (pPicture);
            if (pPicture->pDrawable->type == DRAWABLE_WINDOW)
            {
                WindowPtr	pWindow = (WindowPtr) pPicture->pDrawable;
                PicturePtr	*pPrev;

                for (pPrev = (PicturePtr *)dixLookupPrivateAddr
			 (&pWindow->devPrivates, PictureWindowPrivateKey);
                     *pPrev;
                     pPrev = &(*pPrev)->pNext)
                {
                    if (*pPrev == pPicture)
                    {
                        *pPrev = pPicture->pNext;
                        break;
                    }
                }
            }
            else if (pPicture->pDrawable->type == DRAWABLE_PIXMAP)
            {
                (*pScreen->DestroyPixmap) ((PixmapPtr)pPicture->pDrawable);
            }
        }
	dixFreeObjectWithPrivates(pPicture, PRIVATE_PICTURE);
    }
    return Success;
}

int
FreePictFormat (pointer	pPictFormat,
		XID     pid)
{
    return Success;
}

/**
 * ReduceCompositeOp is used to choose simpler ops for cases where alpha
 * channels are always one and so math on the alpha channel per pixel becomes
 * unnecessary.  It may also avoid destination reads sometimes if apps aren't
 * being careful to avoid these cases.
 */
static CARD8
ReduceCompositeOp (CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
		   INT16 xSrc, INT16 ySrc, CARD16 width, CARD16 height)
{
    Bool no_src_alpha, no_dst_alpha;

    /* Sampling off the edge of a RepeatNone picture introduces alpha
     * even if the picture itself doesn't have alpha. We don't try to
     * detect every case where we don't sample off the edge, just the
     * simplest case where there is no transform on the source
     * picture.
     */
    no_src_alpha = PICT_FORMAT_COLOR(pSrc->format) &&
                   PICT_FORMAT_A(pSrc->format) == 0 &&
                   (pSrc->repeatType != RepeatNone ||
		    (!pSrc->transform &&
		     xSrc >= 0 && ySrc >= 0 &&
		     xSrc + width <= pSrc->pDrawable->width &&
		     ySrc + height <= pSrc->pDrawable->height)) &&
                   pSrc->alphaMap == NULL &&
                   pMask == NULL;
    no_dst_alpha = PICT_FORMAT_COLOR(pDst->format) &&
                   PICT_FORMAT_A(pDst->format) == 0 &&
                   pDst->alphaMap == NULL;

    /* TODO, maybe: Conjoint and Disjoint op reductions? */
 
    /* Deal with simplifications where the source alpha is always 1. */
    if (no_src_alpha)
    {
	switch (op) {
	case PictOpOver:
	    op = PictOpSrc;
	    break;
	case PictOpInReverse:
	    op = PictOpDst;
	    break;
	case PictOpOutReverse:
	    op = PictOpClear;
	    break;
	case PictOpAtop:
	    op = PictOpIn;
	    break;
	case PictOpAtopReverse:
	    op = PictOpOverReverse;
	    break;
	case PictOpXor:
	    op = PictOpOut;
	    break;
	default:
	    break;
	}
    }

    /* Deal with simplifications when the destination alpha is always 1 */
    if (no_dst_alpha)
    {
	switch (op) {
	case PictOpOverReverse:
	    op = PictOpDst;
	    break;
	case PictOpIn:
	    op = PictOpSrc;
	    break;
	case PictOpOut:
	    op = PictOpClear;
	    break;
	case PictOpAtop:
	    op = PictOpOver;
	    break;
	case PictOpXor:
	    op = PictOpOutReverse;
	    break;
	default:
	    break;
	}
    }

    /* Reduce some con/disjoint ops to the basic names. */
    switch (op) {
    case PictOpDisjointClear:
    case PictOpConjointClear:
	op = PictOpClear;
	break;
    case PictOpDisjointSrc:
    case PictOpConjointSrc:
	op = PictOpSrc;
	break;
    case PictOpDisjointDst:
    case PictOpConjointDst:
	op = PictOpDst;
	break;
    default:
	break;
    }

    return op;
}

void
CompositePicture (CARD8		op,
		  PicturePtr	pSrc,
		  PicturePtr	pMask,
		  PicturePtr	pDst,
		  INT16		xSrc,
		  INT16		ySrc,
		  INT16		xMask,
		  INT16		yMask,
		  INT16		xDst,
		  INT16		yDst,
		  CARD16	width,
		  CARD16	height)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    if (pMask)
	ValidatePicture (pMask);
    ValidatePicture (pDst);

    op = ReduceCompositeOp (op, pSrc, pMask, pDst, xSrc, ySrc, width, height);
    if (op == PictOpDst)
	return;

    (*ps->Composite) (op,
		       pSrc,
		       pMask,
		       pDst,
		       xSrc,
		       ySrc,
		       xMask,
		       yMask,
		       xDst,
		       yDst,
		       width,
		       height);
}

void
CompositeRects (CARD8		op,
		PicturePtr	pDst,
		xRenderColor	*color,
		int		nRect,
		xRectangle      *rects)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pDst);
    (*ps->CompositeRects) (op, pDst, color, nRect, rects);
}

void
CompositeTrapezoids (CARD8	    op,
		     PicturePtr	    pSrc,
		     PicturePtr	    pDst,
		     PictFormatPtr  maskFormat,
		     INT16	    xSrc,
		     INT16	    ySrc,
		     int	    ntrap,
		     xTrapezoid	    *traps)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->Trapezoids) (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntrap, traps);
}

void
CompositeTriangles (CARD8	    op,
		    PicturePtr	    pSrc,
		    PicturePtr	    pDst,
		    PictFormatPtr   maskFormat,
		    INT16	    xSrc,
		    INT16	    ySrc,
		    int		    ntriangles,
		    xTriangle	    *triangles)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->Triangles) (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntriangles, triangles);
}

void
CompositeTriStrip (CARD8	    op,
		   PicturePtr	    pSrc,
		   PicturePtr	    pDst,
		   PictFormatPtr    maskFormat,
		   INT16	    xSrc,
		   INT16	    ySrc,
		   int		    npoints,
		   xPointFixed	    *points)
{
    xTriangle           *tris, *tri;
    int                 ntri;
    
    if (npoints < 3)
        return;
    ntri = npoints - 2;
    tris = malloc(ntri * sizeof (xTriangle));
    if (!tris)
        return;
    for (tri = tris; npoints >= 3; npoints--, points++, tri++)
    {
        tri->p1 = points[0];
        tri->p2 = points[1];
        tri->p3 = points[2];
    }
    CompositeTriangles (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, tris);
    free(tris);
}

void
CompositeTriFan (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		npoints,
		 xPointFixed	*points)
{
    xTriangle		*tris, *tri;
    xPointFixed		*first;
    int			ntri;
    
    if (npoints < 3)
	return;
    ntri = npoints - 2;
    tris = malloc(ntri * sizeof (xTriangle));
    if (!tris)
	return;
    first = points++;
    for (tri = tris; npoints >= 3; npoints--, points++, tri++)
    {
	tri->p1 = *first;
	tri->p2 = points[0];
	tri->p3 = points[1];
    }
    CompositeTriangles (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, tris);
    free(tris);
}

void
AddTraps (PicturePtr	pPicture,
	  INT16		xOff,
	  INT16		yOff,
	  int		ntrap,
	  xTrap		*traps)
{
    PictureScreenPtr	ps = GetPictureScreen(pPicture->pDrawable->pScreen);
    
    ValidatePicture (pPicture);
    (*ps->AddTraps) (pPicture, xOff, yOff, ntrap, traps);
}

/*
 *
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifndef _PICTURE_H_
#define _PICTURE_H_

#include "privates.h"

#include <pixman.h>

typedef struct _DirectFormat	*DirectFormatPtr;
typedef struct _PictFormat	*PictFormatPtr;
typedef struct _Picture		*PicturePtr;

/*
 * While the protocol is generous in format support, the
 * sample implementation allows only packed RGB and GBR
 * representations for data to simplify software rendering,
 */
#define PICT_FORMAT(bpp,type,a,r,g,b)	PIXMAN_FORMAT(bpp, type, a, r, g, b)

/*
 * gray/color formats use a visual index instead of argb
 */
#define PICT_VISFORMAT(bpp,type,vi)	(((bpp) << 24) |  \
					 ((type) << 16) | \
					 ((vi)))

#define PICT_FORMAT_BPP(f)	PIXMAN_FORMAT_BPP(f)
#define PICT_FORMAT_TYPE(f)	PIXMAN_FORMAT_TYPE(f)
#define PICT_FORMAT_A(f)	PIXMAN_FORMAT_A(f)
#define PICT_FORMAT_R(f)	PIXMAN_FORMAT_R(f)
#define PICT_FORMAT_G(f)	PIXMAN_FORMAT_G(f)
#define PICT_FORMAT_B(f)	PIXMAN_FORMAT_B(f)
#define PICT_FORMAT_RGB(f)	PIXMAN_FORMAT_RGB(f)
#define PICT_FORMAT_VIS(f)	PIXMAN_FORMAT_VIS(f)

#define PICT_TYPE_OTHER		PIXMAN_TYPE_OTHER
#define PICT_TYPE_A		PIXMAN_TYPE_A
#define PICT_TYPE_ARGB		PIXMAN_TYPE_ARGB
#define PICT_TYPE_ABGR		PIXMAN_TYPE_ABGR
#define PICT_TYPE_COLOR		PIXMAN_TYPE_COLOR
#define PICT_TYPE_GRAY		PIXMAN_TYPE_GRAY
#define PICT_TYPE_BGRA		PIXMAN_TYPE_BGRA

#define PICT_FORMAT_COLOR(f)	PIXMAN_FORMAT_COLOR(f)

/* 32bpp formats */
typedef enum _PictFormatShort {
    PICT_a2r10g10b10 =	PIXMAN_a2r10g10b10,
    PICT_x2r10g10b10 =	PIXMAN_x2r10g10b10,
    PICT_a2b10g10r10 =	PIXMAN_a2b10g10r10,
    PICT_x2b10g10r10 =	PIXMAN_x2b10g10r10,

    PICT_a8r8g8b8 =	PIXMAN_a8r8g8b8,
    PICT_x8r8g8b8 =	PIXMAN_x8r8g8b8,
    PICT_a8b8g8r8 =	PIXMAN_a8b8g8r8,
    PICT_x8b8g8r8 =	PIXMAN_x8b8g8r8,
    PICT_b8g8r8a8 =	PIXMAN_b8g8r8a8,
    PICT_b8g8r8x8 =	PIXMAN_b8g8r8x8,

/* 24bpp formats */
    PICT_r8g8b8 =	PIXMAN_r8g8b8,
    PICT_b8g8r8 =	PIXMAN_b8g8r8,

/* 16bpp formats */
    PICT_r5g6b5 =	PIXMAN_r5g6b5,
    PICT_b5g6r5 =	PIXMAN_b5g6r5,

    PICT_a1r5g5b5 =	PIXMAN_a1r5g5b5,
    PICT_x1r5g5b5 =	PIXMAN_x1r5g5b5,
    PICT_a1b5g5r5 =	PIXMAN_a1b5g5r5,
    PICT_x1b5g5r5 =	PIXMAN_x1b5g5r5,
    PICT_a4r4g4b4 =	PIXMAN_a4r4g4b4,
    PICT_x4r4g4b4 =	PIXMAN_x4r4g4b4,
    PICT_a4b4g4r4 =	PIXMAN_a4b4g4r4,
    PICT_x4b4g4r4 =	PIXMAN_x4b4g4r4,

/* 8bpp formats */
    PICT_a8 =		PIXMAN_a8,
    PICT_r3g3b2 =	PIXMAN_r3g3b2,
    PICT_b2g3r3 =	PIXMAN_b2g3r3,
    PICT_a2r2g2b2 =	PIXMAN_a2r2g2b2,
    PICT_a2b2g2r2 =	PIXMAN_a2b2g2r2,

    PICT_c8 =		PIXMAN_c8,
    PICT_g8 =		PIXMAN_g8,

    PICT_x4a4 =		PIXMAN_x4a4,
				    
    PICT_x4c4 =		PIXMAN_x4c4,
    PICT_x4g4 =		PIXMAN_x4g4,

/* 4bpp formats */
    PICT_a4 =		PIXMAN_a4,
    PICT_r1g2b1 =	PIXMAN_r1g2b1,
    PICT_b1g2r1 =	PIXMAN_b1g2r1,
    PICT_a1r1g1b1 =	PIXMAN_a1r1g1b1,
    PICT_a1b1g1r1 =	PIXMAN_a1b1g1r1,
				    
    PICT_c4 =		PIXMAN_c4,
    PICT_g4 =		PIXMAN_g4,

/* 1bpp formats */
    PICT_a1 =		PIXMAN_a1,

    PICT_g1 =		PIXMAN_g1
} PictFormatShort;

/*
 * For dynamic indexed visuals (GrayScale and PseudoColor), these control the 
 * selection of colors allocated for drawing to Pictures.  The default
 * policy depends on the size of the colormap:
 *
 * Size		Default Policy
 * ----------------------------
 *  < 64	PolicyMono
 *  < 256	PolicyGray
 *  256		PolicyColor (only on PseudoColor)
 *
 * The actual allocation code lives in miindex.c, and so is
 * austensibly server dependent, but that code does:
 *
 * PolicyMono	    Allocate no additional colors, use black and white
 * PolicyGray	    Allocate 13 gray levels (11 cells used)
 * PolicyColor	    Allocate a 4x4x4 cube and 13 gray levels (71 cells used)
 * PolicyAll	    Allocate as big a cube as possible, fill with gray (all)
 *
 * Here's a picture to help understand how many colors are
 * actually allocated (this is just the gray ramp):
 *
 *                 gray level
 * all   0000 1555 2aaa 4000 5555 6aaa 8000 9555 aaaa bfff d555 eaaa ffff
 * b/w   0000                                                        ffff
 * 4x4x4                     5555                aaaa
 * extra      1555 2aaa 4000      6aaa 8000 9555      bfff d555 eaaa
 *
 * The default colormap supplies two gray levels (black/white), the
 * 4x4x4 cube allocates another two and nine more are allocated to fill
 * in the 13 levels.  When the 4x4x4 cube is not allocated, a total of
 * 11 cells are allocated.
 */   

#define PictureCmapPolicyInvalid    -1
#define PictureCmapPolicyDefault    0
#define PictureCmapPolicyMono	    1
#define PictureCmapPolicyGray	    2
#define PictureCmapPolicyColor	    3
#define PictureCmapPolicyAll	    4

extern _X_EXPORT int PictureCmapPolicy;

extern _X_EXPORT int PictureParseCmapPolicy (const char *name);

extern _X_EXPORT int RenderErrBase;

/* Fixed point updates from Carl Worth, USC, Information Sciences Institute */

typedef pixman_fixed_32_32_t	xFixed_32_32;

typedef pixman_fixed_48_16_t	xFixed_48_16;

#define MAX_FIXED_48_16		pixman_max_fixed_48_16
#define MIN_FIXED_48_16		pixman_min_fixed_48_16

typedef pixman_fixed_1_31_t	xFixed_1_31;
typedef pixman_fixed_1_16_t	xFixed_1_16;
typedef pixman_fixed_16_16_t	xFixed_16_16;

/*
 * An unadorned "xFixed" is the same as xFixed_16_16, 
 * (since it's quite common in the code) 
 */
typedef	pixman_fixed_t	xFixed;
#define XFIXED_BITS	16

#define xFixedToInt(f)	pixman_fixed_to_int(f)
#define IntToxFixed(i)	pixman_int_to_fixed(i)
#define xFixedE		pixman_fixed_e
#define xFixed1		pixman_fixed_1
#define xFixed1MinusE	pixman_fixed_1_minus_e
#define xFixedFrac(f)	pixman_fixed_frac(f)
#define xFixedFloor(f)	pixman_fixed_floor(f)
#define xFixedCeil(f)	pixman_fixed_ceil(f)

#define xFixedFraction(f)	pixman_fixed_fraction(f)
#define xFixedMod2(f)		pixman_fixed_mod2(f)

/* whether 't' is a well defined not obviously empty trapezoid */
#define xTrapezoidValid(t)  ((t)->left.p1.y != (t)->left.p2.y && \
			     (t)->right.p1.y != (t)->right.p2.y && \
			     (int) ((t)->bottom - (t)->top) > 0)

/*
 * Standard NTSC luminance conversions:
 *
 *  y = r * 0.299 + g * 0.587 + b * 0.114
 *
 * Approximate this for a bit more speed:
 *
 *  y = (r * 153 + g * 301 + b * 58) / 512
 *
 * This gives 17 bits of luminance; to get 15 bits, lop the low two
 */

#define CvtR8G8B8toY15(s)	(((((s) >> 16) & 0xff) * 153 + \
				  (((s) >>  8) & 0xff) * 301 + \
				  (((s)      ) & 0xff) * 58) >> 2)

#endif /* _PICTURE_H_ */
/*
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifndef _PICTURESTR_H_
#define _PICTURESTR_H_

#include "scrnintstr.h"
#include "glyphstr.h"
#include "resource.h"
#include "privates.h"

typedef struct _DirectFormat {
    CARD16	    red, redMask;
    CARD16	    green, greenMask;
    CARD16	    blue, blueMask;
    CARD16	    alpha, alphaMask;
} DirectFormatRec;

typedef struct _IndexFormat {
    VisualID	    vid;
    ColormapPtr	    pColormap;
    int		    nvalues;
    xIndexValue	    *pValues;
    void	    *devPrivate;
} IndexFormatRec;

typedef struct _PictFormat {
    CARD32	    id;
    CARD32	    format;	    /* except bpp */
    unsigned char   type;
    unsigned char   depth;
    DirectFormatRec direct;
    IndexFormatRec  index;
} PictFormatRec;

typedef struct pixman_vector PictVector, *PictVectorPtr;
typedef struct pixman_transform PictTransform, *PictTransformPtr;

#define pict_f_vector pixman_f_vector
#define pict_f_transform pixman_f_transform

#define PICT_GRADIENT_STOPTABLE_SIZE 1024
#define SourcePictTypeSolidFill 0
#define SourcePictTypeLinear 1
#define SourcePictTypeRadial 2
#define SourcePictTypeConical 3

typedef struct _PictSolidFill {
    unsigned int type;
    CARD32 color;
} PictSolidFill, *PictSolidFillPtr;

typedef struct _PictGradientStop {
    xFixed x;
    xRenderColor color;
} PictGradientStop, *PictGradientStopPtr;

typedef struct _PictGradient {
    unsigned int type;
    int nstops;
    PictGradientStopPtr stops;
} PictGradient, *PictGradientPtr;

typedef struct _PictLinearGradient {
    unsigned int type;
    int nstops;
    PictGradientStopPtr stops;
    xPointFixed p1;
    xPointFixed p2;
} PictLinearGradient, *PictLinearGradientPtr;

typedef struct _PictCircle {
    xFixed x;
    xFixed y;
    xFixed radius;
} PictCircle, *PictCirclePtr;

typedef struct _PictRadialGradient {
    unsigned int type;
    int nstops;
    PictGradientStopPtr stops;
    PictCircle c1;
    PictCircle c2;
} PictRadialGradient, *PictRadialGradientPtr;

typedef struct _PictConicalGradient {
    unsigned int type;
    int nstops;
    PictGradientStopPtr stops;
    xPointFixed center;
    xFixed angle;
} PictConicalGradient, *PictConicalGradientPtr;

typedef union _SourcePict {
    unsigned int type;
    PictSolidFill solidFill;
    PictGradient gradient;
    PictLinearGradient linear;
    PictRadialGradient radial;
    PictConicalGradient conical;
} SourcePict, *SourcePictPtr;

typedef struct _Picture {
    DrawablePtr	    pDrawable;
    PictFormatPtr   pFormat;
    PictFormatShort format;	    /* PICT_FORMAT */
    int		    refcnt;
    CARD32	    id;
    unsigned int    repeat : 1;
    unsigned int    graphicsExposures : 1;
    unsigned int    subWindowMode : 1;
    unsigned int    polyEdge : 1;
    unsigned int    polyMode : 1;
    unsigned int    freeCompClip : 1;
    unsigned int    clientClipType : 2;
    unsigned int    componentAlpha : 1;
    unsigned int    repeatType : 2;
    unsigned int    filter : 3;
    unsigned int    stateChanges : CPLastBit;
    unsigned int    unused : 18 - CPLastBit;

    PicturePtr	    pNext;	    /* chain on same drawable */

    PicturePtr	    alphaMap;
    DDXPointRec	    alphaOrigin;

    DDXPointRec	    clipOrigin;
    pointer	    clientClip;

    unsigned long   serialNumber;

    RegionPtr	    pCompositeClip;

    PrivateRec	    *devPrivates;

    PictTransform   *transform;

    SourcePictPtr   pSourcePict;
    xFixed	    *filter_params;
    int		    filter_nparams;
} PictureRec;

typedef Bool (*PictFilterValidateParamsProcPtr) (ScreenPtr pScreen, int id,
						 xFixed *params, int nparams,
						 int *width, int *height);
typedef struct {
    char			    *name;
    int				    id;
    PictFilterValidateParamsProcPtr ValidateParams;
    int				    width, height;
} PictFilterRec, *PictFilterPtr;

#define PictFilterNearest	0
#define PictFilterBilinear	1

#define PictFilterFast		2
#define PictFilterGood		3
#define PictFilterBest		4

#define PictFilterConvolution	5
/* if you add an 8th filter, expand the filter bitfield above */

typedef struct {
    char	    *alias;
    int		    alias_id;
    int		    filter_id;
} PictFilterAliasRec, *PictFilterAliasPtr;

typedef int	(*CreatePictureProcPtr)	    (PicturePtr pPicture);
typedef void	(*DestroyPictureProcPtr)    (PicturePtr pPicture);
typedef int	(*ChangePictureClipProcPtr) (PicturePtr	pPicture,
					     int	clipType,
					     pointer    value,
					     int	n);
typedef void	(*DestroyPictureClipProcPtr)(PicturePtr	pPicture);

typedef int	(*ChangePictureTransformProcPtr)    (PicturePtr	    pPicture,
						     PictTransform  *transform);

typedef int	(*ChangePictureFilterProcPtr)	(PicturePtr	pPicture,
						 int		filter,
						 xFixed		*params,
						 int		nparams);

typedef void	(*DestroyPictureFilterProcPtr)	(PicturePtr pPicture);

typedef void	(*ChangePictureProcPtr)	    (PicturePtr pPicture,
					     Mask	mask);
typedef void	(*ValidatePictureProcPtr)    (PicturePtr pPicture,
					     Mask       mask);
typedef void	(*CompositeProcPtr)	    (CARD8	op,
					     PicturePtr pSrc,
					     PicturePtr pMask,
					     PicturePtr pDst,
					     INT16	xSrc,
					     INT16	ySrc,
					     INT16	xMask,
					     INT16	yMask,
					     INT16	xDst,
					     INT16	yDst,
					     CARD16	width,
					     CARD16	height);

typedef void	(*GlyphsProcPtr)	    (CARD8      op,
					     PicturePtr pSrc,
					     PicturePtr pDst,
					     PictFormatPtr  maskFormat,
					     INT16      xSrc,
					     INT16      ySrc,
					     int	nlists,
					     GlyphListPtr   lists,
					     GlyphPtr	*glyphs);

typedef void	(*CompositeRectsProcPtr)    (CARD8	    op,
					     PicturePtr	    pDst,
					     xRenderColor   *color,
					     int	    nRect,
					     xRectangle	    *rects);

typedef void	(*RasterizeTrapezoidProcPtr)(PicturePtr	    pMask,
					     xTrapezoid	    *trap,
					     int	    x_off,
					     int	    y_off);

typedef void	(*TrapezoidsProcPtr)	    (CARD8	    op,
					     PicturePtr	    pSrc,
					     PicturePtr	    pDst,
					     PictFormatPtr  maskFormat,
					     INT16	    xSrc,
					     INT16	    ySrc,
					     int	    ntrap,
					     xTrapezoid	    *traps);

typedef void	(*TrianglesProcPtr)	    (CARD8	    op,
					     PicturePtr	    pSrc,
					     PicturePtr	    pDst,
					     PictFormatPtr  maskFormat,
					     INT16	    xSrc,
					     INT16	    ySrc,
					     int	    ntri,
					     xTriangle	    *tris);

typedef Bool	(*InitIndexedProcPtr)	    (ScreenPtr	    pScreen,
					     PictFormatPtr  pFormat);

typedef void	(*CloseIndexedProcPtr)	    (ScreenPtr	    pScreen,
					     PictFormatPtr  pFormat);

typedef void	(*UpdateIndexedProcPtr)	    (ScreenPtr	    pScreen,
					     PictFormatPtr  pFormat,
					     int	    ndef,
					     xColorItem	    *pdef);

typedef void	(*AddTrapsProcPtr)	    (PicturePtr	    pPicture,
					     INT16	    xOff,
					     INT16	    yOff,
					     int	    ntrap,
					     xTrap	    *traps);

typedef void	(*AddTrianglesProcPtr)	    (PicturePtr	    pPicture,
					     INT16	    xOff,
					     INT16	    yOff,
					     int	    ntri,
					     xTriangle	    *tris);

typedef Bool	(*RealizeGlyphProcPtr)	    (ScreenPtr	    pScreen,
					     GlyphPtr	    glyph);

typedef void	(*UnrealizeGlyphProcPtr)    (ScreenPtr	    pScreen,
					     GlyphPtr	    glyph);

typedef struct _PictureScreen {
    PictFormatPtr		formats;
    PictFormatPtr		fallback;
    int				nformats;

    CreatePictureProcPtr	CreatePicture;
    DestroyPictureProcPtr	DestroyPicture;
    ChangePictureClipProcPtr	ChangePictureClip;
    DestroyPictureClipProcPtr	DestroyPictureClip;

    ChangePictureProcPtr	ChangePicture;
    ValidatePictureProcPtr	ValidatePicture;

    CompositeProcPtr		Composite;
    GlyphsProcPtr		Glyphs; /* unused */
    CompositeRectsProcPtr	CompositeRects;

    DestroyWindowProcPtr	DestroyWindow;
    CloseScreenProcPtr		CloseScreen;

    StoreColorsProcPtr		StoreColors;

    InitIndexedProcPtr		InitIndexed;
    CloseIndexedProcPtr		CloseIndexed;
    UpdateIndexedProcPtr	UpdateIndexed;

    int				subpixel;

    PictFilterPtr		filters;
    int				nfilters;
    PictFilterAliasPtr		filterAliases;
    int				nfilterAliases;

    /**
     * Called immediately after a picture's transform is changed through the
     * SetPictureTransform request.  Not called for source-only pictures.
     */
    ChangePictureTransformProcPtr   ChangePictureTransform;

    /**
     * Called immediately after a picture's transform is changed through the
     * SetPictureFilter request.  Not called for source-only pictures.
     */
    ChangePictureFilterProcPtr	ChangePictureFilter;

    DestroyPictureFilterProcPtr	DestroyPictureFilter;

    TrapezoidsProcPtr		Trapezoids;
    TrianglesProcPtr		Triangles;

    RasterizeTrapezoidProcPtr	RasterizeTrapezoid;

    AddTrianglesProcPtr		AddTriangles;

    AddTrapsProcPtr		AddTraps;

    RealizeGlyphProcPtr   	RealizeGlyph;
    UnrealizeGlyphProcPtr 	UnrealizeGlyph;

} PictureScreenRec, *PictureScreenPtr;

extern _X_EXPORT DevPrivateKeyRec PictureScreenPrivateKeyRec;
#define PictureScreenPrivateKey (&PictureScreenPrivateKeyRec)

extern _X_EXPORT DevPrivateKeyRec PictureWindowPrivateKeyRec;
#define	PictureWindowPrivateKey (&PictureWindowPrivateKeyRec)

extern _X_EXPORT RESTYPE	PictureType;
extern _X_EXPORT RESTYPE	PictFormatType;
extern _X_EXPORT RESTYPE	GlyphSetType;

#define GetPictureScreen(s) ((PictureScreenPtr)dixLookupPrivate(&(s)->devPrivates, PictureScreenPrivateKey))
#define GetPictureScreenIfSet(s) (dixPrivateKeyRegistered(PictureScreenPrivateKey) ? GetPictureScreen(s) : NULL)
#define SetPictureScreen(s,p) dixSetPrivate(&(s)->devPrivates, PictureScreenPrivateKey, p)
#define GetPictureWindow(w) ((PicturePtr)dixLookupPrivate(&(w)->devPrivates, PictureWindowPrivateKey))
#define SetPictureWindow(w,p) dixSetPrivate(&(w)->devPrivates, PictureWindowPrivateKey, p)

#define VERIFY_PICTURE(pPicture, pid, client, mode) {\
    int rc = dixLookupResourceByType((pointer)&(pPicture), pid,\
	                             PictureType, client, mode);\
    if (rc != Success)\
	return rc;\
}

#define VERIFY_ALPHA(pPicture, pid, client, mode) {\
    if (pid == None) \
	pPicture = 0; \
    else { \
	VERIFY_PICTURE(pPicture, pid, client, mode); \
    } \
} \

extern _X_EXPORT Bool
PictureDestroyWindow (WindowPtr pWindow);

extern _X_EXPORT Bool
PictureCloseScreen (int Index, ScreenPtr pScreen);

extern _X_EXPORT void
PictureStoreColors (ColormapPtr pColormap, int ndef, xColorItem *pdef);

extern _X_EXPORT Bool
PictureInitIndexedFormat (ScreenPtr pScreen, PictFormatPtr format);

extern _X_EXPORT Bool
PictureSetSubpixelOrder (ScreenPtr pScreen, int subpixel);

extern _X_EXPORT int
PictureGetSubpixelOrder (ScreenPtr pScreen);

extern _X_EXPORT PictFormatPtr
PictureCreateDefaultFormats (ScreenPtr pScreen, int *nformatp);

extern _X_EXPORT PictFormatPtr
PictureMatchVisual (ScreenPtr pScreen, int depth, VisualPtr pVisual);

extern _X_EXPORT PictFormatPtr
PictureMatchFormat (ScreenPtr pScreen, int depth, CARD32 format);

extern _X_EXPORT Bool
PictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats);

extern _X_EXPORT int
PictureGetFilterId (char *filter, int len, Bool makeit);

extern _X_EXPORT char *
PictureGetFilterName (int id);

extern _X_EXPORT int
PictureAddFilter (ScreenPtr			    pScreen,
		  char				    *filter,
		  PictFilterValidateParamsProcPtr   ValidateParams,
		  int				    width,
		  int				    height);

extern _X_EXPORT Bool
PictureSetFilterAlias (ScreenPtr pScreen, char *filter, char *alias);

extern _X_EXPORT Bool
PictureSetDefaultFilters (ScreenPtr pScreen);

extern _X_EXPORT void
PictureResetFilters (ScreenPtr pScreen);

extern _X_EXPORT PictFilterPtr
PictureFindFilter (ScreenPtr pScreen, char *name, int len);

extern _X_EXPORT int
SetPicturePictFilter (PicturePtr pPicture, PictFilterPtr pFilter,
		      xFixed *params, int nparams);

extern _X_EXPORT int
SetPictureFilter (PicturePtr pPicture, char *name, int len,
		  xFixed *params, int nparams);

extern _X_EXPORT Bool
PictureFinishInit (void);

extern _X_EXPORT void
SetPictureToDefaults (PicturePtr pPicture);

extern _X_EXPORT PicturePtr
CreatePicture (Picture		pid,
	       DrawablePtr	pDrawable,
	       PictFormatPtr	pFormat,
	       Mask		mask,
	       XID		*list,
	       ClientPtr	client,
	       int		*error);

extern _X_EXPORT int
ChangePicture (PicturePtr	pPicture,
	       Mask		vmask,
	       XID		*vlist,
	       DevUnion		*ulist,
	       ClientPtr	client);

extern _X_EXPORT int
SetPictureClipRects (PicturePtr	pPicture,
		     int	xOrigin,
		     int	yOrigin,
		     int	nRect,
		     xRectangle	*rects);

extern _X_EXPORT int
SetPictureClipRegion (PicturePtr    pPicture,
		      int	    xOrigin,
		      int	    yOrigin,
		      RegionPtr	    pRegion);

extern _X_EXPORT int
SetPictureTransform (PicturePtr	    pPicture,
		     PictTransform  *transform);

extern _X_EXPORT void
CopyPicture (PicturePtr	pSrc,
	     Mask	mask,
	     PicturePtr	pDst);

extern _X_EXPORT void
ValidatePicture(PicturePtr pPicture);

extern _X_EXPORT int
FreePicture (pointer	pPicture,
	     XID	pid);

extern _X_EXPORT int
FreePictFormat (pointer	pPictFormat,
		XID     pid);

extern _X_EXPORT void
CompositePicture (CARD8		op,
		  PicturePtr	pSrc,
		  PicturePtr	pMask,
		  PicturePtr	pDst,
		  INT16		xSrc,
		  INT16		ySrc,
		  INT16		xMask,
		  INT16		yMask,
		  INT16		xDst,
		  INT16		yDst,
		  CARD16	width,
		  CARD16	height);

extern _X_EXPORT void
CompositeGlyphs (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		nlist,
		 GlyphListPtr	lists,
		 GlyphPtr	*glyphs);

extern _X_EXPORT void
CompositeRects (CARD8		op,
		PicturePtr	pDst,
		xRenderColor	*color,
		int		nRect,
		xRectangle      *rects);

extern _X_EXPORT void
CompositeTrapezoids (CARD8	    op,
		     PicturePtr	    pSrc,
		     PicturePtr	    pDst,
		     PictFormatPtr  maskFormat,
		     INT16	    xSrc,
		     INT16	    ySrc,
		     int	    ntrap,
		     xTrapezoid	    *traps);

extern _X_EXPORT void
CompositeTriangles (CARD8	    op,
		    PicturePtr	    pSrc,
		    PicturePtr	    pDst,
		    PictFormatPtr   maskFormat,
		    INT16	    xSrc,
		    INT16	    ySrc,
		    int		    ntriangles,
		    xTriangle	    *triangles);

extern _X_EXPORT void
CompositeTriStrip (CARD8	    op,
		   PicturePtr	    pSrc,
		   PicturePtr	    pDst,
		   PictFormatPtr    maskFormat,
		   INT16	    xSrc,
		   INT16	    ySrc,
		   int		    npoints,
		   xPointFixed	    *points);

extern _X_EXPORT void
CompositeTriFan (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		npoints,
		 xPointFixed	*points);

extern _X_EXPORT void RenderExtensionInit (void);

Bool
AnimCurInit (ScreenPtr pScreen);

int
AnimCursorCreate (CursorPtr *cursors, CARD32 *deltas, int ncursor, CursorPtr *ppCursor, ClientPtr client, XID cid);

extern _X_EXPORT void
AddTraps (PicturePtr	pPicture,
	  INT16		xOff,
	  INT16		yOff,
	  int		ntraps,
	  xTrap		*traps);

extern _X_EXPORT PicturePtr
CreateSolidPicture (Picture pid,
                    xRenderColor *color,
                    int *error);

extern _X_EXPORT PicturePtr
CreateLinearGradientPicture (Picture pid,
                             xPointFixed *p1,
                             xPointFixed *p2,
                             int nStops,
                             xFixed *stops,
                             xRenderColor *colors,
                             int *error);

extern _X_EXPORT PicturePtr
CreateRadialGradientPicture (Picture pid,
                             xPointFixed *inner,
                             xPointFixed *outer,
                             xFixed innerRadius,
                             xFixed outerRadius,
                             int nStops,
                             xFixed *stops,
                             xRenderColor *colors,
                             int *error);

extern _X_EXPORT PicturePtr
CreateConicalGradientPicture (Picture pid,
                              xPointFixed *center,
                              xFixed angle,
                              int nStops,
                              xFixed *stops,
                              xRenderColor *colors,
                              int *error);

#ifdef PANORAMIX
extern _X_EXPORT void PanoramiXRenderInit (void);
extern _X_EXPORT void PanoramiXRenderReset (void);
#endif

/*
 * matrix.c
 */

extern _X_EXPORT void
PictTransform_from_xRenderTransform (PictTransformPtr pict,
				     xRenderTransform *render);

extern _X_EXPORT void
xRenderTransform_from_PictTransform (xRenderTransform *render,
				     PictTransformPtr pict);

extern _X_EXPORT Bool
PictureTransformPoint (PictTransformPtr transform,
		       PictVectorPtr	vector);

extern _X_EXPORT Bool
PictureTransformPoint3d (PictTransformPtr transform,
                         PictVectorPtr	vector);

#endif /* _PICTURESTR_H_ */
/*
 *
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "colormapst.h"
#include "extnsionst.h"
#include "servermd.h"
#include <X11/extensions/render.h>
#include <X11/extensions/renderproto.h>
#include "picturestr.h"
#include "glyphstr.h"
#include <X11/Xfuncproto.h>
#include "cursorstr.h"
#include "xace.h"
#include "protocol-versions.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

#if HAVE_STDINT_H
#include <stdint.h>
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif

static int ProcRenderQueryVersion (ClientPtr pClient);
static int ProcRenderQueryPictFormats (ClientPtr pClient);
static int ProcRenderQueryPictIndexValues (ClientPtr pClient);
static int ProcRenderQueryDithers (ClientPtr pClient);
static int ProcRenderCreatePicture (ClientPtr pClient);
static int ProcRenderChangePicture (ClientPtr pClient);
static int ProcRenderSetPictureClipRectangles (ClientPtr pClient);
static int ProcRenderFreePicture (ClientPtr pClient);
static int ProcRenderComposite (ClientPtr pClient);
static int ProcRenderScale (ClientPtr pClient);
static int ProcRenderTrapezoids (ClientPtr pClient);
static int ProcRenderTriangles (ClientPtr pClient);
static int ProcRenderTriStrip (ClientPtr pClient);
static int ProcRenderTriFan (ClientPtr pClient);
static int ProcRenderColorTrapezoids (ClientPtr pClient);
static int ProcRenderColorTriangles (ClientPtr pClient);
static int ProcRenderTransform (ClientPtr pClient);
static int ProcRenderCreateGlyphSet (ClientPtr pClient);
static int ProcRenderReferenceGlyphSet (ClientPtr pClient);
static int ProcRenderFreeGlyphSet (ClientPtr pClient);
static int ProcRenderAddGlyphs (ClientPtr pClient);
static int ProcRenderAddGlyphsFromPicture (ClientPtr pClient);
static int ProcRenderFreeGlyphs (ClientPtr pClient);
static int ProcRenderCompositeGlyphs (ClientPtr pClient);
static int ProcRenderFillRectangles (ClientPtr pClient);
static int ProcRenderCreateCursor (ClientPtr pClient);
static int ProcRenderSetPictureTransform (ClientPtr pClient);
static int ProcRenderQueryFilters (ClientPtr pClient);
static int ProcRenderSetPictureFilter (ClientPtr pClient);
static int ProcRenderCreateAnimCursor (ClientPtr pClient);
static int ProcRenderAddTraps (ClientPtr pClient);
static int ProcRenderCreateSolidFill (ClientPtr pClient);
static int ProcRenderCreateLinearGradient (ClientPtr pClient);
static int ProcRenderCreateRadialGradient (ClientPtr pClient);
static int ProcRenderCreateConicalGradient (ClientPtr pClient);

static int ProcRenderDispatch (ClientPtr pClient);

static int SProcRenderQueryVersion (ClientPtr pClient);
static int SProcRenderQueryPictFormats (ClientPtr pClient);
static int SProcRenderQueryPictIndexValues (ClientPtr pClient);
static int SProcRenderQueryDithers (ClientPtr pClient);
static int SProcRenderCreatePicture (ClientPtr pClient);
static int SProcRenderChangePicture (ClientPtr pClient);
static int SProcRenderSetPictureClipRectangles (ClientPtr pClient);
static int SProcRenderFreePicture (ClientPtr pClient);
static int SProcRenderComposite (ClientPtr pClient);
static int SProcRenderScale (ClientPtr pClient);
static int SProcRenderTrapezoids (ClientPtr pClient);
static int SProcRenderTriangles (ClientPtr pClient);
static int SProcRenderTriStrip (ClientPtr pClient);
static int SProcRenderTriFan (ClientPtr pClient);
static int SProcRenderColorTrapezoids (ClientPtr pClient);
static int SProcRenderColorTriangles (ClientPtr pClient);
static int SProcRenderTransform (ClientPtr pClient);
static int SProcRenderCreateGlyphSet (ClientPtr pClient);
static int SProcRenderReferenceGlyphSet (ClientPtr pClient);
static int SProcRenderFreeGlyphSet (ClientPtr pClient);
static int SProcRenderAddGlyphs (ClientPtr pClient);
static int SProcRenderAddGlyphsFromPicture (ClientPtr pClient);
static int SProcRenderFreeGlyphs (ClientPtr pClient);
static int SProcRenderCompositeGlyphs (ClientPtr pClient);
static int SProcRenderFillRectangles (ClientPtr pClient);
static int SProcRenderCreateCursor (ClientPtr pClient);
static int SProcRenderSetPictureTransform (ClientPtr pClient);
static int SProcRenderQueryFilters (ClientPtr pClient);
static int SProcRenderSetPictureFilter (ClientPtr pClient);
static int SProcRenderCreateAnimCursor (ClientPtr pClient);
static int SProcRenderAddTraps (ClientPtr pClient);
static int SProcRenderCreateSolidFill (ClientPtr pClient);
static int SProcRenderCreateLinearGradient (ClientPtr pClient);
static int SProcRenderCreateRadialGradient (ClientPtr pClient);
static int SProcRenderCreateConicalGradient (ClientPtr pClient);

static int SProcRenderDispatch (ClientPtr pClient);

int	(*ProcRenderVector[RenderNumberRequests])(ClientPtr) = {
    ProcRenderQueryVersion,
    ProcRenderQueryPictFormats,
    ProcRenderQueryPictIndexValues,
    ProcRenderQueryDithers,
    ProcRenderCreatePicture,
    ProcRenderChangePicture,
    ProcRenderSetPictureClipRectangles,
    ProcRenderFreePicture,
    ProcRenderComposite,
    ProcRenderScale,
    ProcRenderTrapezoids,
    ProcRenderTriangles,
    ProcRenderTriStrip,
    ProcRenderTriFan,
    ProcRenderColorTrapezoids,
    ProcRenderColorTriangles,
    ProcRenderTransform,
    ProcRenderCreateGlyphSet,
    ProcRenderReferenceGlyphSet,
    ProcRenderFreeGlyphSet,
    ProcRenderAddGlyphs,
    ProcRenderAddGlyphsFromPicture,
    ProcRenderFreeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderFillRectangles,
    ProcRenderCreateCursor,
    ProcRenderSetPictureTransform,
    ProcRenderQueryFilters,
    ProcRenderSetPictureFilter,
    ProcRenderCreateAnimCursor,
    ProcRenderAddTraps,
    ProcRenderCreateSolidFill,
    ProcRenderCreateLinearGradient,
    ProcRenderCreateRadialGradient,
    ProcRenderCreateConicalGradient
};

int	(*SProcRenderVector[RenderNumberRequests])(ClientPtr) = {
    SProcRenderQueryVersion,
    SProcRenderQueryPictFormats,
    SProcRenderQueryPictIndexValues,
    SProcRenderQueryDithers,
    SProcRenderCreatePicture,
    SProcRenderChangePicture,
    SProcRenderSetPictureClipRectangles,
    SProcRenderFreePicture,
    SProcRenderComposite,
    SProcRenderScale,
    SProcRenderTrapezoids,
    SProcRenderTriangles,
    SProcRenderTriStrip,
    SProcRenderTriFan,
    SProcRenderColorTrapezoids,
    SProcRenderColorTriangles,
    SProcRenderTransform,
    SProcRenderCreateGlyphSet,
    SProcRenderReferenceGlyphSet,
    SProcRenderFreeGlyphSet,
    SProcRenderAddGlyphs,
    SProcRenderAddGlyphsFromPicture,
    SProcRenderFreeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderFillRectangles,
    SProcRenderCreateCursor,
    SProcRenderSetPictureTransform,
    SProcRenderQueryFilters,
    SProcRenderSetPictureFilter,
    SProcRenderCreateAnimCursor,
    SProcRenderAddTraps,
    SProcRenderCreateSolidFill,
    SProcRenderCreateLinearGradient,
    SProcRenderCreateRadialGradient,
    SProcRenderCreateConicalGradient
};

int	RenderErrBase;
static DevPrivateKeyRec RenderClientPrivateKeyRec;
#define RenderClientPrivateKey (&RenderClientPrivateKeyRec )

typedef struct _RenderClient {
    int	    major_version;
    int	    minor_version;
} RenderClientRec, *RenderClientPtr;

#define GetRenderClient(pClient) ((RenderClientPtr)dixLookupPrivate(&(pClient)->devPrivates, RenderClientPrivateKey))

static void
RenderClientCallback (CallbackListPtr	*list,
		      pointer		closure,
		      pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    RenderClientPtr	pRenderClient = GetRenderClient (pClient);

    pRenderClient->major_version = 0;
    pRenderClient->minor_version = 0;
}

#ifdef PANORAMIX
RESTYPE	XRT_PICTURE;
#endif

void
RenderExtensionInit (void)
{
    ExtensionEntry *extEntry;

    if (!PictureType)
	return;
    if (!PictureFinishInit ())
	return;
    if (!dixRegisterPrivateKey(&RenderClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(RenderClientRec)))
	return;
    if (!AddCallback (&ClientStateCallback, RenderClientCallback, 0))
	return;

    extEntry = AddExtension (RENDER_NAME, 0, RenderNumberErrors,
			     ProcRenderDispatch, SProcRenderDispatch,
			     NULL, StandardMinorOpcode);
    if (!extEntry)
	return;
    RenderErrBase = extEntry->errorBase;
#ifdef PANORAMIX
    if (XRT_PICTURE)
	SetResourceTypeErrorValue(XRT_PICTURE, RenderErrBase + BadPicture);
#endif
    SetResourceTypeErrorValue(PictureType, RenderErrBase + BadPicture);
    SetResourceTypeErrorValue(PictFormatType, RenderErrBase + BadPictFormat);
    SetResourceTypeErrorValue(GlyphSetType, RenderErrBase + BadGlyphSet);
}

static int
ProcRenderQueryVersion (ClientPtr client)
{
    RenderClientPtr pRenderClient = GetRenderClient (client);
    xRenderQueryVersionReply rep;
    register int n;
    REQUEST(xRenderQueryVersionReq);

    pRenderClient->major_version = stuff->majorVersion;
    pRenderClient->minor_version = stuff->minorVersion;

    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);
    memset(&rep, 0, sizeof(xRenderQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if ((stuff->majorVersion * 1000 + stuff->minorVersion) <
        (SERVER_RENDER_MAJOR_VERSION * 1000 + SERVER_RENDER_MINOR_VERSION))
    {
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else
    {
	rep.majorVersion = SERVER_RENDER_MAJOR_VERSION;
	rep.minorVersion = SERVER_RENDER_MINOR_VERSION;
    }

    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xRenderQueryVersionReply), (char *)&rep);
    return Success;
}

static VisualPtr
findVisual (ScreenPtr pScreen, VisualID vid)
{
    VisualPtr	pVisual;
    int		v;

    for (v = 0; v < pScreen->numVisuals; v++)
    {
	pVisual = pScreen->visuals + v;
	if (pVisual->vid == vid)
	    return pVisual;
    }
    return 0;
}

static int
ProcRenderQueryPictFormats (ClientPtr client)
{
    RenderClientPtr		    pRenderClient = GetRenderClient (client);
    xRenderQueryPictFormatsReply    *reply;
    xPictScreen			    *pictScreen;
    xPictDepth			    *pictDepth;
    xPictVisual			    *pictVisual;
    xPictFormInfo		    *pictForm;
    CARD32			    *pictSubpixel;
    ScreenPtr			    pScreen;
    VisualPtr			    pVisual;
    DepthPtr			    pDepth;
    int				    v, d;
    PictureScreenPtr		    ps;
    PictFormatPtr		    pFormat;
    int				    nformat;
    int				    ndepth;
    int				    nvisual;
    int				    rlength;
    int				    s;
    int				    n;
    int				    numScreens;
    int				    numSubpixel;
/*    REQUEST(xRenderQueryPictFormatsReq); */

    REQUEST_SIZE_MATCH(xRenderQueryPictFormatsReq);

#ifdef PANORAMIX
    if (noPanoramiXExtension)
	numScreens = screenInfo.numScreens;
    else 
        numScreens = ((xConnSetup *)ConnectionInfo)->numRoots;
#else
    numScreens = screenInfo.numScreens;
#endif
    ndepth = nformat = nvisual = 0;
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	for (d = 0; d < pScreen->numDepths; d++)
	{
	    pDepth = pScreen->allowedDepths + d;
	    ++ndepth;

	    for (v = 0; v < pDepth->numVids; v++)
	    {
		pVisual = findVisual (pScreen, pDepth->vids[v]);
		if (pVisual && PictureMatchVisual (pScreen, pDepth->depth, pVisual))
		    ++nvisual;
	    }
	}
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    nformat += ps->nformats;
    }
    if (pRenderClient->major_version == 0 && pRenderClient->minor_version < 6)
	numSubpixel = 0;
    else
	numSubpixel = numScreens;
    
    rlength = (sizeof (xRenderQueryPictFormatsReply) +
	       nformat * sizeof (xPictFormInfo) +
	       numScreens * sizeof (xPictScreen) +
	       ndepth * sizeof (xPictDepth) +
	       nvisual * sizeof (xPictVisual) +
	       numSubpixel * sizeof (CARD32));
    reply = (xRenderQueryPictFormatsReply *) calloc(1, rlength);
    if (!reply)
	return BadAlloc;
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
    reply->numFormats = nformat;
    reply->numScreens = numScreens;
    reply->numDepths = ndepth;
    reply->numVisuals = nvisual;
    reply->numSubpixel = numSubpixel;
    
    pictForm = (xPictFormInfo *) (reply + 1);
    
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	{
	    for (nformat = 0, pFormat = ps->formats; 
		 nformat < ps->nformats;
		 nformat++, pFormat++)
	    {
		pictForm->id = pFormat->id;
		pictForm->type = pFormat->type;
		pictForm->depth = pFormat->depth;
		pictForm->direct.red = pFormat->direct.red;
		pictForm->direct.redMask = pFormat->direct.redMask;
		pictForm->direct.green = pFormat->direct.green;
		pictForm->direct.greenMask = pFormat->direct.greenMask;
		pictForm->direct.blue = pFormat->direct.blue;
		pictForm->direct.blueMask = pFormat->direct.blueMask;
		pictForm->direct.alpha = pFormat->direct.alpha;
		pictForm->direct.alphaMask = pFormat->direct.alphaMask;
		if (pFormat->type == PictTypeIndexed && pFormat->index.pColormap)
		    pictForm->colormap = pFormat->index.pColormap->mid;
		else
		    pictForm->colormap = None;
		if (client->swapped)
		{
		    swapl (&pictForm->id, n);
		    swaps (&pictForm->direct.red, n);
		    swaps (&pictForm->direct.redMask, n);
		    swaps (&pictForm->direct.green, n);
		    swaps (&pictForm->direct.greenMask, n);
		    swaps (&pictForm->direct.blue, n);
		    swaps (&pictForm->direct.blueMask, n);
		    swaps (&pictForm->direct.alpha, n);
		    swaps (&pictForm->direct.alphaMask, n);
		    swapl (&pictForm->colormap, n);
		}
		pictForm++;
	    }
	}
    }
    
    pictScreen = (xPictScreen *) pictForm;
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	pictDepth = (xPictDepth *) (pictScreen + 1);
	ndepth = 0;
	for (d = 0; d < pScreen->numDepths; d++)
	{
	    pictVisual = (xPictVisual *) (pictDepth + 1);
	    pDepth = pScreen->allowedDepths + d;

	    nvisual = 0;
	    for (v = 0; v < pDepth->numVids; v++)
	    {
		pVisual = findVisual (pScreen, pDepth->vids[v]);
		if (pVisual && (pFormat = PictureMatchVisual (pScreen, 
							      pDepth->depth, 
							      pVisual)))
		{
		    pictVisual->visual = pVisual->vid;
		    pictVisual->format = pFormat->id;
		    if (client->swapped)
		    {
			swapl (&pictVisual->visual, n);
			swapl (&pictVisual->format, n);
		    }
		    pictVisual++;
		    nvisual++;
		}
	    }
	    pictDepth->depth = pDepth->depth;
	    pictDepth->nPictVisuals = nvisual;
	    if (client->swapped)
	    {
		swaps (&pictDepth->nPictVisuals, n);
	    }
	    ndepth++;
	    pictDepth = (xPictDepth *) pictVisual;
	}
	pictScreen->nDepth = ndepth;
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    pictScreen->fallback = ps->fallback->id;
	else
	    pictScreen->fallback = 0;
	if (client->swapped)
	{
	    swapl (&pictScreen->nDepth, n);
	    swapl (&pictScreen->fallback, n);
	}
	pictScreen = (xPictScreen *) pictDepth;
    }
    pictSubpixel = (CARD32 *) pictScreen;
    
    for (s = 0; s < numSubpixel; s++)
    {
	pScreen = screenInfo.screens[s];
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    *pictSubpixel = ps->subpixel;
	else
	    *pictSubpixel = SubPixelUnknown;
	if (client->swapped)
	{
	    swapl (pictSubpixel, n);
	}
	++pictSubpixel;
    }
    
    if (client->swapped)
    {
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swapl (&reply->numFormats, n);
	swapl (&reply->numScreens, n);
	swapl (&reply->numDepths, n);
	swapl (&reply->numVisuals, n);
	swapl (&reply->numSubpixel, n);
    }
    WriteToClient(client, rlength, (char *) reply);
    free(reply);
    return Success;
}

static int
ProcRenderQueryPictIndexValues (ClientPtr client)
{
    PictFormatPtr   pFormat;
    int		    rc, num;
    int		    rlength;
    int		    i, n;
    REQUEST(xRenderQueryPictIndexValuesReq);
    xRenderQueryPictIndexValuesReply *reply;
    xIndexValue	    *values;

    REQUEST_AT_LEAST_SIZE(xRenderQueryPictIndexValuesReq);

    rc = dixLookupResourceByType((pointer *)&pFormat, stuff->format,
				 PictFormatType, client, DixReadAccess);
    if (rc != Success)
	return rc;

    if (pFormat->type != PictTypeIndexed)
    {
	client->errorValue = stuff->format;
	return BadMatch;
    }
    num = pFormat->index.nvalues;
    rlength = (sizeof (xRenderQueryPictIndexValuesReply) + 
	       num * sizeof(xIndexValue));
    reply = (xRenderQueryPictIndexValuesReply *) malloc(rlength);
    if (!reply)
	return BadAlloc;

    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
    reply->numIndexValues = num;

    values = (xIndexValue *) (reply + 1);
    
    memcpy (reply + 1, pFormat->index.pValues, num * sizeof (xIndexValue));
    
    if (client->swapped)
    {
	for (i = 0; i < num; i++)
	{
	    swapl (&values[i].pixel, n);
	    swaps (&values[i].red, n);
	    swaps (&values[i].green, n);
	    swaps (&values[i].blue, n);
	    swaps (&values[i].alpha, n);
	}
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swapl (&reply->numIndexValues, n);
    }

    WriteToClient(client, rlength, (char *) reply);
    free(reply);
    return Success;
}

static int
ProcRenderQueryDithers (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderCreatePicture (ClientPtr client)
{
    PicturePtr	    pPicture;
    DrawablePtr	    pDrawable;
    PictFormatPtr   pFormat;
    int		    len, error, rc;
    REQUEST(xRenderCreatePictureReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
			   DixReadAccess|DixAddAccess);
    if (rc != Success)
	return rc;

    rc = dixLookupResourceByType((pointer *)&pFormat, stuff->format,
				 PictFormatType, client, DixReadAccess);
    if (rc != Success)
	return rc;

    if (pFormat->depth != pDrawable->depth)
	return BadMatch;
    len = client->req_len - bytes_to_int32(sizeof(xRenderCreatePictureReq));
    if (Ones(stuff->mask) != len)
	return BadLength;
    
    pPicture = CreatePicture (stuff->pid,
			      pDrawable,
			      pFormat,
			      stuff->mask,
			      (XID *) (stuff + 1),
			      client,
			      &error);
    if (!pPicture)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}

static int
ProcRenderChangePicture (ClientPtr client)
{
    PicturePtr	    pPicture;
    REQUEST(xRenderChangePictureReq);
    int len;

    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);

    len = client->req_len - bytes_to_int32(sizeof(xRenderChangePictureReq));
    if (Ones(stuff->mask) != len)
	return BadLength;
    
    return ChangePicture (pPicture, stuff->mask, (XID *) (stuff + 1),
			  (DevUnion *) 0, client);
}

static int
ProcRenderSetPictureClipRectangles (ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    PicturePtr	    pPicture;
    int		    nr;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
    if (!pPicture->pDrawable)
        return BadDrawable;

    nr = (client->req_len << 2) - sizeof(xRenderSetPictureClipRectanglesReq);
    if (nr & 4)
	return BadLength;
    nr >>= 3;
    return SetPictureClipRects (pPicture,
				  stuff->xOrigin, stuff->yOrigin,
				  nr, (xRectangle *) &stuff[1]);
}

static int
ProcRenderFreePicture (ClientPtr client)
{
    PicturePtr	pPicture;
    REQUEST(xRenderFreePictureReq);

    REQUEST_SIZE_MATCH(xRenderFreePictureReq);

    VERIFY_PICTURE (pPicture, stuff->picture, client, DixDestroyAccess);
    FreeResource (stuff->picture, RT_NONE);
    return Success;
}

static Bool
PictOpValid (CARD8 op)
{
    if (/*PictOpMinimum <= op && */ op <= PictOpMaximum)
	return TRUE;
    if (PictOpDisjointMinimum <= op && op <= PictOpDisjointMaximum)
	return TRUE;
    if (PictOpConjointMinimum <= op && op <= PictOpConjointMaximum)
	return TRUE;
    if (PictOpBlendMinimum <= op && op <= PictOpBlendMaximum)
	return TRUE;
    return FALSE;
}

static int
ProcRenderComposite (ClientPtr client)
{
    PicturePtr	pSrc, pMask, pDst;
    REQUEST(xRenderCompositeReq);

    REQUEST_SIZE_MATCH(xRenderCompositeReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_ALPHA (pMask, stuff->mask, client, DixReadAccess);
    if ((pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen) ||
	(pMask && pMask->pDrawable && pDst->pDrawable->pScreen != pMask->pDrawable->pScreen))
	return BadMatch;
    CompositePicture (stuff->op,
		      pSrc,
		      pMask,
		      pDst,
		      stuff->xSrc,
		      stuff->ySrc,
		      stuff->xMask,
		      stuff->yMask,
		      stuff->xDst,
		      stuff->yDst,
		      stuff->width,
		      stuff->height);
    return Success;
}

static int
ProcRenderScale (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderTrapezoids (ClientPtr client)
{
    int		rc, ntraps;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
    REQUEST(xRenderTrapezoidsReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;
    ntraps = (client->req_len << 2) - sizeof (xRenderTrapezoidsReq);
    if (ntraps % sizeof (xTrapezoid))
	return BadLength;
    ntraps /= sizeof (xTrapezoid);
    if (ntraps)
	CompositeTrapezoids (stuff->op, pSrc, pDst, pFormat,
			     stuff->xSrc, stuff->ySrc,
			     ntraps, (xTrapezoid *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriangles (ClientPtr client)
{
    int		rc, ntris;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;
    ntris = (client->req_len << 2) - sizeof (xRenderTrianglesReq);
    if (ntris % sizeof (xTriangle))
	return BadLength;
    ntris /= sizeof (xTriangle);
    if (ntris)
	CompositeTriangles (stuff->op, pSrc, pDst, pFormat,
			    stuff->xSrc, stuff->ySrc,
			    ntris, (xTriangle *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriStrip (ClientPtr client)
{
    int		rc, npoints;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;
    npoints = ((client->req_len << 2) - sizeof (xRenderTriStripReq));
    if (npoints & 4)
	return BadLength;
    npoints >>= 3;
    if (npoints >= 3)
	CompositeTriStrip (stuff->op, pSrc, pDst, pFormat,
			   stuff->xSrc, stuff->ySrc,
			   npoints, (xPointFixed *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriFan (ClientPtr client)
{
    int		rc, npoints;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;
    npoints = ((client->req_len << 2) - sizeof (xRenderTriStripReq));
    if (npoints & 4)
	return BadLength;
    npoints >>= 3;
    if (npoints >= 3)
	CompositeTriFan (stuff->op, pSrc, pDst, pFormat,
			 stuff->xSrc, stuff->ySrc,
			 npoints, (xPointFixed *) &stuff[1]);
    return Success;
}

static int
ProcRenderColorTrapezoids (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderColorTriangles (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderTransform (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderCreateGlyphSet (ClientPtr client)
{
    GlyphSetPtr	    glyphSet;
    PictFormatPtr   format;
    int		    rc, f;
    REQUEST(xRenderCreateGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderCreateGlyphSetReq);

    LEGAL_NEW_RESOURCE(stuff->gsid, client);
    rc = dixLookupResourceByType((pointer *)&format, stuff->format,
				 PictFormatType, client, DixReadAccess);
    if (rc != Success)
	return rc;

    switch (format->depth) {
    case 1:
	f = GlyphFormat1;
	break;
    case 4:
	f = GlyphFormat4;
	break;
    case 8:
	f = GlyphFormat8;
	break;
    case 16:
	f = GlyphFormat16;
	break;
    case 32:
	f = GlyphFormat32;
	break;
    default:
	return BadMatch;
    }
    if (format->type != PictTypeDirect)
	return BadMatch;
    glyphSet = AllocateGlyphSet (f, format);
    if (!glyphSet)
	return BadAlloc;
    /* security creation/labeling check */
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->gsid, GlyphSetType,
		  glyphSet, RT_NONE, NULL, DixCreateAccess);
    if (rc != Success)
	return rc;
    if (!AddResource (stuff->gsid, GlyphSetType, (pointer)glyphSet))
	return BadAlloc;
    return Success;
}

static int
ProcRenderReferenceGlyphSet (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    int rc;
    REQUEST(xRenderReferenceGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderReferenceGlyphSetReq);

    LEGAL_NEW_RESOURCE(stuff->gsid, client);

    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->existing, GlyphSetType,
			   client, DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->existing;
	return rc;
    }
    glyphSet->refcnt++;
    if (!AddResource (stuff->gsid, GlyphSetType, (pointer)glyphSet))
	return BadAlloc;
    return Success;
}

#define NLOCALDELTA	64
#define NLOCALGLYPH	256

static int
ProcRenderFreeGlyphSet (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    int rc;
    REQUEST(xRenderFreeGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderFreeGlyphSetReq);
    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			   client, DixDestroyAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->glyphset;
	return rc;
    }
    FreeResource (stuff->glyphset, RT_NONE);
    return Success;
}

typedef struct _GlyphNew {
    Glyph	    id;
    GlyphPtr        glyph;
    Bool	    found;
    unsigned char   sha1[20];
} GlyphNewRec, *GlyphNewPtr;

#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)

static int
ProcRenderAddGlyphs (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    REQUEST(xRenderAddGlyphsReq);
    GlyphNewRec	    glyphsLocal[NLOCALGLYPH];
    GlyphNewPtr	    glyphsBase, glyphs, glyph_new;
    int		    remain, nglyphs;
    CARD32	    *gids;
    xGlyphInfo	    *gi;
    CARD8	    *bits;
    unsigned int    size;
    int		    err;
    int		    i, screen;
    PicturePtr	    pSrc = NULL, pDst = NULL;
    PixmapPtr	    pSrcPix = NULL, pDstPix = NULL;
    CARD32	    component_alpha;

    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);
    err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			    client, DixAddAccess);
    if (err != Success)
    {
	client->errorValue = stuff->glyphset;
	return err;
    }

    err = BadAlloc;
    nglyphs = stuff->nglyphs;
    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))
	    return BadAlloc;

    component_alpha = NeedsComponent (glyphSet->format->format);

    if (nglyphs <= NLOCALGLYPH) {
	memset (glyphsLocal, 0, sizeof (glyphsLocal));
	glyphsBase = glyphsLocal;
    }
    else
    {
	glyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));
	if (!glyphsBase)
	    return BadAlloc;
    }

    remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);

    glyphs = glyphsBase;

    gids = (CARD32 *) (stuff + 1);
    gi = (xGlyphInfo *) (gids + nglyphs);
    bits = (CARD8 *) (gi + nglyphs);
    remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;

    /* protect against bad nglyphs */
    if (gi < ((xGlyphInfo *)stuff) ||
        gi > ((xGlyphInfo *)((CARD32 *)stuff + client->req_len)) ||
        bits < ((CARD8 *)stuff) ||
        bits > ((CARD8 *)((CARD32 *)stuff + client->req_len))) {
        err = BadLength;
        goto bail;
    }

    for (i = 0; i < nglyphs; i++)
    {
	size_t padded_width;
	glyph_new = &glyphs[i];

	padded_width = PixmapBytePad (gi[i].width,
				      glyphSet->format->depth);

	if (gi[i].height && padded_width > (UINT32_MAX - sizeof(GlyphRec))/gi[i].height)
	    break;
	
	size = gi[i].height * padded_width;
	if (remain < size)
	    break;

	err = HashGlyph (&gi[i], bits, size, glyph_new->sha1);
	if (err)
	    goto bail;

	glyph_new->glyph = FindGlyphByHash (glyph_new->sha1,
					    glyphSet->fdepth);

	if (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)
	{
	    glyph_new->found = TRUE;
	}
	else
	{
	    GlyphPtr glyph;

	    glyph_new->found = FALSE;
	    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);
	    if (! glyph)
	    {
		err = BadAlloc;
		goto bail;
	    }

	    for (screen = 0; screen < screenInfo.numScreens; screen++)
	    {
		int	    width = gi[i].width;
		int	    height = gi[i].height;
		int	    depth = glyphSet->format->depth;
		ScreenPtr   pScreen;
		int	    error;

		/* Skip work if it's invisibly small anyway */
		if (!width || !height)
		    break;

		pScreen = screenInfo.screens[screen];
		pSrcPix = GetScratchPixmapHeader (pScreen,
						  width, height,
						  depth, depth,
						  -1, bits);
		if (! pSrcPix)
		{
		    err = BadAlloc;
		    goto bail;
		}

		pSrc = CreatePicture (0, &pSrcPix->drawable,
				      glyphSet->format, 0, NULL,
				      serverClient, &error);
		if (! pSrc)
		{
		    err = BadAlloc;
		    goto bail;
		}

		pDstPix = (pScreen->CreatePixmap) (pScreen,
						   width, height, depth,
						   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);

		if (!pDstPix)
		{
		    err = BadAlloc;
		    goto bail;
		}

		GlyphPicture (glyph)[screen] = pDst =
			CreatePicture (0, &pDstPix->drawable,
				       glyphSet->format,
				       CPComponentAlpha, &component_alpha,
				       serverClient, &error);

		/* The picture takes a reference to the pixmap, so we
		   drop ours. */
		(pScreen->DestroyPixmap) (pDstPix);
		pDstPix = NULL;

		if (! pDst)
		{
		    err = BadAlloc;
		    goto bail;
		}

		CompositePicture (PictOpSrc,
				  pSrc,
				  None,
				  pDst,
				  0, 0,
				  0, 0,
				  0, 0,
				  width, height);

		FreePicture ((pointer) pSrc, 0);
		pSrc = NULL;
		FreeScratchPixmapHeader (pSrcPix);
		pSrcPix = NULL;
	    }

	    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);
	}

	glyph_new->id = gids[i];
	
	if (size & 3)
	    size += 4 - (size & 3);
	bits += size;
	remain -= size;
    }
    if (remain || i < nglyphs)
    {
	err = BadLength;
	goto bail;
    }
    if (!ResizeGlyphSet (glyphSet, nglyphs))
    {
	err = BadAlloc;
	goto bail;
    }
    for (i = 0; i < nglyphs; i++)
	AddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);

    if (glyphsBase != glyphsLocal)
	free(glyphsBase);
    return Success;
bail:
    if (pSrc)
	FreePicture ((pointer) pSrc, 0);
    if (pSrcPix)
	FreeScratchPixmapHeader (pSrcPix);
    for (i = 0; i < nglyphs; i++)
	if (glyphs[i].glyph && ! glyphs[i].found)
	    free(glyphs[i].glyph);
    if (glyphsBase != glyphsLocal)
	free(glyphsBase);
    return err;
}

static int
ProcRenderAddGlyphsFromPicture (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderFreeGlyphs (ClientPtr client)
{
    REQUEST(xRenderFreeGlyphsReq);
    GlyphSetPtr     glyphSet;
    int		    rc, nglyph;
    CARD32	    *gids;
    CARD32	    glyph;

    REQUEST_AT_LEAST_SIZE(xRenderFreeGlyphsReq);
    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			   client, DixRemoveAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->glyphset;
	return rc;
    }
    nglyph = bytes_to_int32((client->req_len << 2) - sizeof (xRenderFreeGlyphsReq));
    gids = (CARD32 *) (stuff + 1);
    while (nglyph-- > 0)
    {
	glyph = *gids++;
	if (!DeleteGlyph (glyphSet, glyph))
	{
	    client->errorValue = glyph;
	    return RenderErrBase + BadGlyph;
	}
    }
    return Success;
}

static int
ProcRenderCompositeGlyphs (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    GlyphSet	    gs;
    PicturePtr      pSrc, pDst;
    PictFormatPtr   pFormat;
    GlyphListRec    listsLocal[NLOCALDELTA];
    GlyphListPtr    lists, listsBase;
    GlyphPtr	    glyphsLocal[NLOCALGLYPH];
    Glyph	    glyph;
    GlyphPtr	    *glyphs, *glyphsBase;
    xGlyphElt	    *elt;
    CARD8	    *buffer, *end;
    int		    nglyph;
    int		    nlist;
    int		    space;
    int		    size;
    int		    rc, n;
    
    REQUEST(xRenderCompositeGlyphsReq);

    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);

    switch (stuff->renderReqType) {
    default:			    size = 1; break;
    case X_RenderCompositeGlyphs16: size = 2; break;
    case X_RenderCompositeGlyphs32: size = 4; break;
    }
	    
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;

    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset,
				 GlyphSetType, client, DixUseAccess);
    if (rc != Success)
	return rc;

    buffer = (CARD8 *) (stuff + 1);
    end = (CARD8 *) stuff + (client->req_len << 2);
    nglyph = 0;
    nlist = 0;
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	if (elt->len == 0xff)
	{
	    buffer += 4;
	}
	else
	{
	    nlist++;
	    nglyph += elt->len;
	    space = size * elt->len;
	    if (space & 3)
		space += 4 - (space & 3);
	    buffer += space;
	}
    }
    if (nglyph <= NLOCALGLYPH)
	glyphsBase = glyphsLocal;
    else
    {
	glyphsBase = (GlyphPtr *) malloc(nglyph * sizeof (GlyphPtr));
	if (!glyphsBase)
	    return BadAlloc;
    }
    if (nlist <= NLOCALDELTA)
	listsBase = listsLocal;
    else
    {
	listsBase = (GlyphListPtr) malloc(nlist * sizeof (GlyphListRec));
	if (!listsBase) {
	    rc = BadAlloc;
	    goto bail;
	}
    }
    buffer = (CARD8 *) (stuff + 1);
    glyphs = glyphsBase;
    lists = listsBase;
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	if (elt->len == 0xff)
	{
	    if (buffer + sizeof (GlyphSet) < end)
	    {
                memcpy(&gs, buffer, sizeof(GlyphSet));
		rc = dixLookupResourceByType((pointer *)&glyphSet, gs,
					     GlyphSetType, client,
					     DixUseAccess);
		if (rc != Success)
		    goto bail;
	    }
	    buffer += 4;
	}
	else
	{
	    lists->xOff = elt->deltax;
	    lists->yOff = elt->deltay;
	    lists->format = glyphSet->format;
	    lists->len = 0;
	    n = elt->len;
	    while (n--)
	    {
		if (buffer + size <= end)
		{
		    switch (size) {
		    case 1:
			glyph = *((CARD8 *)buffer); break;
		    case 2:
			glyph = *((CARD16 *)buffer); break;
		    case 4:
		    default:
			glyph = *((CARD32 *)buffer); break;
		    }
		    if ((*glyphs = FindGlyph (glyphSet, glyph)))
		    {
			lists->len++;
			glyphs++;
		    }
		}
		buffer += size;
	    }
	    space = size * elt->len;
	    if (space & 3)
		buffer += 4 - (space & 3);
	    lists++;
	}
    }
    if (buffer > end) {
	rc = BadLength;
	goto bail;
    }

    CompositeGlyphs (stuff->op,
		     pSrc,
		     pDst,
		     pFormat,
		     stuff->xSrc,
		     stuff->ySrc,
		     nlist,
		     listsBase,
		     glyphsBase);
    rc = Success;

bail:
    if (glyphsBase != glyphsLocal)
	free(glyphsBase);
    if (listsBase != listsLocal)
	free(listsBase);
    return rc;
}

static int
ProcRenderFillRectangles (ClientPtr client)
{
    PicturePtr	    pDst;
    int             things;
    REQUEST(xRenderFillRectanglesReq);
    
    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    
    things = (client->req_len << 2) - sizeof(xRenderFillRectanglesReq);
    if (things & 4)
	return BadLength;
    things >>= 3;
    
    CompositeRects (stuff->op,
		    pDst,
		    &stuff->color,
		    things,
		    (xRectangle *) &stuff[1]);
    
    return Success;
}

static void
RenderSetBit (unsigned char *line, int x, int bit)
{
    unsigned char   mask;
    
    if (screenInfo.bitmapBitOrder == LSBFirst)
	mask = (1 << (x & 7));
    else
	mask = (0x80 >> (x & 7));
    /* XXX assumes byte order is host byte order */
    line += (x >> 3);
    if (bit)
	*line |= mask;
    else
	*line &= ~mask;
}

#define DITHER_DIM 2

static CARD32 orderedDither[DITHER_DIM][DITHER_DIM] = {
    {  1,  3,  },
    {  4,  2,  },
};

#define DITHER_SIZE  ((sizeof orderedDither / sizeof orderedDither[0][0]) + 1)

static int
ProcRenderCreateCursor (ClientPtr client)
{
    REQUEST(xRenderCreateCursorReq);
    PicturePtr	    pSrc;
    ScreenPtr	    pScreen;
    unsigned short  width, height;
    CARD32	    *argbbits, *argb;
    unsigned char   *srcbits, *srcline;
    unsigned char   *mskbits, *mskline;
    int		    stride;
    int		    x, y;
    int		    nbytes_mono;
    CursorMetricRec cm;
    CursorPtr	    pCursor;
    CARD32	    twocolor[3];
    int		    rc, ncolor;

    REQUEST_SIZE_MATCH (xRenderCreateCursorReq);
    LEGAL_NEW_RESOURCE(stuff->cid, client);
    
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    if (!pSrc->pDrawable)
        return BadDrawable;
    pScreen = pSrc->pDrawable->pScreen;
    width = pSrc->pDrawable->width;
    height = pSrc->pDrawable->height;
    if (height && width > UINT32_MAX/(height*sizeof(CARD32)))
	return BadAlloc;
    if ( stuff->x > width 
      || stuff->y > height )
	return BadMatch;
    argbbits = malloc(width * height * sizeof (CARD32));
    if (!argbbits)
	return BadAlloc;
    
    stride = BitmapBytePad(width);
    nbytes_mono = stride*height;
    srcbits = calloc(1, nbytes_mono);
    if (!srcbits)
    {
	free(argbbits);
	return BadAlloc;
    }
    mskbits = calloc(1, nbytes_mono);
    if (!mskbits)
    {
	free(argbbits);
	free(srcbits);
	return BadAlloc;
    }

    if (pSrc->format == PICT_a8r8g8b8)
    {
	(*pScreen->GetImage) (pSrc->pDrawable,
			      0, 0, width, height, ZPixmap,
			      0xffffffff, (pointer) argbbits);
    }
    else
    {
	PixmapPtr	pPixmap;
	PicturePtr	pPicture;
	PictFormatPtr	pFormat;
	int		error;

	pFormat = PictureMatchFormat (pScreen, 32, PICT_a8r8g8b8);
	if (!pFormat)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return BadImplementation;
	}
	pPixmap = (*pScreen->CreatePixmap) (pScreen, width, height, 32,
					    CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pPixmap)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return BadAlloc;
	}
	pPicture = CreatePicture (0, &pPixmap->drawable, pFormat, 0, 0, 
				  client, &error);
	if (!pPicture)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return error;
	}
	(*pScreen->DestroyPixmap) (pPixmap);
	CompositePicture (PictOpSrc,
			  pSrc, 0, pPicture,
			  0, 0, 0, 0, 0, 0, width, height);
	(*pScreen->GetImage) (pPicture->pDrawable,
			      0, 0, width, height, ZPixmap,
			      0xffffffff, (pointer) argbbits);
	FreePicture (pPicture, 0);
    }
    /*
     * Check whether the cursor can be directly supported by 
     * the core cursor code
     */
    ncolor = 0;
    argb = argbbits;
    for (y = 0; ncolor <= 2 && y < height; y++)
    {
	for (x = 0; ncolor <= 2 && x < width; x++)
	{
	    CARD32  p = *argb++;
	    CARD32  a = (p >> 24);

	    if (a == 0)	    /* transparent */
		continue;
	    if (a == 0xff)  /* opaque */
	    {
		int n;
		for (n = 0; n < ncolor; n++)
		    if (p == twocolor[n])
			break;
		if (n == ncolor)
		    twocolor[ncolor++] = p;
	    }
	    else
		ncolor = 3;
	}
    }
    
    /*
     * Convert argb image to two plane cursor
     */
    srcline = srcbits;
    mskline = mskbits;
    argb = argbbits;
    for (y = 0; y < height; y++)
    {
	for (x = 0; x < width; x++)
	{
	    CARD32  p = *argb++;

	    if (ncolor <= 2)
	    {
		CARD32	a = ((p >> 24));

		RenderSetBit (mskline, x, a != 0);
		RenderSetBit (srcline, x, a != 0 && p == twocolor[0]);
	    }
	    else
	    {
		CARD32	a = ((p >> 24) * DITHER_SIZE + 127) / 255;
		CARD32	i = ((CvtR8G8B8toY15(p) >> 7) * DITHER_SIZE + 127) / 255;
		CARD32	d = orderedDither[y&(DITHER_DIM-1)][x&(DITHER_DIM-1)];
		/* Set mask from dithered alpha value */
		RenderSetBit(mskline, x, a > d);
		/* Set src from dithered intensity value */
		RenderSetBit(srcline, x, a > d && i <= d);
	    }
	}
	srcline += stride;
	mskline += stride;
    }
    /*
     * Dither to white and black if the cursor has more than two colors
     */
    if (ncolor > 2)
    {
	twocolor[0] = 0xff000000;
	twocolor[1] = 0xffffffff;
    }
    else
    {
	free(argbbits);
	argbbits = 0;
    }
    
#define GetByte(p,s)	(((p) >> (s)) & 0xff)
#define GetColor(p,s)	(GetByte(p,s) | (GetByte(p,s) << 8))
    
    cm.width = width;
    cm.height = height;
    cm.xhot = stuff->x;
    cm.yhot = stuff->y;
    rc = AllocARGBCursor(srcbits, mskbits, argbbits, &cm,
			 GetColor(twocolor[0], 16),
			 GetColor(twocolor[0], 8),
			 GetColor(twocolor[0], 0),
			 GetColor(twocolor[1], 16),
			 GetColor(twocolor[1], 8),
			 GetColor(twocolor[1], 0),
			 &pCursor, client, stuff->cid);
    if (rc != Success)
	goto bail;
    if (!AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor)) {
	rc = BadAlloc;
	goto bail;
    }

    return Success;
bail:
    free(srcbits);
    free(mskbits);
    return rc;
}

static int
ProcRenderSetPictureTransform (ClientPtr client)
{
    REQUEST(xRenderSetPictureTransformReq);
    PicturePtr	pPicture;

    REQUEST_SIZE_MATCH(xRenderSetPictureTransformReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
    return SetPictureTransform (pPicture, (PictTransform *) &stuff->transform);
}

static int
ProcRenderQueryFilters (ClientPtr client)
{
    REQUEST (xRenderQueryFiltersReq);
    DrawablePtr			pDrawable;
    xRenderQueryFiltersReply	*reply;
    int				nbytesName;
    int				nnames;
    ScreenPtr			pScreen;
    PictureScreenPtr		ps;
    int				i, j, len, total_bytes, rc;
    INT16			*aliases;
    char			*names;

    REQUEST_SIZE_MATCH(xRenderQueryFiltersReq);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;
    
    pScreen = pDrawable->pScreen;
    nbytesName = 0;
    nnames = 0;
    ps = GetPictureScreenIfSet(pScreen);
    if (ps)
    {
	for (i = 0; i < ps->nfilters; i++)
	    nbytesName += 1 + strlen (ps->filters[i].name);
	for (i = 0; i < ps->nfilterAliases; i++)
	    nbytesName += 1 + strlen (ps->filterAliases[i].alias);
	nnames = ps->nfilters + ps->nfilterAliases;
    }
    len = ((nnames + 1) >> 1) + bytes_to_int32(nbytesName);
    total_bytes = sizeof (xRenderQueryFiltersReply) + (len << 2);
    reply = (xRenderQueryFiltersReply *) malloc(total_bytes);
    if (!reply)
	return BadAlloc;
    aliases = (INT16 *) (reply + 1);
    names = (char *) (aliases + ((nnames + 1) & ~1));
    
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = len;
    reply->numAliases = nnames;
    reply->numFilters = nnames;
    if (ps)
    {

	/* fill in alias values */
	for (i = 0; i < ps->nfilters; i++)
	    aliases[i] = FilterAliasNone;
	for (i = 0; i < ps->nfilterAliases; i++)
	{
	    for (j = 0; j < ps->nfilters; j++)
		if (ps->filterAliases[i].filter_id == ps->filters[j].id)
		    break;
	    if (j == ps->nfilters)
	    {
		for (j = 0; j < ps->nfilterAliases; j++)
		    if (ps->filterAliases[i].filter_id == 
			ps->filterAliases[j].alias_id)
		    {
			break;
		    }
		if (j == ps->nfilterAliases)
		    j = FilterAliasNone;
		else
		    j = j + ps->nfilters;
	    }
	    aliases[i + ps->nfilters] = j;
	}

	/* fill in filter names */
	for (i = 0; i < ps->nfilters; i++)
	{
	    j = strlen (ps->filters[i].name);
	    *names++ = j;
	    strncpy (names, ps->filters[i].name, j);
	    names += j;
	}
	
	/* fill in filter alias names */
	for (i = 0; i < ps->nfilterAliases; i++)
	{
	    j = strlen (ps->filterAliases[i].alias);
	    *names++ = j;
	    strncpy (names, ps->filterAliases[i].alias, j);
	    names += j;
	}
    }

    if (client->swapped)
    {
	register int n;

	for (i = 0; i < reply->numAliases; i++)
	{
	    swaps (&aliases[i], n);
	}
    	swaps(&reply->sequenceNumber, n);
    	swapl(&reply->length, n);
	swapl(&reply->numAliases, n);
	swapl(&reply->numFilters, n);
    }
    WriteToClient(client, total_bytes, (char *) reply);
    free(reply);
    
    return Success;
}

static int
ProcRenderSetPictureFilter (ClientPtr client)
{
    REQUEST (xRenderSetPictureFilterReq);
    PicturePtr	pPicture;
    int		result;
    xFixed	*params;
    int		nparams;
    char	*name;
    
    REQUEST_AT_LEAST_SIZE (xRenderSetPictureFilterReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
    name = (char *) (stuff + 1);
    params = (xFixed *) (name + pad_to_int32(stuff->nbytes));
    nparams = ((xFixed *) stuff + client->req_len) - params;
    result = SetPictureFilter (pPicture, name, stuff->nbytes, params, nparams);
    return result;
}

static int
ProcRenderCreateAnimCursor (ClientPtr client)
{
    REQUEST(xRenderCreateAnimCursorReq);
    CursorPtr	    *cursors;
    CARD32	    *deltas;
    CursorPtr	    pCursor;
    int		    ncursor;
    xAnimCursorElt  *elt;
    int		    i;
    int		    ret;

    REQUEST_AT_LEAST_SIZE(xRenderCreateAnimCursorReq);
    LEGAL_NEW_RESOURCE(stuff->cid, client);
    if (client->req_len & 1)
	return BadLength;
    ncursor = (client->req_len - (bytes_to_int32(sizeof(xRenderCreateAnimCursorReq)))) >> 1;
    cursors = malloc(ncursor * (sizeof (CursorPtr) + sizeof (CARD32)));
    if (!cursors)
	return BadAlloc;
    deltas = (CARD32 *) (cursors + ncursor);
    elt = (xAnimCursorElt *) (stuff + 1);
    for (i = 0; i < ncursor; i++)
    {
	ret = dixLookupResourceByType((pointer *)(cursors + i), elt->cursor,
				      RT_CURSOR, client, DixReadAccess);
	if (ret != Success)
	{
	    free(cursors);
	    return ret;
	}
	deltas[i] = elt->delay;
	elt++;
    }
    ret = AnimCursorCreate (cursors, deltas, ncursor, &pCursor, client,
			    stuff->cid);
    free(cursors);
    if (ret != Success)
	return ret;
    
    if (AddResource (stuff->cid, RT_CURSOR, (pointer)pCursor))
	return Success;
    return BadAlloc;
}

static int
ProcRenderAddTraps (ClientPtr client)
{
    int		ntraps;
    PicturePtr	pPicture;
    REQUEST(xRenderAddTrapsReq);

    REQUEST_AT_LEAST_SIZE(xRenderAddTrapsReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess);
    if (!pPicture->pDrawable)
        return BadDrawable;
    ntraps = (client->req_len << 2) - sizeof (xRenderAddTrapsReq);
    if (ntraps % sizeof (xTrap))
	return BadLength;
    ntraps /= sizeof (xTrap);
    if (ntraps)
	AddTraps (pPicture,
		  stuff->xOff, stuff->yOff,
		  ntraps, (xTrap *) &stuff[1]);
    return Success;
}

static int ProcRenderCreateSolidFill(ClientPtr client)
{
    PicturePtr	    pPicture;
    int		    error = 0;
    REQUEST(xRenderCreateSolidFillReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateSolidFillReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    pPicture = CreateSolidPicture(stuff->pid, &stuff->color, &error);
    if (!pPicture)
	return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
		     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}

static int ProcRenderCreateLinearGradient (ClientPtr client)
{
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
    REQUEST(xRenderCreateLinearGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateLinearGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateLinearGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);

    pPicture = CreateLinearGradientPicture (stuff->pid, &stuff->p1, &stuff->p2,
                                            stuff->nStops, stops, colors, &error);
    if (!pPicture)
	return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
		     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}

static int ProcRenderCreateRadialGradient (ClientPtr client)
{
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
    REQUEST(xRenderCreateRadialGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateRadialGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);

    pPicture = CreateRadialGradientPicture (stuff->pid, &stuff->inner, &stuff->outer,
                                            stuff->inner_radius, stuff->outer_radius,
                                            stuff->nStops, stops, colors, &error);
    if (!pPicture)
	return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
		     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}

static int ProcRenderCreateConicalGradient (ClientPtr client)
{
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
    REQUEST(xRenderCreateConicalGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);

    pPicture = CreateConicalGradientPicture (stuff->pid, &stuff->center, stuff->angle,
                                             stuff->nStops, stops, colors, &error);
    if (!pPicture)
	return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
		     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}


static int
ProcRenderDispatch (ClientPtr client)
{
    REQUEST(xReq);
    
    if (stuff->data < RenderNumberRequests)
	return (*ProcRenderVector[stuff->data]) (client);
    else
	return BadRequest;
}

static int
SProcRenderQueryVersion (ClientPtr client)
{
    register int n;
    REQUEST(xRenderQueryVersionReq);

    swaps(&stuff->length, n);
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
    return (*ProcRenderVector[stuff->renderReqType])(client);
}

static int
SProcRenderQueryPictFormats (ClientPtr client)
{
    register int n;
    REQUEST(xRenderQueryPictFormatsReq);
    swaps(&stuff->length, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryPictIndexValues (ClientPtr client)
{
    register int n;
    REQUEST(xRenderQueryPictIndexValuesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->format, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryDithers (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderCreatePicture (ClientPtr client)
{
    register int n;
    REQUEST(xRenderCreatePictureReq);
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->drawable, n);
    swapl(&stuff->format, n);
    swapl(&stuff->mask, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderChangePicture (ClientPtr client)
{
    register int n;
    REQUEST(xRenderChangePictureReq);
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swapl(&stuff->mask, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderSetPictureClipRectangles (ClientPtr client)
{
    register int n;
    REQUEST(xRenderSetPictureClipRectanglesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->xOrigin, n);
    swaps(&stuff->yOrigin, n);
    SwapRestS(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderFreePicture (ClientPtr client)
{
    register int n;
    REQUEST(xRenderFreePictureReq);
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderComposite (ClientPtr client)
{
    register int n;
    REQUEST(xRenderCompositeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->mask, n);
    swapl(&stuff->dst, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
    swaps(&stuff->xMask, n);
    swaps(&stuff->yMask, n);
    swaps(&stuff->xDst, n);
    swaps(&stuff->yDst, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderScale (ClientPtr client)
{
    register int n;
    REQUEST(xRenderScaleReq);
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->dst, n);
    swapl(&stuff->colorScale, n);
    swapl(&stuff->alphaScale, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
    swaps(&stuff->xDst, n);
    swaps(&stuff->yDst, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTrapezoids (ClientPtr client)
{
    register int n;
    REQUEST(xRenderTrapezoidsReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriangles (ClientPtr client)
{
    register int n;
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriStrip (ClientPtr client)
{
    register int n;
    REQUEST(xRenderTriStripReq);

    REQUEST_AT_LEAST_SIZE(xRenderTriStripReq);
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriFan (ClientPtr client)
{
    register int n;
    REQUEST(xRenderTriFanReq);

    REQUEST_AT_LEAST_SIZE(xRenderTriFanReq);
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderColorTrapezoids (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderColorTriangles (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderTransform (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderCreateGlyphSet (ClientPtr client)
{
    register int n;
    REQUEST(xRenderCreateGlyphSetReq);
    swaps(&stuff->length, n);
    swapl(&stuff->gsid, n);
    swapl(&stuff->format, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderReferenceGlyphSet (ClientPtr client)
{
    register int n;
    REQUEST(xRenderReferenceGlyphSetReq);
    swaps(&stuff->length, n);
    swapl(&stuff->gsid, n);
    swapl(&stuff->existing, n);
    return (*ProcRenderVector[stuff->renderReqType])  (client);
}

static int
SProcRenderFreeGlyphSet (ClientPtr client)
{
    register int n;
    REQUEST(xRenderFreeGlyphSetReq);
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddGlyphs (ClientPtr client)
{
    register int n;
    register int i;
    CARD32  *gids;
    void    *end;
    xGlyphInfo *gi;
    REQUEST(xRenderAddGlyphsReq);
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
    swapl(&stuff->nglyphs, n);
    if (stuff->nglyphs & 0xe0000000)
	return BadLength;
    end = (CARD8 *) stuff + (client->req_len << 2);
    gids = (CARD32 *) (stuff + 1);
    gi = (xGlyphInfo *) (gids + stuff->nglyphs);
    if ((char *) end - (char *) (gids + stuff->nglyphs) < 0)
	return BadLength;
    if ((char *) end - (char *) (gi + stuff->nglyphs) < 0)
	return BadLength;
    for (i = 0; i < stuff->nglyphs; i++)
    {
	swapl (&gids[i], n);
	swaps (&gi[i].width, n);
	swaps (&gi[i].height, n);
	swaps (&gi[i].x, n);
	swaps (&gi[i].y, n);
	swaps (&gi[i].xOff, n);
	swaps (&gi[i].yOff, n);
    }
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddGlyphsFromPicture (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderFreeGlyphs (ClientPtr client)
{
    register int n;
    REQUEST(xRenderFreeGlyphsReq);
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCompositeGlyphs (ClientPtr client)
{
    register int n;
    xGlyphElt	*elt;
    CARD8	*buffer;
    CARD8	*end;
    int		space;
    int		i;
    int		size;
    
    REQUEST(xRenderCompositeGlyphsReq);
    
    switch (stuff->renderReqType) {
    default:			    size = 1; break;
    case X_RenderCompositeGlyphs16: size = 2; break;
    case X_RenderCompositeGlyphs32: size = 4; break;
    }
	    
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->dst, n);
    swapl(&stuff->maskFormat, n);
    swapl(&stuff->glyphset, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
    buffer = (CARD8 *) (stuff + 1);
    end = (CARD8 *) stuff + (client->req_len << 2);
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	swaps (&elt->deltax, n);
	swaps (&elt->deltay, n);
	
	i = elt->len;
	if (i == 0xff)
	{
	    swapl (buffer, n);
	    buffer += 4;
	}
	else
	{
	    space = size * i;
	    switch (size) {
	    case 1:
		buffer += i;
		break;
	    case 2:
		while (i--)
		{
		    swaps (buffer, n);
		    buffer += 2;
		}
		break;
	    case 4:
		while (i--)
		{
		    swapl (buffer, n);
		    buffer += 4;
		}
		break;
	    }
	    if (space & 3)
		buffer += 4 - (space & 3);
	}
    }
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderFillRectangles (ClientPtr client)
{
    register int n;
    REQUEST(xRenderFillRectanglesReq);

    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->dst, n);
    swaps(&stuff->color.red, n);
    swaps(&stuff->color.green, n);
    swaps(&stuff->color.blue, n);
    swaps(&stuff->color.alpha, n);
    SwapRestS(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
    
static int
SProcRenderCreateCursor (ClientPtr client)
{
    register int n;
    REQUEST(xRenderCreateCursorReq);
    REQUEST_SIZE_MATCH (xRenderCreateCursorReq);
    
    swaps(&stuff->length, n);
    swapl(&stuff->cid, n);
    swapl(&stuff->src, n);
    swaps(&stuff->x, n);
    swaps(&stuff->y, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
    
static int
SProcRenderSetPictureTransform (ClientPtr client)
{
    register int n;
    REQUEST(xRenderSetPictureTransformReq);
    REQUEST_SIZE_MATCH(xRenderSetPictureTransformReq);

    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swapl(&stuff->transform.matrix11, n);
    swapl(&stuff->transform.matrix12, n);
    swapl(&stuff->transform.matrix13, n);
    swapl(&stuff->transform.matrix21, n);
    swapl(&stuff->transform.matrix22, n);
    swapl(&stuff->transform.matrix23, n);
    swapl(&stuff->transform.matrix31, n);
    swapl(&stuff->transform.matrix32, n);
    swapl(&stuff->transform.matrix33, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryFilters (ClientPtr client)
{
    register int n;
    REQUEST (xRenderQueryFiltersReq);
    REQUEST_SIZE_MATCH (xRenderQueryFiltersReq);

    swaps(&stuff->length, n);
    swapl(&stuff->drawable, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
    
static int
SProcRenderSetPictureFilter (ClientPtr client)
{
    register int n;
    REQUEST (xRenderSetPictureFilterReq);
    REQUEST_AT_LEAST_SIZE (xRenderSetPictureFilterReq);

    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->nbytes, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
    
static int
SProcRenderCreateAnimCursor (ClientPtr client)
{
    register int n;
    REQUEST (xRenderCreateAnimCursorReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateAnimCursorReq);

    swaps(&stuff->length, n);
    swapl(&stuff->cid, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddTraps (ClientPtr client)
{
    register int n;
    REQUEST (xRenderAddTrapsReq);
    REQUEST_AT_LEAST_SIZE (xRenderAddTrapsReq);

    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->xOff, n);
    swaps(&stuff->yOff, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateSolidFill(ClientPtr client)
{
    register int n;
    REQUEST (xRenderCreateSolidFillReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateSolidFillReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swaps(&stuff->color.alpha, n);
    swaps(&stuff->color.red, n);
    swaps(&stuff->color.green, n);
    swaps(&stuff->color.blue, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static void swapStops(void *stuff, int num)
{
    int i, n;
    CARD32 *stops;
    CARD16 *colors;
    stops = (CARD32 *)(stuff);
    for (i = 0; i < num; ++i) {
        swapl(stops, n);
        ++stops;
    }
    colors = (CARD16 *)(stops);
    for (i = 0; i < 4*num; ++i) {
        swaps(colors, n);
        ++colors;
    }
}

static int
SProcRenderCreateLinearGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateLinearGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateLinearGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->p1.x, n);
    swapl(&stuff->p1.y, n);
    swapl(&stuff->p2.x, n);
    swapl(&stuff->p2.y, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateLinearGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateConicalGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateConicalGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateConicalGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->center.x, n);
    swapl(&stuff->center.y, n);
    swapl(&stuff->angle, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderDispatch (ClientPtr client)
{
    REQUEST(xReq);
    
    if (stuff->data < RenderNumberRequests)
	return (*SProcRenderVector[stuff->data]) (client);
    else
	return BadRequest;
}

#ifdef PANORAMIX
#define VERIFY_XIN_PICTURE(pPicture, pid, client, mode) {\
    int rc = dixLookupResourceByType((pointer *)&(pPicture), pid,\
                                     XRT_PICTURE, client, mode);\
    if (rc != Success)\
	return rc;\
}

#define VERIFY_XIN_ALPHA(pPicture, pid, client, mode) {\
    if (pid == None) \
	pPicture = 0; \
    else { \
	VERIFY_XIN_PICTURE(pPicture, pid, client, mode); \
    } \
} \

int	    (*PanoramiXSaveRenderVector[RenderNumberRequests])(ClientPtr);

static int
PanoramiXRenderCreatePicture (ClientPtr client)
{
    REQUEST(xRenderCreatePictureReq);
    PanoramiXRes    *refDraw, *newPict;
    int		    result, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);
    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;
    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    
    if (refDraw->type == XRT_WINDOW &&
	stuff->drawable == screenInfo.screens[0]->root->drawable.id)
    {
	newPict->u.pict.root = TRUE;
    }
    else
	newPict->u.pict.root = FALSE;
    
    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	stuff->drawable = refDraw->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreatePicture]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else 
	free(newPict);

    return result;
}

static int
PanoramiXRenderChangePicture (ClientPtr client)
{
    PanoramiXRes    *pict;
    int		    result = Success, j;
    REQUEST(xRenderChangePictureReq);

    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);
    
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderChangePicture]) (client);
        if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureClipRectangles (ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int		    result = Success, j;
    PanoramiXRes    *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
    
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles]) (client);
        if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureTransform (ClientPtr client)
{
    REQUEST(xRenderSetPictureTransformReq);
    int		    result = Success, j;
    PanoramiXRes    *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureTransformReq);
    
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureTransform]) (client);
        if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureFilter (ClientPtr client)
{
    REQUEST(xRenderSetPictureFilterReq);
    int		    result = Success, j;
    PanoramiXRes    *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureFilterReq);
    
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureFilter]) (client);
        if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderFreePicture (ClientPtr client)
{
    PanoramiXRes *pict;
    int         result = Success, j;
    REQUEST(xRenderFreePictureReq);

    REQUEST_SIZE_MATCH(xRenderFreePictureReq);

    client->errorValue = stuff->picture;

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixDestroyAccess);
    

    FOR_NSCREENS_BACKWARD(j) {
	stuff->picture = pict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderFreePicture]) (client);
	if(result != Success) break;
    }

    /* Since ProcRenderFreePicture is using FreeResource, it will free
	our resource for us on the last pass through the loop above */
 
    return result;
}

static int
PanoramiXRenderComposite (ClientPtr client)
{
    PanoramiXRes	*src, *msk, *dst;
    int			result = Success, j;
    xRenderCompositeReq	orig;
    REQUEST(xRenderCompositeReq);

    REQUEST_SIZE_MATCH(xRenderCompositeReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_ALPHA (msk, stuff->mask, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);
    
    orig = *stuff;
    
    FOR_NSCREENS_FORWARD(j) {
	stuff->src = src->info[j].id;
	if (src->u.pict.root)
	{
	    stuff->xSrc = orig.xSrc - screenInfo.screens[j]->x;
	    stuff->ySrc = orig.ySrc - screenInfo.screens[j]->y;
	}
	stuff->dst = dst->info[j].id;
	if (dst->u.pict.root)
	{
	    stuff->xDst = orig.xDst - screenInfo.screens[j]->x;
	    stuff->yDst = orig.yDst - screenInfo.screens[j]->y;
	}
	if (msk)
	{
	    stuff->mask = msk->info[j].id;
	    if (msk->u.pict.root)
	    {
		stuff->xMask = orig.xMask - screenInfo.screens[j]->x;
		stuff->yMask = orig.yMask - screenInfo.screens[j]->y;
	    }
	}
	result = (*PanoramiXSaveRenderVector[X_RenderComposite]) (client);
	if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderCompositeGlyphs (ClientPtr client)
{
    PanoramiXRes    *src, *dst;
    int		    result = Success, j;
    REQUEST(xRenderCompositeGlyphsReq);
    xGlyphElt	    origElt, *elt;
    INT16	    xSrc, ySrc;

    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    if (client->req_len << 2 >= (sizeof (xRenderCompositeGlyphsReq) +
				 sizeof (xGlyphElt)))
    {
	elt = (xGlyphElt *) (stuff + 1);
	origElt = *elt;
	xSrc = stuff->xSrc;
	ySrc = stuff->ySrc;
	FOR_NSCREENS_FORWARD(j) {
	    stuff->src = src->info[j].id;
	    if (src->u.pict.root)
	    {
		stuff->xSrc = xSrc - screenInfo.screens[j]->x;
		stuff->ySrc = ySrc - screenInfo.screens[j]->y;
	    }
	    stuff->dst = dst->info[j].id;
	    if (dst->u.pict.root)
	    {
		elt->deltax = origElt.deltax - screenInfo.screens[j]->x;
		elt->deltay = origElt.deltay - screenInfo.screens[j]->y;
	    }
	    result = (*PanoramiXSaveRenderVector[stuff->renderReqType]) (client);
	    if(result != Success) break;
	}
    }

    return result;
}

static int
PanoramiXRenderFillRectangles (ClientPtr client)
{
    PanoramiXRes    *dst;
    int		    result = Success, j;
    REQUEST(xRenderFillRectanglesReq);
    char	    *extra;
    int		    extra_len;

    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);
    extra_len = (client->req_len << 2) - sizeof (xRenderFillRectanglesReq);
    if (extra_len &&
	(extra = (char *) malloc(extra_len)))
    {
	memcpy (extra, stuff + 1, extra_len);
	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root)
	    {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xRectangle	*rects = (xRectangle *) (stuff + 1);
		    int		i = extra_len / sizeof (xRectangle);

		    while (i--)
		    {
			rects->x -= x_off;
			rects->y -= y_off;
			rects++;
		    }
		}
	    }
	    stuff->dst = dst->info[j].id;
	    result = (*PanoramiXSaveRenderVector[X_RenderFillRectangles]) (client);
	    if(result != Success) break;
	}
	free(extra);
    }

    return result;
}

static int
PanoramiXRenderTrapezoids(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderTrapezoidsReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTrapezoidsReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTrapezoidsReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xTrapezoid  *trap = (xTrapezoid *) (stuff + 1);
		    int         i = extra_len / sizeof (xTrapezoid);

		    while (i--) {
			trap->top -= y_off;
			trap->bottom -= y_off;
			trap->left.p1.x -= x_off;
			trap->left.p1.y -= y_off;
			trap->left.p2.x -= x_off;
			trap->left.p2.y -= y_off;
			trap->right.p1.x -= x_off;
			trap->right.p1.y -= y_off;
			trap->right.p2.x -= x_off;
			trap->right.p2.y -= y_off;
			trap++;
		    }
		}
	    }
	    
            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTrapezoids]) (client);

	    if(result != Success) break;
	}
	
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriangles(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderTrianglesReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTrianglesReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTrianglesReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xTriangle  *tri = (xTriangle *) (stuff + 1);
		    int         i = extra_len / sizeof (xTriangle);

		    while (i--) {
			tri->p1.x -= x_off;
			tri->p1.y -= y_off;
			tri->p2.x -= x_off;
			tri->p2.y -= y_off;
			tri->p3.x -= x_off;
			tri->p3.y -= y_off;
			tri++;
		    }
		}
	    }
	    
            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriangles]) (client);

	    if(result != Success) break;
	}
	
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriStrip(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderTriStripReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTriStripReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTriStripReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xPointFixed  *fixed = (xPointFixed *) (stuff + 1);
		    int         i = extra_len / sizeof (xPointFixed);

		    while (i--) {
			fixed->x -= x_off;
			fixed->y -= y_off;
			fixed++;
		    }
		}
	    }
	    
            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriStrip]) (client);

	    if(result != Success) break;
	}
	
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriFan(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderTriFanReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTriFanReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTriFanReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xPointFixed  *fixed = (xPointFixed *) (stuff + 1);
		    int         i = extra_len / sizeof (xPointFixed);

		    while (i--) {
			fixed->x -= x_off;
			fixed->y -= y_off;
			fixed++;
		    }
		}
	    }
	    
            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriFan]) (client);

	    if(result != Success) break;
	}
	
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderAddTraps (ClientPtr client)
{
    PanoramiXRes    *picture;
    int		    result = Success, j;
    REQUEST(xRenderAddTrapsReq);
    char	    *extra;
    int		    extra_len;
    INT16    	    x_off, y_off;

    REQUEST_AT_LEAST_SIZE (xRenderAddTrapsReq);
    VERIFY_XIN_PICTURE (picture, stuff->picture, client, DixWriteAccess);
    extra_len = (client->req_len << 2) - sizeof (xRenderAddTrapsReq);
    if (extra_len &&
	(extra = (char *) malloc(extra_len)))
    {
	memcpy (extra, stuff + 1, extra_len);
	x_off = stuff->xOff;
	y_off = stuff->yOff;
	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    stuff->picture = picture->info[j].id;
	    
	    if (picture->u.pict.root)
	    {
		stuff->xOff = x_off + screenInfo.screens[j]->x;
		stuff->yOff = y_off + screenInfo.screens[j]->y;
	    }
	    result = (*PanoramiXSaveRenderVector[X_RenderAddTraps]) (client);
	    if(result != Success) break;
	}
	free(extra);
    }

    return result;
}

static int
PanoramiXRenderCreateSolidFill (ClientPtr client)
{
    REQUEST(xRenderCreateSolidFillReq);
    PanoramiXRes    *newPict;
    int		    result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateSolidFillReq);

    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;
	
    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateSolidFill]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
	free(newPict);

    return result;
}

static int
PanoramiXRenderCreateLinearGradient (ClientPtr client)
{
    REQUEST(xRenderCreateLinearGradientReq);
    PanoramiXRes    *newPict;
    int		    result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateLinearGradientReq);

    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateLinearGradient]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
	free(newPict);

    return result;
}

static int
PanoramiXRenderCreateRadialGradient (ClientPtr client)
{
    REQUEST(xRenderCreateRadialGradientReq);
    PanoramiXRes    *newPict;
    int		    result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateRadialGradientReq);

    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateRadialGradient]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
	free(newPict);

    return result;
}

static int
PanoramiXRenderCreateConicalGradient (ClientPtr client)
{
    REQUEST(xRenderCreateConicalGradientReq);
    PanoramiXRes    *newPict;
    int		    result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);

    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateConicalGradient]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
	free(newPict);

    return result;
}

void
PanoramiXRenderInit (void)
{
    int	    i;
    
    XRT_PICTURE = CreateNewResourceType (XineramaDeleteResource,
					 "XineramaPicture");
    if (RenderErrBase)
	SetResourceTypeErrorValue(XRT_PICTURE, RenderErrBase + BadPicture);
    for (i = 0; i < RenderNumberRequests; i++)
	PanoramiXSaveRenderVector[i] = ProcRenderVector[i];
    /*
     * Stuff in Xinerama aware request processing hooks
     */
    ProcRenderVector[X_RenderCreatePicture] = PanoramiXRenderCreatePicture;
    ProcRenderVector[X_RenderChangePicture] = PanoramiXRenderChangePicture;
    ProcRenderVector[X_RenderSetPictureTransform] = PanoramiXRenderSetPictureTransform;
    ProcRenderVector[X_RenderSetPictureFilter] = PanoramiXRenderSetPictureFilter;
    ProcRenderVector[X_RenderSetPictureClipRectangles] = PanoramiXRenderSetPictureClipRectangles;
    ProcRenderVector[X_RenderFreePicture] = PanoramiXRenderFreePicture;
    ProcRenderVector[X_RenderComposite] = PanoramiXRenderComposite;
    ProcRenderVector[X_RenderCompositeGlyphs8] = PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs16] = PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs32] = PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderFillRectangles] = PanoramiXRenderFillRectangles;

    ProcRenderVector[X_RenderTrapezoids] = PanoramiXRenderTrapezoids;
    ProcRenderVector[X_RenderTriangles] = PanoramiXRenderTriangles;
    ProcRenderVector[X_RenderTriStrip] = PanoramiXRenderTriStrip;
    ProcRenderVector[X_RenderTriFan] = PanoramiXRenderTriFan;
    ProcRenderVector[X_RenderAddTraps] = PanoramiXRenderAddTraps;

    ProcRenderVector[X_RenderCreateSolidFill] = PanoramiXRenderCreateSolidFill;
    ProcRenderVector[X_RenderCreateLinearGradient] = PanoramiXRenderCreateLinearGradient;
    ProcRenderVector[X_RenderCreateRadialGradient] = PanoramiXRenderCreateRadialGradient;
    ProcRenderVector[X_RenderCreateConicalGradient] = PanoramiXRenderCreateConicalGradient;
}

void
PanoramiXRenderReset (void)
{
    int	    i;
    for (i = 0; i < RenderNumberRequests; i++)
	ProcRenderVector[i] = PanoramiXSaveRenderVector[i];
    RenderErrBase = 0;
}

#endif	/* PANORAMIX */
xkb
input
xtest
list
misc
fixes
/**
 * Copyright © 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <X11/X.h>
#include <xfixesint.h>
#include <X11/extensions/xfixeswire.h>

static void
_fixes_test_direction(struct PointerBarrier *barrier, int d[4], int permitted)
{
    BOOL blocking;
    int i, j;
    int dir = barrier_get_direction(d[0], d[1], d[2], d[3]);

    barrier->directions = 0;
    blocking = barrier_is_blocking_direction(barrier, dir);
    assert(blocking);

    for (j = 0; j <= BarrierNegativeY; j++)
    {
        for (i = 0; i <= BarrierNegativeY; i++)
        {
            barrier->directions |= 1 << i;
            blocking = barrier_is_blocking_direction(barrier, dir);
            assert((barrier->directions & permitted) == permitted ? !blocking : blocking);
        }
    }

}

static void
fixes_pointer_barrier_direction_test(void)
{
    struct PointerBarrier barrier;

    int x = 100;
    int y = 100;

    int directions[8][4] = {
        { x, y, x, y + 100},            /* S  */
        { x + 50, y, x - 50, y + 100},  /* SW */
        { x + 100, y, x, y},            /* W  */
        { x + 100, y + 50, x, y - 50},  /* NW */
        { x, y + 100, x, y},            /* N  */
        { x - 50, y + 100, x + 50, y},  /* NE */
        { x, y, x + 100, y},            /* E  */
        { x, y - 50, x + 100, y + 50},  /* SE */
    };

    barrier.x1 = x;
    barrier.x2 = x;
    barrier.y1 = y - 50;
    barrier.y2 = y + 49;


    _fixes_test_direction(&barrier, directions[0], BarrierPositiveY);
    _fixes_test_direction(&barrier, directions[1], BarrierPositiveY | BarrierNegativeX);
    _fixes_test_direction(&barrier, directions[2], BarrierNegativeX);
    _fixes_test_direction(&barrier, directions[3], BarrierNegativeY | BarrierNegativeX);
    _fixes_test_direction(&barrier, directions[4], BarrierNegativeY);
    _fixes_test_direction(&barrier, directions[5], BarrierPositiveX | BarrierNegativeY);
    _fixes_test_direction(&barrier, directions[6], BarrierPositiveX);
    _fixes_test_direction(&barrier, directions[7], BarrierPositiveY | BarrierPositiveX);


}


static void
fixes_pointer_barriers_test(void)
{
    struct PointerBarrier barrier;
    int x1, y1, x2, y2;
    double distance;

    int x = 100;
    int y = 100;

    /* vert barrier */
    barrier.x1 = x;
    barrier.x2 = x;
    barrier.y1 = y - 50;
    barrier.y2 = y + 50;

    /* across at half-way */
    x1 = x + 1;
    x2 = x - 1;
    y1 = y;
    y2 = y;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));
    assert(distance == 1);

    /* definitely not across */
    x1 = x + 10;
    x2 = x + 5;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across, but outside of y range */
    x1 = x + 1;
    x2 = x -1;
    y1 = y + 100;
    y2 = y + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across, diagonally */
    x1 = x + 5;
    x2 = x - 5;
    y1 = y + 5;
    y2 = y - 5;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across but outside boundary, diagonally */
    x1 = x + 5;
    x2 = x - 5;
    y1 = y + 100;
    y2 = y + 50;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → blocking */
    x1 = x;
    x2 = x - 1;
    y1 = y;
    y2 = y;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → not blocking, positive */
    x1 = x;
    x2 = x + 1;
    y1 = y;
    y2 = y;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → not blocking, negative */
    x1 = x - 1;
    x2 = x - 2;
    y1 = y;
    y2 = y;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: endpoint of movement on barrier → blocking */
    x1 = x + 1;
    x2 = x;
    y1 = y;
    y2 = y;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* startpoint on barrier but outside y range */
    x1 = x;
    x2 = x - 1;
    y1 = y + 100;
    y2 = y + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* endpoint on barrier but outside y range */
    x1 = x + 1;
    x2 = x;
    y1 = y + 100;
    y2 = y + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));


    /* horizontal barrier */
    barrier.x1 = x - 50;
    barrier.x2 = x + 50;
    barrier.y1 = y;
    barrier.y2 = y;

    /* across at half-way */
    x1 = x;
    x2 = x;
    y1 = y - 1;
    y2 = y + 1;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* definitely not across */
    y1 = y + 10;
    y2 = y + 5;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across, but outside of y range */
    x1 = x + 100;
    x2 = x + 100;
    y1 = y + 1;
    y2 = y -1;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across, diagonally */
    y1 = y + 5;
    y2 = y - 5;
    x1 = x + 5;
    x2 = x - 5;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across but outside boundary, diagonally */
    y1 = y + 5;
    y2 = y - 5;
    x1 = x + 100;
    x2 = x + 50;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → blocking */
    y1 = y;
    y2 = y - 1;
    x1 = x;
    x2 = x;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → not blocking, positive */
    y1 = y;
    y2 = y + 1;
    x1 = x;
    x2 = x;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → not blocking, negative */
    y1 = y - 1;
    y2 = y - 2;
    x1 = x;
    x2 = x;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: endpoint of movement on barrier → blocking */
    y1 = y + 1;
    y2 = y;
    x1 = x;
    x2 = x;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* startpoint on barrier but outside y range */
    y1 = y;
    y2 = y - 1;
    x1 = x + 100;
    x2 = x + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* endpoint on barrier but outside y range */
    y1 = y + 1;
    y2 = y;
    x1 = x + 100;
    x2 = x + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

}

static void fixes_pointer_barrier_clamp_test(void)
{
    struct PointerBarrier barrier;

    int x = 100;
    int y = 100;

    int cx, cy; /* clamped */

    /* vert barrier */
    barrier.x1 = x;
    barrier.x2 = x;
    barrier.y1 = y - 50;
    barrier.y2 = y + 49;
    barrier.directions = 0;

    cx = INT_MAX;
    cy = INT_MAX;
    barrier_clamp_to_barrier(&barrier, BarrierPositiveX, &cx, &cy);
    assert(cx == barrier.x1 - 1);
    assert(cy == INT_MAX);

    cx = 0;
    cy = INT_MAX;
    barrier_clamp_to_barrier(&barrier, BarrierNegativeX, &cx, &cy);
    assert(cx == barrier.x1);
    assert(cy == INT_MAX);

    /* horiz barrier */
    barrier.x1 = x - 50;
    barrier.x2 = x + 49;
    barrier.y1 = y;
    barrier.y2 = y;
    barrier.directions = 0;

    cx = INT_MAX;
    cy = INT_MAX;
    barrier_clamp_to_barrier(&barrier, BarrierPositiveY, &cx, &cy);
    assert(cx == INT_MAX);
    assert(cy == barrier.y1 - 1);

    cx = INT_MAX;
    cy = 0;
    barrier_clamp_to_barrier(&barrier, BarrierNegativeY, &cx, &cy);
    assert(cx == INT_MAX);
    assert(cy == barrier.y1);
}

int main(int argc, char** argv)
{

    fixes_pointer_barriers_test();
    fixes_pointer_barrier_direction_test();
    fixes_pointer_barrier_clamp_test();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include <X11/X.h>
#include "misc.h"
#include "resource.h"
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/Xatom.h>
#include "windowstr.h"
#include "inputstr.h"
#include "eventconvert.h"
#include "exevents.h"
#include "exglobals.h"
#include "dixgrabs.h"
#include "eventstr.h"
#include "inpututils.h"
#include "assert.h"

/**
 * Init a device with axes.
 * Verify values set on the device.
 *
 * Result: All axes set to default values (usually 0).
 */
static void dix_init_valuators(void)
{
    DeviceIntRec dev;
    ValuatorClassPtr val;
    const int num_axes = 2;
    int i;
    Atom atoms[MAX_VALUATORS] = { 0 };


    memset(&dev, 0, sizeof(DeviceIntRec));
    dev.type = MASTER_POINTER; /* claim it's a master to stop ptracccel */

    assert(InitValuatorClassDeviceStruct(NULL, 0, atoms, 0, 0) == FALSE);
    assert(InitValuatorClassDeviceStruct(&dev, num_axes, atoms, 0, Absolute));

    val = dev.valuator;
    assert(val);
    assert(val->numAxes == num_axes);
    assert(val->numMotionEvents == 0);
    assert(val->axisVal);

    for (i = 0; i < num_axes; i++)
    {
        assert(val->axisVal[i] == 0);
        assert(val->axes->min_value == NO_AXIS_LIMITS);
        assert(val->axes->max_value == NO_AXIS_LIMITS);
        assert(val->axes->mode == Absolute);
    }

    assert(dev.last.numValuators == num_axes);
}

/* just check the known success cases, and that error cases set the client's
 * error value correctly. */
static void dix_check_grab_values(void)
{
    ClientRec client;
    GrabParameters param;
    int rc;

    memset(&client, 0, sizeof(client));

    param.grabtype = GRABTYPE_CORE;
    param.this_device_mode = GrabModeSync;
    param.other_devices_mode = GrabModeSync;
    param.modifiers = AnyModifier;
    param.ownerEvents = FALSE;

    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.this_device_mode = GrabModeAsync;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.this_device_mode = GrabModeAsync + 1;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.this_device_mode);
    assert(client.errorValue == GrabModeAsync + 1);

    param.this_device_mode = GrabModeSync;
    param.other_devices_mode = GrabModeAsync;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.other_devices_mode = GrabModeAsync + 1;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.other_devices_mode);
    assert(client.errorValue == GrabModeAsync + 1);

    param.other_devices_mode = GrabModeSync;

    param.modifiers = 1 << 13;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.modifiers);
    assert(client.errorValue == (1 << 13));


    param.modifiers = AnyModifier;
    param.ownerEvents = TRUE;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.ownerEvents = 3;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.ownerEvents);
    assert(client.errorValue == 3);
}


/**
 * Convert various internal events to the matching core event and verify the
 * parameters.
 */
static void dix_event_to_core(int type)
{
    DeviceEvent ev;
    xEvent *core;
    int time;
    int x, y;
    int rc;
    int state;
    int detail;
    int count;
    const int ROOT_WINDOW_ID = 0x100;

    /* EventToCore memsets the event to 0 */
#define test_event() \
    assert(rc == Success); \
    assert(core); \
    assert(count == 1); \
    assert(core->u.u.type == type); \
    assert(core->u.u.detail == detail); \
    assert(core->u.keyButtonPointer.time == time); \
    assert(core->u.keyButtonPointer.rootX == x); \
    assert(core->u.keyButtonPointer.rootY == y); \
    assert(core->u.keyButtonPointer.state == state); \
    assert(core->u.keyButtonPointer.eventX == 0); \
    assert(core->u.keyButtonPointer.eventY == 0); \
    assert(core->u.keyButtonPointer.root == ROOT_WINDOW_ID); \
    assert(core->u.keyButtonPointer.event == 0); \
    assert(core->u.keyButtonPointer.child == 0); \
    assert(core->u.keyButtonPointer.sameScreen == FALSE);

    x = 0;
    y = 0;
    time = 12345;
    state = 0;
    detail = 0;

    ev.header   = 0xFF;
    ev.length   = sizeof(DeviceEvent);
    ev.time     = time;
    ev.root_y   = x;
    ev.root_x   = y;
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    ev.root     = ROOT_WINDOW_ID;
    ev.corestate = state;
    ev.detail.key = detail;

    ev.type = type;
    ev.detail.key = 0;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    x = 1;
    y = 2;
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    x = 0x7FFF;
    y = 0x7FFF;
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    x = 0x8000; /* too high */
    y = 0x8000; /* too high */
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    assert(rc == Success);
    assert(core);
    assert(count == 1);
    assert(core->u.keyButtonPointer.rootX != x);
    assert(core->u.keyButtonPointer.rootY != y);

    x = 0x7FFF;
    y = 0x7FFF;
    ev.root_x = x;
    ev.root_y = y;
    time = 0;
    ev.time = time;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    detail = 1;
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    detail = 0xFF; /* highest value */
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    detail = 0xFFF; /* too big */
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    assert(rc == BadMatch);

    detail = 0xFF; /* too big */
    ev.detail.key = detail;
    state = 0xFFFF; /* highest value */
    ev.corestate = state;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    state = 0x10000; /* too big */
    ev.corestate = state;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    assert(rc == Success);
    assert(core);
    assert(count == 1);
    assert(core->u.keyButtonPointer.state != state);
    assert(core->u.keyButtonPointer.state == (state & 0xFFFF));

#undef test_event
}

static void dix_event_to_core_fail(int evtype, int expected_rc)
{
    DeviceEvent ev;
    xEvent *core;
    int rc;
    int count;

    ev.header   = 0xFF;
    ev.length   = sizeof(DeviceEvent);

    ev.type     = evtype;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    assert(rc == expected_rc);
}

static void dix_event_to_core_conversion(void)
{
    dix_event_to_core_fail(0, BadImplementation);
    dix_event_to_core_fail(1, BadImplementation);
    dix_event_to_core_fail(ET_ProximityOut + 1, BadImplementation);
    dix_event_to_core_fail(ET_ProximityIn, BadMatch);
    dix_event_to_core_fail(ET_ProximityOut, BadMatch);

    dix_event_to_core(ET_KeyPress);
    dix_event_to_core(ET_KeyRelease);
    dix_event_to_core(ET_ButtonPress);
    dix_event_to_core(ET_ButtonRelease);
    dix_event_to_core(ET_Motion);
}

static void
_dix_test_xi_convert(DeviceEvent *ev, int expected_rc, int expected_count)
{
    xEvent *xi;
    int count = 0;
    int rc;

    rc = EventToXI((InternalEvent*)ev, &xi, &count);
    assert(rc == expected_rc);
    assert(count >= expected_count);
    if (count > 0){
        deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer*)xi;
        assert(kbp->type == IEventBase + ev->type);
        assert(kbp->detail == ev->detail.key);
        assert(kbp->time == ev->time);
        assert((kbp->deviceid & ~MORE_EVENTS) == ev->deviceid);
        assert(kbp->root_x == ev->root_x);
        assert(kbp->root_y == ev->root_y);
        assert(kbp->state == ev->corestate);
        assert(kbp->event_x == 0);
        assert(kbp->event_y == 0);
        assert(kbp->root == ev->root);
        assert(kbp->event == 0);
        assert(kbp->child == 0);
        assert(kbp->same_screen == FALSE);

        while (--count > 0) {
            deviceValuator *v = (deviceValuator*)&xi[count];
            assert(v->type == DeviceValuator);
            assert(v->num_valuators <= 6);
        }


        free(xi);
    }
}

/**
 * This tests for internal event → XI1 event conversion
 * - all conversions should generate the right XI event type
 * - right number of events generated
 * - extra events are valuators
 */
static void dix_event_to_xi1_conversion(void)
{
    DeviceEvent ev = {0};
    int time;
    int x, y;
    int state;
    int detail;
    const int ROOT_WINDOW_ID = 0x100;
    int deviceid;

    IEventBase = 80;
    DeviceValuator      = IEventBase - 1;
    DeviceKeyPress      = IEventBase + ET_KeyPress;
    DeviceKeyRelease    = IEventBase + ET_KeyRelease;
    DeviceButtonPress   = IEventBase + ET_ButtonPress;
    DeviceButtonRelease = IEventBase + ET_ButtonRelease;
    DeviceMotionNotify  = IEventBase + ET_Motion;
    DeviceFocusIn       = IEventBase + ET_FocusIn;
    DeviceFocusOut      = IEventBase + ET_FocusOut;
    ProximityIn         = IEventBase + ET_ProximityIn;
    ProximityOut        = IEventBase + ET_ProximityOut;

    /* EventToXI callocs */
    x = 0;
    y = 0;
    time = 12345;
    state = 0;
    detail = 0;
    deviceid = 4;

    ev.header   = 0xFF;

    ev.header           = 0xFF;
    ev.length           = sizeof(DeviceEvent);
    ev.time             = time;
    ev.root_y           = x;
    ev.root_x           = y;
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    ev.root             = ROOT_WINDOW_ID;
    ev.corestate        = state;
    ev.detail.key       = detail;
    ev.deviceid         = deviceid;

    /* test all types for bad match */
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, Success, 1);

    /* No axes */
    ClearBit(ev.valuators.mask, 0);
    ClearBit(ev.valuators.mask, 1);
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, BadMatch, 0);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, BadMatch, 0);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, BadMatch, 0);

    /* more than 6 axes → 2 valuator events */
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    SetBit(ev.valuators.mask, 2);
    SetBit(ev.valuators.mask, 3);
    SetBit(ev.valuators.mask, 4);
    SetBit(ev.valuators.mask, 5);
    SetBit(ev.valuators.mask, 6);
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, Success, 2);


    /* keycode too high */
    ev.type = ET_KeyPress;
    ev.detail.key = 256;
    _dix_test_xi_convert(&ev, Success, 0);

    /* deviceid too high */
    ev.type = ET_KeyPress;
    ev.detail.key = 18;
    ev.deviceid = 128;
    _dix_test_xi_convert(&ev, Success, 0);
}


static void xi2_struct_sizes(void)
{
#define compare(req) \
    assert(sizeof(req) == sz_##req);

    compare(xXIQueryVersionReq);
    compare(xXIWarpPointerReq);
    compare(xXIChangeCursorReq);
    compare(xXIChangeHierarchyReq);
    compare(xXISetClientPointerReq);
    compare(xXIGetClientPointerReq);
    compare(xXISelectEventsReq);
    compare(xXIQueryVersionReq);
    compare(xXIQueryDeviceReq);
    compare(xXISetFocusReq);
    compare(xXIGetFocusReq);
    compare(xXIGrabDeviceReq);
    compare(xXIUngrabDeviceReq);
    compare(xXIAllowEventsReq);
    compare(xXIPassiveGrabDeviceReq);
    compare(xXIPassiveUngrabDeviceReq);
    compare(xXIListPropertiesReq);
    compare(xXIChangePropertyReq);
    compare(xXIDeletePropertyReq);
    compare(xXIGetPropertyReq);
    compare(xXIGetSelectedEventsReq);
#undef compare
}


static void dix_grab_matching(void)
{
    DeviceIntRec xi_all_devices, xi_all_master_devices, dev1, dev2;
    GrabRec a, b;
    BOOL rc;

    memset(&a, 0, sizeof(a));
    memset(&b, 0, sizeof(b));

    /* different grabtypes must fail */
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_XI2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XI2 grabs for different devices must fail, regardless of ignoreDevice
     * XI2 grabs for master devices must fail against a slave */
    memset(&xi_all_devices, 0, sizeof(DeviceIntRec));
    memset(&xi_all_master_devices, 0, sizeof(DeviceIntRec));
    memset(&dev1, 0, sizeof(DeviceIntRec));
    memset(&dev2, 0, sizeof(DeviceIntRec));

    xi_all_devices.id = XIAllDevices;
    xi_all_master_devices.id = XIAllMasterDevices;
    dev1.id = 10;
    dev1.type = SLAVE;
    dev2.id = 11;
    dev2.type = SLAVE;

    inputInfo.all_devices = &xi_all_devices;
    inputInfo.all_master_devices = &xi_all_master_devices;
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.device = &dev1;
    b.device = &dev2;

    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.device = &dev2;
    b.device = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.device = inputInfo.all_master_devices;
    b.device = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.device = &dev1;
    b.device = inputInfo.all_master_devices;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    /* ignoreDevice FALSE must fail for different devices for CORE and XI */
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.device = &dev1;
    b.device = &dev2;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.device = &dev1;
    b.device = &dev2;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    /* ignoreDevice FALSE must fail for different modifier devices for CORE
     * and XI */
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    /* different event type must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    /* different modifiers must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyPress;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* AnyModifier must fail for XI2 */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XIAnyModifier must fail for CORE and XI */
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* different detail must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = 1;
    b.detail.exact = 2;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* detail of AnyModifier must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = AnyModifier;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* detail of XIAnyModifier must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = XIAnyModifier;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XIAnyModifier or AnyModifer must succeed */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    /* AnyKey or XIAnyKeycode must succeed */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = XIAnyKeycode;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.detail.exact = AnyKey;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.detail.exact = AnyKey;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);
}

static void test_bits_to_byte(int i)
{
        int expected_bytes;
        expected_bytes = (i + 7)/8;

        assert(bits_to_bytes(i) >= i/8);
        assert((bits_to_bytes(i) * 8) - i <= 7);
        assert(expected_bytes == bits_to_bytes(i));
}

static void test_bytes_to_int32(int i)
{
        int expected_4byte;
        expected_4byte = (i + 3)/4;

        assert(bytes_to_int32(i) <= i);
        assert((bytes_to_int32(i) * 4) - i <= 3);
        assert(expected_4byte == bytes_to_int32(i));
}

static void test_pad_to_int32(int i)
{
        int expected_bytes;
        expected_bytes = ((i + 3)/4) * 4;

        assert(pad_to_int32(i) >= i);
        assert(pad_to_int32(i) - i <= 3);
        assert(expected_bytes == pad_to_int32(i));
}
static void include_byte_padding_macros(void)
{
    printf("Testing bits_to_bytes()\n");

    /* the macros don't provide overflow protection */
    test_bits_to_byte(0);
    test_bits_to_byte(1);
    test_bits_to_byte(2);
    test_bits_to_byte(7);
    test_bits_to_byte(8);
    test_bits_to_byte(0xFF);
    test_bits_to_byte(0x100);
    test_bits_to_byte(INT_MAX - 9);
    test_bits_to_byte(INT_MAX - 8);

    printf("Testing bytes_to_int32()\n");

    test_bytes_to_int32(0);
    test_bytes_to_int32(1);
    test_bytes_to_int32(2);
    test_bytes_to_int32(7);
    test_bytes_to_int32(8);
    test_bytes_to_int32(0xFF);
    test_bytes_to_int32(0x100);
    test_bytes_to_int32(0xFFFF);
    test_bytes_to_int32(0x10000);
    test_bytes_to_int32(0xFFFFFF);
    test_bytes_to_int32(0x1000000);
    test_bytes_to_int32(INT_MAX - 4);
    test_bytes_to_int32(INT_MAX - 3);

    printf("Testing pad_to_int32\n");

    test_pad_to_int32(0);
    test_pad_to_int32(0);
    test_pad_to_int32(1);
    test_pad_to_int32(2);
    test_pad_to_int32(7);
    test_pad_to_int32(8);
    test_pad_to_int32(0xFF);
    test_pad_to_int32(0x100);
    test_pad_to_int32(0xFFFF);
    test_pad_to_int32(0x10000);
    test_pad_to_int32(0xFFFFFF);
    test_pad_to_int32(0x1000000);
    test_pad_to_int32(INT_MAX - 4);
    test_pad_to_int32(INT_MAX - 3);
}

static void xi_unregister_handlers(void)
{
    DeviceIntRec dev;
    int handler;

    memset(&dev, 0, sizeof(dev));

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 1);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 2);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 3);

    printf("Unlinking from front.\n");

    XIUnregisterPropertyHandler(&dev, 4); /* NOOP */
    assert(dev.properties.handlers->id == 3);
    XIUnregisterPropertyHandler(&dev, 3);
    assert(dev.properties.handlers->id == 2);
    XIUnregisterPropertyHandler(&dev, 2);
    assert(dev.properties.handlers->id == 1);
    XIUnregisterPropertyHandler(&dev, 1);
    assert(dev.properties.handlers == NULL);

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 4);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 5);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 6);
    XIUnregisterPropertyHandler(&dev, 3); /* NOOP */
    assert(dev.properties.handlers->next->next->next == NULL);
    XIUnregisterPropertyHandler(&dev, 4);
    assert(dev.properties.handlers->next->next == NULL);
    XIUnregisterPropertyHandler(&dev, 5);
    assert(dev.properties.handlers->next == NULL);
    XIUnregisterPropertyHandler(&dev, 6);
    assert(dev.properties.handlers == NULL);

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 7);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 8);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 9);

    XIDeleteAllDeviceProperties(&dev);
    assert(dev.properties.handlers == NULL);
    XIUnregisterPropertyHandler(&dev, 7); /* NOOP */

}

static void cmp_attr_fields(InputAttributes *attr1,
                            InputAttributes *attr2)
{
    char **tags1, **tags2;

    assert(attr1 && attr2);
    assert(attr1 != attr2);
    assert(attr1->flags == attr2->flags);

    if (attr1->product != NULL)
    {
        assert(attr1->product != attr2->product);
        assert(strcmp(attr1->product, attr2->product) == 0);
    } else
        assert(attr2->product == NULL);

    if (attr1->vendor != NULL)
    {
        assert(attr1->vendor != attr2->vendor);
        assert(strcmp(attr1->vendor, attr2->vendor) == 0);
    } else
        assert(attr2->vendor == NULL);

    if (attr1->device != NULL)
    {
        assert(attr1->device != attr2->device);
        assert(strcmp(attr1->device, attr2->device) == 0);
    } else
        assert(attr2->device == NULL);

    if (attr1->pnp_id != NULL)
    {
        assert(attr1->pnp_id != attr2->pnp_id);
        assert(strcmp(attr1->pnp_id, attr2->pnp_id) == 0);
    } else
        assert(attr2->pnp_id == NULL);

    if (attr1->usb_id != NULL)
    {
        assert(attr1->usb_id != attr2->usb_id);
        assert(strcmp(attr1->usb_id, attr2->usb_id) == 0);
    } else
        assert(attr2->usb_id == NULL);

    tags1 = attr1->tags;
    tags2 = attr2->tags;

    /* if we don't have any tags, skip the tag checking bits */
    if (!tags1)
    {
        assert(!tags2);
        return;
    }

    /* Don't lug around empty arrays */
    assert(*tags1);
    assert(*tags2);

    /* check for identical content, but duplicated */
    while (*tags1)
    {
        assert(*tags1 != *tags2);
        assert(strcmp(*tags1, *tags2) == 0);
        tags1++;
        tags2++;
    }

    /* ensure tags1 and tags2 have the same no of elements */
    assert(!*tags2);

    /* check for not sharing memory */
    tags1 = attr1->tags;
    while (*tags1)
    {
        tags2 = attr2->tags;
        while (*tags2)
            assert(*tags1 != *tags2++);

        tags1++;
    }
}

static void dix_input_attributes(void)
{
    InputAttributes orig = {0};
    InputAttributes *new;
    char *tags[4] = {"tag1", "tag2", "tag2", NULL};

    new = DuplicateInputAttributes(NULL);
    assert(!new);

    new = DuplicateInputAttributes(&orig);
    assert(memcmp(&orig, new, sizeof(InputAttributes)) == 0);

    orig.product = "product name";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.vendor = "vendor name";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.device = "device path";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.pnp_id = "PnPID";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.usb_id = "USBID";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.flags = 0xF0;
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.tags = tags;
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);
}

static void dix_input_valuator_masks(void)
{
    ValuatorMask *mask = NULL, *copy;
    int nvaluators = MAX_VALUATORS;
    int valuators[nvaluators];
    int i;
    int first_val, num_vals;

    for (i = 0; i < nvaluators; i++)
        valuators[i] = i;

    mask = valuator_mask_new(nvaluators);
    assert(mask != NULL);
    assert(valuator_mask_size(mask) == 0);
    assert(valuator_mask_num_valuators(mask) == 0);

    for (i = 0; i < nvaluators; i++)
    {
        assert(!valuator_mask_isset(mask, i));
        valuator_mask_set(mask, i, valuators[i]);
        assert(valuator_mask_isset(mask, i));
        assert(valuator_mask_get(mask, i) == valuators[i]);
        assert(valuator_mask_size(mask) == i + 1);
        assert(valuator_mask_num_valuators(mask) == i + 1);
    }

    for (i = 0; i < nvaluators; i++)
    {
        assert(valuator_mask_isset(mask, i));
        valuator_mask_unset(mask, i);
        /* we're removing valuators from the front, so size should stay the
         * same until the last bit is removed */
        if (i < nvaluators - 1)
            assert(valuator_mask_size(mask) == nvaluators);
        assert(!valuator_mask_isset(mask, i));
    }

    assert(valuator_mask_size(mask) == 0);
    valuator_mask_zero(mask);
    assert(valuator_mask_size(mask) == 0);
    assert(valuator_mask_num_valuators(mask) == 0);
    for (i = 0; i < nvaluators; i++)
        assert(!valuator_mask_isset(mask, i));

    first_val = 5;
    num_vals = 6;

    valuator_mask_set_range(mask, first_val, num_vals, valuators);
    assert(valuator_mask_size(mask) == first_val + num_vals);
    assert(valuator_mask_num_valuators(mask) == num_vals);
    for (i = 0; i < nvaluators; i++)
    {
        if (i < first_val || i >= first_val + num_vals)
            assert(!valuator_mask_isset(mask, i));
        else
        {
            assert(valuator_mask_isset(mask, i));
            assert(valuator_mask_get(mask, i) == valuators[i - first_val]);
        }
    }

    copy = valuator_mask_new(nvaluators);
    valuator_mask_copy(copy, mask);
    assert(mask != copy);
    assert(valuator_mask_size(mask) == valuator_mask_size(copy));
    assert(valuator_mask_num_valuators(mask) == valuator_mask_num_valuators(copy));

    for (i = 0; i < nvaluators; i++)
    {
        assert(valuator_mask_isset(mask, i) == valuator_mask_isset(copy, i));
        assert(valuator_mask_get(mask, i) == valuator_mask_get(copy, i));
    }

    valuator_mask_free(&mask);
    assert(mask == NULL);
}

static void dix_valuator_mode(void)
{
    DeviceIntRec dev;
    const int num_axes = MAX_VALUATORS;
    int i;
    Atom atoms[MAX_VALUATORS] = { 0 };

    memset(&dev, 0, sizeof(DeviceIntRec));
    dev.type = MASTER_POINTER; /* claim it's a master to stop ptracccel */

    assert(InitValuatorClassDeviceStruct(NULL, 0, atoms, 0, 0) == FALSE);
    assert(InitValuatorClassDeviceStruct(&dev, num_axes, atoms, 0, Absolute));

    for (i = 0; i < num_axes; i++)
    {
        assert(valuator_get_mode(&dev, i) == Absolute);
        valuator_set_mode(&dev, i, Relative);
        assert(dev.valuator->axes[i].mode == Relative);
        assert(valuator_get_mode(&dev, i) == Relative);
    }

    valuator_set_mode(&dev, VALUATOR_MODE_ALL_AXES, Absolute);
    for (i = 0; i < num_axes; i++)
        assert(valuator_get_mode(&dev, i) == Absolute);

    valuator_set_mode(&dev, VALUATOR_MODE_ALL_AXES, Relative);
    for (i = 0; i < num_axes; i++)
        assert(valuator_get_mode(&dev, i) == Relative);
}

static void include_bit_test_macros(void)
{
    uint8_t mask[9] = { 0 };
    int i;

    for (i = 0; i < sizeof(mask)/sizeof(mask[0]); i++)
    {
        assert(BitIsOn(mask, i) == 0);
        SetBit(mask, i);
        assert(BitIsOn(mask, i) == 1);
        assert(!!(mask[i/8] & (1 << (i % 8))));
        assert(CountBits(mask, sizeof(mask)) == 1);
        ClearBit(mask, i);
        assert(BitIsOn(mask, i) == 0);
    }
}

/**
 * Ensure that val->axisVal and val->axes are aligned on doubles.
 */
static void dix_valuator_alloc(void)
{
    ValuatorClassPtr v = NULL;
    int num_axes = 0;

    while (num_axes < 5)
    {
        v = AllocValuatorClass(v, num_axes);

        assert(v);
        assert(v->numAxes == num_axes);
#if !defined(__i386__) && !defined(__sh__)
        /* must be double-aligned on 64 bit */
        assert(((void*)v->axisVal - (void*)v) % sizeof(double) == 0);
        assert(((void*)v->axes - (void*)v) % sizeof(double) == 0);
#endif
        num_axes ++;
    }

    free(v);
}

int main(int argc, char** argv)
{
    dix_input_valuator_masks();
    dix_input_attributes();
    dix_init_valuators();
    dix_event_to_core_conversion();
    dix_event_to_xi1_conversion();
    dix_check_grab_values();
    xi2_struct_sizes();
    dix_grab_matching();
    dix_valuator_mode();
    include_byte_padding_macros();
    include_bit_test_macros();
    xi_unregister_handlers();
    dix_valuator_alloc();

    return 0;
}
/**
 * Copyright © 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/Xlib.h>
#include <list.h>
#include <string.h>
#include <assert.h>

struct parent {
    int a;
    struct list children;
    int b;
};

struct child {
    int foo;
    int bar;
    struct list node;
};

static void
test_list_init(void)
{
    struct parent parent, tmp;

    memset(&parent, 0, sizeof(parent));
    parent.a = 0xa5a5a5;
    parent.b = ~0xa5a5a5;

    tmp = parent;

    list_init(&parent.children);

    /* test we haven't touched anything else. */
    assert(parent.a == tmp.a);
    assert(parent.b == tmp.b);

    assert(list_is_empty(&parent.children));
}

static void
test_list_add(void)
{
    struct parent parent = {0};
    struct child child[3];
    struct child *c;

    list_init(&parent.children);

    list_add(&child[0].node, &parent.children);
    assert(!list_is_empty(&parent.children));

    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[0], sizeof(struct child)) == 0);

    /* note: list_add prepends */
    list_add(&child[1].node, &parent.children);
    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[1], sizeof(struct child)) == 0);

    list_add(&child[2].node, &parent.children);
    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[2], sizeof(struct child)) == 0);
};

static void
test_list_del(void)
{
    struct parent parent = {0};
    struct child child[3];
    struct child *c;

    list_init(&parent.children);

    list_add(&child[0].node, &parent.children);
    assert(!list_is_empty(&parent.children));

    list_del(&parent.children);
    assert(list_is_empty(&parent.children));

    list_add(&child[0].node, &parent.children);
    list_del(&child[0].node);
    assert(list_is_empty(&parent.children));

    list_add(&child[0].node, &parent.children);
    list_add(&child[1].node, &parent.children);

    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[1], sizeof(struct child)) == 0);

    /* delete first node */
    list_del(&child[1].node);
    assert(!list_is_empty(&parent.children));
    assert(list_is_empty(&child[1].node));
    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[0], sizeof(struct child)) == 0);

    /* delete last node */
    list_add(&child[1].node, &parent.children);
    list_del(&child[0].node);
    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[1], sizeof(struct child)) == 0);

    /* delete list head */
    list_add(&child[0].node, &parent.children);
    list_del(&parent.children);
    assert(list_is_empty(&parent.children));
    assert(!list_is_empty(&child[1].node));
    assert(!list_is_empty(&child[2].node));
}

static void
test_list_for_each(void)
{
    struct parent parent = {0};
    struct child child[3];
    struct child *c;
    int i = 0;

    list_init(&parent.children);

    list_add(&child[2].node, &parent.children);
    list_add(&child[1].node, &parent.children);
    list_add(&child[0].node, &parent.children);

    list_for_each_entry(c, &parent.children, node) {
        assert(memcmp(c, &child[i], sizeof(struct child)) == 0);
        i++;
    }

    /* foreach on empty list */
    list_del(&parent.children);
    assert(list_is_empty(&parent.children));

    list_for_each_entry(c, &parent.children, node) {
        assert(0); /* we must not get here */
    }
}


int main(int argc, char** argv)
{
    test_list_init();
    test_list_add();
    test_list_del();
    test_list_for_each();

    return 0;
}
if ENABLE_UNIT_TESTS
if HAVE_LD_WRAP
SUBDIRS= . xi2
noinst_PROGRAMS = xkb input xtest list misc fixes
check_LTLIBRARIES = libxservertest.la

TESTS=$(noinst_PROGRAMS)

AM_CFLAGS = $(DIX_CFLAGS) @XORG_CFLAGS@
INCLUDES = $(XORG_INCS) -I$(top_srcdir)/hw/xfree86/parser \
	-I$(top_srcdir)/miext/cw -I$(top_srcdir)/hw/xfree86/ddc \
	-I$(top_srcdir)/hw/xfree86/i2c -I$(top_srcdir)/hw/xfree86/modes \
	-I$(top_srcdir)/hw/xfree86/ramdac
TEST_LDADD=libxservertest.la $(XORG_SYS_LIBS) $(XSERVER_SYS_LIBS)

if SPECIAL_DTRACE_OBJECTS
TEST_LDADD += $(OS_LIB) $(DIX_LIB)
endif

xkb_LDADD=$(TEST_LDADD)
input_LDADD=$(TEST_LDADD)
xtest_LDADD=$(TEST_LDADD)
list_LDADD=$(TEST_LDADD)
misc_LDADD=$(TEST_LDADD)
fixes_LDADD=$(TEST_LDADD)

nodist_libxservertest_la_SOURCES = $(top_builddir)/hw/xfree86/sdksyms.c
libxservertest_la_LIBADD = \
            $(XSERVER_LIBS) \
            $(top_builddir)/hw/xfree86/loader/libloader.la \
            $(top_builddir)/hw/xfree86/os-support/libxorgos.la \
            $(top_builddir)/hw/xfree86/common/libcommon.la \
            $(top_builddir)/hw/xfree86/parser/libxf86config_internal.la \
            $(top_builddir)/hw/xfree86/dixmods/libdixmods.la \
            $(top_builddir)/hw/xfree86/modes/libxf86modes.la \
            $(top_builddir)/hw/xfree86/ramdac/libramdac.la \
            $(top_builddir)/hw/xfree86/ddc/libddc.la \
            $(top_builddir)/hw/xfree86/i2c/libi2c.la \
            $(top_builddir)/hw/xfree86/dixmods/libxorgxkb.la \
            $(top_builddir)/mi/libmi.la \
            $(top_builddir)/os/libos.la \
            @XORG_LIBS@
libxservertest_la_DEPENDENCIES = $(libxservertest_la_LIBADD)
endif
endif
/**
 * Copyright © 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include "misc.h"

static void dix_version_compare(void)
{
    int rc;

    rc = version_compare(0, 0, 1, 0);
    assert(rc < 0);
    rc = version_compare(1, 0, 0, 0);
    assert(rc > 0);
    rc = version_compare(0, 0, 0, 0);
    assert(rc == 0);
    rc = version_compare(1, 0, 1, 0);
    assert(rc == 0);
    rc = version_compare(1, 0, 0, 9);
    assert(rc > 0);
    rc = version_compare(0, 9, 1, 0);
    assert(rc < 0);
    rc = version_compare(1, 0, 1, 9);
    assert(rc < 0);
    rc = version_compare(1, 9, 1, 0);
    assert(rc > 0);
    rc = version_compare(2, 0, 1, 9);
    assert(rc > 0);
    rc = version_compare(1, 9, 2, 0);
    assert(rc < 0);
}

int main(int argc, char** argv)
{
    dix_version_compare();

    return 0;
}
                        X server test suite

This suite contains a set of tests to verify the behaviour of functions used
internally to the server. This test suite is based on glib's testing
framework [1].

= How it works =
Through some automake abuse, we link the test programs with the same static
libraries as the Xorg binary. The test suites can then call various functions
and verify their behaviour - without the need to start the server or connect
clients.

This testing only works for functions that do not rely on a particular state
of the X server. Unless the test suite replicates the expected state, which
may be difficult.

= How to run the tests =
Run "make check" the test directory. This will compile the tests and execute
them in the order specified in the TESTS variable in test/Makefile.am.

Each set of tests related to a subsystem are available as a binary that can be
executed directly. For example, run "xkb" to perform some xkb-related tests.

== Adding a new test ==
When adding a new test, ensure that you add a short description of what the
test does and what the expected outcome is. If the test reproduces a
particular bug, using g_test_bug().

== Misc ==

The programs "gtester" and "gtester-report" may be used to generate XML/HTML
log files of tests succeeded and failed.

---------

[1] http://library.gnome.org/devel/glib/stable/glib-Testing.html
protocol-eventconvert
protocol-xigetclientpointer
protocol-xigetselectedevents
protocol-xipassivegrabdevice
protocol-xiquerydevice
protocol-xiquerypointer
protocol-xiqueryversion
protocol-xiselectevents
protocol-xisetclientpointer
protocol-xiwarppointer
if ENABLE_UNIT_TESTS
if HAVE_LD_WRAP
noinst_PROGRAMS =  \
	protocol-xiqueryversion \
	protocol-xiquerydevice \
	protocol-xiselectevents \
	protocol-xigetselectedevents \
        protocol-xisetclientpointer \
        protocol-xigetclientpointer \
        protocol-xipassivegrabdevice \
        protocol-xiquerypointer \
        protocol-xiwarppointer \
        protocol-eventconvert

TESTS=$(noinst_PROGRAMS)

AM_CFLAGS = $(DIX_CFLAGS) @XORG_CFLAGS@
INCLUDES = @XORG_INCS@
TEST_LDADD=../libxservertest.la $(XORG_SYS_LIBS) $(XSERVER_SYS_LIBS)
COMMON_SOURCES=protocol-common.h protocol-common.c

if SPECIAL_DTRACE_OBJECTS
TEST_LDADD += $(OS_LIB) $(DIX_LIB)
endif

protocol_xiqueryversion_LDADD=$(TEST_LDADD)
protocol_xiquerydevice_LDADD=$(TEST_LDADD)
protocol_xiselectevents_LDADD=$(TEST_LDADD)
protocol_xigetselectedevents_LDADD=$(TEST_LDADD)
protocol_xisetclientpointer_LDADD=$(TEST_LDADD)
protocol_xigetclientpointer_LDADD=$(TEST_LDADD)
protocol_xiquerypointer_LDADD=$(TEST_LDADD)
protocol_xipassivegrabdevice_LDADD=$(TEST_LDADD)
protocol_xiwarppointer_LDADD=$(TEST_LDADD)
protocol_eventconvert_LDADD=$(TEST_LDADD)

protocol_xiqueryversion_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient
protocol_xiquerydevice_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient
protocol_xiselectevents_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,dixLookupWindow -Wl,-wrap,XISetEventMask
protocol_xigetselectedevents_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient -Wl,-wrap,dixLookupWindow -Wl,-wrap,AddResource
protocol_xisetclientpointer_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,dixLookupClient
protocol_xigetclientpointer_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient -Wl,-wrap,dixLookupClient
protocol_xipassivegrabdevice_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,GrabButton -Wl,-wrap,dixLookupWindow -Wl,-wrap,WriteToClient
protocol_xiquerypointer_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient -Wl,-wrap,dixLookupWindow
protocol_xiwarppointer_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient -Wl,-wrap,dixLookupWindow

protocol_xiqueryversion_SOURCES=$(COMMON_SOURCES) protocol-xiqueryversion.c
protocol_xiquerydevice_SOURCES=$(COMMON_SOURCES) protocol-xiquerydevice.c
protocol_xiselectevents_SOURCES=$(COMMON_SOURCES) protocol-xiselectevents.c
protocol_xigetselectedevents_SOURCES=$(COMMON_SOURCES) protocol-xigetselectedevents.c
protocol_xisetclientpointer_SOURCES=$(COMMON_SOURCES) protocol-xisetclientpointer.c
protocol_xigetclientpointer_SOURCES=$(COMMON_SOURCES) protocol-xigetclientpointer.c
protocol_xiquerypointer_SOURCES=$(COMMON_SOURCES) protocol-xiquerypointer.c
protocol_xipassivegrabdevice_SOURCES=$(COMMON_SOURCES) protocol-xipassivegrabdevice.c
protocol_xiwarppointer_SOURCES=$(COMMON_SOURCES) protocol-xiwarppointer.c
endif
endif
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include "extinit.h" /* for XInputExtensionInit */
#include "exglobals.h"
#include "xkbsrv.h" /* for XkbInitPrivates */

#include "protocol-common.h"

struct devices devices;
ScreenRec screen;
WindowRec root;
WindowRec window;

void *userdata;

extern int CorePointerProc(DeviceIntPtr pDev, int what);
extern int CoreKeyboardProc(DeviceIntPtr pDev, int what);

static void fake_init_sprite(DeviceIntPtr dev)
{
    SpritePtr sprite;
    sprite = dev->spriteInfo->sprite;

    sprite->spriteTraceSize = 10;
    sprite->spriteTrace = calloc(sprite->spriteTraceSize, sizeof(WindowPtr));
    sprite->spriteTraceGood = 1;
    sprite->spriteTrace[0] = &root;
    sprite->hot.x = SPRITE_X;
    sprite->hot.y = SPRITE_Y;
    sprite->hotPhys.x = sprite->hot.x;
    sprite->hotPhys.y = sprite->hot.y;
    sprite->win = &window;
    sprite->hotPhys.pScreen = &screen;
    sprite->physLimits.x1 = 0;
    sprite->physLimits.y1 = 0;
    sprite->physLimits.x2 = screen.width;
    sprite->physLimits.y2 = screen.height;
}

/**
 * Create and init 2 master devices (VCP + VCK) and two slave devices, one
 * default mouse, one default keyboard.
 */
struct devices init_devices(void)
{
    ClientRec client;
    struct devices devices;

    client = init_client(0, NULL);

    AllocDevicePair(&client, "Virtual core", &devices.vcp, &devices.vck,
                    CorePointerProc, CoreKeyboardProc, TRUE);
    inputInfo.pointer = devices.vcp;
    inputInfo.keyboard = devices.vck;
    ActivateDevice(devices.vcp, FALSE);
    ActivateDevice(devices.vck, FALSE);
    EnableDevice(devices.vcp, FALSE);
    EnableDevice(devices.vck, FALSE);

    AllocDevicePair(&client, "", &devices.mouse, &devices.kbd,
                    CorePointerProc, CoreKeyboardProc, FALSE);
    ActivateDevice(devices.mouse, FALSE);
    ActivateDevice(devices.kbd, FALSE);
    EnableDevice(devices.mouse, FALSE);
    EnableDevice(devices.kbd, FALSE);

    devices.num_devices = 4;
    devices.num_master_devices = 2;

    fake_init_sprite(devices.mouse);
    fake_init_sprite(devices.vcp);

    return devices;
}


/* Create minimal client, with the given buffer and len as request buffer */
ClientRec init_client(int len, void *data)
{
    ClientRec client = { 0 };

    /* we store the privates now and reassign it after the memset. this way
     * we can share them across multiple test runs and don't have to worry
     * about freeing them after each test run. */

    client.index = CLIENT_INDEX;
    client.clientAsMask = CLIENT_MASK;
    client.sequence = CLIENT_SEQUENCE;
    client.req_len = len;

    client.requestBuffer = data;
    dixAllocatePrivates(&client.devPrivates, PRIVATE_CLIENT);
    return client;
}

void init_window(WindowPtr window, WindowPtr parent, int id)
{
    memset(window, 0, sizeof(*window));

    window->drawable.id = id;
    if (parent)
    {
        window->drawable.x = 30;
        window->drawable.y = 50;
        window->drawable.width = 100;
        window->drawable.height = 200;
    }
    window->parent = parent;
    window->optional = calloc(1, sizeof(WindowOptRec));
    assert(window->optional);
}

extern DevPrivateKeyRec miPointerScreenKeyRec;
extern DevPrivateKeyRec miPointerPrivKeyRec;

/* Needed for the screen setup, otherwise we crash during sprite initialization */
static Bool device_cursor_init(DeviceIntPtr dev, ScreenPtr screen) { return TRUE; }
static Bool set_cursor_pos(DeviceIntPtr dev, ScreenPtr screen, int x, int y, Bool event) { return TRUE; }
void init_simple(void)
{
    screenInfo.numScreens = 1;
    screenInfo.screens[0] = &screen;

    screen.myNum = 0;
    screen.id = 100;
    screen.width = 640;
    screen.height = 480;
    screen.DeviceCursorInitialize = device_cursor_init;
    screen.SetCursorPosition = set_cursor_pos;

    dixResetPrivates();
    InitAtoms();
    XkbInitPrivates();
    dixRegisterPrivateKey(&XIClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(XIClientRec));
    dixRegisterPrivateKey(&miPointerScreenKeyRec, PRIVATE_SCREEN, 0);
    dixRegisterPrivateKey(&miPointerPrivKeyRec, PRIVATE_DEVICE, 0);
    XInputExtensionInit();

    init_window(&root, NULL, ROOT_WINDOW_ID);
    init_window(&window, &root, CLIENT_WINDOW_ID);

    devices = init_devices();
}

void __wrap_WriteToClient(ClientPtr client, int len, void *data)
{
    assert(reply_handler != NULL);

    (*reply_handler)(client, len, data, userdata);
}

/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "windowstr.h"
#include "exevents.h"
#include <assert.h>

#ifndef PROTOCOL_COMMON_H
#define PROTOCOL_COMMON_H

extern int BadDevice;

/* Check default values in a reply */
#define reply_check_defaults(rep, len, type) \
    { \
        assert((len) >= sz_x##type##Reply); \
        assert((rep)->repType == X_Reply); \
        assert((rep)->RepType == X_##type); \
        assert((rep)->sequenceNumber == CLIENT_SEQUENCE); \
        assert((rep)->length >= (sz_x##type##Reply - 32)/4); \
    }

/* initialise default values for request */
#define request_init(req, type) \
    { \
        (req)->reqType = 128; /* doesn't matter */ \
        (req)->ReqType = X_##type; \
        (req)->length = (sz_x##type##Req >> 2); \
    }


/* Various defines used in the tests. Some tests may use different values
 * than these defaults */
/* default client index */
#define CLIENT_INDEX            1
/* default client mask for resources and windows */
#define CLIENT_MASK             ((CLIENT_INDEX) << CLIENTOFFSET)
/* default client sequence number for replies */
#define CLIENT_SEQUENCE         0x100
/* default root window id */
#define ROOT_WINDOW_ID          0x10
/* default client window id */
#define CLIENT_WINDOW_ID        0x100001
/* invalid window ID. use for BadWindow checks. */
#define INVALID_WINDOW_ID       0x111111
/* initial fake sprite position */
#define SPRITE_X                100
#define SPRITE_Y                200


/* Various structs used throughout the tests */


/* The default devices struct, contains one pointer + keyboard and the
 * matching master devices. Initialize with init_devices() if needed. */
struct devices {
    DeviceIntPtr vcp;
    DeviceIntPtr vck;
    DeviceIntPtr mouse;
    DeviceIntPtr kbd;

    int num_devices;
    int num_master_devices;
} devices;

/**
 * The set of default devices available in all tests if necessary.
 */
extern struct devices devices;

/**
 * test-specific userdata, passed into the reply handler.
 */
extern void *userdata;
/**
 * The reply handler called from WriteToClient. Set this handler if you need
 * to check the reply values.
 */
void (*reply_handler)(ClientPtr client, int len, char *data, void *userdata);

/**
 * The default screen used for the windows. Initialized by init_simple().
 */
extern ScreenRec screen;
/**
 * Semi-initialized root window. initialized by init().
 */
extern WindowRec root;
/**
 * Semi-initialized top-level window. initialized by init().
 */
extern WindowRec window;

/* various simple functions for quick setup */
/**
 * Initialize the above struct with default devices and return the struct.
 * Usually not needed if you call ::init_simple.
 */
struct devices init_devices(void);
/**
 * Init a mostly zeroed out client with default values for index and mask.
 */
ClientRec init_client(int request_len, void *request_data);
/**
 * Init a mostly zeroed out window with the given window ID.
 * Usually not needed if you call ::init_simple which sets up root and
 * window.
 */
void init_window(WindowPtr window, WindowPtr parent, int id);
/**
 * Create a very simple setup that provides the minimum values for most
 * tests, including a screen, the root and client window and the default
 * device setup.
 */
void init_simple(void);

/* Declarations for various overrides in the test files. */
void __wrap_WriteToClient(ClientPtr client, int len, void *data);
int __wrap_XISetEventMask(DeviceIntPtr dev, WindowPtr win, int len, unsigned char* mask);
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access);
int __real_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access);
Bool __wrap_AddResource(XID id, RESTYPE type, pointer value);
int __wrap_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);
int __real_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);


#endif /* PROTOCOL_COMMON_H */

/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>

#include "inputstr.h"
#include "eventstr.h"
#include "eventconvert.h"
#include "exevents.h"
#include <X11/extensions/XI2proto.h>

static void test_values_XIRawEvent(RawDeviceEvent *in, xXIRawEvent *out,
                                   BOOL swap)
{
    int i;
    unsigned char *ptr;
    FP3232 *value, *raw_value;
    int nvals = 0;
    int bits_set;
    int len;

    if (swap)
    {
        char n;

        swaps(&out->sequenceNumber, n);
        swapl(&out->length, n);
        swaps(&out->evtype, n);
        swaps(&out->deviceid, n);
        swapl(&out->time, n);
        swapl(&out->detail, n);
        swaps(&out->valuators_len, n);
    }


    assert(out->type == GenericEvent);
    assert(out->extension == 0); /* IReqCode defaults to 0 */
    assert(out->evtype == GetXI2Type((InternalEvent*)in));
    assert(out->time == in->time);
    assert(out->detail == in->detail.button);
    assert(out->deviceid == in->deviceid);
    assert(out->valuators_len >= bytes_to_int32(bits_to_bytes(sizeof(in->valuators.mask))));
    assert(out->flags == 0); /* FIXME: we don't set the flags yet */

    ptr = (unsigned char*)&out[1];
    bits_set = 0;

    for (i = 0; out->valuators_len && i < sizeof(in->valuators.mask) * 8; i++)
    {
        if (i >= MAX_VALUATORS)
            assert (!XIMaskIsSet(in->valuators.mask, i));
        assert (XIMaskIsSet(in->valuators.mask, i) == XIMaskIsSet(ptr, i));
        if (XIMaskIsSet(in->valuators.mask, i))
            bits_set++;
    }

    /* length is len of valuator mask (in 4-byte units) + the number of bits
     * set. Each bit set represents 2 8-byte values, hence the
     * 'bits_set * 4' */
    len = out->valuators_len + bits_set * 4;
    assert(out->length == len);

    nvals = 0;

    for (i = 0; out->valuators_len && i < MAX_VALUATORS; i++)
    {
        assert (XIMaskIsSet(in->valuators.mask, i) == XIMaskIsSet(ptr, i));
        if (XIMaskIsSet(in->valuators.mask, i))
        {
            FP3232 vi, vo;
            value = (FP3232*)(((unsigned char*)&out[1]) + out->valuators_len * 4);
            value += nvals;

            vi.integral = in->valuators.data[i];
            vi.frac = in->valuators.data_frac[i];

            vo.integral = value->integral;
            vo.frac = value->frac;
            if (swap)
            {
                char n;
                swapl(&vo.integral, n);
                swapl(&vo.frac, n);
            }

            assert(vi.integral == vo.integral);
            assert(vi.frac == vo.frac);

            raw_value = value + bits_set;

            vi.integral = in->valuators.data_raw[i];
            vi.frac = in->valuators.data_raw_frac[i];

            vo.integral = raw_value->integral;
            vo.frac = raw_value->frac;
            if (swap)
            {
                char n;
                swapl(&vo.integral, n);
                swapl(&vo.frac, n);
            }

            assert(vi.integral == vo.integral);
            assert(vi.frac == vo.frac);

            nvals++;
        }
    }
}

static void test_XIRawEvent(RawDeviceEvent *in)
{
    xXIRawEvent *out, *swapped;
    int rc;

    rc = EventToXI2((InternalEvent*)in, (xEvent**)&out);
    assert(rc == Success);

    test_values_XIRawEvent(in, out, FALSE);

    swapped = calloc(1, sizeof(xEvent) + out->length * 4);
    XI2EventSwap((xGenericEvent*)out, (xGenericEvent*)swapped);
    test_values_XIRawEvent(in, swapped, TRUE);

    free(out);
    free(swapped);
}

static void test_convert_XIFocusEvent(void)
{
    xEvent *out;
    DeviceEvent in;
    int rc;

    in.header = ET_Internal;
    in.type = ET_Enter;
    rc = EventToXI2((InternalEvent*)&in, &out);
    assert(rc == Success);
    assert(out == NULL);

    in.header = ET_Internal;
    in.type = ET_FocusIn;
    rc = EventToXI2((InternalEvent*)&in, &out);
    assert(rc == Success);
    assert(out == NULL);

    in.header = ET_Internal;
    in.type = ET_FocusOut;
    rc = EventToXI2((InternalEvent*)&in, &out);
    assert(rc == BadImplementation);

    in.header = ET_Internal;
    in.type = ET_Leave;
    rc = EventToXI2((InternalEvent*)&in, &out);
    assert(rc == BadImplementation);
}


static void test_convert_XIRawEvent(void)
{
    RawDeviceEvent in;
    int i;

    memset(&in, 0, sizeof(in));

    printf("Testing all event types\n");
    in.header = ET_Internal;
    in.type = ET_RawMotion;
    test_XIRawEvent(&in);

    in.header = ET_Internal;
    in.type = ET_RawKeyPress;
    test_XIRawEvent(&in);

    in.header = ET_Internal;
    in.type = ET_RawKeyRelease;
    test_XIRawEvent(&in);

    in.header = ET_Internal;
    in.type = ET_RawButtonPress;
    test_XIRawEvent(&in);

    in.header = ET_Internal;
    in.type = ET_RawButtonRelease;
    test_XIRawEvent(&in);

    printf("Testing details and other fields\n");
    in.detail.button = 1L;
    test_XIRawEvent(&in);
    in.detail.button = 1L << 8;
    test_XIRawEvent(&in);
    in.detail.button = 1L << 16;
    test_XIRawEvent(&in);
    in.detail.button = 1L << 24;
    test_XIRawEvent(&in);
    in.detail.button = ~0L;
    test_XIRawEvent(&in);

    in.detail.button = 0;

    in.time = 1L;
    test_XIRawEvent(&in);
    in.time = 1L << 8;
    test_XIRawEvent(&in);
    in.time = 1L << 16;
    test_XIRawEvent(&in);
    in.time = 1L << 24;
    test_XIRawEvent(&in);
    in.time = ~0L;
    test_XIRawEvent(&in);

    in.deviceid = 1;
    test_XIRawEvent(&in);
    in.deviceid = 1 << 8;
    test_XIRawEvent(&in);
    in.deviceid = ~0 & 0xFF;
    test_XIRawEvent(&in);

    printf("Testing valuator masks\n");
    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);
        test_XIRawEvent(&in);
        XIClearMask(in.valuators.mask, i);
    }

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);

        in.valuators.data[i] = i;
        in.valuators.data_raw[i] = i + 10;
        in.valuators.data_frac[i] = i + 20;
        in.valuators.data_raw_frac[i] = i + 30;
        test_XIRawEvent(&in);
        XIClearMask(in.valuators.mask, i);
    }

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);
        test_XIRawEvent(&in);
    }
}

static void test_values_XIDeviceEvent(DeviceEvent *in, xXIDeviceEvent *out,
                                      BOOL swap)
{
    int buttons, valuators;
    int i;
    unsigned char *ptr;
    uint32_t flagmask = 0;
    FP3232 *values;

    if (swap) {
        char n;

        swaps(&out->sequenceNumber, n);
        swapl(&out->length, n);
        swaps(&out->evtype, n);
        swaps(&out->deviceid, n);
        swaps(&out->sourceid, n);
        swapl(&out->time, n);
        swapl(&out->detail, n);
        swapl(&out->root, n);
        swapl(&out->event, n);
        swapl(&out->child, n);
        swapl(&out->root_x, n);
        swapl(&out->root_y, n);
        swapl(&out->event_x, n);
        swapl(&out->event_y, n);
        swaps(&out->buttons_len, n);
        swaps(&out->valuators_len, n);
        swapl(&out->mods.base_mods, n);
        swapl(&out->mods.latched_mods, n);
        swapl(&out->mods.locked_mods, n);
        swapl(&out->mods.effective_mods, n);
        swapl(&out->flags, n);
    }

    assert(out->extension == 0); /* IReqCode defaults to 0 */
    assert(out->evtype == GetXI2Type((InternalEvent*)in));
    assert(out->time == in->time);
    assert(out->detail == in->detail.button);
    assert(out->length >= 12);

    assert(out->deviceid == in->deviceid);
    assert(out->sourceid == in->sourceid);

    switch (in->type) {
        case ET_KeyPress:
            flagmask = XIKeyRepeat;
            break;
        default:
            flagmask = 0;
            break;
    }
    assert((out->flags & ~flagmask) == 0);

    assert(out->root == in->root);
    assert(out->event == None); /* set in FixUpEventFromWindow */
    assert(out->child == None); /* set in FixUpEventFromWindow */

    assert(out->mods.base_mods == in->mods.base);
    assert(out->mods.latched_mods == in->mods.latched);
    assert(out->mods.locked_mods == in->mods.locked);
    assert(out->mods.effective_mods == in->mods.effective);

    assert(out->group.base_group == in->group.base);
    assert(out->group.latched_group == in->group.latched);
    assert(out->group.locked_group == in->group.locked);
    assert(out->group.effective_group == in->group.effective);

    assert(out->event_x == 0); /* set in FixUpEventFromWindow */
    assert(out->event_y == 0); /* set in FixUpEventFromWindow */

    assert(out->root_x == FP1616(in->root_x, in->root_x_frac));
    assert(out->root_y == FP1616(in->root_y, in->root_y_frac));

    buttons = 0;
    for (i = 0; i < bits_to_bytes(sizeof(in->buttons)); i++)
    {
        if (XIMaskIsSet(in->buttons, i))
        {
            assert(out->buttons_len >= bytes_to_int32(bits_to_bytes(i)));
            buttons++;
        }
    }

    ptr = (unsigned char*)&out[1];
    for (i = 0; i < sizeof(in->buttons) * 8; i++)
        assert(XIMaskIsSet(in->buttons, i) == XIMaskIsSet(ptr, i));


    valuators = 0;
    for (i = 0; i < MAX_VALUATORS; i++)
        if (XIMaskIsSet(in->valuators.mask, i))
            valuators++;

    assert(out->valuators_len >= bytes_to_int32(bits_to_bytes(valuators)));

    ptr += out->buttons_len * 4;
    values = (FP3232*)(ptr + out->valuators_len * 4);
    for (i = 0; i < sizeof(in->valuators.mask) * 8 ||
                i < (out->valuators_len * 4) * 8; i++)
    {
        if (i >= MAX_VALUATORS)
            assert(!XIMaskIsSet(in->valuators.mask, i) && !XIMaskIsSet(ptr, i));
        else if (i > sizeof(in->valuators.mask) * 8)
            assert(!XIMaskIsSet(ptr, i));
        else if (i > out->valuators_len * 4 * 8)
            assert(!XIMaskIsSet(in->valuators.mask, i));
        else {
            assert(XIMaskIsSet(in->valuators.mask, i) ==
                     XIMaskIsSet(ptr, i));

            if (XIMaskIsSet(ptr, i))
            {
                FP3232 vi, vo;

                vi.integral = in->valuators.data[i];
                vi.frac = in->valuators.data_frac[i];

                vo = *values;

                if (swap)
                {
                    char n;
                    swapl(&vo.integral, n);
                    swapl(&vo.frac, n);
                }


                assert(vi.integral == vo.integral);
                assert(vi.frac == vo.frac);
                values++;
            }
        }
    }
}

static void test_XIDeviceEvent(DeviceEvent *in)
{
    xXIDeviceEvent *out, *swapped;
    int rc;

    rc = EventToXI2((InternalEvent*)in, (xEvent**)&out);
    assert(rc == Success);

    test_values_XIDeviceEvent(in, out, FALSE);

    swapped = calloc(1, sizeof(xEvent) + out->length * 4);
    XI2EventSwap((xGenericEvent*)out, (xGenericEvent*)swapped);
    test_values_XIDeviceEvent(in, swapped, TRUE);

    free(out);
    free(swapped);
}

static void test_convert_XIDeviceEvent(void)
{
    DeviceEvent in;
    int i;

    memset(&in, 0, sizeof(in));

    printf("Testing simple field values\n");
    in.header = ET_Internal;
    in.type = ET_Motion;
    in.length = sizeof(DeviceEvent);
    in.time             = 0;
    in.deviceid         = 1;
    in.sourceid         = 2;
    in.root             = 3;
    in.root_x           = 4;
    in.root_x_frac      = 5;
    in.root_y           = 6;
    in.root_y_frac      = 7;
    in.detail.button    = 8;
    in.mods.base        = 9;
    in.mods.latched     = 10;
    in.mods.locked      = 11;
    in.mods.effective   = 11;
    in.group.base       = 12;
    in.group.latched    = 13;
    in.group.locked     = 14;
    in.group.effective  = 15;

    test_XIDeviceEvent(&in);

    printf("Testing field ranges\n");
    /* 32 bit */
    in.detail.button = 1L;
    test_XIDeviceEvent(&in);
    in.detail.button = 1L << 8;
    test_XIDeviceEvent(&in);
    in.detail.button = 1L << 16;
    test_XIDeviceEvent(&in);
    in.detail.button = 1L << 24;
    test_XIDeviceEvent(&in);
    in.detail.button = ~0L;
    test_XIDeviceEvent(&in);

    /* 32 bit */
    in.time = 1L;
    test_XIDeviceEvent(&in);
    in.time = 1L << 8;
    test_XIDeviceEvent(&in);
    in.time = 1L << 16;
    test_XIDeviceEvent(&in);
    in.time = 1L << 24;
    test_XIDeviceEvent(&in);
    in.time = ~0L;
    test_XIDeviceEvent(&in);

    /* 16 bit */
    in.deviceid = 1;
    test_XIDeviceEvent(&in);
    in.deviceid = 1 << 8;
    test_XIDeviceEvent(&in);
    in.deviceid = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    /* 16 bit */
    in.sourceid = 1;
    test_XIDeviceEvent(&in);
    in.deviceid = 1 << 8;
    test_XIDeviceEvent(&in);
    in.deviceid = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    /* 32 bit */
    in.root = 1L;
    test_XIDeviceEvent(&in);
    in.root = 1L << 8;
    test_XIDeviceEvent(&in);
    in.root = 1L << 16;
    test_XIDeviceEvent(&in);
    in.root = 1L << 24;
    test_XIDeviceEvent(&in);
    in.root = ~0L;
    test_XIDeviceEvent(&in);

    /* 16 bit */
    in.root_x = 1;
    test_XIDeviceEvent(&in);
    in.root_x = 1 << 8;
    test_XIDeviceEvent(&in);
    in.root_x = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.root_x_frac = 1;
    test_XIDeviceEvent(&in);
    in.root_x_frac = 1 << 8;
    test_XIDeviceEvent(&in);
    in.root_x_frac = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.root_y = 1;
    test_XIDeviceEvent(&in);
    in.root_y = 1 << 8;
    test_XIDeviceEvent(&in);
    in.root_y = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.root_y_frac = 1;
    test_XIDeviceEvent(&in);
    in.root_y_frac = 1 << 8;
    test_XIDeviceEvent(&in);
    in.root_y_frac = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    /* 32 bit */
    in.mods.base = 1L;
    test_XIDeviceEvent(&in);
    in.mods.base = 1L << 8;
    test_XIDeviceEvent(&in);
    in.mods.base = 1L << 16;
    test_XIDeviceEvent(&in);
    in.mods.base = 1L << 24;
    test_XIDeviceEvent(&in);
    in.mods.base = ~0L;
    test_XIDeviceEvent(&in);

    in.mods.latched = 1L;
    test_XIDeviceEvent(&in);
    in.mods.latched = 1L << 8;
    test_XIDeviceEvent(&in);
    in.mods.latched = 1L << 16;
    test_XIDeviceEvent(&in);
    in.mods.latched = 1L << 24;
    test_XIDeviceEvent(&in);
    in.mods.latched = ~0L;
    test_XIDeviceEvent(&in);

    in.mods.locked = 1L;
    test_XIDeviceEvent(&in);
    in.mods.locked = 1L << 8;
    test_XIDeviceEvent(&in);
    in.mods.locked = 1L << 16;
    test_XIDeviceEvent(&in);
    in.mods.locked = 1L << 24;
    test_XIDeviceEvent(&in);
    in.mods.locked = ~0L;
    test_XIDeviceEvent(&in);

    in.mods.effective = 1L;
    test_XIDeviceEvent(&in);
    in.mods.effective = 1L << 8;
    test_XIDeviceEvent(&in);
    in.mods.effective = 1L << 16;
    test_XIDeviceEvent(&in);
    in.mods.effective = 1L << 24;
    test_XIDeviceEvent(&in);
    in.mods.effective = ~0L;
    test_XIDeviceEvent(&in);

    /* 8 bit */
    in.group.base = 1;
    test_XIDeviceEvent(&in);
    in.group.base = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.group.latched = 1;
    test_XIDeviceEvent(&in);
    in.group.latched = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.group.locked = 1;
    test_XIDeviceEvent(&in);
    in.group.locked = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.mods.effective = 1;
    test_XIDeviceEvent(&in);
    in.mods.effective = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    printf("Testing button masks\n");
    for (i = 0; i < sizeof(in.buttons) * 8; i++)
    {
        XISetMask(in.buttons, i);
        test_XIDeviceEvent(&in);
        XIClearMask(in.buttons, i);
    }

    for (i = 0; i < sizeof(in.buttons) * 8; i++)
    {
        XISetMask(in.buttons, i);
        test_XIDeviceEvent(&in);
    }

    printf("Testing valuator masks\n");
    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);
        test_XIDeviceEvent(&in);
        XIClearMask(in.valuators.mask, i);
    }

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);

        in.valuators.data[i] = i;
        in.valuators.data_frac[i] = i + 20;
        test_XIDeviceEvent(&in);
        XIClearMask(in.valuators.mask, i);
    }

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);
        test_XIDeviceEvent(&in);
    }
}

static void test_values_XIDeviceChangedEvent(DeviceChangedEvent *in,
                                             xXIDeviceChangedEvent *out,
                                             BOOL swap)
{
    int i, j;
    unsigned char *ptr;

    if (swap)
    {
        char n;

        swaps(&out->sequenceNumber, n);
        swapl(&out->length, n);
        swaps(&out->evtype, n);
        swaps(&out->deviceid, n);
        swaps(&out->sourceid, n);
        swapl(&out->time, n);
        swaps(&out->num_classes, n);
    }

    assert(out->type == GenericEvent);
    assert(out->extension == 0); /* IReqCode defaults to 0 */
    assert(out->evtype == GetXI2Type((InternalEvent*)in));
    assert(out->time == in->time);
    assert(out->deviceid == in->deviceid);
    assert(out->sourceid == in->sourceid);

    ptr = (unsigned char*)&out[1];
    for (i = 0; i < out->num_classes; i++)
    {
        xXIAnyInfo* any = (xXIAnyInfo*)ptr;

        if (swap)
        {
            char n;
            swaps(&any->length, n);
            swaps(&any->type, n);
            swaps(&any->sourceid, n);
        }

        switch(any->type)
        {
            case XIButtonClass:
                {
                    xXIButtonInfo *b = (xXIButtonInfo*)any;
                    Atom *names;

                    if (swap)
                    {
                        char n;
                        swaps(&b->num_buttons, n);
                    }

                    assert(b->length ==
                            bytes_to_int32(sizeof(xXIButtonInfo)) +
                            bytes_to_int32(bits_to_bytes(b->num_buttons)) +
                            b->num_buttons);
                    assert(b->num_buttons == in->buttons.num_buttons);

                    names = (Atom*)((char*)&b[1] +
                            pad_to_int32(bits_to_bytes(b->num_buttons)));
                    for (j = 0; j < b->num_buttons; j++)
                    {
                        if (swap)
                        {
                            char n;
                            swapl(&names[j], n);
                        }
                        assert(names[j] == in->buttons.names[j]);
                    }
                }
                break;
            case XIKeyClass:
                {
                    xXIKeyInfo *k = (xXIKeyInfo*)any;
                    uint32_t *kc;

                    if (swap)
                    {
                        char n;
                        swaps(&k->num_keycodes, n);
                    }

                    assert(k->length ==
                            bytes_to_int32(sizeof(xXIKeyInfo)) +
                            k->num_keycodes);
                    assert(k->num_keycodes == in->keys.max_keycode -
                            in->keys.min_keycode + 1);

                    kc = (uint32_t*)&k[1];
                    for (j = 0; j < k->num_keycodes; j++)
                    {
                        if (swap)
                        {
                            char n;
                            swapl(&kc[j], n);
                        }
                        assert(kc[j] >= in->keys.min_keycode);
                        assert(kc[j] <= in->keys.max_keycode);
                    }
                }
                break;
            case XIValuatorClass:
                {
                    xXIValuatorInfo *v = (xXIValuatorInfo*)any;
                    assert(v->length ==
                             bytes_to_int32(sizeof(xXIValuatorInfo)));

                }
                break;
            default:
                printf("Invalid class type.\n\n");
                assert(1);
                break;
        }

        ptr += any->length * 4;
    }

}

static void test_XIDeviceChangedEvent(DeviceChangedEvent *in)
{
    xXIDeviceChangedEvent *out, *swapped;
    int rc;

    rc = EventToXI2((InternalEvent*)in, (xEvent**)&out);
    assert(rc == Success);

    test_values_XIDeviceChangedEvent(in, out, FALSE);

    swapped = calloc(1, sizeof(xEvent) + out->length * 4);
    XI2EventSwap((xGenericEvent*)out, (xGenericEvent*)swapped);
    test_values_XIDeviceChangedEvent(in, swapped, TRUE);

    free(out);
    free(swapped);
}

static void test_convert_XIDeviceChangedEvent(void)
{
    DeviceChangedEvent in;
    int i;

    printf("Testing simple field values\n");
    memset(&in, 0, sizeof(in));
    in.header = ET_Internal;
    in.type = ET_DeviceChanged;
    in.length = sizeof(DeviceChangedEvent);
    in.time             = 0;
    in.deviceid         = 1;
    in.sourceid         = 2;
    in.masterid         = 3;
    in.num_valuators    = 4;
    in.flags = DEVCHANGE_SLAVE_SWITCH | DEVCHANGE_POINTER_EVENT | DEVCHANGE_KEYBOARD_EVENT;

    for (i = 0; i < MAX_BUTTONS; i++)
        in.buttons.names[i] = i + 10;

    in.keys.min_keycode = 8;
    in.keys.max_keycode = 255;

    test_XIDeviceChangedEvent(&in);

    in.time = 1L;
    test_XIDeviceChangedEvent(&in);
    in.time = 1L << 8;
    test_XIDeviceChangedEvent(&in);
    in.time = 1L << 16;
    test_XIDeviceChangedEvent(&in);
    in.time = 1L << 24;
    test_XIDeviceChangedEvent(&in);
    in.time = ~0L;
    test_XIDeviceChangedEvent(&in);

    in.deviceid = 1L;
    test_XIDeviceChangedEvent(&in);
    in.deviceid = 1L << 8;
    test_XIDeviceChangedEvent(&in);
    in.deviceid = ~0 & 0xFFFF;
    test_XIDeviceChangedEvent(&in);

    in.sourceid = 1L;
    test_XIDeviceChangedEvent(&in);
    in.sourceid = 1L << 8;
    test_XIDeviceChangedEvent(&in);
    in.sourceid = ~0 & 0xFFFF;
    test_XIDeviceChangedEvent(&in);

    in.masterid = 1L;
    test_XIDeviceChangedEvent(&in);
    in.masterid = 1L << 8;
    test_XIDeviceChangedEvent(&in);
    in.masterid = ~0 & 0xFFFF;
    test_XIDeviceChangedEvent(&in);

    in.buttons.num_buttons = 0;
    test_XIDeviceChangedEvent(&in);

    in.buttons.num_buttons = 1;
    test_XIDeviceChangedEvent(&in);

    in.buttons.num_buttons = MAX_BUTTONS;
    test_XIDeviceChangedEvent(&in);

    in.keys.min_keycode = 0;
    in.keys.max_keycode = 0;
    test_XIDeviceChangedEvent(&in);

    in.keys.max_keycode = 1 << 8;
    test_XIDeviceChangedEvent(&in);

    in.keys.max_keycode = 0xFFFC; /* highest range, above that the length
                                     field gives up */
    test_XIDeviceChangedEvent(&in);

    in.keys.min_keycode = 1 << 8;
    in.keys.max_keycode = 1 << 8;
    test_XIDeviceChangedEvent(&in);

    in.keys.min_keycode = 1 << 8;
    in.keys.max_keycode = 0;
    test_XIDeviceChangedEvent(&in);

    in.num_valuators = 0;
    test_XIDeviceChangedEvent(&in);

    in.num_valuators = 1;
    test_XIDeviceChangedEvent(&in);

    in.num_valuators = MAX_VALUATORS;
    test_XIDeviceChangedEvent(&in);

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        in.valuators[i].min = 0;
        in.valuators[i].max = 0;
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].max = 1 << 8;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].max = 1 << 16;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].max = 1 << 24;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].max = abs(~0);
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].resolution = 1 << 8;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].resolution = 1 << 16;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].resolution = 1 << 24;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].resolution = abs(~0);
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].name = i;
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].mode = Relative;
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].mode = Absolute;
        test_XIDeviceChangedEvent(&in);
    }
}

int main(int argc, char** argv)
{
    test_convert_XIRawEvent();
    test_convert_XIFocusEvent();
    test_convert_XIDeviceEvent();
    test_convert_XIDeviceChangedEvent();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIGetClientPointer request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xigetclientpointer.h"
#include "exevents.h"

#include "protocol-common.h"

struct {
    int cp_is_set;
    DeviceIntPtr dev;
    int win;
} test_data;

static ClientRec client_window;
static ClientRec client_request;

int __wrap_dixLookupClient(ClientPtr *pClient, XID rid, ClientPtr client, Mask access)
{
    if (rid == ROOT_WINDOW_ID)
        return BadWindow;

    if (rid == CLIENT_WINDOW_ID)
    {
        *pClient = &client_window;
        return Success;
    }

    return __real_dixLookupClient(pClient, rid, client, access);
}


static void reply_XIGetClientPointer(ClientPtr client, int len, char *data, void *userdata)
{
    xXIGetClientPointerReply *rep = (xXIGetClientPointerReply*)data;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swaps(&rep->deviceid, n);
    }

    reply_check_defaults(rep, len, XIGetClientPointer);

    assert(rep->set == test_data.cp_is_set);
    if (rep->set)
        assert(rep->deviceid == test_data.dev->id);
}

static void request_XIGetClientPointer(ClientPtr client, xXIGetClientPointerReq* req, int error)
{
    char n;
    int rc;

    test_data.win = req->win;

    rc = ProcXIGetClientPointer(&client_request);
    assert(rc == error);

    if (rc == BadWindow)
        assert(client_request.errorValue == req->win);

    client_request.swapped = TRUE;
    swapl(&req->win, n);
    swaps(&req->length, n);
    rc = SProcXIGetClientPointer(&client_request);
    assert(rc == error);

    if (rc == BadWindow)
        assert(client_request.errorValue == req->win);

}

static void test_XIGetClientPointer(void)
{
    xXIGetClientPointerReq request;

    request_init(&request, XIGetClientPointer);

    request.win = CLIENT_WINDOW_ID;


    reply_handler = reply_XIGetClientPointer;

    client_request = init_client(request.length, &request);

    printf("Testing invalid window\n");
    request.win = INVALID_WINDOW_ID;
    request_XIGetClientPointer(&client_request, &request, BadWindow);

    test_data.cp_is_set = FALSE;

    printf("Testing window None, unset ClientPointer.\n");
    request.win = None;
    request_XIGetClientPointer(&client_request, &request, Success);

    printf("Testing valid window, unset ClientPointer.\n");
    request.win = CLIENT_WINDOW_ID;
    request_XIGetClientPointer(&client_request, &request, Success);

    printf("Testing valid window, set ClientPointer.\n");
    client_window.clientPtr = devices.vcp;
    test_data.dev = devices.vcp;
    test_data.cp_is_set = TRUE;
    request.win = CLIENT_WINDOW_ID;
    request_XIGetClientPointer(&client_request, &request, Success);

    client_window.clientPtr = NULL;

    printf("Testing window None, set ClientPointer.\n");
    client_request.clientPtr = devices.vcp;
    test_data.dev = devices.vcp;
    test_data.cp_is_set = TRUE;
    request.win = None;
    request_XIGetClientPointer(&client_request, &request, Success);
}

int main(int argc, char** argv)
{
    init_simple();
    client_window = init_client(0, NULL);

    test_XIGetClientPointer();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIGetSelectedEvents request.
 *
 * Tests include:
 * BadWindow on wrong window.
 * Zero-length masks if no masks are set.
 * Valid masks for valid devices.
 * Masks set on non-existent devices are not returned.
 *
 * Note that this test is not connected to the XISelectEvents request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "extinit.h" /* for XInputExtensionInit */
#include "scrnintstr.h"
#include "xiselectev.h"
#include "exevents.h"

#include "protocol-common.h"

static void reply_XIGetSelectedEvents(ClientPtr client, int len, char *data, void *userdata);
static void reply_XIGetSelectedEvents_data(ClientPtr client, int len, char *data, void *userdata);


struct {
    int num_masks_expected;
    unsigned char mask[MAXDEVICES][XI2LASTEVENT]; /* intentionally bigger */
    int mask_len;
} test_data;

/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

/* AddResource is called from XISetSEventMask, we don't need this */
Bool __wrap_AddResource(XID id, RESTYPE type, pointer value)
{
    return TRUE;
}

static void reply_XIGetSelectedEvents(ClientPtr client, int len, char *data, void *userdata)
{
    xXIGetSelectedEventsReply *rep = (xXIGetSelectedEventsReply*)data;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swaps(&rep->num_masks, n);
    }

    reply_check_defaults(rep, len, XIGetSelectedEvents);

    assert(rep->num_masks == test_data.num_masks_expected);

    reply_handler = reply_XIGetSelectedEvents_data;
}

static void reply_XIGetSelectedEvents_data(ClientPtr client, int len, char *data, void *userdata)
{
    int i;
    xXIEventMask *mask;
    unsigned char *bitmask;

    mask = (xXIEventMask*)data;
    for (i = 0; i < test_data.num_masks_expected; i++)
    {
        if (client->swapped)
        {
            char n;
            swaps(&mask->deviceid, n);
            swaps(&mask->mask_len, n);
        }

        assert(mask->deviceid < 6);
        assert(mask->mask_len <= (((XI2LASTEVENT + 8)/8) + 3)/4) ;

        bitmask = (unsigned char*)&mask[1];
        assert(memcmp(bitmask,
                    test_data.mask[mask->deviceid],
                    mask->mask_len * 4) == 0);

        mask = (xXIEventMask*)((char*)mask + mask->mask_len * 4 + sizeof(xXIEventMask));
    }


}

static void request_XIGetSelectedEvents(xXIGetSelectedEventsReq* req, int error)
{
    char n;
    int rc;
    ClientRec client;
    client = init_client(req->length, req);

    reply_handler = reply_XIGetSelectedEvents;

    rc = ProcXIGetSelectedEvents(&client);
    assert(rc == error);

    reply_handler = reply_XIGetSelectedEvents;
    client.swapped = TRUE;
    swapl(&req->win, n);
    swaps(&req->length, n);
    rc = SProcXIGetSelectedEvents(&client);
    assert(rc == error);
}

static void test_XIGetSelectedEvents(void)
{
    int i, j;
    xXIGetSelectedEventsReq request;
    ClientRec client = init_client(0, NULL);
    unsigned char *mask;
    DeviceIntRec dev;

    request_init(&request, XIGetSelectedEvents);

    printf("Testing for BadWindow on invalid window.\n");
    request.win = None;
    request_XIGetSelectedEvents(&request, BadWindow);

    printf("Testing for zero-length (unset) masks.\n");
    /* No masks set yet */
    test_data.num_masks_expected = 0;
    request.win = ROOT_WINDOW_ID;
    request_XIGetSelectedEvents(&request, Success);

    request.win = CLIENT_WINDOW_ID;
    request_XIGetSelectedEvents(&request, Success);

    memset(test_data.mask, 0,
           sizeof(test_data.mask));

    printf("Testing for valid masks\n");
    memset(&dev, 0, sizeof(dev)); /* dev->id is enough for XISetEventMask */
    request.win = ROOT_WINDOW_ID;

    /* devices 6 - MAXDEVICES don't exist, they mustn't be included in the
     * reply even if a mask is set */
    for (j = 0; j < MAXDEVICES; j++)
    {
        test_data.num_masks_expected = min(j + 1, devices.num_devices + 2);
        dev.id = j;
        mask = test_data.mask[j];
        /* bits one-by-one */
        for (i = 0; i < XI2LASTEVENT; i++)
        {
            SetBit(mask, i);
            XISetEventMask(&dev, &root, &client, (i + 8)/8, mask);
            request_XIGetSelectedEvents(&request, Success);
            ClearBit(mask, i);
        }

        /* all valid mask bits */
        for (i = 0; i < XI2LASTEVENT; i++)
        {
            SetBit(mask, i);
            XISetEventMask(&dev, &root, &client, (i + 8)/8, mask);
            request_XIGetSelectedEvents(&request, Success);
        }
    }

    printf("Testing removing all masks\n");
    /* Unset all masks one-by-one */
    for (j = MAXDEVICES - 1; j >= 0; j--)
    {
        if (j < devices.num_devices + 2)
            test_data.num_masks_expected--;

        mask = test_data.mask[j];
        memset(mask, 0, XI2LASTEVENT);

        dev.id = j;
        XISetEventMask(&dev, &root, &client, 0, NULL);

        request_XIGetSelectedEvents(&request, Success);
    }
}

int main(int argc, char** argv)
{
    init_simple();

    test_XIGetSelectedEvents();

    return 0;
}

/**
 * Copyright © 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIPassiveGrab request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xipassivegrab.h"
#include "exevents.h"

#include "protocol-common.h"

static ClientRec client_request;
#define N_MODS 7
static uint32_t modifiers[N_MODS] = {1, 2, 3, 4, 5, 6, 7};

struct test_data {
    int num_modifiers;
} testdata;

int __wrap_GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
                      int button, GrabParameters *param, GrabType grabtype,
                      GrabMask *mask);
static void reply_XIPassiveGrabDevice_data(ClientPtr client, int len, char *data, void *userdata);

int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

int __wrap_GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
                      int button, GrabParameters *param, GrabType grabtype,
                      GrabMask *mask)
{
    /* Fail every odd modifier */
    if (param->modifiers % 2)
        return BadAccess;

    return Success;
}

static void reply_XIPassiveGrabDevice(ClientPtr client, int len, char *data, void *userdata)
{
    xXIPassiveGrabDeviceReply *rep = (xXIPassiveGrabDeviceReply*)data;

    if (client->swapped)
    {
        char n;
        swaps(&rep->sequenceNumber, n);
        swapl(&rep->length, n);
        swaps(&rep->num_modifiers, n);

        testdata.num_modifiers = rep->num_modifiers;
    }

    reply_check_defaults(rep, len, XIPassiveGrabDevice);

    /* ProcXIPassiveGrabDevice sends the data in two batches, let the second
     * handler handle the modifier data */
    if (rep->num_modifiers > 0)
        reply_handler = reply_XIPassiveGrabDevice_data;
}

static void reply_XIPassiveGrabDevice_data(ClientPtr client, int len, char *data, void *userdata)
{
    int i;
    int n;

    xXIGrabModifierInfo *mods = (xXIGrabModifierInfo*)data;

    for (i = 0; i < testdata.num_modifiers; i++, mods++)
    {
        if (client->swapped)
            swapl(&mods->modifiers, n);

        /* 1 - 7 is the range we use for the global modifiers array
         * above */
        assert(mods->modifiers > 0);
        assert(mods->modifiers <= 7);
        assert(mods->modifiers % 2 == 1); /* because we fail odd ones */
        assert(mods->status != Success);
        assert(mods->pad0 == 0);
        assert(mods->pad1 == 0);
    }

    reply_handler = reply_XIPassiveGrabDevice;
}

static void request_XIPassiveGrabDevice(ClientPtr client, xXIPassiveGrabDeviceReq* req, int error, int errval)
{
    char n;
    int rc;
    int modifiers;

    rc = ProcXIPassiveGrabDevice(&client_request);
    assert(rc == error);

    if (rc != Success)
        assert(client_request.errorValue == errval);

    client_request.swapped = TRUE;
    swaps(&req->length, n);
    swapl(&req->time, n);
    swapl(&req->grab_window, n);
    swapl(&req->cursor, n);
    swapl(&req->detail, n);
    swaps(&req->deviceid, n);
    modifiers = req->num_modifiers;
    swaps(&req->num_modifiers, n);
    swaps(&req->mask_len, n);

    while(modifiers--)
    {
        CARD32 *mod = ((CARD32*)(req + 1)) + modifiers;
        swapl(mod, n);
    }

    rc = SProcXIPassiveGrabDevice(&client_request);
    assert(rc == error);

    if (rc != Success)
        assert(client_request.errorValue == errval);
}

static unsigned char *data[4096]; /* the request buffer */
static void test_XIPassiveGrabDevice(void)
{
    int i;
    xXIPassiveGrabDeviceReq *request = (xXIPassiveGrabDeviceReq*)data;
    unsigned char *mask;

    request_init(request, XIPassiveGrabDevice);

    request->grab_window = CLIENT_WINDOW_ID;

    reply_handler = reply_XIPassiveGrabDevice;
    client_request = init_client(request->length, request);

    printf("Testing invalid device\n");
    request->deviceid = 12;
    request_XIPassiveGrabDevice(&client_request, request, BadDevice, request->deviceid);

    request->deviceid = XIAllMasterDevices;

    printf("Testing invalid grab types\n");
    for (i = XIGrabtypeFocusIn + 1; i < 0xFF; i++)
    {
        request->grab_type = i;
        request_XIPassiveGrabDevice(&client_request, request, BadValue, request->grab_type);
    }

    printf("Testing invalid grab type + detail combinations\n");
    request->grab_type = XIGrabtypeEnter;
    request->detail = 1;
    request_XIPassiveGrabDevice(&client_request, request, BadValue, request->detail);

    request->grab_type = XIGrabtypeFocusIn;
    request_XIPassiveGrabDevice(&client_request, request, BadValue, request->detail);

    request->detail = 0;

    printf("Testing invalid masks\n");
    mask = (unsigned char*)&request[1];

    request->mask_len = bytes_to_int32(XI2LASTEVENT + 1);
    request->length += request->mask_len;
    SetBit(mask, XI2LASTEVENT + 1);
    request_XIPassiveGrabDevice(&client_request, request, BadValue, XI2LASTEVENT + 1);

    ClearBit(mask, XI2LASTEVENT + 1);

    /* tested all special cases now, test a few valid cases */

    /* no modifiers */
    request->deviceid = XIAllDevices;
    request->grab_type = XIGrabtypeButton;
    request->detail = XIAnyButton;
    request_XIPassiveGrabDevice(&client_request, request, Success, 0);

    /* some modifiers */
    request->num_modifiers = N_MODS;
    request->length += N_MODS;
    memcpy((uint32_t*)(request + 1) + request->mask_len, modifiers, sizeof(modifiers));
    request_XIPassiveGrabDevice(&client_request, request, Success, 0);
}

int main(int argc, char** argv)
{
    init_simple();

    test_XIPassiveGrabDevice();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/Xatom.h>
#include "inputstr.h"
#include "extinit.h"
#include "scrnintstr.h"
#include "xkbsrv.h"

#include "xiquerydevice.h"

#include "protocol-common.h"
/*
 * Protocol testing for XIQueryDevice request and reply.
 *
 * Test approach:
 * Wrap WriteToClient to intercept server's reply. ProcXIQueryDevice returns
 * data in two batches, once for the request, once for the trailing data
 * with the device information.
 * Repeatedly test with varying deviceids and check against data in reply.
 */

struct test_data {
    int which_device;
    int num_devices_in_reply;
};

static void reply_XIQueryDevice_data(ClientPtr client, int len, char *data, void *userdata);
static void reply_XIQueryDevice(ClientPtr client, int len, char* data, void *userdata);

/* reply handling for the first bytes that constitute the reply */
static void reply_XIQueryDevice(ClientPtr client, int len, char* data, void *userdata)
{
    xXIQueryDeviceReply *rep = (xXIQueryDeviceReply*)data;
    struct test_data *querydata = (struct test_data*)userdata;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swaps(&rep->num_devices, n);
    }

    reply_check_defaults(rep, len, XIQueryDevice);

    if (querydata->which_device == XIAllDevices)
        assert(rep->num_devices == devices.num_devices);
    else if (querydata->which_device == XIAllMasterDevices)
        assert(rep->num_devices == devices.num_master_devices);
    else
        assert(rep->num_devices == 1);

    querydata->num_devices_in_reply = rep->num_devices;
    reply_handler = reply_XIQueryDevice_data;
}

/* reply handling for the trailing bytes that constitute the device info */
static void reply_XIQueryDevice_data(ClientPtr client, int len, char *data, void *userdata)
{
    char n;
    int i, j;
    struct test_data *querydata = (struct test_data*)userdata;

    DeviceIntPtr dev;
    xXIDeviceInfo *info = (xXIDeviceInfo*)data;
    xXIAnyInfo *any;

    for (i = 0; i < querydata->num_devices_in_reply; i++)
    {
        if (client->swapped)
        {
            swaps(&info->deviceid, n);
            swaps(&info->attachment, n);
            swaps(&info->use, n);
            swaps(&info->num_classes, n);
            swaps(&info->name_len, n);
        }

        if (querydata->which_device > XIAllMasterDevices)
            assert(info->deviceid == querydata->which_device);

        assert(info->deviceid >=  2); /* 0 and 1 is reserved */


        switch(info->deviceid)
        {
            case 2:  /* VCP */
                dev = devices.vcp;
                assert(info->use == XIMasterPointer);
                assert(info->attachment == devices.vck->id);
                assert(info->num_classes == 3); /* 2 axes + button */
                break;
            case 3:  /* VCK */
                dev = devices.vck;
                assert(info->use == XIMasterKeyboard);
                assert(info->attachment == devices.vcp->id);
                assert(info->num_classes == 1);
                break;
            case 4:  /* mouse */
                dev = devices.mouse;
                assert(info->use == XISlavePointer);
                assert(info->attachment == devices.vcp->id);
                assert(info->num_classes == 3); /* 2 axes + button */
                break;
            case 5:  /* keyboard */
                dev = devices.kbd;
                assert(info->use == XISlaveKeyboard);
                assert(info->attachment == devices.vck->id);
                assert(info->num_classes == 1);
                break;

            default:
                /* We shouldn't get here */
                assert(0);
                break;
        }
        assert(info->enabled == dev->enabled);
        assert(info->name_len == strlen(dev->name));
        assert(strncmp((char*)&info[1], dev->name, info->name_len) == 0);

        any = (xXIAnyInfo*)((char*)&info[1] + ((info->name_len + 3)/4) * 4);
        for (j = 0; j < info->num_classes; j++)
        {
            if (client->swapped)
            {
                swaps(&any->type, n);
                swaps(&any->length, n);
                swaps(&any->sourceid, n);
            }

            switch(info->deviceid)
            {
                case 3: /* VCK and kbd have the same properties */
                case 5:
                    {
                        int k;
                        xXIKeyInfo *ki = (xXIKeyInfo*)any;
                        XkbDescPtr xkb = devices.vck->key->xkbInfo->desc;
                        uint32_t *kc;

                        if (client->swapped)
                            swaps(&ki->num_keycodes, n);

                        assert(any->type == XIKeyClass);
                        assert(ki->num_keycodes == (xkb->max_key_code - xkb->min_key_code + 1));
                        assert(any->length == (2 + ki->num_keycodes));

                        kc = (uint32_t*)&ki[1];
                        for (k = 0; k < ki->num_keycodes; k++, kc++)
                        {
                            if (client->swapped)
                                swapl(kc, n);

                            assert(*kc >= xkb->min_key_code);
                            assert(*kc <= xkb->max_key_code);
                        }
                        break;
                    }
                case 2: /* VCP and mouse have the same properties */
                case 4:
                    {
                        assert(any->type == XIButtonClass ||
                                any->type == XIValuatorClass);

                        if (any->type == XIButtonClass)
                        {
                            int len;
                            xXIButtonInfo *bi = (xXIButtonInfo*)any;

                            if (client->swapped)
                                swaps(&bi->num_buttons, n);

                            assert(bi->num_buttons == devices.vcp->button->numButtons);

                            len = 2 + bi->num_buttons + bytes_to_int32(bits_to_bytes(bi->num_buttons));
                            assert(bi->length == len);
                        } else if (any->type == XIValuatorClass)
                        {
                            xXIValuatorInfo *vi = (xXIValuatorInfo*)any;

                            if (client->swapped)
                            {
                                swaps(&vi->number, n);
                                swapl(&vi->label, n);
                                swapl(&vi->min.integral, n);
                                swapl(&vi->min.frac, n);
                                swapl(&vi->max.integral, n);
                                swapl(&vi->max.frac, n);
                                swapl(&vi->resolution, n);
                            }

                            assert(vi->length == 11);
                            assert(vi->number == 0 ||
                                     vi->number == 1);
                            assert(vi->mode == XIModeRelative);
                            /* device was set up as relative, so standard
                             * values here. */
                            assert(vi->min.integral == -1);
                            assert(vi->min.frac == 0);
                            assert(vi->max.integral == -1);
                            assert(vi->max.frac == 0);
                            assert(vi->resolution == 0);
                        }
                    }
                    break;
            }
            any = (xXIAnyInfo*)(((char*)any) + any->length * 4);
        }

        info = (xXIDeviceInfo*)any;
    }
}

static void request_XIQueryDevice(struct test_data *querydata,
                                 int deviceid, int error)
{
    int rc;
    char n;
    ClientRec client;
    xXIQueryDeviceReq request;

    request_init(&request, XIQueryDevice);
    client = init_client(request.length, &request);
    reply_handler = reply_XIQueryDevice;

    querydata->which_device = deviceid;

    request.deviceid = deviceid;
    rc = ProcXIQueryDevice(&client);
    assert(rc == error);

    if (rc != Success)
        assert(client.errorValue == deviceid);

    reply_handler = reply_XIQueryDevice;

    client.swapped = TRUE;
    swaps(&request.length, n);
    swaps(&request.deviceid, n);
    rc = SProcXIQueryDevice(&client);
    assert(rc == error);

    if (rc != Success)
        assert(client.errorValue == deviceid);
}

static void test_XIQueryDevice(void)
{
    int i;
    xXIQueryDeviceReq request;
    struct test_data data;

    reply_handler = reply_XIQueryDevice;
    userdata = &data;
    request_init(&request, XIQueryDevice);

    printf("Testing XIAllDevices.\n");
    request_XIQueryDevice(&data, XIAllDevices, Success);
    printf("Testing XIAllMasterDevices.\n");
    request_XIQueryDevice(&data, XIAllMasterDevices, Success);

    printf("Testing existing device ids.\n");
    for (i = 2; i < 6; i++)
        request_XIQueryDevice(&data, i, Success);

    printf("Testing non-existing device ids.\n");
    for (i = 6; i <= 0xFFFF; i++)
        request_XIQueryDevice(&data, i, BadDevice);


    reply_handler = NULL;

}

int main(int argc, char** argv)
{
    init_simple();

    test_XIQueryDevice();

    return 0;
}

/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIQueryPointer request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xiquerypointer.h"
#include "exevents.h"

#include "protocol-common.h"

static ClientRec client_request;
static void reply_XIQueryPointer_data(ClientPtr client, int len,
                                      char *data, void *userdata);

static struct {
    DeviceIntPtr dev;
    WindowPtr win;
} test_data;


/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

static void reply_XIQueryPointer(ClientPtr client, int len, char *data,
                                 void *userdata)
{
    xXIQueryPointerReply *rep = (xXIQueryPointerReply*)data;
    SpritePtr sprite;

    if (!rep->repType)
        return;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swapl(&rep->root, n);
        swapl(&rep->child, n);
        swapl(&rep->root_x, n);
        swapl(&rep->root_y, n);
        swapl(&rep->win_x, n);
        swapl(&rep->win_y, n);
        swaps(&rep->buttons_len, n);
    }

    reply_check_defaults(rep, len, XIQueryPointer);

    assert(rep->root == root.drawable.id);
    assert(rep->same_screen == xTrue);

    sprite = test_data.dev->spriteInfo->sprite;
    assert((rep->root_x >> 16) == sprite->hot.x);
    assert((rep->root_y >> 16) == sprite->hot.y);

    if (test_data.win == &root)
    {
        assert(rep->root_x == rep->win_x);
        assert(rep->root_y == rep->win_y);
        assert(rep->child == window.drawable.id);
    } else
    {
        int x, y;

        x = sprite->hot.x - window.drawable.x;
        y = sprite->hot.y - window.drawable.y;

        assert((rep->win_x >> 16) == x);
        assert((rep->win_y >> 16) == y);
        assert(rep->child == None);
    }


    assert(rep->same_screen == xTrue);

    reply_handler = reply_XIQueryPointer_data;
}

static void reply_XIQueryPointer_data(ClientPtr client, int len, char *data, void *userdata)
{
    reply_handler = reply_XIQueryPointer;
}

static void request_XIQueryPointer(ClientPtr client, xXIQueryPointerReq* req, int error)
{
    char n;
    int rc;

    rc = ProcXIQueryPointer(&client_request);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client_request.errorValue == req->deviceid);

    client_request.swapped = TRUE;
    swaps(&req->deviceid, n);
    swaps(&req->length, n);
    rc = SProcXIQueryPointer(&client_request);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client_request.errorValue == req->deviceid);
}

static void test_XIQueryPointer(void)
{
    int i;
    xXIQueryPointerReq request;

    memset(&request, 0, sizeof(request));

    request_init(&request, XIQueryPointer);

    reply_handler = reply_XIQueryPointer;

    client_request = init_client(request.length, &request);

    request.deviceid = XIAllDevices;
    request_XIQueryPointer(&client_request, &request, BadDevice);

    request.deviceid = XIAllMasterDevices;
    request_XIQueryPointer(&client_request, &request, BadDevice);

    request.win = root.drawable.id;
    test_data.win = &root;

    test_data.dev = devices.vcp;
    request.deviceid = devices.vcp->id;
    request_XIQueryPointer(&client_request, &request, Success);
    request.deviceid = devices.vck->id;
    request_XIQueryPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.mouse->id;
    request_XIQueryPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.kbd->id;
    request_XIQueryPointer(&client_request, &request, BadDevice);

    test_data.dev = devices.mouse;
    devices.mouse->master = NULL; /* Float, kind-of */
    request.deviceid = devices.mouse->id;
    request_XIQueryPointer(&client_request, &request, Success);

    for (i = devices.kbd->id + 1; i <= 0xFFFF; i++)
    {
        request.deviceid = i;
        request_XIQueryPointer(&client_request, &request, BadDevice);
    }

    request.win = window.drawable.id;

    test_data.dev = devices.vcp;
    test_data.win = &window;
    request.deviceid = devices.vcp->id;
    request_XIQueryPointer(&client_request, &request, Success);

    test_data.dev = devices.mouse;
    request.deviceid = devices.mouse->id;
    request_XIQueryPointer(&client_request, &request, Success);
}

int main(int argc, char** argv)
{
    init_simple();

    test_XIQueryPointer();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIQueryVersion request and reply.
 *
 * Test approach:
 * Wrap WriteToClient to intercept the server's reply.
 * Repeatedly test a client/server version combination, compare version in
 * reply with versions given. Version must be equal to either
 * server version or client version, whichever is smaller.
 * Client version less than 2 must return BadValue.
 */

#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "extinit.h" /* for XInputExtensionInit */
#include "scrnintstr.h"
#include "xiqueryversion.h"

#include "protocol-common.h"

extern XExtensionVersion XIVersion;

struct test_data {
    int major_client;
    int minor_client;
    int major_server;
    int minor_server;
};

static void reply_XIQueryVersion(ClientPtr client, int len, char* data, void *userdata)
{
    xXIQueryVersionReply *rep = (xXIQueryVersionReply*)data;
    struct test_data *versions = (struct test_data*)userdata;
    unsigned int sver, cver, ver;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swaps(&rep->major_version, n);
        swaps(&rep->minor_version, n);
    }

    reply_check_defaults(rep, len, XIQueryVersion);

    assert(rep->length == 0);

    sver = versions->major_server * 1000 + versions->minor_server;
    cver = versions->major_client * 1000 + versions->minor_client;
    ver = rep->major_version * 1000 + rep->minor_version;

    assert(ver >= 2000);
    assert((sver > cver) ? ver == cver : ver == sver);
}

/**
 * Run a single test with server version smaj.smin and client
 * version cmaj.cmin. Verify that return code is equal to 'error'.
 *
 * Test is run normal, then for a swapped client.
 */
static void request_XIQueryVersion(int smaj, int smin, int cmaj, int cmin, int error)
{
    char n;
    int rc;
    struct test_data versions;
    xXIQueryVersionReq request;
    ClientRec client;

    request_init(&request, XIQueryVersion);
    client = init_client(request.length, &request);
    userdata = (void*)&versions;

    /* Change the server to support smaj.smin */
    XIVersion.major_version = smaj;
    XIVersion.minor_version = smin;

    /* remember versions we send and expect */
    versions.major_client = cmaj;
    versions.minor_client = cmin;
    versions.major_server = XIVersion.major_version;
    versions.minor_server = XIVersion.minor_version;

    request.major_version = versions.major_client;
    request.minor_version = versions.minor_client;
    rc = ProcXIQueryVersion(&client);
    assert(rc == error);

    client.swapped = TRUE;

    swaps(&request.length, n);
    swaps(&request.major_version, n);
    swaps(&request.minor_version, n);

    rc = SProcXIQueryVersion(&client);
    assert(rc == error);
}

/* Client version less than 2.0 must return BadValue, all other combinations
 * Success */
static void test_XIQueryVersion(void)
{
    reply_handler = reply_XIQueryVersion;

    printf("Server version 2.0 - client versions [1..3].0\n");
    /* some simple tests to catch common errors quickly */
    request_XIQueryVersion(2, 0, 1, 0, BadValue);
    request_XIQueryVersion(2, 0, 2, 0, Success);
    request_XIQueryVersion(2, 0, 3, 0, Success);

    printf("Server version 3.0 - client versions [1..3].0\n");
    request_XIQueryVersion(3, 0, 1, 0, BadValue);
    request_XIQueryVersion(3, 0, 2, 0, Success);
    request_XIQueryVersion(3, 0, 3, 0, Success);

    printf("Server version 2.0 - client versions [1..3].[1..3]\n");
    request_XIQueryVersion(2, 0, 1, 1, BadValue);
    request_XIQueryVersion(2, 0, 2, 2, Success);
    request_XIQueryVersion(2, 0, 3, 3, Success);

    printf("Server version 2.2 - client versions [1..3].0\n");
    request_XIQueryVersion(2, 2, 1, 0, BadValue);
    request_XIQueryVersion(2, 2, 2, 0, Success);
    request_XIQueryVersion(2, 2, 3, 0, Success);

#if 0
    /* this one takes a while */
    unsigned int cmin, cmaj, smin, smaj;

    printf("Testing all combinations.\n");
    for (smaj = 2; smaj <= 0xFFFF; smaj++)
        for (smin = 0; smin <= 0xFFFF; smin++)
            for (cmin = 0; cmin <= 0xFFFF; cmin++)
                for (cmaj = 0; cmaj <= 0xFFFF; cmaj++)
                {
                    int error = (cmaj < 2) ? BadValue : Success;
                    request_XIQueryVersion(smaj, smin, cmaj, cmin, error);
                }

#endif

    reply_handler = NULL;
}

int main(int argc, char** argv)
{
    init_simple();

    test_XIQueryVersion();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XISelectEvents request.
 *
 * Test approach:
 *
 * Wrap XISetEventMask to intercept when the server tries to apply the event
 * mask. Ensure that the mask passed in is equivalent to the one supplied by
 * the client. Ensure that invalid devices and invalid masks return errors
 * as appropriate.
 *
 * Tests included:
 * BadValue for num_masks < 0
 * BadWindow for invalid windows
 * BadDevice for non-existing devices
 * BadImplemenation for devices >= 0xFF
 * BadValue if HierarchyChanged bit is set for devices other than
 *          XIAllDevices
 * BadValue for invalid mask bits
 * Sucecss for excessive mask lengths
 *
 */

#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "extinit.h" /* for XInputExtensionInit */
#include "scrnintstr.h"
#include "xiselectev.h"

#include "protocol-common.h"

static unsigned char *data[4096 * 20]; /* the request data buffer */

int __wrap_XISetEventMask(DeviceIntPtr dev, WindowPtr win, int len, unsigned char* mask)
{
    return Success;
}

/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}


static void request_XISelectEvent(xXISelectEventsReq *req, int error)
{
    char n;
    int i;
    int rc;
    ClientRec client;
    xXIEventMask *mask, *next;

    req->length = (sz_xXISelectEventsReq/4);
    mask = (xXIEventMask*)&req[1];
    for (i = 0; i < req->num_masks; i++)
    {
        req->length += sizeof(xXIEventMask)/4 + mask->mask_len;
        mask = (xXIEventMask*)((char*)&mask[1] + mask->mask_len * 4);
    }

    client = init_client(req->length, req);

    rc = ProcXISelectEvents(&client);
    assert(rc == error);

    client.swapped = TRUE;

    mask = (xXIEventMask*)&req[1];
    for (i = 0; i < req->num_masks; i++)
    {
        next = (xXIEventMask*)((char*)&mask[1] + mask->mask_len * 4);
        swaps(&mask->deviceid, n);
        swaps(&mask->mask_len, n);
        mask = next;
    }

    swapl(&req->win, n);
    swaps(&req->length, n);
    swaps(&req->num_masks, n);
    rc = SProcXISelectEvents(&client);
    assert(rc == error);
}

static void request_XISelectEvents_masks(xXISelectEventsReq *req)
{
    int i, j;
    xXIEventMask *mask;
    int nmasks = (XI2LASTEVENT + 7)/8;
    unsigned char *bits;

    mask = (xXIEventMask*)&req[1];
    req->win = ROOT_WINDOW_ID;

    /* if a clients submits more than 100 masks, consider it insane and untested */
    for (i = 1; i <= 1000; i++)
    {
        req->num_masks = i;
        mask->deviceid = XIAllDevices;

        /* Test 0:
         * mask_len is 0 -> Success
         */
        mask->mask_len = 0;
        request_XISelectEvent(req, Success);

        /* Test 1:
         * mask may be larger than needed for XI2LASTEVENT.
         * Test setting each valid mask bit, while leaving unneeded bits 0.
         * -> Success
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4 * 10;
        memset(bits, 0, mask->mask_len * 4);
        for (j = 0; j <= XI2LASTEVENT; j++)
        {
            SetBit(bits, j);
            request_XISelectEvent(req, Success);
            ClearBit(bits, j);
        }

        /* Test 2:
         * mask may be larger than needed for XI2LASTEVENT.
         * Test setting all valid mask bits, while leaving unneeded bits 0.
         * -> Success
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4 * 10;
        memset(bits, 0, mask->mask_len * 4);

        for (j = 0; j <= XI2LASTEVENT; j++)
        {
            SetBit(bits, j);
            request_XISelectEvent(req, Success);
        }

        /* Test 3:
         * mask is larger than needed for XI2LASTEVENT. If any unneeded bit
         * is set -> BadValue
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4 * 10;
        memset(bits, 0, mask->mask_len * 4);

        for (j = XI2LASTEVENT + 1; j < mask->mask_len * 4; j++)
        {
            SetBit(bits, j);
            request_XISelectEvent(req, BadValue);
            ClearBit(bits, j);
        }

        /* Test 4:
         * Mask len is a sensible length, only valid bits are set -> Success
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4;
        memset(bits, 0, mask->mask_len * 4);
        for (j = 0; j <= XI2LASTEVENT; j++)
        {
            SetBit(bits, j);
            request_XISelectEvent(req, Success);
        }

        /* Test 5:
         * HierarchyChanged bit is BadValue for devices other than
         * XIAllDevices
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4;
        memset(bits, 0, mask->mask_len * 4);
        SetBit(bits, XI_HierarchyChanged);
        mask->deviceid = XIAllDevices;
        request_XISelectEvent(req, Success);
        for (j = 1; j < devices.num_devices; j++)
        {
            mask->deviceid = j;
            request_XISelectEvent(req, BadValue);
        }

        /* Test 6:
         * All bits set minus hierarchy changed bit -> Success
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4;
        memset(bits, 0, mask->mask_len * 4);
        for (j = 0; j <= XI2LASTEVENT; j++)
            SetBit(bits, j);
        ClearBit(bits, XI_HierarchyChanged);
        for (j = 1; j < 6; j++)
        {
            mask->deviceid = j;
            request_XISelectEvent(req, Success);
        }

        mask = (xXIEventMask*)((char*)mask + sizeof(xXIEventMask) + mask->mask_len * 4);
    }
}

static void test_XISelectEvents(void)
{
    int i;
    xXIEventMask *mask;
    xXISelectEventsReq *req;
    req = (xXISelectEventsReq*)data;

    request_init(req, XISelectEvents);

    printf("Testing for BadValue on zero-length masks\n");
    /* zero masks are BadValue, regardless of the window */
    req->num_masks = 0;

    req->win = None;
    request_XISelectEvent(req, BadValue);

    req->win = ROOT_WINDOW_ID;
    request_XISelectEvent(req, BadValue);

    req->win = CLIENT_WINDOW_ID;
    request_XISelectEvent(req, BadValue);

    printf("Testing for BadWindow.\n");
    /* None window is BadWindow, regardless of the masks.
     * We don't actually need to set the masks here, BadWindow must occur
     * before checking the masks.
     */
    req->win = None;
    req->num_masks = 1;
    request_XISelectEvent(req, BadWindow);

    req->num_masks = 2;
    request_XISelectEvent(req, BadWindow);

    req->num_masks = 0xFF;
    request_XISelectEvent(req, BadWindow);

    /* request size is 3, so 0xFFFC is the highest num_mask that doesn't
     * overflow req->length */
    req->num_masks = 0xFFFC;
    request_XISelectEvent(req, BadWindow);

    printf("Triggering num_masks/length overflow\n");
    req->win = ROOT_WINDOW_ID;
    /* Integer overflow - req->length can't hold that much */
    req->num_masks = 0xFFFF;
    request_XISelectEvent(req, BadLength);

    req->win = ROOT_WINDOW_ID;
    req->num_masks = 1;

    printf("Triggering bogus mask length error\n");
    mask = (xXIEventMask*)&req[1];
    mask->deviceid = 0;
    mask->mask_len = 0xFFFF;
    request_XISelectEvent(req, BadLength);

    /* testing various device ids */
    printf("Testing existing device ids.\n");
    for (i = 0; i < 6; i++)
    {
        mask = (xXIEventMask*)&req[1];
        mask->deviceid = i;
        mask->mask_len = 1;
        req->win = ROOT_WINDOW_ID;
        req->num_masks = 1;
        request_XISelectEvent(req, Success);
    }

    printf("Testing non-existing device ids.\n");
    for (i = 6; i <= 0xFFFF; i++)
    {
        req->win = ROOT_WINDOW_ID;
        req->num_masks = 1;
        mask = (xXIEventMask*)&req[1];
        mask->deviceid = i;
        mask->mask_len = 1;
        request_XISelectEvent(req, BadDevice);
    }

    request_XISelectEvents_masks(req);
}

int main(int argc, char** argv)
{
    init_simple();

    test_XISelectEvents();

    return 0;
}

/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XISetClientPointer request.
 *
 * Tests include:
 * BadDevice of all devices except master pointers.
 * Success for a valid window.
 * Success for window None.
 * BadWindow for invalid windows.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "extinit.h" /* for XInputExtensionInit */
#include "scrnintstr.h"
#include "xisetclientpointer.h"
#include "exevents.h"

#include "protocol-common.h"

static ClientRec client_window;
static ClientRec client_request;

int __wrap_dixLookupClient(ClientPtr *pClient, XID rid, ClientPtr client, Mask access)
{
    if (rid == ROOT_WINDOW_ID)
        return BadWindow;

    if (rid == CLIENT_WINDOW_ID)
    {
        *pClient = &client_window;
        return Success;
    }

    return __real_dixLookupClient(pClient, rid, client, access);
}

static void request_XISetClientPointer(xXISetClientPointerReq* req, int error)
{
    char n;
    int rc;
    client_request = init_client(req->length, req);

    rc = ProcXISetClientPointer(&client_request);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client_request.errorValue == req->deviceid);

    client_request.swapped = TRUE;
    swapl(&req->win, n);
    swaps(&req->length, n);
    swaps(&req->deviceid, n);
    rc = SProcXISetClientPointer(&client_request);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client_request.errorValue == req->deviceid);

}

static void test_XISetClientPointer(void)
{
    int i;
    xXISetClientPointerReq request;

    request_init(&request, XISetClientPointer);

    request.win = CLIENT_WINDOW_ID;

    printf("Testing BadDevice error for XIAllDevices and XIMasterDevices.\n");
    request.deviceid = XIAllDevices;
    request_XISetClientPointer(&request, BadDevice);

    request.deviceid = XIAllMasterDevices;
    request_XISetClientPointer(&request, BadDevice);

    printf("Testing Success for VCP and VCK.\n");
    request.deviceid = devices.vcp->id; /* 2 */
    request_XISetClientPointer(&request, Success);
    assert(client_window.clientPtr->id == 2);

    request.deviceid = devices.vck->id; /* 3 */
    request_XISetClientPointer(&request, Success);
    assert(client_window.clientPtr->id == 2);

    printf("Testing BadDevice error for all other devices.\n");
    for (i = 4; i <= 0xFFFF; i++)
    {
        request.deviceid = i;
        request_XISetClientPointer(&request, BadDevice);
    }

    printf("Testing window None\n");
    request.win = None;
    request.deviceid = devices.vcp->id; /* 2 */
    request_XISetClientPointer(&request, Success);
    assert(client_request.clientPtr->id == 2);

    printf("Testing invalid window\n");
    request.win = INVALID_WINDOW_ID;
    request.deviceid = devices.vcp->id;
    request_XISetClientPointer(&request, BadWindow);

}


int main(int argc, char** argv)
{
    init_simple();
    client_window = init_client(0, NULL);

    test_XISetClientPointer();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIWarpPointer request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xiwarppointer.h"
#include "exevents.h"

#include "protocol-common.h"

static int expected_x = SPRITE_X;
static int expected_y = SPRITE_Y;

/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

/**
 * This function overrides the one in the screen rec.
 */
static Bool ScreenSetCursorPosition(DeviceIntPtr dev, ScreenPtr screen,
                                    int x, int y, Bool generateEvent)
{
    assert(x == expected_x);
    assert(y == expected_y);
    return TRUE;
}


static void request_XIWarpPointer(ClientPtr client, xXIWarpPointerReq* req,
        int error)
{
    char n;
    int rc;

    rc = ProcXIWarpPointer(client);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client->errorValue == req->deviceid);
    else if (rc == BadWindow)
        assert(client->errorValue == req->dst_win ||
                 client->errorValue == req->src_win);


    client->swapped = TRUE;

    swapl(&req->src_win, n);
    swapl(&req->dst_win, n);
    swapl(&req->src_x, n);
    swapl(&req->src_y, n);
    swapl(&req->dst_x, n);
    swapl(&req->dst_y, n);
    swaps(&req->src_width, n);
    swaps(&req->src_height, n);
    swaps(&req->deviceid, n);

    rc = SProcXIWarpPointer(client);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client->errorValue == req->deviceid);
    else if (rc == BadWindow)
        assert(client->errorValue == req->dst_win ||
                 client->errorValue == req->src_win);

    client->swapped = FALSE;
}

static void test_XIWarpPointer(void)
{
    int i;
    ClientRec client_request;
    xXIWarpPointerReq request;

    memset(&request, 0, sizeof(request));

    request_init(&request, XIWarpPointer);

    client_request = init_client(request.length, &request);

    request.deviceid = XIAllDevices;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    request.deviceid = XIAllMasterDevices;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    request.src_win = root.drawable.id;
    request.dst_win = root.drawable.id;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);
    request.deviceid = devices.vck->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.kbd->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    devices.mouse->master = NULL; /* Float, kind-of */
    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, Success);

    for (i = devices.kbd->id + 1; i <= 0xFFFF; i++)
    {
        request.deviceid = i;
        request_XIWarpPointer(&client_request, &request, BadDevice);
    }

    request.src_win = window.drawable.id;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.src_win = root.drawable.id;
    request.dst_win = 0xFFFF; /* invalid window */
    request_XIWarpPointer(&client_request, &request, BadWindow);

    request.src_win = 0xFFFF; /* invalid window */
    request.dst_win = root.drawable.id;
    request_XIWarpPointer(&client_request, &request, BadWindow);

    request.src_win = None;
    request.dst_win = None;

    request.dst_y = 0;
    expected_y = SPRITE_Y;

    request.dst_x = 1 << 16;
    expected_x = SPRITE_X + 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_x = -1 << 16;
    expected_x = SPRITE_X - 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_x = 0;
    expected_x = SPRITE_X;

    request.dst_y = 1 << 16;
    expected_y = SPRITE_Y + 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_y = -1 << 16;
    expected_y = SPRITE_Y - 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    /* FIXME: src_x/y checks */
}

int main(int argc, char** argv)
{
    init_simple();
    screen.SetCursorPosition = ScreenSetCursorPosition;

    test_XIWarpPointer();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "inputstr.h"
#include "opaque.h"
#include "property.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "../xkb/xkbgeom.h"
#include <X11/extensions/XKMformat.h>
#include "xkbfile.h"
#include "../xkb/xkb.h"
#include <assert.h>

/**
 * Initialize an empty XkbRMLVOSet.
 * Call XkbGetRulesDflts to obtain the default ruleset.
 * Compare obtained ruleset with the built-in defaults.
 *
 * Result: RMLVO defaults are the same as obtained.
 */
static void xkb_get_rules_test(void)
{
    XkbRMLVOSet rmlvo = { NULL};
    XkbGetRulesDflts(&rmlvo);


    assert(rmlvo.rules);
    assert(rmlvo.model);
    assert(rmlvo.layout);
    assert(rmlvo.variant);
    assert(rmlvo.options);
    assert(strcmp(rmlvo.rules, XKB_DFLT_RULES) == 0);
    assert(strcmp(rmlvo.model, XKB_DFLT_MODEL) == 0);
    assert(strcmp(rmlvo.layout, XKB_DFLT_LAYOUT) == 0);
    assert(strcmp(rmlvo.variant, XKB_DFLT_VARIANT) == 0);
    assert(strcmp(rmlvo.options, XKB_DFLT_OPTIONS) == 0);
}

/**
 * Initialize an random XkbRMLVOSet.
 * Call XkbGetRulesDflts to obtain the default ruleset.
 * Compare obtained ruleset with the built-in defaults.
 * Result: RMLVO defaults are the same as obtained.
 */
static void xkb_set_rules_test(void)
{
    XkbRMLVOSet rmlvo = {
        .rules = "test-rules",
        .model = "test-model",
        .layout = "test-layout",
        .variant = "test-variant",
        .options = "test-options"
    };
    XkbRMLVOSet rmlvo_new = { NULL };

    XkbSetRulesDflts(&rmlvo);
    XkbGetRulesDflts(&rmlvo_new);

    /* XkbGetRulesDflts strdups the values */
    assert(rmlvo.rules != rmlvo_new.rules);
    assert(rmlvo.model != rmlvo_new.model);
    assert(rmlvo.layout != rmlvo_new.layout);
    assert(rmlvo.variant != rmlvo_new.variant);
    assert(rmlvo.options != rmlvo_new.options);

    assert(strcmp(rmlvo.rules, rmlvo_new.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_new.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_new.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_new.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_new.options) == 0);
}


/**
 * Get the default RMLVO set.
 * Set the default RMLVO set.
 * Get the default RMLVO set.
 * Repeat the last two steps.
 *
 * Result: RMLVO set obtained is the same as previously set.
 */
static void xkb_set_get_rules_test(void)
{
/* This test failed before XkbGetRulesDftlts changed to strdup.
   We test this twice because the first time using XkbGetRulesDflts we obtain
   the built-in defaults. The unexpected free isn't triggered until the second
   XkbSetRulesDefaults.
 */
    XkbRMLVOSet rmlvo = { NULL };
    XkbRMLVOSet rmlvo_backup;

    XkbGetRulesDflts(&rmlvo);

    /* pass 1 */
    XkbSetRulesDflts(&rmlvo);
    XkbGetRulesDflts(&rmlvo);

    /* Make a backup copy */
    rmlvo_backup.rules = strdup(rmlvo.rules);
    rmlvo_backup.layout = strdup(rmlvo.layout);
    rmlvo_backup.model = strdup(rmlvo.model);
    rmlvo_backup.variant = strdup(rmlvo.variant);
    rmlvo_backup.options = strdup(rmlvo.options);

    /* pass 2 */
    XkbSetRulesDflts(&rmlvo);

    /* This test is iffy, because strictly we may be comparing against already
     * freed memory */
    assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);

    XkbGetRulesDflts(&rmlvo);
    assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);
}


int main(int argc, char** argv)
{
    xkb_set_get_rules_test();
    xkb_get_rules_test();
    xkb_set_rules_test();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif
#include <stdint.h>
#include <X11/Xatom.h>
#include "input.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "exevents.h"
#include "xkbsrv.h"
#include "xserver-properties.h"

/**
 */

/* from Xext/xtest.c */
extern DeviceIntPtr xtestpointer, xtestkeyboard;

/* Needed for the screen setup, otherwise we crash during sprite initialization */
static Bool device_cursor_init(DeviceIntPtr dev, ScreenPtr screen) { return TRUE; }

static void xtest_init_devices(void)
{
    ScreenRec screen;

    /* random stuff that needs initialization */
    memset(&screen, 0, sizeof(screen));
    screenInfo.numScreens = 1;
    screenInfo.screens[0] = &screen;
    screen.myNum = 0;
    screen.id = 100;
    screen.width = 640;
    screen.height = 480;
    screen.DeviceCursorInitialize = device_cursor_init;
    dixResetPrivates();
    InitAtoms();

    XkbInitPrivates();

    /* this also inits the xtest devices */
    InitCoreDevices();

    assert(xtestpointer);
    assert(xtestkeyboard);
    assert(IsXTestDevice(xtestpointer, NULL));
    assert(IsXTestDevice(xtestkeyboard, NULL));
    assert(IsXTestDevice(xtestpointer, inputInfo.pointer));
    assert(IsXTestDevice(xtestkeyboard, inputInfo.keyboard));
    assert(GetXTestDevice(inputInfo.pointer) == xtestpointer);
    assert(GetXTestDevice(inputInfo.keyboard) == xtestkeyboard);
}

/**
 * Each xtest devices has a property attached marking it. This property
 * cannot be changed.
 */
static void xtest_properties(void)
{
    int rc;
    char value = 1;
    XIPropertyValuePtr prop;
    Atom xtest_prop = XIGetKnownProperty(XI_PROP_XTEST_DEVICE);

    rc = XIGetDeviceProperty(xtestpointer, xtest_prop, &prop);
    assert(rc == Success);
    assert(prop);

    rc = XIGetDeviceProperty(xtestkeyboard, xtest_prop, &prop);
    assert(rc == Success);
    assert(prop != NULL);

    rc = XIChangeDeviceProperty(xtestpointer, xtest_prop,
                                XA_INTEGER, 8, PropModeReplace, 1, &value, FALSE);
    assert(rc == BadAccess);
    rc = XIChangeDeviceProperty(xtestkeyboard, xtest_prop,
                                XA_INTEGER, 8, PropModeReplace, 1, &value, FALSE);
    assert(rc == BadAccess);
}



int main(int argc, char** argv)
{
    xtest_init_devices();
    xtest_properties();

    return 0;
}


/*

Copyright 1992, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include <X11/extensions/bigreqsproto.h>
#include "opaque.h"
#include "modinit.h"

void BigReqExtensionInit(INITARGS);

static int
ProcBigReqDispatch (ClientPtr client)
{
    REQUEST(xBigReqEnableReq);
    xBigReqEnableReply rep;
     int n;

    if (client->swapped) {
	swaps(&stuff->length, n);
    }
    if (stuff->brReqType != X_BigReqEnable)
	return BadRequest;
    REQUEST_SIZE_MATCH(xBigReqEnableReq);
    client->big_requests = TRUE;
    memset(&rep, 0, sizeof(xBigReqEnableReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.max_request_size = maxBigRequestSize;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.max_request_size, n);
    }
    WriteToClient(client, sizeof(xBigReqEnableReply), (char *)&rep);
    return Success;
}

void
BigReqExtensionInit(INITARGS)
{
    AddExtension(XBigReqExtensionName, 0, 0,
		 ProcBigReqDispatch, ProcBigReqDispatch,
		 NULL, StandardMinorOpcode);
}
/*****************************************************************

Copyright (c) 1996 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING, 
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation 
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital 
Equipment Corporation.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "opaque.h"
#include <X11/extensions/dpmsproto.h>
#include "dpmsproc.h"
#include "modinit.h"

static int
ProcDPMSGetVersion(ClientPtr client)
{
    /* REQUEST(xDPMSGetVersionReq); */
    xDPMSGetVersionReply rep;
    int n;

    REQUEST_SIZE_MATCH(xDPMSGetVersionReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = DPMSMajorVersion;
    rep.minorVersion = DPMSMinorVersion;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xDPMSGetVersionReply), (char *)&rep);
    return Success;
}

static int
ProcDPMSCapable(ClientPtr client)
{
    /* REQUEST(xDPMSCapableReq); */
    xDPMSCapableReply rep;
    int n;

    REQUEST_SIZE_MATCH(xDPMSCapableReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.capable = DPMSCapableFlag;

    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
    }
    WriteToClient(client, sizeof(xDPMSCapableReply), (char *)&rep);
    return Success;
}

static int
ProcDPMSGetTimeouts(ClientPtr client)
{
    /* REQUEST(xDPMSGetTimeoutsReq); */
    xDPMSGetTimeoutsReply rep;
    int n;

    REQUEST_SIZE_MATCH(xDPMSGetTimeoutsReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.standby = DPMSStandbyTime / MILLI_PER_SECOND;
    rep.suspend = DPMSSuspendTime / MILLI_PER_SECOND;
    rep.off = DPMSOffTime / MILLI_PER_SECOND;

    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.standby, n);
	swaps(&rep.suspend, n);
	swaps(&rep.off, n);
    }
    WriteToClient(client, sizeof(xDPMSGetTimeoutsReply), (char *)&rep);
    return Success;
}

static int
ProcDPMSSetTimeouts(ClientPtr client)
{
    REQUEST(xDPMSSetTimeoutsReq);

    REQUEST_SIZE_MATCH(xDPMSSetTimeoutsReq);

    if ((stuff->off != 0)&&(stuff->off < stuff->suspend)) 
    {
	client->errorValue = stuff->off;
	return BadValue;
    }
    if ((stuff->suspend != 0)&&(stuff->suspend < stuff->standby))
    {
	client->errorValue = stuff->suspend;
	return BadValue;
    }  

    DPMSStandbyTime = stuff->standby * MILLI_PER_SECOND;
    DPMSSuspendTime = stuff->suspend * MILLI_PER_SECOND;
    DPMSOffTime = stuff->off * MILLI_PER_SECOND;
    SetScreenSaverTimer();

    return Success;
}

static int
ProcDPMSEnable(ClientPtr client)
{
    Bool was_enabled = DPMSEnabled;

    REQUEST_SIZE_MATCH(xDPMSEnableReq);

    if (DPMSCapableFlag) {
	DPMSEnabled = TRUE;
	if (!was_enabled)
	    SetScreenSaverTimer();
    }

    return Success;
}

static int
ProcDPMSDisable(ClientPtr client)
{
    /* REQUEST(xDPMSDisableReq); */

    REQUEST_SIZE_MATCH(xDPMSDisableReq);

    DPMSSet(client, DPMSModeOn);

    DPMSEnabled = FALSE;

    return Success;
}

static int
ProcDPMSForceLevel(ClientPtr client)
{
    REQUEST(xDPMSForceLevelReq);

    REQUEST_SIZE_MATCH(xDPMSForceLevelReq);

    if (!DPMSEnabled)
	return BadMatch;

    if (stuff->level != DPMSModeOn &&
        stuff->level != DPMSModeStandby &&
        stuff->level != DPMSModeSuspend &&
        stuff->level != DPMSModeOff) {
	client->errorValue = stuff->level;
	return BadValue;
    }

    DPMSSet(client, stuff->level);

    return Success;
}

static int
ProcDPMSInfo(ClientPtr client)
{
    /* REQUEST(xDPMSInfoReq); */
    xDPMSInfoReply rep;
    int n;

    REQUEST_SIZE_MATCH(xDPMSInfoReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.power_level = DPMSPowerLevel;
    rep.state = DPMSEnabled;

    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.power_level, n);
    }
    WriteToClient(client, sizeof(xDPMSInfoReply), (char *)&rep);
    return Success;
}

static int
ProcDPMSDispatch (ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
    case X_DPMSGetVersion:
	return ProcDPMSGetVersion(client);
    case X_DPMSCapable:
	return ProcDPMSCapable(client);
    case X_DPMSGetTimeouts:
	return ProcDPMSGetTimeouts(client);
    case X_DPMSSetTimeouts:
	return ProcDPMSSetTimeouts(client);
    case X_DPMSEnable:
	return ProcDPMSEnable(client);
    case X_DPMSDisable:
	return ProcDPMSDisable(client);
    case X_DPMSForceLevel:
	return ProcDPMSForceLevel(client);
    case X_DPMSInfo:
	return ProcDPMSInfo(client);
    default:
	return BadRequest;
    }
}

static int
SProcDPMSGetVersion(ClientPtr client)
{
    int n;
    REQUEST(xDPMSGetVersionReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSGetVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion, n);
    return ProcDPMSGetVersion(client);
}

static int
SProcDPMSCapable(ClientPtr client)
{
    REQUEST(xDPMSCapableReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSCapableReq);

    return ProcDPMSCapable(client);
}

static int
SProcDPMSGetTimeouts(ClientPtr client)
{
    REQUEST(xDPMSGetTimeoutsReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSGetTimeoutsReq);

    return ProcDPMSGetTimeouts(client);
}

static int
SProcDPMSSetTimeouts(ClientPtr client)
{
    REQUEST(xDPMSSetTimeoutsReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSSetTimeoutsReq);

    swaps(&stuff->standby, n);
    swaps(&stuff->suspend, n);
    swaps(&stuff->off, n);
    return ProcDPMSSetTimeouts(client);
}

static int
SProcDPMSEnable(ClientPtr client)
{
    REQUEST(xDPMSEnableReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSEnableReq);

    return ProcDPMSEnable(client);
}

static int
SProcDPMSDisable(ClientPtr client)
{
    REQUEST(xDPMSDisableReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSDisableReq);

    return ProcDPMSDisable(client);
}

static int
SProcDPMSForceLevel(ClientPtr client)
{
    REQUEST(xDPMSForceLevelReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSForceLevelReq);

    swaps(&stuff->level, n);

    return ProcDPMSForceLevel(client);
}

static int
SProcDPMSInfo(ClientPtr client)
{
    REQUEST(xDPMSInfoReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSInfoReq);

    return ProcDPMSInfo(client);
}

static int
SProcDPMSDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_DPMSGetVersion:
	return SProcDPMSGetVersion(client);
    case X_DPMSCapable:
	return SProcDPMSCapable(client);
    case X_DPMSGetTimeouts:
	return SProcDPMSGetTimeouts(client);
    case X_DPMSSetTimeouts:
	return SProcDPMSSetTimeouts(client);
    case X_DPMSEnable:
	return SProcDPMSEnable(client);
    case X_DPMSDisable:
	return SProcDPMSDisable(client);
    case X_DPMSForceLevel:
	return SProcDPMSForceLevel(client);
    case X_DPMSInfo:
	return SProcDPMSInfo(client);
    default:
	return BadRequest;
    }
}

void
DPMSExtensionInit(INITARGS)
{
    AddExtension(DPMSExtensionName, 0, 0,
		 ProcDPMSDispatch, SProcDPMSDispatch,
		 NULL, StandardMinorOpcode);
}
/* Prototypes for functions that the DDX must provide */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _DPMSPROC_H_
#define _DPMSPROC_H_

#include "dixstruct.h"

int  DPMSSet(ClientPtr client, int level);
Bool DPMSSupported(void);

#endif
/*****************************************************************

Copyright (c) 1996 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING, 
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation 
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital 
Equipment Corporation.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "dpmsproc.h"

#define FALSE 0

Bool DPMSSupported(void)
{
    return FALSE;
}

int DPMSSet(ClientPtr client, int level)
{
    return Success;
}
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif
#include "windowstr.h"
#include <X11/extensions/ge.h>

#include "geint.h"
#include "geext.h"
#include "protocol-versions.h"

DevPrivateKeyRec GEClientPrivateKeyRec;

int RT_GECLIENT  = 0;

GEExtension GEExtensions[MAXEXTENSIONS];

/* Major available requests */
static const int version_requests[] = {
    X_GEQueryVersion,	/* before client sends QueryVersion */
    X_GEQueryVersion,	/* must be set to last request in version 1 */
};

/* Forward declarations */
static void SGEGenericEvent(xEvent* from, xEvent* to);

#define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))
#define EXT_MASK(ext) ((ext) & 0x7F)

/************************************************************/
/*                request handlers                          */
/************************************************************/

static int
ProcGEQueryVersion(ClientPtr client)
{
    int n;
    GEClientInfoPtr pGEClient = GEGetClient(client);
    xGEQueryVersionReply rep;
    REQUEST(xGEQueryVersionReq);

    REQUEST_SIZE_MATCH(xGEQueryVersionReq);

    rep.repType = X_Reply;
    rep.RepType = X_GEQueryVersion;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    /* return the supported version by the server */
    rep.majorVersion = SERVER_GE_MAJOR_VERSION;
    rep.minorVersion = SERVER_GE_MINOR_VERSION;

    /* Remember version the client requested */
    pGEClient->major_version = stuff->majorVersion;
    pGEClient->minor_version = stuff->minorVersion;

    if (client->swapped)
    {
	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
    }

    WriteToClient(client, sizeof(xGEQueryVersionReply), (char*)&rep);
    return Success;
}

int (*ProcGEVector[GENumberRequests])(ClientPtr) = {
    /* Version 1.0 */
    ProcGEQueryVersion
};

/************************************************************/
/*                swapped request handlers                  */
/************************************************************/
static int
SProcGEQueryVersion(ClientPtr client)
{
    int n;
    REQUEST(xGEQueryVersionReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGEQueryVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion, n);
    return(*ProcGEVector[stuff->ReqType])(client);
}

int (*SProcGEVector[GENumberRequests])(ClientPtr) = {
    /* Version 1.0 */
    SProcGEQueryVersion
};


/************************************************************/
/*                callbacks                                 */
/************************************************************/

/* dispatch requests */
static int
ProcGEDispatch(ClientPtr client)
{
    GEClientInfoPtr pGEClient = GEGetClient(client);
    REQUEST(xGEReq);

    if (pGEClient->major_version >= NUM_VERSION_REQUESTS)
        return BadRequest;
    if (stuff->ReqType > version_requests[pGEClient->major_version])
        return BadRequest;

    return (ProcGEVector[stuff->ReqType])(client);
}

/* dispatch swapped requests */
static int
SProcGEDispatch(ClientPtr client)
{
    REQUEST(xGEReq);
    if (stuff->ReqType >= GENumberRequests)
        return BadRequest;
    return (*SProcGEVector[stuff->ReqType])(client);
}

/**
 * Called when a new client inits a connection to the X server.
 *
 * We alloc a simple struct to store the client's major/minor version. Can be
 * used in the furture for versioning support.
 */
static void
GEClientCallback(CallbackListPtr *list,
                 pointer closure,
                 pointer data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    GEClientInfoPtr     pGEClient = GEGetClient(pClient);

    pGEClient->major_version = 0;
    pGEClient->minor_version = 0;
}

/* Reset extension. Called on server shutdown. */
static void
GEResetProc(ExtensionEntry *extEntry)
{
    DeleteCallback(&ClientStateCallback, GEClientCallback, 0);
    EventSwapVector[GenericEvent] = NotImplemented;
}

/*  Calls the registered event swap function for the extension.
 *
 *  Each extension can register a swap function to handle GenericEvents being
 *  swapped properly. The server calls SGEGenericEvent() before the event is
 *  written on the wire, this one calls the registered swap function to do the
 *  work.
 */
static void
SGEGenericEvent(xEvent* from, xEvent* to)
{
    xGenericEvent* gefrom = (xGenericEvent*)from;
    xGenericEvent* geto = (xGenericEvent*)to;

    if ((gefrom->extension & 0x7f) > MAXEXTENSIONS)
    {
        ErrorF("GE: Invalid extension offset for event.\n");
        return;
    }

    if (GEExtensions[EXT_MASK(gefrom->extension)].evswap)
        GEExtensions[EXT_MASK(gefrom->extension)].evswap(gefrom, geto);
}

/* Init extension, register at server.
 * Since other extensions may rely on XGE (XInput does already), it is a good
 * idea to init XGE first, before any other extension.
 */
void
GEExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!dixRegisterPrivateKey(&GEClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(GEClientInfoRec)))
        FatalError("GEExtensionInit: GE private request failed.\n");

    if(!AddCallback(&ClientStateCallback, GEClientCallback, 0))
    {
        FatalError("GEExtensionInit: register client callback failed.\n");
    }

    if((extEntry = AddExtension(GE_NAME,
                        0, GENumberErrors,
                        ProcGEDispatch, SProcGEDispatch,
                        GEResetProc, StandardMinorOpcode)) != 0)
    {
        memset(GEExtensions, 0, sizeof(GEExtensions));

        EventSwapVector[GenericEvent] = (EventSwapPtr) SGEGenericEvent;
    } else {
        FatalError("GEInit: AddExtensions failed.\n");
    }

}

/************************************************************/
/*                interface for extensions                  */
/************************************************************/

/* Register an extension with GE. The given swap function will be called each
 * time an event is sent to a client with different byte order.
 * @param extension The extensions major opcode
 * @param ev_swap The event swap function.
 * @param ev_fill Called for an event before delivery. The extension now has
 * the chance to fill in necessary fields for the event.
 */
void
GERegisterExtension(int extension,
                    void (*ev_swap)(xGenericEvent* from, xGenericEvent* to))
{
    if (EXT_MASK(extension) >=  MAXEXTENSIONS)
        FatalError("GE: extension > MAXEXTENSIONS. This should not happen.\n");

    /* extension opcodes are > 128, might as well save some space here */
    GEExtensions[EXT_MASK(extension)].evswap = ev_swap;
}


/* Sets type and extension field for a generic event. This is just an
 * auxiliary function, extensions could do it manually too.
 */
void
GEInitEvent(xGenericEvent* ev, int extension)
{
    ev->type = GenericEvent;
    ev->extension = extension;
    ev->length = 0;
}

/*

Copyright 2007 Peter Hutterer <peter@cs.unisa.edu.au>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the author shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from the author.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _GEEXT_H_
#define _GEEXT_H_
#include <X11/extensions/geproto.h>

/** Struct to keep information about registered extensions */
typedef struct _GEExtension {
    /** Event swapping routine */
    void (*evswap)(xGenericEvent* from, xGenericEvent* to);
} GEExtension, *GEExtensionPtr;


/* All registered extensions and their handling functions. */
extern _X_EXPORT GEExtension GEExtensions[MAXEXTENSIONS];

/* Typecast to generic event */
#define GEV(ev) ((xGenericEvent*)(ev))
/* Returns the extension offset from the event */
#define GEEXT(ev) (GEV(ev)->extension)

/* Return zero-based extension offset (offset - 128). Only for use in arrays */
#define GEEXTIDX(ev) (GEEXT(ev) & 0x7F)
/* True if mask is set for extension on window */
#define GEMaskIsSet(pWin, extension, mask) \
    ((pWin)->optional && \
     (pWin)->optional->geMasks && \
     ((pWin)->optional->geMasks->eventMasks[(extension) & 0x7F] & (mask)))

/* Returns first client */
#define GECLIENT(pWin) \
    (((pWin)->optional) ? (pWin)->optional->geMasks->geClients : NULL)

/* Returns the event_fill for the given event */
#define GEEventFill(ev) \
    GEExtensions[GEEXTIDX(ev)].evfill

#define GEIsType(ev, ext, ev_type) \
        ((GEV(ev)->type == GenericEvent) &&  \
         GEEXT(ev) == (ext) && \
         GEV(ev)->evtype == (ev_type))


/* Interface for other extensions */
extern _X_EXPORT void GERegisterExtension(
        int extension,
        void (*ev_dispatch)(xGenericEvent* from, xGenericEvent* to));

extern _X_EXPORT void GEInitEvent(xGenericEvent* ev, int extension);

extern _X_EXPORT void GEExtensionInit(void);

#endif /* _GEEXT_H_ */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _GEINT_H_
#define _GEINT_H_

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include <X11/extensions/geproto.h>

extern _X_EXPORT DevPrivateKeyRec GEClientPrivateKeyRec;
#define GEClientPrivateKey (&GEClientPrivateKeyRec)

typedef struct _GEClientInfo {
    CARD32  major_version;
    CARD32  minor_version;
} GEClientInfoRec, *GEClientInfoPtr;

#define GEGetClient(pClient)    ((GEClientInfoPtr)(dixLookupPrivate(&((pClient)->devPrivates), GEClientPrivateKey)))

extern _X_EXPORT int (*ProcGEVector[/*GENumRequests*/])(ClientPtr);
extern _X_EXPORT int (*SProcGEVector[/*GENumRequests*/])(ClientPtr);

#endif /* _GEINT_H_ */
# libXext.la:        includes all extensions and should be linked into Xvfb,
#                    Xnest, Xdmx and Xprt
# libXextbuiltin.la: includes those extensions that are built directly into
#                    Xorg by default
# libXextmodule.la:  includes those extensions that are built into a module
#                    that Xorg loads
if XORG
noinst_LTLIBRARIES = libXext.la libXextbuiltin.la libXextmodule.la
else
noinst_LTLIBRARIES = libXext.la
endif

INCLUDES = -I$(top_srcdir)/hw/xfree86/dixmods/extmod

AM_CFLAGS = $(DIX_CFLAGS)

if XORG
sdk_HEADERS = xvdix.h xvmcext.h geext.h geint.h shmint.h syncsdk.h
endif

# Sources always included in libXextbuiltin.la & libXext.la
BUILTIN_SRCS =			\
	bigreq.c		\
        geext.c			\
	shape.c			\
	sleepuntil.c		\
	sleepuntil.h		\
	sync.c			\
	syncsdk.h		\
	syncsrv.h		\
	xcmisc.c		\
	xtest.c

# Sources always included in libXextmodule.la & libXext.la. That's right, zero.
MODULE_SRCS =
MODULE_LIBS =

# Optional sources included if extension enabled by configure.ac rules

# MIT Shared Memory extension
MITSHM_SRCS = shm.c shmint.h
if MITSHM
BUILTIN_SRCS += $(MITSHM_SRCS)
endif

# XVideo extension
XV_SRCS = xvmain.c xvdisp.c xvmc.c xvdix.h xvmcext.h xvdisp.h
if XV
MODULE_SRCS  += $(XV_SRCS)
endif

# XResource extension: lets clients get data about per-client resource usage
RES_SRCS = xres.c
if RES
MODULE_SRCS  += $(RES_SRCS)
endif

# MIT ScreenSaver extension
SCREENSAVER_SRCS = saver.c
if SCREENSAVER
MODULE_SRCS  += $(SCREENSAVER_SRCS)
endif

# Xinerama extension: making multiple video devices act as one virtual screen
XINERAMA_SRCS = panoramiX.c panoramiX.h panoramiXh.h panoramiXsrv.h panoramiXprocs.c panoramiXSwap.c 
if XINERAMA
BUILTIN_SRCS += $(XINERAMA_SRCS)
if XORG
sdk_HEADERS += panoramiXsrv.h panoramiX.h
endif
endif

# X-ACE extension: provides hooks for building security policy extensions
# like XC-Security, X-SELinux & XTSol
XACE_SRCS = xace.c xace.h xacestr.h
if XACE
BUILTIN_SRCS += $(XACE_SRCS)
if XORG
sdk_HEADERS += xace.h xacestr.h
endif
endif

# SELinux extension: provides SELinux policy support for X objects
# requires X-ACE extension
XSELINUX_SRCS = xselinux_ext.c xselinux_hooks.c xselinux_label.c xselinux.h xselinuxint.h
if XSELINUX
MODULE_SRCS += $(XSELINUX_SRCS)
MODULE_LIBS += $(SELINUX_LIBS)
endif

# Security extension: multi-level security to protect clients from each other
XCSECURITY_SRCS = security.c securitysrv.h
if XCSECURITY   
BUILTIN_SRCS += $(XCSECURITY_SRCS)
endif

# XF86 Big Font extension
BIGFONT_SRCS = xf86bigfont.c xf86bigfontsrv.h
if XF86BIGFONT
BUILTIN_SRCS += $(BIGFONT_SRCS)
endif

# DPMS extension
DPMS_SRCS = dpms.c dpmsproc.h
if DPMSExtension
MODULE_SRCS += $(DPMS_SRCS)
endif

# Now take all of the above, mix well, bake for 10 minutes and get libXext*.la

libXext_la_SOURCES =		$(BUILTIN_SRCS) $(MODULE_SRCS)
libXext_la_LIBADD =		$(MODULE_LIBS)

if XORG
libXextbuiltin_la_SOURCES =	$(BUILTIN_SRCS)

libXextmodule_la_SOURCES =	$(MODULE_SRCS)
libXextmodule_la_LIBADD =	$(MODULE_LIBS)
endif

EXTRA_DIST = \
	$(MITSHM_SRCS) \
	$(XV_SRCS) \
	$(RES_SRCS) \
	$(SCREENSAVER_SRCS) \
	$(XACE_SRCS) \
	$(XCSECURITY_SRCS) \
	$(XSELINUX_SRCS) \
	$(XINERAMA_SRCS) \
	$(BIGFONT_SRCS) \
	$(DPMS_SRCS) \
        $(GE_SRCS)

/*****************************************************************
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xarch.h>
#include "misc.h"
#include "cursor.h"
#include "cursorstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "gc.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#include "window.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "panoramiX.h"
#include <X11/extensions/panoramiXproto.h>
#include "panoramiXsrv.h"
#include "globals.h"
#include "servermd.h"
#include "resource.h"
#include "picturestr.h"
#ifdef XFIXES
#include "xfixesint.h"
#endif
#ifdef COMPOSITE
#include "compint.h"
#endif
#include "modinit.h"
#include "protocol-versions.h"

#ifdef GLXPROXY
extern VisualPtr glxMatchVisual(ScreenPtr pScreen,
				VisualPtr pVisual,
				ScreenPtr pMatchScreen);
#endif

/*
 *	PanoramiX data declarations
 */

int 		PanoramiXPixWidth = 0;
int 		PanoramiXPixHeight = 0;
int 		PanoramiXNumScreens = 0;

static RegionRec   	PanoramiXScreenRegion = {{0, 0, 0, 0}, NULL};

static int		PanoramiXNumDepths;
static DepthPtr		PanoramiXDepths;
static int		PanoramiXNumVisuals;
static VisualPtr	PanoramiXVisuals;

RESTYPE XRC_DRAWABLE;
RESTYPE XRT_WINDOW;
RESTYPE XRT_PIXMAP;
RESTYPE XRT_GC;
RESTYPE XRT_COLORMAP;

static Bool VisualsEqual(VisualPtr, ScreenPtr, VisualPtr);
XineramaVisualsEqualProcPtr XineramaVisualsEqualPtr = &VisualsEqual;

/*
 *	Function prototypes
 */

static int panoramiXGeneration;
static int ProcPanoramiXDispatch(ClientPtr client); 

static void PanoramiXResetProc(ExtensionEntry*);

/*
 *	External references for functions and data variables
 */

#include "panoramiXh.h"

int (* SavedProcVector[256]) (ClientPtr client) = { NULL, };

static DevPrivateKeyRec PanoramiXGCKeyRec;
#define PanoramiXGCKey (&PanoramiXGCKeyRec)
static DevPrivateKeyRec PanoramiXScreenKeyRec;
#define PanoramiXScreenKey (&PanoramiXScreenKeyRec)

typedef struct {
  DDXPointRec clipOrg;
  DDXPointRec patOrg;
  GCFuncs *wrapFuncs;
} PanoramiXGCRec, *PanoramiXGCPtr;

typedef struct {
  CreateGCProcPtr	CreateGC;
  CloseScreenProcPtr	CloseScreen;
} PanoramiXScreenRec, *PanoramiXScreenPtr;

static void XineramaValidateGC(GCPtr, unsigned long, DrawablePtr);
static void XineramaChangeGC(GCPtr, unsigned long);
static void XineramaCopyGC(GCPtr, unsigned long, GCPtr);
static void XineramaDestroyGC(GCPtr);
static void XineramaChangeClip(GCPtr, int, pointer, int);
static void XineramaDestroyClip(GCPtr);
static void XineramaCopyClip(GCPtr, GCPtr);

static GCFuncs XineramaGCFuncs = {
    XineramaValidateGC, XineramaChangeGC, XineramaCopyGC, XineramaDestroyGC,
    XineramaChangeClip, XineramaDestroyClip, XineramaCopyClip
};

#define Xinerama_GC_FUNC_PROLOGUE(pGC)\
    PanoramiXGCPtr  pGCPriv = (PanoramiXGCPtr) \
	dixLookupPrivate(&(pGC)->devPrivates, PanoramiXGCKey); \
    (pGC)->funcs = pGCPriv->wrapFuncs;

#define Xinerama_GC_FUNC_EPILOGUE(pGC)\
    pGCPriv->wrapFuncs = (pGC)->funcs;\
    (pGC)->funcs = &XineramaGCFuncs;


static Bool
XineramaCloseScreen (int i, ScreenPtr pScreen)
{
    PanoramiXScreenPtr pScreenPriv = (PanoramiXScreenPtr)
	dixLookupPrivate(&pScreen->devPrivates, PanoramiXScreenKey);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->CreateGC = pScreenPriv->CreateGC;

    if (pScreen->myNum == 0)
	RegionUninit(&PanoramiXScreenRegion);

    free((pointer) pScreenPriv);

    return (*pScreen->CloseScreen) (i, pScreen);
}

static Bool
XineramaCreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;
    PanoramiXScreenPtr pScreenPriv = (PanoramiXScreenPtr)
	dixLookupPrivate(&pScreen->devPrivates, PanoramiXScreenKey);
    Bool ret;

    pScreen->CreateGC = pScreenPriv->CreateGC;
    if((ret = (*pScreen->CreateGC)(pGC))) {
	PanoramiXGCPtr pGCPriv = (PanoramiXGCPtr)
	    dixLookupPrivate(&pGC->devPrivates, PanoramiXGCKey);

	pGCPriv->wrapFuncs = pGC->funcs;
        pGC->funcs = &XineramaGCFuncs;

	pGCPriv->clipOrg.x = pGC->clipOrg.x; 
	pGCPriv->clipOrg.y = pGC->clipOrg.y;
	pGCPriv->patOrg.x = pGC->patOrg.x;
	pGCPriv->patOrg.y = pGC->patOrg.y;
    }
    pScreen->CreateGC = XineramaCreateGC;

    return ret;
}

static void
XineramaValidateGC(
   GCPtr         pGC,
   unsigned long changes,
   DrawablePtr   pDraw 
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);

    if((pDraw->type == DRAWABLE_WINDOW) && !(((WindowPtr)pDraw)->parent)) {
	/* the root window */
	int x_off = pGC->pScreen->x;
	int y_off = pGC->pScreen->y;
	int new_val;

	new_val = pGCPriv->clipOrg.x - x_off;
	if(pGC->clipOrg.x != new_val) {
	    pGC->clipOrg.x = new_val;
	    changes |= GCClipXOrigin;
	}
	new_val = pGCPriv->clipOrg.y - y_off;
	if(pGC->clipOrg.y != new_val) {
	    pGC->clipOrg.y = new_val;
	    changes |= GCClipYOrigin;
	}
	new_val = pGCPriv->patOrg.x - x_off;
	if(pGC->patOrg.x != new_val) {
	    pGC->patOrg.x = new_val;
	    changes |= GCTileStipXOrigin;
	}
	new_val = pGCPriv->patOrg.y - y_off;
	if(pGC->patOrg.y != new_val) {
	    pGC->patOrg.y = new_val;
	    changes |= GCTileStipYOrigin;
	}
    } else {
	if(pGC->clipOrg.x != pGCPriv->clipOrg.x) {
	    pGC->clipOrg.x = pGCPriv->clipOrg.x;
	    changes |= GCClipXOrigin;
	}
	if(pGC->clipOrg.y != pGCPriv->clipOrg.y) {
	    pGC->clipOrg.y = pGCPriv->clipOrg.y;
	    changes |= GCClipYOrigin;
	}
	if(pGC->patOrg.x != pGCPriv->patOrg.x) {
	    pGC->patOrg.x = pGCPriv->patOrg.x;
	    changes |= GCTileStipXOrigin;
	}
	if(pGC->patOrg.y != pGCPriv->patOrg.y) {
	    pGC->patOrg.y = pGCPriv->patOrg.y;
	    changes |= GCTileStipYOrigin;
	}
    }
  
    (*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

static void
XineramaDestroyGC(GCPtr pGC)
{
    Xinerama_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->DestroyGC)(pGC);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

static void
XineramaChangeGC (
    GCPtr	    pGC,
    unsigned long   mask
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);

    if(mask & GCTileStipXOrigin)
	pGCPriv->patOrg.x = pGC->patOrg.x;
    if(mask & GCTileStipYOrigin)
	pGCPriv->patOrg.y = pGC->patOrg.y;
    if(mask & GCClipXOrigin)
	pGCPriv->clipOrg.x = pGC->clipOrg.x; 
    if(mask & GCClipYOrigin)
	pGCPriv->clipOrg.y = pGC->clipOrg.y;

    (*pGC->funcs->ChangeGC) (pGC, mask);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

static void
XineramaCopyGC (
    GCPtr	    pGCSrc, 
    unsigned long   mask,
    GCPtr	    pGCDst
){
    PanoramiXGCPtr pSrcPriv = (PanoramiXGCPtr)
	dixLookupPrivate(&pGCSrc->devPrivates, PanoramiXGCKey);
    Xinerama_GC_FUNC_PROLOGUE (pGCDst);

    if(mask & GCTileStipXOrigin)
        pGCPriv->patOrg.x = pSrcPriv->patOrg.x;
    if(mask & GCTileStipYOrigin)
        pGCPriv->patOrg.y = pSrcPriv->patOrg.y;
    if(mask & GCClipXOrigin)
        pGCPriv->clipOrg.x = pSrcPriv->clipOrg.x;
    if(mask & GCClipYOrigin)
        pGCPriv->clipOrg.y = pSrcPriv->clipOrg.y;

    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    Xinerama_GC_FUNC_EPILOGUE (pGCDst);
}

static void
XineramaChangeClip (
    GCPtr   pGC,
    int		type,
    pointer	pvalue,
    int		nrects 
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

static void
XineramaCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    Xinerama_GC_FUNC_PROLOGUE (pgcDst);
    (* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
    Xinerama_GC_FUNC_EPILOGUE (pgcDst);
}

static void
XineramaDestroyClip(GCPtr pGC)
{
    Xinerama_GC_FUNC_PROLOGUE (pGC);
    (* pGC->funcs->DestroyClip)(pGC);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

int
XineramaDeleteResource(pointer data, XID id)
{
    free(data);
    return 1;
}

typedef struct {
   int screen;
   int id;
} PanoramiXSearchData; 

static Bool 
XineramaFindIDByScrnum(pointer resource, XID id, pointer privdata)
{
    PanoramiXRes *res = (PanoramiXRes*)resource;
    PanoramiXSearchData *data = (PanoramiXSearchData*)privdata;
    
    return res->info[data->screen].id == data->id;
}

PanoramiXRes *
PanoramiXFindIDByScrnum(RESTYPE type, XID id, int screen)
{
    PanoramiXSearchData data;
    pointer val;

    if(!screen) {
	dixLookupResourceByType(&val, id, type, serverClient, DixReadAccess);
	return val;
    }

    data.screen = screen;
    data.id = id;

    return LookupClientResourceComplex(clients[CLIENT_ID(id)], type,
		XineramaFindIDByScrnum, &data);
}

typedef struct _connect_callback_list {
    void (*func)(void);
    struct _connect_callback_list *next;
} XineramaConnectionCallbackList;

static XineramaConnectionCallbackList *ConnectionCallbackList = NULL;

Bool
XineramaRegisterConnectionBlockCallback(void (*func)(void))
{
    XineramaConnectionCallbackList *newlist;

    if(!(newlist = malloc(sizeof(XineramaConnectionCallbackList))))
	return FALSE;

    newlist->next = ConnectionCallbackList;
    newlist->func = func;
    ConnectionCallbackList = newlist;

    return TRUE;
}

static void XineramaInitData(ScreenPtr pScreen)
{
    int i, w, h;

    RegionNull(&PanoramiXScreenRegion);
    FOR_NSCREENS(i) {
	BoxRec TheBox;
	RegionRec ScreenRegion;

        pScreen = screenInfo.screens[i];

	TheBox.x1 = pScreen->x;
	TheBox.x2 = TheBox.x1 + pScreen->width;
	TheBox.y1 = pScreen->y;
	TheBox.y2 = TheBox.y1 + pScreen->height;

	RegionInit(&ScreenRegion, &TheBox, 1);
	RegionUnion(&PanoramiXScreenRegion, &PanoramiXScreenRegion,
		     &ScreenRegion);
	RegionUninit(&ScreenRegion);
    }

    PanoramiXPixWidth = screenInfo.screens[0]->x + screenInfo.screens[0]->width;
    PanoramiXPixHeight = screenInfo.screens[0]->y + screenInfo.screens[0]->height;

    FOR_NSCREENS_FORWARD_SKIP(i) {
	pScreen = screenInfo.screens[i];
	w = pScreen->x + pScreen->width;
	h = pScreen->y + pScreen->height;

	if (PanoramiXPixWidth < w)
	    PanoramiXPixWidth = w;
	if (PanoramiXPixHeight < h)
	    PanoramiXPixHeight = h;
    }
}

void XineramaReinitData(ScreenPtr pScreen)
{
    RegionUninit(&PanoramiXScreenRegion);
    XineramaInitData(pScreen);
}

/*
 *	PanoramiXExtensionInit():
 *		Called from InitExtensions in main().  
 *		Register PanoramiXeen Extension
 *		Initialize global variables.
 */ 

void PanoramiXExtensionInit(int argc, char *argv[])
{
    int 	     	i;
    Bool	     	success = FALSE;
    ExtensionEntry 	*extEntry;
    ScreenPtr		pScreen = screenInfo.screens[0];
    PanoramiXScreenPtr	pScreenPriv;

    if (noPanoramiXExtension) 
	return;

    if (!dixRegisterPrivateKey(&PanoramiXScreenKeyRec, PRIVATE_SCREEN, 0)) {
	noPanoramiXExtension = TRUE;
	return;
    }

    if (!dixRegisterPrivateKey(&PanoramiXGCKeyRec, PRIVATE_GC, sizeof(PanoramiXGCRec))) {
	noPanoramiXExtension = TRUE;
	return;
    }

    PanoramiXNumScreens = screenInfo.numScreens;
    if (PanoramiXNumScreens == 1) {		/* Only 1 screen 	*/
	noPanoramiXExtension = TRUE;
	return;
    }

    while (panoramiXGeneration != serverGeneration) {
	extEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0, 
				ProcPanoramiXDispatch,
				SProcPanoramiXDispatch, PanoramiXResetProc, 
				StandardMinorOpcode);
	if (!extEntry)
	    break;

	/*
	 *	First make sure all the basic allocations succeed.  If not,
	 *	run in non-PanoramiXeen mode.
	 */

	FOR_NSCREENS(i) {
	   pScreen = screenInfo.screens[i];
	   pScreenPriv = malloc(sizeof(PanoramiXScreenRec));
	   dixSetPrivate(&pScreen->devPrivates, PanoramiXScreenKey,
			 pScreenPriv);
	   if(!pScreenPriv) {
		noPanoramiXExtension = TRUE;
		return;
	   }
	
	   pScreenPriv->CreateGC = pScreen->CreateGC;
	   pScreenPriv->CloseScreen = pScreen->CloseScreen;
	
	   pScreen->CreateGC = XineramaCreateGC;
	   pScreen->CloseScreen = XineramaCloseScreen;
	}

	XRC_DRAWABLE = CreateNewResourceClass();
	XRT_WINDOW = CreateNewResourceType(XineramaDeleteResource,
					   "XineramaWindow");
	if (XRT_WINDOW)
	    XRT_WINDOW |= XRC_DRAWABLE;
	XRT_PIXMAP = CreateNewResourceType(XineramaDeleteResource,
					   "XineramaPixmap");
	if (XRT_PIXMAP)
	    XRT_PIXMAP |= XRC_DRAWABLE;
	XRT_GC = CreateNewResourceType(XineramaDeleteResource,
				       "XineramaGC");
	XRT_COLORMAP = CreateNewResourceType(XineramaDeleteResource,
					     "XineramaColormap");

	if (XRT_WINDOW && XRT_PIXMAP && XRT_GC && XRT_COLORMAP) {
	    panoramiXGeneration = serverGeneration;
	    success = TRUE;
	}
	SetResourceTypeErrorValue(XRT_WINDOW, BadWindow);
	SetResourceTypeErrorValue(XRT_PIXMAP, BadPixmap);
	SetResourceTypeErrorValue(XRT_GC, BadGC);
	SetResourceTypeErrorValue(XRT_COLORMAP, BadColor);
    }

    if (!success) {
	noPanoramiXExtension = TRUE;
	ErrorF(PANORAMIX_PROTOCOL_NAME " extension failed to initialize\n");
	return;
    }
  
    XineramaInitData(pScreen);

    /*
     *	Put our processes into the ProcVector
     */

    for (i = 256; i--; )
	SavedProcVector[i] = ProcVector[i];

    ProcVector[X_CreateWindow] = PanoramiXCreateWindow;
    ProcVector[X_ChangeWindowAttributes] = PanoramiXChangeWindowAttributes;
    ProcVector[X_DestroyWindow] = PanoramiXDestroyWindow;
    ProcVector[X_DestroySubwindows] = PanoramiXDestroySubwindows;
    ProcVector[X_ChangeSaveSet] = PanoramiXChangeSaveSet;
    ProcVector[X_ReparentWindow] = PanoramiXReparentWindow;
    ProcVector[X_MapWindow] = PanoramiXMapWindow;
    ProcVector[X_MapSubwindows] = PanoramiXMapSubwindows;
    ProcVector[X_UnmapWindow] = PanoramiXUnmapWindow;
    ProcVector[X_UnmapSubwindows] = PanoramiXUnmapSubwindows;
    ProcVector[X_ConfigureWindow] = PanoramiXConfigureWindow;
    ProcVector[X_CirculateWindow] = PanoramiXCirculateWindow;
    ProcVector[X_GetGeometry] = PanoramiXGetGeometry;
    ProcVector[X_TranslateCoords] = PanoramiXTranslateCoords;
    ProcVector[X_CreatePixmap] = PanoramiXCreatePixmap;
    ProcVector[X_FreePixmap] = PanoramiXFreePixmap;
    ProcVector[X_CreateGC] = PanoramiXCreateGC;
    ProcVector[X_ChangeGC] = PanoramiXChangeGC;
    ProcVector[X_CopyGC] = PanoramiXCopyGC;
    ProcVector[X_SetDashes] = PanoramiXSetDashes;
    ProcVector[X_SetClipRectangles] = PanoramiXSetClipRectangles;
    ProcVector[X_FreeGC] = PanoramiXFreeGC;
    ProcVector[X_ClearArea] = PanoramiXClearToBackground;
    ProcVector[X_CopyArea] = PanoramiXCopyArea;
    ProcVector[X_CopyPlane] = PanoramiXCopyPlane;
    ProcVector[X_PolyPoint] = PanoramiXPolyPoint;
    ProcVector[X_PolyLine] = PanoramiXPolyLine;
    ProcVector[X_PolySegment] = PanoramiXPolySegment;
    ProcVector[X_PolyRectangle] = PanoramiXPolyRectangle;
    ProcVector[X_PolyArc] = PanoramiXPolyArc;
    ProcVector[X_FillPoly] = PanoramiXFillPoly;
    ProcVector[X_PolyFillRectangle] = PanoramiXPolyFillRectangle;
    ProcVector[X_PolyFillArc] = PanoramiXPolyFillArc;
    ProcVector[X_PutImage] = PanoramiXPutImage;
    ProcVector[X_GetImage] = PanoramiXGetImage;
    ProcVector[X_PolyText8] = PanoramiXPolyText8;
    ProcVector[X_PolyText16] = PanoramiXPolyText16;
    ProcVector[X_ImageText8] = PanoramiXImageText8;
    ProcVector[X_ImageText16] = PanoramiXImageText16;
    ProcVector[X_CreateColormap] = PanoramiXCreateColormap;
    ProcVector[X_FreeColormap] = PanoramiXFreeColormap;
    ProcVector[X_CopyColormapAndFree] = PanoramiXCopyColormapAndFree;
    ProcVector[X_InstallColormap] = PanoramiXInstallColormap;
    ProcVector[X_UninstallColormap] = PanoramiXUninstallColormap;
    ProcVector[X_AllocColor] = PanoramiXAllocColor;
    ProcVector[X_AllocNamedColor] = PanoramiXAllocNamedColor;
    ProcVector[X_AllocColorCells] = PanoramiXAllocColorCells;
    ProcVector[X_AllocColorPlanes] = PanoramiXAllocColorPlanes;
    ProcVector[X_FreeColors] = PanoramiXFreeColors;
    ProcVector[X_StoreColors] = PanoramiXStoreColors;
    ProcVector[X_StoreNamedColor] = PanoramiXStoreNamedColor;

    PanoramiXRenderInit ();
#ifdef XFIXES
    PanoramiXFixesInit ();
#endif
#ifdef COMPOSITE
    PanoramiXCompositeInit ();
#endif

}

extern Bool CreateConnectionBlock(void);

Bool PanoramiXCreateConnectionBlock(void)
{
    int i, j, length;
    Bool disableBackingStore = FALSE;
    int old_width, old_height;
    float width_mult, height_mult;
    xWindowRoot *root;
    xVisualType *visual;
    xDepth *depth;
    VisualPtr pVisual;
    ScreenPtr pScreen;

    /*
     *	Do normal CreateConnectionBlock but faking it for only one screen
     */

    if(!PanoramiXNumDepths) {
	ErrorF("Xinerama error: No common visuals\n");
	return FALSE;
    }

    for(i = 1; i < screenInfo.numScreens; i++) {
	pScreen = screenInfo.screens[i];
	if(pScreen->rootDepth != screenInfo.screens[0]->rootDepth) {
	    ErrorF("Xinerama error: Root window depths differ\n");
	    return FALSE;
	}
	if(pScreen->backingStoreSupport != screenInfo.screens[0]->backingStoreSupport)
	     disableBackingStore = TRUE;
    }

    if (disableBackingStore) {
    	for (i = 0; i < screenInfo.numScreens; i++) {
	    pScreen = screenInfo.screens[i];
	    pScreen->backingStoreSupport = NotUseful;
	}
    }

    i = screenInfo.numScreens;
    screenInfo.numScreens = 1;
    if (!CreateConnectionBlock()) {
	screenInfo.numScreens = i;
	return FALSE;
    }

    screenInfo.numScreens = i;
    
    root = (xWindowRoot *) (ConnectionInfo + connBlockScreenStart);
    length = connBlockScreenStart + sizeof(xWindowRoot);

    /* overwrite the connection block */
    root->nDepths = PanoramiXNumDepths;

    for (i = 0; i < PanoramiXNumDepths; i++) {
	depth = (xDepth *) (ConnectionInfo + length);
	depth->depth = PanoramiXDepths[i].depth;
	depth->nVisuals = PanoramiXDepths[i].numVids;
	length += sizeof(xDepth);
	visual = (xVisualType *)(ConnectionInfo + length);
	
	for (j = 0; j < depth->nVisuals; j++, visual++) {
	    visual->visualID = PanoramiXDepths[i].vids[j];

	    for (pVisual = PanoramiXVisuals;
		 pVisual->vid != visual->visualID;
		 pVisual++)
	         ;

	    visual->class = pVisual->class;
	    visual->bitsPerRGB = pVisual->bitsPerRGBValue;
	    visual->colormapEntries = pVisual->ColormapEntries;
	    visual->redMask = pVisual->redMask;
	    visual->greenMask = pVisual->greenMask;
	    visual->blueMask = pVisual->blueMask;
	}

	length += (depth->nVisuals * sizeof(xVisualType));
    }

    connSetupPrefix.length = bytes_to_int32(length);

    for (i = 0; i < PanoramiXNumDepths; i++)
	free(PanoramiXDepths[i].vids);
    free(PanoramiXDepths);
    PanoramiXDepths = NULL;

    /*
     *  OK, change some dimensions so it looks as if it were one big screen
     */
    
    old_width = root->pixWidth;
    old_height = root->pixHeight;

    root->pixWidth = PanoramiXPixWidth;
    root->pixHeight = PanoramiXPixHeight;
    width_mult = (1.0 * root->pixWidth) / old_width;
    height_mult = (1.0 * root->pixHeight) / old_height;
    root->mmWidth *= width_mult;
    root->mmHeight *= height_mult;

    while(ConnectionCallbackList) {
	pointer tmp;

	tmp = (pointer)ConnectionCallbackList;
	(*ConnectionCallbackList->func)();
	ConnectionCallbackList = ConnectionCallbackList->next;
	free(tmp);
    }

    return TRUE;
}

/*
 * This isn't just memcmp(), bitsPerRGBValue is skipped.  markv made that
 * change way back before xf86 4.0, but the comment for _why_ is a bit
 * opaque, so I'm not going to question it for now.
 *
 * This is probably better done as a screen hook so DBE/EVI/GLX can add
 * their own tests, and adding privates to VisualRec so they don't have to
 * do their own back-mapping.
 */
static Bool
VisualsEqual(VisualPtr a, ScreenPtr pScreenB, VisualPtr b)
{
    return ((a->class == b->class) &&
	(a->ColormapEntries == b->ColormapEntries) &&
	(a->nplanes == b->nplanes) &&
	(a->redMask == b->redMask) &&
	(a->greenMask == b->greenMask) &&
	(a->blueMask == b->blueMask) &&
	(a->offsetRed == b->offsetRed) &&
	(a->offsetGreen == b->offsetGreen) &&
	(a->offsetBlue == b->offsetBlue));
}

static void
PanoramiXMaybeAddDepth(DepthPtr pDepth)
{
    ScreenPtr pScreen;
    int j, k;
    Bool found = FALSE;

    FOR_NSCREENS_FORWARD_SKIP(j) {
	pScreen = screenInfo.screens[j];
	for (k = 0; k < pScreen->numDepths; k++) {
	    if (pScreen->allowedDepths[k].depth == pDepth->depth) {
		found = TRUE;
		break;
	    }
	}
    }

    if (!found)
	return;

    j = PanoramiXNumDepths;
    PanoramiXNumDepths++;
    PanoramiXDepths = realloc(PanoramiXDepths,
	    PanoramiXNumDepths * sizeof(DepthRec));
    PanoramiXDepths[j].depth = pDepth->depth;
    PanoramiXDepths[j].numVids = 0;
    /* XXX suboptimal, should grow these dynamically */
    if(pDepth->numVids)
	PanoramiXDepths[j].vids = malloc(sizeof(VisualID) * pDepth->numVids);
    else
	PanoramiXDepths[j].vids = NULL;
}

static void
PanoramiXMaybeAddVisual(VisualPtr pVisual)
{
    ScreenPtr pScreen;
    int j, k;
    Bool found = FALSE;

    FOR_NSCREENS_FORWARD_SKIP(j) {
	pScreen = screenInfo.screens[j];
	found = FALSE;

	for (k = 0; k < pScreen->numVisuals; k++) {
	    VisualPtr candidate = &pScreen->visuals[k];

	    if ((*XineramaVisualsEqualPtr)(pVisual, pScreen, candidate)
#ifdef GLXPROXY
		&& glxMatchVisual(screenInfo.screens[0], pVisual, pScreen)
#endif
		    ) {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	    return;
    }

    /* found a matching visual on all screens, add it to the subset list */
    j = PanoramiXNumVisuals;
    PanoramiXNumVisuals++;
    PanoramiXVisuals = realloc(PanoramiXVisuals,
	    PanoramiXNumVisuals * sizeof(VisualRec));

    memcpy(&PanoramiXVisuals[j], pVisual, sizeof(VisualRec));

    for (k = 0; k < PanoramiXNumDepths; k++) {
	if (PanoramiXDepths[k].depth == pVisual->nplanes) {
	    PanoramiXDepths[k].vids[PanoramiXDepths[k].numVids] = pVisual->vid;
	    PanoramiXDepths[k].numVids++;
	    break;
	}	
    }   
}

extern void
PanoramiXConsolidate(void)
{
    int 	i;
    PanoramiXRes *root, *defmap, *saver;
    ScreenPtr   pScreen = screenInfo.screens[0];
    DepthPtr    pDepth = pScreen->allowedDepths;
    VisualPtr   pVisual = pScreen->visuals;

    PanoramiXNumDepths = 0;
    PanoramiXNumVisuals = 0;

    for (i = 0; i < pScreen->numDepths; i++)
	PanoramiXMaybeAddDepth(pDepth++);

    for (i = 0; i < pScreen->numVisuals; i++)
	PanoramiXMaybeAddVisual(pVisual++);

    root = malloc(sizeof(PanoramiXRes));
    root->type = XRT_WINDOW;
    defmap = malloc(sizeof(PanoramiXRes));
    defmap->type = XRT_COLORMAP;
    saver = malloc(sizeof(PanoramiXRes));
    saver->type = XRT_WINDOW;

    FOR_NSCREENS(i) {
	ScreenPtr pScreen = screenInfo.screens[i];
	root->info[i].id = pScreen->root->drawable.id;
	root->u.win.class = InputOutput;
        root->u.win.root = TRUE;
        saver->info[i].id = pScreen->screensaver.wid;
        saver->u.win.class = InputOutput;
        saver->u.win.root = TRUE;
	defmap->info[i].id = pScreen->defColormap;
    }

    AddResource(root->info[0].id, XRT_WINDOW, root);
    AddResource(saver->info[0].id, XRT_WINDOW, saver);
    AddResource(defmap->info[0].id, XRT_COLORMAP, defmap);
}

VisualID
PanoramiXTranslateVisualID(int screen, VisualID orig)
{
    ScreenPtr pOtherScreen = screenInfo.screens[screen];
    VisualPtr pVisual = NULL;
    int i;

    for (i = 0; i < PanoramiXNumVisuals; i++) {
	if (orig == PanoramiXVisuals[i].vid) {
	    pVisual = &PanoramiXVisuals[i];
	    break;
	}
    }

    if (!pVisual)
	return 0;

    /* if screen is 0, orig is already the correct visual ID */
    if (screen == 0)
	return orig;

    /* found the original, now translate it relative to the backend screen */
    for (i = 0; i < pOtherScreen->numVisuals; i++) {
	VisualPtr pOtherVisual = &pOtherScreen->visuals[i];

	if ((*XineramaVisualsEqualPtr)(pVisual, pOtherScreen, pOtherVisual))
	    return pOtherVisual->vid;
    }

    return 0;
}


/*
 *	PanoramiXResetProc()
 *		Exit, deallocating as needed.
 */

static void PanoramiXResetProc(ExtensionEntry* extEntry)
{
    int		i;

    PanoramiXRenderReset ();
#ifdef XFIXES
    PanoramiXFixesReset ();
#endif
    screenInfo.numScreens = PanoramiXNumScreens;
    for (i = 256; i--; )
	ProcVector[i] = SavedProcVector[i];
}


int
ProcPanoramiXQueryVersion (ClientPtr client)
{
    /* REQUEST(xPanoramiXQueryVersionReq); */
    xPanoramiXQueryVersionReply		rep;
    register 	int			n;

    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_PANORAMIX_MAJOR_VERSION;
    rep.minorVersion = SERVER_PANORAMIX_MINOR_VERSION;
    if (client->swapped) { 
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);     
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof (xPanoramiXQueryVersionReply), (char *)&rep);
    return Success;
}

int
ProcPanoramiXGetState(ClientPtr client)
{
	REQUEST(xPanoramiXGetStateReq);
    	WindowPtr			pWin;
	xPanoramiXGetStateReply		rep;
	int			n, rc;
	
	REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
	rep.state = !noPanoramiXExtension;
	rep.window = stuff->window;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.window, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetStateReply), (char *) &rep);
	return Success;

}

int 
ProcPanoramiXGetScreenCount(ClientPtr client)
{
	REQUEST(xPanoramiXGetScreenCountReq);
    	WindowPtr			pWin;
	xPanoramiXGetScreenCountReply	rep;
	int			n, rc;

	REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
	rep.ScreenCount = PanoramiXNumScreens;
	rep.window = stuff->window;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.window, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetScreenCountReply), (char *) &rep);
	return Success;
}

int 
ProcPanoramiXGetScreenSize(ClientPtr client)
{
	REQUEST(xPanoramiXGetScreenSizeReq);
    	WindowPtr			pWin;
	xPanoramiXGetScreenSizeReply	rep;
	int			n, rc;
	
	if (stuff->screen >= PanoramiXNumScreens)
	    return BadMatch;

	REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
		/* screen dimensions */
	rep.width  = screenInfo.screens[stuff->screen]->width;
	rep.height = screenInfo.screens[stuff->screen]->height;
	rep.window = stuff->window;
	rep.screen = stuff->screen;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.width, n);
	    swapl (&rep.height, n);
	    swapl (&rep.window, n);
	    swapl (&rep.screen, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetScreenSizeReply), (char *) &rep);
	return Success;
}


int
ProcXineramaIsActive(ClientPtr client)
{
    /* REQUEST(xXineramaIsActiveReq); */
    xXineramaIsActiveReply	rep;

    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
#if 1
    {
	/* The following hack fools clients into thinking that Xinerama
	 * is disabled even though it is not. */
	rep.state = !noPanoramiXExtension && !PanoramiXExtensionDisabledHack;
    }
#else
    rep.state = !noPanoramiXExtension;
#endif
    if (client->swapped) {
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.state, n);
    }	
    WriteToClient (client, sizeof (xXineramaIsActiveReply), (char *) &rep);
    return Success;
}


int
ProcXineramaQueryScreens(ClientPtr client)
{
    /* REQUEST(xXineramaQueryScreensReq); */
    xXineramaQueryScreensReply	rep;

    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = (noPanoramiXExtension) ? 0 : PanoramiXNumScreens;
    rep.length = bytes_to_int32(rep.number * sz_XineramaScreenInfo);
    if (client->swapped) {
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.number, n);
    }	
    WriteToClient (client, sizeof (xXineramaQueryScreensReply), (char *) &rep);

    if(!noPanoramiXExtension) {
	xXineramaScreenInfo scratch;
	int i;

	FOR_NSCREENS(i) {
	    scratch.x_org  = screenInfo.screens[i]->x;
	    scratch.y_org  = screenInfo.screens[i]->y;
	    scratch.width  = screenInfo.screens[i]->width;
	    scratch.height = screenInfo.screens[i]->height;
	
	    if(client->swapped) {
		int n;
		swaps (&scratch.x_org, n);
		swaps (&scratch.y_org, n);
		swaps (&scratch.width, n);
		swaps (&scratch.height, n);
	    }
	    WriteToClient (client, sz_XineramaScreenInfo, (char *) &scratch);
	}
    }

    return Success;
}


static int
ProcPanoramiXDispatch (ClientPtr client)
{   REQUEST(xReq);
    switch (stuff->data)
    {
	case X_PanoramiXQueryVersion:
	     return ProcPanoramiXQueryVersion(client);
	case X_PanoramiXGetState:
	     return ProcPanoramiXGetState(client);
	case X_PanoramiXGetScreenCount:
	     return ProcPanoramiXGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return ProcPanoramiXGetScreenSize(client);
	case X_XineramaIsActive:
	     return ProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return ProcXineramaQueryScreens(client);
    }
    return BadRequest;
}


#if X_BYTE_ORDER == X_LITTLE_ENDIAN
#define SHIFT_L(v,s) (v) << (s)
#define SHIFT_R(v,s) (v) >> (s)
#else
#define SHIFT_L(v,s) (v) >> (s)
#define SHIFT_R(v,s) (v) << (s)
#endif

static void
CopyBits(char *dst, int shiftL, char *src, int bytes)
{
   /* Just get it to work.  Worry about speed later */
    int shiftR = 8 - shiftL;

    while(bytes--) {
	*dst |= SHIFT_L(*src, shiftL);
	*(dst + 1) |= SHIFT_R(*src, shiftR);
	dst++; src++;
    }     
}


/* Caution.  This doesn't support 2 and 4 bpp formats.  We expect
   1 bpp and planar data to be already cleared when presented
   to this function */

void
XineramaGetImageData(
    DrawablePtr *pDrawables,
    int left,
    int top,
    int width, 
    int height,
    unsigned int format,
    unsigned long planemask,
    char *data,
    int pitch,
    Bool isRoot
){
    RegionRec SrcRegion, ScreenRegion, GrabRegion;
    BoxRec SrcBox, *pbox;
    int x, y, w, h, i, j, nbox, size, sizeNeeded, ScratchPitch, inOut, depth;
    DrawablePtr pDraw = pDrawables[0];
    char *ScratchMem = NULL;

    size = 0;

    /* find box in logical screen space */
    SrcBox.x1 = left;
    SrcBox.y1 = top;
    if(!isRoot) {
	SrcBox.x1 += pDraw->x + screenInfo.screens[0]->x;
	SrcBox.y1 += pDraw->y + screenInfo.screens[0]->y;
    }
    SrcBox.x2 = SrcBox.x1 + width;
    SrcBox.y2 = SrcBox.y1 + height;
    
    RegionInit(&SrcRegion, &SrcBox, 1);
    RegionNull(&GrabRegion);

    depth = (format == XYPixmap) ? 1 : pDraw->depth;

    FOR_NSCREENS(i) {
	BoxRec TheBox;
	ScreenPtr pScreen;
	pDraw = pDrawables[i];
	pScreen = pDraw->pScreen;

	TheBox.x1 = pScreen->x;
	TheBox.x2 = TheBox.x1 + pScreen->width;
	TheBox.y1 = pScreen->y;
	TheBox.y2 = TheBox.y1 + pScreen->height;

	RegionInit(&ScreenRegion, &TheBox, 1);
	inOut = RegionContainsRect(&ScreenRegion, &SrcBox);
	if(inOut == rgnPART)
	    RegionIntersect(&GrabRegion, &SrcRegion, &ScreenRegion);
	RegionUninit(&ScreenRegion);

	if(inOut == rgnIN) {	   
	    (*pScreen->GetImage)(pDraw,
			SrcBox.x1 - pDraw->x - screenInfo.screens[i]->x,
			SrcBox.y1 - pDraw->y - screenInfo.screens[i]->y,
			width, height, format, planemask, data);
	    break;
	} else if (inOut == rgnOUT)
	    continue;

	nbox = RegionNumRects(&GrabRegion);

	if(nbox) {
	    pbox = RegionRects(&GrabRegion);

	    while(nbox--) {
		w = pbox->x2 - pbox->x1;
		h = pbox->y2 - pbox->y1;
		ScratchPitch = PixmapBytePad(w, depth);
		sizeNeeded = ScratchPitch * h;

		if(sizeNeeded > size) {
		    char *tmpdata = ScratchMem;
		    ScratchMem = realloc(ScratchMem, sizeNeeded);
		    if(ScratchMem)
			size = sizeNeeded;
		    else {
			ScratchMem = tmpdata;
			break;
		    }	
		}

		x = pbox->x1 - pDraw->x - screenInfo.screens[i]->x;
		y = pbox->y1 - pDraw->y - screenInfo.screens[i]->y;

		(*pScreen->GetImage)(pDraw, x, y, w, h,
					format, planemask, ScratchMem);
		
		/* copy the memory over */

		if(depth == 1) {
		   int k, shift, leftover, index, index2;
		
		   x = pbox->x1 - SrcBox.x1;
		   y = pbox->y1 - SrcBox.y1;
		   shift = x & 7;
		   x >>= 3;
		   leftover = w & 7;
		   w >>= 3;

		   /* clean up the edge */
		   if(leftover) {
			int mask = (1 << leftover) - 1;
			for(j = h, k = w; j--; k += ScratchPitch)
			    ScratchMem[k] &= mask;
		   }

		   for(j = 0, index = (pitch * y) + x, index2 = 0; j < h;
		       j++, index += pitch, index2 += ScratchPitch) 
		   {
			if(w) {
			    if(!shift)
				memcpy(data + index, ScratchMem + index2, w);
			    else
				CopyBits(data + index, shift, 
						ScratchMem + index2, w);
			}
	
			if(leftover) {
			    data[index + w] |= 
				SHIFT_L(ScratchMem[index2 + w], shift);
			    if((shift + leftover) > 8)
				data[index + w + 1] |= 
				  SHIFT_R(ScratchMem[index2 + w],(8 - shift));
			}
		    }
		} else {
		    j = BitsPerPixel(depth) >> 3;
		    x = (pbox->x1 - SrcBox.x1) * j;
		    y = pbox->y1 - SrcBox.y1;
		    w *= j;

		    for(j = 0; j < h; j++) {
			memcpy(data + (pitch * (y + j)) + x, 
				ScratchMem + (ScratchPitch * j), w);
		    }
		}
		pbox++;
	    }

	    RegionSubtract(&SrcRegion, &SrcRegion, &GrabRegion);
	    if(!RegionNotEmpty(&SrcRegion))
		break;
	}
	
    }

    free(ScratchMem);

    RegionUninit(&SrcRegion);
    RegionUninit(&GrabRegion);
}
/*****************************************************************

Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/


/* THIS IS NOT AN X PROJECT TEAM SPECIFICATION */

/*  
 *	PanoramiX definitions
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _PANORAMIX_H_
#define _PANORAMIX_H_

#define _PANORAMIX_SERVER
#include <X11/extensions/panoramiXproto.h>
#undef _PANORAMIX_SERVER
#include "gcstruct.h"
#include "dixstruct.h"

typedef struct _PanoramiXInfo {
    XID id ;
} PanoramiXInfo;

typedef struct {
    PanoramiXInfo info[MAXSCREENS];
    RESTYPE type;
    union {
	struct {
	    char   visibility;
	    char   class;
            char   root;
	} win;
	struct {
	    Bool shared;
	} pix;
	struct {
	    Bool root;
	} pict;
	char raw_data[4];
    } u;
} PanoramiXRes;

#define FOR_NSCREENS_FORWARD(j) for(j = 0; j < PanoramiXNumScreens; j++)
#define FOR_NSCREENS_FORWARD_SKIP(j) for(j = 1; j < PanoramiXNumScreens; j++)
#define FOR_NSCREENS_BACKWARD(j) for(j = PanoramiXNumScreens - 1; j >= 0; j--)
#define FOR_NSCREENS(j) FOR_NSCREENS_FORWARD(j)

#define IS_SHARED_PIXMAP(r) (((r)->type == XRT_PIXMAP) && (r)->u.pix.shared)

#define IS_ROOT_DRAWABLE(d) (((d)->type == XRT_WINDOW) && (d)->u.win.root)
#endif /* _PANORAMIX_H_ */

/*
 *	Server dispatcher function replacements
 */

extern int PanoramiXCreateWindow(ClientPtr client);
extern int PanoramiXChangeWindowAttributes(ClientPtr client);
extern int PanoramiXDestroyWindow(ClientPtr client);
extern int PanoramiXDestroySubwindows(ClientPtr client);
extern int PanoramiXChangeSaveSet(ClientPtr client);
extern int PanoramiXReparentWindow(ClientPtr client);
extern int PanoramiXMapWindow(ClientPtr client);
extern int PanoramiXMapSubwindows(ClientPtr client);
extern int PanoramiXUnmapWindow(ClientPtr client);
extern int PanoramiXUnmapSubwindows(ClientPtr client);
extern int PanoramiXConfigureWindow(ClientPtr client);
extern int PanoramiXCirculateWindow(ClientPtr client);
extern int PanoramiXGetGeometry(ClientPtr client);
extern int PanoramiXTranslateCoords(ClientPtr client);	
extern int PanoramiXCreatePixmap(ClientPtr client);
extern int PanoramiXFreePixmap(ClientPtr client);
extern int PanoramiXChangeGC(ClientPtr client);
extern int PanoramiXCopyGC(ClientPtr client);
extern int PanoramiXCopyColormapAndFree(ClientPtr client);
extern int PanoramiXCreateGC(ClientPtr client);
extern int PanoramiXSetDashes(ClientPtr client);
extern int PanoramiXSetClipRectangles(ClientPtr client);
extern int PanoramiXFreeGC(ClientPtr client);
extern int PanoramiXClearToBackground(ClientPtr client);
extern int PanoramiXCopyArea(ClientPtr client);
extern int PanoramiXCopyPlane(ClientPtr client);
extern int PanoramiXPolyPoint(ClientPtr client);
extern int PanoramiXPolyLine(ClientPtr client);
extern int PanoramiXPolySegment(ClientPtr client);
extern int PanoramiXPolyRectangle(ClientPtr client);
extern int PanoramiXPolyArc(ClientPtr client);
extern int PanoramiXFillPoly(ClientPtr client);
extern int PanoramiXPolyFillArc(ClientPtr client);
extern int PanoramiXPolyFillRectangle(ClientPtr client);
extern int PanoramiXPutImage(ClientPtr client);
extern int PanoramiXGetImage(ClientPtr client);
extern int PanoramiXPolyText8(ClientPtr client);
extern int PanoramiXPolyText16(ClientPtr client);	
extern int PanoramiXImageText8(ClientPtr client);
extern int PanoramiXImageText16(ClientPtr client);
extern int PanoramiXCreateColormap(ClientPtr client);
extern int PanoramiXFreeColormap(ClientPtr client);
extern int PanoramiXInstallColormap(ClientPtr client);
extern int PanoramiXUninstallColormap(ClientPtr client);
extern int PanoramiXAllocColor(ClientPtr client);
extern int PanoramiXAllocNamedColor(ClientPtr client);
extern int PanoramiXAllocColorCells(ClientPtr client);
extern int PanoramiXStoreNamedColor(ClientPtr client);
extern int PanoramiXFreeColors(ClientPtr client);
extern int PanoramiXStoreColors(ClientPtr client);
extern int PanoramiXAllocColorPlanes(ClientPtr client);

#define PROC_EXTERN(pfunc)      extern int pfunc(ClientPtr)

PROC_EXTERN(ProcPanoramiXQueryVersion); 
PROC_EXTERN(ProcPanoramiXGetState); 
PROC_EXTERN(ProcPanoramiXGetScreenCount); 
PROC_EXTERN(ProcPanoramiXGetScreenSize); 
 
PROC_EXTERN(ProcXineramaQueryScreens);
PROC_EXTERN(ProcXineramaIsActive);

extern int SProcPanoramiXDispatch(ClientPtr client);

extern int connBlockScreenStart;
extern xConnSetupPrefix connSetupPrefix;

extern int (* SavedProcVector[256]) (ClientPtr client);
/*****************************************************************
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/

/* Massively rewritten by Mark Vojkovich <markv@valinux.com> */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "windowstr.h"
#include "dixfontstr.h"
#include "gcstruct.h"
#include "colormapst.h"
#include "scrnintstr.h"
#include "opaque.h"
#include "inputstr.h"
#include "migc.h"
#include "misc.h"
#include "dixstruct.h"
#include "panoramiX.h"
#include "panoramiXsrv.h"
#include "resource.h"
#include "panoramiXh.h"

#define XINERAMA_IMAGE_BUFSIZE (256*1024)
#define INPUTONLY_LEGAL_MASK (CWWinGravity | CWEventMask | \
                              CWDontPropagate | CWOverrideRedirect | CWCursor )

int PanoramiXCreateWindow(ClientPtr client)
{
    PanoramiXRes *parent, *newWin;
    PanoramiXRes *backPix = NULL;
    PanoramiXRes *bordPix = NULL;
    PanoramiXRes *cmap    = NULL;
    REQUEST(xCreateWindowReq);
    int pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
    int result, len, j;
    int orig_x, orig_y;
    XID orig_visual, tmp;
    Bool parentIsRoot;

    REQUEST_AT_LEAST_SIZE(xCreateWindowReq);
    
    len = client->req_len - bytes_to_int32(sizeof(xCreateWindowReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByType((pointer *)&parent, stuff->parent,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    if(stuff->class == CopyFromParent)
	stuff->class = parent->u.win.class;

    if((stuff->class == InputOnly) && (stuff->mask & (~INPUTONLY_LEGAL_MASK)))
        return BadMatch;

    if ((Mask)stuff->mask & CWBackPixmap) {
	pback_offset = Ones((Mask)stuff->mask & (CWBackPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pback_offset);
	if ((tmp != None) && (tmp != ParentRelative)) {
	    result = dixLookupResourceByType((pointer *)&backPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & CWBorderPixmap) {
	pbord_offset = Ones((Mask)stuff->mask & (CWBorderPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pbord_offset);
	if (tmp != CopyFromParent) {
	    result = dixLookupResourceByType((pointer *)&bordPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & CWColormap) {
	cmap_offset = Ones((Mask)stuff->mask & (CWColormap - 1));
	tmp = *((CARD32 *) &stuff[1] + cmap_offset);
	if ((tmp != CopyFromParent) && (tmp != None)) {
	    result = dixLookupResourceByType((pointer *)&cmap, tmp,
					     XRT_COLORMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    if(!(newWin = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newWin->type = XRT_WINDOW;
    newWin->u.win.visibility = VisibilityNotViewable;
    newWin->u.win.class = stuff->class;
    newWin->u.win.root = FALSE;
    panoramix_setup_ids(newWin, client, stuff->wid);

    if (stuff->class == InputOnly)
	stuff->visual = CopyFromParent;
    orig_visual = stuff->visual;
    orig_x = stuff->x;
    orig_y = stuff->y;
    parentIsRoot = (stuff->parent == screenInfo.screens[0]->root->drawable.id) ||
                   (stuff->parent == screenInfo.screens[0]->screensaver.wid);
    FOR_NSCREENS_BACKWARD(j) {
        stuff->wid = newWin->info[j].id;
        stuff->parent = parent->info[j].id;
	if (parentIsRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	if (backPix)
	    *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[j].id;
	if (bordPix)
	    *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[j].id;
	if (cmap)
	    *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[j].id;
	if ( orig_visual != CopyFromParent ) 
	    stuff->visual = PanoramiXTranslateVisualID(j, orig_visual);
        result = (*SavedProcVector[X_CreateWindow])(client);
        if(result != Success) break;
    }

    if (result == Success)
        AddResource(newWin->info[0].id, XRT_WINDOW, newWin);
    else 
        free(newWin);

    return result;
}


int PanoramiXChangeWindowAttributes(ClientPtr client)
{
    PanoramiXRes *win;
    PanoramiXRes *backPix = NULL;
    PanoramiXRes *bordPix = NULL;
    PanoramiXRes *cmap    = NULL;
    REQUEST(xChangeWindowAttributesReq);
    int pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xChangeWindowAttributesReq);
    
    len = client->req_len - bytes_to_int32(sizeof(xChangeWindowAttributesReq));
    if (Ones(stuff->valueMask) != len)
        return BadLength;

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    if((win->u.win.class == InputOnly) && 
       (stuff->valueMask & (~INPUTONLY_LEGAL_MASK)))
        return BadMatch;

    if ((Mask)stuff->valueMask & CWBackPixmap) {
	pback_offset = Ones((Mask)stuff->valueMask & (CWBackPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pback_offset);
	if ((tmp != None) && (tmp != ParentRelative)) {
	    result = dixLookupResourceByType((pointer *)&backPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->valueMask & CWBorderPixmap) {
	pbord_offset = Ones((Mask)stuff->valueMask & (CWBorderPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pbord_offset);
	if (tmp != CopyFromParent) {
	    result = dixLookupResourceByType((pointer *)&bordPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->valueMask & CWColormap) {
	cmap_offset = Ones((Mask)stuff->valueMask & (CWColormap - 1));
	tmp = *((CARD32 *) &stuff[1] + cmap_offset);
	if ((tmp != CopyFromParent) && (tmp != None)) {
	    result = dixLookupResourceByType((pointer *)&cmap, tmp,
					     XRT_COLORMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->window = win->info[j].id;
	if (backPix)
	    *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[j].id;
	if (bordPix)
	    *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[j].id;
	if (cmap)
	    *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[j].id;
        result = (*SavedProcVector[X_ChangeWindowAttributes])(client);
    }

    return result;
}


int PanoramiXDestroyWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id, XRT_WINDOW,
				     client, DixDestroyAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_DestroyWindow])(client);
        if(result != Success) break;
    }

    /* Since ProcDestroyWindow is using FreeResource, it will free
	our resource for us on the last pass through the loop above */
 
    return result;
}


int PanoramiXDestroySubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id, XRT_WINDOW,
				     client, DixDestroyAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_DestroySubwindows])(client);
        if(result != Success) break;
    }

    /* DestroySubwindows is using FreeResource which will free
	our resources for us on the last pass through the loop above */

    return result;
}


int PanoramiXChangeSaveSet(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xChangeSaveSetReq);

    REQUEST_SIZE_MATCH(xChangeSaveSetReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->window = win->info[j].id;
	result = (*SavedProcVector[X_ChangeSaveSet])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXReparentWindow(ClientPtr client)
{
    PanoramiXRes *win, *parent;
    int         result, j;
    int		x, y;
    Bool	parentIsRoot;
    REQUEST(xReparentWindowReq);

    REQUEST_SIZE_MATCH(xReparentWindowReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    result = dixLookupResourceByType((pointer *)&parent, stuff->parent,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    x = stuff->x;
    y = stuff->y;
    parentIsRoot = (stuff->parent == screenInfo.screens[0]->root->drawable.id) ||
                   (stuff->parent == screenInfo.screens[0]->screensaver.wid);
    FOR_NSCREENS_BACKWARD(j) {
	stuff->window = win->info[j].id;
	stuff->parent = parent->info[j].id;
	if(parentIsRoot) {
	    stuff->x = x - screenInfo.screens[j]->x;
	    stuff->y = y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ReparentWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXMapWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_MapWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXMapSubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_MapSubwindows])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXUnmapWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_UnmapWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXUnmapSubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_UnmapSubwindows])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXConfigureWindow(ClientPtr client)
{
    PanoramiXRes *win;
    PanoramiXRes *sib = NULL;
    WindowPtr   pWin;
    int         result, j, len, sib_offset = 0, x = 0, y = 0;
    int		x_offset = -1;
    int		y_offset = -1;
    REQUEST(xConfigureWindowReq);

    REQUEST_AT_LEAST_SIZE(xConfigureWindowReq);

    len = client->req_len - bytes_to_int32(sizeof(xConfigureWindowReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    /* because we need the parent */
    result = dixLookupResourceByType((pointer *)&pWin, stuff->window,
				     RT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    if ((Mask)stuff->mask & CWSibling) {
	XID tmp;
	sib_offset = Ones((Mask)stuff->mask & (CWSibling - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + sib_offset))) {
	    result = dixLookupResourceByType((pointer *)&sib, tmp, XRT_WINDOW,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    if(pWin->parent && ((pWin->parent == screenInfo.screens[0]->root) ||
                        (pWin->parent->drawable.id == screenInfo.screens[0]->screensaver.wid)))
    {
	if ((Mask)stuff->mask & CWX) {
	    x_offset = 0;
	    x = *((CARD32 *)&stuff[1]);
	}
	if ((Mask)stuff->mask & CWY) {
	    y_offset = (x_offset == -1) ? 0 : 1;
	    y = *((CARD32 *) &stuff[1] + y_offset);
	}
    }

    /* have to go forward or you get expose events before 
	ConfigureNotify events */
    FOR_NSCREENS_FORWARD(j) {
	stuff->window = win->info[j].id;
	if(sib)
	    *((CARD32 *) &stuff[1] + sib_offset) = sib->info[j].id;
	if(x_offset >= 0)
	    *((CARD32 *) &stuff[1] + x_offset) = x - screenInfo.screens[j]->x;
	if(y_offset >= 0)
	    *((CARD32 *) &stuff[1] + y_offset) = y - screenInfo.screens[j]->y;
	result = (*SavedProcVector[X_ConfigureWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXCirculateWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xCirculateWindowReq);

    REQUEST_SIZE_MATCH(xCirculateWindowReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->window = win->info[j].id;
	result = (*SavedProcVector[X_CirculateWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXGetGeometry(ClientPtr client)
{
    xGetGeometryReply 	 rep;
    DrawablePtr pDraw;
    int rc;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupDrawable(&pDraw, stuff->id, client, M_ANY, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.root = screenInfo.screens[0]->root->drawable.id;
    rep.depth = pDraw->depth;
    rep.width = pDraw->width;
    rep.height = pDraw->height;
    rep.x = rep.y = rep.borderWidth = 0;

    if (stuff->id == rep.root) {
	xWindowRoot *root  = (xWindowRoot *)
				    (ConnectionInfo + connBlockScreenStart);

	rep.width = root->pixWidth;
	rep.height = root->pixHeight;
    } else 
    if (WindowDrawable(pDraw->type))
    {
        WindowPtr pWin = (WindowPtr)pDraw;
	rep.x = pWin->origin.x - wBorderWidth (pWin);
	rep.y = pWin->origin.y - wBorderWidth (pWin);
	if((pWin->parent == screenInfo.screens[0]->root) ||
           (pWin->parent->drawable.id == screenInfo.screens[0]->screensaver.wid))
        {
	   rep.x += screenInfo.screens[0]->x;
	   rep.y += screenInfo.screens[0]->y;
	}
	rep.borderWidth = pWin->borderWidth;
    }

    WriteReplyToClient(client, sizeof(xGetGeometryReply), &rep);
    return Success;
}

int PanoramiXTranslateCoords(ClientPtr client)
{
    INT16 x, y;
    REQUEST(xTranslateCoordsReq);
    int rc;
    WindowPtr pWin, pDst;
    xTranslateCoordsReply rep;

    REQUEST_SIZE_MATCH(xTranslateCoordsReq);
    rc = dixLookupWindow(&pWin, stuff->srcWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pDst, stuff->dstWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.sameScreen = xTrue;
    rep.child = None;

    if((pWin == screenInfo.screens[0]->root) ||
       (pWin->drawable.id == screenInfo.screens[0]->screensaver.wid))
    { 
	x = stuff->srcX - screenInfo.screens[0]->x;
	y = stuff->srcY - screenInfo.screens[0]->y;
    } else {
	x = pWin->drawable.x + stuff->srcX;
	y = pWin->drawable.y + stuff->srcY;
    }
    pWin = pDst->firstChild;
    while (pWin) {
	    BoxRec  box;
	    if ((pWin->mapped) &&
		(x >= pWin->drawable.x - wBorderWidth (pWin)) &&
		(x < pWin->drawable.x + (int)pWin->drawable.width +
		 wBorderWidth (pWin)) &&
		(y >= pWin->drawable.y - wBorderWidth (pWin)) &&
		(y < pWin->drawable.y + (int)pWin->drawable.height +
		 wBorderWidth (pWin))
		/* When a window is shaped, a further check
		 * is made to see if the point is inside
		 * borderSize
		 */
		&& (!wBoundingShape(pWin) ||
		    RegionContainsPoint(wBoundingShape(pWin),
					x - pWin->drawable.x, 
					y - pWin->drawable.y, &box))
		)
            {
		rep.child = pWin->drawable.id;
		pWin = (WindowPtr) NULL;
	    }
	    else
		pWin = pWin->nextSib;
    }
    rep.dstX = x - pDst->drawable.x;
    rep.dstY = y - pDst->drawable.y;
    if((pDst == screenInfo.screens[0]->root) ||
       (pDst->drawable.id == screenInfo.screens[0]->screensaver.wid))
    {
	rep.dstX += screenInfo.screens[0]->x;
	rep.dstY += screenInfo.screens[0]->y;
    }

    WriteReplyToClient(client, sizeof(xTranslateCoordsReply), &rep);
    return Success;
}

int PanoramiXCreatePixmap(ClientPtr client)
{
    PanoramiXRes *refDraw, *newPix;
    int result, j;
    REQUEST(xCreatePixmapReq);

    REQUEST_SIZE_MATCH(xCreatePixmapReq);
    client->errorValue = stuff->pid;

    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(!(newPix = malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPix->type = XRT_PIXMAP;
    newPix->u.pix.shared = FALSE;
    panoramix_setup_ids(newPix, client, stuff->pid);
   
    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPix->info[j].id;
	stuff->drawable = refDraw->info[j].id;
	result = (*SavedProcVector[X_CreatePixmap])(client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPix->info[0].id, XRT_PIXMAP, newPix);
    else 
	free(newPix);

    return result;
}


int PanoramiXFreePixmap(ClientPtr client)
{
    PanoramiXRes *pix;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((pointer *)&pix, stuff->id, XRT_PIXMAP,
				     client, DixDestroyAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = pix->info[j].id;
	result = (*SavedProcVector[X_FreePixmap])(client);
	if(result != Success) break;
    }

    /* Since ProcFreePixmap is using FreeResource, it will free
	our resource for us on the last pass through the loop above */
 
    return result;
}


int PanoramiXCreateGC(ClientPtr client)
{
    PanoramiXRes *refDraw;
    PanoramiXRes *newGC;
    PanoramiXRes *stip = NULL;
    PanoramiXRes *tile = NULL;
    PanoramiXRes *clip = NULL;
    REQUEST(xCreateGCReq);
    int tile_offset = 0, stip_offset = 0, clip_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xCreateGCReq);
    
    client->errorValue = stuff->gc;
    len = client->req_len - bytes_to_int32(sizeof(xCreateGCReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if ((Mask)stuff->mask & GCTile) {
	tile_offset = Ones((Mask)stuff->mask & (GCTile - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + tile_offset))) {
	    result = dixLookupResourceByType((pointer *)&tile, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCStipple) {
	stip_offset = Ones((Mask)stuff->mask & (GCStipple - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + stip_offset))) {
	    result = dixLookupResourceByType((pointer *)&stip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCClipMask) {
	clip_offset = Ones((Mask)stuff->mask & (GCClipMask - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + clip_offset))) {
	    result = dixLookupResourceByType((pointer *)&clip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    if(!(newGC = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newGC->type = XRT_GC;
    panoramix_setup_ids(newGC, client, stuff->gc);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = newGC->info[j].id;
        stuff->drawable = refDraw->info[j].id;
	if (tile)
	    *((CARD32 *) &stuff[1] + tile_offset) = tile->info[j].id;
	if (stip)
	    *((CARD32 *) &stuff[1] + stip_offset) = stip->info[j].id;
	if (clip)
	    *((CARD32 *) &stuff[1] + clip_offset) = clip->info[j].id;
        result = (*SavedProcVector[X_CreateGC])(client);
        if(result != Success) break;
    }

    if (result == Success)
        AddResource(newGC->info[0].id, XRT_GC, newGC);
    else 
        free(newGC);

    return result;
}

int PanoramiXChangeGC(ClientPtr client)
{
    PanoramiXRes *gc;
    PanoramiXRes *stip = NULL;
    PanoramiXRes *tile = NULL;
    PanoramiXRes *clip = NULL;
    REQUEST(xChangeGCReq);
    int tile_offset = 0, stip_offset = 0, clip_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xChangeGCReq);
    
    len = client->req_len - bytes_to_int32(sizeof(xChangeGCReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    if ((Mask)stuff->mask & GCTile) {
	tile_offset = Ones((Mask)stuff->mask & (GCTile - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + tile_offset))) {
	    result = dixLookupResourceByType((pointer *)&tile, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCStipple) {
	stip_offset = Ones((Mask)stuff->mask & (GCStipple - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + stip_offset))) {
	    result = dixLookupResourceByType((pointer *)&stip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCClipMask) {
	clip_offset = Ones((Mask)stuff->mask & (GCClipMask - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + clip_offset))) {
	    result = dixLookupResourceByType((pointer *)&clip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }


    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = gc->info[j].id;
	if (tile)
	    *((CARD32 *) &stuff[1] + tile_offset) = tile->info[j].id;
	if (stip)
	    *((CARD32 *) &stuff[1] + stip_offset) = stip->info[j].id;
	if (clip)
	    *((CARD32 *) &stuff[1] + clip_offset) = clip->info[j].id;
        result = (*SavedProcVector[X_ChangeGC])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXCopyGC(ClientPtr client)
{
    PanoramiXRes *srcGC, *dstGC;
    int         result, j;
    REQUEST(xCopyGCReq);

    REQUEST_SIZE_MATCH(xCopyGCReq);

    result = dixLookupResourceByType((pointer *)&srcGC, stuff->srcGC, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    result = dixLookupResourceByType((pointer *)&dstGC, stuff->dstGC, XRT_GC,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS(j) {
	stuff->srcGC = srcGC->info[j].id;
	stuff->dstGC = dstGC->info[j].id;
	result = (*SavedProcVector[X_CopyGC])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXSetDashes(ClientPtr client)
{
    PanoramiXRes *gc;
    int         result, j;
    REQUEST(xSetDashesReq);

    REQUEST_FIXED_SIZE(xSetDashesReq, stuff->nDashes);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->gc = gc->info[j].id;
	result = (*SavedProcVector[X_SetDashes])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXSetClipRectangles(ClientPtr client)
{
    PanoramiXRes *gc;
    int         result, j;
    REQUEST(xSetClipRectanglesReq);

    REQUEST_AT_LEAST_SIZE(xSetClipRectanglesReq);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->gc = gc->info[j].id;
	result = (*SavedProcVector[X_SetClipRectangles])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXFreeGC(ClientPtr client)
{
    PanoramiXRes *gc;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&gc, stuff->id, XRT_GC,
				     client, DixDestroyAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = gc->info[j].id;
	result = (*SavedProcVector[X_FreeGC])(client);
	if(result != Success) break;
    }

    /* Since ProcFreeGC is using FreeResource, it will free
	our resource for us on the last pass through the loop above */
 
    return result;
}


int PanoramiXClearToBackground(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j, x, y;
    Bool	isRoot;
    REQUEST(xClearAreaReq);

    REQUEST_SIZE_MATCH(xClearAreaReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    x = stuff->x;
    y = stuff->y;
    isRoot = win->u.win.root;
    FOR_NSCREENS_BACKWARD(j) {
	stuff->window = win->info[j].id;
	if(isRoot) {
	    stuff->x = x - screenInfo.screens[j]->x;
	    stuff->y = y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ClearArea])(client);
	if(result != Success) break;
    }
 
    return result;
}


/* 
    For Window to Pixmap copies you're screwed since each screen's
    pixmap will look like what it sees on its screen.  Unless the
    screens overlap and the window lies on each, the two copies
    will be out of sync.  To remedy this we do a GetImage and PutImage
    in place of the copy.  Doing this as a single Image isn't quite
    correct since it will include the obscured areas but we will
    have to fix this later. (MArk).
*/

int PanoramiXCopyArea(ClientPtr client)
{
    int			j, result, srcx, srcy, dstx, dsty;
    PanoramiXRes	*gc, *src, *dst;
    Bool		srcIsRoot = FALSE;
    Bool		dstIsRoot = FALSE;
    Bool		srcShared, dstShared;
    REQUEST(xCopyAreaReq);

    REQUEST_SIZE_MATCH(xCopyAreaReq);

    result = dixLookupResourceByClass((pointer *)&src, stuff->srcDrawable,
				      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    srcShared = IS_SHARED_PIXMAP(src);

    result = dixLookupResourceByClass((pointer *)&dst, stuff->dstDrawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    dstShared = IS_SHARED_PIXMAP(dst);

    if(dstShared && srcShared)
	return (* SavedProcVector[X_CopyArea])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    if((dst->type == XRT_WINDOW) && dst->u.win.root)
	dstIsRoot = TRUE;
    if((src->type == XRT_WINDOW) && src->u.win.root)
	srcIsRoot = TRUE;

    srcx = stuff->srcX; srcy = stuff->srcY;
    dstx = stuff->dstX; dsty = stuff->dstY;
    if((dst->type == XRT_PIXMAP) && (src->type == XRT_WINDOW)) {
	DrawablePtr drawables[MAXSCREENS];
	DrawablePtr pDst;
	GCPtr pGC;
        char *data;
	int pitch, rc;

	FOR_NSCREENS(j) {
	    rc = dixLookupDrawable(drawables+j, src->info[j].id, client, 0,
				   DixGetAttrAccess);
	    if (rc != Success)
		return rc;
	}

	pitch = PixmapBytePad(stuff->width, drawables[0]->depth); 
	if(!(data = calloc(1, stuff->height * pitch)))
	    return BadAlloc;

	XineramaGetImageData(drawables, srcx, srcy, 
		stuff->width, stuff->height, ZPixmap, ~0, data, pitch, 
		srcIsRoot);

	FOR_NSCREENS_BACKWARD(j) {
	    stuff->gc = gc->info[j].id;
	    VALIDATE_DRAWABLE_AND_GC(dst->info[j].id, pDst, DixWriteAccess);
	    if(drawables[0]->depth != pDst->depth) {
		client->errorValue = stuff->dstDrawable;
		free(data);
		return BadMatch;
	    }

	    (*pGC->ops->PutImage) (pDst, pGC, pDst->depth, dstx, dsty, 
				   stuff->width, stuff->height, 
				   0, ZPixmap, data);

	    if(dstShared) break;
	}

	free(data);
    } else {
	DrawablePtr pDst = NULL, pSrc = NULL;
	GCPtr pGC = NULL;
	RegionRec totalReg;
	int rc;

	RegionNull(&totalReg);
	FOR_NSCREENS_BACKWARD(j) {
	    RegionPtr pRgn;
	    stuff->dstDrawable = dst->info[j].id;
	    stuff->srcDrawable = src->info[j].id;
	    stuff->gc          = gc->info[j].id;
 	    if (srcIsRoot) {	
		stuff->srcX = srcx - screenInfo.screens[j]->x;
		stuff->srcY = srcy - screenInfo.screens[j]->y;
	    }
 	    if (dstIsRoot) {	
		stuff->dstX = dstx - screenInfo.screens[j]->x;
		stuff->dstY = dsty - screenInfo.screens[j]->y;
	    }

	    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pDst, DixWriteAccess);

	    if (stuff->dstDrawable != stuff->srcDrawable) {
		rc = dixLookupDrawable(&pSrc, stuff->srcDrawable, client, 0,
				       DixReadAccess);
		if (rc != Success)
		    return rc;

		if ((pDst->pScreen != pSrc->pScreen) || 
		    (pDst->depth != pSrc->depth)) {
			client->errorValue = stuff->dstDrawable;
			return BadMatch;
   		}
 	    } else
		pSrc = pDst;

	    pRgn = (*pGC->ops->CopyArea)(pSrc, pDst, pGC,
				stuff->srcX, stuff->srcY,
				stuff->width, stuff->height, 
				stuff->dstX, stuff->dstY);
	    if(pGC->graphicsExposures && pRgn) {
	       if(srcIsRoot) {
		   RegionTranslate(pRgn,
			    screenInfo.screens[j]->x, screenInfo.screens[j]->y);
	       }
	       RegionAppend(&totalReg, pRgn);
	       RegionDestroy(pRgn);
	    }

	    if(dstShared)
		break;
	}

	if(pGC->graphicsExposures) {
	    Bool overlap;
	    RegionValidate(&totalReg, &overlap);
	    (*pDst->pScreen->SendGraphicsExpose)(
		client, &totalReg, stuff->dstDrawable, X_CopyArea, 0);
	    RegionUninit(&totalReg);
	}
    }

    return Success;
}


int PanoramiXCopyPlane(ClientPtr client)
{
    int			j, srcx, srcy, dstx, dsty, rc;
    PanoramiXRes	*gc, *src, *dst;
    Bool		srcIsRoot = FALSE;
    Bool		dstIsRoot = FALSE;
    Bool		srcShared, dstShared;
    DrawablePtr 	psrcDraw, pdstDraw = NULL;
    GCPtr 		pGC = NULL;
    RegionRec		totalReg;
    REQUEST(xCopyPlaneReq);

    REQUEST_SIZE_MATCH(xCopyPlaneReq);

    rc = dixLookupResourceByClass((pointer *)&src, stuff->srcDrawable,
				  XRC_DRAWABLE, client, DixReadAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    srcShared = IS_SHARED_PIXMAP(src);

    rc = dixLookupResourceByClass((pointer *)&dst, stuff->dstDrawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    dstShared = IS_SHARED_PIXMAP(dst);

    if(dstShared && srcShared)
	return (* SavedProcVector[X_CopyPlane])(client);

    rc = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				 client, DixReadAccess);
    if (rc != Success)
	return rc;

    if((dst->type == XRT_WINDOW) && dst->u.win.root)
	dstIsRoot = TRUE;
    if((src->type == XRT_WINDOW) && src->u.win.root)
	srcIsRoot = TRUE;

    srcx = stuff->srcX; srcy = stuff->srcY;
    dstx = stuff->dstX; dsty = stuff->dstY;
 
    RegionNull(&totalReg);
    FOR_NSCREENS_BACKWARD(j) {
	RegionPtr pRgn;
	stuff->dstDrawable = dst->info[j].id;
	stuff->srcDrawable = src->info[j].id;
	stuff->gc          = gc->info[j].id;
	if (srcIsRoot) {	
	    stuff->srcX = srcx - screenInfo.screens[j]->x;
	    stuff->srcY = srcy - screenInfo.screens[j]->y;
	}
	if (dstIsRoot) {	
	    stuff->dstX = dstx - screenInfo.screens[j]->x;
	    stuff->dstY = dsty - screenInfo.screens[j]->y;
	}

	VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pdstDraw, DixWriteAccess);
	if (stuff->dstDrawable != stuff->srcDrawable) {
	    rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,
				   DixReadAccess);
	    if (rc != Success)
		return rc;

            if (pdstDraw->pScreen != psrcDraw->pScreen) {
		client->errorValue = stuff->dstDrawable;
		return BadMatch;
	    }
	} else
	    psrcDraw = pdstDraw;

	if(stuff->bitPlane == 0 || (stuff->bitPlane & (stuff->bitPlane - 1)) ||
		(stuff->bitPlane > (1L << (psrcDraw->depth - 1)))) {
	    client->errorValue = stuff->bitPlane;
	    return BadValue;
	}

	pRgn = (*pGC->ops->CopyPlane)(psrcDraw, pdstDraw, pGC,
				stuff->srcX, stuff->srcY,
				stuff->width, stuff->height, 
				stuff->dstX, stuff->dstY, stuff->bitPlane);
	if(pGC->graphicsExposures && pRgn) {
	    RegionAppend(&totalReg, pRgn);
	    RegionDestroy(pRgn);
	}

	if(dstShared)
	    break;
    }

    if(pGC->graphicsExposures) {
	Bool overlap;
	RegionValidate(&totalReg, &overlap);
	(*pdstDraw->pScreen->SendGraphicsExpose)(
		client, &totalReg, stuff->dstDrawable, X_CopyPlane, 0);
	RegionUninit(&totalReg);
    }

    return Success;
}


int PanoramiXPolyPoint(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    int 	  result, npoint, j;
    xPoint 	  *origPts;
    Bool	  isRoot;
    REQUEST(xPolyPointReq);

    REQUEST_AT_LEAST_SIZE(xPolyPointReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyPoint])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyPointReq));
    if (npoint > 0) {
        origPts = malloc(npoint * sizeof(xPoint));
        memcpy((char *) origPts, (char *) &stuff[1], npoint * sizeof(xPoint));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origPts, npoint * sizeof(xPoint));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xPoint *pnts = (xPoint*)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : npoint;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
                    }
		}
            }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyPoint])(client);
	    if(result != Success) break;
        }
        free(origPts);
        return result;
    } else
	return Success;
}


int PanoramiXPolyLine(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    int 	  result, npoint, j;
    xPoint 	  *origPts;
    Bool	  isRoot;
    REQUEST(xPolyLineReq);

    REQUEST_AT_LEAST_SIZE(xPolyLineReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyLine])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);
    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyLineReq));
    if (npoint > 0){
        origPts = malloc(npoint * sizeof(xPoint));
        memcpy((char *) origPts, (char *) &stuff[1], npoint * sizeof(xPoint));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origPts, npoint * sizeof(xPoint));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xPoint *pnts = (xPoint*)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : npoint;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
		    }
		}
            }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyLine])(client);
	    if(result != Success) break;
        }
        free(origPts);
        return result;
   } else
	return Success;
}


int PanoramiXPolySegment(ClientPtr client)
{
    int		  result, nsegs, i, j;
    PanoramiXRes *gc, *draw;
    xSegment 	  *origSegs;
    Bool	  isRoot;
    REQUEST(xPolySegmentReq);

    REQUEST_AT_LEAST_SIZE(xPolySegmentReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolySegment])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    nsegs = (client->req_len << 2) - sizeof(xPolySegmentReq);
    if(nsegs & 4) return BadLength;
    nsegs >>= 3;
    if (nsegs > 0) {
	origSegs = malloc(nsegs * sizeof(xSegment));
        memcpy((char *) origSegs, (char *) &stuff[1], nsegs * sizeof(xSegment));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origSegs, nsegs * sizeof(xSegment));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xSegment *segs = (xSegment*)&stuff[1];

		    for (i = nsegs; i--; segs++) {
			segs->x1 -= x_off;
			segs->x2 -= x_off;
			segs->y1 -= y_off;
			segs->y2 -= y_off;
		    }
		}
            }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolySegment])(client);
	    if(result != Success) break;
    	}
	free(origSegs);
	return result;
    } else
	  return Success;
}


int PanoramiXPolyRectangle(ClientPtr client)
{
    int 	  result, nrects, i, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    xRectangle 	  *origRecs;
    REQUEST(xPolyRectangleReq);

    REQUEST_AT_LEAST_SIZE(xPolyRectangleReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyRectangle])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    nrects = (client->req_len << 2) - sizeof(xPolyRectangleReq);
    if(nrects & 4) return BadLength;
    nrects >>= 3;
    if (nrects > 0){
	origRecs = malloc(nrects * sizeof(xRectangle));
	memcpy((char *)origRecs,(char *)&stuff[1],nrects * sizeof(xRectangle));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origRecs, nrects * sizeof(xRectangle));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;


		if(x_off || y_off) {
	    	    xRectangle *rects = (xRectangle *) &stuff[1];

		    for (i = nrects; i--; rects++) {
			rects->x -= x_off;
			rects->y -= y_off;
		    }
		}
	    } 

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyRectangle])(client);
	    if(result != Success) break;
	}
	free(origRecs);
	return result;
    } else
       return Success;
}


int PanoramiXPolyArc(ClientPtr client)
{
    int 	  result, narcs, i, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    xArc	  *origArcs;
    REQUEST(xPolyArcReq);

    REQUEST_AT_LEAST_SIZE(xPolyArcReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyArc])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    narcs = (client->req_len << 2) - sizeof(xPolyArcReq);
    if(narcs % sizeof(xArc)) return BadLength;
    narcs /= sizeof(xArc);
    if (narcs > 0){
	origArcs = malloc(narcs * sizeof(xArc));
	memcpy((char *) origArcs, (char *) &stuff[1], narcs * sizeof(xArc));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origArcs, narcs * sizeof(xArc));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;
	
		if(x_off || y_off) {
		    xArc *arcs = (xArc *) &stuff[1];

		    for (i = narcs; i--; arcs++) {
			arcs->x -= x_off;
			arcs->y -= y_off;
		    }
		}
            }
	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyArc])(client);
	    if(result != Success) break;
        }
	free(origArcs);
	return result;
    } else
       return Success;
}


int PanoramiXFillPoly(ClientPtr client)
{
    int 	  result, count, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    DDXPointPtr	  locPts;
    REQUEST(xFillPolyReq);

    REQUEST_AT_LEAST_SIZE(xFillPolyReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_FillPoly])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    count = bytes_to_int32((client->req_len << 2) - sizeof(xFillPolyReq));
    if (count > 0){
	locPts = malloc(count * sizeof(DDXPointRec));
	memcpy((char *)locPts, (char *)&stuff[1], count * sizeof(DDXPointRec));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], locPts, count * sizeof(DDXPointRec));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    DDXPointPtr pnts = (DDXPointPtr)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : count;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_FillPoly])(client);
	    if(result != Success) break;
	}
	free(locPts);
	return result;
    } else
       return Success;
}


int PanoramiXPolyFillRectangle(ClientPtr client)
{
    int 	  result, things, i, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    xRectangle	  *origRects;
    REQUEST(xPolyFillRectangleReq);

    REQUEST_AT_LEAST_SIZE(xPolyFillRectangleReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyFillRectangle])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    things = (client->req_len << 2) - sizeof(xPolyFillRectangleReq);
    if(things & 4) return BadLength;
    things >>= 3;
    if (things > 0){
	origRects = malloc(things * sizeof(xRectangle));
	memcpy((char*)origRects,(char*)&stuff[1], things * sizeof(xRectangle));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], origRects, things * sizeof(xRectangle));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xRectangle *rects = (xRectangle *) &stuff[1];

		    for (i = things; i--; rects++) {
			rects->x -= x_off;
			rects->y -= y_off;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyFillRectangle])(client);
	    if(result != Success) break;
	}
	free(origRects);
	return result;
    } else
       return Success;
}


int PanoramiXPolyFillArc(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int 	  result, narcs, i, j;
    xArc	  *origArcs;
    REQUEST(xPolyFillArcReq);

    REQUEST_AT_LEAST_SIZE(xPolyFillArcReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyFillArc])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    narcs = (client->req_len << 2) - sizeof(xPolyFillArcReq);
    if (narcs % sizeof(xArc)) return BadLength;
    narcs /= sizeof(xArc);
    if (narcs > 0) {
	origArcs = malloc(narcs * sizeof(xArc));
	memcpy((char *) origArcs, (char *)&stuff[1], narcs * sizeof(xArc));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], origArcs, narcs * sizeof(xArc));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xArc *arcs = (xArc *) &stuff[1];

		    for (i = narcs; i--; arcs++) {
			arcs->x -= x_off;
			arcs->y -= y_off;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyFillArc])(client);
	    if(result != Success) break;
	}
	free(origArcs);
	return result;
    } else
       return Success;
}


int PanoramiXPutImage(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int		  j, result, orig_x, orig_y;
    REQUEST(xPutImageReq);

    REQUEST_AT_LEAST_SIZE(xPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PutImage])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->dstX;
    orig_y = stuff->dstY;
    FOR_NSCREENS_BACKWARD(j){
	if (isRoot) {
	  stuff->dstX = orig_x - screenInfo.screens[j]->x;
	  stuff->dstY = orig_y - screenInfo.screens[j]->y;
	}
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	result = (* SavedProcVector[X_PutImage])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXGetImage(ClientPtr client)
{
    DrawablePtr 	drawables[MAXSCREENS];
    DrawablePtr 	pDraw;
    PanoramiXRes	*draw;
    xGetImageReply	xgi;
    Bool		isRoot;
    char		*pBuf;
    int         	i, x, y, w, h, format, rc;
    Mask		plane = 0, planemask;
    int			linesDone, nlines, linesPerBuf;
    long		widthBytesLine, length;

    REQUEST(xGetImageReq);

    REQUEST_SIZE_MATCH(xGetImageReq);

    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap)) {
	client->errorValue = stuff->format;
        return BadValue;
    }

    rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    if(draw->type == XRT_PIXMAP)
	return (*SavedProcVector[X_GetImage])(client);

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;

    if(!((WindowPtr)pDraw)->realized)
	return BadMatch;

    x = stuff->x;
    y = stuff->y;
    w = stuff->width;
    h = stuff->height;
    format = stuff->format;
    planemask = stuff->planeMask;

    isRoot = IS_ROOT_DRAWABLE(draw);

    if(isRoot) {
      if( /* check for being onscreen */
	x < 0 || x + w > PanoramiXPixWidth ||
	y < 0 || y + h > PanoramiXPixHeight )
	    return BadMatch;
    } else {
      if( /* check for being onscreen */
	screenInfo.screens[0]->x + pDraw->x + x < 0 ||
	screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth ||
	screenInfo.screens[0]->y + pDraw->y + y < 0 ||
	screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight ||
	 /* check for being inside of border */
       	x < - wBorderWidth((WindowPtr)pDraw) ||
	x + w > wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
	y < -wBorderWidth((WindowPtr)pDraw) ||
	y + h > wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height)
	    return BadMatch;
    }

    drawables[0] = pDraw;
    FOR_NSCREENS_FORWARD_SKIP(i) {
	rc = dixLookupDrawable(drawables+i, draw->info[i].id, client, 0,
			       DixGetAttrAccess);
	if (rc != Success)
	    return rc;
    }

    xgi.visual = wVisual (((WindowPtr) pDraw));
    xgi.type = X_Reply;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
    if(format == ZPixmap) {
	widthBytesLine = PixmapBytePad(w, pDraw->depth);
	length = widthBytesLine * h;


    } else {
	widthBytesLine = BitmapBytePad(w);
	plane = ((Mask)1) << (pDraw->depth - 1);
	/* only planes asked for */
	length = widthBytesLine * h *
		 Ones(planemask & (plane | (plane - 1)));

    }

    xgi.length = bytes_to_int32(length);

    if (widthBytesLine == 0 || h == 0)
	linesPerBuf = 0;
    else if (widthBytesLine >= XINERAMA_IMAGE_BUFSIZE)
	linesPerBuf = 1;
    else {
	linesPerBuf = XINERAMA_IMAGE_BUFSIZE / widthBytesLine;
	if (linesPerBuf > h)
	    linesPerBuf = h;
    }
    length = linesPerBuf * widthBytesLine;
    if(!(pBuf = malloc(length)))
	return BadAlloc;

    WriteReplyToClient(client, sizeof (xGetImageReply), &xgi);

    if (linesPerBuf == 0) {
	/* nothing to do */
    }
    else if (format == ZPixmap) {
        linesDone = 0;
        while (h - linesDone > 0) {
	    nlines = min(linesPerBuf, h - linesDone);

	    if(pDraw->depth == 1)
		memset(pBuf, 0, nlines * widthBytesLine);

	    XineramaGetImageData(drawables, x, y + linesDone, w, nlines,
			format, planemask, pBuf, widthBytesLine, isRoot);

		(void)WriteToClient(client,
				    (int)(nlines * widthBytesLine),
				    pBuf);
	    linesDone += nlines;
        }
    } else { /* XYPixmap */
        for (; plane; plane >>= 1) {
	    if (planemask & plane) {
	        linesDone = 0;
	        while (h - linesDone > 0) {
		    nlines = min(linesPerBuf, h - linesDone);

		    memset(pBuf, 0, nlines * widthBytesLine);

		    XineramaGetImageData(drawables, x, y + linesDone, w, 
					nlines, format, plane, pBuf,
					widthBytesLine, isRoot);

		    (void)WriteToClient(client,
				    (int)(nlines * widthBytesLine),
				    pBuf);

		    linesDone += nlines;
		}
            }
	}
    }
    free(pBuf);
    return Success;
}


/* The text stuff should be rewritten so that duplication happens
   at the GlyphBlt level.  That is, loading the font and getting
   the glyphs should only happen once */

int 
PanoramiXPolyText8(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int 	  result, j;
    int	 	  orig_x, orig_y;
    REQUEST(xPolyTextReq);

    REQUEST_AT_LEAST_SIZE(xPolyTextReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyText8])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_PolyText8])(client);
	if(result != Success) break;
    }
    return result;
}

int 
PanoramiXPolyText16(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int 	  result, j;
    int	 	  orig_x, orig_y;
    REQUEST(xPolyTextReq);

    REQUEST_AT_LEAST_SIZE(xPolyTextReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyText16])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_PolyText16])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXImageText8(ClientPtr client)
{
    int 	  result, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int		  orig_x, orig_y;
    REQUEST(xImageTextReq);

    REQUEST_FIXED_SIZE(xImageTextReq, stuff->nChars);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_ImageText8])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ImageText8])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXImageText16(ClientPtr client)
{
    int 	  result, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int		  orig_x, orig_y;
    REQUEST(xImageTextReq);

    REQUEST_FIXED_SIZE(xImageTextReq, stuff->nChars << 1);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_ImageText16])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ImageText16])(client);
	if(result != Success) break;
    }
    return result;
}



int PanoramiXCreateColormap(ClientPtr client)
{
    PanoramiXRes	*win, *newCmap;
    int 		result, j, orig_visual;
    REQUEST(xCreateColormapReq);

    REQUEST_SIZE_MATCH(xCreateColormapReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    if(!(newCmap = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newCmap->type = XRT_COLORMAP;
    panoramix_setup_ids(newCmap, client, stuff->mid);

    orig_visual = stuff->visual;
    FOR_NSCREENS_BACKWARD(j){
	stuff->mid = newCmap->info[j].id;
	stuff->window = win->info[j].id;
	stuff->visual = PanoramiXTranslateVisualID(j, orig_visual);
	result = (* SavedProcVector[X_CreateColormap])(client);
	if(result != Success) break;
    }
 
    if (result == Success)
        AddResource(newCmap->info[0].id, XRT_COLORMAP, newCmap);
    else 
        free(newCmap);

    return result;
}


int PanoramiXFreeColormap(ClientPtr client)
{
    PanoramiXRes *cmap;
    int          result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixDestroyAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = cmap->info[j].id;
        result = (* SavedProcVector[X_FreeColormap])(client);
	if(result != Success) break;
    }

    /* Since ProcFreeColormap is using FreeResource, it will free
	our resource for us on the last pass through the loop above */

    return result;
}


int
PanoramiXCopyColormapAndFree(ClientPtr client)
{
    PanoramiXRes *cmap, *newCmap;
    int          result, j;
    REQUEST(xCopyColormapAndFreeReq);

    REQUEST_SIZE_MATCH(xCopyColormapAndFreeReq);

    client->errorValue = stuff->srcCmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->srcCmap,
				     XRT_COLORMAP, client,
				     DixReadAccess | DixWriteAccess);
    if (result != Success)
        return result;

    if(!(newCmap = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newCmap->type = XRT_COLORMAP;
    panoramix_setup_ids(newCmap, client, stuff->mid);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->srcCmap = cmap->info[j].id;
	stuff->mid = newCmap->info[j].id;
        result = (* SavedProcVector[X_CopyColormapAndFree])(client);
	if(result != Success) break;
    }

    if (result == Success)
        AddResource(newCmap->info[0].id, XRT_COLORMAP, newCmap);
    else 
        free(newCmap);

    return result;
}


int PanoramiXInstallColormap(ClientPtr client)
{
    REQUEST(xResourceReq);
    int 	result, j;
    PanoramiXRes *cmap;

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
	stuff->id = cmap->info[j].id;
	result = (* SavedProcVector[X_InstallColormap])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXUninstallColormap(ClientPtr client)
{
    REQUEST(xResourceReq);
    int 	result, j;
    PanoramiXRes *cmap;

    REQUEST_SIZE_MATCH(xResourceReq);
 
    client->errorValue = stuff->id;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = cmap->info[j].id;
	result = (* SavedProcVector[X_UninstallColormap])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXAllocColor(ClientPtr client)
{
    int           result, j;
    PanoramiXRes *cmap;
    REQUEST(xAllocColorReq);

    REQUEST_SIZE_MATCH(xAllocColorReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColor])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXAllocNamedColor(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xAllocNamedColorReq);

    REQUEST_FIXED_SIZE(xAllocNamedColorReq, stuff->nbytes);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
        stuff->cmap = cmap->info[j].id;
        result = (* SavedProcVector[X_AllocNamedColor])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXAllocColorCells(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xAllocColorCellsReq);

    REQUEST_SIZE_MATCH(xAllocColorCellsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;
	
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColorCells])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXAllocColorPlanes(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xAllocColorPlanesReq);

    REQUEST_SIZE_MATCH(xAllocColorPlanesReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;
	
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColorPlanes])(client);
	if(result != Success) break;
    }
    return result;
}



int PanoramiXFreeColors(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xFreeColorsReq);

    REQUEST_AT_LEAST_SIZE(xFreeColorsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (* SavedProcVector[X_FreeColors])(client);
    }
    return result;
}


int PanoramiXStoreColors(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xStoreColorsReq);

    REQUEST_AT_LEAST_SIZE(xStoreColorsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_StoreColors])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXStoreNamedColor(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xStoreNamedColorReq);

    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_StoreNamedColor])(client);
	if(result != Success) break;
    }
    return result;
}

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _PANORAMIXSRV_H_
#define _PANORAMIXSRV_H_

#include "panoramiX.h"

extern _X_EXPORT int PanoramiXNumScreens;
extern _X_EXPORT int PanoramiXPixWidth;
extern _X_EXPORT int PanoramiXPixHeight;

extern _X_EXPORT VisualID PanoramiXTranslateVisualID(int screen, VisualID orig);
extern _X_EXPORT void PanoramiXConsolidate(void);
extern _X_EXPORT Bool PanoramiXCreateConnectionBlock(void);
extern _X_EXPORT PanoramiXRes * PanoramiXFindIDByScrnum(RESTYPE, XID, int);
extern _X_EXPORT Bool XineramaRegisterConnectionBlockCallback(void (*func)(void));
extern _X_EXPORT int XineramaDeleteResource(pointer, XID);

extern _X_EXPORT void XineramaReinitData(ScreenPtr);

extern _X_EXPORT RESTYPE XRC_DRAWABLE;
extern _X_EXPORT RESTYPE XRT_WINDOW;
extern _X_EXPORT RESTYPE XRT_PIXMAP;
extern _X_EXPORT RESTYPE XRT_GC;
extern _X_EXPORT RESTYPE XRT_COLORMAP;
extern _X_EXPORT RESTYPE XRT_PICTURE;

/*
 * Drivers are allowed to wrap this function.  Each wrapper can decide that the
 * two visuals are unequal, but if they are deemed equal, the wrapper must call
 * down and return FALSE if the wrapped function does.  This ensures that all
 * layers agree that the visuals are equal.  The first visual is always from
 * screen 0.
 */
typedef Bool (*XineramaVisualsEqualProcPtr)(VisualPtr, ScreenPtr, VisualPtr);
extern _X_EXPORT XineramaVisualsEqualProcPtr XineramaVisualsEqualPtr;

extern _X_EXPORT void XineramaGetImageData(
    DrawablePtr *pDrawables,
    int left,
    int top,
    int width, 
    int height,
    unsigned int format,
    unsigned long planemask,
    char *data,
    int pitch,
    Bool isRoot
);

static inline void panoramix_setup_ids(PanoramiXRes *resource, 
                                       ClientPtr client, XID base_id)
{
    int j;

    resource->info[0].id = base_id;
    FOR_NSCREENS_FORWARD_SKIP(j) {
        resource->info[j].id = FakeClientID(client->index);
    }
}

#endif /* _PANORAMIXSRV_H_ */
/*****************************************************************
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "cursor.h"
#include "cursorstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "gc.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#include "window.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "panoramiX.h"
#include <X11/extensions/panoramiXproto.h>
#include "panoramiXsrv.h"
#include "globals.h"
#include "panoramiXh.h"

static int
SProcPanoramiXQueryVersion (ClientPtr client)
{
	REQUEST(xPanoramiXQueryVersionReq);
	int n;

	swaps(&stuff->length,n);
	REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
	return ProcPanoramiXQueryVersion(client);
}

static int
SProcPanoramiXGetState(ClientPtr client)
{
	REQUEST(xPanoramiXGetStateReq);
	int n;

 	swaps (&stuff->length, n);	
	REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
	swapl (&stuff->window, n);
	return ProcPanoramiXGetState(client);
}

static int 
SProcPanoramiXGetScreenCount(ClientPtr client)
{
	REQUEST(xPanoramiXGetScreenCountReq);
	int n;

	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
	swapl (&stuff->window, n);
	return ProcPanoramiXGetScreenCount(client);
}

static int 
SProcPanoramiXGetScreenSize(ClientPtr client)
{
	REQUEST(xPanoramiXGetScreenSizeReq);
	int n;

	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
	swapl (&stuff->window, n);
	swapl (&stuff->screen, n);
	return ProcPanoramiXGetScreenSize(client);
}


static int 
SProcXineramaIsActive(ClientPtr client)
{
	REQUEST(xXineramaIsActiveReq);
	int n;

	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
	return ProcXineramaIsActive(client);
}


static int 
SProcXineramaQueryScreens(ClientPtr client)
{
	REQUEST(xXineramaQueryScreensReq);
	int n;

	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
	return ProcXineramaQueryScreens(client);
}


int
SProcPanoramiXDispatch (ClientPtr client)
{   REQUEST(xReq);
    switch (stuff->data)
    {
	case X_PanoramiXQueryVersion:
	     return SProcPanoramiXQueryVersion(client);
	case X_PanoramiXGetState:
	     return SProcPanoramiXGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SProcPanoramiXGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SProcPanoramiXGetScreenSize(client);
	case X_XineramaIsActive:
	     return SProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SProcXineramaQueryScreens(client);
    }
    return BadRequest;
}
/*
 *
Copyright (c) 1992  X Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the X Consortium.
 *
 * Author:  Keith Packard, MIT X Consortium
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/saverproto.h>
#include "gcstruct.h"
#include "cursorstr.h"
#include "colormapst.h"
#include "xace.h"
#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
#ifdef DPMSExtension
#include <X11/extensions/dpmsconst.h>
#endif
#include "protocol-versions.h"

#include <stdio.h>

#include "modinit.h"

static int ScreenSaverEventBase = 0;


static Bool ScreenSaverHandle (
	ScreenPtr /* pScreen */,
	int /* xstate */,
	Bool /* force */
	);

static Bool
CreateSaverWindow (
	ScreenPtr /* pScreen */
	);

static Bool
DestroySaverWindow (
	ScreenPtr /* pScreen */
	);

static void
UninstallSaverColormap (
	ScreenPtr /* pScreen */
	);

static void
CheckScreenPrivate (
	ScreenPtr /* pScreen */
	);

static void SScreenSaverNotifyEvent (
	xScreenSaverNotifyEvent * /* from */,
	xScreenSaverNotifyEvent * /* to */
	);

static RESTYPE SuspendType;  /* resource type for suspension records */

typedef struct _ScreenSaverSuspension *ScreenSaverSuspensionPtr;

/* List of clients that are suspending the screensaver. */
static ScreenSaverSuspensionPtr suspendingClients = NULL;

/*
 * clientResource is a resource ID that's added when the record is
 * allocated, so the record is freed and the screensaver resumed when
 * the client disconnects. count is the number of times the client has
 * requested the screensaver be suspended.
 */
typedef struct _ScreenSaverSuspension
{
    ScreenSaverSuspensionPtr  next;
    ClientPtr                 pClient;
    XID                       clientResource;
    int                       count;
} ScreenSaverSuspensionRec;

static int ScreenSaverFreeSuspend(
    pointer /*value */,
    XID /* id */
);

/*
 * each screen has a list of clients requesting
 * ScreenSaverNotify events.  Each client has a resource
 * for each screen it selects ScreenSaverNotify input for,
 * this resource is used to delete the ScreenSaverNotifyRec
 * entry from the per-screen queue.
 */

static RESTYPE SaverEventType;   /* resource type for event masks */

typedef struct _ScreenSaverEvent *ScreenSaverEventPtr;

typedef struct _ScreenSaverEvent {
    ScreenSaverEventPtr	next;
    ClientPtr		client;
    ScreenPtr		screen;
    XID			resource;
    CARD32		mask;
} ScreenSaverEventRec;

static int ScreenSaverFreeEvents(
    pointer /* value */,
    XID /* id */
);

static Bool setEventMask (
    ScreenPtr /* pScreen */,
    ClientPtr /* client */,
    unsigned long /* mask */
);

static unsigned long getEventMask (
    ScreenPtr /* pScreen */,
    ClientPtr /* client */
);

/*
 * when a client sets the screen saver attributes, a resource is
 * kept to be freed when the client exits
 */

static RESTYPE AttrType;    /* resource type for attributes */

typedef struct _ScreenSaverAttr {
    ScreenPtr	    screen;
    ClientPtr	    client;
    XID		    resource;
    short	    x, y;
    unsigned short  width, height, borderWidth;
    unsigned char   class;
    unsigned char   depth;
    VisualID	    visual;
    CursorPtr	    pCursor;
    PixmapPtr	    pBackgroundPixmap;
    PixmapPtr	    pBorderPixmap;
    Colormap	    colormap;
    unsigned long   mask;		/* no pixmaps or cursors */
    unsigned long   *values;
} ScreenSaverAttrRec, *ScreenSaverAttrPtr;

static int ScreenSaverFreeAttr (
    pointer /* value */,
    XID /* id */
);

static void FreeAttrs (
    ScreenSaverAttrPtr	/* pAttr */
);

static void FreeScreenAttr (
    ScreenSaverAttrPtr	/* pAttr */
);

static void
SendScreenSaverNotify (
    ScreenPtr /* pScreen */,
    int /* state */,
    Bool /* forced */
);

typedef struct _ScreenSaverScreenPrivate {
    ScreenSaverEventPtr	    events;
    ScreenSaverAttrPtr	    attr;
    Bool		    hasWindow;
    Colormap		    installedMap;
} ScreenSaverScreenPrivateRec, *ScreenSaverScreenPrivatePtr;

static ScreenSaverScreenPrivatePtr
MakeScreenPrivate (
	ScreenPtr /* pScreen */
	);

static DevPrivateKeyRec ScreenPrivateKeyRec;
#define ScreenPrivateKey (&ScreenPrivateKeyRec)

#define GetScreenPrivate(s) ((ScreenSaverScreenPrivatePtr) \
    dixLookupPrivate(&(s)->devPrivates, ScreenPrivateKey))
#define SetScreenPrivate(s,v) \
    dixSetPrivate(&(s)->devPrivates, ScreenPrivateKey, v);
#define SetupScreen(s)	ScreenSaverScreenPrivatePtr pPriv = (s ? GetScreenPrivate(s) : NULL)

#define New(t)	(malloc(sizeof (t)))

static void
CheckScreenPrivate (ScreenPtr pScreen)
{
    SetupScreen (pScreen);

    if (!pPriv)
	return;
    if (!pPriv->attr && !pPriv->events &&
	!pPriv->hasWindow && pPriv->installedMap == None)
    {
	free(pPriv);
	SetScreenPrivate (pScreen, NULL);
	pScreen->screensaver.ExternalScreenSaver = NULL;
    }
}

static ScreenSaverScreenPrivatePtr
MakeScreenPrivate (ScreenPtr pScreen)
{
    SetupScreen (pScreen);

    if (pPriv)
	return pPriv;
    pPriv = New (ScreenSaverScreenPrivateRec);
    if (!pPriv)
	return 0;
    pPriv->events = 0;
    pPriv->attr = 0;
    pPriv->hasWindow = FALSE;
    pPriv->installedMap = None;
    SetScreenPrivate (pScreen, pPriv);
    pScreen->screensaver.ExternalScreenSaver = ScreenSaverHandle;
    return pPriv;
}

static unsigned long
getEventMask (ScreenPtr pScreen, ClientPtr client)
{
    SetupScreen(pScreen);
    ScreenSaverEventPtr	pEv;

    if (!pPriv)
	return 0;
    for (pEv = pPriv->events; pEv; pEv = pEv->next)
	if (pEv->client == client)
	    return pEv->mask;
    return 0;
}

static Bool
setEventMask (ScreenPtr pScreen, ClientPtr client, unsigned long mask)
{
    SetupScreen(pScreen);
    ScreenSaverEventPtr	pEv, *pPrev;

    if (getEventMask (pScreen, client) == mask)
	return TRUE;
    if (!pPriv)
    {
	pPriv = MakeScreenPrivate (pScreen);
	if (!pPriv)
	    return FALSE;
    }
    for (pPrev = &pPriv->events; (pEv = *pPrev) != 0; pPrev = &pEv->next)
	if (pEv->client == client)
	    break;
    if (mask == 0)
    {
	FreeResource (pEv->resource, SaverEventType);
	*pPrev = pEv->next;
	free(pEv);
	CheckScreenPrivate (pScreen);
    }
    else
    {
    	if (!pEv) 
    	{
	    pEv = New (ScreenSaverEventRec);
	    if (!pEv) 
	    {
		CheckScreenPrivate (pScreen);
	    	return FALSE;
	    }
    	    *pPrev = pEv;
    	    pEv->next = NULL;
    	    pEv->client = client;
    	    pEv->screen = pScreen;
    	    pEv->resource = FakeClientID (client->index);
	    if (!AddResource (pEv->resource, SaverEventType, (pointer) pEv))
		return FALSE;
    	}
	pEv->mask = mask;
    }
    return TRUE;
}

static void
FreeAttrs (ScreenSaverAttrPtr pAttr)
{
    PixmapPtr	    pPixmap;
    CursorPtr	    pCursor;

    if ((pPixmap = pAttr->pBackgroundPixmap) != 0)
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
    if ((pPixmap = pAttr->pBorderPixmap) != 0)
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
    if ((pCursor = pAttr->pCursor) != 0)
	FreeCursor (pCursor, (Cursor) 0);
}

static void
FreeScreenAttr (ScreenSaverAttrPtr pAttr)
{
    FreeAttrs (pAttr);
    free(pAttr->values);
    free(pAttr);
}

static int
ScreenSaverFreeEvents (pointer value, XID id)
{
    ScreenSaverEventPtr	pOld = (ScreenSaverEventPtr)value;
    ScreenPtr pScreen = pOld->screen;
    SetupScreen (pScreen);
    ScreenSaverEventPtr	pEv, *pPrev;

    if (!pPriv)
	return TRUE;
    for (pPrev = &pPriv->events; (pEv = *pPrev) != 0; pPrev = &pEv->next)
	if (pEv == pOld)
	    break;
    if (!pEv)
	return TRUE;
    *pPrev = pEv->next;
    free(pEv);
    CheckScreenPrivate (pScreen);
    return TRUE;
}

static int
ScreenSaverFreeAttr (pointer value, XID id)
{
    ScreenSaverAttrPtr	pOldAttr = (ScreenSaverAttrPtr)value;
    ScreenPtr	pScreen = pOldAttr->screen;
    SetupScreen (pScreen);

    if (!pPriv)
	return TRUE;
    if (pPriv->attr != pOldAttr)
	return TRUE;
    FreeScreenAttr (pOldAttr);
    pPriv->attr = NULL;
    if (pPriv->hasWindow)
    {
	dixSaveScreens (serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);
	dixSaveScreens (serverClient, SCREEN_SAVER_FORCER, ScreenSaverActive);
    }
    CheckScreenPrivate (pScreen);
    return TRUE;
}

static int
ScreenSaverFreeSuspend (pointer value, XID id)
{
    ScreenSaverSuspensionPtr data = (ScreenSaverSuspensionPtr) value;
    ScreenSaverSuspensionPtr *prev, this;

    /* Unlink and free the suspension record for the client */
    for (prev = &suspendingClients; (this = *prev); prev = &this->next)
    {
	if (this == data)
	{
	    *prev = this->next;
	    free(this);
	    break;
	}
    }

    /* Reenable the screensaver if this was the last client suspending it. */
    if (screenSaverSuspended && suspendingClients == NULL)
    {
	screenSaverSuspended = FALSE;

	/* The screensaver could be active, since suspending it (by design)
	   doesn't prevent it from being forceably activated */
#ifdef DPMSExtension
	if (screenIsSaved != SCREEN_SAVER_ON && DPMSPowerLevel == DPMSModeOn)
#else
	if (screenIsSaved != SCREEN_SAVER_ON)
#endif
	{
	    UpdateCurrentTimeIf();
	    lastDeviceEventTime = currentTime;
	    SetScreenSaverTimer();
	}
    }

    return Success;
}

static void
SendScreenSaverNotify (ScreenPtr pScreen, int state, Bool forced)
{
    ScreenSaverScreenPrivatePtr	pPriv;
    ScreenSaverEventPtr		pEv;
    unsigned long		mask;
    xScreenSaverNotifyEvent	ev;
    int				kind;

    UpdateCurrentTimeIf ();
    mask = ScreenSaverNotifyMask;
    if (state == ScreenSaverCycle)
	mask = ScreenSaverCycleMask;
    pScreen = screenInfo.screens[pScreen->myNum];
    pPriv = GetScreenPrivate(pScreen);
    if (!pPriv)
	return;
    if (pPriv->attr)
	kind = ScreenSaverExternal;
    else if (ScreenSaverBlanking != DontPreferBlanking)
	kind = ScreenSaverBlanked;
    else
	kind = ScreenSaverInternal;
    for (pEv = pPriv->events; pEv; pEv = pEv->next)
    {
	if (!(pEv->mask & mask))
	    continue;
	ev.type = ScreenSaverNotify + ScreenSaverEventBase;
	ev.state = state;
	ev.timestamp = currentTime.milliseconds;
	ev.root = pScreen->root->drawable.id;
	ev.window = pScreen->screensaver.wid;
	ev.kind = kind;
	ev.forced = forced;
	WriteEventsToClient (pEv->client, 1, (xEvent *) &ev);
    }
}

static void
SScreenSaverNotifyEvent (xScreenSaverNotifyEvent *from,
                         xScreenSaverNotifyEvent *to)
{
    to->type = from->type;
    to->state = from->state;
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->timestamp, to->timestamp);    
    cpswapl (from->root, to->root);    
    cpswapl (from->window, to->window);    
    to->kind = from->kind;
    to->forced = from->forced;
}

static void
UninstallSaverColormap (ScreenPtr pScreen)
{
    SetupScreen(pScreen);
    ColormapPtr			pCmap;
    int rc;

    if (pPriv && pPriv->installedMap != None)
    {
	rc = dixLookupResourceByType((pointer *)&pCmap, pPriv->installedMap,
				     RT_COLORMAP, serverClient,
				     DixUninstallAccess);
	if (rc == Success)
	    (*pCmap->pScreen->UninstallColormap) (pCmap);
	pPriv->installedMap = None;
	CheckScreenPrivate (pScreen);
    }
}

static Bool
CreateSaverWindow (ScreenPtr pScreen)
{
    SetupScreen (pScreen);
    ScreenSaverStuffPtr		pSaver;
    ScreenSaverAttrPtr		pAttr;
    WindowPtr			pWin;
    int				result;
    unsigned long		mask;
    Colormap			*installedMaps;
    int				numInstalled;
    int				i;
    Colormap			wantMap;
    ColormapPtr			pCmap;

    pSaver = &pScreen->screensaver;
    if (pSaver->pWindow)
    {
	pSaver->pWindow = NullWindow;
	FreeResource (pSaver->wid, RT_NONE);
	if (pPriv)
	{
	    UninstallSaverColormap (pScreen);
	    pPriv->hasWindow = FALSE;
	    CheckScreenPrivate (pScreen);
	}
    }

    if (!pPriv || !(pAttr = pPriv->attr))
	return FALSE;

    pPriv->installedMap = None;

    if (GrabInProgress && GrabInProgress != pAttr->client->index)
	return FALSE;

    pWin = CreateWindow (pSaver->wid, pScreen->root,
			 pAttr->x, pAttr->y, pAttr->width, pAttr->height,
			 pAttr->borderWidth, pAttr->class, 
			 pAttr->mask, (XID *)pAttr->values, 
			 pAttr->depth, serverClient, pAttr->visual, 
			 &result);
    if (!pWin)
	return FALSE;

    if (!AddResource(pWin->drawable.id, RT_WINDOW, pWin))
	return FALSE;

    mask = 0;
    if (pAttr->pBackgroundPixmap)
    {
	pWin->backgroundState = BackgroundPixmap;
	pWin->background.pixmap = pAttr->pBackgroundPixmap;
	pAttr->pBackgroundPixmap->refcnt++;
	mask |= CWBackPixmap;
    }
    if (pAttr->pBorderPixmap)
    {
	pWin->borderIsPixel = FALSE;
	pWin->border.pixmap = pAttr->pBorderPixmap;
	pAttr->pBorderPixmap->refcnt++;
	mask |= CWBorderPixmap;
    }
    if (pAttr->pCursor)
    {
	if (!pWin->optional)
	    if (!MakeWindowOptional (pWin))
	    {
    	    	FreeResource (pWin->drawable.id, RT_NONE);
    	    	return FALSE;
	    }
	pAttr->pCursor->refcnt++;
	if (pWin->optional->cursor)
	    FreeCursor (pWin->optional->cursor, (Cursor)0);
	pWin->optional->cursor = pAttr->pCursor;
	pWin->cursorIsNone = FALSE;
	CheckWindowOptionalNeed (pWin);
	mask |= CWCursor;
    }
    if (mask)
	(*pScreen->ChangeWindowAttributes) (pWin, mask);

    if (pAttr->colormap != None)
	(void) ChangeWindowAttributes (pWin, CWColormap, &pAttr->colormap,
				       serverClient);

    MapWindow (pWin, serverClient);

    pPriv->hasWindow = TRUE;
    pSaver->pWindow = pWin;

    /* check and install our own colormap if it isn't installed now */
    wantMap = wColormap (pWin);
    if (wantMap == None)
	return TRUE;
    installedMaps = malloc(pScreen->maxInstalledCmaps * sizeof (Colormap));
    numInstalled = (*pWin->drawable.pScreen->ListInstalledColormaps)
						    (pScreen, installedMaps);
    for (i = 0; i < numInstalled; i++) 
	if (installedMaps[i] == wantMap)
	    break;

    free((char *) installedMaps);

    if (i < numInstalled)
	return TRUE;

    result = dixLookupResourceByType((pointer *)&pCmap, wantMap, RT_COLORMAP,
				     serverClient, DixInstallAccess);
    if (result != Success)
	return TRUE;

    pPriv->installedMap = wantMap;

    (*pCmap->pScreen->InstallColormap) (pCmap);

    return TRUE;
}

static Bool
DestroySaverWindow (ScreenPtr pScreen)
{
    SetupScreen(pScreen);
    ScreenSaverStuffPtr		pSaver;

    if (!pPriv || !pPriv->hasWindow)
	return FALSE;

    pSaver = &pScreen->screensaver;
    if (pSaver->pWindow)
    {
	pSaver->pWindow = NullWindow;
	FreeResource (pSaver->wid, RT_NONE);
    }
    pPriv->hasWindow = FALSE;
    CheckScreenPrivate (pScreen);
    UninstallSaverColormap (pScreen);
    return TRUE;
}

static Bool
ScreenSaverHandle (ScreenPtr pScreen, int xstate, Bool force)
{
    int				state = 0;
    Bool			ret = FALSE;
    ScreenSaverScreenPrivatePtr	pPriv;

    switch (xstate)
    {
    case SCREEN_SAVER_ON:	
	state = ScreenSaverOn;
	ret = CreateSaverWindow (pScreen);
	break;
    case SCREEN_SAVER_OFF:	
	state = ScreenSaverOff;
	ret = DestroySaverWindow (pScreen);
	break;
    case SCREEN_SAVER_CYCLE:	
	state = ScreenSaverCycle;
	pPriv = GetScreenPrivate (pScreen);
	if (pPriv && pPriv->hasWindow)
	    ret = TRUE;
	
    }
#ifdef PANORAMIX
    if(noPanoramiXExtension || !pScreen->myNum)
#endif
       SendScreenSaverNotify (pScreen, state, force);
    return ret;
}

static int
ProcScreenSaverQueryVersion (ClientPtr client)
{
    xScreenSaverQueryVersionReply	rep;
    int		n;

    REQUEST_SIZE_MATCH (xScreenSaverQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SAVER_MAJOR_VERSION;
    rep.minorVersion = SERVER_SAVER_MINOR_VERSION;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    }
    WriteToClient(client, sizeof (xScreenSaverQueryVersionReply), (char *)&rep);
    return Success;
}

static int
ProcScreenSaverQueryInfo (ClientPtr client)
{
    REQUEST(xScreenSaverQueryInfoReq);
    xScreenSaverQueryInfoReply	rep;
    int		n, rc;
    ScreenSaverStuffPtr		pSaver;
    DrawablePtr			pDraw;
    CARD32			lastInput;
    ScreenSaverScreenPrivatePtr	pPriv;

    REQUEST_SIZE_MATCH (xScreenSaverQueryInfoReq);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;
    rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, pDraw->pScreen,
		  DixGetAttrAccess);
    if (rc != Success)
	return rc;

    pSaver = &pDraw->pScreen->screensaver;
    pPriv = GetScreenPrivate (pDraw->pScreen);

    UpdateCurrentTime ();
    lastInput = GetTimeInMillis() - lastDeviceEventTime.milliseconds;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.window = pSaver->wid;
    if (screenIsSaved != SCREEN_SAVER_OFF)
    {
	rep.state = ScreenSaverOn;
	if (ScreenSaverTime)
	    rep.tilOrSince = lastInput - ScreenSaverTime;
	else
	    rep.tilOrSince = 0;
    }
    else
    {
	if (ScreenSaverTime)
	{
	    rep.state = ScreenSaverOff;
	    if (ScreenSaverTime < lastInput)
		rep.tilOrSince = 0;
	    else
		rep.tilOrSince = ScreenSaverTime - lastInput;
	}
	else
	{
	    rep.state = ScreenSaverDisabled;
	    rep.tilOrSince = 0;
	}
    }
    rep.idle = lastInput;
    rep.eventMask = getEventMask (pDraw->pScreen, client);
    if (pPriv && pPriv->attr)
	rep.kind = ScreenSaverExternal;
    else if (ScreenSaverBlanking != DontPreferBlanking)
	rep.kind = ScreenSaverBlanked;
    else
	rep.kind = ScreenSaverInternal;
    if (client->swapped)
    {
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.window, n);
	swapl (&rep.tilOrSince, n);
	swapl (&rep.idle, n);
	swapl (&rep.eventMask, n);
    }
    WriteToClient(client, sizeof (xScreenSaverQueryInfoReply), (char *)&rep);
    return Success;
}

static int
ProcScreenSaverSelectInput (ClientPtr client)
{
    REQUEST(xScreenSaverSelectInputReq);
    DrawablePtr			pDraw;
    int				rc;

    REQUEST_SIZE_MATCH (xScreenSaverSelectInputReq);
    rc = dixLookupDrawable (&pDraw, stuff->drawable, client, 0,
			    DixGetAttrAccess);
    if (rc != Success)
	return rc;

    rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, pDraw->pScreen,
		  DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if (!setEventMask (pDraw->pScreen, client, stuff->eventMask))
	return BadAlloc;
    return Success;
}

static int
ScreenSaverSetAttributes (ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    DrawablePtr			pDraw;
    WindowPtr			pParent;
    ScreenPtr			pScreen;
    ScreenSaverScreenPrivatePtr pPriv = 0;
    ScreenSaverAttrPtr		pAttr = 0;
    int				ret, len, class, bw, depth;
    unsigned long		visual;
    int				idepth, ivisual;
    Bool			fOK;
    DepthPtr			pDepth;
    WindowOptPtr		ancwopt;
    unsigned int		*pVlist;
    unsigned long		*values = 0;
    unsigned long		tmask, imask;
    unsigned long		val;
    Pixmap			pixID;
    PixmapPtr			pPixmap;
    Cursor			cursorID;
    CursorPtr			pCursor;
    Colormap			cmap;
    ColormapPtr			pCmap;

    REQUEST_AT_LEAST_SIZE (xScreenSaverSetAttributesReq);
    ret = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			    DixGetAttrAccess);
    if (ret != Success)
	return ret;
    pScreen = pDraw->pScreen;
    pParent = pScreen->root;

    ret = XaceHook(XACE_SCREENSAVER_ACCESS, client, pScreen, DixSetAttrAccess);
    if (ret != Success)
	return ret;

    len = stuff->length -  bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));
    if (Ones(stuff->mask) != len)
        return BadLength;
    if (!stuff->width || !stuff->height)
    {
	client->errorValue = 0;
        return BadValue;
    }
    switch (class = stuff->c_class) 
    {
    case CopyFromParent:
    case InputOnly:
    case InputOutput:
	break;
    default:
	client->errorValue = class;
	return BadValue;
    }
    bw = stuff->borderWidth;
    depth = stuff->depth;
    visual = stuff->visualID;

    /* copied directly from CreateWindow */

    if (class == CopyFromParent)
	class = pParent->drawable.class;

    if ((class != InputOutput) && (class != InputOnly))
    {
	client->errorValue = class;
	return BadValue;
    }

    if ((class != InputOnly) && (pParent->drawable.class == InputOnly))
        return BadMatch;

    if ((class == InputOnly) && ((bw != 0) || (depth != 0)))
        return BadMatch;

    if ((class == InputOutput) && (depth == 0))
        depth = pParent->drawable.depth;
    ancwopt = pParent->optional;
    if (!ancwopt)
	ancwopt = FindWindowWithOptional(pParent)->optional;
    if (visual == CopyFromParent)
	visual = ancwopt->visual;

    /* Find out if the depth and visual are acceptable for this Screen */
    if ((visual != ancwopt->visual) || (depth != pParent->drawable.depth))
    {
	fOK = FALSE;
	for(idepth = 0; idepth < pScreen->numDepths; idepth++)
	{
	    pDepth = (DepthPtr) &pScreen->allowedDepths[idepth];
	    if ((depth == pDepth->depth) || (depth == 0))
	    {
		for (ivisual = 0; ivisual < pDepth->numVids; ivisual++)
		{
		    if (visual == pDepth->vids[ivisual])
		    {
			fOK = TRUE;
			break;
		    }
		}
	    }
	}
	if (fOK == FALSE)
	    return BadMatch;
    }

    if (((stuff->mask & (CWBorderPixmap | CWBorderPixel)) == 0) &&
	(class != InputOnly) &&
	(depth != pParent->drawable.depth))
    {
        return BadMatch;
    }

    if (((stuff->mask & CWColormap) == 0) &&
	(class != InputOnly) &&
	((visual != ancwopt->visual) || (ancwopt->colormap == None)))
    {
	return BadMatch;
    }

    /* end of errors from CreateWindow */

    pPriv = GetScreenPrivate (pScreen);
    if (pPriv && pPriv->attr)
    {
	if (pPriv->attr->client != client)
	    return BadAccess;
    }
    if (!pPriv)
    {
	pPriv = MakeScreenPrivate (pScreen);
	if (!pPriv)
	    return FALSE;
    }
    pAttr = New (ScreenSaverAttrRec);
    if (!pAttr)
    {
	ret = BadAlloc;
	goto bail;
    }
    /* over allocate for override redirect */
    values = malloc((len + 1) * sizeof (unsigned long));
    if (!values)
    {
	ret = BadAlloc;
	goto bail;
    }
    pAttr->screen = pScreen;
    pAttr->client = client;
    pAttr->x = stuff->x;
    pAttr->y = stuff->y;
    pAttr->width = stuff->width;
    pAttr->height = stuff->height;
    pAttr->borderWidth = stuff->borderWidth;
    pAttr->class = stuff->c_class;
    pAttr->depth = depth;
    pAttr->visual = visual;
    pAttr->colormap = None;
    pAttr->pCursor = NullCursor;
    pAttr->pBackgroundPixmap = NullPixmap;
    pAttr->pBorderPixmap = NullPixmap;
    pAttr->values = values;
    /*
     * go through the mask, checking the values,
     * looking up pixmaps and cursors and hold a reference
     * to them.
     */
    pAttr->mask = tmask = stuff->mask | CWOverrideRedirect;
    pVlist = (unsigned int *) (stuff + 1);
    while (tmask) {
	imask = lowbit (tmask);
	tmask &= ~imask;
	switch (imask)
        {
	case CWBackPixmap:
	    pixID = (Pixmap )*pVlist;
	    if (pixID == None)
	    {
		*values++ = None;
	    }
	    else if (pixID == ParentRelative)
	    {
		if (depth != pParent->drawable.depth)
		{
		    ret = BadMatch;
		    goto PatchUp;
		}
		*values++ = ParentRelative;
	    }
            else
	    {	
		ret = dixLookupResourceByType((pointer *)&pPixmap, pixID, RT_PIXMAP,
					client, DixReadAccess);
		if (ret == Success)
		{
                    if  ((pPixmap->drawable.depth != depth) ||
			 (pPixmap->drawable.pScreen != pScreen))
		    {
                        ret = BadMatch;
			goto PatchUp;
		    }
		    pAttr->pBackgroundPixmap = pPixmap;
		    pPixmap->refcnt++;
		    pAttr->mask &= ~CWBackPixmap;
		}
	        else
		{
		    client->errorValue = pixID;
		    goto PatchUp;
		}
	    }
	    break;
	case CWBackPixel:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWBorderPixmap:
	    pixID = (Pixmap ) *pVlist;
	    if (pixID == CopyFromParent)
	    {
		if (depth != pParent->drawable.depth)
		{
		    ret = BadMatch;
		    goto PatchUp;
		}
		*values++ = CopyFromParent;
	    }
	    else
	    {	
		ret = dixLookupResourceByType((pointer *)&pPixmap, pixID, RT_PIXMAP,
					client, DixReadAccess);
		if (ret == Success)
		{
                    if  ((pPixmap->drawable.depth != depth) ||
			 (pPixmap->drawable.pScreen != pScreen))
		    {
			ret = BadMatch;
			goto PatchUp;
		    }
		    pAttr->pBorderPixmap = pPixmap;
		    pPixmap->refcnt++;
		    pAttr->mask &= ~CWBorderPixmap;
		}
    	        else
		{
		    client->errorValue = pixID;
		    goto PatchUp;
		}
	    }
	    break;
	case CWBorderPixel:
            *values++ = (CARD32) *pVlist;
            break;
	case CWBitGravity:
	    val = (CARD8 )*pVlist;
	    if (val > StaticGravity)
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWWinGravity:
	    val = (CARD8 )*pVlist;
	    if (val > StaticGravity)
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWBackingStore:
	    val = (CARD8 )*pVlist;
	    if ((val != NotUseful) && (val != WhenMapped) && (val != Always))
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWBackingPlanes:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWBackingPixel:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWSaveUnder:
	    val = (BOOL) *pVlist;
	    if ((val != xTrue) && (val != xFalse))
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWEventMask:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWDontPropagate:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWOverrideRedirect:
	    if (!(stuff->mask & CWOverrideRedirect))
		pVlist--;
	    else
	    {
	    	val = (BOOL ) *pVlist;
	    	if ((val != xTrue) && (val != xFalse))
	    	{
		    ret = BadValue;
		    client->errorValue = val;
		    goto PatchUp;
	    	}
	    }
	    *values++ = xTrue;
	    break;
	case CWColormap:
	    cmap = (Colormap) *pVlist;
	    ret = dixLookupResourceByType((pointer *)&pCmap, cmap, RT_COLORMAP,
				    client, DixUseAccess);
	    if (ret != Success)
	    {
		client->errorValue = cmap;
		goto PatchUp;
	    }
	    if (pCmap->pVisual->vid != visual || pCmap->pScreen != pScreen)
	    {
		ret = BadMatch;
		goto PatchUp;
	    }
	    pAttr->colormap = cmap;
	    pAttr->mask &= ~CWColormap;
	    break;
	case CWCursor:
	    cursorID = (Cursor ) *pVlist;
	    if ( cursorID == None)
	    {
		*values++ = None;
	    }
	    else
	    {
		ret = dixLookupResourceByType((pointer *)&pCursor, cursorID,
					RT_CURSOR, client, DixUseAccess);
	    	if (ret != Success)
	    	{
		    client->errorValue = cursorID;
		    goto PatchUp;
	    	}
		pCursor->refcnt++;
		pAttr->pCursor = pCursor;
		pAttr->mask &= ~CWCursor;
	    }
	    break;
     	 default:
	    ret = BadValue;
	    client->errorValue = stuff->mask;
	    goto PatchUp;
	}
	pVlist++;
    }
    if (pPriv->attr)
	FreeScreenAttr (pPriv->attr);
    pPriv->attr = pAttr;
    pAttr->resource = FakeClientID (client->index);
    if (!AddResource (pAttr->resource, AttrType, (pointer) pAttr))
	return BadAlloc;
    return Success;
PatchUp:
    FreeAttrs (pAttr);
bail:
    CheckScreenPrivate (pScreen);
    if (pAttr) free(pAttr->values);
    free(pAttr);
    return ret;
}

static int
ScreenSaverUnsetAttributes (ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    DrawablePtr			pDraw;
    ScreenSaverScreenPrivatePtr	pPriv;
    int				rc;

    REQUEST_SIZE_MATCH (xScreenSaverUnsetAttributesReq);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;
    pPriv = GetScreenPrivate (pDraw->pScreen);
    if (pPriv && pPriv->attr && pPriv->attr->client == client)
    {
	FreeResource (pPriv->attr->resource, AttrType);
    	FreeScreenAttr (pPriv->attr);
	pPriv->attr = NULL;
	CheckScreenPrivate (pDraw->pScreen);
    }
    return Success;
}

static int
ProcScreenSaverSetAttributes (ClientPtr client)
{
#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
       REQUEST(xScreenSaverSetAttributesReq);
       PanoramiXRes *draw;
       PanoramiXRes *backPix = NULL;
       PanoramiXRes *bordPix = NULL;
       PanoramiXRes *cmap    = NULL;
       int i, status, len;
       int  pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
       XID orig_visual, tmp;

       REQUEST_AT_LEAST_SIZE (xScreenSaverSetAttributesReq);

       status = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
					 XRC_DRAWABLE, client, DixWriteAccess);
       if (status != Success)
           return (status == BadValue) ? BadDrawable : status;

       len = stuff->length -  bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));
       if (Ones(stuff->mask) != len)
           return BadLength;

       if((Mask)stuff->mask & CWBackPixmap) {
          pback_offset = Ones((Mask)stuff->mask & (CWBackPixmap - 1));
          tmp = *((CARD32 *) &stuff[1] + pback_offset);
          if ((tmp != None) && (tmp != ParentRelative)) {
	      status = dixLookupResourceByType((pointer *)&backPix, tmp,
					       XRT_PIXMAP, client,
					       DixReadAccess);
	      if (status != Success)
		  return status;
          }
       }

       if ((Mask)stuff->mask & CWBorderPixmap) {
          pbord_offset = Ones((Mask)stuff->mask & (CWBorderPixmap - 1));
          tmp = *((CARD32 *) &stuff[1] + pbord_offset);
          if (tmp != CopyFromParent) {
	      status = dixLookupResourceByType((pointer *)&bordPix, tmp,
					       XRT_PIXMAP, client,
					       DixReadAccess);
	      if (status != Success)
		  return status;
          }
       }

       if ((Mask)stuff->mask & CWColormap) {
           cmap_offset = Ones((Mask)stuff->mask & (CWColormap - 1));
           tmp = *((CARD32 *) &stuff[1] + cmap_offset);
           if ((tmp != CopyFromParent) && (tmp != None)) {
	       status = dixLookupResourceByType((pointer *)&cmap, tmp,
						XRT_COLORMAP, client,
						DixReadAccess);
	       if (status != Success)
		   return status;
           }
       }

       orig_visual = stuff->visualID;

       FOR_NSCREENS_BACKWARD(i) {
          stuff->drawable = draw->info[i].id;  
          if (backPix)
             *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[i].id;
          if (bordPix)
             *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[i].id;
          if (cmap)
             *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[i].id;

          if (orig_visual != CopyFromParent) 
            stuff->visualID = PanoramiXTranslateVisualID(i, orig_visual);

          status = ScreenSaverSetAttributes(client);
       }

       return status;
    }
#endif

    return ScreenSaverSetAttributes(client);
}

static int
ProcScreenSaverUnsetAttributes (ClientPtr client)
{
#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
       REQUEST(xScreenSaverUnsetAttributesReq);
       PanoramiXRes *draw;
       int rc, i;

       rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				     XRC_DRAWABLE, client, DixWriteAccess);
       if (rc != Success)
           return (rc == BadValue) ? BadDrawable : rc;

       for(i = PanoramiXNumScreens - 1; i > 0; i--) {
            stuff->drawable = draw->info[i].id;
            ScreenSaverUnsetAttributes(client);
       }

       stuff->drawable = draw->info[0].id;
    }
#endif

    return ScreenSaverUnsetAttributes(client);
}

static int
ProcScreenSaverSuspend (ClientPtr client)
{
    ScreenSaverSuspensionPtr *prev, this;

    REQUEST(xScreenSaverSuspendReq);
    REQUEST_SIZE_MATCH(xScreenSaverSuspendReq);

    /* Check if this client is suspending the screensaver */
    for (prev = &suspendingClients; (this = *prev); prev = &this->next)
	if (this->pClient == client)
	    break;

    if (this)
    {
	if (stuff->suspend == TRUE)
	   this->count++;
	else if (--this->count == 0)
	   FreeResource (this->clientResource, RT_NONE);

	return Success;
    }

    /* If we get to this point, this client isn't suspending the screensaver */
    if (stuff->suspend == FALSE)
	return Success;

    /*
     * Allocate a suspension record for the client, and stop the screensaver
     * if it isn't already suspended by another client. We attach a resource ID
     * to the record, so the screensaver will be reenabled and the record freed
     * if the client disconnects without reenabling it first.
     */
    this = malloc(sizeof (ScreenSaverSuspensionRec));

    if (!this)
	return BadAlloc;

    this->next           = NULL;
    this->pClient        = client;
    this->count          = 1;
    this->clientResource = FakeClientID (client->index);

    if (!AddResource (this->clientResource, SuspendType, (pointer) this))
    {
	free(this);
	return BadAlloc;
    }

    *prev = this;
    if (!screenSaverSuspended)
    {
	screenSaverSuspended = TRUE;
	FreeScreenSaverTimer();
    }

    return Success;
}

static int (*NormalVector[]) (ClientPtr /* client */) = {
    ProcScreenSaverQueryVersion,
    ProcScreenSaverQueryInfo,
    ProcScreenSaverSelectInput,
    ProcScreenSaverSetAttributes,
    ProcScreenSaverUnsetAttributes,
    ProcScreenSaverSuspend,
};

#define NUM_REQUESTS	((sizeof NormalVector) / (sizeof NormalVector[0]))

static int
ProcScreenSaverDispatch (ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < NUM_REQUESTS)
	return (*NormalVector[stuff->data])(client);
    return BadRequest;
}

static int
SProcScreenSaverQueryVersion (ClientPtr client)
{
    REQUEST(xScreenSaverQueryVersionReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverQueryVersionReq);
    return ProcScreenSaverQueryVersion (client);
}

static int
SProcScreenSaverQueryInfo (ClientPtr client)
{
    REQUEST(xScreenSaverQueryInfoReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverQueryInfoReq);
    swapl (&stuff->drawable, n);
    return ProcScreenSaverQueryInfo (client);
}

static int
SProcScreenSaverSelectInput (ClientPtr client)
{
    REQUEST(xScreenSaverSelectInputReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverSelectInputReq);
    swapl (&stuff->drawable, n);
    swapl (&stuff->eventMask, n);
    return ProcScreenSaverSelectInput (client);
}

static int
SProcScreenSaverSetAttributes (ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xScreenSaverSetAttributesReq);
    swapl (&stuff->drawable, n);
    swaps (&stuff->x, n);
    swaps (&stuff->y, n);
    swaps (&stuff->width, n);
    swaps (&stuff->height, n);
    swaps (&stuff->borderWidth, n);
    swapl (&stuff->visualID, n);
    swapl (&stuff->mask, n);
    SwapRestL(stuff);
    return ProcScreenSaverSetAttributes (client);
}

static int
SProcScreenSaverUnsetAttributes (ClientPtr client)
{
    REQUEST(xScreenSaverUnsetAttributesReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);
    swapl (&stuff->drawable, n);
    return ProcScreenSaverUnsetAttributes (client);
}

static int
SProcScreenSaverSuspend (ClientPtr client)
{
    int n;
    REQUEST(xScreenSaverSuspendReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverSuspendReq);
    swapl(&stuff->suspend, n);
    return ProcScreenSaverSuspend (client);
}

static int (*SwappedVector[]) (ClientPtr /* client */) = {
    SProcScreenSaverQueryVersion,
    SProcScreenSaverQueryInfo,
    SProcScreenSaverSelectInput,
    SProcScreenSaverSetAttributes,
    SProcScreenSaverUnsetAttributes,
    SProcScreenSaverSuspend,
};

static int
SProcScreenSaverDispatch (ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < NUM_REQUESTS)
	return (*SwappedVector[stuff->data])(client);
    return BadRequest;
}

void
ScreenSaverExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;
    int		    i;
    ScreenPtr	    pScreen;

    if (!dixRegisterPrivateKey(&ScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return;

    AttrType = CreateNewResourceType(ScreenSaverFreeAttr, "SaverAttr");
    SaverEventType = CreateNewResourceType(ScreenSaverFreeEvents,
					   "SaverEvent");
    SuspendType = CreateNewResourceType(ScreenSaverFreeSuspend,
					"SaverSuspend");

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	pScreen = screenInfo.screens[i];
	SetScreenPrivate (pScreen, NULL);
    }
    if (AttrType && SaverEventType && SuspendType &&
	(extEntry = AddExtension(ScreenSaverName, ScreenSaverNumberEvents, 0,
				 ProcScreenSaverDispatch, SProcScreenSaverDispatch,
				 NULL, StandardMinorOpcode)))
    {
	ScreenSaverEventBase = extEntry->eventBase;
	EventSwapVector[ScreenSaverEventBase] = (EventSwapPtr) SScreenSaverNotifyEvent;
    }
}
/*

Copyright 1996, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "inputstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "colormapst.h"
#include "privates.h"
#include "registry.h"
#include "xacestr.h"
#include "securitysrv.h"
#include <X11/extensions/securproto.h>
#include "modinit.h"
#include "protocol-versions.h"

/* Extension stuff */
static int SecurityErrorBase;  /* first Security error number */
static int SecurityEventBase;  /* first Security event number */

RESTYPE SecurityAuthorizationResType; /* resource type for authorizations */
static RESTYPE RTEventClient;

static CallbackListPtr SecurityValidateGroupCallback = NULL;

/* Private state record */
static DevPrivateKeyRec stateKeyRec;
#define stateKey (&stateKeyRec)

/* This is what we store as client security state */
typedef struct {
    int haveState;
    unsigned int trustLevel;
    XID authId;
} SecurityStateRec;

/* Extensions that untrusted clients shouldn't have access to */
static char *SecurityTrustedExtensions[] = {
    "XC-MISC",
    "BIG-REQUESTS",
    "XpExtension",
    NULL
};

/*
 * Access modes that untrusted clients are allowed on trusted objects.
 */
static const Mask SecurityResourceMask =
    DixGetAttrAccess | DixReceiveAccess | DixListPropAccess |
    DixGetPropAccess | DixListAccess;
static const Mask SecurityWindowExtraMask = DixRemoveAccess;
static const Mask SecurityRootWindowExtraMask =
    DixReceiveAccess | DixSendAccess | DixAddAccess | DixRemoveAccess;
static const Mask SecurityDeviceMask =
    DixGetAttrAccess | DixReceiveAccess | DixGetFocusAccess |
    DixGrabAccess | DixSetAttrAccess | DixUseAccess;
static const Mask SecurityServerMask = DixGetAttrAccess | DixGrabAccess;
static const Mask SecurityClientMask = DixGetAttrAccess;


/* SecurityAudit
 *
 * Arguments:
 *	format is the formatting string to be used to interpret the
 *	  remaining arguments.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Writes the message to the log file if security logging is on.
 */

static void
SecurityAudit(char *format, ...)
{
    va_list args;

    if (auditTrailLevel < SECURITY_AUDIT_LEVEL)
	return;
    va_start(args, format);
    VAuditF(format, args);
    va_end(args);
} /* SecurityAudit */

/*
 * Performs a Security permission check.
 */
static int
SecurityDoCheck(SecurityStateRec *subj, SecurityStateRec *obj,
		Mask requested, Mask allowed)
{
    if (!subj->haveState || !obj->haveState)
	return Success;
    if (subj->trustLevel == XSecurityClientTrusted)
	return Success;
    if (obj->trustLevel != XSecurityClientTrusted)
	return Success;
    if ((requested | allowed) == allowed)
	return Success;

    return BadAccess;
}

/*
 * Labels initial server objects.
 */
static void
SecurityLabelInitial(void)
{
    SecurityStateRec *state;

    /* Do the serverClient */
    state = dixLookupPrivate(&serverClient->devPrivates, stateKey);
    state->trustLevel = XSecurityClientTrusted;
    state->haveState = TRUE;
}

/*
 * Looks up a request name
 */
static _X_INLINE const char *
SecurityLookupRequestName(ClientPtr client)
{
    int major = ((xReq *)client->requestBuffer)->reqType;
    int minor = MinorOpcodeOfRequest(client);
    return LookupRequestName(major, minor);
}


/* SecurityDeleteAuthorization
 *
 * Arguments:
 *	value is the authorization to delete.
 *	id is its resource ID.
 *
 * Returns: Success.
 *
 * Side Effects:
 *	Frees everything associated with the authorization.
 */

static int
SecurityDeleteAuthorization(
    pointer value,
    XID id)
{
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)value;
    unsigned short name_len, data_len;
    char *name, *data;
    int status;
    int i;
    OtherClientsPtr pEventClient;

    /* Remove the auth using the os layer auth manager */

    status = AuthorizationFromID(pAuth->id, &name_len, &name,
				 &data_len, &data);
    assert(status);
    status = RemoveAuthorization(name_len, name, data_len, data);
    assert(status);
    (void)status;

    /* free the auth timer if there is one */

    if (pAuth->timer) TimerFree(pAuth->timer);

    /* send revoke events */

    while ((pEventClient = pAuth->eventClients))
    {
	/* send revocation event event */
	xSecurityAuthorizationRevokedEvent are;
	are.type = SecurityEventBase + XSecurityAuthorizationRevoked;
	are.authId = pAuth->id;
	WriteEventsToClient(rClient(pEventClient), 1, (xEvent *)&are);
	FreeResource(pEventClient->resource, RT_NONE);
    }

    /* kill all clients using this auth */

    for (i = 1; i<currentMaxClients; i++)
	if (clients[i]) {
	    SecurityStateRec *state;
	    state = dixLookupPrivate(&clients[i]->devPrivates, stateKey);
	    if (state->haveState && state->authId == pAuth->id)
		CloseDownClient(clients[i]);
	}

    SecurityAudit("revoked authorization ID %d\n", pAuth->id);
    free(pAuth);
    return Success;

} /* SecurityDeleteAuthorization */


/* resource delete function for RTEventClient */
static int
SecurityDeleteAuthorizationEventClient(
    pointer value,
    XID id)
{
    OtherClientsPtr pEventClient, prev = NULL;
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)value;

    for (pEventClient = pAuth->eventClients;
	 pEventClient;
	 pEventClient = pEventClient->next)
    {
	if (pEventClient->resource == id)
	{
	    if (prev)
		prev->next = pEventClient->next;
	    else
		pAuth->eventClients = pEventClient->next;
	    free(pEventClient);
	    return Success;
	}
	prev = pEventClient;
    }
    /*NOTREACHED*/
    return -1; /* make compiler happy */
} /* SecurityDeleteAuthorizationEventClient */


/* SecurityComputeAuthorizationTimeout
 *
 * Arguments:
 *	pAuth is the authorization for which we are computing the timeout
 *	seconds is the number of seconds we want to wait
 *
 * Returns:
 *	the number of milliseconds that the auth timer should be set to
 *
 * Side Effects:
 *	Sets pAuth->secondsRemaining to any "overflow" amount of time
 *	that didn't fit in 32 bits worth of milliseconds
 */

static CARD32
SecurityComputeAuthorizationTimeout(
    SecurityAuthorizationPtr pAuth,
    unsigned int seconds)
{
    /* maxSecs is the number of full seconds that can be expressed in
     * 32 bits worth of milliseconds
     */
    CARD32 maxSecs = (CARD32)(~0) / (CARD32)MILLI_PER_SECOND;

    if (seconds > maxSecs)
    { /* only come here if we want to wait more than 49 days */
	pAuth->secondsRemaining = seconds - maxSecs;
	return maxSecs * MILLI_PER_SECOND;
    }
    else
    { /* by far the common case */
	pAuth->secondsRemaining = 0;
	return seconds * MILLI_PER_SECOND;
    }
} /* SecurityStartAuthorizationTimer */

/* SecurityAuthorizationExpired
 *
 * This function is passed as an argument to TimerSet and gets called from
 * the timer manager in the os layer when its time is up.
 *
 * Arguments:
 *	timer is the timer for this authorization.
 *	time is the current time.
 *	pval is the authorization whose time is up.
 *
 * Returns:
 *	A new time delay in milliseconds if the timer should wait some
 *	more, else zero.
 *
 * Side Effects:
 *	Frees the authorization resource if the timeout period is really
 *	over, otherwise recomputes pAuth->secondsRemaining.
 */

static CARD32
SecurityAuthorizationExpired(
    OsTimerPtr timer,
    CARD32 time,
    pointer pval)
{
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)pval;

    assert(pAuth->timer == timer);

    if (pAuth->secondsRemaining)
    {
	return SecurityComputeAuthorizationTimeout(pAuth,
						   pAuth->secondsRemaining);
    }
    else
    {
	FreeResource(pAuth->id, RT_NONE);
	return 0;
    }
} /* SecurityAuthorizationExpired */

/* SecurityStartAuthorizationTimer
 *
 * Arguments:
 *	pAuth is the authorization whose timer should be started.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	A timer is started, set to expire after the timeout period for
 *	this authorization.  When it expires, the function
 *	SecurityAuthorizationExpired will be called.
 */

static void
SecurityStartAuthorizationTimer(
    SecurityAuthorizationPtr pAuth)
{
    pAuth->timer = TimerSet(pAuth->timer, 0,
	SecurityComputeAuthorizationTimeout(pAuth, pAuth->timeout),
			    SecurityAuthorizationExpired, pAuth);
} /* SecurityStartAuthorizationTimer */


/* Proc functions all take a client argument, execute the request in
 * client->requestBuffer, and return a protocol error status.
 */

static int
ProcSecurityQueryVersion(
    ClientPtr client)
{
    /* REQUEST(xSecurityQueryVersionReq); */
    xSecurityQueryVersionReply 	rep;

    REQUEST_SIZE_MATCH(xSecurityQueryVersionReq);
    rep.type        	= X_Reply;
    rep.sequenceNumber 	= client->sequence;
    rep.length         	= 0;
    rep.majorVersion  	= SERVER_SECURITY_MAJOR_VERSION;
    rep.minorVersion  	= SERVER_SECURITY_MINOR_VERSION;
    if(client->swapped)
    {
	char n;
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    (void)WriteToClient(client, SIZEOF(xSecurityQueryVersionReply),
			(char *)&rep);
    return Success;
} /* ProcSecurityQueryVersion */


static int
SecurityEventSelectForAuthorization(
    SecurityAuthorizationPtr pAuth,
    ClientPtr client,
    Mask mask)
{
    OtherClients *pEventClient;

    for (pEventClient = pAuth->eventClients;
	 pEventClient;
	 pEventClient = pEventClient->next)
    {
	if (SameClient(pEventClient, client))
	{
	    if (mask == 0)
		FreeResource(pEventClient->resource, RT_NONE);
	    else
		pEventClient->mask = mask;
	    return Success;
	}
    }
    
    pEventClient = malloc(sizeof(OtherClients));
    if (!pEventClient)
	return BadAlloc;
    pEventClient->mask = mask;
    pEventClient->resource = FakeClientID(client->index);
    pEventClient->next = pAuth->eventClients;
    if (!AddResource(pEventClient->resource, RTEventClient,
		     (pointer)pAuth))
    {
	free(pEventClient);
	return BadAlloc;
    }
    pAuth->eventClients = pEventClient;

    return Success;
} /* SecurityEventSelectForAuthorization */


static int
ProcSecurityGenerateAuthorization(
    ClientPtr client)
{
    REQUEST(xSecurityGenerateAuthorizationReq);
    int len;			/* request length in CARD32s*/
    Bool removeAuth = FALSE;	/* if bailout, call RemoveAuthorization? */
    SecurityAuthorizationPtr pAuth = NULL;  /* auth we are creating */
    int err;			/* error to return from this function */
    XID authId;			/* authorization ID assigned by os layer */
    xSecurityGenerateAuthorizationReply rep; /* reply struct */
    unsigned int trustLevel;    /* trust level of new auth */
    XID group;			/* group of new auth */
    CARD32 timeout;		/* timeout of new auth */
    CARD32 *values;		/* list of supplied attributes */
    char *protoname;		/* auth proto name sent in request */
    char *protodata;		/* auth proto data sent in request */
    unsigned int authdata_len;  /* # bytes of generated auth data */
    char *pAuthdata;		/* generated auth data */
    Mask eventMask;		/* what events on this auth does client want */

    /* check request length */

    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);
    len = bytes_to_int32(SIZEOF(xSecurityGenerateAuthorizationReq));
    len += bytes_to_int32(stuff->nbytesAuthProto);
    len += bytes_to_int32(stuff->nbytesAuthData);
    values = ((CARD32 *)stuff) + len;
    len += Ones(stuff->valueMask);
    if (client->req_len != len)
	return BadLength;

    /* check valuemask */
    if (stuff->valueMask & ~XSecurityAllAuthorizationAttributes)
    {
	client->errorValue = stuff->valueMask;
	return BadValue;
    }

    /* check timeout */
    timeout = 60;
    if (stuff->valueMask & XSecurityTimeout)
    {
	timeout = *values++;
    }

    /* check trustLevel */
    trustLevel = XSecurityClientUntrusted;
    if (stuff->valueMask & XSecurityTrustLevel)
    {
	trustLevel = *values++;
	if (trustLevel != XSecurityClientTrusted &&
	    trustLevel != XSecurityClientUntrusted)
	{
	    client->errorValue = trustLevel;
	    return BadValue;
	}
    }

    /* check group */
    group = None;
    if (stuff->valueMask & XSecurityGroup)
    {
	group = *values++;
	if (SecurityValidateGroupCallback)
	{
	    SecurityValidateGroupInfoRec vgi;
	    vgi.group = group;
	    vgi.valid = FALSE;
	    CallCallbacks(&SecurityValidateGroupCallback, (pointer)&vgi);

	    /* if nobody said they recognized it, it's an error */

	    if (!vgi.valid)
	    {
		client->errorValue = group;
		return BadValue;
	    }
	}
    }

    /* check event mask */
    eventMask = 0;
    if (stuff->valueMask & XSecurityEventMask)
    {
	eventMask = *values++;
	if (eventMask & ~XSecurityAllEventMasks)
	{
	    client->errorValue = eventMask;
	    return BadValue;
	}
    }

    protoname = (char *)&stuff[1];
    protodata = protoname + bytes_to_int32(stuff->nbytesAuthProto);

    /* call os layer to generate the authorization */

    authId = GenerateAuthorization(stuff->nbytesAuthProto, protoname,
				   stuff->nbytesAuthData,  protodata,
				   &authdata_len, &pAuthdata);
    if ((XID) ~0L == authId)
    {
	err = SecurityErrorBase + XSecurityBadAuthorizationProtocol;
	goto bailout;
    }

    /* now that we've added the auth, remember to remove it if we have to
     * abort the request for some reason (like allocation failure)
     */
    removeAuth = TRUE;

    /* associate additional information with this auth ID */

    pAuth = malloc(sizeof(SecurityAuthorizationRec));
    if (!pAuth)
    {
	err = BadAlloc;
	goto bailout;
    }

    /* fill in the auth fields */

    pAuth->id = authId;
    pAuth->timeout = timeout;
    pAuth->group = group;
    pAuth->trustLevel = trustLevel;
    pAuth->refcnt = 0;	/* the auth was just created; nobody's using it yet */
    pAuth->secondsRemaining = 0;
    pAuth->timer = NULL;
    pAuth->eventClients = NULL;

    /* handle event selection */
    if (eventMask)
    {
	err = SecurityEventSelectForAuthorization(pAuth, client, eventMask);
	if (err != Success)
	    goto bailout;
    }

    if (!AddResource(authId, SecurityAuthorizationResType, pAuth))
    {
	err = BadAlloc;
	goto bailout;
    }

    /* start the timer ticking */

    if (pAuth->timeout != 0)
	SecurityStartAuthorizationTimer(pAuth);

    /* tell client the auth id and data */

    rep.type = X_Reply;
    rep.length = bytes_to_int32(authdata_len);
    rep.sequenceNumber = client->sequence;
    rep.authId = authId;
    rep.dataLength = authdata_len;

    if (client->swapped)
    {
	char n;
    	swapl(&rep.length, n);
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.authId, n);
    	swaps(&rep.dataLength, n);
    }

    WriteToClient(client, SIZEOF(xSecurityGenerateAuthorizationReply),
		  (char *)&rep);
    WriteToClient(client, authdata_len, pAuthdata);

    SecurityAudit("client %d generated authorization %d trust %d timeout %d group %d events %d\n",
		  client->index, pAuth->id, pAuth->trustLevel, pAuth->timeout,
		  pAuth->group, eventMask);

    /* the request succeeded; don't call RemoveAuthorization or free pAuth */
    return Success;

bailout:
    if (removeAuth)
	RemoveAuthorization(stuff->nbytesAuthProto, protoname,
			    authdata_len, pAuthdata);
    free(pAuth);
    return err;

} /* ProcSecurityGenerateAuthorization */

static int
ProcSecurityRevokeAuthorization(
    ClientPtr client)
{
    REQUEST(xSecurityRevokeAuthorizationReq);
    SecurityAuthorizationPtr pAuth;
    int rc;

    REQUEST_SIZE_MATCH(xSecurityRevokeAuthorizationReq);

    rc = dixLookupResourceByType((pointer *)&pAuth, stuff->authId,
				 SecurityAuthorizationResType, client,
				 DixDestroyAccess);
    if (rc != Success)
	return rc;

    FreeResource(stuff->authId, RT_NONE);
    return Success;
} /* ProcSecurityRevokeAuthorization */


static int
ProcSecurityDispatch(
    ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
	case X_SecurityQueryVersion:
	    return ProcSecurityQueryVersion(client);
	case X_SecurityGenerateAuthorization:
	    return ProcSecurityGenerateAuthorization(client);
	case X_SecurityRevokeAuthorization:
	    return ProcSecurityRevokeAuthorization(client);
	default:
	    return BadRequest;
    }
} /* ProcSecurityDispatch */

static int
SProcSecurityQueryVersion(
    ClientPtr client)
{
    REQUEST(xSecurityQueryVersionReq);
    char	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xSecurityQueryVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion,n);
    return ProcSecurityQueryVersion(client);
} /* SProcSecurityQueryVersion */


static int
SProcSecurityGenerateAuthorization(
    ClientPtr client)
{
    REQUEST(xSecurityGenerateAuthorizationReq);
    char	n;
    CARD32 *values;
    unsigned long nvalues;
    int values_offset;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);
    swaps(&stuff->nbytesAuthProto, n);
    swaps(&stuff->nbytesAuthData, n);
    swapl(&stuff->valueMask, n);
    values_offset = bytes_to_int32(stuff->nbytesAuthProto) +
		    bytes_to_int32(stuff->nbytesAuthData);
    if (values_offset > 
	stuff->length - bytes_to_int32(sz_xSecurityGenerateAuthorizationReq))
	return BadLength;
    values = (CARD32 *)(&stuff[1]) + values_offset;
    nvalues = (((CARD32 *)stuff) + stuff->length) - values;
    SwapLongs(values, nvalues);
    return ProcSecurityGenerateAuthorization(client);
} /* SProcSecurityGenerateAuthorization */


static int
SProcSecurityRevokeAuthorization(
    ClientPtr client)
{
    REQUEST(xSecurityRevokeAuthorizationReq);
    char	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xSecurityRevokeAuthorizationReq);
    swapl(&stuff->authId, n);
    return ProcSecurityRevokeAuthorization(client);
} /* SProcSecurityRevokeAuthorization */


static int
SProcSecurityDispatch(
    ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
	case X_SecurityQueryVersion:
	    return SProcSecurityQueryVersion(client);
	case X_SecurityGenerateAuthorization:
	    return SProcSecurityGenerateAuthorization(client);
	case X_SecurityRevokeAuthorization:
	    return SProcSecurityRevokeAuthorization(client);
	default:
	    return BadRequest;
    }
} /* SProcSecurityDispatch */

static void 
SwapSecurityAuthorizationRevokedEvent(
    xSecurityAuthorizationRevokedEvent *from,
    xSecurityAuthorizationRevokedEvent *to)
{
    to->type = from->type;
    to->detail = from->detail;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->authId, to->authId);
}

/* SecurityCheckDeviceAccess
 *
 * Arguments:
 *	client is the client attempting to access a device.
 *	dev is the device being accessed.
 *	fromRequest is TRUE if the device access is a direct result of
 *	  the client executing some request and FALSE if it is a
 *	  result of the server trying to send an event (e.g. KeymapNotify)
 *	  to the client.
 * Returns:
 *	TRUE if the device access should be allowed, else FALSE.
 *
 * Side Effects:
 *	An audit message is generated if access is denied.
 */

static void
SecurityDevice(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceDeviceAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityDeviceMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, stateKey);

    if (rec->dev != inputInfo.keyboard)
	/* this extension only supports the core keyboard */
	allowed = requested;

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
	SecurityAudit("Security denied client %d keyboard access on request "
		      "%s\n", rec->client->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
    }
}

/* SecurityResource
 *
 * This function gets plugged into client->CheckAccess and is called from
 * SecurityLookupIDByType/Class to determine if the client can access the
 * resource.
 *
 * Arguments:
 *	client is the client doing the resource access.
 *	id is the resource id.
 *	rtype is its type or class.
 *	access_mode represents the intended use of the resource; see
 *	  resource.h.
 *	res is a pointer to the resource structure for this resource.
 *
 * Returns:
 *	If access is granted, the value of rval that was passed in, else FALSE.
 *
 * Side Effects:
 *	Disallowed resource accesses are audited.
 */

static void
SecurityResource(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceResourceAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    int cid = CLIENT_ID(rec->id);
    Mask requested = rec->access_mode;
    Mask allowed = SecurityResourceMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);

    /* disable background None for untrusted windows */
    if ((requested & DixCreateAccess) && (rec->rtype == RT_WINDOW))
	if (subj->haveState && subj->trustLevel != XSecurityClientTrusted)
	    ((WindowPtr)rec->res)->forcedBG = TRUE;

    /* additional permissions for specific resource types */
    if (rec->rtype == RT_WINDOW)
	allowed |= SecurityWindowExtraMask;

    /* special checks for server-owned resources */
    if (cid == 0) {
	if (rec->rtype & RC_DRAWABLE)
	    /* additional operations allowed on root windows */
	    allowed |= SecurityRootWindowExtraMask;

	else if (rec->rtype == RT_COLORMAP)
	    /* allow access to default colormaps */
	    allowed = requested;

	else
	    /* allow read access to other server-owned resources */
	    allowed |= DixReadAccess;
    }

    if (clients[cid] != NULL) {
	obj = dixLookupPrivate(&clients[cid]->devPrivates, stateKey);
	if (SecurityDoCheck(subj, obj, requested, allowed) == Success)
	    return;
    }

    SecurityAudit("Security: denied client %d access %x to resource 0x%x "
		  "of client %d on request %s\n", rec->client->index,
		  requested, rec->id, cid,
		  SecurityLookupRequestName(rec->client));
    rec->status = BadAccess; /* deny access */
}


static void
SecurityExtension(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceExtAccessRec *rec = calldata;
    SecurityStateRec *subj;
    int i = 0;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);

    if (subj->haveState && subj->trustLevel == XSecurityClientTrusted)
	return;

    while (SecurityTrustedExtensions[i])
	if (!strcmp(SecurityTrustedExtensions[i++], rec->ext->name))
	    return;

    SecurityAudit("Security: denied client %d access to extension "
		  "%s on request %s\n",
		  rec->client->index, rec->ext->name,
		  SecurityLookupRequestName(rec->client));
    rec->status = BadAccess;
}

static void
SecurityServer(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceServerAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityServerMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, stateKey);
 
    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
	SecurityAudit("Security: denied client %d access to server "
		      "configuration request %s\n", rec->client->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
    }
}

static void
SecurityClient(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceClientAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityClientMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&rec->target->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
	SecurityAudit("Security: denied client %d access to client %d on "
		      "request %s\n", rec->client->index, rec->target->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
    }
}

static void
SecurityProperty(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{    
    XacePropertyAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    ATOM name = (*rec->ppProp)->propertyName;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityResourceMask | DixReadAccess;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
	SecurityAudit("Security: denied client %d access to property %s "
		      "(atom 0x%x) window 0x%x of client %d on request %s\n",
		      rec->client->index, NameForAtom(name), name,
		      rec->pWin->drawable.id, wClient(rec->pWin)->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
    }
}

static void
SecuritySend(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceSendAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;

    if (rec->client) {
	int i;

	subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
	obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

	if (SecurityDoCheck(subj, obj, DixSendAccess, 0) == Success)
	    return;

	for (i = 0; i < rec->count; i++)
	    if (rec->events[i].u.u.type != UnmapNotify &&
		rec->events[i].u.u.type != ConfigureRequest &&
		rec->events[i].u.u.type != ClientMessage) {

		SecurityAudit("Security: denied client %d from sending event "
			      "of type %s to window 0x%x of client %d\n",
			      rec->client->index,
			      LookupEventName(rec->events[i].u.u.type),
			      rec->pWin->drawable.id,
			      wClient(rec->pWin)->index);
		rec->status = BadAccess;
		return;
	    }
    }
}

static void
SecurityReceive(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceReceiveAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, DixReceiveAccess, 0) == Success)
	return;

    SecurityAudit("Security: denied client %d from receiving an event "
		  "sent to window 0x%x of client %d\n",
		  rec->client->index, rec->pWin->drawable.id,
		  wClient(rec->pWin)->index);
    rec->status = BadAccess;
}

/* SecurityClientStateCallback
 *
 * Arguments:
 *	pcbl is &ClientStateCallback.
 *	nullata is NULL.
 *	calldata is a pointer to a NewClientInfoRec (include/dixstruct.h)
 *	which contains information about client state changes.
 *
 * Returns: nothing.
 *
 * Side Effects:
 * 
 * If a new client is connecting, its authorization ID is copied to
 * client->authID.  If this is a generated authorization, its reference
 * count is bumped, its timer is cancelled if it was running, and its
 * trustlevel is copied to TRUSTLEVEL(client).
 * 
 * If a client is disconnecting and the client was using a generated
 * authorization, the authorization's reference count is decremented, and
 * if it is now zero, the timer for this authorization is started.
 */

static void
SecurityClientState(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    NewClientInfoRec *pci = calldata;
    SecurityStateRec *state;
    SecurityAuthorizationPtr pAuth;
    int rc;

    state = dixLookupPrivate(&pci->client->devPrivates, stateKey);

    switch (pci->client->clientState) {
    case ClientStateInitial:
	state->trustLevel = XSecurityClientTrusted;
	state->authId = None;
	state->haveState = TRUE;
	break;

    case ClientStateRunning:
	state->authId = AuthorizationIDOfClient(pci->client);
	rc = dixLookupResourceByType((pointer *)&pAuth, state->authId,
			       SecurityAuthorizationResType, serverClient,
			       DixGetAttrAccess);
	if (rc == Success) {
	    /* it is a generated authorization */
	    pAuth->refcnt++;
	    if (pAuth->refcnt == 1 && pAuth->timer)
		TimerCancel(pAuth->timer);

	    state->trustLevel = pAuth->trustLevel;
	}
	break;

    case ClientStateGone:
    case ClientStateRetained:
	rc = dixLookupResourceByType((pointer *)&pAuth, state->authId,
			       SecurityAuthorizationResType, serverClient,
			       DixGetAttrAccess);
	if (rc == Success) {
	    /* it is a generated authorization */
	    pAuth->refcnt--;
	    if (pAuth->refcnt == 0)
		SecurityStartAuthorizationTimer(pAuth);
	}
	break;

    default:
	break;
    }
}

/* SecurityResetProc
 *
 * Arguments:
 *	extEntry is the extension information for the security extension.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Performs any cleanup needed by Security at server shutdown time.
 */

static void
SecurityResetProc(
    ExtensionEntry *extEntry)
{
    /* Unregister callbacks */
    DeleteCallback(&ClientStateCallback, SecurityClientState, NULL);

    XaceDeleteCallback(XACE_EXT_DISPATCH, SecurityExtension, NULL);
    XaceDeleteCallback(XACE_RESOURCE_ACCESS, SecurityResource, NULL);
    XaceDeleteCallback(XACE_DEVICE_ACCESS, SecurityDevice, NULL);
    XaceDeleteCallback(XACE_PROPERTY_ACCESS, SecurityProperty, NULL);
    XaceDeleteCallback(XACE_SEND_ACCESS, SecuritySend, NULL);
    XaceDeleteCallback(XACE_RECEIVE_ACCESS, SecurityReceive, NULL);
    XaceDeleteCallback(XACE_CLIENT_ACCESS, SecurityClient, NULL);
    XaceDeleteCallback(XACE_EXT_ACCESS, SecurityExtension, NULL);
    XaceDeleteCallback(XACE_SERVER_ACCESS, SecurityServer, NULL);
}


/* SecurityExtensionInit
 *
 * Arguments: none.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Enables the Security extension if possible.
 */

void
SecurityExtensionInit(INITARGS)
{
    ExtensionEntry	*extEntry;
    int ret = TRUE;

    SecurityAuthorizationResType =
	CreateNewResourceType(SecurityDeleteAuthorization,
			      "SecurityAuthorization");

    RTEventClient =
	CreateNewResourceType(SecurityDeleteAuthorizationEventClient,
			      "SecurityEventClient");

    if (!SecurityAuthorizationResType || !RTEventClient)
	return;

    RTEventClient |= RC_NEVERRETAIN;

    /* Allocate the private storage */
    if (!dixRegisterPrivateKey(stateKey, PRIVATE_CLIENT, sizeof(SecurityStateRec)))
	FatalError("SecurityExtensionSetup: Can't allocate client private.\n");

    /* Register callbacks */
    ret &= AddCallback(&ClientStateCallback, SecurityClientState, NULL);

    ret &= XaceRegisterCallback(XACE_EXT_DISPATCH, SecurityExtension, NULL);
    ret &= XaceRegisterCallback(XACE_RESOURCE_ACCESS, SecurityResource, NULL);
    ret &= XaceRegisterCallback(XACE_DEVICE_ACCESS, SecurityDevice, NULL);
    ret &= XaceRegisterCallback(XACE_PROPERTY_ACCESS, SecurityProperty, NULL);
    ret &= XaceRegisterCallback(XACE_SEND_ACCESS, SecuritySend, NULL);
    ret &= XaceRegisterCallback(XACE_RECEIVE_ACCESS, SecurityReceive, NULL);
    ret &= XaceRegisterCallback(XACE_CLIENT_ACCESS, SecurityClient, NULL);
    ret &= XaceRegisterCallback(XACE_EXT_ACCESS, SecurityExtension, NULL);
    ret &= XaceRegisterCallback(XACE_SERVER_ACCESS, SecurityServer, NULL);

    if (!ret)
	FatalError("SecurityExtensionSetup: Failed to register callbacks\n");

    /* Add extension to server */
    extEntry = AddExtension(SECURITY_EXTENSION_NAME,
			    XSecurityNumberEvents, XSecurityNumberErrors,
			    ProcSecurityDispatch, SProcSecurityDispatch,
                            SecurityResetProc, StandardMinorOpcode);

    SecurityErrorBase = extEntry->errorBase;
    SecurityEventBase = extEntry->eventBase;

    EventSwapVector[SecurityEventBase + XSecurityAuthorizationRevoked] =
	(EventSwapPtr)SwapSecurityAuthorizationRevokedEvent;

    SetResourceTypeErrorValue(SecurityAuthorizationResType, SecurityErrorBase + XSecurityBadAuthorization);

    /* Label objects that were created before we could register ourself */
    SecurityLabelInitial();
}
/*
Copyright 1996, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.
*/

/* Xserver internals for Security extension - moved here from
   _SECURITY_SERVER section of <X11/extensions/security.h> */

#ifndef _SECURITY_SRV_H
#define _SECURITY_SRV_H

/* Allow client side portions of <X11/extensions/security.h> to compile */
#ifndef Status
# define Status int
# define NEED_UNDEF_Status
#endif
#ifndef Display
# define Display void
# define NEED_UNDEF_Display
#endif

#include <X11/extensions/secur.h>

#ifdef NEED_UNDEF_Status
# undef Status
# undef NEED_UNDEF_Status
#endif
#ifdef NEED_UNDEF_Display
# undef Display
# undef NEED_UNDEF_Display
#endif


#include "input.h"    /* for DeviceIntPtr */
#include "property.h" /* for PropertyPtr */
#include "pixmap.h"   /* for DrawablePtr */
#include "resource.h" /* for RESTYPE */

/* resource type to pass in LookupIDByType for authorizations */
extern RESTYPE SecurityAuthorizationResType;

/* this is what we store for an authorization */
typedef struct {
    XID id;			/* resource ID */
    CARD32 timeout;	/* how long to live in seconds after refcnt == 0 */
    unsigned int trustLevel;	/* trusted/untrusted */
    XID group;			/* see embedding extension */
    unsigned int refcnt;	/* how many clients connected with this auth */
    unsigned int secondsRemaining; /* overflow time amount for >49 days */
    OsTimerPtr timer;		/* timer for this auth */
    struct _OtherClients *eventClients; /* clients wanting events */
} SecurityAuthorizationRec, *SecurityAuthorizationPtr;

typedef struct {
    XID group;	/* the group that was sent in GenerateAuthorization */
    Bool valid; /* did anyone recognize it? if so, set to TRUE */
} SecurityValidateGroupInfoRec;

/* Give this value or higher to the -audit option to get security messages */
#define SECURITY_AUDIT_LEVEL 4

#endif /* _SECURITY_SRV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/shapeproto.h>
#include "regionstr.h"
#include "gcstruct.h"
#include "modinit.h"
#include "protocol-versions.h"

typedef	RegionPtr (*CreateDftPtr)(
	WindowPtr /* pWin */
	);

static int ShapeFreeClient(
	pointer /* data */,
	XID /* id */
	);
static int ShapeFreeEvents(
	pointer /* data */,
	XID /* id */
	);
static void SShapeNotifyEvent(
	xShapeNotifyEvent * /* from */,
	xShapeNotifyEvent * /* to */
	);

/* SendShapeNotify, CreateBoundingShape and CreateClipShape are used
 * externally by the Xfixes extension and are now defined in window.h
 */


#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

static int ShapeEventBase = 0;
static RESTYPE ClientType, ShapeEventType; /* resource types for event masks */

/*
 * each window has a list of clients requesting
 * ShapeNotify events.  Each client has a resource
 * for each window it selects ShapeNotify input for,
 * this resource is used to delete the ShapeNotifyRec
 * entry from the per-window queue.
 */

typedef struct _ShapeEvent *ShapeEventPtr;

typedef struct _ShapeEvent {
    ShapeEventPtr   next;
    ClientPtr	    client;
    WindowPtr	    window;
    XID		    clientResource;
} ShapeEventRec;

/****************
 * ShapeExtensionInit
 *
 * Called from InitExtensions in main() or from QueryExtension() if the
 * extension is dynamically loaded.
 *
 ****************/

static int
RegionOperate (
	ClientPtr client,
	WindowPtr pWin,
	int kind,
	RegionPtr *destRgnp,
	RegionPtr srcRgn,
	int op,
	int xoff, int yoff,
	CreateDftPtr create)
{
    if (srcRgn && (xoff || yoff))
	RegionTranslate(srcRgn, xoff, yoff);
    if (!pWin->parent)
    {
	if (srcRgn)
	    RegionDestroy(srcRgn);
	return Success;
    }

    /* May/30/2001:
     * The shape.PS specs say if src is None, existing shape is to be
     * removed (and so the op-code has no meaning in such removal);
     * see shape.PS, page 3, ShapeMask.
     */
    if (srcRgn == NULL) {
      if (*destRgnp != NULL) {
	RegionDestroy(*destRgnp);
	*destRgnp = 0;
	/* go on to remove shape and generate ShapeNotify */
      }
      else {
	/* May/30/2001:
	 * The target currently has no shape in effect, so nothing to
	 * do here.  The specs say that ShapeNotify is generated whenever
	 * the client region is "modified"; since no modification is done
	 * here, we do not generate that event.  The specs does not say
	 * "it is an error to request removal when there is no shape in
	 * effect", so we return good status.
	 */
	return Success;
      }
    }
    else switch (op) {
    case ShapeSet:
	if (*destRgnp)
	    RegionDestroy(*destRgnp);
	*destRgnp = srcRgn;
	srcRgn = 0;
	break;
    case ShapeUnion:
	if (*destRgnp)
	    RegionUnion(*destRgnp, *destRgnp, srcRgn);
	break;
    case ShapeIntersect:
	if (*destRgnp)
	    RegionIntersect(*destRgnp, *destRgnp, srcRgn);
	else {
	    *destRgnp = srcRgn;
	    srcRgn = 0;
	}
	break;
    case ShapeSubtract:
	if (!*destRgnp)
	    *destRgnp = (*create)(pWin);
	RegionSubtract(*destRgnp, *destRgnp, srcRgn);
	break;
    case ShapeInvert:
	if (!*destRgnp)
	    *destRgnp = RegionCreate((BoxPtr) 0, 0);
	else
	    RegionSubtract(*destRgnp, srcRgn, *destRgnp);
	break;
    default:
	client->errorValue = op;
	return BadValue;
    }
    if (srcRgn)
	RegionDestroy(srcRgn);
    (*pWin->drawable.pScreen->SetShape) (pWin, kind);
    SendShapeNotify (pWin, kind);
    return Success;
}

RegionPtr
CreateBoundingShape (WindowPtr pWin)
{
    BoxRec	extents;

    extents.x1 = -wBorderWidth (pWin);
    extents.y1 = -wBorderWidth (pWin);
    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
    return RegionCreate(&extents, 1);
}

RegionPtr
CreateClipShape (WindowPtr pWin)
{
    BoxRec	extents;

    extents.x1 = 0;
    extents.y1 = 0;
    extents.x2 = pWin->drawable.width;
    extents.y2 = pWin->drawable.height;
    return RegionCreate(&extents, 1);
}

static int
ProcShapeQueryVersion (ClientPtr client)
{
    xShapeQueryVersionReply	rep;
    int		n;

    REQUEST_SIZE_MATCH (xShapeQueryVersionReq);
    memset(&rep, 0, sizeof(xShapeQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SHAPE_MAJOR_VERSION;
    rep.minorVersion = SERVER_SHAPE_MINOR_VERSION;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof (xShapeQueryVersionReply), (char *)&rep);
    return Success;
}

/*****************
 * ProcShapeRectangles
 *
 *****************/

static int
ProcShapeRectangles (ClientPtr client)
{
    WindowPtr		pWin;
    REQUEST(xShapeRectanglesReq);
    xRectangle		*prects;
    int		        nrects, ctype, rc;
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    CreateDftPtr	createDefault;

    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
	createDefault = CreateBoundingShape;
	break;
    case ShapeClip:
	createDefault = CreateClipShape;
	break;
    case ShapeInput:
	createDefault = CreateBoundingShape;
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }
    if ((stuff->ordering != Unsorted) && (stuff->ordering != YSorted) &&
	(stuff->ordering != YXSorted) && (stuff->ordering != YXBanded))
    {
	client->errorValue = stuff->ordering;
        return BadValue;
    }
    nrects = ((stuff->length  << 2) - sizeof(xShapeRectanglesReq));
    if (nrects & 4)
	return BadLength;
    nrects >>= 3;
    prects = (xRectangle *) &stuff[1];
    ctype = VerifyRectOrder(nrects, prects, (int)stuff->ordering);
    if (ctype < 0)
	return BadMatch;
    srcRgn = RegionFromRects(nrects, prects, ctype);

    if (!pWin->optional)
	MakeWindowOptional (pWin);
    switch (stuff->destKind) {
    case ShapeBounding:
	destRgn = &pWin->optional->boundingShape;
	break;
    case ShapeClip:
	destRgn = &pWin->optional->clipShape;
	break;
    case ShapeInput:
	destRgn = &pWin->optional->inputShape;
	break;
    default:
	return BadValue;
    }

    return RegionOperate (client, pWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
}

#ifdef PANORAMIX
static int
ProcPanoramiXShapeRectangles(
    ClientPtr client)
{
    REQUEST(xShapeRectanglesReq);
    PanoramiXRes	*win;
    int        		j, result;

    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS(j) {
	stuff->dest = win->info[j].id;
	result = ProcShapeRectangles (client);
	if (result != Success) break;
    }
    return result;
}
#endif


/**************
 * ProcShapeMask
 **************/


static int
ProcShapeMask (ClientPtr client)
{
    WindowPtr		pWin;
    ScreenPtr		pScreen;
    REQUEST(xShapeMaskReq);
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    PixmapPtr		pPixmap;
    CreateDftPtr	createDefault;
    int			rc;

    REQUEST_SIZE_MATCH (xShapeMaskReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
	createDefault = CreateBoundingShape;
	break;
    case ShapeClip:
	createDefault = CreateClipShape;
	break;
    case ShapeInput:
	createDefault = CreateBoundingShape;
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }
    pScreen = pWin->drawable.pScreen;
    if (stuff->src == None)
	srcRgn = 0;
    else {
	rc = dixLookupResourceByType((pointer *)&pPixmap, stuff->src, RT_PIXMAP,
			       client, DixReadAccess);
        if (rc != Success)
	    return rc;
	if (pPixmap->drawable.pScreen != pScreen ||
	    pPixmap->drawable.depth != 1)
	    return BadMatch;
	srcRgn = BitmapToRegion(pScreen, pPixmap);
	if (!srcRgn)
	    return BadAlloc;
    }

    if (!pWin->optional)
	MakeWindowOptional (pWin);
    switch (stuff->destKind) {
    case ShapeBounding:
	destRgn = &pWin->optional->boundingShape;
	break;
    case ShapeClip:
	destRgn = &pWin->optional->clipShape;
	break;
    case ShapeInput:
	destRgn = &pWin->optional->inputShape;
	break;
    default:
	return BadValue;
    }

    return RegionOperate (client, pWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
}

#ifdef PANORAMIX
static int
ProcPanoramiXShapeMask(
    ClientPtr client)
{
    REQUEST(xShapeMaskReq);
    PanoramiXRes	*win, *pmap;
    int 		j, result;

    REQUEST_SIZE_MATCH (xShapeMaskReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    if(stuff->src != None) {
	result = dixLookupResourceByType((pointer *)&pmap, stuff->src,
					 XRT_PIXMAP, client, DixReadAccess);
	if (result != Success)
	    return result;
    } else
	pmap = NULL;

    FOR_NSCREENS(j) {
	stuff->dest = win->info[j].id;
	if(pmap)
	    stuff->src  = pmap->info[j].id;
	result = ProcShapeMask (client);
	if (result != Success) break;
    }
    return result;
}
#endif


/************
 * ProcShapeCombine
 ************/

static int
ProcShapeCombine (ClientPtr client)
{
    WindowPtr		pSrcWin, pDestWin;
    REQUEST(xShapeCombineReq);
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    CreateDftPtr	createDefault;
    CreateDftPtr	createSrc;
    RegionPtr		tmp;
    int			rc;

    REQUEST_SIZE_MATCH (xShapeCombineReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pDestWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (!pDestWin->optional)
	MakeWindowOptional (pDestWin);
    switch (stuff->destKind) {
    case ShapeBounding:
	createDefault = CreateBoundingShape;
	break;
    case ShapeClip:
	createDefault = CreateClipShape;
	break;
    case ShapeInput:
	createDefault = CreateBoundingShape;
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }

    rc = dixLookupWindow(&pSrcWin, stuff->src, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->srcKind) {
    case ShapeBounding:
	srcRgn = wBoundingShape (pSrcWin);
	createSrc = CreateBoundingShape;
	break;
    case ShapeClip:
	srcRgn = wClipShape (pSrcWin);
	createSrc = CreateClipShape;
	break;
    case ShapeInput:
	srcRgn = wInputShape (pSrcWin);
	createSrc = CreateBoundingShape;
	break;
    default:
	client->errorValue = stuff->srcKind;
	return BadValue;
    }
    if (pSrcWin->drawable.pScreen != pDestWin->drawable.pScreen)
    {
	return BadMatch;
    }

    if (srcRgn) {
        tmp = RegionCreate((BoxPtr) 0, 0);
        RegionCopy(tmp, srcRgn);
        srcRgn = tmp;
    } else
	srcRgn = (*createSrc) (pSrcWin);

    if (!pDestWin->optional)
	MakeWindowOptional (pDestWin);
    switch (stuff->destKind) {
    case ShapeBounding:
	destRgn = &pDestWin->optional->boundingShape;
	break;
    case ShapeClip:
	destRgn = &pDestWin->optional->clipShape;
	break;
    case ShapeInput:
	destRgn = &pDestWin->optional->inputShape;
	break;
    default:
	return BadValue;
    }

    return RegionOperate (client, pDestWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
}


#ifdef PANORAMIX
static int
ProcPanoramiXShapeCombine(
    ClientPtr client)
{
    REQUEST(xShapeCombineReq);
    PanoramiXRes	*win, *win2;
    int 		j, result;

    REQUEST_AT_LEAST_SIZE (xShapeCombineReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    result = dixLookupResourceByType((pointer *)&win2, stuff->src, XRT_WINDOW,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS(j) {
	stuff->dest = win->info[j].id;
	stuff->src =  win2->info[j].id;
	result = ProcShapeCombine (client);
	if (result != Success) break;
    }
    return result;
}
#endif

/*************
 * ProcShapeOffset
 *************/

static int
ProcShapeOffset (ClientPtr client)
{
    WindowPtr		pWin;
    REQUEST(xShapeOffsetReq);
    RegionPtr		srcRgn;
    int			rc;

    REQUEST_SIZE_MATCH (xShapeOffsetReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
	srcRgn = wBoundingShape (pWin);
	break;
    case ShapeClip:
	srcRgn = wClipShape(pWin);
	break;
    case ShapeInput:
	srcRgn = wInputShape (pWin);
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }
    if (srcRgn)
    {
        RegionTranslate(srcRgn, stuff->xOff, stuff->yOff);
        (*pWin->drawable.pScreen->SetShape) (pWin, stuff->destKind);
    }
    SendShapeNotify (pWin, (int)stuff->destKind);
    return Success;
}


#ifdef PANORAMIX
static int
ProcPanoramiXShapeOffset(
    ClientPtr client)
{
    REQUEST(xShapeOffsetReq);
    PanoramiXRes *win;
    int j, result;

    REQUEST_AT_LEAST_SIZE (xShapeOffsetReq);
   
    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS(j) {
	stuff->dest = win->info[j].id;
	result = ProcShapeOffset (client);
	if(result != Success) break;
    }
    return result;
}
#endif


static int
ProcShapeQueryExtents (ClientPtr client)
{
    REQUEST(xShapeQueryExtentsReq);
    WindowPtr		pWin;
    xShapeQueryExtentsReply	rep;
    BoxRec		extents, *pExtents;
    int	n, rc;
    RegionPtr		region;

    REQUEST_SIZE_MATCH (xShapeQueryExtentsReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    memset(&rep, 0, sizeof(xShapeQueryExtentsReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.boundingShaped = (wBoundingShape(pWin) != 0);
    rep.clipShaped = (wClipShape(pWin) != 0);
    if ((region = wBoundingShape(pWin))) {
     /* this is done in two steps because of a compiler bug on SunOS 4.1.3 */
	pExtents = RegionExtents(region);
	extents = *pExtents;
    } else {
	extents.x1 = -wBorderWidth (pWin);
	extents.y1 = -wBorderWidth (pWin);
	extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
    }
    rep.xBoundingShape = extents.x1;
    rep.yBoundingShape = extents.y1;
    rep.widthBoundingShape = extents.x2 - extents.x1;
    rep.heightBoundingShape = extents.y2 - extents.y1;
    if ((region = wClipShape(pWin))) {
     /* this is done in two steps because of a compiler bug on SunOS 4.1.3 */
	pExtents = RegionExtents(region);
	extents = *pExtents;
    } else {
	extents.x1 = 0;
	extents.y1 = 0;
	extents.x2 = pWin->drawable.width;
	extents.y2 = pWin->drawable.height;
    }
    rep.xClipShape = extents.x1;
    rep.yClipShape = extents.y1;
    rep.widthClipShape = extents.x2 - extents.x1;
    rep.heightClipShape = extents.y2 - extents.y1;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.xBoundingShape, n);
	swaps(&rep.yBoundingShape, n);
	swaps(&rep.widthBoundingShape, n);
	swaps(&rep.heightBoundingShape, n);
	swaps(&rep.xClipShape, n);
	swaps(&rep.yClipShape, n);
	swaps(&rep.widthClipShape, n);
	swaps(&rep.heightClipShape, n);
    }
    WriteToClient(client, sizeof (xShapeQueryExtentsReply), (char *)&rep);
    return Success;
}

/*ARGSUSED*/
static int
ShapeFreeClient (pointer data, XID id)
{
    ShapeEventPtr   pShapeEvent;
    WindowPtr	    pWin;
    ShapeEventPtr   *pHead, pCur, pPrev;
    int rc;

    pShapeEvent = (ShapeEventPtr) data;
    pWin = pShapeEvent->window;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, serverClient, DixReadAccess);
    if (rc == Success) {
	pPrev = 0;
	for (pCur = *pHead; pCur && pCur != pShapeEvent; pCur=pCur->next)
	    pPrev = pCur;
	if (pCur)
	{
	    if (pPrev)
	    	pPrev->next = pShapeEvent->next;
	    else
	    	*pHead = pShapeEvent->next;
	}
    }
    free((pointer) pShapeEvent);
    return 1;
}

/*ARGSUSED*/
static int
ShapeFreeEvents (pointer data, XID id)
{
    ShapeEventPtr   *pHead, pCur, pNext;

    pHead = (ShapeEventPtr *) data;
    for (pCur = *pHead; pCur; pCur = pNext) {
	pNext = pCur->next;
	FreeResource (pCur->clientResource, ClientType);
	free((pointer) pCur);
    }
    free((pointer) pHead);
    return 1;
}

static int
ProcShapeSelectInput (ClientPtr client)
{
    REQUEST(xShapeSelectInputReq);
    WindowPtr		pWin;
    ShapeEventPtr	pShapeEvent, pNewShapeEvent, *pHead;
    XID			clientResource;
    int			rc;

    REQUEST_SIZE_MATCH (xShapeSelectInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReceiveAccess);
    if (rc != Success)
	return rc;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, client, DixWriteAccess);
    if (rc != Success && rc != BadValue)
	return rc;

    switch (stuff->enable) {
    case xTrue:
	if (pHead) {

	    /* check for existing entry. */
	    for (pShapeEvent = *pHead;
		 pShapeEvent;
 		 pShapeEvent = pShapeEvent->next)
	    {
		if (pShapeEvent->client == client)
		    return Success;
	    }
	}

	/* build the entry */
	pNewShapeEvent = malloc(sizeof (ShapeEventRec));
    	if (!pNewShapeEvent)
	    return BadAlloc;
    	pNewShapeEvent->next = 0;
    	pNewShapeEvent->client = client;
    	pNewShapeEvent->window = pWin;
    	/*
 	 * add a resource that will be deleted when
     	 * the client goes away
     	 */
   	clientResource = FakeClientID (client->index);
    	pNewShapeEvent->clientResource = clientResource;
    	if (!AddResource (clientResource, ClientType, (pointer)pNewShapeEvent))
	    return BadAlloc;
    	/*
     	 * create a resource to contain a pointer to the list
     	 * of clients selecting input.  This must be indirect as
     	 * the list may be arbitrarily rearranged which cannot be
     	 * done through the resource database.
     	 */
    	if (!pHead)
    	{
	    pHead = malloc(sizeof (ShapeEventPtr));
	    if (!pHead ||
		!AddResource (pWin->drawable.id, ShapeEventType, (pointer)pHead))
	    {
	    	FreeResource (clientResource, RT_NONE);
	    	return BadAlloc;
	    }
	    *pHead = 0;
    	}
    	pNewShapeEvent->next = *pHead;
    	*pHead = pNewShapeEvent;
	break;
    case xFalse:
	/* delete the interest */
	if (pHead) {
	    pNewShapeEvent = 0;
	    for (pShapeEvent = *pHead; pShapeEvent; pShapeEvent = pShapeEvent->next) {
		if (pShapeEvent->client == client)
		    break;
		pNewShapeEvent = pShapeEvent;
	    }
	    if (pShapeEvent) {
		FreeResource (pShapeEvent->clientResource, ClientType);
		if (pNewShapeEvent)
		    pNewShapeEvent->next = pShapeEvent->next;
		else
		    *pHead = pShapeEvent->next;
		free(pShapeEvent);
	    }
	}
	break;
    default:
	client->errorValue = stuff->enable;
	return BadValue;
    }
    return Success;
}

/*
 * deliver the event
 */

void
SendShapeNotify (WindowPtr pWin, int which)
{
    ShapeEventPtr	*pHead, pShapeEvent;
    xShapeNotifyEvent	se;
    BoxRec		extents;
    RegionPtr		region;
    BYTE		shaped;
    int rc;

    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, serverClient, DixReadAccess);
    if (rc != Success)
	return;
    switch (which) {
    case ShapeBounding:
	region = wBoundingShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = -wBorderWidth (pWin);
	    extents.y1 = -wBorderWidth (pWin);
	    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
	    shaped = xFalse;
	}
	break;
    case ShapeClip:
	region = wClipShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = 0;
	    extents.y1 = 0;
	    extents.x2 = pWin->drawable.width;
	    extents.y2 = pWin->drawable.height;
	    shaped = xFalse;
	}
	break;
    case ShapeInput:
	region = wInputShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = -wBorderWidth (pWin);
	    extents.y1 = -wBorderWidth (pWin);
	    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
	    shaped = xFalse;
	}
	break;
    default:
	return;
    }
    for (pShapeEvent = *pHead; pShapeEvent; pShapeEvent = pShapeEvent->next) {
	se.type = ShapeNotify + ShapeEventBase;
	se.kind = which;
	se.window = pWin->drawable.id;
	se.x = extents.x1;
	se.y = extents.y1;
	se.width = extents.x2 - extents.x1;
	se.height = extents.y2 - extents.y1;
	se.time = currentTime.milliseconds;
	se.shaped = shaped;
	WriteEventsToClient (pShapeEvent->client, 1, (xEvent *) &se);
    }
}

static int
ProcShapeInputSelected (ClientPtr client)
{
    REQUEST(xShapeInputSelectedReq);
    WindowPtr		pWin;
    ShapeEventPtr	pShapeEvent, *pHead;
    int			enabled, rc;
    xShapeInputSelectedReply	rep;
    int		n;

    REQUEST_SIZE_MATCH (xShapeInputSelectedReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, client, DixReadAccess);
    if (rc != Success && rc != BadValue)
	return rc;
    enabled = xFalse;
    if (pHead) {
    	for (pShapeEvent = *pHead;
	     pShapeEvent;
	     pShapeEvent = pShapeEvent->next)
    	{
	    if (pShapeEvent->client == client) {
	    	enabled = xTrue;
		break;
	    }
    	}
    }
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.enabled = enabled;
    if (client->swapped) {
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
    }
    WriteToClient (client, sizeof (xShapeInputSelectedReply), (char *) &rep);
    return Success;
}

static int
ProcShapeGetRectangles (ClientPtr client)
{
    REQUEST(xShapeGetRectanglesReq);
    WindowPtr			pWin;
    xShapeGetRectanglesReply	rep;
    xRectangle			*rects;
    int				nrects, i, rc;
    RegionPtr			region;
    int		n;

    REQUEST_SIZE_MATCH(xShapeGetRectanglesReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->kind) {
    case ShapeBounding:
	region = wBoundingShape(pWin);
	break;
    case ShapeClip:
	region = wClipShape(pWin);
	break;
    case ShapeInput:
	region = wInputShape (pWin);
	break;
    default:
	client->errorValue = stuff->kind;
	return BadValue;
    }
    if (!region) {
	nrects = 1;
	rects = malloc(sizeof (xRectangle));
	if (!rects)
	    return BadAlloc;
	switch (stuff->kind) {
	case ShapeBounding:
	    rects->x = - (int) wBorderWidth (pWin);
	    rects->y = - (int) wBorderWidth (pWin);
	    rects->width = pWin->drawable.width + wBorderWidth (pWin);
	    rects->height = pWin->drawable.height + wBorderWidth (pWin);
	    break;
	case ShapeClip:
	    rects->x = 0;
	    rects->y = 0;
	    rects->width = pWin->drawable.width;
	    rects->height = pWin->drawable.height;
	    break;
	case ShapeInput:
	    rects->x = - (int) wBorderWidth (pWin);
	    rects->y = - (int) wBorderWidth (pWin);
	    rects->width = pWin->drawable.width + wBorderWidth (pWin);
	    rects->height = pWin->drawable.height + wBorderWidth (pWin);
	    break;
	}
    } else {
	BoxPtr box;
	nrects = RegionNumRects(region);
	box = RegionRects(region);
	rects = malloc(nrects * sizeof (xRectangle));
	if (!rects && nrects)
	    return BadAlloc;
	for (i = 0; i < nrects; i++, box++) {
	    rects[i].x = box->x1;
	    rects[i].y = box->y1;
	    rects[i].width = box->x2 - box->x1;
	    rects[i].height = box->y2 - box->y1;
	}
    }
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = bytes_to_int32(nrects * sizeof (xRectangle));
    rep.ordering = YXBanded;
    rep.nrects = nrects;
    if (client->swapped) {
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.nrects, n);
	SwapShorts ((short *)rects, (unsigned long)nrects * 4);
    }
    WriteToClient (client, sizeof (rep), (char *) &rep);
    WriteToClient (client, nrects * sizeof (xRectangle), (char *) rects);
    free(rects);
    return Success;
}

static int
ProcShapeDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_ShapeQueryVersion:
	return ProcShapeQueryVersion (client);
    case X_ShapeRectangles:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
	    return ProcPanoramiXShapeRectangles (client);
        else 
#endif
	return ProcShapeRectangles (client);
    case X_ShapeMask:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeMask (client);
	else
#endif
	return ProcShapeMask (client);
    case X_ShapeCombine:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeCombine (client);
	else
#endif
	return ProcShapeCombine (client);
    case X_ShapeOffset:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeOffset (client);
	else
#endif
	return ProcShapeOffset (client);
    case X_ShapeQueryExtents:
	return ProcShapeQueryExtents (client);
    case X_ShapeSelectInput:
	return ProcShapeSelectInput (client);
    case X_ShapeInputSelected:
	return ProcShapeInputSelected (client);
    case X_ShapeGetRectangles:
	return ProcShapeGetRectangles (client);
    default:
	return BadRequest;
    }
}

static void
SShapeNotifyEvent(xShapeNotifyEvent *from, xShapeNotifyEvent *to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswapl (from->window, to->window);
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswaps (from->x, to->x);
    cpswaps (from->y, to->y);
    cpswaps (from->width, to->width);
    cpswaps (from->height, to->height);
    cpswapl (from->time, to->time);
    to->shaped = from->shaped;
}

static int
SProcShapeQueryVersion (ClientPtr client)
{
    int    n;
    REQUEST (xShapeQueryVersionReq);

    swaps (&stuff->length, n);
    return ProcShapeQueryVersion (client);
}

static int
SProcShapeRectangles (ClientPtr client)
{
    char   n;
    REQUEST (xShapeRectanglesReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    SwapRestS(stuff);
    return ProcShapeRectangles (client);
}

static int
SProcShapeMask (ClientPtr client)
{
    char   n;
    REQUEST (xShapeMaskReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeMaskReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->src, n);
    return ProcShapeMask (client);
}

static int
SProcShapeCombine (ClientPtr client)
{
    char   n;
    REQUEST (xShapeCombineReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeCombineReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->src, n);
    return ProcShapeCombine (client);
}

static int
SProcShapeOffset (ClientPtr client)
{
    char   n;
    REQUEST (xShapeOffsetReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeOffsetReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    return ProcShapeOffset (client);
}

static int
SProcShapeQueryExtents (ClientPtr client)
{
    char   n;
    REQUEST (xShapeQueryExtentsReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeQueryExtentsReq);
    swapl (&stuff->window, n);
    return ProcShapeQueryExtents (client);
}

static int
SProcShapeSelectInput (ClientPtr client)
{
    char   n;
    REQUEST (xShapeSelectInputReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeSelectInputReq);
    swapl (&stuff->window, n);
    return ProcShapeSelectInput (client);
}

static int
SProcShapeInputSelected (ClientPtr client)
{
    int    n;
    REQUEST (xShapeInputSelectedReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeInputSelectedReq);
    swapl (&stuff->window, n);
    return ProcShapeInputSelected (client);
}

static int
SProcShapeGetRectangles (ClientPtr client)
{
    REQUEST(xShapeGetRectanglesReq);
    char   n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xShapeGetRectanglesReq);
    swapl (&stuff->window, n);
    return ProcShapeGetRectangles (client);
}

static int
SProcShapeDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_ShapeQueryVersion:
	return SProcShapeQueryVersion (client);
    case X_ShapeRectangles:
	return SProcShapeRectangles (client);
    case X_ShapeMask:
	return SProcShapeMask (client);
    case X_ShapeCombine:
	return SProcShapeCombine (client);
    case X_ShapeOffset:
	return SProcShapeOffset (client);
    case X_ShapeQueryExtents:
	return SProcShapeQueryExtents (client);
    case X_ShapeSelectInput:
	return SProcShapeSelectInput (client);
    case X_ShapeInputSelected:
	return SProcShapeInputSelected (client);
    case X_ShapeGetRectangles:
	return SProcShapeGetRectangles (client);
    default:
	return BadRequest;
    }
}

void
ShapeExtensionInit(void)
{
    ExtensionEntry *extEntry;

    ClientType = CreateNewResourceType(ShapeFreeClient, "ShapeClient");
    ShapeEventType = CreateNewResourceType(ShapeFreeEvents, "ShapeEvent");
    if (ClientType && ShapeEventType &&
	(extEntry = AddExtension(SHAPENAME, ShapeNumberEvents, 0,
				 ProcShapeDispatch, SProcShapeDispatch,
				 NULL, StandardMinorOpcode)))
    {
	ShapeEventBase = extEntry->eventBase;
	EventSwapVector[ShapeEventBase] = (EventSwapPtr) SShapeNotifyEvent;
    }
}
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

********************************************************/

/* THIS IS NOT AN X CONSORTIUM STANDARD OR AN X PROJECT TEAM SPECIFICATION */


#define SHM

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <sys/stat.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "extnsionst.h"
#include "servermd.h"
#include "shmint.h"
#include "xace.h"
#include <X11/extensions/shmproto.h>
#include <X11/Xfuncproto.h>
#include "protocol-versions.h"

/* Needed for Solaris cross-zone shared memory extension */
#ifdef HAVE_SHMCTL64
#include <sys/ipc_impl.h>
#define SHMSTAT(id, buf)	shmctl64(id, IPC_STAT64, buf)
#define SHMSTAT_TYPE 		struct shmid_ds64
#define SHMPERM_TYPE 		struct ipc_perm64
#define SHM_PERM(buf) 		buf.shmx_perm
#define SHM_SEGSZ(buf)		buf.shmx_segsz
#define SHMPERM_UID(p)		p->ipcx_uid
#define SHMPERM_CUID(p)		p->ipcx_cuid
#define SHMPERM_GID(p)		p->ipcx_gid
#define SHMPERM_CGID(p)		p->ipcx_cgid
#define SHMPERM_MODE(p)		p->ipcx_mode
#define SHMPERM_ZONEID(p)	p->ipcx_zoneid
#else
#define SHMSTAT(id, buf) 	shmctl(id, IPC_STAT, buf)
#define SHMSTAT_TYPE 		struct shmid_ds
#define SHMPERM_TYPE 		struct ipc_perm
#define SHM_PERM(buf) 		buf.shm_perm
#define SHM_SEGSZ(buf)		buf.shm_segsz
#define SHMPERM_UID(p)		p->uid
#define SHMPERM_CUID(p)		p->cuid
#define SHMPERM_GID(p)		p->gid
#define SHMPERM_CGID(p)		p->cgid
#define SHMPERM_MODE(p)		p->mode
#endif

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

#include "modinit.h"

typedef struct _ShmDesc {
    struct _ShmDesc *next;
    int shmid;
    int refcnt;
    char *addr;
    Bool writable;
    unsigned long size;
} ShmDescRec, *ShmDescPtr;

typedef struct _ShmScrPrivateRec {
    CloseScreenProcPtr CloseScreen;
    ShmFuncsPtr shmFuncs;
    DestroyPixmapProcPtr destroyPixmap;
} ShmScrPrivateRec;

static PixmapPtr fbShmCreatePixmap(XSHM_CREATE_PIXMAP_ARGS);
static int ShmDetachSegment(
    pointer		/* value */,
    XID			/* shmseg */
    );
static void ShmResetProc(
    ExtensionEntry *	/* extEntry */
    );
static void SShmCompletionEvent(
    xShmCompletionEvent * /* from */,
    xShmCompletionEvent * /* to */
    );

static Bool ShmDestroyPixmap (PixmapPtr pPixmap);


static unsigned char ShmReqCode;
int ShmCompletionCode;
int BadShmSegCode;
RESTYPE ShmSegType;
static ShmDescPtr Shmsegs;
static Bool sharedPixmaps;
static DevPrivateKeyRec shmScrPrivateKeyRec;
#define shmScrPrivateKey (&shmScrPrivateKeyRec)
static DevPrivateKeyRec shmPixmapPrivateKeyRec;
#define shmPixmapPrivateKey (&shmPixmapPrivateKeyRec)
static ShmFuncs miFuncs = {NULL, NULL};
static ShmFuncs fbFuncs = {fbShmCreatePixmap, NULL};

#define ShmGetScreenPriv(s) ((ShmScrPrivateRec *)dixLookupPrivate(&(s)->devPrivates, shmScrPrivateKey))

#define VERIFY_SHMSEG(shmseg,shmdesc,client) \
{ \
    int rc; \
    rc = dixLookupResourceByType((pointer *)&(shmdesc), shmseg, ShmSegType, \
                                 client, DixReadAccess); \
    if (rc != Success) \
	return rc; \
}

#define VERIFY_SHMPTR(shmseg,offset,needwrite,shmdesc,client) \
{ \
    VERIFY_SHMSEG(shmseg, shmdesc, client); \
    if ((offset & 3) || (offset > shmdesc->size)) \
    { \
	client->errorValue = offset; \
	return BadValue; \
    } \
    if (needwrite && !shmdesc->writable) \
	return BadAccess; \
}

#define VERIFY_SHMSIZE(shmdesc,offset,len,client) \
{ \
    if ((offset + len) > shmdesc->size) \
    { \
	return BadAccess; \
    } \
}


#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__) || defined(__DragonFly__)
#include <sys/signal.h>

static Bool badSysCall = FALSE;

static void
SigSysHandler(int signo)
{
    badSysCall = TRUE;
}

static Bool CheckForShmSyscall(void)
{
    void (*oldHandler)();
    int shmid = -1;

    /* If no SHM support in the kernel, the bad syscall will generate SIGSYS */
    oldHandler = signal(SIGSYS, SigSysHandler);

    badSysCall = FALSE;
    shmid = shmget(IPC_PRIVATE, 4096, IPC_CREAT);

    if (shmid != -1)
    {
        /* Successful allocation - clean up */
	shmctl(shmid, IPC_RMID, NULL);
    }
    else
    {
        /* Allocation failed */
        badSysCall = TRUE;
    }
    signal(SIGSYS, oldHandler);
    return !badSysCall;
}

#define MUST_CHECK_FOR_SHM_SYSCALL

#endif

static Bool
ShmCloseScreen(int i, ScreenPtr pScreen)
{
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);
    pScreen->CloseScreen = screen_priv->CloseScreen;
    dixSetPrivate(&pScreen->devPrivates, shmScrPrivateKey, NULL);
    free(screen_priv);
    return (*pScreen->CloseScreen) (i, pScreen);
}

static ShmScrPrivateRec *
ShmInitScreenPriv(ScreenPtr pScreen)
{
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);
    if (!screen_priv)
    {
	screen_priv = calloc(1, sizeof (ShmScrPrivateRec));
	screen_priv->CloseScreen = pScreen->CloseScreen;
	dixSetPrivate(&pScreen->devPrivates, shmScrPrivateKey, screen_priv);
	pScreen->CloseScreen = ShmCloseScreen;
    }
    return screen_priv;
}

static Bool
ShmRegisterPrivates(void)
{
    if (!dixRegisterPrivateKey(&shmScrPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;
    if (!dixRegisterPrivateKey(&shmPixmapPrivateKeyRec, PRIVATE_PIXMAP, 0))
	return FALSE;
    return TRUE;
}

/*ARGSUSED*/
static void
ShmResetProc(ExtensionEntry *extEntry)
{
    int i;
    for (i = 0; i < screenInfo.numScreens; i++)
	ShmRegisterFuncs(screenInfo.screens[i], NULL);
}

void
ShmRegisterFuncs(ScreenPtr pScreen, ShmFuncsPtr funcs)
{
    if (!ShmRegisterPrivates())
	return;
    ShmInitScreenPriv(pScreen)->shmFuncs = funcs;
}

static Bool
ShmDestroyPixmap (PixmapPtr pPixmap)
{
    ScreenPtr	    pScreen = pPixmap->drawable.pScreen;
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);
    Bool	    ret;
    if (pPixmap->refcnt == 1)
    {
	ShmDescPtr  shmdesc;
	shmdesc = (ShmDescPtr)dixLookupPrivate(&pPixmap->devPrivates,
					       shmPixmapPrivateKey);
	if (shmdesc)
	    ShmDetachSegment ((pointer) shmdesc, pPixmap->drawable.id);
    }
    
    pScreen->DestroyPixmap = screen_priv->destroyPixmap;
    ret = (*pScreen->DestroyPixmap) (pPixmap);
    screen_priv->destroyPixmap = pScreen->DestroyPixmap;
    pScreen->DestroyPixmap = ShmDestroyPixmap;
    return ret;
}

void
ShmRegisterFbFuncs(ScreenPtr pScreen)
{
    ShmRegisterFuncs(pScreen, &fbFuncs);
}

static int
ProcShmQueryVersion(ClientPtr client)
{
    xShmQueryVersionReply rep;
    int n;

    REQUEST_SIZE_MATCH(xShmQueryVersionReq);
    memset(&rep, 0, sizeof(xShmQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.sharedPixmaps = sharedPixmaps;
    rep.pixmapFormat = sharedPixmaps ? ZPixmap : 0;
    rep.majorVersion = SERVER_SHM_MAJOR_VERSION;
    rep.minorVersion = SERVER_SHM_MINOR_VERSION;
    rep.uid = geteuid();
    rep.gid = getegid();
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
	swaps(&rep.uid, n);
	swaps(&rep.gid, n);
    }
    WriteToClient(client, sizeof(xShmQueryVersionReply), (char *)&rep);
    return Success;
}

/*
 * Simulate the access() system call for a shared memory segement,
 * using the credentials from the client if available
 */
static int
shm_access(ClientPtr client, SHMPERM_TYPE *perm, int readonly)
{
    int uid, gid;
    mode_t mask;
    int uidset = 0, gidset = 0;
    LocalClientCredRec *lcc;
    
    if (GetLocalClientCreds(client, &lcc) != -1) {

	if (lcc->fieldsSet & LCC_UID_SET) {
	    uid = lcc->euid;
	    uidset = 1;
	}
	if (lcc->fieldsSet & LCC_GID_SET) {
	    gid = lcc->egid;
	    gidset = 1;
	}

#if defined(HAVE_GETZONEID) && defined(SHMPERM_ZONEID)
	if ( ((lcc->fieldsSet & LCC_ZID_SET) == 0) || (lcc->zoneid == -1)
	     || (lcc->zoneid != SHMPERM_ZONEID(perm))) {
		uidset = 0;
		gidset = 0;
	}
#endif
	FreeLocalClientCreds(lcc);
	
	if (uidset) {
	    /* User id 0 always gets access */
	    if (uid == 0) {
		return 0;
	    }
	    /* Check the owner */
	    if (SHMPERM_UID(perm) == uid || SHMPERM_CUID(perm) == uid) {
		mask = S_IRUSR;
		if (!readonly) {
		    mask |= S_IWUSR;
		}
		return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
	    }
	}

	if (gidset) {
	    /* Check the group */
	    if (SHMPERM_GID(perm) == gid || SHMPERM_CGID(perm) == gid) {
		mask = S_IRGRP;
		if (!readonly) {
		    mask |= S_IWGRP;
		}
		return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
	    }
	}
    }
    /* Otherwise, check everyone else */
    mask = S_IROTH;
    if (!readonly) {
	mask |= S_IWOTH;
    }
    return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
}

static int
ProcShmAttach(ClientPtr client)
{
    SHMSTAT_TYPE buf;
    ShmDescPtr shmdesc;
    REQUEST(xShmAttachReq);

    REQUEST_SIZE_MATCH(xShmAttachReq);
    LEGAL_NEW_RESOURCE(stuff->shmseg, client);
    if ((stuff->readOnly != xTrue) && (stuff->readOnly != xFalse))
    {
	client->errorValue = stuff->readOnly;
        return BadValue;
    }
    for (shmdesc = Shmsegs;
	 shmdesc && (shmdesc->shmid != stuff->shmid);
	 shmdesc = shmdesc->next)
	;
    if (shmdesc)
    {
	if (!stuff->readOnly && !shmdesc->writable)
	    return BadAccess;
	shmdesc->refcnt++;
    }
    else
    {
	shmdesc = malloc(sizeof(ShmDescRec));
	if (!shmdesc)
	    return BadAlloc;
	shmdesc->addr = shmat(stuff->shmid, 0,
			      stuff->readOnly ? SHM_RDONLY : 0);
	if ((shmdesc->addr == ((char *)-1)) ||
	    SHMSTAT(stuff->shmid, &buf))
	{
	    free(shmdesc);
	    return BadAccess;
	}

	/* The attach was performed with root privs. We must
	 * do manual checking of access rights for the credentials 
	 * of the client */

	if (shm_access(client, &(SHM_PERM(buf)), stuff->readOnly) == -1) {
	    shmdt(shmdesc->addr);
	    free(shmdesc);
	    return BadAccess;
	}

	shmdesc->shmid = stuff->shmid;
	shmdesc->refcnt = 1;
	shmdesc->writable = !stuff->readOnly;
	shmdesc->size = SHM_SEGSZ(buf);
	shmdesc->next = Shmsegs;
	Shmsegs = shmdesc;
    }
    if (!AddResource(stuff->shmseg, ShmSegType, (pointer)shmdesc))
	return BadAlloc;
    return Success;
}

/*ARGSUSED*/
static int
ShmDetachSegment(pointer value, /* must conform to DeleteType */
		 XID shmseg)
{
    ShmDescPtr shmdesc = (ShmDescPtr)value;
    ShmDescPtr *prev;

    if (--shmdesc->refcnt)
	return TRUE;
    shmdt(shmdesc->addr);
    for (prev = &Shmsegs; *prev != shmdesc; prev = &(*prev)->next)
	;
    *prev = shmdesc->next;
    free(shmdesc);
    return Success;
}

static int
ProcShmDetach(ClientPtr client)
{
    ShmDescPtr shmdesc;
    REQUEST(xShmDetachReq);

    REQUEST_SIZE_MATCH(xShmDetachReq);
    VERIFY_SHMSEG(stuff->shmseg, shmdesc, client);
    FreeResource(stuff->shmseg, RT_NONE);
    return Success;
}

/*
 * If the given request doesn't exactly match PutImage's constraints,
 * wrap the image in a scratch pixmap header and let CopyArea sort it out.
 */
static void
doShmPutImage(DrawablePtr dst, GCPtr pGC,
	      int depth, unsigned int format,
	      int w, int h, int sx, int sy, int sw, int sh, int dx, int dy,
	      char *data)
{
    PixmapPtr pPixmap;

    if (format == ZPixmap || depth == 1) {
	pPixmap = GetScratchPixmapHeader(dst->pScreen, w, h, depth,
					 BitsPerPixel(depth),
					 PixmapBytePad(w, depth),
					 data);
	if (!pPixmap)
	    return;
	pGC->ops->CopyArea((DrawablePtr)pPixmap, dst, pGC, sx, sy, sw, sh, dx, dy);
	FreeScratchPixmapHeader(pPixmap);
    } else {
	GCPtr putGC = GetScratchGC(depth, dst->pScreen);

	if (!putGC)
	    return;

	pPixmap = (*dst->pScreen->CreatePixmap)(dst->pScreen, sw, sh, depth,
						CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pPixmap) {
	    FreeScratchGC(putGC);
	    return;
	}
	ValidateGC(&pPixmap->drawable, putGC);
	(*putGC->ops->PutImage)(&pPixmap->drawable, putGC, depth, -sx, -sy, w, h, 0,
				(format == XYPixmap) ? XYPixmap : ZPixmap, data);
	FreeScratchGC(putGC);
	if (format == XYBitmap)
	    (void)(*pGC->ops->CopyPlane)(&pPixmap->drawable, dst, pGC, 0, 0, sw, sh,
					 dx, dy, 1L);
	else
	    (void)(*pGC->ops->CopyArea)(&pPixmap->drawable, dst, pGC, 0, 0, sw, sh,
					dx, dy);
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
    }
}

static int
ProcShmPutImage(ClientPtr client)
{
    GCPtr pGC;
    DrawablePtr pDraw;
    long length;
    ShmDescPtr shmdesc;
    REQUEST(xShmPutImageReq);

    REQUEST_SIZE_MATCH(xShmPutImageReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, FALSE, shmdesc, client);
    if ((stuff->sendEvent != xTrue) && (stuff->sendEvent != xFalse))
	return BadValue;
    if (stuff->format == XYBitmap)
    {
        if (stuff->depth != 1)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, 1);
    }
    else if (stuff->format == XYPixmap)
    {
        if (pDraw->depth != stuff->depth)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, 1);
	length *= stuff->depth;
    }
    else if (stuff->format == ZPixmap)
    {
        if (pDraw->depth != stuff->depth)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, stuff->depth);
    }
    else
    {
	client->errorValue = stuff->format;
        return BadValue;
    }

    /*
     * There's a potential integer overflow in this check:
     * VERIFY_SHMSIZE(shmdesc, stuff->offset, length * stuff->totalHeight,
     *                client);
     * the version below ought to avoid it
     */
    if (stuff->totalHeight != 0 &&
	length > (shmdesc->size - stuff->offset)/stuff->totalHeight) {
	client->errorValue = stuff->totalWidth;
	return BadValue;
    }
    if (stuff->srcX > stuff->totalWidth)
    {
	client->errorValue = stuff->srcX;
	return BadValue;
    }
    if (stuff->srcY > stuff->totalHeight)
    {
	client->errorValue = stuff->srcY;
	return BadValue;
    }
    if ((stuff->srcX + stuff->srcWidth) > stuff->totalWidth)
    {
	client->errorValue = stuff->srcWidth;
	return BadValue;
    }
    if ((stuff->srcY + stuff->srcHeight) > stuff->totalHeight)
    {
	client->errorValue = stuff->srcHeight;
	return BadValue;
    }

    if ((((stuff->format == ZPixmap) && (stuff->srcX == 0)) ||
	 ((stuff->format != ZPixmap) &&
	  (stuff->srcX < screenInfo.bitmapScanlinePad) &&
	  ((stuff->format == XYBitmap) ||
	   ((stuff->srcY == 0) &&
	    (stuff->srcHeight == stuff->totalHeight))))) &&
	((stuff->srcX + stuff->srcWidth) == stuff->totalWidth))
	(*pGC->ops->PutImage) (pDraw, pGC, stuff->depth,
			       stuff->dstX, stuff->dstY,
			       stuff->totalWidth, stuff->srcHeight,
			       stuff->srcX, stuff->format,
			       shmdesc->addr + stuff->offset +
			       (stuff->srcY * length));
    else
	doShmPutImage(pDraw, pGC, stuff->depth, stuff->format,
		      stuff->totalWidth, stuff->totalHeight,
		      stuff->srcX, stuff->srcY,
		      stuff->srcWidth, stuff->srcHeight,
		      stuff->dstX, stuff->dstY,
                      shmdesc->addr + stuff->offset);

    if (stuff->sendEvent)
    {
	xShmCompletionEvent ev;

	ev.type = ShmCompletionCode;
	ev.drawable = stuff->drawable;
	ev.minorEvent = X_ShmPutImage;
	ev.majorEvent = ShmReqCode;
	ev.shmseg = stuff->shmseg;
	ev.offset = stuff->offset;
	WriteEventsToClient(client, 1, (xEvent *) &ev);
    }

    return Success;
}

static int
ProcShmGetImage(ClientPtr client)
{
    DrawablePtr		pDraw;
    long		lenPer = 0, length;
    Mask		plane = 0;
    xShmGetImageReply	xgi;
    ShmDescPtr		shmdesc;
    int			n, rc;

    REQUEST(xShmGetImageReq);

    REQUEST_SIZE_MATCH(xShmGetImageReq);
    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap))
    {
	client->errorValue = stuff->format;
        return BadValue;
    }
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;
    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);
    if (pDraw->type == DRAWABLE_WINDOW)
    {
      if( /* check for being viewable */
	 !((WindowPtr) pDraw)->realized ||
	  /* check for being on screen */
         pDraw->x + stuff->x < 0 ||
         pDraw->x + stuff->x + (int)stuff->width > pDraw->pScreen->width ||
         pDraw->y + stuff->y < 0 ||
         pDraw->y + stuff->y + (int)stuff->height > pDraw->pScreen->height ||
          /* check for being inside of border */
         stuff->x < - wBorderWidth((WindowPtr)pDraw) ||
         stuff->x + (int)stuff->width >
		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
         stuff->y < -wBorderWidth((WindowPtr)pDraw) ||
         stuff->y + (int)stuff->height >
		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->height
        )
	    return BadMatch;
	xgi.visual = wVisual(((WindowPtr)pDraw));
    }
    else
    {
	if (stuff->x < 0 ||
	    stuff->x+(int)stuff->width > pDraw->width ||
	    stuff->y < 0 ||
	    stuff->y+(int)stuff->height > pDraw->height
	    )
	    return BadMatch;
	xgi.visual = None;
    }
    xgi.type = X_Reply;
    xgi.length = 0;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
    if(stuff->format == ZPixmap)
    {
	length = PixmapBytePad(stuff->width, pDraw->depth) * stuff->height;
    }
    else
    {
	lenPer = PixmapBytePad(stuff->width, 1) * stuff->height;
	plane = ((Mask)1) << (pDraw->depth - 1);
	/* only planes asked for */
	length = lenPer * Ones(stuff->planeMask & (plane | (plane - 1)));
    }

    VERIFY_SHMSIZE(shmdesc, stuff->offset, length, client);
    xgi.size = length;

    if (length == 0)
    {
	/* nothing to do */
    }
    else if (stuff->format == ZPixmap)
    {
	(*pDraw->pScreen->GetImage)(pDraw, stuff->x, stuff->y,
				    stuff->width, stuff->height,
				    stuff->format, stuff->planeMask,
				    shmdesc->addr + stuff->offset);
    }
    else
    {

	length = stuff->offset;
        for (; plane; plane >>= 1)
	{
	    if (stuff->planeMask & plane)
	    {
		(*pDraw->pScreen->GetImage)(pDraw,
					    stuff->x, stuff->y,
					    stuff->width, stuff->height,
					    stuff->format, plane,
					    shmdesc->addr + length);
		length += lenPer;
	    }
	}
    }

    if (client->swapped) {
	swaps(&xgi.sequenceNumber, n);
	swapl(&xgi.length, n);
	swapl(&xgi.visual, n);
	swapl(&xgi.size, n);
    }
    WriteToClient(client, sizeof(xShmGetImageReply), (char *)&xgi);

    return Success;
}

#ifdef PANORAMIX
static int 
ProcPanoramiXShmPutImage(ClientPtr client)
{
    int			 j, result, orig_x, orig_y;
    PanoramiXRes	*draw, *gc;
    Bool		 sendEvent, isRoot;

    REQUEST(xShmPutImageReq);
    REQUEST_SIZE_MATCH(xShmPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    orig_x = stuff->dstX;
    orig_y = stuff->dstY;
    sendEvent = stuff->sendEvent;
    stuff->sendEvent = 0;
    FOR_NSCREENS(j) {
	if(!j) stuff->sendEvent = sendEvent;
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->dstX = orig_x - screenInfo.screens[j]->x;
	    stuff->dstY = orig_y - screenInfo.screens[j]->y;
	}
	result = ProcShmPutImage(client);
	if(result != Success) break;
    }
    return result;
}

static int 
ProcPanoramiXShmGetImage(ClientPtr client)
{
    PanoramiXRes	*draw;
    DrawablePtr 	*drawables;
    DrawablePtr 	pDraw;
    xShmGetImageReply	xgi;
    ShmDescPtr		shmdesc;
    int         	i, x, y, w, h, format, rc;
    Mask		plane = 0, planemask;
    long		lenPer = 0, length, widthBytesLine;
    Bool		isRoot;

    REQUEST(xShmGetImageReq);

    REQUEST_SIZE_MATCH(xShmGetImageReq);

    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap)) {
	client->errorValue = stuff->format;
        return BadValue;
    }

    rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    if (draw->type == XRT_PIXMAP)
	return ProcShmGetImage(client);

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);

    x = stuff->x;
    y = stuff->y;
    w = stuff->width;
    h = stuff->height;
    format = stuff->format;
    planemask = stuff->planeMask;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    if(isRoot) {
      if( /* check for being onscreen */
	x < 0 || x + w > PanoramiXPixWidth ||
	y < 0 || y + h > PanoramiXPixHeight )
	    return BadMatch;
    } else {
      if( /* check for being onscreen */
	screenInfo.screens[0]->x + pDraw->x + x < 0 ||
	screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth ||
	screenInfo.screens[0]->y + pDraw->y + y < 0 ||
	screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight ||
	 /* check for being inside of border */
       	x < - wBorderWidth((WindowPtr)pDraw) ||
	x + w > wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
	y < -wBorderWidth((WindowPtr)pDraw) ||
	y + h > wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height)
	    return BadMatch;
    }

    drawables = calloc(PanoramiXNumScreens, sizeof(DrawablePtr));
    if(!drawables)
	return BadAlloc;

    drawables[0] = pDraw;
    FOR_NSCREENS_FORWARD_SKIP(i) {
	rc = dixLookupDrawable(drawables+i, draw->info[i].id, client, 0, 
			       DixReadAccess);
	if (rc != Success)
	{
	    free(drawables);
	    return rc;
	}
    }

    xgi.visual = wVisual(((WindowPtr)pDraw));
    xgi.type = X_Reply;
    xgi.length = 0;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;

    if(format == ZPixmap) {
	widthBytesLine = PixmapBytePad(w, pDraw->depth);
	length = widthBytesLine * h;
    } else {
	widthBytesLine = PixmapBytePad(w, 1);
	lenPer = widthBytesLine * h;
	plane = ((Mask)1) << (pDraw->depth - 1);
	length = lenPer * Ones(planemask & (plane | (plane - 1)));
    }

    VERIFY_SHMSIZE(shmdesc, stuff->offset, length, client);
    xgi.size = length;

    if (length == 0) {/* nothing to do */ }
    else if (format == ZPixmap) {
	    XineramaGetImageData(drawables, x, y, w, h, format, planemask,
					shmdesc->addr + stuff->offset,
					widthBytesLine, isRoot);
    } else {

	length = stuff->offset;
        for (; plane; plane >>= 1) {
	    if (planemask & plane) {
		XineramaGetImageData(drawables, x, y, w, h, 
				     format, plane, shmdesc->addr + length,
				     widthBytesLine, isRoot);
		length += lenPer;
	    }
	}
    }
    free(drawables);
    
    if (client->swapped) {
	int n;
    	swaps(&xgi.sequenceNumber, n);
    	swapl(&xgi.length, n);
	swapl(&xgi.visual, n);
	swapl(&xgi.size, n);
    }
    WriteToClient(client, sizeof(xShmGetImageReply), (char *)&xgi);

    return Success;
}

static int
ProcPanoramiXShmCreatePixmap(ClientPtr client)
{
    ScreenPtr pScreen = NULL;
    PixmapPtr pMap = NULL;
    DrawablePtr pDraw;
    DepthPtr pDepth;
    int i, j, result, rc;
    ShmDescPtr shmdesc;
    REQUEST(xShmCreatePixmapReq);
    unsigned int width, height, depth;
    unsigned long size;
    PanoramiXRes *newPix;

    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    client->errorValue = stuff->pid;
    if (!sharedPixmaps)
	return BadImplementation;
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);

    width = stuff->width;
    height = stuff->height;
    depth = stuff->depth;
    if (!width || !height || !depth)
    {
	client->errorValue = 0;
        return BadValue;
    }
    if (width > 32767 || height > 32767)
        return BadAlloc;

    if (stuff->depth != 1)
    {
        pDepth = pDraw->pScreen->allowedDepths;
        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)
	   if (pDepth->depth == stuff->depth)
               goto CreatePmap;
	client->errorValue = stuff->depth;
        return BadValue;
    }

CreatePmap:
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {
        if (size < width * height)
            return BadAlloc;
    }
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
	return BadAlloc;

    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);

    if(!(newPix = malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPix->type = XRT_PIXMAP;
    newPix->u.pix.shared = TRUE;
    panoramix_setup_ids(newPix, client, stuff->pid);

    result = Success;

    FOR_NSCREENS(j) {
	ShmScrPrivateRec *screen_priv;
	pScreen = screenInfo.screens[j];

	screen_priv = ShmGetScreenPriv(pScreen);
	pMap = (*screen_priv->shmFuncs->CreatePixmap)(pScreen,
				stuff->width, stuff->height, stuff->depth,
				shmdesc->addr + stuff->offset);

	if (pMap) {
	    dixSetPrivate(&pMap->devPrivates, shmPixmapPrivateKey, shmdesc);
            shmdesc->refcnt++;
	    pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	    pMap->drawable.id = newPix->info[j].id;
	    if (!AddResource(newPix->info[j].id, RT_PIXMAP, (pointer)pMap)) {
		result = BadAlloc;
		break;
	    }
	} else {
	   result = BadAlloc;
	   break;
	}
    }

    if(result == BadAlloc) {
	while(j--)
	    FreeResource(newPix->info[j].id, RT_NONE);
	free(newPix);
    } else 
	AddResource(stuff->pid, XRT_PIXMAP, newPix);

    return result;
}
#endif

static PixmapPtr
fbShmCreatePixmap (ScreenPtr pScreen,
		   int width, int height, int depth, char *addr)
{
    PixmapPtr pPixmap;

    pPixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, pScreen->rootDepth, 0);
    if (!pPixmap)
	return NullPixmap;

    if (!(*pScreen->ModifyPixmapHeader)(pPixmap, width, height, depth,
	    BitsPerPixel(depth), PixmapBytePad(width, depth), (pointer)addr)) {
	(*pScreen->DestroyPixmap)(pPixmap);
	return NullPixmap;
    }
    return pPixmap;
}

static int
ProcShmCreatePixmap(ClientPtr client)
{
    PixmapPtr pMap;
    DrawablePtr pDraw;
    DepthPtr pDepth;
    int i, rc;
    ShmDescPtr shmdesc;
    ShmScrPrivateRec *screen_priv;
    REQUEST(xShmCreatePixmapReq);
    unsigned int width, height, depth;
    unsigned long size;

    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    client->errorValue = stuff->pid;
    if (!sharedPixmaps)
	return BadImplementation;
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);
    
    width = stuff->width;
    height = stuff->height;
    depth = stuff->depth;
    if (!width || !height || !depth)
    {
	client->errorValue = 0;
        return BadValue;
    }
    if (width > 32767 || height > 32767)
	return BadAlloc;

    if (stuff->depth != 1)
    {
        pDepth = pDraw->pScreen->allowedDepths;
        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)
	   if (pDepth->depth == stuff->depth)
               goto CreatePmap;
	client->errorValue = stuff->depth;
        return BadValue;
    }

CreatePmap:
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {
	if (size < width * height)
	    return BadAlloc;
    }
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
	return BadAlloc;

    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);
    screen_priv = ShmGetScreenPriv(pDraw->pScreen);
    pMap = (*screen_priv->shmFuncs->CreatePixmap)(
			    pDraw->pScreen, stuff->width,
			    stuff->height, stuff->depth,
			    shmdesc->addr + stuff->offset);
    if (pMap)
    {
	rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,
		      pMap, RT_NONE, NULL, DixCreateAccess);
	if (rc != Success) {
	    pDraw->pScreen->DestroyPixmap(pMap);
	    return rc;
	}
	dixSetPrivate(&pMap->devPrivates, shmPixmapPrivateKey, shmdesc);
	shmdesc->refcnt++;
	pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	pMap->drawable.id = stuff->pid;
	if (AddResource(stuff->pid, RT_PIXMAP, (pointer)pMap))
	{
	    return Success;
	}
    }
    return BadAlloc;
}

static int
ProcShmDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_ShmQueryVersion:
	return ProcShmQueryVersion(client);
    case X_ShmAttach:
	return ProcShmAttach(client);
    case X_ShmDetach:
	return ProcShmDetach(client);
    case X_ShmPutImage:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmPutImage(client);
#endif
	return ProcShmPutImage(client);
    case X_ShmGetImage:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmGetImage(client);
#endif
	return ProcShmGetImage(client);
    case X_ShmCreatePixmap:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmCreatePixmap(client);
#endif
	   return ProcShmCreatePixmap(client);
    default:
	return BadRequest;
    }
}

static void
SShmCompletionEvent(xShmCompletionEvent *from, xShmCompletionEvent *to)
{
    to->type = from->type;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->drawable, to->drawable);
    cpswaps(from->minorEvent, to->minorEvent);
    to->majorEvent = from->majorEvent;
    cpswapl(from->shmseg, to->shmseg);
    cpswapl(from->offset, to->offset);
}

static int
SProcShmQueryVersion(ClientPtr client)
{
    int n;
    REQUEST(xShmQueryVersionReq);

    swaps(&stuff->length, n);
    return ProcShmQueryVersion(client);
}

static int
SProcShmAttach(ClientPtr client)
{
    int n;
    REQUEST(xShmAttachReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmAttachReq);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->shmid, n);
    return ProcShmAttach(client);
}

static int
SProcShmDetach(ClientPtr client)
{
    int n;
    REQUEST(xShmDetachReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmDetachReq);
    swapl(&stuff->shmseg, n);
    return ProcShmDetach(client);
}

static int
SProcShmPutImage(ClientPtr client)
{
    int n;
    REQUEST(xShmPutImageReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmPutImageReq);
    swapl(&stuff->drawable, n);
    swapl(&stuff->gc, n);
    swaps(&stuff->totalWidth, n);
    swaps(&stuff->totalHeight, n);
    swaps(&stuff->srcX, n);
    swaps(&stuff->srcY, n);
    swaps(&stuff->srcWidth, n);
    swaps(&stuff->srcHeight, n);
    swaps(&stuff->dstX, n);
    swaps(&stuff->dstY, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
    return ProcShmPutImage(client);
}

static int
SProcShmGetImage(ClientPtr client)
{
    int n;
    REQUEST(xShmGetImageReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmGetImageReq);
    swapl(&stuff->drawable, n);
    swaps(&stuff->x, n);
    swaps(&stuff->y, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    swapl(&stuff->planeMask, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
    return ProcShmGetImage(client);
}

static int
SProcShmCreatePixmap(ClientPtr client)
{
    int n;
    REQUEST(xShmCreatePixmapReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    swapl(&stuff->pid, n);
    swapl(&stuff->drawable, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
    return ProcShmCreatePixmap(client);
}

static int
SProcShmDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_ShmQueryVersion:
	return SProcShmQueryVersion(client);
    case X_ShmAttach:
	return SProcShmAttach(client);
    case X_ShmDetach:
	return SProcShmDetach(client);
    case X_ShmPutImage:
	return SProcShmPutImage(client);
    case X_ShmGetImage:
	return SProcShmGetImage(client);
    case X_ShmCreatePixmap:
	return SProcShmCreatePixmap(client);
    default:
	return BadRequest;
    }
}

void
ShmExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;
    int i;

#ifdef MUST_CHECK_FOR_SHM_SYSCALL
    if (!CheckForShmSyscall())
    {
	ErrorF("MIT-SHM extension disabled due to lack of kernel support\n");
	return;
    }
#endif

    if (!ShmRegisterPrivates())
	return;

    sharedPixmaps = xFalse;
    {
      sharedPixmaps = xTrue;
      for (i = 0; i < screenInfo.numScreens; i++)
      {
	ShmScrPrivateRec *screen_priv = ShmInitScreenPriv(screenInfo.screens[i]);
	if (!screen_priv->shmFuncs)
	    screen_priv->shmFuncs = &miFuncs;
	if (!screen_priv->shmFuncs->CreatePixmap)
	    sharedPixmaps = xFalse;
      }
      if (sharedPixmaps)
	for (i = 0; i < screenInfo.numScreens; i++)
	{
	    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(screenInfo.screens[i]);
	    screen_priv->destroyPixmap = screenInfo.screens[i]->DestroyPixmap;
	    screenInfo.screens[i]->DestroyPixmap = ShmDestroyPixmap;
	}
    }
    ShmSegType = CreateNewResourceType(ShmDetachSegment, "ShmSeg");
    if (ShmSegType &&
	(extEntry = AddExtension(SHMNAME, ShmNumberEvents, ShmNumberErrors,
				 ProcShmDispatch, SProcShmDispatch,
				 ShmResetProc, StandardMinorOpcode)))
    {
	ShmReqCode = (unsigned char)extEntry->base;
	ShmCompletionCode = extEntry->eventBase;
	BadShmSegCode = extEntry->errorBase;
	SetResourceTypeErrorValue(ShmSegType, BadShmSegCode);
	EventSwapVector[ShmCompletionCode] = (EventSwapPtr) SShmCompletionEvent;
    }
}
/*
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _SHMINT_H_
#define _SHMINT_H_

#include <X11/extensions/shmproto.h>

#include "screenint.h"
#include "pixmap.h"
#include "gc.h"

#define XSHM_PUT_IMAGE_ARGS \
    DrawablePtr		/* dst */, \
    GCPtr		/* pGC */, \
    int			/* depth */, \
    unsigned int	/* format */, \
    int			/* w */, \
    int			/* h */, \
    int			/* sx */, \
    int			/* sy */, \
    int			/* sw */, \
    int			/* sh */, \
    int			/* dx */, \
    int			/* dy */, \
    char *		/* data */

#define XSHM_CREATE_PIXMAP_ARGS \
    ScreenPtr	/* pScreen */, \
    int		/* width */, \
    int		/* height */, \
    int		/* depth */, \
    char *	/* addr */

typedef struct _ShmFuncs {
    PixmapPtr	(* CreatePixmap)(XSHM_CREATE_PIXMAP_ARGS);
    void	(* PutImage)(XSHM_PUT_IMAGE_ARGS);
} ShmFuncs, *ShmFuncsPtr;

extern _X_EXPORT void
ShmRegisterFuncs(ScreenPtr pScreen, ShmFuncsPtr funcs);

extern _X_EXPORT void
ShmRegisterFbFuncs(ScreenPtr pScreen);

extern _X_EXPORT RESTYPE ShmSegType;
extern _X_EXPORT int ShmCompletionCode;
extern _X_EXPORT int BadShmSegCode;

#endif /* _SHMINT_H_ */
/*
 *
Copyright 1992, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
 *
 * Author:  Keith Packard, MIT X Consortium
 */

/* dixsleep.c - implement millisecond timeouts for X clients */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "sleepuntil.h"
#include <X11/X.h>
#include <X11/Xmd.h>
#include "misc.h"
#include "windowstr.h"
#include "dixstruct.h"
#include "pixmapstr.h"
#include "scrnintstr.h"

typedef struct _Sertafied {
    struct _Sertafied	*next;
    TimeStamp		revive;
    ClientPtr		pClient;
    XID			id;
    void		(*notifyFunc)(
			ClientPtr /* client */,
			pointer /* closure */
			);

    pointer		closure;
} SertafiedRec, *SertafiedPtr;

static SertafiedPtr pPending;
static RESTYPE	    SertafiedResType;
static Bool	    BlockHandlerRegistered;
static int	    SertafiedGeneration;

static void	    ClientAwaken(
    ClientPtr /* client */,
    pointer /* closure */
);
static int	    SertafiedDelete(
    pointer /* value */,
    XID /* id */
);
static void	    SertafiedBlockHandler(
    pointer /* data */,
    OSTimePtr /* wt */,
    pointer /* LastSelectMask */
);
static void	    SertafiedWakeupHandler(
    pointer /* data */,
    int /* i */,
    pointer /* LastSelectMask */
);

int
ClientSleepUntil (ClientPtr client,
                  TimeStamp *revive,
                  void (*notifyFunc)(ClientPtr, pointer),
                  pointer closure)
{
    SertafiedPtr	pRequest, pReq, pPrev;

    if (SertafiedGeneration != serverGeneration)
    {
	SertafiedResType = CreateNewResourceType (SertafiedDelete,
						  "ClientSleep");
	if (!SertafiedResType)
	    return FALSE;
	SertafiedGeneration = serverGeneration;
	BlockHandlerRegistered = FALSE;
    }
    pRequest = malloc(sizeof (SertafiedRec));
    if (!pRequest)
	return FALSE;
    pRequest->pClient = client;
    pRequest->revive = *revive;
    pRequest->id = FakeClientID (client->index);
    pRequest->closure = closure;
    if (!BlockHandlerRegistered)
    {
	if (!RegisterBlockAndWakeupHandlers (SertafiedBlockHandler,
					     SertafiedWakeupHandler,
					     (pointer) 0))
	{
	    free(pRequest);
	    return FALSE;
	}
	BlockHandlerRegistered = TRUE;
    }
    pRequest->notifyFunc = 0;
    if (!AddResource (pRequest->id, SertafiedResType, (pointer) pRequest))
	return FALSE;
    if (!notifyFunc)
	notifyFunc = ClientAwaken;
    pRequest->notifyFunc = notifyFunc;
    /* Insert into time-ordered queue, with earliest activation time coming first. */
    pPrev = 0;
    for (pReq = pPending; pReq; pReq = pReq->next)
    {
	if (CompareTimeStamps (pReq->revive, *revive) == LATER)
	    break;
	pPrev = pReq;
    }
    if (pPrev)
	pPrev->next = pRequest;
    else
	pPending = pRequest;
    pRequest->next = pReq;
    IgnoreClient (client);
    return TRUE;
}

static void
ClientAwaken (ClientPtr client, pointer closure)
{
    if (!client->clientGone)
	AttendClient (client);
}


static int
SertafiedDelete (pointer value, XID id)
{
    SertafiedPtr	pRequest = (SertafiedPtr)value;
    SertafiedPtr	pReq, pPrev;

    pPrev = 0;
    for (pReq = pPending; pReq; pPrev = pReq, pReq = pReq->next)
	if (pReq == pRequest)
	{
	    if (pPrev)
		pPrev->next = pReq->next;
	    else
		pPending = pReq->next;
	    break;
	}
    if (pRequest->notifyFunc)
	(*pRequest->notifyFunc) (pRequest->pClient, pRequest->closure);
    free(pRequest);
    return TRUE;
}

static void
SertafiedBlockHandler (pointer data, OSTimePtr wt, pointer LastSelectMask)
{
    SertafiedPtr	    pReq, pNext;
    unsigned long	    delay;
    TimeStamp		    now;

    if (!pPending)
	return;
    now.milliseconds = GetTimeInMillis ();
    now.months = currentTime.months;
    if ((int) (now.milliseconds - currentTime.milliseconds) < 0)
	now.months++;
    for (pReq = pPending; pReq; pReq = pNext)
    {
	pNext = pReq->next;
	if (CompareTimeStamps (pReq->revive, now) == LATER)
	    break;
	FreeResource (pReq->id, RT_NONE);

 	/* AttendClient() may have been called via the resource delete
 	 * function so a client may have input to be processed and so
 	 *  set delay to 0 to prevent blocking in WaitForSomething().
 	 */
 	AdjustWaitForDelay (wt, 0);
    }
    pReq = pPending;
    if (!pReq)
	return;
    delay = pReq->revive.milliseconds - now.milliseconds;
    AdjustWaitForDelay (wt, delay);
}

static void
SertafiedWakeupHandler (pointer data, int i, pointer LastSelectMask)
{
    SertafiedPtr	pReq, pNext;
    TimeStamp		now;

    now.milliseconds = GetTimeInMillis ();
    now.months = currentTime.months;
    if ((int) (now.milliseconds - currentTime.milliseconds) < 0)
	now.months++;
    for (pReq = pPending; pReq; pReq = pNext)
    {
	pNext = pReq->next;
	if (CompareTimeStamps (pReq->revive, now) == LATER)
	    break;
	FreeResource (pReq->id, RT_NONE);
    }
    if (!pPending)
    {
	RemoveBlockAndWakeupHandlers (SertafiedBlockHandler,
				      SertafiedWakeupHandler,
				      (pointer) 0);
	BlockHandlerRegistered = FALSE;
    }
}
/*
 * Copyright (C) 2001 The XFree86 Project, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _SLEEPUNTIL_H_
#define _SLEEPUNTIL_H_ 1

#include "dix.h"

extern int ClientSleepUntil(
    ClientPtr client,
    TimeStamp *revive,
    void (*notifyFunc)(
	ClientPtr /* client */,
	pointer   /* closure */
	),
    pointer Closure
);

#endif
/*

Copyright 1991, 1993, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.


Copyright 1991, 1993 by Digital Equipment Corporation, Maynard, Massachusetts,
and Olivetti Research Limited, Cambridge, England.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or Olivetti
not be used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  Digital and Olivetti
make no representations about the suitability of this software
for any purpose.  It is provided "as is" without express or implied warranty.

DIGITAL AND OLIVETTI DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL THEY BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xmd.h>
#include "scrnintstr.h"
#include "os.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "pixmapstr.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/syncproto.h>
#include "syncsrv.h"
#include "syncsdk.h"
#include "protocol-versions.h"

#include <stdio.h>
#if !defined(WIN32)
#include <sys/time.h>
#endif

#include "modinit.h"

/*
 * Local Global Variables
 */
static int      SyncEventBase;
static int      SyncErrorBase;
static RESTYPE  RTCounter = 0;
static RESTYPE  RTAwait;
static RESTYPE  RTAlarm;
static RESTYPE  RTAlarmClient;
static RESTYPE  RTFence;
static int SyncNumSystemCounters = 0;
static SyncCounter **SysCounterList = NULL;
static int SyncNumInvalidCounterWarnings = 0;
#define MAX_INVALID_COUNTER_WARNINGS	   5

static const char *WARN_INVALID_COUNTER_COMPARE =
"Warning: Non-counter XSync object using Counter-only\n"
"         comparison.  Result will never be true.\n";

static const char *WARN_INVALID_COUNTER_ALARM =
"Warning: Non-counter XSync object used in alarm.  This is\n"
"         the result of a programming error in the X server.\n";

#define IsSystemCounter(pCounter) \
    (pCounter && (pCounter->sync.client == NULL))

/* these are all the alarm attributes that pertain to the alarm's trigger */
#define XSyncCAAllTrigger \
    (XSyncCACounter | XSyncCAValueType | XSyncCAValue | XSyncCATestType)

static void SyncComputeBracketValues(SyncCounter *);

static void SyncInitServerTime(void);

static void SyncInitIdleTime(void);

static Bool
SyncCheckWarnIsCounter(const SyncObject* pSync, const char *warning)
{
    if (pSync && (SYNC_COUNTER != pSync->type))
    {
	if (SyncNumInvalidCounterWarnings++ < MAX_INVALID_COUNTER_WARNINGS)
	{
	    ErrorF("%s", warning);
	    ErrorF("         Counter type: %d\n", pSync->type);
	}

	return FALSE;
    }

    return TRUE;
}

/*  Each counter maintains a simple linked list of triggers that are
 *  interested in the counter.  The two functions below are used to
 *  delete and add triggers on this list.
 */
static void
SyncDeleteTriggerFromSyncObject(SyncTrigger *pTrigger)
{
    SyncTriggerList *pCur;
    SyncTriggerList *pPrev;
    SyncCounter *pCounter;

    /* pSync needs to be stored in pTrigger before calling here. */

    if (!pTrigger->pSync)
	return;

    pPrev = NULL;
    pCur = pTrigger->pSync->pTriglist;

    while (pCur)
    {
	if (pCur->pTrigger == pTrigger)
	{
	    if (pPrev)
		pPrev->next = pCur->next;
	    else
		pTrigger->pSync->pTriglist = pCur->next;

	    free(pCur);
	    break;
	}
	
	pPrev = pCur;
	pCur = pCur->next;
    }

    if (SYNC_COUNTER == pTrigger->pSync->type)
    {
	pCounter = (SyncCounter *)pTrigger->pSync;

	if (IsSystemCounter(pCounter))
	    SyncComputeBracketValues(pCounter);
    } else if (SYNC_FENCE == pTrigger->pSync->type) {
	SyncFence* pFence = (SyncFence*) pTrigger->pSync;
	pFence->funcs.DeleteTrigger(pTrigger);
    }
}


static int
SyncAddTriggerToSyncObject(SyncTrigger *pTrigger)
{
    SyncTriggerList *pCur;
    SyncCounter *pCounter;

    if (!pTrigger->pSync)
	return Success;

    /* don't do anything if it's already there */
    for (pCur = pTrigger->pSync->pTriglist; pCur; pCur = pCur->next)
    {
	if (pCur->pTrigger == pTrigger)
	    return Success;
    }

    if (!(pCur = malloc(sizeof(SyncTriggerList))))
	return BadAlloc;

    pCur->pTrigger = pTrigger;
    pCur->next = pTrigger->pSync->pTriglist;
    pTrigger->pSync->pTriglist = pCur;

    if (SYNC_COUNTER == pTrigger->pSync->type)
    {
	pCounter = (SyncCounter *)pTrigger->pSync;

	if (IsSystemCounter(pCounter))
	    SyncComputeBracketValues(pCounter);
    } else if (SYNC_FENCE == pTrigger->pSync->type) {
	SyncFence* pFence = (SyncFence*) pTrigger->pSync;
	pFence->funcs.AddTrigger(pTrigger);
    }

    return Success;
}


/*  Below are five possible functions that can be plugged into
 *  pTrigger->CheckTrigger for counter sync objects, corresponding to
 *  the four possible test-types, and the one possible function that
 *  can be plugged into pTrigger->CheckTrigger for fence sync objects.
 *  These functions are called after the sync object's state changes
 *  but are also passed the old state so they can inspect both the old
 *  and new values.  (PositiveTransition and NegativeTransition need to
 *  see both pieces of information.)  These functions return the truth
 *  value of the trigger.
 *
 *  All of them include the condition pTrigger->pSync == NULL.
 *  This is because the spec says that a trigger with a sync value
 *  of None is always TRUE.
 */

static Bool
SyncCheckTriggerPositiveComparison(SyncTrigger *pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
	return FALSE;

    pCounter = (SyncCounter *)pTrigger->pSync;

    return (pCounter == NULL ||
	    XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value));
}

static Bool
SyncCheckTriggerNegativeComparison(SyncTrigger *pTrigger,  CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
	return FALSE;

    pCounter = (SyncCounter *)pTrigger->pSync;

    return (pCounter == NULL ||
	    XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value));
}

static Bool
SyncCheckTriggerPositiveTransition(SyncTrigger *pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
	return FALSE;

    pCounter = (SyncCounter *)pTrigger->pSync;

    return (pCounter == NULL ||
	    (XSyncValueLessThan(oldval, pTrigger->test_value) &&
	     XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value)));
}

static Bool
SyncCheckTriggerNegativeTransition(SyncTrigger *pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
	return FALSE;

    pCounter = (SyncCounter *)pTrigger->pSync;

    return (pCounter == NULL ||
	    (XSyncValueGreaterThan(oldval, pTrigger->test_value) &&
	     XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value)));
}

static Bool
SyncCheckTriggerFence(SyncTrigger *pTrigger, CARD64 unused)
{
    SyncFence* pFence = (SyncFence*) pTrigger->pSync;
    (void)unused;

    return (pFence == NULL ||
	    pFence->funcs.CheckTriggered(pFence));
}

static int
SyncInitTrigger(ClientPtr client, SyncTrigger *pTrigger, XID syncObject,
		RESTYPE resType, Mask changes)
{
    SyncObject *pSync = pTrigger->pSync;
    SyncCounter *pCounter = NULL;
    int		rc;
    Bool	newSyncObject = FALSE;

    if (changes & XSyncCACounter)
    {
	if (syncObject == None)
	    pSync = NULL;
	else if (Success != (rc = dixLookupResourceByType ((pointer *)&pSync,
				syncObject, resType, client, DixReadAccess)))
	{
	    client->errorValue = syncObject;
	    return rc;
	}
	if (pSync != pTrigger->pSync)
	{ /* new counter for trigger */
	    SyncDeleteTriggerFromSyncObject(pTrigger);
	    pTrigger->pSync = pSync;
	    newSyncObject = TRUE;
	}
    }

    /* if system counter, ask it what the current value is */

    if (pSync && SYNC_COUNTER == pSync->type)
    {
	pCounter = (SyncCounter *)pSync;

	if (IsSystemCounter(pCounter))
	{
	    (*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
						      &pCounter->value);
	}
    }

    if (changes & XSyncCAValueType)
    {
	if (pTrigger->value_type != XSyncRelative &&
	    pTrigger->value_type != XSyncAbsolute)
	{
	    client->errorValue = pTrigger->value_type;
	    return BadValue;
	}
    }

    if (changes & XSyncCATestType)
    {

	if (pSync && SYNC_FENCE == pSync->type)
	{
	    pTrigger->CheckTrigger = SyncCheckTriggerFence;
	}
	else
	{
	    /* select appropriate CheckTrigger function */

	    switch (pTrigger->test_type)
	    {
	    case XSyncPositiveTransition:
		pTrigger->CheckTrigger = SyncCheckTriggerPositiveTransition;
		break;
	    case XSyncNegativeTransition:
		pTrigger->CheckTrigger = SyncCheckTriggerNegativeTransition;
		break;
	    case XSyncPositiveComparison:
		pTrigger->CheckTrigger = SyncCheckTriggerPositiveComparison;
		break;
	    case XSyncNegativeComparison:
		pTrigger->CheckTrigger = SyncCheckTriggerNegativeComparison;
		break;
	    default:
		client->errorValue = pTrigger->test_type;
		return BadValue;
	    }
	}
    }

    if (changes & (XSyncCAValueType | XSyncCAValue))
    {
	if (pTrigger->value_type == XSyncAbsolute)
	    pTrigger->test_value = pTrigger->wait_value;
	else /* relative */
	{
	    Bool overflow;
	    if (pCounter == NULL)
		return BadMatch;

	    XSyncValueAdd(&pTrigger->test_value, pCounter->value,
			  pTrigger->wait_value, &overflow);
	    if (overflow)
	    {
		client->errorValue = XSyncValueHigh32(pTrigger->wait_value);
		return BadValue;
	    }
	}
    }

    /*  we wait until we're sure there are no errors before registering
     *  a new counter on a trigger
     */
    if (newSyncObject)
    {
	if ((rc = SyncAddTriggerToSyncObject(pTrigger)) != Success)
	    return rc;
    }
    else if (pCounter && IsSystemCounter(pCounter))
    {
	SyncComputeBracketValues(pCounter);
    }

    return Success;
}

/*  AlarmNotify events happen in response to actions taken on an Alarm or
 *  the counter used by the alarm.  AlarmNotify may be sent to multiple
 *  clients.  The alarm maintains a list of clients interested in events.
 */
static void
SyncSendAlarmNotifyEvents(SyncAlarm *pAlarm)
{
    SyncAlarmClientList *pcl;
    xSyncAlarmNotifyEvent ane;
    SyncTrigger *pTrigger = &pAlarm->trigger;
    SyncCounter *pCounter;

    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_ALARM))
	return;

    pCounter = (SyncCounter *)pTrigger->pSync;

    UpdateCurrentTime();

    ane.type = SyncEventBase + XSyncAlarmNotify;
    ane.kind = XSyncAlarmNotify;
    ane.alarm = pAlarm->alarm_id;
    if (pTrigger->pSync && SYNC_COUNTER == pTrigger->pSync->type)
    {
	ane.counter_value_hi = XSyncValueHigh32(pCounter->value);
	ane.counter_value_lo = XSyncValueLow32(pCounter->value);
    }
    else
    { /* XXX what else can we do if there's no counter? */
	ane.counter_value_hi = ane.counter_value_lo = 0;
    }

    ane.alarm_value_hi = XSyncValueHigh32(pTrigger->test_value);
    ane.alarm_value_lo = XSyncValueLow32(pTrigger->test_value);
    ane.time = currentTime.milliseconds;
    ane.state = pAlarm->state;

    /* send to owner */
    if (pAlarm->events)
	WriteEventsToClient(pAlarm->client, 1, (xEvent *) &ane);

    /* send to other interested clients */
    for (pcl = pAlarm->pEventClients; pcl; pcl = pcl->next)
	WriteEventsToClient(pcl->client, 1, (xEvent *) &ane);
}


/*  CounterNotify events only occur in response to an Await.  The events
 *  go only to the Awaiting client.
 */
static void
SyncSendCounterNotifyEvents(ClientPtr client, SyncAwait **ppAwait,
			    int num_events)
{
    xSyncCounterNotifyEvent *pEvents, *pev;
    int i;

    if (client->clientGone)
	return;
    pev = pEvents = malloc(num_events * sizeof(xSyncCounterNotifyEvent));
    if (!pEvents)
	return;
    UpdateCurrentTime();
    for (i = 0; i < num_events; i++, ppAwait++, pev++)
    {
	SyncTrigger *pTrigger = &(*ppAwait)->trigger;
	pev->type = SyncEventBase + XSyncCounterNotify;
	pev->kind = XSyncCounterNotify;
	pev->counter = pTrigger->pSync->id;
	pev->wait_value_lo = XSyncValueLow32(pTrigger->test_value);
	pev->wait_value_hi = XSyncValueHigh32(pTrigger->test_value);
	if (SYNC_COUNTER == pTrigger->pSync->type)
	{
	    SyncCounter *pCounter = (SyncCounter *)pTrigger->pSync;

	    pev->counter_value_lo = XSyncValueLow32(pCounter->value);
	    pev->counter_value_hi = XSyncValueHigh32(pCounter->value);
	}
	else
	{
	    pev->counter_value_lo = 0;
	    pev->counter_value_hi = 0;
	}

	pev->time = currentTime.milliseconds;
	pev->count = num_events - i - 1; /* events remaining */
	pev->destroyed = pTrigger->pSync->beingDestroyed;
    }
    /* swapping will be taken care of by this */
    WriteEventsToClient(client, num_events, (xEvent *)pEvents);
    free(pEvents);
}


/* This function is called when an alarm's counter is destroyed.
 * It is plugged into pTrigger->CounterDestroyed (for alarm triggers).
 */
static void
SyncAlarmCounterDestroyed(SyncTrigger *pTrigger)
{
    SyncAlarm *pAlarm = (SyncAlarm *)pTrigger;

    pAlarm->state = XSyncAlarmInactive;
    SyncSendAlarmNotifyEvents(pAlarm);
    pTrigger->pSync = NULL;
}


/*  This function is called when an alarm "goes off."
 *  It is plugged into pTrigger->TriggerFired (for alarm triggers).
 */
static void
SyncAlarmTriggerFired(SyncTrigger *pTrigger)
{
    SyncAlarm *pAlarm = (SyncAlarm *)pTrigger;
    SyncCounter *pCounter;
    CARD64 new_test_value;

    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_ALARM))
	return;

    pCounter = (SyncCounter *)pTrigger->pSync;

    /* no need to check alarm unless it's active */
    if (pAlarm->state != XSyncAlarmActive)
	return;

    /*  " if the counter value is None, or if the delta is 0 and
     *    the test-type is PositiveComparison or NegativeComparison,
     *    no change is made to value (test-value) and the alarm
     *    state is changed to Inactive before the event is generated."
     */
    if (pCounter == NULL
	|| (XSyncValueIsZero(pAlarm->delta)
	    && (pAlarm->trigger.test_type == XSyncPositiveComparison
		|| pAlarm->trigger.test_type == XSyncNegativeComparison)))
	pAlarm->state = XSyncAlarmInactive;

    new_test_value = pAlarm->trigger.test_value;

    if (pAlarm->state == XSyncAlarmActive)
    {
	Bool overflow;
	CARD64 oldvalue;
	SyncTrigger *paTrigger = &pAlarm->trigger;
	SyncCounter *paCounter;

	if (!SyncCheckWarnIsCounter(paTrigger->pSync,
				    WARN_INVALID_COUNTER_ALARM))
	    return;

	paCounter = (SyncCounter *)pTrigger->pSync;

	/* "The alarm is updated by repeatedly adding delta to the
	 *  value of the trigger and re-initializing it until it
	 *  becomes FALSE."
	 */
	oldvalue = paTrigger->test_value;

	/* XXX really should do something smarter here */

	do
	{
	    XSyncValueAdd(&paTrigger->test_value, paTrigger->test_value,
			  pAlarm->delta, &overflow);
	} while (!overflow &&
	      (*paTrigger->CheckTrigger)(paTrigger,
					paCounter->value));

	new_test_value = paTrigger->test_value;
	paTrigger->test_value = oldvalue;

	/* "If this update would cause value to fall outside the range
	 *  for an INT64...no change is made to value (test-value) and
	 *  the alarm state is changed to Inactive before the event is
	 *  generated."
	 */
	if (overflow)
	{
	    new_test_value = oldvalue;
	    pAlarm->state = XSyncAlarmInactive;
	}
    }
    /*  The AlarmNotify event has to have the "new state of the alarm"
     *  which we can't be sure of until this point.  However, it has
     *  to have the "old" trigger test value.  That's the reason for
     *  all the newvalue/oldvalue shuffling above.  After we send the
     *  events, give the trigger its new test value.
     */
    SyncSendAlarmNotifyEvents(pAlarm);
    pTrigger->test_value = new_test_value;
}


/*  This function is called when an Await unblocks, either as a result
 *  of the trigger firing OR the counter being destroyed.
 *  It goes into pTrigger->TriggerFired AND pTrigger->CounterDestroyed
 *  (for Await triggers).
 */
static void
SyncAwaitTriggerFired(SyncTrigger *pTrigger)
{
    SyncAwait *pAwait = (SyncAwait *)pTrigger;
    int numwaits;
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait **ppAwait;
    int num_events = 0;

    pAwaitUnion = (SyncAwaitUnion *)pAwait->pHeader;
    numwaits = pAwaitUnion->header.num_waitconditions;
    ppAwait = malloc(numwaits * sizeof(SyncAwait *));
    if (!ppAwait)
	goto bail;

    pAwait = &(pAwaitUnion+1)->await;

    /* "When a client is unblocked, all the CounterNotify events for
     *  the Await request are generated contiguously. If count is 0
     *  there are no more events to follow for this request. If
     *  count is n, there are at least n more events to follow."
     *
     *  Thus, it is best to find all the counters for which events
     *  need to be sent first, so that an accurate count field can
     *  be stored in the events.
     */
    for ( ; numwaits; numwaits--, pAwait++)
    {
	CARD64 diff;
	Bool overflow, diffgreater, diffequal;

	/* "A CounterNotify event with the destroyed flag set to TRUE is
	 *  always generated if the counter for one of the triggers is
	 *  destroyed."
	 */
	if (pAwait->trigger.pSync->beingDestroyed)
	{
	    ppAwait[num_events++] = pAwait;
	    continue;
	}
	
	if (SYNC_COUNTER == pAwait->trigger.pSync->type)
	{
	    SyncCounter *pCounter = (SyncCounter *) pAwait->trigger.pSync;

	    /* "The difference between the counter and the test value is
	     *  calculated by subtracting the test value from the value of
	     *  the counter."
	     */
	    XSyncValueSubtract(&diff, pCounter->value,
			       pAwait->trigger.test_value, &overflow);

	    /* "If the difference lies outside the range for an INT64, an
	     *  event is not generated."
	     */
	    if (overflow)
		continue;
	    diffgreater = XSyncValueGreaterThan(diff, pAwait->event_threshold);
	    diffequal   = XSyncValueEqual(diff, pAwait->event_threshold);

	    /* "If the test-type is PositiveTransition or
	     *  PositiveComparison, a CounterNotify event is generated if
	     *  the difference is at least event-threshold. If the test-type
	     *  is NegativeTransition or NegativeComparison, a CounterNotify
	     *  event is generated if the difference is at most
	     *  event-threshold."
	     */

	    if ( ((pAwait->trigger.test_type == XSyncPositiveComparison ||
		   pAwait->trigger.test_type == XSyncPositiveTransition)
		  && (diffgreater || diffequal))
		 ||
		 ((pAwait->trigger.test_type == XSyncNegativeComparison ||
		   pAwait->trigger.test_type == XSyncNegativeTransition)
		  && (!diffgreater) /* less or equal */
		 )
	       )
	    {
		ppAwait[num_events++] = pAwait;
	    }
	}
    }
    if (num_events)
	SyncSendCounterNotifyEvents(pAwaitUnion->header.client, ppAwait,
				    num_events);
    free(ppAwait);

bail:
    /* unblock the client */
    AttendClient(pAwaitUnion->header.client);
    /* delete the await */
    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
}


/*  This function should always be used to change a counter's value so that
 *  any triggers depending on the counter will be checked.
 */
void
SyncChangeCounter(SyncCounter *pCounter, CARD64 newval)
{
    SyncTriggerList       *ptl, *pnext;
    CARD64 oldval;

    oldval = pCounter->value;
    pCounter->value = newval;

    /* run through triggers to see if any become true */
    for (ptl = pCounter->sync.pTriglist; ptl; ptl = pnext)
    {
	pnext = ptl->next;
	if ((*ptl->pTrigger->CheckTrigger)(ptl->pTrigger, oldval))
	    (*ptl->pTrigger->TriggerFired)(ptl->pTrigger);
    }

    if (IsSystemCounter(pCounter))
    {
	SyncComputeBracketValues(pCounter);
    }
}


/* loosely based on dix/events.c/EventSelectForWindow */
static Bool
SyncEventSelectForAlarm(SyncAlarm *pAlarm, ClientPtr client, Bool wantevents)
{
    SyncAlarmClientList *pClients;

    if (client == pAlarm->client) /* alarm owner */
    {
	pAlarm->events = wantevents;
	return Success;
    }

    /* see if the client is already on the list (has events selected) */

    for (pClients = pAlarm->pEventClients; pClients;
	 pClients = pClients->next)
    {
	if (pClients->client == client)
	{
	    /* client's presence on the list indicates desire for
	     * events.  If the client doesn't want events, remove it
	     * from the list.  If the client does want events, do
	     * nothing, since it's already got them.
	     */
	    if (!wantevents)
	    {
		FreeResource(pClients->delete_id, RT_NONE);
	    }
	    return Success;
	}
    }

    /*  if we get here, this client does not currently have
     *  events selected on the alarm
     */

    if (!wantevents)
	/* client doesn't want events, and we just discovered that it
	 * doesn't have them, so there's nothing to do.
	 */
	return Success;

    /* add new client to pAlarm->pEventClients */

    pClients = malloc(sizeof(SyncAlarmClientList));
    if (!pClients)
	return BadAlloc;

    /*  register it as a resource so it will be cleaned up
     *  if the client dies
     */

    pClients->delete_id = FakeClientID(client->index);

    /* link it into list after we know all the allocations succeed */
    pClients->next = pAlarm->pEventClients;
    pAlarm->pEventClients = pClients;
    pClients->client = client;

    if (!AddResource(pClients->delete_id, RTAlarmClient, pAlarm))
	return BadAlloc;

    return Success;
}

/*
 * ** SyncChangeAlarmAttributes ** This is used by CreateAlarm and ChangeAlarm
 */
static int
SyncChangeAlarmAttributes(ClientPtr client, SyncAlarm *pAlarm, Mask mask,
			  CARD32 *values)
{
    int		   status;
    XSyncCounter   counter;
    Mask	   origmask = mask;

    counter =
	pAlarm->trigger.pSync ? pAlarm->trigger.pSync->id : None;

    while (mask)
    {
	int    index2 = lowbit(mask);
	mask &= ~index2;
	switch (index2)
	{
	  case XSyncCACounter:
	    mask &= ~XSyncCACounter;
	    /* sanity check in SyncInitTrigger */
	    counter = *values++;
	    break;

	  case XSyncCAValueType:
	    mask &= ~XSyncCAValueType;
	    /* sanity check in SyncInitTrigger */
	    pAlarm->trigger.value_type = *values++;
	    break;

	  case XSyncCAValue:
	    mask &= ~XSyncCAValue;
	    XSyncIntsToValue(&pAlarm->trigger.wait_value, values[1], values[0]);
	    values += 2;
	    break;

	  case XSyncCATestType:
	    mask &= ~XSyncCATestType;
	    /* sanity check in SyncInitTrigger */
	    pAlarm->trigger.test_type = *values++;
	    break;

	  case XSyncCADelta:
	    mask &= ~XSyncCADelta;
	    XSyncIntsToValue(&pAlarm->delta, values[1], values[0]);
	    values += 2;
	    break;

	  case XSyncCAEvents:
	    mask &= ~XSyncCAEvents;
	    if ((*values != xTrue) && (*values != xFalse))
	    {
		client->errorValue = *values;
		return BadValue;
	    }
	    status = SyncEventSelectForAlarm(pAlarm, client,
					     (Bool)(*values++));
	    if (status != Success)
		return status;
	    break;

	  default:
	    client->errorValue = mask;
	    return BadValue;
	}
    }

    /* "If the test-type is PositiveComparison or PositiveTransition
     *  and delta is less than zero, or if the test-type is
     *  NegativeComparison or NegativeTransition and delta is
     *  greater than zero, a Match error is generated."
     */
    if (origmask & (XSyncCADelta|XSyncCATestType))
    {
	CARD64 zero;
	XSyncIntToValue(&zero, 0);
	if ((((pAlarm->trigger.test_type == XSyncPositiveComparison) ||
	      (pAlarm->trigger.test_type == XSyncPositiveTransition))
	     && XSyncValueLessThan(pAlarm->delta, zero))
	    ||
	    (((pAlarm->trigger.test_type == XSyncNegativeComparison) ||
	      (pAlarm->trigger.test_type == XSyncNegativeTransition))
	     && XSyncValueGreaterThan(pAlarm->delta, zero))
	   )
	{
	    return BadMatch;
	}
    }

    /* postpone this until now, when we're sure nothing else can go wrong */
    if ((status = SyncInitTrigger(client, &pAlarm->trigger, counter, RTCounter,
			     origmask & XSyncCAAllTrigger)) != Success)
	return status;

    /* XXX spec does not really say to do this - needs clarification */
    pAlarm->state = XSyncAlarmActive;
    return Success;
}

static SyncObject *
SyncCreate(ClientPtr client, XID id, unsigned char type)
{
    SyncObject *pSync;

    switch (type) {
    case SYNC_COUNTER:
	pSync = malloc(sizeof(SyncCounter));
	break;
    case SYNC_FENCE:
	pSync = (SyncObject*)dixAllocateObjectWithPrivates(SyncFence,
							   PRIVATE_SYNC_FENCE);
	break;
    default:
	return NULL;
    }

    if (!pSync)
	return NULL;

    pSync->client = client;
    pSync->id = id;
    pSync->pTriglist = NULL;
    pSync->beingDestroyed = FALSE;
    pSync->type = type;

    return pSync;
}


static SyncCounter *
SyncCreateCounter(ClientPtr client, XSyncCounter id, CARD64 initialvalue)
{
    SyncCounter *pCounter;

    if (!(pCounter = (SyncCounter *)SyncCreate(client,
					       id,
					       SYNC_COUNTER)))
	return NULL;

    pCounter->value = initialvalue;
    pCounter->pSysCounterInfo = NULL;

    if (!AddResource(id, RTCounter, (pointer) pCounter))
	return NULL;

    return pCounter;
}

static int FreeCounter(void *, XID);

/*
 * ***** System Counter utilities
 */

pointer
SyncCreateSystemCounter(
	char *name,
	CARD64 initial,
	CARD64 resolution,
	SyncCounterType counterType,
	void (*QueryValue)(pointer /* pCounter */,
	      	           CARD64 * /* pValue_return */),
	void (*BracketValues)(pointer /* pCounter */,
	       	              CARD64 * /* pbracket_less */,
	                      CARD64 * /* pbracket_greater */)
	)
{
    SyncCounter    *pCounter;

    SysCounterList = realloc(SysCounterList,
			    (SyncNumSystemCounters+1)*sizeof(SyncCounter *));
    if (!SysCounterList)
	return NULL;

    /* this function may be called before SYNC has been initialized, so we
     * have to make sure RTCounter is created.
     */
    if (RTCounter == 0)
    {
	RTCounter = CreateNewResourceType(FreeCounter, "SyncCounter");
	if (RTCounter == 0)
	{
	    return NULL;
	}
    }

    pCounter = SyncCreateCounter(NULL, FakeClientID(0), initial);

    if (pCounter)
    {
	SysCounterInfo *psci;

	psci = malloc(sizeof(SysCounterInfo));
	if (!psci)
	{
	    FreeResource(pCounter->sync.id, RT_NONE);
	    return pCounter;
	}
	pCounter->pSysCounterInfo = psci;
	psci->name = name;
	psci->resolution = resolution;
	psci->counterType = counterType;
	psci->QueryValue = QueryValue;
	psci->BracketValues = BracketValues;
	XSyncMaxValue(&psci->bracket_greater);
	XSyncMinValue(&psci->bracket_less);
	SysCounterList[SyncNumSystemCounters++] = pCounter;
    }
    return pCounter;
}

void
SyncDestroySystemCounter(pointer pSysCounter)
{
    SyncCounter *pCounter = (SyncCounter *)pSysCounter;
    FreeResource(pCounter->sync.id, RT_NONE);
}

static void
SyncComputeBracketValues(SyncCounter *pCounter)
{
    SyncTriggerList *pCur;
    SyncTrigger *pTrigger;
    SysCounterInfo *psci;
    CARD64 *pnewgtval = NULL;
    CARD64 *pnewltval = NULL;
    SyncCounterType ct;

    if (!pCounter)
	return;

    psci = pCounter->pSysCounterInfo;
    ct = pCounter->pSysCounterInfo->counterType;
    if (ct == XSyncCounterNeverChanges)
	return;

    XSyncMaxValue(&psci->bracket_greater);
    XSyncMinValue(&psci->bracket_less);

    for (pCur = pCounter->sync.pTriglist; pCur; pCur = pCur->next)
    {
	pTrigger = pCur->pTrigger;
	
        if (pTrigger->test_type == XSyncPositiveComparison &&
	    ct != XSyncCounterNeverIncreases)
	{
	    if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueLessThan(pTrigger->test_value,
				   psci->bracket_greater))
	    {
		psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    }
	}
	else if (pTrigger->test_type == XSyncNegativeComparison &&
		 ct != XSyncCounterNeverDecreases)
	{
	    if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueGreaterThan(pTrigger->test_value,
				      psci->bracket_less))
	    {
		psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    }
	}
	else if (pTrigger->test_type == XSyncNegativeTransition &&
		   ct != XSyncCounterNeverIncreases)
	{
	    if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueGreaterThan(pTrigger->test_value, psci->bracket_less))
	    {
		psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    } else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
		       XSyncValueLessThan(pTrigger->test_value,
					  psci->bracket_greater))
	    {
	        /*
		 * The value is exactly equal to our threshold.  We want one
		 * more event in the positive direction to ensure we pick up
		 * when the value *exceeds* this threshold.
		 */
	        psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    }
	}
        else if (pTrigger->test_type == XSyncPositiveTransition &&
		  ct != XSyncCounterNeverDecreases)
	{
	    if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueLessThan(pTrigger->test_value, psci->bracket_greater))
	    {
		psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    } else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
		       XSyncValueGreaterThan(pTrigger->test_value,
					     psci->bracket_less))
	    {
	        /*
		 * The value is exactly equal to our threshold.  We want one
		 * more event in the negative direction to ensure we pick up
		 * when the value is less than this threshold.
		 */
	        psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    }
	}
    } /* end for each trigger */

    if (pnewgtval || pnewltval)
    {
	(*psci->BracketValues)((pointer)pCounter, pnewltval, pnewgtval);
    }
}

/*
 * *****  Resource delete functions
 */

/* ARGSUSED */
static int
FreeAlarm(void *addr, XID id)
{
    SyncAlarm      *pAlarm = (SyncAlarm *) addr;

    pAlarm->state = XSyncAlarmDestroyed;

    SyncSendAlarmNotifyEvents(pAlarm);

    /* delete event selections */

    while (pAlarm->pEventClients)
	FreeResource(pAlarm->pEventClients->delete_id, RT_NONE);

    SyncDeleteTriggerFromSyncObject(&pAlarm->trigger);

    free(pAlarm);
    return Success;
}


/*
 * ** Cleanup after the destruction of a Counter
 */
/* ARGSUSED */
static int
FreeCounter(void *env, XID id)
{
    SyncCounter     *pCounter = (SyncCounter *) env;
    SyncTriggerList *ptl, *pnext;

    pCounter->sync.beingDestroyed = TRUE;
    /* tell all the counter's triggers that the counter has been destroyed */
    for (ptl = pCounter->sync.pTriglist; ptl; ptl = pnext)
    {
	(*ptl->pTrigger->CounterDestroyed)(ptl->pTrigger);
	pnext = ptl->next;
	free(ptl); /* destroy the trigger list as we go */
    }
    if (IsSystemCounter(pCounter))
    {
	int i, found = 0;

	free(pCounter->pSysCounterInfo);

	/* find the counter in the list of system counters and remove it */

	if (SysCounterList)
	{
	    for (i = 0; i < SyncNumSystemCounters; i++)
	    {
		if (SysCounterList[i] == pCounter)
		{
		    found = i;
		    break;
		}
	    }
	    if (found < (SyncNumSystemCounters-1))
	    {
		for (i = found; i < SyncNumSystemCounters-1; i++)
		{
		    SysCounterList[i] = SysCounterList[i+1];
		}
	    }
	}
	SyncNumSystemCounters--;
    }
    free(pCounter);
    return Success;
}

/*
 * ** Cleanup after Await
 */
/* ARGSUSED */
static int
FreeAwait(void *addr, XID id)
{
    SyncAwaitUnion *pAwaitUnion = (SyncAwaitUnion *) addr;
    SyncAwait *pAwait;
    int numwaits;

    pAwait = &(pAwaitUnion+1)->await; /* first await on list */

    /* remove triggers from counters */

    for (numwaits = pAwaitUnion->header.num_waitconditions; numwaits;
	 numwaits--, pAwait++)
    {
	/* If the counter is being destroyed, FreeCounter will delete
	 * the trigger list itself, so don't do it here.
	 */
	SyncObject *pSync = pAwait->trigger.pSync;
	if (pSync && !pSync->beingDestroyed)
	    SyncDeleteTriggerFromSyncObject(&pAwait->trigger);
    }
    free(pAwaitUnion);
    return Success;
}

/* loosely based on dix/events.c/OtherClientGone */
static int
FreeAlarmClient(void *value, XID id)
{
    SyncAlarm *pAlarm = (SyncAlarm *)value;
    SyncAlarmClientList *pCur, *pPrev;

    for (pPrev = NULL, pCur = pAlarm->pEventClients;
	 pCur;
	 pPrev = pCur, pCur = pCur->next)
    {
	if (pCur->delete_id == id)
	{
	    if (pPrev)
		pPrev->next = pCur->next;
	    else
		pAlarm->pEventClients = pCur->next;
	    free(pCur);
	    return Success;
	}
    }
    FatalError("alarm client not on event list");
    /*NOTREACHED*/
}


/*
 * *****  Proc functions
 */


/*
 * ** Initialize the extension
 */
static int
ProcSyncInitialize(ClientPtr client)
{
    xSyncInitializeReply  rep;
    int   n;

    REQUEST_SIZE_MATCH(xSyncInitializeReq);

    memset(&rep, 0, sizeof(xSyncInitializeReply));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SYNC_MAJOR_VERSION;
    rep.minorVersion = SERVER_SYNC_MINOR_VERSION;
    rep.length = 0;

    if (client->swapped)
    {
	swaps(&rep.sequenceNumber, n);
    }
    WriteToClient(client, sizeof(rep), (char *) &rep);
    return Success;
}

/*
 * ** Get list of system counters available through the extension
 */
static int
ProcSyncListSystemCounters(ClientPtr client)
{
    xSyncListSystemCountersReply  rep;
    int i, len;
    xSyncSystemCounter *list = NULL, *walklist = NULL;

    REQUEST_SIZE_MATCH(xSyncListSystemCountersReq);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.nCounters = SyncNumSystemCounters;

    for (i = len = 0; i < SyncNumSystemCounters; i++)
    {
	char *name = SysCounterList[i]->pSysCounterInfo->name;
	/* pad to 4 byte boundary */
	len += pad_to_int32(sz_xSyncSystemCounter + strlen(name));
    }

    if (len)
    {
	walklist = list = malloc(len);
	if (!list)
	    return BadAlloc;
    }

    rep.length = bytes_to_int32(len);

    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.nCounters, n);
    }

    for (i = 0; i < SyncNumSystemCounters; i++)
    {
	int namelen;
	char *pname_in_reply;
	SysCounterInfo *psci = SysCounterList[i]->pSysCounterInfo;

	walklist->counter = SysCounterList[i]->sync.id;
	walklist->resolution_hi = XSyncValueHigh32(psci->resolution);
	walklist->resolution_lo = XSyncValueLow32(psci->resolution);
	namelen = strlen(psci->name);
	walklist->name_length = namelen;

	if (client->swapped)
	{
	    char n;
	    swapl(&walklist->counter, n);
	    swapl(&walklist->resolution_hi, n);
	    swapl(&walklist->resolution_lo, n);
	    swaps(&walklist->name_length, n);
	}

	pname_in_reply = ((char *)walklist) + sz_xSyncSystemCounter;
	strncpy(pname_in_reply, psci->name, namelen);
	walklist = (xSyncSystemCounter *) (((char *)walklist) +
				pad_to_int32(sz_xSyncSystemCounter + namelen));
    }

    WriteToClient(client, sizeof(rep), (char *) &rep);
    if (len)
    {
	WriteToClient(client, len, (char *) list);
	free(list);
    }

    return Success;
}

/*
 * ** Set client Priority
 */
static int
ProcSyncSetPriority(ClientPtr client)
{
    REQUEST(xSyncSetPriorityReq);
    ClientPtr priorityclient;
    int rc;

    REQUEST_SIZE_MATCH(xSyncSetPriorityReq);

    if (stuff->id == None)
	priorityclient = client;
    else {
	rc = dixLookupClient(&priorityclient, stuff->id, client,
			     DixSetAttrAccess);
	if (rc != Success)
	    return rc;
    }

    if (priorityclient->priority != stuff->priority)
    {
	priorityclient->priority = stuff->priority;

	/*  The following will force the server back into WaitForSomething
	 *  so that the change in this client's priority is immediately
	 *  reflected.
	 */
	isItTimeToYield = TRUE;
	dispatchException |= DE_PRIORITYCHANGE;
    }
    return Success;
}

/*
 * ** Get client Priority
 */
static int
ProcSyncGetPriority(ClientPtr client)
{
    REQUEST(xSyncGetPriorityReq);
    xSyncGetPriorityReply rep;
    ClientPtr priorityclient;
    int rc;

    REQUEST_SIZE_MATCH(xSyncGetPriorityReq);

    if (stuff->id == None)
	priorityclient = client;
    else {
	rc = dixLookupClient(&priorityclient, stuff->id, client,
			     DixGetAttrAccess);
	if (rc != Success)
	    return rc;
    }

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.priority = priorityclient->priority;

    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.priority, n);
    }

    WriteToClient(client, sizeof(xSyncGetPriorityReply), (char *) &rep);

    return Success;
}

/*
 * ** Create a new counter
 */
static int
ProcSyncCreateCounter(ClientPtr client)
{
    REQUEST(xSyncCreateCounterReq);
    CARD64          initial;

    REQUEST_SIZE_MATCH(xSyncCreateCounterReq);

    LEGAL_NEW_RESOURCE(stuff->cid, client);

    XSyncIntsToValue(&initial, stuff->initial_value_lo, stuff->initial_value_hi);
    if (!SyncCreateCounter(client, stuff->cid, initial))
	return BadAlloc;

    return Success;
}

/*
 * ** Set Counter value
 */
static int
ProcSyncSetCounter(ClientPtr client)
{
    REQUEST(xSyncSetCounterReq);
    SyncCounter    *pCounter;
    CARD64	   newvalue;
    int	rc;

    REQUEST_SIZE_MATCH(xSyncSetCounterReq);

    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->cid, RTCounter,
				 client, DixWriteAccess);
    if (rc != Success)
	return rc;

    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->cid;
	return BadAccess;
    }

    XSyncIntsToValue(&newvalue, stuff->value_lo, stuff->value_hi);
    SyncChangeCounter(pCounter, newvalue);
    return Success;
}

/*
 * ** Change Counter value
 */
static int
ProcSyncChangeCounter(ClientPtr client)
{
    REQUEST(xSyncChangeCounterReq);
    SyncCounter    *pCounter;
    CARD64          newvalue;
    Bool	    overflow;
    int	rc;

    REQUEST_SIZE_MATCH(xSyncChangeCounterReq);

    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->cid, RTCounter,
				 client, DixWriteAccess);
    if (rc != Success)
	return rc;

    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->cid;
	return BadAccess;
    }

    XSyncIntsToValue(&newvalue, stuff->value_lo, stuff->value_hi);
    XSyncValueAdd(&newvalue, pCounter->value, newvalue, &overflow);
    if (overflow)
    {
	/* XXX 64 bit value can't fit in 32 bits; do the best we can */
	client->errorValue = stuff->value_hi;
	return BadValue;
    }
    SyncChangeCounter(pCounter, newvalue);
    return Success;
}

/*
 * ** Destroy a counter
 */
static int
ProcSyncDestroyCounter(ClientPtr client)
{
    REQUEST(xSyncDestroyCounterReq);
    SyncCounter    *pCounter;
    int rc;

    REQUEST_SIZE_MATCH(xSyncDestroyCounterReq);

    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->counter, RTCounter,
				 client, DixDestroyAccess);
    if (rc != Success)
	return rc;

    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->counter;
	return BadAccess;
    }
    FreeResource(pCounter->sync.id, RT_NONE);
    return Success;
}

static SyncAwaitUnion*
SyncAwaitPrologue(ClientPtr client, int items)
{
    SyncAwaitUnion *pAwaitUnion;

    /*  all the memory for the entire await list is allocated
     *  here in one chunk
     */
    pAwaitUnion = malloc((items+1) * sizeof(SyncAwaitUnion));
    if (!pAwaitUnion)
	return NULL;

    /* first item is the header, remainder are real wait conditions */

    pAwaitUnion->header.delete_id = FakeClientID(client->index);
    pAwaitUnion->header.client = client;
    pAwaitUnion->header.num_waitconditions = 0;

    if (!AddResource(pAwaitUnion->header.delete_id, RTAwait, pAwaitUnion))
	return NULL;

    return pAwaitUnion;
}

static void
SyncAwaitEpilogue(ClientPtr client, int items, SyncAwaitUnion *pAwaitUnion)
{
    SyncAwait *pAwait;
    int i;

    IgnoreClient(client);

    /* see if any of the triggers are already true */

    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pAwait++)
    {
	CARD64 value;

	/*  don't have to worry about NULL counters because the request
	 *  errors before we get here out if they occur
	 */
	switch (pAwait->trigger.pSync->type) {
	case SYNC_COUNTER:
	    value = ((SyncCounter *)pAwait->trigger.pSync)->value;
	    break;
	default:
	    XSyncIntToValue(&value, 0);
	}

	if ((*pAwait->trigger.CheckTrigger)(&pAwait->trigger, value))
	{
	    (*pAwait->trigger.TriggerFired)(&pAwait->trigger);
	    break; /* once is enough */
	}
    }
}

/*
 * ** Await
 */
static int
ProcSyncAwait(ClientPtr client)
{
    REQUEST(xSyncAwaitReq);
    int             len, items;
    int             i;
    xSyncWaitCondition *pProtocolWaitConds;
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait	   *pAwait;
    int		   status;

    REQUEST_AT_LEAST_SIZE(xSyncAwaitReq);

    len = client->req_len << 2;
    len -= sz_xSyncAwaitReq;
    items = len / sz_xSyncWaitCondition;

    if (items * sz_xSyncWaitCondition != len)
    {
	return BadLength;
    }
    if (items == 0)
    {
	client->errorValue = items; /* XXX protocol change */
	return BadValue;
    }

    if (!(pAwaitUnion = SyncAwaitPrologue(client, items)))
	return BadAlloc;

    /* don't need to do any more memory allocation for this request! */

    pProtocolWaitConds = (xSyncWaitCondition *) & stuff[1];

    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pProtocolWaitConds++, pAwait++)
    {
	if (pProtocolWaitConds->counter == None) /* XXX protocol change */
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    client->errorValue = pProtocolWaitConds->counter;
	    return SyncErrorBase + XSyncBadCounter;
	}

	/* sanity checks are in SyncInitTrigger */
	pAwait->trigger.pSync = NULL;
	pAwait->trigger.value_type = pProtocolWaitConds->value_type;
	XSyncIntsToValue(&pAwait->trigger.wait_value,
			 pProtocolWaitConds->wait_value_lo,
			 pProtocolWaitConds->wait_value_hi);
	pAwait->trigger.test_type = pProtocolWaitConds->test_type;

	status = SyncInitTrigger(client, &pAwait->trigger,
				 pProtocolWaitConds->counter, RTCounter,
				 XSyncCAAllTrigger);
	if (status != Success)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    return status;
	}
	/* this is not a mistake -- same function works for both cases */
	pAwait->trigger.TriggerFired = SyncAwaitTriggerFired;
	pAwait->trigger.CounterDestroyed = SyncAwaitTriggerFired;
	XSyncIntsToValue(&pAwait->event_threshold,
			 pProtocolWaitConds->event_threshold_lo,
			 pProtocolWaitConds->event_threshold_hi);
	pAwait->pHeader = &pAwaitUnion->header;
	pAwaitUnion->header.num_waitconditions++;
    }

    SyncAwaitEpilogue(client, items, pAwaitUnion);

    return Success;
}


/*
 * ** Query a counter
 */
static int
ProcSyncQueryCounter(ClientPtr client)
{
    REQUEST(xSyncQueryCounterReq);
    xSyncQueryCounterReply rep;
    SyncCounter    *pCounter;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryCounterReq);

    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->counter,
				 RTCounter, client, DixReadAccess);
    if (rc != Success)
	return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    /* if system counter, ask it what the current value is */

    if (IsSystemCounter(pCounter))
    {
	(*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
						  &pCounter->value);
    }

    rep.value_hi = XSyncValueHigh32(pCounter->value);
    rep.value_lo = XSyncValueLow32(pCounter->value);
    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.value_hi, n);
	swapl(&rep.value_lo, n);
    }
    WriteToClient(client, sizeof(xSyncQueryCounterReply), (char *) &rep);
    return Success;
}


/*
 * ** Create Alarm
 */
static int
ProcSyncCreateAlarm(ClientPtr client)
{
    REQUEST(xSyncCreateAlarmReq);
    SyncAlarm      *pAlarm;
    int             status;
    unsigned long   len, vmask;
    SyncTrigger	    *pTrigger;

    REQUEST_AT_LEAST_SIZE(xSyncCreateAlarmReq);

    LEGAL_NEW_RESOURCE(stuff->id, client);

    vmask = stuff->valueMask;
    len = client->req_len - bytes_to_int32(sizeof(xSyncCreateAlarmReq));
    /* the "extra" call to Ones accounts for the presence of 64 bit values */
    if (len != (Ones(vmask) + Ones(vmask & (XSyncCAValue|XSyncCADelta))))
	return BadLength;

    if (!(pAlarm = malloc(sizeof(SyncAlarm))))
    {
	return BadAlloc;
    }

    /* set up defaults */

    pTrigger = &pAlarm->trigger;
    pTrigger->pSync = NULL;
    pTrigger->value_type = XSyncAbsolute;
    XSyncIntToValue(&pTrigger->wait_value, 0L);
    pTrigger->test_type = XSyncPositiveComparison;
    pTrigger->TriggerFired = SyncAlarmTriggerFired;
    pTrigger->CounterDestroyed = SyncAlarmCounterDestroyed;
    status = SyncInitTrigger(client, pTrigger, None, RTCounter,
			     XSyncCAAllTrigger);
    if (status != Success)
    {
	free(pAlarm);
	return status;
    }

    pAlarm->client = client;
    pAlarm->alarm_id = stuff->id;
    XSyncIntToValue(&pAlarm->delta, 1L);
    pAlarm->events = TRUE;
    pAlarm->state = XSyncAlarmInactive;
    pAlarm->pEventClients = NULL;
    status = SyncChangeAlarmAttributes(client, pAlarm, vmask,
				       (CARD32 *)&stuff[1]);
    if (status != Success)
    {
	free(pAlarm);
	return status;
    }

    if (!AddResource(stuff->id, RTAlarm, pAlarm))
	return BadAlloc;

    /*  see if alarm already triggered.  NULL counter will not trigger
     *  in CreateAlarm and sets alarm state to Inactive.
     */

    if (!pTrigger->pSync)
    {
	pAlarm->state = XSyncAlarmInactive; /* XXX protocol change */
    }
    else
    {
	SyncCounter *pCounter;

	if (!SyncCheckWarnIsCounter(pTrigger->pSync,
				    WARN_INVALID_COUNTER_ALARM))
	{
	    FreeResource(stuff->id, RT_NONE);
	    return BadAlloc;
	}

	pCounter = (SyncCounter *)pTrigger->pSync;

	if ((*pTrigger->CheckTrigger)(pTrigger, pCounter->value))
	    (*pTrigger->TriggerFired)(pTrigger);
    }

    return Success;
}

/*
 * ** Change Alarm
 */
static int
ProcSyncChangeAlarm(ClientPtr client)
{
    REQUEST(xSyncChangeAlarmReq);
    SyncAlarm   *pAlarm;
    SyncCounter *pCounter = NULL;
    long        vmask;
    int         len, status;

    REQUEST_AT_LEAST_SIZE(xSyncChangeAlarmReq);

    status = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				     client, DixWriteAccess);
    if (status != Success)
	return status;

    vmask = stuff->valueMask;
    len = client->req_len - bytes_to_int32(sizeof(xSyncChangeAlarmReq));
    /* the "extra" call to Ones accounts for the presence of 64 bit values */
    if (len != (Ones(vmask) + Ones(vmask & (XSyncCAValue|XSyncCADelta))))
	return BadLength;

    if ((status = SyncChangeAlarmAttributes(client, pAlarm, vmask,
					    (CARD32 *)&stuff[1])) != Success)
	return status;

    if (SyncCheckWarnIsCounter(pAlarm->trigger.pSync,
			       WARN_INVALID_COUNTER_ALARM))
	pCounter = (SyncCounter *)pAlarm->trigger.pSync;

    /*  see if alarm already triggered.  NULL counter WILL trigger
     *  in ChangeAlarm.
     */

    if (!pCounter ||
	(*pAlarm->trigger.CheckTrigger)(&pAlarm->trigger, pCounter->value))
    {
	(*pAlarm->trigger.TriggerFired)(&pAlarm->trigger);
    }
    return Success;
}

static int
ProcSyncQueryAlarm(ClientPtr client)
{
    REQUEST(xSyncQueryAlarmReq);
    SyncAlarm      *pAlarm;
    xSyncQueryAlarmReply rep;
    SyncTrigger    *pTrigger;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryAlarmReq);

    rc = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				 client, DixReadAccess);
    if (rc != Success)
	return rc;

    rep.type = X_Reply;
    rep.length = bytes_to_int32(sizeof(xSyncQueryAlarmReply) - sizeof(xGenericReply));
    rep.sequenceNumber = client->sequence;

    pTrigger = &pAlarm->trigger;
    rep.counter = (pTrigger->pSync) ? pTrigger->pSync->id : None;

#if 0 /* XXX unclear what to do, depends on whether relative value-types
       * are "consumed" immediately and are considered absolute from then
       * on.
       */
    rep.value_type = pTrigger->value_type;
    rep.wait_value_hi = XSyncValueHigh32(pTrigger->wait_value);
    rep.wait_value_lo = XSyncValueLow32(pTrigger->wait_value);
#else
    rep.value_type = XSyncAbsolute;
    rep.wait_value_hi = XSyncValueHigh32(pTrigger->test_value);
    rep.wait_value_lo = XSyncValueLow32(pTrigger->test_value);
#endif

    rep.test_type = pTrigger->test_type;
    rep.delta_hi = XSyncValueHigh32(pAlarm->delta);
    rep.delta_lo = XSyncValueLow32(pAlarm->delta);
    rep.events = pAlarm->events;
    rep.state = pAlarm->state;

    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.counter, n);
	swapl(&rep.wait_value_hi, n);
	swapl(&rep.wait_value_lo, n);
	swapl(&rep.test_type, n);
	swapl(&rep.delta_hi, n);
	swapl(&rep.delta_lo, n);
    }

    WriteToClient(client, sizeof(xSyncQueryAlarmReply), (char *) &rep);
    return Success;
}

static int
ProcSyncDestroyAlarm(ClientPtr client)
{
    SyncAlarm *pAlarm;
    int rc;
    REQUEST(xSyncDestroyAlarmReq);

    REQUEST_SIZE_MATCH(xSyncDestroyAlarmReq);

    rc = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				 client, DixDestroyAccess);
    if (rc != Success)
	return rc;

    FreeResource(stuff->alarm, RT_NONE);
    return Success;
}

static int
ProcSyncCreateFence(ClientPtr client)
{
    REQUEST(xSyncCreateFenceReq);
    DrawablePtr pDraw;
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncCreateFenceReq);

    rc = dixLookupDrawable(&pDraw, stuff->d, client, M_ANY, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    LEGAL_NEW_RESOURCE(stuff->fid, client);

    if (!(pFence = (SyncFence *)SyncCreate(client,
					   stuff->fid,
					   SYNC_FENCE)))
	return BadAlloc;

    miSyncInitFence(pDraw->pScreen, pFence, stuff->initially_triggered);

    if (!AddResource(stuff->fid, RTFence, (pointer) pFence))
	return BadAlloc;

    return client->noClientException;
}

static int
FreeFence(void *obj, XID id)
{
    SyncFence *pFence = (SyncFence *) obj;

    miSyncDestroyFence(pFence);

    return Success;
}

int SyncVerifyFence(SyncFence **ppSyncFence, XID fid,
		    ClientPtr client, Mask mode)
{
    int rc = dixLookupResourceByType((pointer *)ppSyncFence, fid, RTFence,
				     client, mode);

    if (rc != Success)
	client->errorValue = fid;

    return rc;
}

static int
ProcSyncTriggerFence(ClientPtr client)
{
    REQUEST(xSyncTriggerFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncTriggerFenceReq);

    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixWriteAccess);
    if (rc != Success)
	return rc;

    miSyncTriggerFence(pFence);

    return client->noClientException;
}

static int
ProcSyncResetFence(ClientPtr client)
{
    REQUEST(xSyncResetFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncResetFenceReq);

    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixWriteAccess);
    if (rc != Success)
	return rc;

    if (pFence->funcs.CheckTriggered(pFence) != TRUE)
	return BadMatch;

    pFence->funcs.Reset(pFence);

    return client->noClientException;
}

static int
ProcSyncDestroyFence(ClientPtr client)
{
    REQUEST(xSyncDestroyFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncDestroyFenceReq);

    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixDestroyAccess);
    if (rc != Success)
	return rc;

    FreeResource(stuff->fid, RT_NONE);
    return client->noClientException;
}

static int
ProcSyncQueryFence(ClientPtr client)
{
    REQUEST(xSyncQueryFenceReq);
    xSyncQueryFenceReply rep;
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryFenceReq);

    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid,
				 RTFence, client, DixReadAccess);
    if (rc != Success)
	return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rep.triggered = pFence->funcs.CheckTriggered(pFence);

    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
    }

    WriteToClient(client, sizeof(xSyncQueryFenceReply), (char *) &rep);
    return client->noClientException;
}

static int
ProcSyncAwaitFence(ClientPtr client)
{
    REQUEST(xSyncAwaitFenceReq);
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait *pAwait;
    /* Use CARD32 rather than XSyncFence because XIDs are hard-coded to
     * CARD32 in protocol definitions */
    CARD32 *pProtocolFences;
    int status;
    int len;
    int items;
    int i;

    REQUEST_AT_LEAST_SIZE(xSyncAwaitFenceReq);

    len = client->req_len << 2;
    len -= sz_xSyncAwaitFenceReq;
    items = len / sizeof(CARD32);

    if (items * sizeof(CARD32) != len)
    {
	return BadLength;
    }
    if (items == 0)
    {
	client->errorValue = items;
	return BadValue;
    }

    if (!(pAwaitUnion = SyncAwaitPrologue(client, items)))
	return BadAlloc;

    /* don't need to do any more memory allocation for this request! */

    pProtocolFences = (CARD32 *) & stuff[1];

    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pProtocolFences++, pAwait++)
    {
	if (*pProtocolFences == None)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    client->errorValue = *pProtocolFences;
	    return SyncErrorBase + XSyncBadFence;
	}

	pAwait->trigger.pSync = NULL;
	/* Provide acceptable values for these unused fields to
	 * satisfy SyncInitTrigger's validation logic
	 */
	pAwait->trigger.value_type = XSyncAbsolute;
	XSyncIntToValue(&pAwait->trigger.wait_value, 0);
	pAwait->trigger.test_type = 0;

	status = SyncInitTrigger(client, &pAwait->trigger,
				 *pProtocolFences, RTFence,
				 XSyncCAAllTrigger);
	if (status != Success)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    return status;
	}
	/* this is not a mistake -- same function works for both cases */
	pAwait->trigger.TriggerFired = SyncAwaitTriggerFired;
	pAwait->trigger.CounterDestroyed = SyncAwaitTriggerFired;
	/* event_threshold is unused for fence syncs */
	XSyncIntToValue(&pAwait->event_threshold, 0);
	pAwait->pHeader = &pAwaitUnion->header;
	pAwaitUnion->header.num_waitconditions++;
    }

    SyncAwaitEpilogue(client, items, pAwaitUnion);

    return client->noClientException;
}

/*
 * ** Given an extension request, call the appropriate request procedure
 */
static int
ProcSyncDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
      case X_SyncInitialize:
	return ProcSyncInitialize(client);
      case X_SyncListSystemCounters:
	return ProcSyncListSystemCounters(client);
      case X_SyncCreateCounter:
	return ProcSyncCreateCounter(client);
      case X_SyncSetCounter:
	return ProcSyncSetCounter(client);
      case X_SyncChangeCounter:
	return ProcSyncChangeCounter(client);
      case X_SyncQueryCounter:
	return ProcSyncQueryCounter(client);
      case X_SyncDestroyCounter:
	return ProcSyncDestroyCounter(client);
      case X_SyncAwait:
	return ProcSyncAwait(client);
      case X_SyncCreateAlarm:
	return ProcSyncCreateAlarm(client);
      case X_SyncChangeAlarm:
	return ProcSyncChangeAlarm(client);
      case X_SyncQueryAlarm:
	return ProcSyncQueryAlarm(client);
      case X_SyncDestroyAlarm:
	return ProcSyncDestroyAlarm(client);
      case X_SyncSetPriority:
	return ProcSyncSetPriority(client);
      case X_SyncGetPriority:
	return ProcSyncGetPriority(client);
      case X_SyncCreateFence:
	return ProcSyncCreateFence(client);
      case X_SyncTriggerFence:
	return ProcSyncTriggerFence(client);
      case X_SyncResetFence:
	return ProcSyncResetFence(client);
      case X_SyncDestroyFence:
	return ProcSyncDestroyFence(client);
      case X_SyncQueryFence:
	return ProcSyncQueryFence(client);
      case X_SyncAwaitFence:
	return ProcSyncAwaitFence(client);
      default:
	return BadRequest;
    }
}

/*
 * Boring Swapping stuff ...
 */

static int
SProcSyncInitialize(ClientPtr client)
{
    REQUEST(xSyncInitializeReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncInitializeReq);

    return ProcSyncInitialize(client);
}

static int
SProcSyncListSystemCounters(ClientPtr client)
{
    REQUEST(xSyncListSystemCountersReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncListSystemCountersReq);

    return ProcSyncListSystemCounters(client);
}

static int
SProcSyncCreateCounter(ClientPtr client)
{
    REQUEST(xSyncCreateCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncCreateCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->initial_value_lo, n);
    swapl(&stuff->initial_value_hi, n);

    return ProcSyncCreateCounter(client);
}

static int
SProcSyncSetCounter(ClientPtr client)
{
    REQUEST(xSyncSetCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncSetCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->value_lo, n);
    swapl(&stuff->value_hi, n);

    return ProcSyncSetCounter(client);
}

static int
SProcSyncChangeCounter(ClientPtr client)
{
    REQUEST(xSyncChangeCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncChangeCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->value_lo, n);
    swapl(&stuff->value_hi, n);

    return ProcSyncChangeCounter(client);
}

static int
SProcSyncQueryCounter(ClientPtr client)
{
    REQUEST(xSyncQueryCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryCounterReq);
    swapl(&stuff->counter, n);

    return ProcSyncQueryCounter(client);
}

static int
SProcSyncDestroyCounter(ClientPtr client)
{
    REQUEST(xSyncDestroyCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyCounterReq);
    swapl(&stuff->counter, n);

    return ProcSyncDestroyCounter(client);
}

static int
SProcSyncAwait(ClientPtr client)
{
    REQUEST(xSyncAwaitReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSyncAwaitReq);
    SwapRestL(stuff);

    return ProcSyncAwait(client);
}

static int
SProcSyncCreateAlarm(ClientPtr client)
{
    REQUEST(xSyncCreateAlarmReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSyncCreateAlarmReq);
    swapl(&stuff->id, n);
    swapl(&stuff->valueMask, n);
    SwapRestL(stuff);

    return ProcSyncCreateAlarm(client);
}

static int
SProcSyncChangeAlarm(ClientPtr client)
{
    REQUEST(xSyncChangeAlarmReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSyncChangeAlarmReq);
    swapl(&stuff->alarm, n);
    swapl(&stuff->valueMask, n);
    SwapRestL(stuff);
    return ProcSyncChangeAlarm(client);
}

static int
SProcSyncQueryAlarm(ClientPtr client)
{
    REQUEST(xSyncQueryAlarmReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryAlarmReq);
    swapl(&stuff->alarm, n);

    return ProcSyncQueryAlarm(client);
}

static int
SProcSyncDestroyAlarm(ClientPtr client)
{
    REQUEST(xSyncDestroyAlarmReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyAlarmReq);
    swapl(&stuff->alarm, n);

    return ProcSyncDestroyAlarm(client);
}

static int
SProcSyncSetPriority(ClientPtr client)
{
    REQUEST(xSyncSetPriorityReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncSetPriorityReq);
    swapl(&stuff->id, n);
    swapl(&stuff->priority, n);

    return ProcSyncSetPriority(client);
}

static int
SProcSyncGetPriority(ClientPtr client)
{
    REQUEST(xSyncGetPriorityReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncGetPriorityReq);
    swapl(&stuff->id, n);

    return ProcSyncGetPriority(client);
}

static int
SProcSyncCreateFence(ClientPtr client)
{
    REQUEST(xSyncCreateFenceReq);
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncCreateFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncCreateFence(client);
}

static int
SProcSyncTriggerFence(ClientPtr client)
{
    REQUEST(xSyncTriggerFenceReq);
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncTriggerFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncTriggerFence(client);
}

static int
SProcSyncResetFence(ClientPtr client)
{
    REQUEST(xSyncResetFenceReq);
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncResetFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncResetFence(client);
}

static int
SProcSyncDestroyFence(ClientPtr client)
{
    REQUEST(xSyncDestroyFenceReq);
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncDestroyFence(client);
}

static int
SProcSyncQueryFence(ClientPtr client)
{
    REQUEST(xSyncQueryFenceReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncQueryFence(client);
}

static int
SProcSyncAwaitFence(ClientPtr client)
{
    REQUEST(xSyncAwaitFenceReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSyncAwaitFenceReq);
    SwapRestL(stuff);

    return ProcSyncAwaitFence(client);
}

static int
SProcSyncDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
      case X_SyncInitialize:
	return SProcSyncInitialize(client);
      case X_SyncListSystemCounters:
	return SProcSyncListSystemCounters(client);
      case X_SyncCreateCounter:
	return SProcSyncCreateCounter(client);
      case X_SyncSetCounter:
	return SProcSyncSetCounter(client);
      case X_SyncChangeCounter:
	return SProcSyncChangeCounter(client);
      case X_SyncQueryCounter:
	return SProcSyncQueryCounter(client);
      case X_SyncDestroyCounter:
	return SProcSyncDestroyCounter(client);
      case X_SyncAwait:
	return SProcSyncAwait(client);
      case X_SyncCreateAlarm:
	return SProcSyncCreateAlarm(client);
      case X_SyncChangeAlarm:
	return SProcSyncChangeAlarm(client);
      case X_SyncQueryAlarm:
	return SProcSyncQueryAlarm(client);
      case X_SyncDestroyAlarm:
	return SProcSyncDestroyAlarm(client);
      case X_SyncSetPriority:
	return SProcSyncSetPriority(client);
      case X_SyncGetPriority:
	return SProcSyncGetPriority(client);
      case X_SyncCreateFence:
	return SProcSyncCreateFence(client);
      case X_SyncTriggerFence:
	return SProcSyncTriggerFence(client);
      case X_SyncResetFence:
	return SProcSyncResetFence(client);
      case X_SyncDestroyFence:
	return SProcSyncDestroyFence(client);
      case X_SyncQueryFence:
	return SProcSyncQueryFence(client);
      case X_SyncAwaitFence:
	return SProcSyncAwaitFence(client);
      default:
	return BadRequest;
    }
}

/*
 * Event Swapping
 */

static void
SCounterNotifyEvent(xSyncCounterNotifyEvent *from, xSyncCounterNotifyEvent *to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->counter, to->counter);
    cpswapl(from->wait_value_lo, to->wait_value_lo);
    cpswapl(from->wait_value_hi, to->wait_value_hi);
    cpswapl(from->counter_value_lo, to->counter_value_lo);
    cpswapl(from->counter_value_hi, to->counter_value_hi);
    cpswapl(from->time, to->time);
    cpswaps(from->count, to->count);
    to->destroyed = from->destroyed;
}


static void
SAlarmNotifyEvent(xSyncAlarmNotifyEvent *from, xSyncAlarmNotifyEvent *to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->alarm, to->alarm);
    cpswapl(from->counter_value_lo, to->counter_value_lo);
    cpswapl(from->counter_value_hi, to->counter_value_hi);
    cpswapl(from->alarm_value_lo, to->alarm_value_lo);
    cpswapl(from->alarm_value_hi, to->alarm_value_hi);
    cpswapl(from->time, to->time);
    to->state = from->state;
}

/*
 * ** Close everything down. ** This is fairly simple for now.
 */
/* ARGSUSED */
static void
SyncResetProc(ExtensionEntry *extEntry)
{
    free(SysCounterList);
    SysCounterList = NULL;
    RTCounter = 0;
}

/*
 * ** Initialise the extension.
 */
void
SyncExtensionInit(void)
{
    ExtensionEntry *extEntry;
    int 	    s;

    for (s = 0; s < screenInfo.numScreens; s++)
	miSyncSetup(screenInfo.screens[s]);

    if (RTCounter == 0)
    {
	RTCounter = CreateNewResourceType(FreeCounter, "SyncCounter");
    }
    RTAlarm = CreateNewResourceType(FreeAlarm, "SyncAlarm");
    RTAwait = CreateNewResourceType(FreeAwait, "SyncAwait");
    RTFence = CreateNewResourceType(FreeFence, "SyncFence");
    if (RTAwait)
	RTAwait |= RC_NEVERRETAIN;
    RTAlarmClient = CreateNewResourceType(FreeAlarmClient, "SyncAlarmClient");
    if (RTAlarmClient)
	RTAlarmClient |= RC_NEVERRETAIN;

    if (RTCounter == 0 || RTAwait == 0 || RTAlarm == 0 ||
	RTAlarmClient == 0 ||
	(extEntry = AddExtension(SYNC_NAME,
				 XSyncNumberEvents, XSyncNumberErrors,
				 ProcSyncDispatch, SProcSyncDispatch,
				 SyncResetProc,
				 StandardMinorOpcode)) == NULL)
    {
	ErrorF("Sync Extension %d.%d failed to Initialise\n",
		SYNC_MAJOR_VERSION, SYNC_MINOR_VERSION);
	return;
    }

    SyncEventBase = extEntry->eventBase;
    SyncErrorBase = extEntry->errorBase;
    EventSwapVector[SyncEventBase + XSyncCounterNotify] = (EventSwapPtr) SCounterNotifyEvent;
    EventSwapVector[SyncEventBase + XSyncAlarmNotify] = (EventSwapPtr) SAlarmNotifyEvent;

    SetResourceTypeErrorValue(RTCounter, SyncErrorBase + XSyncBadCounter);
    SetResourceTypeErrorValue(RTAlarm, SyncErrorBase + XSyncBadAlarm);
    SetResourceTypeErrorValue(RTFence, SyncErrorBase + XSyncBadFence);

    /*
     * Although SERVERTIME is implemented by the OS layer, we initialise it
     * here because doing it in OsInit() is too early. The resource database
     * is not initialised when OsInit() is called. This is just about OK
     * because there is always a servertime counter.
     */
    SyncInitServerTime();
    SyncInitIdleTime();

#ifdef DEBUG
    fprintf(stderr, "Sync Extension %d.%d\n",
	    SYNC_MAJOR_VERSION, SYNC_MINOR_VERSION);
#endif
}


/*
 * ***** SERVERTIME implementation - should go in its own file in OS directory?
 */



static pointer ServertimeCounter;
static XSyncValue Now;
static XSyncValue *pnext_time;

#define GetTime()\
{\
    unsigned long millis = GetTimeInMillis();\
    unsigned long maxis = XSyncValueHigh32(Now);\
    if (millis < XSyncValueLow32(Now)) maxis++;\
    XSyncIntsToValue(&Now, millis, maxis);\
}

/*
*** Server Block Handler
*** code inspired by multibuffer extension (now deprecated)
 */
/*ARGSUSED*/
static void
ServertimeBlockHandler(void *env, struct timeval **wt, void *LastSelectMask)
{
    XSyncValue delay;
    unsigned long timeout;

    if (pnext_time)
    {
        GetTime();

        if (XSyncValueGreaterOrEqual(Now, *pnext_time))
	{
            timeout = 0;
        }
	else
	{
	    Bool overflow;
            XSyncValueSubtract(&delay, *pnext_time, Now, &overflow);
	    (void)overflow;
            timeout = XSyncValueLow32(delay);
        }
        AdjustWaitForDelay(wt, timeout); /* os/utils.c */
    }
}

/*
*** Wakeup Handler
 */
/*ARGSUSED*/
static void
ServertimeWakeupHandler(void *env, int rc, void *LastSelectMask)
{
    if (pnext_time)
    {
        GetTime();

        if (XSyncValueGreaterOrEqual(Now, *pnext_time))
	{
            SyncChangeCounter(ServertimeCounter, Now);
        }
    }
}

static void
ServertimeQueryValue(void *pCounter, CARD64 *pValue_return)
{
    GetTime();
    *pValue_return = Now;
}

static void
ServertimeBracketValues(void *pCounter, CARD64 *pbracket_less,
			CARD64 *pbracket_greater)
{
    if (!pnext_time && pbracket_greater)
    {
	RegisterBlockAndWakeupHandlers(ServertimeBlockHandler,
				       ServertimeWakeupHandler,
				       NULL);
    }
    else if (pnext_time && !pbracket_greater)
    {
	RemoveBlockAndWakeupHandlers(ServertimeBlockHandler,
				     ServertimeWakeupHandler,
				     NULL);
    }
    pnext_time = pbracket_greater;
}

static void
SyncInitServerTime(void)
{
    CARD64 resolution;

    XSyncIntsToValue(&Now, GetTimeInMillis(), 0);
    XSyncIntToValue(&resolution, 4);
    ServertimeCounter = SyncCreateSystemCounter("SERVERTIME", Now, resolution,
			    XSyncCounterNeverDecreases,
			    ServertimeQueryValue, ServertimeBracketValues);
    pnext_time = NULL;
}



/*
 * IDLETIME implementation
 */

static SyncCounter *IdleTimeCounter;
static XSyncValue *pIdleTimeValueLess;
static XSyncValue *pIdleTimeValueGreater;

static void
IdleTimeQueryValue (pointer pCounter, CARD64 *pValue_return)
{
    CARD32 idle = GetTimeInMillis() - lastDeviceEventTime.milliseconds;
    XSyncIntsToValue (pValue_return, idle, 0);
}

static void
IdleTimeBlockHandler(pointer env, struct timeval **wt, pointer LastSelectMask)
{
    XSyncValue idle, old_idle;
    SyncTriggerList *list = IdleTimeCounter->sync.pTriglist;
    SyncTrigger *trig;

    if (!pIdleTimeValueLess && !pIdleTimeValueGreater)
	return;

    old_idle = IdleTimeCounter->value;
    IdleTimeQueryValue (NULL, &idle);
    IdleTimeCounter->value = idle; /* push, so CheckTrigger works */

    if (pIdleTimeValueLess &&
        XSyncValueLessOrEqual (idle, *pIdleTimeValueLess))
    {
	/*
	 * We've been idle for less than the threshold value, and someone
	 * wants to know about that, but now we need to know whether they
	 * want level or edge trigger.  Check the trigger list against the
	 * current idle time, and if any succeed, bomb out of select()
	 * immediately so we can reschedule.
	 */

	for (list = IdleTimeCounter->sync.pTriglist; list; list = list->next) {
	    trig = list->pTrigger;
	    if (trig->CheckTrigger(trig, old_idle)) {
		AdjustWaitForDelay(wt, 0);
		break;
	    }
	}
	/* 
	 * We've been called exactly on the idle time, but we have a
	 * NegativeTransition trigger which requires a transition from an
	 * idle time greater than this.  Schedule a wakeup for the next
	 * millisecond so we won't miss a transition.
	 */
	if (XSyncValueEqual (idle, *pIdleTimeValueLess))
	    AdjustWaitForDelay(wt, 1);
    }
    else if (pIdleTimeValueGreater)
    {
	/*
	 * There's a threshold in the positive direction.  If we've been
	 * idle less than it, schedule a wakeup for sometime in the future.
	 * If we've been idle more than it, and someone wants to know about
	 * that level-triggered, schedule an immediate wakeup.
	 */
	unsigned long timeout = -1;

	if (XSyncValueLessThan (idle, *pIdleTimeValueGreater)) {
	    XSyncValue value;
	    Bool overflow;

	    XSyncValueSubtract (&value, *pIdleTimeValueGreater,
	                        idle, &overflow);
	    timeout = min(timeout, XSyncValueLow32 (value));
	} else {
	    for (list = IdleTimeCounter->sync.pTriglist; list; list = list->next) {
		trig = list->pTrigger;
		if (trig->CheckTrigger(trig, old_idle)) {
		    timeout = min(timeout, 0);
		    break;
		}
	    }
	}

	AdjustWaitForDelay (wt, timeout);
    }

    IdleTimeCounter->value = old_idle; /* pop */
}

static void
IdleTimeWakeupHandler (pointer env, int rc, pointer LastSelectMask)
{
    XSyncValue idle;

    if (!pIdleTimeValueLess && !pIdleTimeValueGreater)
	return;

    IdleTimeQueryValue (NULL, &idle);

    if ((pIdleTimeValueGreater &&
         XSyncValueGreaterOrEqual (idle, *pIdleTimeValueGreater)) ||
        (pIdleTimeValueLess &&
	 XSyncValueLessOrEqual (idle, *pIdleTimeValueLess)))
    {
	SyncChangeCounter (IdleTimeCounter, idle);
    }
}

static void
IdleTimeBracketValues (pointer pCounter, CARD64 *pbracket_less,
                       CARD64 *pbracket_greater)
{
    Bool registered = (pIdleTimeValueLess || pIdleTimeValueGreater);

    if (registered && !pbracket_less && !pbracket_greater)
    {
	RemoveBlockAndWakeupHandlers(IdleTimeBlockHandler,
	                             IdleTimeWakeupHandler,
	                             NULL);
    }
    else if (!registered && (pbracket_less || pbracket_greater))
    {
	RegisterBlockAndWakeupHandlers(IdleTimeBlockHandler,
	                               IdleTimeWakeupHandler,
	                               NULL);
    }

    pIdleTimeValueGreater = pbracket_greater;
    pIdleTimeValueLess    = pbracket_less;
}

static void
SyncInitIdleTime (void)
{
    CARD64 resolution;
    XSyncValue idle;

    IdleTimeQueryValue (NULL, &idle);
    XSyncIntToValue (&resolution, 4);

    IdleTimeCounter = SyncCreateSystemCounter ("IDLETIME", idle, resolution,
                                               XSyncCounterUnrestricted,
                                               IdleTimeQueryValue,
                                               IdleTimeBracketValues);

    pIdleTimeValueLess = pIdleTimeValueGreater = NULL;
}
/*
 * Copyright © 2010 NVIDIA Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef _SYNCSDK_H_
#define _SYNCSDK_H_

#include "misync.h"

extern _X_EXPORT int
SyncVerifyFence(SyncFence **ppFence, XID fid, ClientPtr client, Mask mode);

#define VERIFY_SYNC_FENCE(pFence, fid, client, mode)			\
    do {								\
	int rc;								\
	rc = SyncVerifyFence(&(pFence), (fid), (client), (mode));	\
	if (Success != rc) return rc;					\
    } while (0)

#define VERIFY_SYNC_FENCE_OR_NONE(pFence, fid, client, mode)		\
    do {								\
        pFence = 0;							\
        if (None != fid)						\
	    VERIFY_SYNC_FENCE((pFence), (fid), (client), (mode));	\
    } while (0)

#endif /* _SYNCSDK_H_ */

/*

Copyright 1991, 1993, 1994, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/

/***********************************************************
Copyright 1991,1993 by Digital Equipment Corporation, Maynard, Massachusetts,
and Olivetti Research Limited, Cambridge, England.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or Olivetti
not be used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL AND OLIVETTI DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL THEY BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

******************************************************************/

#ifndef _SYNCSRV_H_
#define _SYNCSRV_H_

#include "misync.h"
#include "misyncstr.h"

/*
 * The System Counter interface
 */

typedef enum {
    XSyncCounterNeverChanges,
    XSyncCounterNeverIncreases,
    XSyncCounterNeverDecreases,
    XSyncCounterUnrestricted
} SyncCounterType;

typedef struct _SysCounterInfo {
    char	*name;
    CARD64	resolution;
    CARD64	bracket_greater;
    CARD64	bracket_less;
    SyncCounterType counterType;  /* how can this counter change */
    void        (*QueryValue)(
			      pointer /*pCounter*/,
			      CARD64 * /*freshvalue*/
);
    void	(*BracketValues)(
				 pointer /*pCounter*/,
				 CARD64 * /*lessthan*/,
				 CARD64 * /*greaterthan*/
);
} SysCounterInfo;



typedef struct _SyncAlarmClientList {
    ClientPtr	client;
    XID		delete_id;
    struct _SyncAlarmClientList *next;
} SyncAlarmClientList;

typedef struct _SyncAlarm {
    SyncTrigger trigger;
    ClientPtr	client;
    XSyncAlarm 	alarm_id;
    CARD64	delta;
    int		events;
    int		state;
    SyncAlarmClientList *pEventClients;
} SyncAlarm;

typedef struct {
    ClientPtr	client;
    CARD32 	delete_id;
    int		num_waitconditions;
} SyncAwaitHeader;

typedef struct {
    SyncTrigger trigger;
    CARD64	event_threshold;
    SyncAwaitHeader *pHeader;
} SyncAwait;

typedef union {
    SyncAwaitHeader header;
    SyncAwait	    await;
} SyncAwaitUnion;

extern pointer SyncCreateSystemCounter(
    char *	/* name */,
    CARD64  	/* inital_value */,
    CARD64  	/* resolution */,
    SyncCounterType /* change characterization */,
    void        (* /*QueryValue*/ ) (
        pointer /* pCounter */,
        CARD64 * /* pValue_return */), /* XXX prototype */
    void        (* /*BracketValues*/) (
        pointer /* pCounter */, 
        CARD64 * /* pbracket_less */,
        CARD64 * /* pbracket_greater */)
);

extern void SyncChangeCounter(
    SyncCounter *	/* pCounter*/,
    CARD64  		/* new_value */
);

extern void SyncDestroySystemCounter(
    pointer pCounter
);

extern void InitServertime(void);

extern void SyncExtensionInit(void);
#endif /* _SYNCSRV_H_ */
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdarg.h>
#include "scrnintstr.h"
#include "extnsionst.h"
#include "pixmapstr.h"
#include "regionstr.h"
#include "gcstruct.h"
#include "xacestr.h"

#define XSERV_t
#define TRANS_SERVER
#include <X11/Xtrans/Xtrans.h>
#include "../os/osdep.h"

_X_EXPORT CallbackListPtr XaceHooks[XACE_NUM_HOOKS] = {0};

/* Special-cased hook functions.  Called by Xserver.
 */
int XaceHookDispatch(ClientPtr client, int major)
{
    /* Call the audit begin callback, there is no return value. */
    XaceAuditRec rec = { client, 0 };
    CallCallbacks(&XaceHooks[XACE_AUDIT_BEGIN], &rec);

    if (major < 128) {
	/* Call the core dispatch hook */
	XaceCoreDispatchRec rec = { client, Success /* default allow */ };
	CallCallbacks(&XaceHooks[XACE_CORE_DISPATCH], &rec);
	return rec.status;
    } else {
	/* Call the extension dispatch hook */
	ExtensionEntry *ext = GetExtensionEntry(major);
	XaceExtAccessRec rec = { client, ext, DixUseAccess, Success };
	if (ext)
	    CallCallbacks(&XaceHooks[XACE_EXT_DISPATCH], &rec);
	/* On error, pretend extension doesn't exist */
	return (rec.status == Success) ? Success : BadRequest;
    }
}

int XaceHookPropertyAccess(ClientPtr client, WindowPtr pWin,
			   PropertyPtr *ppProp, Mask access_mode)
{
    XacePropertyAccessRec rec = { client, pWin, ppProp, access_mode, Success };
    CallCallbacks(&XaceHooks[XACE_PROPERTY_ACCESS], &rec);
    return rec.status;
}

int XaceHookSelectionAccess(ClientPtr client,
			    Selection **ppSel, Mask access_mode)
{
    XaceSelectionAccessRec rec = { client, ppSel, access_mode, Success };
    CallCallbacks(&XaceHooks[XACE_SELECTION_ACCESS], &rec);
    return rec.status;
}

void XaceHookAuditEnd(ClientPtr ptr, int result)
{
    XaceAuditRec rec = { ptr, result };
    /* call callbacks, there is no return value. */
    CallCallbacks(&XaceHooks[XACE_AUDIT_END], &rec);
}

/* Entry point for hook functions.  Called by Xserver.
 */
int XaceHook(int hook, ...)
{
    union {
	XaceResourceAccessRec res;
	XaceDeviceAccessRec dev;
	XaceSendAccessRec send;
	XaceReceiveAccessRec recv;
	XaceClientAccessRec client;
	XaceExtAccessRec ext;
	XaceServerAccessRec server;
	XaceScreenAccessRec screen;
	XaceAuthAvailRec auth;
	XaceKeyAvailRec key;
    } u;
    int *prv = NULL;	/* points to return value from callback */
    va_list ap;		/* argument list */
    va_start(ap, hook);

    /* Marshal arguments for passing to callback.
     * Each callback has its own case, which sets up a structure to hold
     * the arguments and integer return parameter, or in some cases just
     * sets calldata directly to a single argument (with no return result)
     */
    switch (hook)
    {
	case XACE_RESOURCE_ACCESS:
	    u.res.client = va_arg(ap, ClientPtr);
	    u.res.id = va_arg(ap, XID);
	    u.res.rtype = va_arg(ap, RESTYPE);
	    u.res.res = va_arg(ap, pointer);
	    u.res.ptype = va_arg(ap, RESTYPE);
	    u.res.parent = va_arg(ap, pointer);
	    u.res.access_mode = va_arg(ap, Mask);
	    u.res.status = Success; /* default allow */
	    prv = &u.res.status;
	    break;
	case XACE_DEVICE_ACCESS:
	    u.dev.client = va_arg(ap, ClientPtr);
	    u.dev.dev = va_arg(ap, DeviceIntPtr);
	    u.dev.access_mode = va_arg(ap, Mask);
	    u.dev.status = Success; /* default allow */
	    prv = &u.dev.status;
	    break;
	case XACE_SEND_ACCESS:
	    u.send.client = va_arg(ap, ClientPtr);
	    u.send.dev = va_arg(ap, DeviceIntPtr);
	    u.send.pWin = va_arg(ap, WindowPtr);
	    u.send.events = va_arg(ap, xEventPtr);
	    u.send.count = va_arg(ap, int);
	    u.send.status = Success; /* default allow */
	    prv = &u.send.status;
	    break;
	case XACE_RECEIVE_ACCESS:
	    u.recv.client = va_arg(ap, ClientPtr);
	    u.recv.pWin = va_arg(ap, WindowPtr);
	    u.recv.events = va_arg(ap, xEventPtr);
	    u.recv.count = va_arg(ap, int);
	    u.recv.status = Success; /* default allow */
	    prv = &u.recv.status;
	    break;
	case XACE_CLIENT_ACCESS:
	    u.client.client = va_arg(ap, ClientPtr);
	    u.client.target = va_arg(ap, ClientPtr);
	    u.client.access_mode = va_arg(ap, Mask);
	    u.client.status = Success; /* default allow */
	    prv = &u.client.status;
	    break;
	case XACE_EXT_ACCESS:
	    u.ext.client = va_arg(ap, ClientPtr);
	    u.ext.ext = va_arg(ap, ExtensionEntry*);
	    u.ext.access_mode = DixGetAttrAccess;
	    u.ext.status = Success; /* default allow */
	    prv = &u.ext.status;
	    break;
	case XACE_SERVER_ACCESS:
	    u.server.client = va_arg(ap, ClientPtr);
	    u.server.access_mode = va_arg(ap, Mask);
	    u.server.status = Success; /* default allow */
	    prv = &u.server.status;
	    break;
	case XACE_SCREEN_ACCESS:
	case XACE_SCREENSAVER_ACCESS:
	    u.screen.client = va_arg(ap, ClientPtr);
	    u.screen.screen = va_arg(ap, ScreenPtr);
	    u.screen.access_mode = va_arg(ap, Mask);
	    u.screen.status = Success; /* default allow */
	    prv = &u.screen.status;
	    break;
	case XACE_AUTH_AVAIL:
	    u.auth.client = va_arg(ap, ClientPtr);
	    u.auth.authId = va_arg(ap, XID);
	    break;
	case XACE_KEY_AVAIL:
	    u.key.event = va_arg(ap, xEventPtr);
	    u.key.keybd = va_arg(ap, DeviceIntPtr);
	    u.key.count = va_arg(ap, int);
	    break;
	default:
	    va_end(ap);
	    return 0;	/* unimplemented hook number */
    }
    va_end(ap);
 
    /* call callbacks and return result, if any. */
    CallCallbacks(&XaceHooks[hook], &u);
    return prv ? *prv : Success;
}

/* XaceCensorImage
 *
 * Called after pScreen->GetImage to prevent pieces or trusted windows from
 * being returned in image data from an untrusted window.
 *
 * Arguments:
 *	client is the client doing the GetImage.
 *      pVisibleRegion is the visible region of the window.
 *	widthBytesLine is the width in bytes of one horizontal line in pBuf.
 *	pDraw is the source window.
 *	x, y, w, h is the rectangle of image data from pDraw in pBuf.
 *	format is the format of the image data in pBuf: ZPixmap or XYPixmap.
 *	pBuf is the image data.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Any part of the rectangle (x, y, w, h) that is outside the visible
 *	region of the window will be destroyed (overwritten) in pBuf.
 */
void
XaceCensorImage(
	ClientPtr client,
	RegionPtr pVisibleRegion,
	long widthBytesLine,
	DrawablePtr pDraw,
	int x, int y, int w, int h,
	unsigned int format,
	char *pBuf)
{
    RegionRec imageRegion;  /* region representing x,y,w,h */
    RegionRec censorRegion; /* region to obliterate */
    BoxRec imageBox;
    int nRects;

    imageBox.x1 = x;
    imageBox.y1 = y;
    imageBox.x2 = x + w;
    imageBox.y2 = y + h;
    RegionInit(&imageRegion, &imageBox, 1);
    RegionNull(&censorRegion);

    /* censorRegion = imageRegion - visibleRegion */
    RegionSubtract(&censorRegion, &imageRegion, pVisibleRegion);
    nRects = RegionNumRects(&censorRegion);
    if (nRects > 0)
    { /* we have something to censor */
	GCPtr pScratchGC = NULL;
	PixmapPtr pPix = NULL;
	xRectangle *pRects = NULL;
	Bool failed = FALSE;
	int depth = 1;
	int bitsPerPixel = 1;
	int i;
	BoxPtr pBox;

	/* convert region to list-of-rectangles for PolyFillRect */

	pRects = malloc(nRects * sizeof(xRectangle));
	if (!pRects)
	{
	    failed = TRUE;
	    goto failSafe;
	}
	for (pBox = RegionRects(&censorRegion), i = 0;
	     i < nRects;
	     i++, pBox++)
	{
	    pRects[i].x = pBox->x1;
	    pRects[i].y = pBox->y1 - imageBox.y1;
	    pRects[i].width  = pBox->x2 - pBox->x1;
	    pRects[i].height = pBox->y2 - pBox->y1;
	}

	/* use pBuf as a fake pixmap */

	if (format == ZPixmap)
	{
	    depth = pDraw->depth;
	    bitsPerPixel = pDraw->bitsPerPixel;
	}

	pPix = GetScratchPixmapHeader(pDraw->pScreen, w, h,
		    depth, bitsPerPixel,
		    widthBytesLine, (pointer)pBuf);
	if (!pPix)
	{
	    failed = TRUE;
	    goto failSafe;
	}

	pScratchGC = GetScratchGC(depth, pPix->drawable.pScreen);
	if (!pScratchGC)
	{
	    failed = TRUE;
	    goto failSafe;
	}

	ValidateGC(&pPix->drawable, pScratchGC);
	(* pScratchGC->ops->PolyFillRect)(&pPix->drawable,
			    pScratchGC, nRects, pRects);

    failSafe:
	if (failed)
	{
	    /* Censoring was not completed above.  To be safe, wipe out
	     * all the image data so that nothing trusted gets out.
	     */
	    memset(pBuf, 0, (int)(widthBytesLine * h));
	}
	free(pRects);
	if (pScratchGC) FreeScratchGC(pScratchGC);
	if (pPix)       FreeScratchPixmapHeader(pPix);
    }
    RegionUninit(&imageRegion);
    RegionUninit(&censorRegion);
} /* XaceCensorImage */

/*
 * Xtrans wrappers for use by modules
 */
int XaceGetConnectionNumber(ClientPtr client)
{
    XtransConnInfo ci = ((OsCommPtr)client->osPrivate)->trans_conn;
    return _XSERVTransGetConnectionNumber(ci);
}

int XaceIsLocal(ClientPtr client)
{
    XtransConnInfo ci = ((OsCommPtr)client->osPrivate)->trans_conn;
    return _XSERVTransIsLocal(ci);
}
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifndef _XACE_H
#define _XACE_H

#ifdef XACE

#define XACE_MAJOR_VERSION		2
#define XACE_MINOR_VERSION		0

#include "pixmap.h"
#include "region.h"
#include "window.h"
#include "property.h"
#include "selection.h"

/* Default window background */
#define XaceBackgroundNoneState(w) ((w)->forcedBG ? BackgroundPixel : None)

/* security hooks */
/* Constants used to identify the available security hooks
 */
#define XACE_CORE_DISPATCH		0
#define XACE_EXT_DISPATCH		1
#define XACE_RESOURCE_ACCESS		2
#define XACE_DEVICE_ACCESS		3
#define XACE_PROPERTY_ACCESS		4
#define XACE_SEND_ACCESS		5
#define XACE_RECEIVE_ACCESS		6
#define XACE_CLIENT_ACCESS		7
#define XACE_EXT_ACCESS			8
#define XACE_SERVER_ACCESS		9
#define XACE_SELECTION_ACCESS		10
#define XACE_SCREEN_ACCESS		11
#define XACE_SCREENSAVER_ACCESS		12
#define XACE_AUTH_AVAIL			13
#define XACE_KEY_AVAIL			14
#define XACE_AUDIT_BEGIN		15
#define XACE_AUDIT_END			16
#define XACE_NUM_HOOKS			17

extern _X_EXPORT CallbackListPtr XaceHooks[XACE_NUM_HOOKS];

/* Entry point for hook functions.  Called by Xserver.
 * Required by libdbe and libextmod
 */
extern _X_EXPORT int XaceHook(
    int /*hook*/,
    ... /*appropriate args for hook*/
    ); 

/* Special-cased hook functions
 */
extern _X_EXPORT int XaceHookDispatch(ClientPtr ptr, int major);
extern _X_EXPORT int XaceHookPropertyAccess(ClientPtr ptr, WindowPtr pWin,
				   PropertyPtr *ppProp, Mask access_mode);
extern _X_EXPORT int XaceHookSelectionAccess(ClientPtr ptr,
				   Selection **ppSel, Mask access_mode);
extern _X_EXPORT void XaceHookAuditEnd(ClientPtr ptr, int result);

/* Register a callback for a given hook.
 */
#define XaceRegisterCallback(hook,callback,data) \
    AddCallback(XaceHooks+(hook), callback, data)

/* Unregister an existing callback for a given hook.
 */
#define XaceDeleteCallback(hook,callback,data) \
    DeleteCallback(XaceHooks+(hook), callback, data)

/* XTrans wrappers for use by security modules
 */
extern _X_EXPORT int XaceGetConnectionNumber(ClientPtr ptr);
extern _X_EXPORT int XaceIsLocal(ClientPtr ptr);

/* From the original Security extension...
 */

extern _X_EXPORT void XaceCensorImage(
    ClientPtr client,
    RegionPtr pVisibleRegion,
    long widthBytesLine,
    DrawablePtr pDraw,
    int x, int y, int w, int h,
    unsigned int format,
    char * pBuf
    );

#else /* XACE */

/* Default window background */
#define XaceBackgroundNoneState(w)		None

/* Define calls away when XACE is not being built. */

#ifdef __GNUC__
#define XaceHook(args...) Success
#define XaceHookDispatch(args...) Success
#define XaceHookPropertyAccess(args...) Success
#define XaceHookSelectionAccess(args...) Success
#define XaceHookAuditEnd(args...) { ; }
#define XaceCensorImage(args...) { ; }
#else
#define XaceHook(...) Success
#define XaceHookDispatch(...) Success
#define XaceHookPropertyAccess(...) Success
#define XaceHookSelectionAccess(...) Success
#define XaceHookAuditEnd(...) { ; }
#define XaceCensorImage(...) { ; }
#endif

#endif /* XACE */

#endif /* _XACE_H */
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifndef _XACESTR_H
#define _XACESTR_H

#include "dix.h"
#include "resource.h"
#include "extnsionst.h"
#include "window.h"
#include "input.h"
#include "property.h"
#include "selection.h"
#include "xace.h"

/* XACE_CORE_DISPATCH */
typedef struct {
    ClientPtr client;
    int status;
} XaceCoreDispatchRec;

/* XACE_RESOURCE_ACCESS */
typedef struct {
    ClientPtr client;
    XID id;
    RESTYPE rtype;
    pointer res;
    RESTYPE ptype;
    pointer parent;
    Mask access_mode;
    int status;
} XaceResourceAccessRec;

/* XACE_DEVICE_ACCESS */
typedef struct {
    ClientPtr client;
    DeviceIntPtr dev;
    Mask access_mode;
    int status;
} XaceDeviceAccessRec;

/* XACE_PROPERTY_ACCESS */
typedef struct {
    ClientPtr client;
    WindowPtr pWin;
    PropertyPtr *ppProp;
    Mask access_mode;
    int status;
} XacePropertyAccessRec;

/* XACE_SEND_ACCESS */
typedef struct {
    ClientPtr client;
    DeviceIntPtr dev;
    WindowPtr pWin;
    xEventPtr events;
    int count;
    int status;
} XaceSendAccessRec;

/* XACE_RECEIVE_ACCESS */
typedef struct {
    ClientPtr client;
    WindowPtr pWin;
    xEventPtr events;
    int count;
    int status;
} XaceReceiveAccessRec;

/* XACE_CLIENT_ACCESS */
typedef struct {
    ClientPtr client;
    ClientPtr target;
    Mask access_mode;
    int status;
} XaceClientAccessRec;

/* XACE_EXT_DISPATCH */
/* XACE_EXT_ACCESS */
typedef struct {
    ClientPtr client;
    ExtensionEntry *ext;
    Mask access_mode;
    int status;
} XaceExtAccessRec;

/* XACE_SERVER_ACCESS */
typedef struct {
    ClientPtr client;
    Mask access_mode;
    int status;
} XaceServerAccessRec;

/* XACE_SELECTION_ACCESS */
typedef struct {
    ClientPtr client;
    Selection **ppSel;
    Mask access_mode;
    int status;
} XaceSelectionAccessRec;

/* XACE_SCREEN_ACCESS */
/* XACE_SCREENSAVER_ACCESS */
typedef struct {
    ClientPtr client;
    ScreenPtr screen;
    Mask access_mode;
    int status;
} XaceScreenAccessRec;

/* XACE_AUTH_AVAIL */
typedef struct {
    ClientPtr client;
    XID authId;
} XaceAuthAvailRec;

/* XACE_KEY_AVAIL */
typedef struct {
    xEventPtr event;
    DeviceIntPtr keybd;
    int count;
} XaceKeyAvailRec;

/* XACE_AUDIT_BEGIN */
/* XACE_AUDIT_END */
typedef struct {
    ClientPtr client;
    int requestResult;
} XaceAuditRec;

#endif /* _XACESTR_H */
/*

Copyright 1993, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "swaprep.h"
#include <X11/extensions/xcmiscproto.h>
#include "modinit.h"

#if HAVE_STDINT_H
#include <stdint.h>
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif


static int
ProcXCMiscGetVersion(ClientPtr client)
{
    xXCMiscGetVersionReply rep;
    int n;

    REQUEST_SIZE_MATCH(xXCMiscGetVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = XCMiscMajorVersion;
    rep.minorVersion = XCMiscMinorVersion;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xXCMiscGetVersionReply), (char *)&rep);
    return Success;
}

static int
ProcXCMiscGetXIDRange(ClientPtr client)
{
    xXCMiscGetXIDRangeReply rep;
    int n;
    XID min_id, max_id;

    REQUEST_SIZE_MATCH(xXCMiscGetXIDRangeReq);
    GetXIDRange(client->index, FALSE, &min_id, &max_id);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.start_id = min_id;
    rep.count = max_id - min_id + 1;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.start_id, n);
	swapl(&rep.count, n);
    }
    WriteToClient(client, sizeof(xXCMiscGetXIDRangeReply), (char *)&rep);
    return Success;
}

static int
ProcXCMiscGetXIDList(ClientPtr client)
{
    REQUEST(xXCMiscGetXIDListReq);
    xXCMiscGetXIDListReply rep;
    int n;
    XID *pids;
    unsigned int count;

    REQUEST_SIZE_MATCH(xXCMiscGetXIDListReq);

    if (stuff->count > UINT32_MAX / sizeof(XID))
	    return BadAlloc;

    pids = (XID *)malloc(stuff->count * sizeof(XID));
    if (!pids)
    {
	return BadAlloc;
    }
    count = GetXIDList(client, stuff->count, pids);
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = count;
    rep.count = count;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.count, n);
    }
    WriteToClient(client, sizeof(xXCMiscGetXIDListReply), (char *)&rep);
    if (count)
    {
    	client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	WriteSwappedDataToClient(client, count * sizeof(XID), pids);
    }
    free(pids);
    return Success;
}

static int
ProcXCMiscDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_XCMiscGetVersion:
	return ProcXCMiscGetVersion(client);
    case X_XCMiscGetXIDRange:
	return ProcXCMiscGetXIDRange(client);
    case X_XCMiscGetXIDList:
	return ProcXCMiscGetXIDList(client);
    default:
	return BadRequest;
    }
}

static int
SProcXCMiscGetVersion(ClientPtr client)
{
    int n;
    REQUEST(xXCMiscGetVersionReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXCMiscGetVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion, n);
    return ProcXCMiscGetVersion(client);
}

static int
SProcXCMiscGetXIDRange(ClientPtr client)
{
    int n;
    REQUEST(xReq);

    swaps(&stuff->length, n);
    return ProcXCMiscGetXIDRange(client);
}

static int
SProcXCMiscGetXIDList(ClientPtr client)
{
    int n;
    REQUEST(xXCMiscGetXIDListReq);

    swaps(&stuff->length, n);
    swapl(&stuff->count, n);
    return ProcXCMiscGetXIDList(client);
}

static int
SProcXCMiscDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_XCMiscGetVersion:
	return SProcXCMiscGetVersion(client);
    case X_XCMiscGetXIDRange:
	return SProcXCMiscGetXIDRange(client);
    case X_XCMiscGetXIDList:
	return SProcXCMiscGetXIDList(client);
    default:
	return BadRequest;
    }
}

void
XCMiscExtensionInit(INITARGS)
{
    AddExtension(XCMiscExtensionName, 0, 0,
		 ProcXCMiscDispatch, SProcXCMiscDispatch,
		 NULL, StandardMinorOpcode);
}
/*
 * BIGFONT extension for sharing font metrics between clients (if possible)
 * and for transmitting font metrics to clients in a compressed form.
 *
 * Copyright (c) 1999-2000  Bruno Haible
 * Copyright (c) 1999-2000  The XFree86 Project, Inc.
 */

/* THIS IS NOT AN X CONSORTIUM STANDARD */

/*
 * Big fonts suffer from the following: All clients that have opened a
 * font can access the complete glyph metrics array (the XFontStruct member
 * `per_char') directly, without going through a macro. Moreover these
 * glyph metrics are ink metrics, i.e. are not redundant even for a
 * fixed-width font. For a Unicode font, the size of this array is 768 KB.
 *
 * Problems: 1. It eats a lot of memory in each client. 2. All this glyph
 * metrics data is piped through the socket when the font is opened.
 *
 * This extension addresses these two problems for local clients, by using
 * shared memory. It also addresses the second problem for non-local clients,
 * by compressing the data before transmit by a factor of nearly 6.
 *
 * If you use this extension, your OS ought to nicely support shared memory.
 * This means: Shared memory should be swappable to the swap, and the limits
 * should be high enough (SHMMNI at least 64, SHMMAX at least 768 KB,
 * SHMALL at least 48 MB). It is a plus if your OS allows shmat() calls
 * on segments that have already been marked "removed", because it permits
 * these segments to be cleaned up by the OS if the X server is killed with
 * signal SIGKILL.
 *
 * This extension is transparently exploited by Xlib (functions XQueryFont,
 * XLoadQueryFont).
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/types.h>
#ifdef HAS_SHM
#if defined(linux) && (!defined(__GNU_LIBRARY__) || __GNU_LIBRARY__ < 2)
/* libc4 does not define __GNU_LIBRARY__, libc5 defines __GNU_LIBRARY__ as 1 */
/* Linux libc4 and libc5 only (because glibc doesn't include kernel headers):
   Linux 2.0.x and 2.2.x define SHMLBA as PAGE_SIZE, but forget to define
   PAGE_SIZE. It is defined in <asm/page.h>. */
#include <asm/page.h>
#endif
#ifdef SVR4
#include <sys/sysmacros.h>
#endif
#if defined(__CYGWIN__) 
#include <sys/param.h>
#include <sys/sysmacros.h>
#endif
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "dixfontstr.h"
#include "extnsionst.h"
#include "protocol-versions.h"

#include <X11/extensions/xf86bigfproto.h>
#include "xf86bigfontsrv.h"

static void XF86BigfontResetProc(
    ExtensionEntry *	/* extEntry */
    );


#ifdef HAS_SHM

/* A random signature, transmitted to the clients so they can verify that the
   shared memory segment they are attaching to was really established by the
   X server they are talking to. */
static CARD32 signature;

/* Index for additional information stored in a FontRec's devPrivates array. */
static int FontShmdescIndex;

static unsigned int pagesize;

static Bool badSysCall = FALSE;

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__) || defined(__DragonFly__)

#include <sys/signal.h>

static void
SigSysHandler(
     int signo)
{
    badSysCall = TRUE;
}

static Bool
CheckForShmSyscall(void)
{
    void (*oldHandler)(int);
    int shmid = -1;

    /* If no SHM support in the kernel, the bad syscall will generate SIGSYS */
    oldHandler = signal(SIGSYS, SigSysHandler);

    badSysCall = FALSE;
    shmid = shmget(IPC_PRIVATE, 4096, IPC_CREAT);
    if (shmid != -1)
    {
        /* Successful allocation - clean up */
	shmctl(shmid, IPC_RMID, NULL);
    }
    else
    {
        /* Allocation failed */
        badSysCall = TRUE;
    }
    signal(SIGSYS, oldHandler);
    return !badSysCall;
}

#define MUST_CHECK_FOR_SHM_SYSCALL

#endif

#endif

/* ========== Management of shared memory segments ========== */

#ifdef HAS_SHM

#ifdef __linux__
/* On Linux, shared memory marked as "removed" can still be attached.
   Nice feature, because the kernel will automatically free the associated
   storage when the server and all clients are gone. */
#define EARLY_REMOVE
#endif

typedef struct _ShmDesc {
    struct _ShmDesc *next;
    struct _ShmDesc **prev;
    int shmid;
    char *attach_addr;
} ShmDescRec, *ShmDescPtr;

static ShmDescPtr ShmList = (ShmDescPtr) NULL;

static ShmDescPtr
shmalloc(
    unsigned int size)
{
    ShmDescPtr pDesc;
    int shmid;
    char *addr;

#ifdef MUST_CHECK_FOR_SHM_SYSCALL
    if (pagesize == 0)
	return (ShmDescPtr) NULL;
#endif

    /* On some older Linux systems, the number of shared memory segments
       system-wide is 127. In Linux 2.4, it is 4095.
       Therefore there is a tradeoff to be made between allocating a
       shared memory segment on one hand, and allocating memory and piping
       the glyph metrics on the other hand. If the glyph metrics size is
       small, we prefer the traditional way. */
    if (size < 3500)
	return (ShmDescPtr) NULL;

    pDesc = malloc(sizeof(ShmDescRec));
    if (!pDesc)
	return (ShmDescPtr) NULL;

    size = (size + pagesize-1) & -pagesize;
    shmid = shmget(IPC_PRIVATE, size, S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH);
    if (shmid == -1) {
	ErrorF(XF86BIGFONTNAME " extension: shmget() failed, size = %u, %s\n",
	       size, strerror(errno));
	free(pDesc);
	return (ShmDescPtr) NULL;
    }

    if ((addr = shmat(shmid, 0, 0)) == (char *)-1) {
	ErrorF(XF86BIGFONTNAME " extension: shmat() failed, size = %u, %s\n",
	       size, strerror(errno));
	shmctl(shmid, IPC_RMID, (void *) 0);
	free(pDesc);
	return (ShmDescPtr) NULL;
    }

#ifdef EARLY_REMOVE
    shmctl(shmid, IPC_RMID, (void *) 0);
#endif

    pDesc->shmid = shmid;
    pDesc->attach_addr = addr;
    if (ShmList) ShmList->prev = &pDesc->next;
    pDesc->next = ShmList;
    pDesc->prev = &ShmList;
    ShmList = pDesc;

    return pDesc;
}

static void
shmdealloc(
    ShmDescPtr pDesc)
{
#ifndef EARLY_REMOVE
    shmctl(pDesc->shmid, IPC_RMID, (void *) 0);
#endif
    shmdt(pDesc->attach_addr);

    if (pDesc->next) pDesc->next->prev = pDesc->prev;
    *pDesc->prev = pDesc->next;
    free(pDesc);
}

#endif

/* Called when a font is closed. */
void
XF86BigfontFreeFontShm(
    FontPtr pFont)
{
#ifdef HAS_SHM
    ShmDescPtr pDesc;

    /* If during shutdown of the server, XF86BigfontCleanup() has already
     * called shmdealloc() for all segments, we don't need to do it here.
     */
    if (!ShmList)
	return;

    pDesc = (ShmDescPtr) FontGetPrivate(pFont, FontShmdescIndex);
    if (pDesc)
	shmdealloc(pDesc);
#endif
}

/* Called upon fatal signal. */
void
XF86BigfontCleanup(void)
{
#ifdef HAS_SHM
    while (ShmList)
	shmdealloc(ShmList);
#endif
}

/* Called when a server generation dies. */
static void
XF86BigfontResetProc(
    ExtensionEntry* extEntry)
{
    /* This function is normally called from CloseDownExtensions(), called
     * from main(). It will be followed by a call to FreeAllResources(),
     * which will call XF86BigfontFreeFontShm() for each font. Thus it
     * appears that we do not need to do anything in this function. --
     * But I prefer to write robust code, and not keep shared memory lying
     * around when it's not needed any more. (Someone might close down the
     * extension without calling FreeAllResources()...)
     */
    XF86BigfontCleanup();
}


/* ========== Handling of extension specific requests ========== */

static int
ProcXF86BigfontQueryVersion(
    ClientPtr client)
{
    xXF86BigfontQueryVersionReply reply;

    REQUEST_SIZE_MATCH(xXF86BigfontQueryVersionReq);
    reply.type = X_Reply;
    reply.length = 0;
    reply.sequenceNumber = client->sequence;
    reply.majorVersion = SERVER_XF86BIGFONT_MAJOR_VERSION;
    reply.minorVersion = SERVER_XF86BIGFONT_MINOR_VERSION;
    reply.uid = geteuid();
    reply.gid = getegid();
#ifdef HAS_SHM
    reply.signature = signature;
#else
    reply.signature = 0; /* This is redundant. Avoids uninitialized memory. */
#endif
    reply.capabilities =
#ifdef HAS_SHM
	(LocalClient(client) && !client->swapped ? XF86Bigfont_CAP_LocalShm : 0)
#else
	0
#endif
	; /* may add more bits here in future versions */
    if (client->swapped) {
	char tmp;
	swaps(&reply.sequenceNumber, tmp);
	swapl(&reply.length, tmp);
	swaps(&reply.majorVersion, tmp);
	swaps(&reply.minorVersion, tmp);
	swapl(&reply.uid, tmp);
	swapl(&reply.gid, tmp);
	swapl(&reply.signature, tmp);
    }
    WriteToClient(client,
		  sizeof(xXF86BigfontQueryVersionReply), (char *)&reply);
    return Success;
}

static void
swapCharInfo(
    xCharInfo *pCI)
{
    char tmp;

    swaps(&pCI->leftSideBearing, tmp);
    swaps(&pCI->rightSideBearing, tmp);
    swaps(&pCI->characterWidth, tmp);
    swaps(&pCI->ascent, tmp);
    swaps(&pCI->descent, tmp);
    swaps(&pCI->attributes, tmp);
}

/* static CARD32 hashCI (xCharInfo *p); */
#define hashCI(p) \
	(CARD32)(((p->leftSideBearing << 27) + (p->leftSideBearing >> 5) + \
	          (p->rightSideBearing << 23) + (p->rightSideBearing >> 9) + \
	          (p->characterWidth << 16) + \
	          (p->ascent << 11) + (p->descent << 6)) ^ p->attributes)

static int
ProcXF86BigfontQueryFont(
    ClientPtr client)
{
    FontPtr pFont;
    REQUEST(xXF86BigfontQueryFontReq);
    CARD32 stuff_flags;
    xCharInfo* pmax;
    xCharInfo* pmin;
    int nCharInfos;
    int shmid;
#ifdef HAS_SHM
    ShmDescPtr pDesc = NULL;
#else
#define pDesc 0
#endif
    xCharInfo* pCI;
    CARD16* pIndex2UniqIndex;
    CARD16* pUniqIndex2Index;
    CARD32 nUniqCharInfos;

#if 0
    REQUEST_SIZE_MATCH(xXF86BigfontQueryFontReq);
#else
    switch (client->req_len) {
	case 2: /* client with version 1.0 libX11 */
	    stuff_flags = (LocalClient(client) && !client->swapped ? XF86Bigfont_FLAGS_Shm : 0);
	    break;
	case 3: /* client with version 1.1 libX11 */
	    stuff_flags = stuff->flags;
	    break;
	default:
	    return BadLength;
    }
#endif
    if (dixLookupFontable(&pFont, stuff->id, client, DixGetAttrAccess) != Success)
	return BadFont;    /* procotol spec says only error is BadFont */

    pmax = FONTINKMAX(pFont);
    pmin = FONTINKMIN(pFont);
    nCharInfos =
       (pmax->rightSideBearing == pmin->rightSideBearing
        && pmax->leftSideBearing == pmin->leftSideBearing
        && pmax->descent == pmin->descent
        && pmax->ascent == pmin->ascent
        && pmax->characterWidth == pmin->characterWidth)
       ? 0 : N2dChars(pFont);
    shmid = -1;
    pCI = NULL;
    pIndex2UniqIndex = NULL;
    pUniqIndex2Index = NULL;
    nUniqCharInfos = 0;

    if (nCharInfos > 0) {
#ifdef HAS_SHM
	if (!badSysCall)
	    pDesc = (ShmDescPtr) FontGetPrivate(pFont, FontShmdescIndex);
	if (pDesc) {
	    pCI = (xCharInfo *) pDesc->attach_addr;
	    if (stuff_flags & XF86Bigfont_FLAGS_Shm)
		shmid = pDesc->shmid;
	} else {
	    if (stuff_flags & XF86Bigfont_FLAGS_Shm && !badSysCall)
		pDesc = shmalloc(nCharInfos * sizeof(xCharInfo)
				 + sizeof(CARD32));
	    if (pDesc) {
		pCI = (xCharInfo *) pDesc->attach_addr;
		shmid = pDesc->shmid;
	    } else {
#endif
		pCI = malloc(nCharInfos * sizeof(xCharInfo));
		if (!pCI)
		    return BadAlloc;
#ifdef HAS_SHM
	    }
#endif
	    /* Fill nCharInfos starting at pCI. */
	    {
		xCharInfo* prCI = pCI;
		int ninfos = 0;
		int ncols = pFont->info.lastCol - pFont->info.firstCol + 1;
		int row;
		for (row = pFont->info.firstRow;
		     row <= pFont->info.lastRow && ninfos < nCharInfos;
		     row++) {
		    unsigned char chars[512];
		    xCharInfo* tmpCharInfos[256];
		    unsigned long count;
		    int col;
		    unsigned long i;
		    i = 0;
		    for (col = pFont->info.firstCol;
			 col <= pFont->info.lastCol;
			 col++) {
			chars[i++] = row;
			chars[i++] = col;
		    }
		    (*pFont->get_metrics) (pFont, ncols, chars, TwoD16Bit,
					   &count, tmpCharInfos);
		    for (i = 0; i < count && ninfos < nCharInfos; i++) {
			*prCI++ = *tmpCharInfos[i];
			ninfos++;
		    }
		}
	    }
#ifdef HAS_SHM
	    if (pDesc && !badSysCall) {
		*(CARD32 *)(pCI + nCharInfos) = signature;
		if (!FontSetPrivate(pFont, FontShmdescIndex, pDesc)) {
		    shmdealloc(pDesc);
		    return BadAlloc;
		}
	    }
	}
#endif
	if (shmid == -1) {
	    /* Cannot use shared memory, so remove-duplicates the xCharInfos
	       using a temporary hash table. */
	    /* Note that CARD16 is suitable as index type, because
	       nCharInfos <= 0x10000. */
	    CARD32 hashModulus;
	    CARD16* pHash2UniqIndex;
	    CARD16* pUniqIndex2NextUniqIndex;
	    CARD32 NextIndex;
	    CARD32 NextUniqIndex;
	    CARD16* tmp;
	    CARD32 i, j;

	    hashModulus = 67;
	    if (hashModulus > nCharInfos+1)
		hashModulus = nCharInfos+1;

	    tmp = malloc((4*nCharInfos+1) * sizeof(CARD16));
	    if (!tmp) {
		if (!pDesc) free(pCI);
		return BadAlloc;
	    }
	    pIndex2UniqIndex = tmp;
		/* nCharInfos elements */
	    pUniqIndex2Index = tmp + nCharInfos;
		/* max. nCharInfos elements */
	    pUniqIndex2NextUniqIndex = tmp + 2*nCharInfos;
		/* max. nCharInfos elements */
	    pHash2UniqIndex = tmp + 3*nCharInfos;
		/* hashModulus (<= nCharInfos+1) elements */

	    /* Note that we can use 0xffff as end-of-list indicator, because
	       even if nCharInfos = 0x10000, 0xffff can not occur as valid
	       entry before the last element has been inserted. And once the
	       last element has been inserted, we don't need the hash table
	       any more. */
	    for (j = 0; j < hashModulus; j++)
		pHash2UniqIndex[j] = (CARD16)(-1);

	    NextUniqIndex = 0;
	    for (NextIndex = 0; NextIndex < nCharInfos; NextIndex++) {
		xCharInfo* p = &pCI[NextIndex];
		CARD32 hashCode = hashCI(p) % hashModulus;
		for (i = pHash2UniqIndex[hashCode];
		     i != (CARD16)(-1);
		     i = pUniqIndex2NextUniqIndex[i]) {
		    j = pUniqIndex2Index[i];
		    if (pCI[j].leftSideBearing == p->leftSideBearing
			&& pCI[j].rightSideBearing == p->rightSideBearing
			&& pCI[j].characterWidth == p->characterWidth
			&& pCI[j].ascent == p->ascent
			&& pCI[j].descent == p->descent
			&& pCI[j].attributes == p->attributes)
			break;
		}
		if (i != (CARD16)(-1)) {
		    /* Found *p at Index j, UniqIndex i */
		    pIndex2UniqIndex[NextIndex] = i;
		} else {
		    /* Allocate a new entry in the Uniq table */
		    if (hashModulus <= 2*NextUniqIndex
			&& hashModulus < nCharInfos+1) {
			/* Time to increate hash table size */
			hashModulus = 2*hashModulus+1;
			if (hashModulus > nCharInfos+1)
			    hashModulus = nCharInfos+1;
			for (j = 0; j < hashModulus; j++)
			    pHash2UniqIndex[j] = (CARD16)(-1);
			for (i = 0; i < NextUniqIndex; i++)
			    pUniqIndex2NextUniqIndex[i] = (CARD16)(-1);
			for (i = 0; i < NextUniqIndex; i++) {
			    j = pUniqIndex2Index[i];
			    p = &pCI[j];
			    hashCode = hashCI(p) % hashModulus;
			    pUniqIndex2NextUniqIndex[i] = pHash2UniqIndex[hashCode];
			    pHash2UniqIndex[hashCode] = i;
			}
			p = &pCI[NextIndex];
			hashCode = hashCI(p) % hashModulus;
		    }
		    i = NextUniqIndex++;
		    pUniqIndex2NextUniqIndex[i] = pHash2UniqIndex[hashCode];
		    pHash2UniqIndex[hashCode] = i;
		    pUniqIndex2Index[i] = NextIndex;
		    pIndex2UniqIndex[NextIndex] = i;
		}
	    }
	    nUniqCharInfos = NextUniqIndex;
	    /* fprintf(stderr, "font metrics: nCharInfos = %d, nUniqCharInfos = %d, hashModulus = %d\n", nCharInfos, nUniqCharInfos, hashModulus); */
	}
    }

    {
	int nfontprops = pFont->info.nprops;
	int rlength =
	   sizeof(xXF86BigfontQueryFontReply)
	   + nfontprops * sizeof(xFontProp)
	   + (nCharInfos > 0 && shmid == -1
	      ? nUniqCharInfos * sizeof(xCharInfo)
	        + (nCharInfos+1)/2 * 2 * sizeof(CARD16)
	      : 0);
	xXF86BigfontQueryFontReply* reply = malloc(rlength);
	char* p;
	if (!reply) {
	    if (nCharInfos > 0) {
		if (shmid == -1) free(pIndex2UniqIndex);
		if (!pDesc) free(pCI);
	    }
	    return BadAlloc;
	}
	reply->type = X_Reply;
	reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
	reply->sequenceNumber = client->sequence;
	reply->minBounds = pFont->info.ink_minbounds;
	reply->maxBounds = pFont->info.ink_maxbounds;
	reply->minCharOrByte2 = pFont->info.firstCol;
	reply->maxCharOrByte2 = pFont->info.lastCol;
	reply->defaultChar = pFont->info.defaultCh;
	reply->nFontProps = pFont->info.nprops;
	reply->drawDirection = pFont->info.drawDirection;
	reply->minByte1 = pFont->info.firstRow;
	reply->maxByte1 = pFont->info.lastRow;
	reply->allCharsExist = pFont->info.allExist;
	reply->fontAscent = pFont->info.fontAscent;
	reply->fontDescent = pFont->info.fontDescent;
	reply->nCharInfos = nCharInfos;
        reply->nUniqCharInfos = nUniqCharInfos;
	reply->shmid = shmid;
	reply->shmsegoffset = 0;
	if (client->swapped) {
	    char tmp;
	    swaps(&reply->sequenceNumber, tmp);
	    swapl(&reply->length, tmp);
	    swapCharInfo(&reply->minBounds);
	    swapCharInfo(&reply->maxBounds);
	    swaps(&reply->minCharOrByte2, tmp);
	    swaps(&reply->maxCharOrByte2, tmp);
	    swaps(&reply->defaultChar, tmp);
	    swaps(&reply->nFontProps, tmp);
	    swaps(&reply->fontAscent, tmp);
	    swaps(&reply->fontDescent, tmp);
	    swapl(&reply->nCharInfos, tmp);
	    swapl(&reply->nUniqCharInfos, tmp);
	    swapl(&reply->shmid, tmp);
	    swapl(&reply->shmsegoffset, tmp);
	}
	p = (char*) &reply[1];
	{
	    FontPropPtr pFP;
	    xFontProp* prFP;
	    int i;
	    for (i = 0, pFP = pFont->info.props, prFP = (xFontProp *) p;
		 i < nfontprops;
		 i++, pFP++, prFP++) {
		prFP->name = pFP->name;
		prFP->value = pFP->value;
		if (client->swapped) {
		    char tmp;
		    swapl(&prFP->name, tmp);
		    swapl(&prFP->value, tmp);
		}
	    }
	    p = (char*) prFP;
	}
	if (nCharInfos > 0 && shmid == -1) {
	    xCharInfo* pci;
	    CARD16* ps;
	    int i, j;
	    pci = (xCharInfo*) p;
	    for (i = 0; i < nUniqCharInfos; i++, pci++) {
		*pci = pCI[pUniqIndex2Index[i]];
		if (client->swapped)
		    swapCharInfo(pci);
	    }
	    ps = (CARD16*) pci;
	    for (j = 0; j < nCharInfos; j++, ps++) {
		*ps = pIndex2UniqIndex[j];
		if (client->swapped) {
		    char tmp;
		    swaps(ps, tmp);
		}
	    }
	}
	WriteToClient(client, rlength, (char *)reply);
	free(reply);
	if (nCharInfos > 0) {
	    if (shmid == -1) free(pIndex2UniqIndex);
	    if (!pDesc) free(pCI);
	}
	return Success;
    }
}

static int
ProcXF86BigfontDispatch(
    ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
	case X_XF86BigfontQueryVersion:
	    return ProcXF86BigfontQueryVersion(client);
	case X_XF86BigfontQueryFont:
	    return ProcXF86BigfontQueryFont(client);
	default:
	    return BadRequest;
    }
}

static int
SProcXF86BigfontQueryVersion(
    ClientPtr client)
{
    REQUEST(xXF86BigfontQueryVersionReq);
    char tmp;

    swaps(&stuff->length, tmp);
    return ProcXF86BigfontQueryVersion(client);
}

static int
SProcXF86BigfontQueryFont(
    ClientPtr client)
{
    REQUEST(xXF86BigfontQueryFontReq);
    char tmp;

    swaps(&stuff->length, tmp);
    REQUEST_SIZE_MATCH(xXF86BigfontQueryFontReq);
    swapl(&stuff->id, tmp);
    return ProcXF86BigfontQueryFont(client);
}

static int
SProcXF86BigfontDispatch(
    ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
	case X_XF86BigfontQueryVersion:
	    return SProcXF86BigfontQueryVersion(client);
	case X_XF86BigfontQueryFont:
	    return SProcXF86BigfontQueryFont(client);
	default:
	    return BadRequest;
    }
}

void
XFree86BigfontExtensionInit(void)
{
    if (AddExtension(XF86BIGFONTNAME,
		     XF86BigfontNumberEvents,
		     XF86BigfontNumberErrors,
		     ProcXF86BigfontDispatch,
		     SProcXF86BigfontDispatch,
		     XF86BigfontResetProc,
		     StandardMinorOpcode)) {
#ifdef HAS_SHM
#ifdef MUST_CHECK_FOR_SHM_SYSCALL
	/*
	 * Note: Local-clients will not be optimized without shared memory
	 * support. Remote-client optimization does not depend on shared
	 * memory support.  Thus, the extension is still registered even
	 * when shared memory support is not functional.
	 */
	if (!CheckForShmSyscall()) {
	    ErrorF(XF86BIGFONTNAME " extension local-client optimization disabled due to lack of shared memory support in the kernel\n");
	    return;
	}
#endif

	srand((unsigned int) time(NULL));
	signature = ((unsigned int) (65536.0/(RAND_MAX+1.0) * rand()) << 16)
	           + (unsigned int) (65536.0/(RAND_MAX+1.0) * rand());
	/* fprintf(stderr, "signature = 0x%08X\n", signature); */

	FontShmdescIndex = AllocateFontPrivateIndex();

#if !defined(CSRG_BASED) && !defined(__CYGWIN__)
	pagesize = SHMLBA;
#else
# ifdef _SC_PAGESIZE
	pagesize = sysconf(_SC_PAGESIZE);
# else
	pagesize = getpagesize();
# endif
#endif
#endif
    }
}
/*
 * Copyright © 2010 Yaakov Selkowitz
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef _XF86BIGFONTSRV_H_
#define _XF86BIGFONTSRV_H_

#include <X11/fonts/font.h>

extern void XFree86BigfontExtensionInit(void);
extern void XF86BigfontFreeFontShm(FontPtr);
extern void XF86BigfontCleanup(void);

#endif
/*
   Copyright (c) 2002  XFree86 Inc
*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <string.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "swaprep.h"
#include "registry.h"
#include <X11/extensions/XResproto.h>
#include "pixmapstr.h"
#include "windowstr.h"
#include "gcstruct.h"
#include "modinit.h"
#include "protocol-versions.h"

static int
ProcXResQueryVersion (ClientPtr client)
{
    REQUEST(xXResQueryVersionReq);
    xXResQueryVersionReply rep;
    CARD16 client_major, client_minor;  /* not used */

    REQUEST_SIZE_MATCH (xXResQueryVersionReq);

    client_major = stuff->client_major;
    client_minor = stuff->client_minor;
    (void) client_major;
    (void) client_minor;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.server_major = SERVER_XRES_MAJOR_VERSION;
    rep.server_minor = SERVER_XRES_MINOR_VERSION;
    if (client->swapped) { 
        int n;
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);     
        swaps(&rep.server_major, n);
        swaps(&rep.server_minor, n);
    }
    WriteToClient(client, sizeof (xXResQueryVersionReply), (char *)&rep);
    return Success;
}

static int
ProcXResQueryClients (ClientPtr client)
{
    /* REQUEST(xXResQueryClientsReq); */
    xXResQueryClientsReply rep;
    int *current_clients;
    int i, num_clients;

    REQUEST_SIZE_MATCH(xXResQueryClientsReq);

    current_clients = malloc(currentMaxClients * sizeof(int));

    num_clients = 0;
    for(i = 0; i < currentMaxClients; i++) {
       if(clients[i]) {
           current_clients[num_clients] = i;
           num_clients++;   
       }
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num_clients = num_clients;
    rep.length = bytes_to_int32(rep.num_clients * sz_xXResClient);
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.num_clients, n);
    }   
    WriteToClient (client, sizeof (xXResQueryClientsReply), (char *) &rep);

    if(num_clients) {
        xXResClient scratch;

        for(i = 0; i < num_clients; i++) {
            scratch.resource_base = clients[current_clients[i]]->clientAsMask;
            scratch.resource_mask = RESOURCE_ID_MASK;
        
            if(client->swapped) {
                int n;
                swapl (&scratch.resource_base, n);
                swapl (&scratch.resource_mask, n);
            }
            WriteToClient (client, sz_xXResClient, (char *) &scratch);
        }
    }

    free(current_clients);

    return Success;
}


static void
ResFindAllRes (pointer value, XID id, RESTYPE type, pointer cdata)
{
    int *counts = (int *)cdata;

    counts[(type & TypeMask) - 1]++;
}

static int
ProcXResQueryClientResources (ClientPtr client)
{
    REQUEST(xXResQueryClientResourcesReq);
    xXResQueryClientResourcesReply rep;
    int i, clientID, num_types;
    int *counts;

    REQUEST_SIZE_MATCH(xXResQueryClientResourcesReq);

    clientID = CLIENT_ID(stuff->xid);

    if((clientID >= currentMaxClients) || !clients[clientID]) {
        client->errorValue = stuff->xid;
        return BadValue;
    }

    counts = calloc(lastResourceType + 1, sizeof(int));

    FindAllClientResources(clients[clientID], ResFindAllRes, counts);

    num_types = 0;

    for(i = 0; i <= lastResourceType; i++) {
       if(counts[i]) num_types++;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num_types = num_types;
    rep.length = bytes_to_int32(rep.num_types * sz_xXResType);
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.num_types, n);
    }   

    WriteToClient (client,sizeof(xXResQueryClientResourcesReply),(char*)&rep);

    if(num_types) {
        xXResType scratch;
	char *name;

        for(i = 0; i < lastResourceType; i++) {
            if(!counts[i]) continue;

	    name = (char *)LookupResourceName(i + 1);
            if (strcmp(name, XREGISTRY_UNKNOWN))
		scratch.resource_type = MakeAtom(name, strlen(name), TRUE);
	    else {
                char buf[40];
                snprintf(buf, sizeof(buf), "Unregistered resource %i", i + 1);
		scratch.resource_type = MakeAtom(buf, strlen(buf), TRUE);
            }

            scratch.count = counts[i];

            if(client->swapped) {
                int n;
                swapl (&scratch.resource_type, n);
                swapl (&scratch.count, n);
            }
            WriteToClient (client, sz_xXResType, (char *) &scratch);
        }
    }

    free(counts);
    
    return Success;
}

static unsigned long
ResGetApproxPixmapBytes (PixmapPtr pix)
{
   unsigned long nPixels;
   int           bytesPerPixel; 

   bytesPerPixel = pix->drawable.bitsPerPixel>>3;
   nPixels       = pix->drawable.width * pix->drawable.height;

   /* Divide by refcnt as pixmap could be shared between clients,  
    * so total pixmap mem is shared between these. 
   */
   return ( nPixels * bytesPerPixel ) / pix->refcnt;
}

static void 
ResFindPixmaps (pointer value, XID id, pointer cdata)
{
   unsigned long *bytes = (unsigned long *)cdata;
   PixmapPtr pix = (PixmapPtr)value;

   *bytes += ResGetApproxPixmapBytes(pix);
}

static void
ResFindWindowPixmaps (pointer value, XID id, pointer cdata)
{
   unsigned long *bytes = (unsigned long *)cdata;
   WindowPtr pWin = (WindowPtr)value;

   if (pWin->backgroundState == BackgroundPixmap)
     *bytes += ResGetApproxPixmapBytes(pWin->background.pixmap);

   if (pWin->border.pixmap != NULL && !pWin->borderIsPixel)
     *bytes += ResGetApproxPixmapBytes(pWin->border.pixmap);
}

static void
ResFindGCPixmaps (pointer value, XID id, pointer cdata)
{
   unsigned long *bytes = (unsigned long *)cdata;
   GCPtr pGC = (GCPtr)value;

   if (pGC->stipple != NULL)
     *bytes += ResGetApproxPixmapBytes(pGC->stipple);

   if (pGC->tile.pixmap != NULL && !pGC->tileIsPixel)
     *bytes += ResGetApproxPixmapBytes(pGC->tile.pixmap);
}

static int
ProcXResQueryClientPixmapBytes (ClientPtr client)
{
    REQUEST(xXResQueryClientPixmapBytesReq);
    xXResQueryClientPixmapBytesReply rep;
    int clientID;
    unsigned long bytes;

    REQUEST_SIZE_MATCH(xXResQueryClientPixmapBytesReq);

    clientID = CLIENT_ID(stuff->xid);

    if((clientID >= currentMaxClients) || !clients[clientID]) {
        client->errorValue = stuff->xid;
        return BadValue;
    }

    bytes = 0;

    FindClientResourcesByType(clients[clientID], RT_PIXMAP, ResFindPixmaps, 
                              (pointer)(&bytes));

    /* 
     * Make sure win background pixmaps also held to account. 
     */
    FindClientResourcesByType(clients[clientID], RT_WINDOW, 
			      ResFindWindowPixmaps, 
                              (pointer)(&bytes));

    /* 
     * GC Tile & Stipple pixmaps too.
    */
    FindClientResourcesByType(clients[clientID], RT_GC, 
			      ResFindGCPixmaps, 
                              (pointer)(&bytes));

#ifdef COMPOSITE
    /* FIXME: include composite pixmaps too */
#endif

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.bytes = bytes;
#ifdef _XSERVER64
    rep.bytes_overflow = bytes >> 32;
#else
    rep.bytes_overflow = 0;
#endif
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.bytes, n);
        swapl (&rep.bytes_overflow, n);
    }
    WriteToClient (client,sizeof(xXResQueryClientPixmapBytesReply),(char*)&rep);

    return Success;
}

static int
ProcResDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_XResQueryVersion:
        return ProcXResQueryVersion(client);
    case X_XResQueryClients:
        return ProcXResQueryClients(client);
    case X_XResQueryClientResources:
        return ProcXResQueryClientResources(client);
    case X_XResQueryClientPixmapBytes:
        return ProcXResQueryClientPixmapBytes(client);
    default: break;
    }

    return BadRequest;
}

static int
SProcXResQueryVersion (ClientPtr client)
{
    REQUEST(xXResQueryVersionReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryVersionReq);
    swaps(&stuff->client_major,n);
    swaps(&stuff->client_minor,n);
    return ProcXResQueryVersion(client);
}

static int
SProcXResQueryClientResources (ClientPtr client)
{
    REQUEST(xXResQueryClientResourcesReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryClientResourcesReq);
    swaps(&stuff->xid,n);
    return ProcXResQueryClientResources(client);
}

static int
SProcXResQueryClientPixmapBytes (ClientPtr client)
{
    REQUEST(xXResQueryClientPixmapBytesReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryClientPixmapBytesReq);
    swaps(&stuff->xid,n);
    return ProcXResQueryClientPixmapBytes(client);
}

static int
SProcResDispatch (ClientPtr client)
{
    REQUEST(xReq);
    int n;

    swaps(&stuff->length,n);

    switch (stuff->data) {
    case X_XResQueryVersion:
        return SProcXResQueryVersion(client);
    case X_XResQueryClients:  /* nothing to swap */
        return ProcXResQueryClients(client);
    case X_XResQueryClientResources:
        return SProcXResQueryClientResources(client);
    case X_XResQueryClientPixmapBytes:
        return SProcXResQueryClientPixmapBytes(client);
    default: break;
    }

    return BadRequest;
}

void
ResExtensionInit(INITARGS)
{
    (void) AddExtension(XRES_NAME, 0, 0,
                            ProcResDispatch, SProcResDispatch,
                            NULL, StandardMinorOpcode);
}
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifndef _XSELINUX_H
#define _XSELINUX_H

/* Extension info */
#define SELINUX_EXTENSION_NAME		"SELinux"
#define SELINUX_MAJOR_VERSION		1
#define SELINUX_MINOR_VERSION		1
#define SELinuxNumberEvents		0
#define SELinuxNumberErrors		0

/* Extension protocol */
#define X_SELinuxQueryVersion			0
#define X_SELinuxSetDeviceCreateContext		1
#define X_SELinuxGetDeviceCreateContext		2
#define X_SELinuxSetDeviceContext		3
#define X_SELinuxGetDeviceContext		4
#define X_SELinuxSetDrawableCreateContext	5
#define X_SELinuxGetDrawableCreateContext	6
#define X_SELinuxGetDrawableContext		7
#define X_SELinuxSetPropertyCreateContext	8
#define X_SELinuxGetPropertyCreateContext	9
#define X_SELinuxSetPropertyUseContext		10
#define X_SELinuxGetPropertyUseContext		11
#define X_SELinuxGetPropertyContext		12
#define X_SELinuxGetPropertyDataContext		13
#define X_SELinuxListProperties			14
#define X_SELinuxSetSelectionCreateContext	15
#define X_SELinuxGetSelectionCreateContext	16
#define X_SELinuxSetSelectionUseContext		17
#define X_SELinuxGetSelectionUseContext		18
#define X_SELinuxGetSelectionContext		19
#define X_SELinuxGetSelectionDataContext	20
#define X_SELinuxListSelections			21
#define X_SELinuxGetClientContext		22

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD8   client_major;
    CARD8   client_minor;
} SELinuxQueryVersionReq;

typedef struct {
    CARD8   type;
    CARD8   pad1;
    CARD16  sequenceNumber;
    CARD32  length;
    CARD16  server_major;
    CARD16  server_minor;
    CARD32  pad2;
    CARD32  pad3;
    CARD32  pad4;
    CARD32  pad5;
    CARD32  pad6; 
} SELinuxQueryVersionReply;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD32  context_len;
} SELinuxSetCreateContextReq;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
} SELinuxGetCreateContextReq;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD32  id;
    CARD32  context_len;
} SELinuxSetContextReq;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD32  id;
} SELinuxGetContextReq;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD32  window;
    CARD32  property;
} SELinuxGetPropertyContextReq;

typedef struct {
    CARD8   type;
    CARD8   pad1;
    CARD16  sequenceNumber;
    CARD32  length;
    CARD32  context_len;
    CARD32  pad2;
    CARD32  pad3;
    CARD32  pad4;
    CARD32  pad5;
    CARD32  pad6;
} SELinuxGetContextReply;

typedef struct {
    CARD8   type;
    CARD8   pad1;
    CARD16  sequenceNumber;
    CARD32  length;
    CARD32  count;
    CARD32  pad2;
    CARD32  pad3;
    CARD32  pad4;
    CARD32  pad5;
    CARD32  pad6;
} SELinuxListItemsReply;

#endif /* _XSELINUX_H */
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifndef _XSELINUXINT_H
#define _XSELINUXINT_H

#include <selinux/selinux.h>
#include <selinux/avc.h>

#include "globals.h"
#include "dixaccess.h"
#include "dixstruct.h"
#include "privates.h"
#include "resource.h"
#include "registry.h"
#include "inputstr.h"
#include "xselinux.h"

/*
 * Types
 */

#define COMMAND_LEN 64

/* subject state (clients and devices only) */
typedef struct {
    security_id_t sid;
    security_id_t dev_create_sid;
    security_id_t win_create_sid;
    security_id_t sel_create_sid;
    security_id_t prp_create_sid;
    security_id_t sel_use_sid;
    security_id_t prp_use_sid;
    struct avc_entry_ref aeref;
    char command[COMMAND_LEN];
    int privileged;
} SELinuxSubjectRec;

/* object state */
typedef struct {
    security_id_t sid;
    int poly;
} SELinuxObjectRec;

/*
 * Globals
 */

extern DevPrivateKeyRec subjectKeyRec;
#define subjectKey (&subjectKeyRec)
extern DevPrivateKeyRec objectKeyRec;
#define objectKey (&objectKeyRec)
extern DevPrivateKeyRec dataKeyRec;
#define dataKey (&dataKeyRec)

/*
 * Label functions
 */

int
SELinuxAtomToSID(Atom atom, int prop, SELinuxObjectRec **obj_rtn);

int
SELinuxSelectionToSID(Atom selection, SELinuxSubjectRec *subj,
		      security_id_t *sid_rtn, int *poly_rtn);

int
SELinuxPropertyToSID(Atom property, SELinuxSubjectRec *subj,
		     security_id_t *sid_rtn, int *poly_rtn);

int
SELinuxEventToSID(unsigned type, security_id_t sid_of_window,
		  SELinuxObjectRec *sid_return);

int
SELinuxExtensionToSID(const char *name, security_id_t *sid_rtn);

security_class_t
SELinuxTypeToClass(RESTYPE type);

security_context_t
SELinuxDefaultClientLabel(void);

void
SELinuxLabelInit(void);

void
SELinuxLabelReset(void);

/*
 * Security module functions
 */

void
SELinuxFlaskInit(void);

void
SELinuxFlaskReset(void);


/*
 * Private Flask definitions
 */

/* Security class constants */
#define SECCLASS_X_DRAWABLE		1
#define SECCLASS_X_SCREEN		2
#define SECCLASS_X_GC			3
#define SECCLASS_X_FONT			4
#define SECCLASS_X_COLORMAP		5
#define SECCLASS_X_PROPERTY		6
#define SECCLASS_X_SELECTION		7
#define SECCLASS_X_CURSOR		8
#define SECCLASS_X_CLIENT		9
#define SECCLASS_X_POINTER		10
#define SECCLASS_X_KEYBOARD		11
#define SECCLASS_X_SERVER		12
#define SECCLASS_X_EXTENSION		13
#define SECCLASS_X_EVENT		14
#define SECCLASS_X_FAKEEVENT		15
#define SECCLASS_X_RESOURCE		16

#ifdef _XSELINUX_NEED_FLASK_MAP
/* Mapping from DixAccess bits to Flask permissions */
static struct security_class_mapping map[] = {
    { "x_drawable",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "list_property",	/* DixListPropAccess */
          "get_property",	/* DixGetPropAccess */
          "set_property",	/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "list_child",		/* DixListAccess */
          "add_child",		/* DixAddAccess */
          "remove_child",	/* DixRemoveAccess */
          "hide",		/* DixHideAccess */
          "show",		/* DixShowAccess */
          "blend",		/* DixBlendAccess */
          "override",		/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "send",		/* DixSendAccess */
          "receive",		/* DixReceiveAccess */
          "",			/* DixUseAccess */
          "manage",		/* DixManageAccess */
          NULL }},
    { "x_screen",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "saver_getattr",	/* DixListPropAccess */
          "saver_setattr",	/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "hide_cursor",	/* DixHideAccess */
          "show_cursor",	/* DixShowAccess */
          "saver_hide",		/* DixBlendAccess */
          "saver_show",		/* DixGrabAccess */
          NULL }},
    { "x_gc",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_font",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "add_glyph",		/* DixAddAccess */
          "remove_glyph",	/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_colormap",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "add_color",		/* DixAddAccess */
          "remove_color",	/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "install",		/* DixInstallAccess */
          "uninstall",		/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_property",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "write",		/* DixBlendAccess */
          NULL }},
    { "x_selection",
        { "read",		/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "setattr",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          NULL }},
    { "x_cursor",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_client",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "",			/* DixUseAccess */
          "manage",		/* DixManageAccess */
          NULL }},
    { "x_pointer",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "list_property",	/* DixListPropAccess */
          "get_property",	/* DixGetPropAccess */
          "set_property",	/* DixSetPropAccess */
          "getfocus",		/* DixGetFocusAccess */
          "setfocus",		/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "add",		/* DixAddAccess */
          "remove",		/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "grab",		/* DixGrabAccess */
          "freeze",		/* DixFreezeAccess */
          "force_cursor",	/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          "manage",		/* DixManageAccess */
          "",			/* DixDebugAccess */
          "bell",		/* DixBellAccess */
          NULL }},
    { "x_keyboard",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "list_property",	/* DixListPropAccess */
          "get_property",	/* DixGetPropAccess */
          "set_property",	/* DixSetPropAccess */
          "getfocus",		/* DixGetFocusAccess */
          "setfocus",		/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "add",		/* DixAddAccess */
          "remove",		/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "grab",		/* DixGrabAccess */
          "freeze",		/* DixFreezeAccess */
          "force_cursor",	/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          "manage",		/* DixManageAccess */
          "",			/* DixDebugAccess */
          "bell",		/* DixBellAccess */
          NULL }},
    { "x_server",
        { "record",		/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "grab",		/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "",			/* DixUseAccess */
          "manage",		/* DixManageAccess */
          "debug",		/* DixDebugAccess */
          NULL }},
    { "x_extension",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "query",		/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_event",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "",			/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "send",		/* DixSendAccess */
          "receive",		/* DixReceiveAccess */
          NULL }},
    { "x_synthetic_event",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "",			/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "send",		/* DixSendAccess */
          "receive",		/* DixReceiveAccess */
          NULL }},
    { "x_resource",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "write",		/* DixDestroyAccess */
          "write",		/* DixCreateAccess */
          "read",		/* DixGetAttrAccess */
          "write",		/* DixSetAttrAccess */
          "read",		/* DixListPropAccess */
          "read",		/* DixGetPropAccess */
          "write",		/* DixSetPropAccess */
          "read",		/* DixGetFocusAccess */
          "write",		/* DixSetFocusAccess */
          "read",		/* DixListAccess */
          "write",		/* DixAddAccess */
          "write",		/* DixRemoveAccess */
          "write",		/* DixHideAccess */
          "read",		/* DixShowAccess */
          "read",		/* DixBlendAccess */
          "write",		/* DixGrabAccess */
          "write",		/* DixFreezeAccess */
          "write",		/* DixForceAccess */
          "write",		/* DixInstallAccess */
          "write",		/* DixUninstallAccess */
          "write",		/* DixSendAccess */
          "read",		/* DixReceiveAccess */
          "read",		/* DixUseAccess */
          "write",		/* DixManageAccess */
          "read",		/* DixDebugAccess */
          "write",		/* DixBellAccess */
          NULL }},
    { NULL }
};

/* x_resource "read" bits from the list above */
#define SELinuxReadMask (DixReadAccess|DixGetAttrAccess|DixListPropAccess| \
			 DixGetPropAccess|DixGetFocusAccess|DixListAccess| \
			 DixShowAccess|DixBlendAccess|DixReceiveAccess| \
			 DixUseAccess|DixDebugAccess)

#endif /* _XSELINUX_NEED_FLASK_MAP */
#endif /* _XSELINUXINT_H */
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "selection.h"
#include "inputstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "extnsionst.h"
#include "modinit.h"
#include "xselinuxint.h"

#define CTX_DEV offsetof(SELinuxSubjectRec, dev_create_sid)
#define CTX_WIN offsetof(SELinuxSubjectRec, win_create_sid)
#define CTX_PRP offsetof(SELinuxSubjectRec, prp_create_sid)
#define CTX_SEL offsetof(SELinuxSubjectRec, sel_create_sid)
#define USE_PRP offsetof(SELinuxSubjectRec, prp_use_sid)
#define USE_SEL offsetof(SELinuxSubjectRec, sel_use_sid)

typedef struct {
    security_context_t octx;
    security_context_t dctx;
    CARD32 octx_len;
    CARD32 dctx_len;
    CARD32 id;
} SELinuxListItemRec;


/*
 * Extension Dispatch
 */

static security_context_t
SELinuxCopyContext(char *ptr, unsigned len)
{
    security_context_t copy = malloc(len + 1);
    if (!copy)
	return NULL;
    strncpy(copy, ptr, len);
    copy[len] = '\0';
    return copy;
}

static int
ProcSELinuxQueryVersion(ClientPtr client)
{
    SELinuxQueryVersionReply rep;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.server_major = SELINUX_MAJOR_VERSION;
    rep.server_minor = SELINUX_MINOR_VERSION;
    if (client->swapped) {
	int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swaps(&rep.server_major, n);
	swaps(&rep.server_minor, n);
    }
    WriteToClient(client, sizeof(rep), (char *)&rep);
    return Success;
}

static int
SELinuxSendContextReply(ClientPtr client, security_id_t sid)
{
    SELinuxGetContextReply rep;
    security_context_t ctx = NULL;
    int len = 0;

    if (sid) {
	if (avc_sid_to_context_raw(sid, &ctx) < 0)
	    return BadValue;
	len = strlen(ctx) + 1;
    }

    rep.type = X_Reply;
    rep.length = bytes_to_int32(len);
    rep.sequenceNumber = client->sequence;
    rep.context_len = len;

    if (client->swapped) {
	int n;
	swapl(&rep.length, n);
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.context_len, n);
    }

    WriteToClient(client, sizeof(SELinuxGetContextReply), (char *)&rep);
    WriteToClient(client, len, ctx);
    freecon(ctx);
    return Success;
}

static int
ProcSELinuxSetCreateContext(ClientPtr client, unsigned offset)
{
    PrivateRec **privPtr = &client->devPrivates;
    security_id_t *pSid;
    security_context_t ctx = NULL;
    char *ptr;
    int rc;

    REQUEST(SELinuxSetCreateContextReq);
    REQUEST_FIXED_SIZE(SELinuxSetCreateContextReq, stuff->context_len);

    if (stuff->context_len > 0) {
	ctx = SELinuxCopyContext((char *)(stuff + 1), stuff->context_len);
	if (!ctx)
	    return BadAlloc;
    }

    ptr = dixLookupPrivate(privPtr, subjectKey);
    pSid = (security_id_t *)(ptr + offset);
    *pSid = NULL;

    rc = Success;
    if (stuff->context_len > 0) {
	if (security_check_context_raw(ctx) < 0 ||
	    avc_context_to_sid_raw(ctx, pSid) < 0)
	    rc = BadValue;
    }

    free(ctx);
    return rc;
}

static int
ProcSELinuxGetCreateContext(ClientPtr client, unsigned offset)
{
    security_id_t *pSid;
    char *ptr;

    REQUEST_SIZE_MATCH(SELinuxGetCreateContextReq);

    if (offset == CTX_DEV)
	ptr = dixLookupPrivate(&serverClient->devPrivates, subjectKey);
    else
	ptr = dixLookupPrivate(&client->devPrivates, subjectKey);

    pSid = (security_id_t *)(ptr + offset);
    return SELinuxSendContextReply(client, *pSid);
}

static int
ProcSELinuxSetDeviceContext(ClientPtr client)
{
    security_context_t ctx;
    security_id_t sid;
    DeviceIntPtr dev;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    int rc;

    REQUEST(SELinuxSetContextReq);
    REQUEST_FIXED_SIZE(SELinuxSetContextReq, stuff->context_len);

    if (stuff->context_len < 1)
	return BadLength;
    ctx = SELinuxCopyContext((char *)(stuff + 1), stuff->context_len);
    if (!ctx)
	return BadAlloc;

    rc = dixLookupDevice(&dev, stuff->id, client, DixManageAccess);
    if (rc != Success)
	goto out;

    if (security_check_context_raw(ctx) < 0 ||
	avc_context_to_sid_raw(ctx, &sid) < 0) {
	rc = BadValue;
	goto out;
    }

    subj = dixLookupPrivate(&dev->devPrivates, subjectKey);
    subj->sid = sid;
    obj = dixLookupPrivate(&dev->devPrivates, objectKey);
    obj->sid = sid;

    rc = Success;
out:
    free(ctx);
    return rc;
}

static int
ProcSELinuxGetDeviceContext(ClientPtr client)
{
    DeviceIntPtr dev;
    SELinuxSubjectRec *subj;
    int rc;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupDevice(&dev, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    subj = dixLookupPrivate(&dev->devPrivates, subjectKey);
    return SELinuxSendContextReply(client, subj->sid);
}

static int
ProcSELinuxGetDrawableContext(ClientPtr client)
{
    DrawablePtr pDraw;
    PrivateRec **privatePtr;
    SELinuxObjectRec *obj;
    int rc;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupDrawable(&pDraw, stuff->id, client, 0, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    if (pDraw->type == DRAWABLE_PIXMAP)
	privatePtr = &((PixmapPtr)pDraw)->devPrivates;
    else
	privatePtr = &((WindowPtr)pDraw)->devPrivates;

    obj = dixLookupPrivate(privatePtr, objectKey);
    return SELinuxSendContextReply(client, obj->sid);
}

static int
ProcSELinuxGetPropertyContext(ClientPtr client, pointer privKey)
{
    WindowPtr pWin;
    PropertyPtr pProp;
    SELinuxObjectRec *obj;
    int rc;

    REQUEST(SELinuxGetPropertyContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetPropertyContextReq);

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetPropAccess);
    if (rc != Success)
	return rc;

    rc = dixLookupProperty(&pProp, pWin, stuff->property, client,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;

    obj = dixLookupPrivate(&pProp->devPrivates, privKey);
    return SELinuxSendContextReply(client, obj->sid);
}

static int
ProcSELinuxGetSelectionContext(ClientPtr client, pointer privKey)
{
    Selection *pSel;
    SELinuxObjectRec *obj;
    int rc;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupSelection(&pSel, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    obj = dixLookupPrivate(&pSel->devPrivates, privKey);
    return SELinuxSendContextReply(client, obj->sid);
}

static int
ProcSELinuxGetClientContext(ClientPtr client)
{
    ClientPtr target;
    SELinuxSubjectRec *subj;
    int rc;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupClient(&target, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    subj = dixLookupPrivate(&target->devPrivates, subjectKey);
    return SELinuxSendContextReply(client, subj->sid);
}

static int
SELinuxPopulateItem(SELinuxListItemRec *i, PrivateRec **privPtr, CARD32 id,
		    int *size)
{
    SELinuxObjectRec *obj = dixLookupPrivate(privPtr, objectKey);
    SELinuxObjectRec *data = dixLookupPrivate(privPtr, dataKey);

    if (avc_sid_to_context_raw(obj->sid, &i->octx) < 0)
	return BadValue;
    if (avc_sid_to_context_raw(data->sid, &i->dctx) < 0)
	return BadValue;

    i->id = id;
    i->octx_len = bytes_to_int32(strlen(i->octx) + 1);
    i->dctx_len = bytes_to_int32(strlen(i->dctx) + 1);

    *size += i->octx_len + i->dctx_len + 3;
    return Success;
}

static void
SELinuxFreeItems(SELinuxListItemRec *items, int count)
{
    int k;
    for (k = 0; k < count; k++) {
	freecon(items[k].octx);
	freecon(items[k].dctx);
    }
    free(items);
}

static int
SELinuxSendItemsToClient(ClientPtr client, SELinuxListItemRec *items,
			 int size, int count)
{
    int rc, k, n, pos = 0;
    SELinuxListItemsReply rep;
    CARD32 *buf;

    buf = calloc(size, sizeof(CARD32));
    if (size && !buf) {
	rc = BadAlloc;
	goto out;
    }

    /* Fill in the buffer */
    for (k = 0; k < count; k++) {
	buf[pos] = items[k].id;
	if (client->swapped)
	    swapl(buf + pos, n);
	pos++;

	buf[pos] = items[k].octx_len * 4;
	if (client->swapped)
	    swapl(buf + pos, n);
	pos++;

	buf[pos] = items[k].dctx_len * 4;
	if (client->swapped)
	    swapl(buf + pos, n);
	pos++;

	memcpy((char *)(buf + pos), items[k].octx, strlen(items[k].octx) + 1);
	pos += items[k].octx_len;
	memcpy((char *)(buf + pos), items[k].dctx, strlen(items[k].dctx) + 1);
	pos += items[k].dctx_len;
    }

    /* Send reply to client */
    rep.type = X_Reply;
    rep.length = size;
    rep.sequenceNumber = client->sequence;
    rep.count = count;

    if (client->swapped) {
	swapl(&rep.length, n);
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.count, n);
    }

    WriteToClient(client, sizeof(SELinuxListItemsReply), (char *)&rep);
    WriteToClient(client, size * 4, (char *)buf);

    /* Free stuff and return */
    rc = Success;
    free(buf);
out:
    SELinuxFreeItems(items, count);
    return rc;
}

static int
ProcSELinuxListProperties(ClientPtr client)
{
    WindowPtr pWin;
    PropertyPtr pProp;
    SELinuxListItemRec *items;
    int rc, count, size, i;
    CARD32 id;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupWindow(&pWin, stuff->id, client, DixListPropAccess);
    if (rc != Success)
	return rc;

    /* Count the number of properties and allocate items */
    count = 0;
    for (pProp = wUserProps(pWin); pProp; pProp = pProp->next)
	count++;
    items = calloc(count, sizeof(SELinuxListItemRec));
    if (count && !items)
	return BadAlloc;

    /* Fill in the items and calculate size */
    i = 0;
    size = 0;
    for (pProp = wUserProps(pWin); pProp; pProp = pProp->next) {
	id = pProp->propertyName;
	rc = SELinuxPopulateItem(items + i, &pProp->devPrivates, id, &size);
	if (rc != Success) {
	    SELinuxFreeItems(items, count);
	    return rc;
	}
	i++;
    }

    return SELinuxSendItemsToClient(client, items, size, count);
}

static int
ProcSELinuxListSelections(ClientPtr client)
{
    Selection *pSel;
    SELinuxListItemRec *items;
    int rc, count, size, i;
    CARD32 id;

    REQUEST_SIZE_MATCH(SELinuxGetCreateContextReq);

    /* Count the number of selections and allocate items */
    count = 0;
    for (pSel = CurrentSelections; pSel; pSel = pSel->next)
	count++;
    items = calloc(count, sizeof(SELinuxListItemRec));
    if (count && !items)
	return BadAlloc;

    /* Fill in the items and calculate size */
    i = 0;
    size = 0;
    for (pSel = CurrentSelections; pSel; pSel = pSel->next) {
	id = pSel->selection;
	rc = SELinuxPopulateItem(items + i, &pSel->devPrivates, id, &size);
	if (rc != Success) {
	    SELinuxFreeItems(items, count);
	    return rc;
	}
	i++;
    }

    return SELinuxSendItemsToClient(client, items, size, count);
}

static int
ProcSELinuxDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_SELinuxQueryVersion:
	return ProcSELinuxQueryVersion(client);
    case X_SELinuxSetDeviceCreateContext:
	return ProcSELinuxSetCreateContext(client, CTX_DEV);
    case X_SELinuxGetDeviceCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_DEV);
    case X_SELinuxSetDeviceContext:
	return ProcSELinuxSetDeviceContext(client);
    case X_SELinuxGetDeviceContext:
	return ProcSELinuxGetDeviceContext(client);
    case X_SELinuxSetDrawableCreateContext:
	return ProcSELinuxSetCreateContext(client, CTX_WIN);
    case X_SELinuxGetDrawableCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_WIN);
    case X_SELinuxGetDrawableContext:
	return ProcSELinuxGetDrawableContext(client);
    case X_SELinuxSetPropertyCreateContext:
	return ProcSELinuxSetCreateContext(client, CTX_PRP);
    case X_SELinuxGetPropertyCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_PRP);
    case X_SELinuxSetPropertyUseContext:
	return ProcSELinuxSetCreateContext(client, USE_PRP);
    case X_SELinuxGetPropertyUseContext:
	return ProcSELinuxGetCreateContext(client, USE_PRP);
    case X_SELinuxGetPropertyContext:
	return ProcSELinuxGetPropertyContext(client, objectKey);
    case X_SELinuxGetPropertyDataContext:
	return ProcSELinuxGetPropertyContext(client, dataKey);
    case X_SELinuxListProperties:
	return ProcSELinuxListProperties(client);
    case X_SELinuxSetSelectionCreateContext:
	return ProcSELinuxSetCreateContext(client, CTX_SEL);
    case X_SELinuxGetSelectionCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_SEL);
    case X_SELinuxSetSelectionUseContext:
	return ProcSELinuxSetCreateContext(client, USE_SEL);
    case X_SELinuxGetSelectionUseContext:
	return ProcSELinuxGetCreateContext(client, USE_SEL);
    case X_SELinuxGetSelectionContext:
	return ProcSELinuxGetSelectionContext(client, objectKey);
    case X_SELinuxGetSelectionDataContext:
	return ProcSELinuxGetSelectionContext(client, dataKey);
    case X_SELinuxListSelections:
	return ProcSELinuxListSelections(client);
    case X_SELinuxGetClientContext:
	return ProcSELinuxGetClientContext(client);
    default:
	return BadRequest;
    }
}

static int
SProcSELinuxQueryVersion(ClientPtr client)
{
    REQUEST(SELinuxQueryVersionReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxQueryVersionReq);
    swaps(&stuff->client_major, n);
    swaps(&stuff->client_minor, n);
    return ProcSELinuxQueryVersion(client);
}

static int
SProcSELinuxSetCreateContext(ClientPtr client, unsigned offset)
{
    REQUEST(SELinuxSetCreateContextReq);
    int n;

    REQUEST_AT_LEAST_SIZE(SELinuxSetCreateContextReq);
    swapl(&stuff->context_len, n);
    return ProcSELinuxSetCreateContext(client, offset);
}

static int
SProcSELinuxSetDeviceContext(ClientPtr client)
{
    REQUEST(SELinuxSetContextReq);
    int n;

    REQUEST_AT_LEAST_SIZE(SELinuxSetContextReq);
    swapl(&stuff->id, n);
    swapl(&stuff->context_len, n);
    return ProcSELinuxSetDeviceContext(client);
}

static int
SProcSELinuxGetDeviceContext(ClientPtr client)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxGetDeviceContext(client);
}

static int
SProcSELinuxGetDrawableContext(ClientPtr client)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxGetDrawableContext(client);
}

static int
SProcSELinuxGetPropertyContext(ClientPtr client, pointer privKey)
{
    REQUEST(SELinuxGetPropertyContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetPropertyContextReq);
    swapl(&stuff->window, n);
    swapl(&stuff->property, n);
    return ProcSELinuxGetPropertyContext(client, privKey);
}

static int
SProcSELinuxGetSelectionContext(ClientPtr client, pointer privKey)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxGetSelectionContext(client, privKey);
}

static int
SProcSELinuxListProperties(ClientPtr client)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxListProperties(client);
}

static int
SProcSELinuxGetClientContext(ClientPtr client)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxGetClientContext(client);
}

static int
SProcSELinuxDispatch(ClientPtr client)
{
    REQUEST(xReq);
    int n;

    swaps(&stuff->length, n);

    switch (stuff->data) {
    case X_SELinuxQueryVersion:
	return SProcSELinuxQueryVersion(client);
    case X_SELinuxSetDeviceCreateContext:
	return SProcSELinuxSetCreateContext(client, CTX_DEV);
    case X_SELinuxGetDeviceCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_DEV);
    case X_SELinuxSetDeviceContext:
	return SProcSELinuxSetDeviceContext(client);
    case X_SELinuxGetDeviceContext:
	return SProcSELinuxGetDeviceContext(client);
    case X_SELinuxSetDrawableCreateContext:
	return SProcSELinuxSetCreateContext(client, CTX_WIN);
    case X_SELinuxGetDrawableCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_WIN);
    case X_SELinuxGetDrawableContext:
	return SProcSELinuxGetDrawableContext(client);
    case X_SELinuxSetPropertyCreateContext:
	return SProcSELinuxSetCreateContext(client, CTX_PRP);
    case X_SELinuxGetPropertyCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_PRP);
    case X_SELinuxSetPropertyUseContext:
	return SProcSELinuxSetCreateContext(client, USE_PRP);
    case X_SELinuxGetPropertyUseContext:
	return ProcSELinuxGetCreateContext(client, USE_PRP);
    case X_SELinuxGetPropertyContext:
	return SProcSELinuxGetPropertyContext(client, objectKey);
    case X_SELinuxGetPropertyDataContext:
	return SProcSELinuxGetPropertyContext(client, dataKey);
    case X_SELinuxListProperties:
	return SProcSELinuxListProperties(client);
    case X_SELinuxSetSelectionCreateContext:
	return SProcSELinuxSetCreateContext(client, CTX_SEL);
    case X_SELinuxGetSelectionCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_SEL);
    case X_SELinuxSetSelectionUseContext:
	return SProcSELinuxSetCreateContext(client, USE_SEL);
    case X_SELinuxGetSelectionUseContext:
	return ProcSELinuxGetCreateContext(client, USE_SEL);
    case X_SELinuxGetSelectionContext:
	return SProcSELinuxGetSelectionContext(client, objectKey);
    case X_SELinuxGetSelectionDataContext:
	return SProcSELinuxGetSelectionContext(client, dataKey);
    case X_SELinuxListSelections:
	return ProcSELinuxListSelections(client);
    case X_SELinuxGetClientContext:
	return SProcSELinuxGetClientContext(client);
    default:
	return BadRequest;
    }
}


/*
 * Extension Setup / Teardown
 */

static void
SELinuxResetProc(ExtensionEntry *extEntry)
{
    SELinuxFlaskReset();
    SELinuxLabelReset();
}

void
SELinuxExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;

    /* Check SELinux mode on system, configuration file, and boolean */
    if (!is_selinux_enabled()) {
	LogMessage(X_INFO, "SELinux: Disabled on system\n");
	return;
    }
    if (selinuxEnforcingState == SELINUX_MODE_DISABLED) {
	LogMessage(X_INFO, "SELinux: Disabled in configuration file\n");
	return;
    }
    if (!security_get_boolean_active("xserver_object_manager")) {
	LogMessage(X_INFO, "SELinux: Disabled by boolean\n");
        return;
    }

    /* Set up XACE hooks */
    SELinuxLabelInit();
    SELinuxFlaskInit();

    /* Add extension to server */
    extEntry = AddExtension(SELINUX_EXTENSION_NAME,
			    SELinuxNumberEvents, SELinuxNumberErrors,
			    ProcSELinuxDispatch, SProcSELinuxDispatch,
			    SELinuxResetProc, StandardMinorOpcode);

    AddExtensionAlias("Flask", extEntry);
}
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

/*
 * Portions of this code copyright (c) 2005 by Trusted Computer Solutions, Inc.
 * All rights reserved.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/socket.h>
#include <stdio.h>
#include <stdarg.h>

#include <libaudit.h>

#include <X11/Xatom.h>
#include "selection.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "extnsionst.h"
#include "xacestr.h"
#include "client.h"
#include "../os/osdep.h"
#define _XSELINUX_NEED_FLASK_MAP
#include "xselinuxint.h"


/* structure passed to auditing callback */
typedef struct {
    ClientPtr client;	/* client */
    DeviceIntPtr dev;	/* device */
    char *command;	/* client's executable path */
    unsigned id;	/* resource id, if any */
    int restype;	/* resource type, if any */
    int event;		/* event type, if any */
    Atom property;	/* property name, if any */
    Atom selection;	/* selection name, if any */
    char *extension;	/* extension name, if any */
} SELinuxAuditRec;

/* private state keys */
DevPrivateKeyRec subjectKeyRec;
DevPrivateKeyRec objectKeyRec;
DevPrivateKeyRec dataKeyRec;

/* audit file descriptor */
static int audit_fd;

/* atoms for window label properties */
static Atom atom_ctx;
static Atom atom_client_ctx;

/* The unlabeled SID */
static security_id_t unlabeled_sid;

/* forward declarations */
static void SELinuxScreen(CallbackListPtr *, pointer, pointer);

/* "true" pointer value for use as callback data */
static pointer truep = (pointer)1;


/*
 * Performs an SELinux permission check.
 */
static int
SELinuxDoCheck(SELinuxSubjectRec *subj, SELinuxObjectRec *obj,
	       security_class_t class, Mask mode, SELinuxAuditRec *auditdata)
{
    /* serverClient requests OK */
    if (subj->privileged)
	return Success;

    auditdata->command = subj->command;
    errno = 0;

    if (avc_has_perm(subj->sid, obj->sid, class, mode, &subj->aeref,
		     auditdata) < 0) {
	if (mode == DixUnknownAccess)
	    return Success; /* DixUnknownAccess requests OK ... for now */
	if (errno == EACCES)
	    return BadAccess;
	ErrorF("SELinux: avc_has_perm: unexpected error %d\n", errno);
	return BadValue;
    }

    return Success;
}

/*
 * Labels a newly connected client.
 */
static void
SELinuxLabelClient(ClientPtr client)
{
    int fd = XaceGetConnectionNumber(client);
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    security_context_t ctx;

    subj = dixLookupPrivate(&client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&client->devPrivates, objectKey);

    /* Try to get a context from the socket */
    if (fd < 0 || getpeercon_raw(fd, &ctx) < 0) {
	/* Otherwise, fall back to a default context */
	ctx = SELinuxDefaultClientLabel();
    }

    /* For local clients, try and determine the executable name */
    if (XaceIsLocal(client)) {
	/* Get cached command name if CLIENTIDS is enabled. */
	const char *cmdname = GetClientCmdName(client);
	Bool cached = (cmdname != NULL);
	/* If CLIENTIDS is disabled, figure out the command name from
	 * scratch. */
	if (!cmdname)
	{
	    pid_t pid = DetermineClientPid(client);
	    if (pid != -1)
		DetermineClientCmd(pid, &cmdname, NULL);
	}

	if (!cmdname)
	    goto finish;

	strncpy(subj->command, cmdname, COMMAND_LEN - 1);

	if (!cached)
	    free((void *) cmdname); /* const char * */
    }

finish:
    /* Get a SID from the context */
    if (avc_context_to_sid_raw(ctx, &subj->sid) < 0)
	FatalError("SELinux: client %d: context_to_sid_raw(%s) failed\n",
		   client->index, ctx);

    obj->sid = subj->sid;
    freecon(ctx);
}

/*
 * Labels initial server objects.
 */
static void
SELinuxLabelInitial(void)
{
    int i;
    XaceScreenAccessRec srec;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    security_context_t ctx;
    pointer unused;

    /* Do the serverClient */
    subj = dixLookupPrivate(&serverClient->devPrivates, subjectKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, objectKey);
    subj->privileged = 1;

    /* Use the context of the X server process for the serverClient */
    if (getcon_raw(&ctx) < 0)
	FatalError("SELinux: couldn't get context of X server process\n");

    /* Get a SID from the context */
    if (avc_context_to_sid_raw(ctx, &subj->sid) < 0)
	FatalError("SELinux: serverClient: context_to_sid(%s) failed\n", ctx);

    obj->sid = subj->sid;
    freecon(ctx);

    srec.client = serverClient;
    srec.access_mode = DixCreateAccess;
    srec.status = Success;

    for (i = 0; i < screenInfo.numScreens; i++) {
	/* Do the screen object */
	srec.screen = screenInfo.screens[i];
	SELinuxScreen(NULL, NULL, &srec);

	/* Do the default colormap */
	dixLookupResourceByType(&unused, screenInfo.screens[i]->defColormap,
			  RT_COLORMAP, serverClient, DixCreateAccess);
    }
}

/*
 * Labels new resource objects.
 */
static int
SELinuxLabelResource(XaceResourceAccessRec *rec, SELinuxSubjectRec *subj,
		     SELinuxObjectRec *obj, security_class_t class)
{
    int offset;
    security_id_t tsid;

    /* Check for a create context */
    if (rec->rtype & RC_DRAWABLE && subj->win_create_sid) {
	obj->sid = subj->win_create_sid;
	return Success;
    }

    if (rec->parent)
	offset = dixLookupPrivateOffset(rec->ptype);

    if (rec->parent && offset >= 0) {
	/* Use the SID of the parent object in the labeling operation */
	PrivateRec **privatePtr = DEVPRIV_AT(rec->parent, offset);
	SELinuxObjectRec *pobj = dixLookupPrivate(privatePtr, objectKey);
	tsid = pobj->sid;
    } else {
	/* Use the SID of the subject */
	tsid = subj->sid;
    }

    /* Perform a transition to obtain the final SID */
    if (avc_compute_create(subj->sid, tsid, class, &obj->sid) < 0) {
	ErrorF("SELinux: a compute_create call failed!\n");
	return BadValue;
    }

    return Success;
}


/*
 * Libselinux Callbacks
 */

static int
SELinuxAudit(void *auditdata,
	     security_class_t class,
	     char *msgbuf,
	     size_t msgbufsize)
{
    SELinuxAuditRec *audit = auditdata;
    ClientPtr client = audit->client;
    char idNum[16];
    const char *propertyName, *selectionName;
    int major = -1, minor = -1;

    if (client) {
	REQUEST(xReq);
	if (stuff) {
	    major = stuff->reqType;
	    minor = MinorOpcodeOfRequest(client);
	}
    }
    if (audit->id)
	snprintf(idNum, 16, "%x", audit->id);

    propertyName = audit->property ? NameForAtom(audit->property) : NULL;
    selectionName = audit->selection ? NameForAtom(audit->selection) : NULL;

    return snprintf(msgbuf, msgbufsize,
		    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
		    (major >= 0) ? "request=" : "",
		    (major >= 0) ? LookupRequestName(major, minor) : "",
		    audit->command ? " comm=" : "",
		    audit->command ? audit->command : "",
		    audit->dev ? " xdevice=\"" : "",
		    audit->dev ? audit->dev->name : "",
		    audit->dev ? "\"" : "",
		    audit->id ? " resid=" : "",
		    audit->id ? idNum : "",
		    audit->restype ? " restype=" : "",
		    audit->restype ? LookupResourceName(audit->restype) : "",
		    audit->event ? " event=" : "",
		    audit->event ? LookupEventName(audit->event & 127) : "",
		    audit->property ? " property=" : "",
		    audit->property ? propertyName : "",
		    audit->selection ? " selection=" : "",
		    audit->selection ? selectionName : "",
		    audit->extension ? " extension=" : "",
		    audit->extension ? audit->extension : "");
}

static int
SELinuxLog(int type, const char *fmt, ...)
{
    va_list ap;
    char buf[MAX_AUDIT_MESSAGE_LENGTH];
    int rc, aut;

    switch (type) {
    case SELINUX_INFO:
	aut = AUDIT_USER_MAC_POLICY_LOAD;
	break;
    case SELINUX_AVC:
	aut = AUDIT_USER_AVC;
	break;
    default:
	aut = AUDIT_USER_SELINUX_ERR;
	break;
    }

    va_start(ap, fmt);
    vsnprintf(buf, MAX_AUDIT_MESSAGE_LENGTH, fmt, ap);
    rc = audit_log_user_avc_message(audit_fd, aut, buf, NULL, NULL, NULL, 0);
    va_end(ap);
    LogMessageVerb(X_WARNING, 0, "%s", buf);
    return 0;
}

/*
 * XACE Callbacks
 */

static void
SELinuxDevice(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceDeviceAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client, .dev = rec->dev };
    security_class_t cls;
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->dev->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    if (rec->access_mode & DixCreateAccess) {
	SELinuxSubjectRec *dsubj;
	dsubj = dixLookupPrivate(&rec->dev->devPrivates, subjectKey);

	if (subj->dev_create_sid) {
	    /* Label the device with the create context */
	    obj->sid = subj->dev_create_sid;
	    dsubj->sid = subj->dev_create_sid;
	} else {
	    /* Label the device directly with the process SID */
	    obj->sid = subj->sid;
	    dsubj->sid = subj->sid;
	}
    }

    cls = IsPointerDevice(rec->dev) ? SECCLASS_X_POINTER : SECCLASS_X_KEYBOARD;
    rc = SELinuxDoCheck(subj, obj, cls, rec->access_mode, &auditdata);
    if (rc != Success)
	rec->status = rc;
}

static void
SELinuxSend(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceSendAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj, ev_sid;
    SELinuxAuditRec auditdata = { .client = rec->client, .dev = rec->dev };
    security_class_t class;
    int rc, i, type;

    if (rec->dev)
	subj = dixLookupPrivate(&rec->dev->devPrivates, subjectKey);
    else
	subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);

    obj = dixLookupPrivate(&rec->pWin->devPrivates, objectKey);

    /* Check send permission on window */
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_DRAWABLE, DixSendAccess,
			&auditdata);
    if (rc != Success)
	goto err;

    /* Check send permission on specific event types */
    for (i = 0; i < rec->count; i++) {
	type = rec->events[i].u.u.type;
	class = (type & 128) ? SECCLASS_X_FAKEEVENT : SECCLASS_X_EVENT;

	rc = SELinuxEventToSID(type, obj->sid, &ev_sid);
	if (rc != Success)
	    goto err;

	auditdata.event = type;
	rc = SELinuxDoCheck(subj, &ev_sid, class, DixSendAccess, &auditdata);
	if (rc != Success)
	    goto err;
    }
    return;
err:
    rec->status = rc;
}

static void
SELinuxReceive(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceReceiveAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj, ev_sid;
    SELinuxAuditRec auditdata = { .client = NULL };
    security_class_t class;
    int rc, i, type;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->pWin->devPrivates, objectKey);

    /* Check receive permission on window */
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_DRAWABLE, DixReceiveAccess,
			&auditdata);
    if (rc != Success)
	goto err;

    /* Check receive permission on specific event types */
    for (i = 0; i < rec->count; i++) {
	type = rec->events[i].u.u.type;
	class = (type & 128) ? SECCLASS_X_FAKEEVENT : SECCLASS_X_EVENT;

	rc = SELinuxEventToSID(type, obj->sid, &ev_sid);
	if (rc != Success)
	    goto err;

	auditdata.event = type;
	rc = SELinuxDoCheck(subj, &ev_sid, class, DixReceiveAccess, &auditdata);
	if (rc != Success)
	    goto err;
    }
    return;
err:
    rec->status = rc;
}

static void
SELinuxExtension(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceExtAccessRec *rec = calldata;
    SELinuxSubjectRec *subj, *serv;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->ext->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    /* XXX there should be a separate callback for this */
    if (obj->sid == NULL) {
	security_id_t sid;

	serv = dixLookupPrivate(&serverClient->devPrivates, subjectKey);
	rc = SELinuxExtensionToSID(rec->ext->name, &sid);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}

	/* Perform a transition to obtain the final SID */
	if (avc_compute_create(serv->sid, sid, SECCLASS_X_EXTENSION,
			       &obj->sid) < 0) {
	    ErrorF("SELinux: a SID transition call failed!\n");
	    rec->status = BadValue;
	    return;
	}
    }

    /* Perform the security check */
    auditdata.extension = rec->ext->name;
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_EXTENSION, rec->access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;
}

static void
SELinuxSelection(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceSelectionAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj, *data;
    Selection *pSel = *rec->ppSel;
    Atom name = pSel->selection;
    Mask access_mode = rec->access_mode;
    SELinuxAuditRec auditdata = { .client = rec->client, .selection = name };
    security_id_t tsid;
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&pSel->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    if (access_mode & DixCreateAccess) {
	rc = SELinuxSelectionToSID(name, subj, &obj->sid, &obj->poly);
	if (rc != Success)
	    obj->sid = unlabeled_sid;
	access_mode = DixSetAttrAccess;
    }
    /* If this is a polyinstantiated object, find the right instance */
    else if (obj->poly) {
	rc = SELinuxSelectionToSID(name, subj, &tsid, NULL);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}
	while (pSel->selection != name || obj->sid != tsid) {
	    if ((pSel = pSel->next) == NULL)
		break;
	    obj = dixLookupPrivate(&pSel->devPrivates, objectKey);
	}

	if (pSel)
	    *rec->ppSel = pSel;
	else {
	    rec->status = BadMatch;
	    return;
	}
    }

    /* Perform the security check */
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_SELECTION, access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;

    /* Label the content (advisory only) */
    if (access_mode & DixSetAttrAccess) {
	data = dixLookupPrivate(&pSel->devPrivates, dataKey);
	if (subj->sel_create_sid)
	    data->sid = subj->sel_create_sid;
	else
	    data->sid = obj->sid;
    }
}

static void
SELinuxProperty(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XacePropertyAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj, *data;
    PropertyPtr pProp = *rec->ppProp;
    Atom name = pProp->propertyName;
    SELinuxAuditRec auditdata = { .client = rec->client, .property = name };
    security_id_t tsid;
    int rc;

    /* Don't care about the new content check */
    if (rec->access_mode & DixPostAccess)
	return;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&pProp->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    if (rec->access_mode & DixCreateAccess) {
	rc = SELinuxPropertyToSID(name, subj, &obj->sid, &obj->poly);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}
    }
    /* If this is a polyinstantiated object, find the right instance */
    else if (obj->poly) {
	rc = SELinuxPropertyToSID(name, subj, &tsid, NULL);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}
	while (pProp->propertyName != name || obj->sid != tsid) {
	    if ((pProp = pProp->next) == NULL)
		break;
	    obj = dixLookupPrivate(&pProp->devPrivates, objectKey);
	}

	if (pProp)
	    *rec->ppProp = pProp;
	else {
	    rec->status = BadMatch;
	    return;
	}
    }

    /* Perform the security check */
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_PROPERTY, rec->access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;

    /* Label the content (advisory only) */
    if (rec->access_mode & DixWriteAccess) {
	data = dixLookupPrivate(&pProp->devPrivates, dataKey);
	if (subj->prp_create_sid)
	    data->sid = subj->prp_create_sid;
	else
	    data->sid = obj->sid;
    }
}

static void
SELinuxResource(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceResourceAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    Mask access_mode = rec->access_mode;
    PrivateRec **privatePtr;
    security_class_t class;
    int rc, offset;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);

    /* Determine if the resource object has a devPrivates field */
    offset = dixLookupPrivateOffset(rec->rtype);
    if (offset < 0) {
	/* No: use the SID of the owning client */
	class = SECCLASS_X_RESOURCE;
	privatePtr = &clients[CLIENT_ID(rec->id)]->devPrivates;
	obj = dixLookupPrivate(privatePtr, objectKey);
    } else {
	/* Yes: use the SID from the resource object itself */
	class = SELinuxTypeToClass(rec->rtype);
	privatePtr = DEVPRIV_AT(rec->res, offset);
	obj = dixLookupPrivate(privatePtr, objectKey);
    }

    /* If this is a new object that needs labeling, do it now */
    if (access_mode & DixCreateAccess && offset >= 0) {
	rc = SELinuxLabelResource(rec, subj, obj, class);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}
    }

    /* Collapse generic resource permissions down to read/write */
    if (class == SECCLASS_X_RESOURCE) {
	access_mode = !!(rec->access_mode & SELinuxReadMask); /* rd */
	access_mode |= !!(rec->access_mode & ~SELinuxReadMask) << 1; /* wr */
    }

    /* Perform the security check */
    auditdata.restype = rec->rtype;
    auditdata.id = rec->id;
    rc = SELinuxDoCheck(subj, obj, class, access_mode, &auditdata);
    if (rc != Success)
	rec->status = rc;

    /* Perform the background none check on windows */
    if (access_mode & DixCreateAccess && rec->rtype == RT_WINDOW) {
	rc = SELinuxDoCheck(subj, obj, class, DixBlendAccess, &auditdata);
	if (rc != Success)
	    ((WindowPtr)rec->res)->forcedBG = TRUE;
    }
}

static void
SELinuxScreen(CallbackListPtr *pcbl, pointer is_saver, pointer calldata)
{
    XaceScreenAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    Mask access_mode = rec->access_mode;
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->screen->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    if (access_mode & DixCreateAccess) {
	/* Perform a transition to obtain the final SID */
	if (avc_compute_create(subj->sid, subj->sid, SECCLASS_X_SCREEN,
			       &obj->sid) < 0) {
	    ErrorF("SELinux: a compute_create call failed!\n");
	    rec->status = BadValue;
	    return;
	}
    }

    if (is_saver)
	access_mode <<= 2;

    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_SCREEN, access_mode, &auditdata);
    if (rc != Success)
	rec->status = rc;
}

static void
SELinuxClient(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceClientAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->target->devPrivates, objectKey);

    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_CLIENT, rec->access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;
}

static void
SELinuxServer(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceServerAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, objectKey);

    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_SERVER, rec->access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;
}


/*
 * DIX Callbacks
 */

static void
SELinuxClientState(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    NewClientInfoRec *pci = calldata;

    switch (pci->client->clientState) {
    case ClientStateInitial:
	SELinuxLabelClient(pci->client);
	break;

    default:
	break;
    }
}

static void
SELinuxResourceState(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    ResourceStateInfoRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    WindowPtr pWin;

    if (rec->type != RT_WINDOW)
	return;
    if (rec->state != ResourceStateAdding)
	return;

    pWin = (WindowPtr)rec->value;
    subj = dixLookupPrivate(&wClient(pWin)->devPrivates, subjectKey);

    if (subj->sid) {
	security_context_t ctx;
	int rc = avc_sid_to_context_raw(subj->sid, &ctx);
	if (rc < 0)
	    FatalError("SELinux: Failed to get security context!\n");
	rc = dixChangeWindowProperty(serverClient,
				     pWin, atom_client_ctx, XA_STRING, 8,
				     PropModeReplace, strlen(ctx), ctx, FALSE);
	if (rc != Success)
	    FatalError("SELinux: Failed to set label property on window!\n");
	freecon(ctx);
    } else
	FatalError("SELinux: Unexpected unlabeled client found\n");

    obj = dixLookupPrivate(&pWin->devPrivates, objectKey);

    if (obj->sid) {
	security_context_t ctx;
	int rc = avc_sid_to_context_raw(obj->sid, &ctx);
	if (rc < 0)
	    FatalError("SELinux: Failed to get security context!\n");
	rc = dixChangeWindowProperty(serverClient,
				     pWin, atom_ctx, XA_STRING, 8,
				     PropModeReplace, strlen(ctx), ctx, FALSE);
	if (rc != Success)
	    FatalError("SELinux: Failed to set label property on window!\n");
	freecon(ctx);
    } else
	FatalError("SELinux: Unexpected unlabeled window found\n");
}


static int netlink_fd;

static void
SELinuxBlockHandler(void *data, struct timeval **tv, void *read_mask)
{
}

static void
SELinuxWakeupHandler(void *data, int err, void *read_mask)
{
    if (FD_ISSET(netlink_fd, (fd_set *)read_mask))
        avc_netlink_check_nb();
}

void
SELinuxFlaskReset(void)
{
    /* Unregister callbacks */
    DeleteCallback(&ClientStateCallback, SELinuxClientState, NULL);
    DeleteCallback(&ResourceStateCallback, SELinuxResourceState, NULL);

    XaceDeleteCallback(XACE_EXT_DISPATCH, SELinuxExtension, NULL);
    XaceDeleteCallback(XACE_RESOURCE_ACCESS, SELinuxResource, NULL);
    XaceDeleteCallback(XACE_DEVICE_ACCESS, SELinuxDevice, NULL);
    XaceDeleteCallback(XACE_PROPERTY_ACCESS, SELinuxProperty, NULL);
    XaceDeleteCallback(XACE_SEND_ACCESS, SELinuxSend, NULL);
    XaceDeleteCallback(XACE_RECEIVE_ACCESS, SELinuxReceive, NULL);
    XaceDeleteCallback(XACE_CLIENT_ACCESS, SELinuxClient, NULL);
    XaceDeleteCallback(XACE_EXT_ACCESS, SELinuxExtension, NULL);
    XaceDeleteCallback(XACE_SERVER_ACCESS, SELinuxServer, NULL);
    XaceDeleteCallback(XACE_SELECTION_ACCESS, SELinuxSelection, NULL);
    XaceDeleteCallback(XACE_SCREEN_ACCESS, SELinuxScreen, NULL);
    XaceDeleteCallback(XACE_SCREENSAVER_ACCESS, SELinuxScreen, truep);

    /* Tear down SELinux stuff */
    audit_close(audit_fd);
    avc_netlink_release_fd();
    RemoveBlockAndWakeupHandlers(SELinuxBlockHandler, SELinuxWakeupHandler,
                                 NULL);
    RemoveGeneralSocket(netlink_fd);

    avc_destroy();
}

void
SELinuxFlaskInit(void)
{
    struct selinux_opt avc_option = { AVC_OPT_SETENFORCE, (char *)0 };
    security_context_t ctx;
    int ret = TRUE;

    switch(selinuxEnforcingState) {
    case SELINUX_MODE_ENFORCING:
	LogMessage(X_INFO, "SELinux: Configured in enforcing mode\n");
	avc_option.value = (char *)1;
	break;
    case SELINUX_MODE_PERMISSIVE:
	LogMessage(X_INFO, "SELinux: Configured in permissive mode\n");
	avc_option.value = (char *)0;
	break;
    default:
	avc_option.type = AVC_OPT_UNUSED;
	break;
    }

    /* Set up SELinux stuff */
    selinux_set_callback(SELINUX_CB_LOG, (union selinux_callback)SELinuxLog);
    selinux_set_callback(SELINUX_CB_AUDIT, (union selinux_callback)SELinuxAudit);

    if (selinux_set_mapping(map) < 0) {
	if (errno == EINVAL) {
	    ErrorF("SELinux: Invalid object class mapping, disabling SELinux support.\n");
	    return;
	}
	FatalError("SELinux: Failed to set up security class mapping\n");
    }

    if (avc_open(&avc_option, 1) < 0)
	FatalError("SELinux: Couldn't initialize SELinux userspace AVC\n");

    if (security_get_initial_context_raw("unlabeled", &ctx) < 0)
	FatalError("SELinux: Failed to look up unlabeled context\n");
    if (avc_context_to_sid_raw(ctx, &unlabeled_sid) < 0)
	FatalError("SELinux: a context_to_SID call failed!\n");
    freecon(ctx);

    /* Prepare for auditing */
    audit_fd = audit_open();
    if (audit_fd < 0)
	FatalError("SELinux: Failed to open the system audit log\n");

    /* Allocate private storage */
    if (!dixRegisterPrivateKey(subjectKey, PRIVATE_XSELINUX, sizeof(SELinuxSubjectRec)) ||
	!dixRegisterPrivateKey(objectKey, PRIVATE_XSELINUX, sizeof(SELinuxObjectRec)) ||
	!dixRegisterPrivateKey(dataKey, PRIVATE_XSELINUX, sizeof(SELinuxObjectRec)))
	FatalError("SELinux: Failed to allocate private storage.\n");

    /* Create atoms for doing window labeling */
    atom_ctx = MakeAtom("_SELINUX_CONTEXT", 16, TRUE);
    if (atom_ctx == BAD_RESOURCE)
	FatalError("SELinux: Failed to create atom\n");
    atom_client_ctx = MakeAtom("_SELINUX_CLIENT_CONTEXT", 23, TRUE);
    if (atom_client_ctx == BAD_RESOURCE)
	FatalError("SELinux: Failed to create atom\n");

    netlink_fd = avc_netlink_acquire_fd();
    AddGeneralSocket(netlink_fd);
    RegisterBlockAndWakeupHandlers(SELinuxBlockHandler, SELinuxWakeupHandler,
                                   NULL);

    /* Register callbacks */
    ret &= AddCallback(&ClientStateCallback, SELinuxClientState, NULL);
    ret &= AddCallback(&ResourceStateCallback, SELinuxResourceState, NULL);

    ret &= XaceRegisterCallback(XACE_EXT_DISPATCH, SELinuxExtension, NULL);
    ret &= XaceRegisterCallback(XACE_RESOURCE_ACCESS, SELinuxResource, NULL);
    ret &= XaceRegisterCallback(XACE_DEVICE_ACCESS, SELinuxDevice, NULL);
    ret &= XaceRegisterCallback(XACE_PROPERTY_ACCESS, SELinuxProperty, NULL);
    ret &= XaceRegisterCallback(XACE_SEND_ACCESS, SELinuxSend, NULL);
    ret &= XaceRegisterCallback(XACE_RECEIVE_ACCESS, SELinuxReceive, NULL);
    ret &= XaceRegisterCallback(XACE_CLIENT_ACCESS, SELinuxClient, NULL);
    ret &= XaceRegisterCallback(XACE_EXT_ACCESS, SELinuxExtension, NULL);
    ret &= XaceRegisterCallback(XACE_SERVER_ACCESS, SELinuxServer, NULL);
    ret &= XaceRegisterCallback(XACE_SELECTION_ACCESS, SELinuxSelection, NULL);
    ret &= XaceRegisterCallback(XACE_SCREEN_ACCESS, SELinuxScreen, NULL);
    ret &= XaceRegisterCallback(XACE_SCREENSAVER_ACCESS, SELinuxScreen, truep);
    if (!ret)
	FatalError("SELinux: Failed to register one or more callbacks\n");

    /* Label objects that were created before we could register ourself */
    SELinuxLabelInitial();
}
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <selinux/label.h>

#include "registry.h"
#include "xselinuxint.h"

/* selection and property atom cache */
typedef struct {
    SELinuxObjectRec prp;
    SELinuxObjectRec sel;
} SELinuxAtomRec;

/* dynamic array */
typedef struct {
    unsigned size;
    void **array;
} SELinuxArrayRec;

/* labeling handle */
static struct selabel_handle *label_hnd;

/* Array of object classes indexed by resource type */
SELinuxArrayRec arr_types;
/* Array of event SIDs indexed by event type */
SELinuxArrayRec arr_events;
/* Array of property and selection SID structures */
SELinuxArrayRec arr_atoms;

/*
 * Dynamic array helpers
 */
static void *
SELinuxArrayGet(SELinuxArrayRec *rec, unsigned key)
{
    return (rec->size > key) ? rec->array[key] : 0;
}

static int
SELinuxArraySet(SELinuxArrayRec *rec, unsigned key, void *val)
{
    if (key >= rec->size) {
	/* Need to increase size of array */
	rec->array = realloc(rec->array, (key + 1) * sizeof(val));
	if (!rec->array)
	    return FALSE;
	memset(rec->array + rec->size, 0, (key - rec->size + 1) * sizeof(val));
	rec->size = key + 1;
    }

    rec->array[key] = val;
    return TRUE;
}

static void
SELinuxArrayFree(SELinuxArrayRec *rec, int free_elements)
{
    if (free_elements) {
	unsigned i = rec->size;
	while (i)
	    free(rec->array[--i]);
    }

    free(rec->array);
    rec->size = 0;
    rec->array = NULL;
}

/*
 * Looks up a name in the selection or property mappings
 */
static int
SELinuxAtomToSIDLookup(Atom atom, SELinuxObjectRec *obj, int map, int polymap)
{
    const char *name = NameForAtom(atom);
    security_context_t ctx;
    int rc = Success;

    obj->poly = 1;

    /* Look in the mappings of names to contexts */
    if (selabel_lookup_raw(label_hnd, &ctx, name, map) == 0) {
	obj->poly = 0;
    } else if (errno != ENOENT) {
	ErrorF("SELinux: a property label lookup failed!\n");
	return BadValue;
    } else if (selabel_lookup_raw(label_hnd, &ctx, name, polymap) < 0) {
	ErrorF("SELinux: a property label lookup failed!\n");
	return BadValue;
    }

    /* Get a SID for context */
    if (avc_context_to_sid_raw(ctx, &obj->sid) < 0) {
	ErrorF("SELinux: a context_to_SID_raw call failed!\n");
	rc = BadAlloc;
    }

    freecon(ctx);
    return rc;
}

/*
 * Looks up the SID corresponding to the given property or selection atom
 */
int
SELinuxAtomToSID(Atom atom, int prop, SELinuxObjectRec **obj_rtn)
{
    SELinuxAtomRec *rec;
    SELinuxObjectRec *obj;
    int rc, map, polymap;

    rec = SELinuxArrayGet(&arr_atoms, atom);
    if (!rec) {
	rec = calloc(1, sizeof(SELinuxAtomRec));
	if (!rec || !SELinuxArraySet(&arr_atoms, atom, rec))
	    return BadAlloc;
    }

    if (prop) {
	obj = &rec->prp;
	map = SELABEL_X_PROP;
	polymap = SELABEL_X_POLYPROP;
    } else {
	obj = &rec->sel;
	map = SELABEL_X_SELN;
	polymap = SELABEL_X_POLYSELN;
    }

    if (!obj->sid) {
	rc = SELinuxAtomToSIDLookup(atom, obj, map, polymap);
	if (rc != Success)
	    goto out;
    }

    *obj_rtn = obj;
    rc = Success;
out:
    return rc;
}

/*
 * Looks up a SID for a selection/subject pair
 */
int
SELinuxSelectionToSID(Atom selection, SELinuxSubjectRec *subj,
		      security_id_t *sid_rtn, int *poly_rtn)
{
    int rc;
    SELinuxObjectRec *obj;
    security_id_t tsid;

    /* Get the default context and polyinstantiation bit */
    rc = SELinuxAtomToSID(selection, 0, &obj);
    if (rc != Success)
	return rc;

    /* Check for an override context next */
    if (subj->sel_use_sid) {
	tsid = subj->sel_use_sid;
	goto out;
    }

    tsid = obj->sid;

    /* Polyinstantiate if necessary to obtain the final SID */
    if (obj->poly && avc_compute_member(subj->sid, obj->sid,
					SECCLASS_X_SELECTION, &tsid) < 0) {
	ErrorF("SELinux: a compute_member call failed!\n");
	return BadValue;
    }
out:
    *sid_rtn = tsid;
    if (poly_rtn)
	*poly_rtn = obj->poly;
    return Success;
}

/*
 * Looks up a SID for a property/subject pair
 */
int
SELinuxPropertyToSID(Atom property, SELinuxSubjectRec *subj,
		     security_id_t *sid_rtn, int *poly_rtn)
{
    int rc;
    SELinuxObjectRec *obj;
    security_id_t tsid, tsid2;

    /* Get the default context and polyinstantiation bit */
    rc = SELinuxAtomToSID(property, 1, &obj);
    if (rc != Success)
	return rc;

    /* Check for an override context next */
    if (subj->prp_use_sid) {
	tsid = subj->prp_use_sid;
	goto out;
    }

    /* Perform a transition */
    if (avc_compute_create(subj->sid, obj->sid,
			   SECCLASS_X_PROPERTY, &tsid) < 0) {
	ErrorF("SELinux: a compute_create call failed!\n");
	return BadValue;
    }

    /* Polyinstantiate if necessary to obtain the final SID */
    if (obj->poly) {
	tsid2 = tsid;
	if (avc_compute_member(subj->sid, tsid2,
			       SECCLASS_X_PROPERTY, &tsid) < 0) {
	    ErrorF("SELinux: a compute_member call failed!\n");
	    return BadValue;
	}
    }
out:
    *sid_rtn = tsid;
    if (poly_rtn)
	*poly_rtn = obj->poly;
    return Success;
}

/*
 * Looks up the SID corresponding to the given event type
 */
int
SELinuxEventToSID(unsigned type, security_id_t sid_of_window,
		  SELinuxObjectRec *sid_return)
{
    const char *name = LookupEventName(type);
    security_id_t sid;
    security_context_t ctx;
    type &= 127;

    sid = SELinuxArrayGet(&arr_events, type);
    if (!sid) {
	/* Look in the mappings of event names to contexts */
	if (selabel_lookup_raw(label_hnd, &ctx, name, SELABEL_X_EVENT) < 0) {
	    ErrorF("SELinux: an event label lookup failed!\n");
	    return BadValue;
	}
	/* Get a SID for context */
	if (avc_context_to_sid_raw(ctx, &sid) < 0) {
	    ErrorF("SELinux: a context_to_SID_raw call failed!\n");
	    freecon(ctx);
	    return BadAlloc;
	}
	freecon(ctx);
	/* Cache the SID value */
	if (!SELinuxArraySet(&arr_events, type, sid))
	    return BadAlloc;
    }

    /* Perform a transition to obtain the final SID */
    if (avc_compute_create(sid_of_window, sid, SECCLASS_X_EVENT,
			   &sid_return->sid) < 0) {
	ErrorF("SELinux: a compute_create call failed!\n");
	return BadValue;
    }

    return Success;
}

int
SELinuxExtensionToSID(const char *name, security_id_t *sid_rtn)
{
    security_context_t ctx;

    /* Look in the mappings of extension names to contexts */
    if (selabel_lookup_raw(label_hnd, &ctx, name, SELABEL_X_EXT) < 0) {
	ErrorF("SELinux: a property label lookup failed!\n");
	return BadValue;
    }
    /* Get a SID for context */
    if (avc_context_to_sid_raw(ctx, sid_rtn) < 0) {
	ErrorF("SELinux: a context_to_SID_raw call failed!\n");
	freecon(ctx);
	return BadAlloc;
    }
    freecon(ctx);
    return Success;
}

/*
 * Returns the object class corresponding to the given resource type.
 */
security_class_t
SELinuxTypeToClass(RESTYPE type)
{
    void *tmp;

    tmp = SELinuxArrayGet(&arr_types, type & TypeMask);
    if (!tmp) {
	unsigned long class = SECCLASS_X_RESOURCE;

	if (type & RC_DRAWABLE)
	    class = SECCLASS_X_DRAWABLE;
	else if (type == RT_GC)
	    class = SECCLASS_X_GC;
	else if (type == RT_FONT)
	    class = SECCLASS_X_FONT;
	else if (type == RT_CURSOR)
	    class = SECCLASS_X_CURSOR;
	else if (type == RT_COLORMAP)
	    class = SECCLASS_X_COLORMAP;
	else {
	    /* Need to do a string lookup */
	    const char *str = LookupResourceName(type);
	    if (!strcmp(str, "PICTURE"))
		class = SECCLASS_X_DRAWABLE;
	    else if (!strcmp(str, "GLYPHSET"))
		class = SECCLASS_X_FONT;
	}

	tmp = (void *)class;
	SELinuxArraySet(&arr_types, type & TypeMask, tmp);
    }

    return (security_class_t)(unsigned long)tmp;
}

security_context_t
SELinuxDefaultClientLabel(void)
{
    security_context_t ctx;

    if (selabel_lookup_raw(label_hnd, &ctx, "remote", SELABEL_X_CLIENT) < 0)
	FatalError("SELinux: failed to look up remote-client context\n");

    return ctx;
}

void
SELinuxLabelInit(void)
{
    struct selinux_opt selabel_option = { SELABEL_OPT_VALIDATE, (char *)1 };

    label_hnd = selabel_open(SELABEL_CTX_X, &selabel_option, 1);
    if (!label_hnd)
	FatalError("SELinux: Failed to open x_contexts mapping in policy\n");
}

void
SELinuxLabelReset(void)
{
    selabel_close(label_hnd);
    label_hnd = NULL;

    /* Free local state */
    SELinuxArrayFree(&arr_types, 0);
    SELinuxArrayFree(&arr_events, 0);
    SELinuxArrayFree(&arr_atoms, 1);
}
/*

   Copyright 1992, 1998  The Open Group

   Permission to use, copy, modify, distribute, and sell this software and its
   documentation for any purpose is hereby granted without fee, provided that
   the above copyright notice appear in all copies and that both that
   copyright notice and this permission notice appear in supporting
   documentation.

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.

   Except as contained in this notice, the name of The Open Group shall
   not be used in advertising or otherwise to promote the sale, use or
   other dealings in this Software without prior written authorization
   from The Open Group.

 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "windowstr.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "dixevents.h"
#include "sleepuntil.h"
#include "mi.h"
#include "xkbsrv.h"
#include "xkbstr.h"
#include <X11/extensions/xtestproto.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "mipointer.h"
#include "xserver-properties.h"
#include "exevents.h"
#include "eventstr.h"
#include "inpututils.h"

#include "modinit.h"

extern int DeviceValuator;

/* XTest events are sent during request processing and may be interruped by
 * a SIGIO. We need a separate event list to avoid events overwriting each
 * other's memory */
static InternalEvent* xtest_evlist;

/**
 * xtestpointer
 * is the virtual pointer for XTest. It is the first slave
 * device of the VCP.
 * xtestkeyboard
 * is the virtual keyboard for XTest. It is the first slave
 * device of the VCK
 *
 * Neither of these devices can be deleted.
 */
DeviceIntPtr xtestpointer, xtestkeyboard;

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

static int XTestSwapFakeInput(
        ClientPtr /* client */,
        xReq * /* req */
        );


static int
ProcXTestGetVersion(ClientPtr client)
{
    xXTestGetVersionReply rep;
    int n;

    REQUEST_SIZE_MATCH(xXTestGetVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = XTestMajorVersion;
    rep.minorVersion = XTestMinorVersion;
    if (client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xXTestGetVersionReply), (char *)&rep);
    return Success;
}

static int
ProcXTestCompareCursor(ClientPtr client)
{
    REQUEST(xXTestCompareCursorReq);
    xXTestCompareCursorReply rep;
    WindowPtr pWin;
    CursorPtr pCursor;
    int n, rc;
    DeviceIntPtr ptr = PickPointer(client);

    REQUEST_SIZE_MATCH(xXTestCompareCursorReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->cursor == None)
        pCursor = NullCursor;
    else if (stuff->cursor == XTestCurrentCursor)
        pCursor = GetSpriteCursor(ptr);
    else {
        rc = dixLookupResourceByType((pointer *)&pCursor, stuff->cursor, RT_CURSOR,
				     client, DixReadAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->cursor;
            return rc;
        }
    }
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.same = (wCursor(pWin) == pCursor);
    if (client->swapped) {
        swaps(&rep.sequenceNumber, n);
    }
    WriteToClient(client, sizeof(xXTestCompareCursorReply), (char *)&rep);
    return Success;
}

static int
ProcXTestFakeInput(ClientPtr client)
{
    REQUEST(xXTestFakeInputReq);
    int nev, n, type, rc;
    xEvent *ev;
    DeviceIntPtr dev = NULL;
    WindowPtr root;
    Bool extension = FALSE;
    deviceValuator *dv = NULL;
    ValuatorMask mask;
    int valuators[MAX_VALUATORS] = {0};
    int numValuators = 0;
    int firstValuator = 0;
    int nevents = 0;
    int i;
    int base = 0;
    int flags = 0;
    int need_ptr_update = 1;

    nev = (stuff->length << 2) - sizeof(xReq);
    if ((nev % sizeof(xEvent)) || !nev)
        return BadLength;
    nev /= sizeof(xEvent);
    UpdateCurrentTime();
    ev = (xEvent *)&((xReq *)stuff)[1];
    type = ev->u.u.type & 0177;

    if (type >= EXTENSION_EVENT_BASE)
    {
        extension = TRUE;

        /* check device */
        rc = dixLookupDevice(&dev, stuff->deviceid & 0177, client,
                DixWriteAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->deviceid & 0177;
            return rc;
        }

        /* check type */
        type -= DeviceValuator;
        switch (type) {
            case XI_DeviceKeyPress:
            case XI_DeviceKeyRelease:
                if (!dev->key)
                {
                    client->errorValue = ev->u.u.type;
                    return BadValue;
                }
                break;
            case XI_DeviceButtonPress:
            case XI_DeviceButtonRelease:
                if (!dev->button)
                {
                    client->errorValue = ev->u.u.type;
                    return BadValue;
                }
                break;
            case XI_DeviceMotionNotify:
                if (!dev->valuator)
                {
                    client->errorValue = ev->u.u.type;
                    return BadValue;
                }
                break;
            case XI_ProximityIn:
            case XI_ProximityOut:
                if (!dev->proximity)
                {
                    client->errorValue = ev->u.u.type;
                    return BadValue;
                }
                break;
            default:
                client->errorValue = ev->u.u.type;
                return BadValue;
        }

        /* check validity */
        if (nev == 1 && type == XI_DeviceMotionNotify)
            return BadLength; /* DevMotion must be followed by DevValuator */

        if (type == XI_DeviceMotionNotify)
        {
            firstValuator = ((deviceValuator *)(ev+1))->first_valuator;
            if (firstValuator > dev->valuator->numAxes)
            {
                client->errorValue = ev->u.u.type;
                return BadValue;
            }

            if (ev->u.u.detail == xFalse)
                flags |= POINTER_ABSOLUTE;
        } else
        {
            firstValuator = 0;
            flags |= POINTER_ABSOLUTE;
        }

        if (nev > 1 && !dev->valuator)
        {
            client->errorValue = dv->first_valuator;
            return BadValue;
        }


        /* check validity of valuator events */
        base = firstValuator;
        for (n = 1; n < nev; n++)
        {
            dv = (deviceValuator *)(ev + n);
            if (dv->type != DeviceValuator)
            {
                client->errorValue = dv->type;
                return BadValue;
            }
            if (dv->first_valuator != base)
            {
                client->errorValue = dv->first_valuator;
                return BadValue;
            }
            switch(dv->num_valuators)
            {
                case 6: valuators[base + 5] = dv->valuator5;
                case 5: valuators[base + 4] = dv->valuator4;
                case 4: valuators[base + 3] = dv->valuator3;
                case 3: valuators[base + 2] = dv->valuator2;
                case 2: valuators[base + 1] = dv->valuator1;
                case 1: valuators[base] = dv->valuator0;
                        break;
                default:
                        client->errorValue = dv->num_valuators;
                        return BadValue;
            }

            base += dv->num_valuators;
            numValuators += dv->num_valuators;

            if (firstValuator + numValuators > dev->valuator->numAxes)
            {
                client->errorValue = dv->num_valuators;
                return BadValue;
            }
        }
        type = type - XI_DeviceKeyPress + KeyPress;

    } else
    {
        if (nev != 1)
            return BadLength;
        switch (type)
        {
            case KeyPress:
            case KeyRelease:
                dev = PickKeyboard(client);
                break;
            case ButtonPress:
            case ButtonRelease:
                dev = PickPointer(client);
                break;
            case MotionNotify:
                dev = PickPointer(client);
                valuators[0] = ev->u.keyButtonPointer.rootX;
                valuators[1] = ev->u.keyButtonPointer.rootY;
                numValuators = 2;
                firstValuator = 0;
                if (ev->u.u.detail == xFalse)
                    flags = POINTER_ABSOLUTE | POINTER_SCREEN;
                break;
            default:
                client->errorValue = ev->u.u.type;
                return BadValue;
        }

        dev = GetXTestDevice(dev);
    }

    /* If the event has a time set, wait for it to pass */
    if (ev->u.keyButtonPointer.time)
    {
        TimeStamp activateTime;
        CARD32 ms;

        activateTime = currentTime;
        ms = activateTime.milliseconds + ev->u.keyButtonPointer.time;
        if (ms < activateTime.milliseconds)
            activateTime.months++;
        activateTime.milliseconds = ms;
        ev->u.keyButtonPointer.time = 0;

        /* see mbuf.c:QueueDisplayRequest (from the deprecated Multibuffer
         * extension) for code similar to this */

        if (!ClientSleepUntil(client, &activateTime, NULL, NULL))
        {
            return BadAlloc;
        }
        /* swap the request back so we can simply re-execute it */
        if (client->swapped)
        {
            (void) XTestSwapFakeInput(client, (xReq *)stuff);
            swaps(&stuff->length, n);
        }
        ResetCurrentRequest (client);
        client->sequence--;
        return Success;
    }

    switch (type)
    {
        case KeyPress:
        case KeyRelease:
            if (!dev->key)
                return BadDevice;

            if (ev->u.u.detail < dev->key->xkbInfo->desc->min_key_code ||
                ev->u.u.detail > dev->key->xkbInfo->desc->max_key_code)
            {
                client->errorValue = ev->u.u.detail;
                return BadValue;
            }

            need_ptr_update = 0;
            break;
        case MotionNotify:
            if (!dev->valuator)
                return BadDevice;

            if (!(extension || ev->u.keyButtonPointer.root == None))
            {
                rc = dixLookupWindow(&root, ev->u.keyButtonPointer.root,
                                     client, DixGetAttrAccess);
                if (rc != Success)
                    return rc;
                if (root->parent)
                {
                    client->errorValue = ev->u.keyButtonPointer.root;
                    return BadValue;
                }
            }
            if (ev->u.u.detail != xTrue && ev->u.u.detail != xFalse)
            {
                client->errorValue = ev->u.u.detail;
                return BadValue;
            }

            /* FIXME: Xinerama! */

            break;
        case ButtonPress:
        case ButtonRelease:
            if (!dev->button)
                return BadDevice;

            if (!ev->u.u.detail || ev->u.u.detail > dev->button->numButtons)
            {
                client->errorValue = ev->u.u.detail;
                return BadValue;
            }
            break;
    }
    if (screenIsSaved == SCREEN_SAVER_ON)
        dixSaveScreens(serverClient, SCREEN_SAVER_OFF, ScreenSaverReset);

    switch(type) {
        case MotionNotify:
            valuator_mask_set_range(&mask, firstValuator, numValuators, valuators);
            nevents = GetPointerEvents(xtest_evlist, dev, type, 0, flags, &mask);
            break;
        case ButtonPress:
        case ButtonRelease:
            valuator_mask_set_range(&mask, firstValuator, numValuators, valuators);
            nevents = GetPointerEvents(xtest_evlist, dev, type, ev->u.u.detail,
                                       flags, &mask);
            break;
        case KeyPress:
        case KeyRelease:
            nevents = GetKeyboardEvents(xtest_evlist, dev, type, ev->u.u.detail, NULL);
            break;
    }

    for (i = 0; i < nevents; i++)
        mieqProcessDeviceEvent(dev, &xtest_evlist[i], NULL);

    if (need_ptr_update)
        miPointerUpdateSprite(dev);
    return Success;
}

static int
ProcXTestGrabControl(ClientPtr client)
{
    REQUEST(xXTestGrabControlReq);

    REQUEST_SIZE_MATCH(xXTestGrabControlReq);
    if ((stuff->impervious != xTrue) && (stuff->impervious != xFalse))
    {
        client->errorValue = stuff->impervious;
        return BadValue;
    }
    if (stuff->impervious)
        MakeClientGrabImpervious(client);
    else
        MakeClientGrabPervious(client);
    return Success;
}

static int
ProcXTestDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
        case X_XTestGetVersion:
            return ProcXTestGetVersion(client);
        case X_XTestCompareCursor:
            return ProcXTestCompareCursor(client);
        case X_XTestFakeInput:
            return ProcXTestFakeInput(client);
        case X_XTestGrabControl:
            return ProcXTestGrabControl(client);
        default:
            return BadRequest;
    }
}

static int
SProcXTestGetVersion(ClientPtr client)
{
    int n;
    REQUEST(xXTestGetVersionReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXTestGetVersionReq);
    swaps(&stuff->minorVersion, n);
    return ProcXTestGetVersion(client);
}

static int
SProcXTestCompareCursor(ClientPtr client)
{
    int n;
    REQUEST(xXTestCompareCursorReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXTestCompareCursorReq);
    swapl(&stuff->window, n);
    swapl(&stuff->cursor, n);
    return ProcXTestCompareCursor(client);
}

static int
XTestSwapFakeInput(ClientPtr client, xReq *req)
{
    int nev;
    xEvent *ev;
    xEvent sev;
    EventSwapPtr proc;

    nev = ((req->length << 2) - sizeof(xReq)) / sizeof(xEvent);
    for (ev = (xEvent *)&req[1]; --nev >= 0; ev++)
    {
        /* Swap event */
        proc = EventSwapVector[ev->u.u.type & 0177];
        /* no swapping proc; invalid event type? */
        if (!proc ||  proc ==  NotImplemented) {
            client->errorValue = ev->u.u.type;
            return BadValue;
        }
        (*proc)(ev, &sev);
        *ev = sev;
    }
    return Success;
}

static int
SProcXTestFakeInput(ClientPtr client)
{
    int n;
    REQUEST(xReq);

    swaps(&stuff->length, n);
    n = XTestSwapFakeInput(client, stuff);
    if (n != Success)
        return n;
    return ProcXTestFakeInput(client);
}

static int
SProcXTestGrabControl(ClientPtr client)
{
    int n;
    REQUEST(xXTestGrabControlReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXTestGrabControlReq);
    return ProcXTestGrabControl(client);
}

static int
SProcXTestDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
        case X_XTestGetVersion:
            return SProcXTestGetVersion(client);
        case X_XTestCompareCursor:
            return SProcXTestCompareCursor(client);
        case X_XTestFakeInput:
            return SProcXTestFakeInput(client);
        case X_XTestGrabControl:
            return SProcXTestGrabControl(client);
        default:
            return BadRequest;
    }
}

/**
 * Allocate an virtual slave device for xtest events, this
 * is a slave device to inputInfo master devices
 */
void InitXTestDevices(void)
{
    if(AllocXTestDevice(serverClient, "Virtual core",
                       &xtestpointer, &xtestkeyboard,
                       inputInfo.pointer, inputInfo.keyboard) != Success)
        FatalError("Failed to allocate XTest devices");

    if (ActivateDevice(xtestpointer, TRUE) != Success ||
        ActivateDevice(xtestkeyboard, TRUE) != Success)
        FatalError("Failed to activate XTest core devices.");
    if (!EnableDevice(xtestpointer, TRUE) ||
        !EnableDevice(xtestkeyboard, TRUE))
        FatalError("Failed to enable XTest core devices.");

    AttachDevice(NULL, xtestpointer, inputInfo.pointer);
    AttachDevice(NULL, xtestkeyboard, inputInfo.keyboard);
}

/**
 * Don't allow changing the XTest property.
 */
static int
DeviceSetXTestProperty(DeviceIntPtr dev, Atom property,
                      XIPropertyValuePtr prop, BOOL checkonly)
{
    if (property == XIGetKnownProperty(XI_PROP_XTEST_DEVICE))
        return BadAccess;

    return Success;
}

/**
 * Allocate a device pair that is initialised as a slave
 * device with properties that identify the devices as belonging
 * to XTest subsystem.
 * This only creates the pair, Activate/Enable Device
 * still need to be called.
 */
int AllocXTestDevice (ClientPtr client, char* name,
                     DeviceIntPtr* ptr, DeviceIntPtr* keybd,
                     DeviceIntPtr master_ptr, DeviceIntPtr master_keybd)
{
    int retval;
    int len = strlen(name);
    char *xtestname = calloc(len + 7, 1 );
    char dummy = 1;

    strncpy( xtestname, name, len);
    strncat( xtestname, " XTEST", 6 );

    retval = AllocDevicePair( client, xtestname, ptr, keybd, CorePointerProc, CoreKeyboardProc, FALSE);
    if ( retval == Success ){
	(*ptr)->xtest_master_id = master_ptr->id;
	(*keybd)->xtest_master_id = master_keybd->id;

        XIChangeDeviceProperty(*ptr, XIGetKnownProperty(XI_PROP_XTEST_DEVICE),
                XA_INTEGER, 8, PropModeReplace, 1, &dummy,
                FALSE);
        XISetDevicePropertyDeletable(*ptr, XIGetKnownProperty(XI_PROP_XTEST_DEVICE), FALSE);
        XIRegisterPropertyHandler(*ptr, DeviceSetXTestProperty, NULL, NULL);
        XIChangeDeviceProperty(*keybd, XIGetKnownProperty(XI_PROP_XTEST_DEVICE),
                XA_INTEGER, 8, PropModeReplace, 1, &dummy,
                FALSE);
        XISetDevicePropertyDeletable(*keybd, XIGetKnownProperty(XI_PROP_XTEST_DEVICE), FALSE);
        XIRegisterPropertyHandler(*keybd, DeviceSetXTestProperty, NULL, NULL);
    }

    free( xtestname );

    return retval;
}

/**
 * If master is NULL, return TRUE if the given device is an xtest device or
 * FALSE otherwise.
 * If master is not NULL, return TRUE if the given device is this master's
 * xtest device.
 */
BOOL
IsXTestDevice(DeviceIntPtr dev, DeviceIntPtr master)
{
    if (IsMaster(dev))
        return FALSE;

    /* deviceid 0 is reserved for XIAllDevices, non-zero mid means XTest
     * device */
    if (master)
	return dev->xtest_master_id == master->id;

    return dev->xtest_master_id != 0;
}

/**
 * @return The X Test virtual device for the given master.
 */
DeviceIntPtr
GetXTestDevice(DeviceIntPtr master)
{
    DeviceIntPtr it;

    for (it = inputInfo.devices; it; it = it->next)
    {
        if (IsXTestDevice(it, master))
            return it;
    }

    /* This only happens if master is a slave device. don't do that */
    return NULL;
}

static void
XTestExtensionTearDown(ExtensionEntry *e)
{
    FreeEventList(xtest_evlist, GetMaximumEventsNum());
    xtest_evlist = NULL;
}

void
XTestExtensionInit(INITARGS)
{
    AddExtension(XTestExtensionName, 0, 0,
            ProcXTestDispatch, SProcXTestDispatch,
            XTestExtensionTearDown, StandardMinorOpcode);

    xtest_evlist = InitEventList(GetMaximumEventsNum());
}
/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"

#include <X11/extensions/Xv.h>
#include <X11/extensions/Xvproto.h>
#include "xvdix.h"
#ifdef MITSHM
#include <X11/extensions/shmproto.h>
#endif

#include "xvdisp.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"

unsigned long XvXRTPort;
#endif

static int
SWriteQueryExtensionReply(
   ClientPtr client,
   xvQueryExtensionReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->version, n);
  swaps(&rep->revision, n);
  
  (void)WriteToClient(client, sz_xvQueryExtensionReply, (char *)rep);

  return Success;
}

static int
SWriteQueryAdaptorsReply(
   ClientPtr client,
   xvQueryAdaptorsReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->num_adaptors, n);
  
  (void)WriteToClient(client, sz_xvQueryAdaptorsReply, (char *)rep);

  return Success;
}

static int
SWriteQueryEncodingsReply(
   ClientPtr client,
   xvQueryEncodingsReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->num_encodings, n);
  
  (void)WriteToClient(client, sz_xvQueryEncodingsReply, (char *)rep);

  return Success;
}

static int
SWriteAdaptorInfo(
   ClientPtr client,
   xvAdaptorInfo *pAdaptor
){
  char n;

  swapl(&pAdaptor->base_id, n);
  swaps(&pAdaptor->name_size, n);
  swaps(&pAdaptor->num_ports, n);
  swaps(&pAdaptor->num_formats, n);

  (void)WriteToClient(client, sz_xvAdaptorInfo, (char *)pAdaptor);

  return Success;
}

static int
SWriteEncodingInfo(
   ClientPtr client,
   xvEncodingInfo *pEncoding
){
  char n;
  
  swapl(&pEncoding->encoding, n);
  swaps(&pEncoding->name_size, n);
  swaps(&pEncoding->width, n);
  swaps(&pEncoding->height, n);
  swapl(&pEncoding->rate.numerator, n);
  swapl(&pEncoding->rate.denominator, n);
  (void)WriteToClient(client, sz_xvEncodingInfo, (char *)pEncoding);

  return Success;
}

static int
SWriteFormat(
   ClientPtr client,
   xvFormat *pFormat
){
  char n;

  swapl(&pFormat->visual, n);
  (void)WriteToClient(client, sz_xvFormat, (char *)pFormat);

  return Success;
}

static int
SWriteAttributeInfo(
   ClientPtr client,
   xvAttributeInfo *pAtt
){
  char n;

  swapl(&pAtt->flags, n);
  swapl(&pAtt->size, n);
  swapl(&pAtt->min, n);
  swapl(&pAtt->max, n);
  (void)WriteToClient(client, sz_xvAttributeInfo, (char *)pAtt);

  return Success;
}

static int
SWriteImageFormatInfo(
   ClientPtr client,
   xvImageFormatInfo *pImage
){
  char n;

  swapl(&pImage->id, n);
  swapl(&pImage->red_mask, n);
  swapl(&pImage->green_mask, n);
  swapl(&pImage->blue_mask, n);
  swapl(&pImage->y_sample_bits, n);
  swapl(&pImage->u_sample_bits, n);
  swapl(&pImage->v_sample_bits, n);
  swapl(&pImage->horz_y_period, n);
  swapl(&pImage->horz_u_period, n);
  swapl(&pImage->horz_v_period, n);
  swapl(&pImage->vert_y_period, n);
  swapl(&pImage->vert_u_period, n);
  swapl(&pImage->vert_v_period, n);

  (void)WriteToClient(client, sz_xvImageFormatInfo, (char *)pImage);

  return Success;
}

static int
SWriteGrabPortReply(
   ClientPtr client,
   xvGrabPortReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);

  (void)WriteToClient(client, sz_xvGrabPortReply, (char *)rep);

  return Success;
}

static int
SWriteGetPortAttributeReply(
   ClientPtr client,
   xvGetPortAttributeReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->value, n);

  (void)WriteToClient(client, sz_xvGetPortAttributeReply, (char *)rep);

  return Success;
}

static int
SWriteQueryBestSizeReply(
   ClientPtr client,
   xvQueryBestSizeReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->actual_width, n);
  swaps(&rep->actual_height, n);

  (void)WriteToClient(client, sz_xvQueryBestSizeReply, (char *)rep);

  return Success;
}

static int
SWriteQueryPortAttributesReply(
   ClientPtr client,
   xvQueryPortAttributesReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_attributes, n);
  swapl(&rep->text_size, n);

  (void)WriteToClient(client, sz_xvQueryPortAttributesReply, (char *)rep);

  return Success;
}

static int
SWriteQueryImageAttributesReply(
   ClientPtr client,
   xvQueryImageAttributesReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_planes, n);
  swapl(&rep->data_size, n);
  swaps(&rep->width, n);
  swaps(&rep->height, n);

  (void)WriteToClient(client, sz_xvQueryImageAttributesReply, (char *)rep);

  return Success;
}

static int
SWriteListImageFormatsReply(
   ClientPtr client,
   xvListImageFormatsReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_formats, n);

  (void)WriteToClient(client, sz_xvListImageFormatsReply, (char *)rep);

  return Success;
}

#define _WriteQueryAdaptorsReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryAdaptorsReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryAdaptorsReply, (char*)_d)

#define _WriteQueryExtensionReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryExtensionReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryExtensionReply, (char*)_d)

#define _WriteQueryEncodingsReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryEncodingsReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryEncodingsReply, (char*)_d)

#define _WriteAdaptorInfo(_c,_d) \
  if ((_c)->swapped) SWriteAdaptorInfo(_c, _d); \
  else WriteToClient(_c, sz_xvAdaptorInfo, (char*)_d)

#define _WriteAttributeInfo(_c,_d) \
  if ((_c)->swapped) SWriteAttributeInfo(_c, _d); \
  else WriteToClient(_c, sz_xvAttributeInfo, (char*)_d)

#define _WriteEncodingInfo(_c,_d) \
  if ((_c)->swapped) SWriteEncodingInfo(_c, _d); \
  else WriteToClient(_c, sz_xvEncodingInfo, (char*)_d)

#define _WriteFormat(_c,_d) \
  if ((_c)->swapped) SWriteFormat(_c, _d); \
  else WriteToClient(_c, sz_xvFormat, (char*)_d)

#define _WriteGrabPortReply(_c,_d) \
  if ((_c)->swapped) SWriteGrabPortReply(_c, _d); \
  else WriteToClient(_c, sz_xvGrabPortReply, (char*)_d)

#define _WriteGetPortAttributeReply(_c,_d) \
  if ((_c)->swapped) SWriteGetPortAttributeReply(_c, _d); \
  else WriteToClient(_c, sz_xvGetPortAttributeReply, (char*)_d)

#define _WriteQueryBestSizeReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryBestSizeReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryBestSizeReply,(char*) _d)

#define _WriteQueryPortAttributesReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryPortAttributesReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryPortAttributesReply,(char*) _d)

#define _WriteQueryImageAttributesReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryImageAttributesReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryImageAttributesReply,(char*) _d)

#define _WriteListImageFormatsReply(_c,_d) \
  if ((_c)->swapped) SWriteListImageFormatsReply(_c, _d); \
  else WriteToClient(_c, sz_xvListImageFormatsReply,(char*) _d)

#define _WriteImageFormatInfo(_c,_d) \
  if ((_c)->swapped) SWriteImageFormatInfo(_c, _d); \
  else WriteToClient(_c, sz_xvImageFormatInfo, (char*)_d)

#define _AllocatePort(_i,_p) \
  ((_p)->id != _i) ? (* (_p)->pAdaptor->ddAllocatePort)(_i,_p,&_p) : Success

static int
ProcXvQueryExtension(ClientPtr client)
{
  xvQueryExtensionReply rep;
  /* REQUEST(xvQueryExtensionReq); */
  REQUEST_SIZE_MATCH(xvQueryExtensionReq);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.version = XvVersion;
  rep.revision = XvRevision;

  _WriteQueryExtensionReply(client, &rep);

  return Success;
}

static int
ProcXvQueryAdaptors(ClientPtr client)
{
  xvFormat format;
  xvAdaptorInfo ainfo;
  xvQueryAdaptorsReply rep;
  int totalSize, na, nf, rc;
  int nameSize;
  XvAdaptorPtr pa;
  XvFormatPtr pf;
  WindowPtr pWin;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;

  REQUEST(xvQueryAdaptorsReq);
  REQUEST_SIZE_MATCH(xvQueryAdaptorsReq);

  rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
  if (rc != Success)
      return rc;

  pScreen = pWin->drawable.pScreen;
  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
				       XvGetScreenKey());
  if (!pxvs)
    {
      rep.type = X_Reply;
      rep.sequenceNumber = client->sequence;
      rep.num_adaptors = 0;
      rep.length = 0;

      _WriteQueryAdaptorsReply(client, &rep);

      return Success;
    }

  (* pxvs->ddQueryAdaptors)(pScreen, &pxvs->pAdaptors, &pxvs->nAdaptors);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_adaptors = pxvs->nAdaptors;

  /* CALCULATE THE TOTAL SIZE OF THE REPLY IN BYTES */

  totalSize = pxvs->nAdaptors * sz_xvAdaptorInfo;

  /* FOR EACH ADPATOR ADD UP THE BYTES FOR ENCODINGS AND FORMATS */

  na = pxvs->nAdaptors;
  pa = pxvs->pAdaptors;
  while (na--)
    {
      totalSize += pad_to_int32(strlen(pa->name));
      totalSize += pa->nFormats * sz_xvFormat;
      pa++;
    }

  rep.length = bytes_to_int32(totalSize);

  _WriteQueryAdaptorsReply(client, &rep);

  na = pxvs->nAdaptors;
  pa = pxvs->pAdaptors;
  while (na--)
    {

      ainfo.base_id = pa->base_id;
      ainfo.num_ports = pa->nPorts;
      ainfo.type = pa->type;
      ainfo.name_size = nameSize = strlen(pa->name);
      ainfo.num_formats = pa->nFormats;

      _WriteAdaptorInfo(client, &ainfo);

      WriteToClient(client, nameSize, pa->name);

      nf = pa->nFormats;
      pf = pa->pFormats;
      while (nf--)
	{
	  format.depth = pf->depth;
	  format.visual = pf->visual;
	  _WriteFormat(client, &format);
	  pf++;
	}

      pa++;

    }

  return Success;
}

static int
ProcXvQueryEncodings(ClientPtr client)
{
  xvEncodingInfo einfo;
  xvQueryEncodingsReply rep;
  int totalSize;
  int nameSize;
  XvPortPtr pPort;
  int ne;
  XvEncodingPtr pe;
  int status;

  REQUEST(xvQueryEncodingsReq);
  REQUEST_SIZE_MATCH(xvQueryEncodingsReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_encodings = pPort->pAdaptor->nEncodings;

  /* FOR EACH ENCODING ADD UP THE BYTES FOR ENCODING NAMES */

  ne = pPort->pAdaptor->nEncodings;
  pe = pPort->pAdaptor->pEncodings;
  totalSize = ne * sz_xvEncodingInfo;
  while (ne--)
    {
      totalSize += pad_to_int32(strlen(pe->name));
      pe++;
    }

  rep.length = bytes_to_int32(totalSize);

  _WriteQueryEncodingsReply(client, &rep);

  ne = pPort->pAdaptor->nEncodings;
  pe = pPort->pAdaptor->pEncodings;
  while (ne--) 
    {
      einfo.encoding = pe->id;
      einfo.name_size = nameSize = strlen(pe->name);
      einfo.width = pe->width;
      einfo.height = pe->height;
      einfo.rate.numerator = pe->rate.numerator;
      einfo.rate.denominator = pe->rate.denominator;
      _WriteEncodingInfo(client, &einfo);
      WriteToClient(client, nameSize, pe->name);
      pe++;
    }

  return Success;
}

static int
ProcXvPutVideo(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;

  REQUEST(xvPutVideoReq);
  REQUEST_SIZE_MATCH(xvPutVideoReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvInputMask) ||
	!(pPort->pAdaptor->type & XvVideoMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  return XvdiPutVideo(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
}

static int
ProcXvPutStill(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;

  REQUEST(xvPutStillReq);
  REQUEST_SIZE_MATCH(xvPutStillReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvInputMask) ||
	!(pPort->pAdaptor->type & XvStillMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  return XvdiPutStill(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
}

static int
ProcXvGetVideo(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;

  REQUEST(xvGetVideoReq);
  REQUEST_SIZE_MATCH(xvGetVideoReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixReadAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvOutputMask) ||
	!(pPort->pAdaptor->type & XvVideoMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  return XvdiGetVideo(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
}

static int
ProcXvGetStill(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;

  REQUEST(xvGetStillReq);
  REQUEST_SIZE_MATCH(xvGetStillReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixReadAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvOutputMask) ||
	!(pPort->pAdaptor->type & XvStillMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  return XvdiGetStill(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
}

static int
ProcXvSelectVideoNotify(ClientPtr client)
{
  DrawablePtr pDraw;
  int rc;
  REQUEST(xvSelectVideoNotifyReq);
  REQUEST_SIZE_MATCH(xvSelectVideoNotifyReq);

  rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixReceiveAccess);
  if (rc != Success)
    return rc;

  return XvdiSelectVideoNotify(client, pDraw, stuff->onoff);
}

static int
ProcXvSelectPortNotify(ClientPtr client)
{
  int status;
  XvPortPtr pPort;
  REQUEST(xvSelectPortNotifyReq);
  REQUEST_SIZE_MATCH(xvSelectPortNotifyReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  return XvdiSelectPortNotify(client, pPort, stuff->onoff);
}

static int
ProcXvGrabPort(ClientPtr client)
{
  int result, status;
  XvPortPtr pPort;
  xvGrabPortReply rep;
  REQUEST(xvGrabPortReq);
  REQUEST_SIZE_MATCH(xvGrabPortReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  status = XvdiGrabPort(client, pPort, stuff->time, &result);

  if (status != Success)
    {
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.result = result;

  _WriteGrabPortReply(client, &rep);

  return Success;
}

static int
ProcXvUngrabPort(ClientPtr client)
{
  int status;
  XvPortPtr pPort;
  REQUEST(xvGrabPortReq);
  REQUEST_SIZE_MATCH(xvGrabPortReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  return XvdiUngrabPort(client, pPort, stuff->time);
}

static int
ProcXvStopVideo(ClientPtr client)
{
  int status, rc;
  DrawablePtr pDraw;
  XvPortPtr pPort;
  REQUEST(xvStopVideoReq);
  REQUEST_SIZE_MATCH(xvStopVideoReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixWriteAccess);
  if (rc != Success)
    return rc;

  return XvdiStopVideo(client, pPort, pDraw);
}

static int
ProcXvSetPortAttribute(ClientPtr client)
{
  int status;
  XvPortPtr pPort;
  REQUEST(xvSetPortAttributeReq);
  REQUEST_SIZE_MATCH(xvSetPortAttributeReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixSetAttrAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!ValidAtom(stuff->attribute))
    {
      client->errorValue = stuff->attribute;
      return BadAtom;
    }

  status = XvdiSetPortAttribute(client, pPort, stuff->attribute, stuff->value);

  if (status == BadMatch) 
      client->errorValue = stuff->attribute;
  else
      client->errorValue = stuff->value;

  return status;
}

static int
ProcXvGetPortAttribute(ClientPtr client)
{
  INT32 value;
  int status;
  XvPortPtr pPort;
  xvGetPortAttributeReply rep;
  REQUEST(xvGetPortAttributeReq);
  REQUEST_SIZE_MATCH(xvGetPortAttributeReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixGetAttrAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!ValidAtom(stuff->attribute))
    {
      client->errorValue = stuff->attribute;
      return BadAtom;
    }

  status = XvdiGetPortAttribute(client, pPort, stuff->attribute, &value);
  if (status != Success)
    {
      client->errorValue = stuff->attribute;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.value = value;
 
  _WriteGetPortAttributeReply(client, &rep);

  return Success;
}

static int
ProcXvQueryBestSize(ClientPtr client)
{
  int status;
  unsigned int actual_width, actual_height;
  XvPortPtr pPort;
  xvQueryBestSizeReply rep;
  REQUEST(xvQueryBestSizeReq);
  REQUEST_SIZE_MATCH(xvQueryBestSizeReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;

  (* pPort->pAdaptor->ddQueryBestSize)(client, pPort, stuff->motion,
				       stuff->vid_w, stuff->vid_h, 
				       stuff->drw_w, stuff->drw_h, 
				       &actual_width, &actual_height);

  rep.actual_width = actual_width;
  rep.actual_height = actual_height;
 
  _WriteQueryBestSizeReply(client, &rep);

  return Success;
}


static int
ProcXvQueryPortAttributes(ClientPtr client)
{
  int status, size, i;
  XvPortPtr pPort;
  XvAttributePtr pAtt;
  xvQueryPortAttributesReply rep;
  xvAttributeInfo Info;
  REQUEST(xvQueryPortAttributesReq);
  REQUEST_SIZE_MATCH(xvQueryPortAttributesReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixGetAttrAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_attributes = pPort->pAdaptor->nAttributes;
  rep.text_size = 0;

  for(i = 0, pAtt = pPort->pAdaptor->pAttributes; 
      i < pPort->pAdaptor->nAttributes; i++, pAtt++) 
  {    
      rep.text_size += pad_to_int32(strlen(pAtt->name) + 1);
  }

  rep.length = (pPort->pAdaptor->nAttributes * sz_xvAttributeInfo)
      + rep.text_size;
  rep.length >>= 2;

  _WriteQueryPortAttributesReply(client, &rep);

  for(i = 0, pAtt = pPort->pAdaptor->pAttributes; 
      i < pPort->pAdaptor->nAttributes; i++, pAtt++) 
  {
      size = strlen(pAtt->name) + 1;  /* pass the NULL */
      Info.flags = pAtt->flags;
      Info.min = pAtt->min_value;
      Info.max = pAtt->max_value;
      Info.size = pad_to_int32(size);

      _WriteAttributeInfo(client, &Info);

      WriteToClient(client, size, pAtt->name);
  }

  return Success;
}

static int 
ProcXvPutImage(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  XvImagePtr pImage = NULL;
  GCPtr pGC;
  int status, i, size;
  CARD16 width, height;

  REQUEST(xvPutImageReq);
  REQUEST_AT_LEAST_SIZE(xvPutImageReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvImageMask) ||
	!(pPort->pAdaptor->type & XvInputMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }

  if(!pImage)
     return BadMatch;

  width = stuff->width;
  height = stuff->height;
  size = (*pPort->pAdaptor->ddQueryImageAttributes)(client, 
			pPort, pImage, &width, &height, NULL, NULL);
  size += sizeof(xvPutImageReq);
  size = bytes_to_int32(size);
  
  if((width < stuff->width) || (height < stuff->height))
     return BadValue;

  if(client->req_len < size)
     return BadLength;

  return XvdiPutImage(client, pDraw, pPort, pGC, stuff->src_x, stuff->src_y,
		      stuff->src_w, stuff->src_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h, pImage,
		      (unsigned char*)(&stuff[1]), FALSE,
		      stuff->width, stuff->height);
}

#ifdef MITSHM
/* redefined here since it's not in any header file */
typedef struct _ShmDesc {
    struct _ShmDesc *next;
    int shmid;
    int refcnt;
    char *addr;
    Bool writable;
    unsigned long size;
} ShmDescRec, *ShmDescPtr;

extern RESTYPE ShmSegType;
extern int ShmCompletionCode;

static int 
ProcXvShmPutImage(ClientPtr client)
{
  ShmDescPtr shmdesc;
  DrawablePtr pDraw;
  XvPortPtr pPort;
  XvImagePtr pImage = NULL;
  GCPtr pGC;
  int status, size_needed, i;
  CARD16 width, height;

  REQUEST(xvShmPutImageReq);
  REQUEST_SIZE_MATCH(xvShmPutImageReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvImageMask) ||
	!(pPort->pAdaptor->type & XvInputMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }

  if(!pImage)
     return BadMatch;

  status = dixLookupResourceByType((pointer *)&shmdesc, stuff->shmseg,
				   ShmSegType, serverClient, DixReadAccess);
  if (status != Success)
      return status;
 
  width = stuff->width;
  height = stuff->height;
  size_needed = (*pPort->pAdaptor->ddQueryImageAttributes)(client, 
			pPort, pImage, &width, &height, NULL, NULL);
  if((size_needed + stuff->offset) > shmdesc->size)
      return BadAccess;

  if((width < stuff->width) || (height < stuff->height))
     return BadValue;
     
  status = XvdiPutImage(client, pDraw, pPort, pGC, stuff->src_x, stuff->src_y,
			stuff->src_w, stuff->src_h, stuff->drw_x, stuff->drw_y,
			stuff->drw_w, stuff->drw_h, pImage,
			(unsigned char *)shmdesc->addr + stuff->offset, 
			stuff->send_event, stuff->width, stuff->height);

  if((status == Success) && stuff->send_event) {
        xShmCompletionEvent ev;

        ev.type = ShmCompletionCode;
        ev.drawable = stuff->drawable;
        ev.minorEvent = xv_ShmPutImage;
        ev.majorEvent = XvReqCode;
        ev.shmseg = stuff->shmseg;
        ev.offset = stuff->offset;
        WriteEventsToClient(client, 1, (xEvent *) &ev);
  }

  return status;
}
#else /* !MITSHM */
static int
ProcXvShmPutImage(ClientPtr client)
{
    SendErrorToClient(client, XvReqCode, xv_ShmPutImage, 0, BadImplementation);
    return BadImplementation;
}
#endif

#ifdef XvMCExtension
#include "xvmcext.h"
#endif

static int 
ProcXvQueryImageAttributes(ClientPtr client)
{
  xvQueryImageAttributesReply rep;
  int size, num_planes, i;
  CARD16 width, height;
  XvImagePtr pImage = NULL;
  XvPortPtr pPort;
  int *offsets;
  int *pitches;
  int planeLength;
  REQUEST(xvQueryImageAttributesReq);

  REQUEST_SIZE_MATCH(xvQueryImageAttributesReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
  
  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }

#ifdef XvMCExtension
  if(!pImage)
     pImage = XvMCFindXvImage(pPort, stuff->id);
#endif

  if(!pImage)
     return BadMatch;

  num_planes = pImage->num_planes;

  if(!(offsets = malloc(num_planes << 3)))
	return BadAlloc;
  pitches = offsets + num_planes;

  width = stuff->width;
  height = stuff->height;

  size = (*pPort->pAdaptor->ddQueryImageAttributes)(client, pPort, pImage,
					&width, &height, offsets, pitches);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = planeLength = num_planes << 1;
  rep.num_planes = num_planes;
  rep.width = width;
  rep.height = height;
  rep.data_size = size;
 
  _WriteQueryImageAttributesReply(client, &rep);
  if(client->swapped)
    SwapLongs((CARD32*)offsets, planeLength);
  WriteToClient(client, planeLength << 2, (char*)offsets);

  free(offsets);

  return Success;
}

static int 
ProcXvListImageFormats(ClientPtr client)
{
  XvPortPtr pPort;
  XvImagePtr pImage;
  int i;
  xvListImageFormatsReply rep;
  xvImageFormatInfo info;
  REQUEST(xvListImageFormatsReq);

  REQUEST_SIZE_MATCH(xvListImageFormatsReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_formats = pPort->pAdaptor->nImages;
  rep.length = bytes_to_int32(pPort->pAdaptor->nImages * sz_xvImageFormatInfo);

  _WriteListImageFormatsReply(client, &rep);

  pImage = pPort->pAdaptor->pImages;
  
  for(i = 0; i < pPort->pAdaptor->nImages; i++, pImage++) {
     info.id = pImage->id; 	
     info.type = pImage->type; 	
     info.byte_order = pImage->byte_order; 
     memcpy(&info.guid, pImage->guid, 16);	
     info.bpp = pImage->bits_per_pixel; 	
     info.num_planes = pImage->num_planes; 	
     info.depth = pImage->depth; 	
     info.red_mask = pImage->red_mask; 	
     info.green_mask = pImage->green_mask; 	
     info.blue_mask = pImage->blue_mask; 	
     info.format = pImage->format; 	
     info.y_sample_bits = pImage->y_sample_bits; 	
     info.u_sample_bits = pImage->u_sample_bits; 	
     info.v_sample_bits = pImage->v_sample_bits; 	
     info.horz_y_period = pImage->horz_y_period; 	
     info.horz_u_period = pImage->horz_u_period; 	
     info.horz_v_period = pImage->horz_v_period; 	
     info.vert_y_period = pImage->vert_y_period; 	
     info.vert_u_period = pImage->vert_u_period; 	
     info.vert_v_period = pImage->vert_v_period; 	
     memcpy(&info.comp_order, pImage->component_order, 32);	
     info.scanline_order = pImage->scanline_order;
     _WriteImageFormatInfo(client, &info);
  }  

  return Success;
}

static int (*XvProcVector[xvNumRequests])(ClientPtr) = {
    ProcXvQueryExtension,
    ProcXvQueryAdaptors,
    ProcXvQueryEncodings,
    ProcXvGrabPort,
    ProcXvUngrabPort,
    ProcXvPutVideo,
    ProcXvPutStill,
    ProcXvGetVideo,
    ProcXvGetStill,
    ProcXvStopVideo,
    ProcXvSelectVideoNotify,
    ProcXvSelectPortNotify,
    ProcXvQueryBestSize,
    ProcXvSetPortAttribute,
    ProcXvGetPortAttribute,
    ProcXvQueryPortAttributes,
    ProcXvListImageFormats,
    ProcXvQueryImageAttributes,
    ProcXvPutImage,
    ProcXvShmPutImage,
};

int
ProcXvDispatch(ClientPtr client)
{
  REQUEST(xReq);

  UpdateCurrentTime();

  if (stuff->data > xvNumRequests) {
    SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
    return BadRequest;
  }

  return XvProcVector[stuff->data](client);
}

/* Swapped Procs */

static int
SProcXvQueryExtension(ClientPtr client)
{
  char n;
  REQUEST(xvQueryExtensionReq);
  swaps(&stuff->length, n);
  return XvProcVector[xv_QueryExtension](client);
}

static int
SProcXvQueryAdaptors(ClientPtr client)
{
  char n;
  REQUEST(xvQueryAdaptorsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->window, n);
  return XvProcVector[xv_QueryAdaptors](client);
}

static int
SProcXvQueryEncodings(ClientPtr client)
{
  char n;
  REQUEST(xvQueryEncodingsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_QueryEncodings](client);
}

static int
SProcXvGrabPort(ClientPtr client)
{
  char n;
  REQUEST(xvGrabPortReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->time, n);
  return XvProcVector[xv_GrabPort](client);
}

static int
SProcXvUngrabPort(ClientPtr client)
{
  char n;
  REQUEST(xvUngrabPortReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->time, n);
  return XvProcVector[xv_UngrabPort](client);
}

static int
SProcXvPutVideo(ClientPtr client)
{
  char n;
  REQUEST(xvPutVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_PutVideo](client);
}

static int
SProcXvPutStill(ClientPtr client)
{
  char n;
  REQUEST(xvPutStillReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_PutStill](client);
}

static int
SProcXvGetVideo(ClientPtr client)
{
  char n;
  REQUEST(xvGetVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_GetVideo](client);
}

static int
SProcXvGetStill(ClientPtr client)
{
  char n;
  REQUEST(xvGetStillReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_GetStill](client);
}

static int
SProcXvPutImage(ClientPtr client)
{
  char n;
  REQUEST(xvPutImageReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swapl(&stuff->id, n);
  swaps(&stuff->src_x, n);
  swaps(&stuff->src_y, n);
  swaps(&stuff->src_w, n);
  swaps(&stuff->src_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_PutImage](client);
}

#ifdef MITSHM
static int
SProcXvShmPutImage(ClientPtr client)
{
  char n;
  REQUEST(xvShmPutImageReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swapl(&stuff->shmseg, n);
  swapl(&stuff->id, n);
  swapl(&stuff->offset, n);
  swaps(&stuff->src_x, n);
  swaps(&stuff->src_y, n);
  swaps(&stuff->src_w, n);
  swaps(&stuff->src_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_ShmPutImage](client);
}
#else /* MITSHM */
#define SProcXvShmPutImage ProcXvShmPutImage
#endif

static int
SProcXvSelectVideoNotify(ClientPtr client)
{
  char n;
  REQUEST(xvSelectVideoNotifyReq);
  swaps(&stuff->length, n);
  swapl(&stuff->drawable, n);
  return XvProcVector[xv_SelectVideoNotify](client);
}

static int
SProcXvSelectPortNotify(ClientPtr client)
{
  char n;
  REQUEST(xvSelectPortNotifyReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_SelectPortNotify](client);
}

static int
SProcXvStopVideo(ClientPtr client)
{
  char n;
  REQUEST(xvStopVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  return XvProcVector[xv_StopVideo](client);
}

static int
SProcXvSetPortAttribute(ClientPtr client)
{
  char n;
  REQUEST(xvSetPortAttributeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->attribute, n);
  swapl(&stuff->value, n);
  return XvProcVector[xv_SetPortAttribute](client);
}

static int
SProcXvGetPortAttribute(ClientPtr client)
{
  char n;
  REQUEST(xvGetPortAttributeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->attribute, n);
  return XvProcVector[xv_GetPortAttribute](client);
}

static int
SProcXvQueryBestSize(ClientPtr client)
{
  char n;
  REQUEST(xvQueryBestSizeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_QueryBestSize](client);
}

static int
SProcXvQueryPortAttributes(ClientPtr client)
{
  char n;
  REQUEST(xvQueryPortAttributesReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_QueryPortAttributes](client);
}

static int
SProcXvQueryImageAttributes(ClientPtr client)
{
  char n;
  REQUEST(xvQueryImageAttributesReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->id, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_QueryImageAttributes](client);
}

static int
SProcXvListImageFormats(ClientPtr client)
{
  char n;
  REQUEST(xvListImageFormatsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_ListImageFormats](client);
}

static int (*SXvProcVector[xvNumRequests])(ClientPtr) = {
    SProcXvQueryExtension,
    SProcXvQueryAdaptors,
    SProcXvQueryEncodings,
    SProcXvGrabPort,
    SProcXvUngrabPort,
    SProcXvPutVideo,
    SProcXvPutStill,
    SProcXvGetVideo,
    SProcXvGetStill,
    SProcXvStopVideo,
    SProcXvSelectVideoNotify,
    SProcXvSelectPortNotify,
    SProcXvQueryBestSize,
    SProcXvSetPortAttribute,
    SProcXvGetPortAttribute,
    SProcXvQueryPortAttributes,
    SProcXvListImageFormats,
    SProcXvQueryImageAttributes,
    SProcXvPutImage,
    SProcXvShmPutImage,
};

int
SProcXvDispatch(ClientPtr client)
{
  REQUEST(xReq);

  UpdateCurrentTime();

  if (stuff->data > xvNumRequests) {
    SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
    return BadRequest;
  }

  return SXvProcVector[stuff->data](client);
}

#ifdef PANORAMIX
static int
XineramaXvStopVideo(ClientPtr client)
{
   int result, i;
   PanoramiXRes *draw, *port;
   REQUEST(xvStopVideoReq);
   REQUEST_SIZE_MATCH(xvStopVideoReq);

   result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				     XRC_DRAWABLE, client, DixWriteAccess);
   if (result != Success)
       return (result == BadValue) ? BadDrawable : result;

   result = dixLookupResourceByType((pointer *)&port, stuff->port,
				    XvXRTPort, client, DixReadAccess);
   if (result != Success)
       return result;

   FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   result = ProcXvStopVideo(client);
     	}
   }

   return result;
}

static int
XineramaXvSetPortAttribute(ClientPtr client)
{
    REQUEST(xvSetPortAttributeReq);
    PanoramiXRes *port;
    int result, i;

    REQUEST_SIZE_MATCH(xvSetPortAttributeReq);

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->port = port->info[i].id;
	   result = ProcXvSetPortAttribute(client);
	}
    }
    return result;
}

#ifdef MITSHM
static int 
XineramaXvShmPutImage(ClientPtr client)
{
    REQUEST(xvShmPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool send_event = stuff->send_event;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_SIZE_MATCH(xvShmPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;
 
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   stuff->gc = gc->info[i].id;
	   stuff->drw_x = x;
	   stuff->drw_y = y;
	   if(isRoot) {
		stuff->drw_x -= screenInfo.screens[i]->x;
		stuff->drw_y -= screenInfo.screens[i]->y;
	   }
	   stuff->send_event = (send_event && !i) ? 1 : 0;

	   result = ProcXvShmPutImage(client);
	}
    }
    return result;
}
#else
#define XineramaXvShmPutImage ProcXvShmPutImage
#endif

static int 
XineramaXvPutImage(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;
 
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   stuff->gc = gc->info[i].id;
	   stuff->drw_x = x;
	   stuff->drw_y = y;
	   if(isRoot) {
		stuff->drw_x -= screenInfo.screens[i]->x;
		stuff->drw_y -= screenInfo.screens[i]->y;
	   }

	   result = ProcXvPutImage(client);
	}
    }
    return result;
}

static int
XineramaXvPutVideo(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutVideoReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
        if(port->info[i].id) {
           stuff->drawable = draw->info[i].id;
           stuff->port = port->info[i].id;
           stuff->gc = gc->info[i].id;
           stuff->drw_x = x;
           stuff->drw_y = y;
           if(isRoot) {
                stuff->drw_x -= screenInfo.screens[i]->x;
                stuff->drw_y -= screenInfo.screens[i]->y;
           }

           result = ProcXvPutVideo(client);
        }
    }
    return result;
}

static int
XineramaXvPutStill(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
        if(port->info[i].id) {
           stuff->drawable = draw->info[i].id;
           stuff->port = port->info[i].id;
           stuff->gc = gc->info[i].id;
           stuff->drw_x = x;
           stuff->drw_y = y;
           if(isRoot) {
                stuff->drw_x -= screenInfo.screens[i]->x;
                stuff->drw_y -= screenInfo.screens[i]->y;
           }

           result = ProcXvPutStill(client);
        }
    }
    return result;
}

static Bool
isImageAdaptor(XvAdaptorPtr pAdapt)
{
    return (pAdapt->type & XvImageMask) && (pAdapt->nImages > 0);
}

static Bool
hasOverlay(XvAdaptorPtr pAdapt)
{
    int i;
    for(i = 0; i < pAdapt->nAttributes; i++)
	if(!strcmp(pAdapt->pAttributes[i].name, "XV_COLORKEY"))
	    return TRUE;
    return FALSE;
}

static XvAdaptorPtr
matchAdaptor(ScreenPtr pScreen, XvAdaptorPtr refAdapt, Bool isOverlay)
{
    int i;
    XvScreenPtr xvsp = dixLookupPrivate(&pScreen->devPrivates, XvGetScreenKey());
    /* Do not try to go on if xv is not supported on this screen */
    if(xvsp == NULL)
	return NULL;

    /* if the adaptor has the same name it's a perfect match */
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(!strcmp(refAdapt->name, pAdapt->name))
	    return pAdapt;
    }

    /* otherwise we only look for XvImage adaptors */
    if(!isImageAdaptor(refAdapt))
	return NULL;

    /* prefer overlay/overlay non-overlay/non-overlay pairing */
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(isImageAdaptor(pAdapt) && isOverlay == hasOverlay(pAdapt))
	    return pAdapt;
    }

    /* but we'll take any XvImage pairing if we can get it */
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(isImageAdaptor(pAdapt))
	    return pAdapt;
    }
    return NULL;
}

void XineramifyXv(void)
{
   XvScreenPtr xvsp0 = dixLookupPrivate(&screenInfo.screens[0]->devPrivates, XvGetScreenKey());
   XvAdaptorPtr MatchingAdaptors[MAXSCREENS];
   int i, j, k;

   XvXRTPort = CreateNewResourceType(XineramaDeleteResource, "XvXRTPort");

   if (!xvsp0 || !XvXRTPort) return;
   SetResourceTypeErrorValue(XvXRTPort, _XvBadPort);

   for(i = 0; i < xvsp0->nAdaptors; i++) {
      Bool isOverlay;
      XvAdaptorPtr refAdapt = xvsp0->pAdaptors + i;
      if(!(refAdapt->type & XvInputMask)) continue;

      MatchingAdaptors[0] = refAdapt;
      isOverlay = hasOverlay(refAdapt);
      FOR_NSCREENS_FORWARD_SKIP(j)
	 MatchingAdaptors[j] = matchAdaptor(screenInfo.screens[j], refAdapt, isOverlay);

      /* now create a resource for each port */
      for(j = 0; j < refAdapt->nPorts; j++) {
	 PanoramiXRes *port = malloc(sizeof(PanoramiXRes));
	 if(!port)
	    break;

	 FOR_NSCREENS(k) {
	    if(MatchingAdaptors[k] && (MatchingAdaptors[k]->nPorts > j)) 
		port->info[k].id = MatchingAdaptors[k]->base_id + j;
	    else
		port->info[k].id = 0;
	 } 
	 AddResource(port->info[0].id, XvXRTPort, port);
      }
   }

   /* munge the dispatch vector */
   XvProcVector[xv_PutVideo]		= XineramaXvPutVideo;
   XvProcVector[xv_PutStill]		= XineramaXvPutStill;
   XvProcVector[xv_StopVideo]		= XineramaXvStopVideo;
   XvProcVector[xv_SetPortAttribute]	= XineramaXvSetPortAttribute;
   XvProcVector[xv_PutImage]		= XineramaXvPutImage;
   XvProcVector[xv_ShmPutImage]		= XineramaXvShmPutImage;
}
#endif /* PANORAMIX */

void
XvResetProcVector(void)
{
#ifdef PANORAMIX
   XvProcVector[xv_PutVideo]		= ProcXvPutVideo;
   XvProcVector[xv_PutStill]		= ProcXvPutStill;
   XvProcVector[xv_StopVideo]		= ProcXvStopVideo;
   XvProcVector[xv_SetPortAttribute]	= ProcXvSetPortAttribute;
   XvProcVector[xv_PutImage]		= ProcXvPutImage;
   XvProcVector[xv_ShmPutImage]		= ProcXvShmPutImage;
#endif
}
extern void XineramifyXv(void);
extern void XvResetProcVector(void);
/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef XVDIX_H
#define XVDIX_H
/*
** File: 
**
**   xvdix.h --- Xv device independent header file
**
** Author: 
**
**   David Carver (Digital Workstation Engineering/Project Athena)
**
** Revisions:
**
**   29.08.91 Carver
**     - removed UnrealizeWindow wrapper unrealizing windows no longer 
**       preempts video
**
**   11.06.91 Carver
**     - changed SetPortControl to SetPortAttribute
**     - changed GetPortControl to GetPortAttribute
**     - changed QueryBestSize
**
**   15.05.91 Carver
**     - version 2.0 upgrade
**
**   24.01.91 Carver
**     - version 1.4 upgrade
**
*/

#include "scrnintstr.h"
#include <X11/extensions/Xvproto.h>

#ifndef XorgLoader
extern _X_EXPORT unsigned long XvExtensionGeneration;
extern _X_EXPORT unsigned long XvScreenGeneration;
extern _X_EXPORT unsigned long XvResourceGeneration;

extern _X_EXPORT int XvReqCode;
extern _X_EXPORT int XvEventBase;
extern _X_EXPORT int XvErrorBase;

extern _X_EXPORT RESTYPE XvRTPort;
extern _X_EXPORT RESTYPE XvRTEncoding;
extern _X_EXPORT RESTYPE XvRTGrab;
extern _X_EXPORT RESTYPE XvRTVideoNotify;
extern _X_EXPORT RESTYPE XvRTVideoNotifyList;
extern _X_EXPORT RESTYPE XvRTPortNotify;
#endif

typedef struct {
  int numerator;
  int denominator;
} XvRationalRec, *XvRationalPtr;

typedef struct {
  char depth;
  unsigned long visual;
} XvFormatRec, *XvFormatPtr;

typedef struct {
  unsigned long id;
  ClientPtr client;
} XvGrabRec, *XvGrabPtr;

typedef struct _XvVideoNotifyRec {
  struct _XvVideoNotifyRec *next;
  ClientPtr client;
  unsigned long id;
  unsigned long mask;
} XvVideoNotifyRec, *XvVideoNotifyPtr;

typedef struct _XvPortNotifyRec {
  struct _XvPortNotifyRec *next;
  ClientPtr client;
  unsigned long id;
} XvPortNotifyRec, *XvPortNotifyPtr;

typedef struct {
  int id;
  ScreenPtr pScreen;
  char *name;
  unsigned short width, height;
  XvRationalRec rate;
} XvEncodingRec, *XvEncodingPtr;

typedef struct _XvAttributeRec {
  int flags;
  int min_value;
  int max_value;
  char *name;
} XvAttributeRec, *XvAttributePtr;

typedef struct {
  int id;
  int type;
  int byte_order;
  char guid[16];
  int bits_per_pixel;
  int format;
  int num_planes;

  /* for RGB formats only */
  int depth;
  unsigned int red_mask;       
  unsigned int green_mask;   
  unsigned int blue_mask;   

  /* for YUV formats only */
  unsigned int y_sample_bits;
  unsigned int u_sample_bits;
  unsigned int v_sample_bits;   
  unsigned int horz_y_period;
  unsigned int horz_u_period;
  unsigned int horz_v_period;
  unsigned int vert_y_period;
  unsigned int vert_u_period;
  unsigned int vert_v_period;
  char component_order[32];
  int scanline_order;
} XvImageRec, *XvImagePtr; 

typedef struct {
  unsigned long base_id;
  unsigned char type; 
  char *name;
  int nEncodings;
  XvEncodingPtr pEncodings;  
  int nFormats;
  XvFormatPtr pFormats; 
  int nAttributes;
  XvAttributePtr pAttributes;
  int nImages;
  XvImagePtr pImages;
  int nPorts;
  struct _XvPortRec *pPorts;
  ScreenPtr pScreen; 
  int (* ddAllocatePort)(unsigned long, struct _XvPortRec*, 
				struct _XvPortRec**);
  int (* ddFreePort)(struct _XvPortRec*);
  int (* ddPutVideo)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16); 
  int (* ddPutStill)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
  int (* ddGetVideo)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
  int (* ddGetStill)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
  int (* ddStopVideo)(ClientPtr, struct _XvPortRec*, DrawablePtr);
  int (* ddSetPortAttribute)(ClientPtr, struct _XvPortRec*, Atom, INT32);
  int (* ddGetPortAttribute)(ClientPtr, struct _XvPortRec*, Atom, INT32*);
  int (* ddQueryBestSize)(ClientPtr, struct _XvPortRec*, CARD8,
   				CARD16, CARD16,CARD16, CARD16, 
				unsigned int*, unsigned int*);
  int (* ddPutImage)(ClientPtr, DrawablePtr, struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16,
				XvImagePtr, unsigned char*, Bool,
				CARD16, CARD16);
  int (* ddQueryImageAttributes)(ClientPtr, struct _XvPortRec*, XvImagePtr, 
				CARD16*, CARD16*, int*, int*);
  DevUnion devPriv;
} XvAdaptorRec, *XvAdaptorPtr;

typedef struct _XvPortRec {
  unsigned long id;
  XvAdaptorPtr pAdaptor;
  XvPortNotifyPtr pNotify;
  DrawablePtr pDraw;
  ClientPtr client;
  XvGrabRec grab;
  TimeStamp time;
  DevUnion devPriv;
} XvPortRec, *XvPortPtr;

#define VALIDATE_XV_PORT(portID, pPort, mode)\
    {\
	int rc = dixLookupResourceByType((pointer *)&(pPort), portID,\
	                                 XvRTPort, client, mode);\
	if (rc != Success)\
	    return rc;\
    }

typedef struct {
  int version, revision;
  int nAdaptors;
  XvAdaptorPtr pAdaptors;
  DestroyWindowProcPtr DestroyWindow;
  DestroyPixmapProcPtr DestroyPixmap;
  CloseScreenProcPtr CloseScreen;
  Bool (* ddCloseScreen)(int, ScreenPtr);
  int (* ddQueryAdaptors)(ScreenPtr, XvAdaptorPtr*, int*);
  DevUnion devPriv;
} XvScreenRec, *XvScreenPtr;

#define SCREEN_PROLOGUE(pScreen, field) ((pScreen)->field = ((XvScreenPtr) \
    dixLookupPrivate(&(pScreen)->devPrivates, XvScreenKey))->field)

#define SCREEN_EPILOGUE(pScreen, field, wrapper)\
    ((pScreen)->field = wrapper)

/* Errors */

#define _XvBadPort (XvBadPort+XvErrorBase)
#define _XvBadEncoding (XvBadEncoding+XvErrorBase)

#ifndef XorgLoader
extern _X_EXPORT int ProcXvDispatch(ClientPtr);
extern _X_EXPORT int SProcXvDispatch(ClientPtr);

extern _X_EXPORT void XvExtensionInit(void);
extern _X_EXPORT int XvScreenInit(ScreenPtr);
extern _X_EXPORT DevPrivateKey XvGetScreenKey(void);
extern _X_EXPORT unsigned long XvGetRTPort(void);
extern _X_EXPORT int XvdiSendPortNotify(XvPortPtr, Atom, INT32);
extern _X_EXPORT int XvdiVideoStopped(XvPortPtr, int);

extern _X_EXPORT int XvdiPutVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
extern _X_EXPORT int XvdiPutStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
extern _X_EXPORT int XvdiGetVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
extern _X_EXPORT int XvdiGetStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
extern _X_EXPORT int XvdiPutImage(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16,
				XvImagePtr, unsigned char*, Bool,
				CARD16, CARD16);
extern _X_EXPORT int XvdiSelectVideoNotify(ClientPtr, DrawablePtr, BOOL);
extern _X_EXPORT int XvdiSelectPortNotify(ClientPtr, XvPortPtr, BOOL);
extern _X_EXPORT int XvdiSetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32);
extern _X_EXPORT int XvdiGetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32*);
extern _X_EXPORT int XvdiStopVideo(ClientPtr, XvPortPtr, DrawablePtr);
extern _X_EXPORT int XvdiPreemptVideo(ClientPtr, XvPortPtr, DrawablePtr);
extern _X_EXPORT int XvdiMatchPort(XvPortPtr, DrawablePtr);
extern _X_EXPORT int XvdiGrabPort(ClientPtr, XvPortPtr, Time, int *);
extern _X_EXPORT int XvdiUngrabPort( ClientPtr, XvPortPtr, Time);
#endif /* XorgLoader */

#endif /* XVDIX_H */

/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
** File: 
**
**   xvmain.c --- Xv server extension main device independent module.
**   
** Author: 
**
**   David Carver (Digital Workstation Engineering/Project Athena)
**
** Revisions:
**
**   04.09.91 Carver
**     - change: stop video always generates an event even when video
**       wasn't active
**
**   29.08.91 Carver
**     - change: unrealizing windows no longer preempts video
**
**   11.06.91 Carver
**     - changed SetPortControl to SetPortAttribute
**     - changed GetPortControl to GetPortAttribute
**     - changed QueryBestSize
**
**   28.05.91 Carver
**     - fixed Put and Get requests to not preempt operations to same drawable
**
**   15.05.91 Carver
**     - version 2.0 upgrade
**
**   19.03.91 Carver
**     - fixed Put and Get requests to honor grabbed ports.
**     - fixed Video requests to update di structure with new drawable, and
**       client after calling ddx.
**
**   24.01.91 Carver
**     - version 1.4 upgrade
**       
** Notes:
**
**   Port structures reference client structures in a two different
**   ways: when grabs, or video is active.  Each reference is encoded
**   as fake client resources and thus when the client is goes away so
**   does the reference (it is zeroed).  No other action is taken, so
**   video doesn't necessarily stop.  It probably will as a result of
**   other resources going away, but if a client starts video using
**   none of its own resources, then the video will continue to play
**   after the client disappears.
**
**
*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gc.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include "input.h"

#define GLOBAL

#include <X11/extensions/Xv.h>
#include <X11/extensions/Xvproto.h>
#include "xvdix.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
#include "xvdisp.h"

static DevPrivateKeyRec XvScreenKeyRec;
#define XvScreenKey (&XvScreenKeyRec)
unsigned long XvExtensionGeneration = 0;
unsigned long XvScreenGeneration = 0;
unsigned long XvResourceGeneration = 0;

int XvReqCode;
int XvEventBase;
int XvErrorBase;

RESTYPE XvRTPort;
RESTYPE XvRTEncoding;
RESTYPE XvRTGrab;
RESTYPE XvRTVideoNotify;
RESTYPE XvRTVideoNotifyList;
RESTYPE XvRTPortNotify;

/* EXTERNAL */

static void WriteSwappedVideoNotifyEvent(xvEvent *, xvEvent *);
static void WriteSwappedPortNotifyEvent(xvEvent *, xvEvent *);
static Bool CreateResourceTypes(void);

static Bool XvCloseScreen(int, ScreenPtr);
static Bool XvDestroyPixmap(PixmapPtr);
static Bool XvDestroyWindow(WindowPtr);
static void XvResetProc(ExtensionEntry*);
static int XvdiDestroyGrab(pointer, XID);
static int XvdiDestroyEncoding(pointer, XID);
static int XvdiDestroyVideoNotify(pointer, XID);
static int XvdiDestroyPortNotify(pointer, XID);
static int XvdiDestroyVideoNotifyList(pointer, XID);
static int XvdiDestroyPort(pointer, XID);
static int XvdiSendVideoNotify(XvPortPtr, DrawablePtr, int);




/*
** XvExtensionInit
**
**
*/

void
XvExtensionInit(void)
{
  ExtensionEntry *extEntry;

  if (!dixRegisterPrivateKey(&XvScreenKeyRec, PRIVATE_SCREEN, 0))
      return;

  /* LOOK TO SEE IF ANY SCREENS WERE INITIALIZED; IF NOT THEN
     INIT GLOBAL VARIABLES SO THE EXTENSION CAN FUNCTION */
  if (XvScreenGeneration != serverGeneration)
    {
      if (!CreateResourceTypes())
	{
	  ErrorF("XvExtensionInit: Unable to allocate resource types\n");
	  return;
	}
#ifdef PANORAMIX
        XineramaRegisterConnectionBlockCallback(XineramifyXv);
#endif
      XvScreenGeneration = serverGeneration;
    }

  if (XvExtensionGeneration != serverGeneration)
    {
      XvExtensionGeneration = serverGeneration;

      extEntry = AddExtension(XvName, XvNumEvents, XvNumErrors, 
			      ProcXvDispatch, SProcXvDispatch,
			      XvResetProc, StandardMinorOpcode);
      if (!extEntry) 
	{
	  FatalError("XvExtensionInit: AddExtensions failed\n");
	}

      XvReqCode = extEntry->base;
      XvEventBase = extEntry->eventBase;
      XvErrorBase = extEntry->errorBase;

      EventSwapVector[XvEventBase+XvVideoNotify] = 
	(EventSwapPtr)WriteSwappedVideoNotifyEvent;
      EventSwapVector[XvEventBase+XvPortNotify] = 
	(EventSwapPtr)WriteSwappedPortNotifyEvent;

      SetResourceTypeErrorValue(XvRTPort, _XvBadPort);
      (void)MakeAtom(XvName, strlen(XvName), xTrue);

    }
}

static Bool
CreateResourceTypes(void)

{
  
  if (XvResourceGeneration == serverGeneration) return TRUE;

  XvResourceGeneration = serverGeneration;

  if (!(XvRTPort = CreateNewResourceType(XvdiDestroyPort, "XvRTPort")))
    {
      ErrorF("CreateResourceTypes: failed to allocate port resource.\n");
      return FALSE;
    }

  if (!(XvRTGrab = CreateNewResourceType(XvdiDestroyGrab, "XvRTGrab")))
    {
      ErrorF("CreateResourceTypes: failed to allocate grab resource.\n");
      return FALSE;
    }

  if (!(XvRTEncoding = CreateNewResourceType(XvdiDestroyEncoding,
					     "XvRTEncoding")))
    {
      ErrorF("CreateResourceTypes: failed to allocate encoding resource.\n");
      return FALSE;
    }

  if (!(XvRTVideoNotify = CreateNewResourceType(XvdiDestroyVideoNotify,
						"XvRTVideoNotify")))
    {
      ErrorF("CreateResourceTypes: failed to allocate video notify resource.\n");
      return FALSE;
    }

  if (!(XvRTVideoNotifyList = CreateNewResourceType(XvdiDestroyVideoNotifyList,
						    "XvRTVideoNotifyList")))
    {
      ErrorF("CreateResourceTypes: failed to allocate video notify list resource.\n");
      return FALSE;
    }

  if (!(XvRTPortNotify = CreateNewResourceType(XvdiDestroyPortNotify,
					       "XvRTPortNotify")))
    {
      ErrorF("CreateResourceTypes: failed to allocate port notify resource.\n");
      return FALSE;
    }

  return TRUE;

}

int
XvScreenInit(ScreenPtr pScreen)
{
  XvScreenPtr pxvs;

  if (XvScreenGeneration != serverGeneration)
    {
      if (!CreateResourceTypes())
	{
	  ErrorF("XvScreenInit: Unable to allocate resource types\n");
	  return BadAlloc;
	}
#ifdef PANORAMIX
        XineramaRegisterConnectionBlockCallback(XineramifyXv);
#endif
      XvScreenGeneration = serverGeneration; 
    }

  if (!dixRegisterPrivateKey(&XvScreenKeyRec, PRIVATE_SCREEN, 0))
      return BadAlloc;

  if (dixLookupPrivate(&pScreen->devPrivates, XvScreenKey))
    {
      ErrorF("XvScreenInit: screen devPrivates ptr non-NULL before init\n");
    }

  /* ALLOCATE SCREEN PRIVATE RECORD */
  
  pxvs = malloc(sizeof (XvScreenRec));
  if (!pxvs)
    {
      ErrorF("XvScreenInit: Unable to allocate screen private structure\n");
      return BadAlloc;
    }

  dixSetPrivate(&pScreen->devPrivates, XvScreenKey, pxvs);
  
  pxvs->DestroyPixmap = pScreen->DestroyPixmap;
  pxvs->DestroyWindow = pScreen->DestroyWindow;
  pxvs->CloseScreen = pScreen->CloseScreen;
  
  pScreen->DestroyPixmap = XvDestroyPixmap;
  pScreen->DestroyWindow = XvDestroyWindow;
  pScreen->CloseScreen = XvCloseScreen;

  return Success;
}

static Bool
XvCloseScreen(
  int ii,
  ScreenPtr pScreen
){

  XvScreenPtr pxvs;

  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

  pScreen->DestroyPixmap = pxvs->DestroyPixmap;
  pScreen->DestroyWindow = pxvs->DestroyWindow;
  pScreen->CloseScreen = pxvs->CloseScreen;

  (* pxvs->ddCloseScreen)(ii, pScreen); 

  free(pxvs);

  dixSetPrivate(&pScreen->devPrivates, XvScreenKey, NULL);

  return (*pScreen->CloseScreen)(ii, pScreen);
}

static void
XvResetProc(ExtensionEntry* extEntry)
{
    XvResetProcVector();
}

DevPrivateKey
XvGetScreenKey(void)
{
    return XvScreenKey;
}

unsigned long
XvGetRTPort(void)
{
  return XvRTPort;
}

static Bool
XvDestroyPixmap(PixmapPtr pPix)
{
  Bool status;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;
  XvAdaptorPtr pa;
  int na;
  XvPortPtr pp;
  int np;

  pScreen = pPix->drawable.pScreen;

  SCREEN_PROLOGUE(pScreen, DestroyPixmap);

  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

  /* CHECK TO SEE IF THIS PORT IS IN USE */

  pa = pxvs->pAdaptors;
  na = pxvs->nAdaptors;
  while (na--)
    {
      np = pa->nPorts;
      pp = pa->pPorts;

      while (np--)
	{
	  if (pp->pDraw == (DrawablePtr)pPix)
	    {
	      XvdiSendVideoNotify(pp, pp->pDraw, XvPreempted);

	      (void)(* pp->pAdaptor->ddStopVideo)(NULL, pp, pp->pDraw);

	      pp->pDraw = NULL;
	      pp->client = NULL;
	      pp->time = currentTime;
	    }
	  pp++;
	}
      pa++;
    }
  
  status = (* pScreen->DestroyPixmap)(pPix);

  SCREEN_EPILOGUE(pScreen, DestroyPixmap, XvDestroyPixmap);

  return status;

}

static Bool
XvDestroyWindow(WindowPtr pWin)
{
  Bool status;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;
  XvAdaptorPtr pa;
  int na;
  XvPortPtr pp;
  int np;

  pScreen = pWin->drawable.pScreen;

  SCREEN_PROLOGUE(pScreen, DestroyWindow);

  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

  /* CHECK TO SEE IF THIS PORT IS IN USE */

  pa = pxvs->pAdaptors;
  na = pxvs->nAdaptors;
  while (na--)
    {
      np = pa->nPorts;
      pp = pa->pPorts;

      while (np--)
	{
	  if (pp->pDraw == (DrawablePtr)pWin)
	    {
	      XvdiSendVideoNotify(pp, pp->pDraw, XvPreempted);

	      (void)(* pp->pAdaptor->ddStopVideo)(NULL, pp, pp->pDraw);

	      pp->pDraw = NULL;
	      pp->client = NULL;
	      pp->time = currentTime;
	    }
	  pp++;
	}
      pa++;
    }

  
  status = (* pScreen->DestroyWindow)(pWin);

  SCREEN_EPILOGUE(pScreen, DestroyWindow, XvDestroyWindow);

  return status;

}

/* The XvdiVideoStopped procedure is a hook for the device dependent layer.
   It provides a way for the dd layer to inform the di layer that video has
   stopped in a port for reasons that the di layer had no control over; note
   that it doesn't call back into the dd layer */

int
XvdiVideoStopped(XvPortPtr pPort, int reason)
{
  
  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

  if (!pPort->pDraw) return Success;

  XvdiSendVideoNotify(pPort, pPort->pDraw, reason);

  pPort->pDraw = NULL;
  pPort->client = NULL;
  pPort->time = currentTime;

  return Success;

}

static int 
XvdiDestroyPort(pointer pPort, XID id)
{
  return (* ((XvPortPtr)pPort)->pAdaptor->ddFreePort)(pPort);
}

static int
XvdiDestroyGrab(pointer pGrab, XID id)
{
  ((XvGrabPtr)pGrab)->client = NULL;
  return Success;
}

static int
XvdiDestroyVideoNotify(pointer pn, XID id)
{
  /* JUST CLEAR OUT THE client POINTER FIELD */

  ((XvVideoNotifyPtr)pn)->client = NULL;
  return Success;
}

static int
XvdiDestroyPortNotify(pointer pn, XID id)
{
  /* JUST CLEAR OUT THE client POINTER FIELD */

  ((XvPortNotifyPtr)pn)->client = NULL;
  return Success;
}

static int
XvdiDestroyVideoNotifyList(pointer pn, XID id)
{
  XvVideoNotifyPtr npn,cpn;

  /* ACTUALLY DESTROY THE NOTITY LIST */

  cpn = (XvVideoNotifyPtr)pn;

  while (cpn)
    {
      npn = cpn->next;
      if (cpn->client) FreeResource(cpn->id, XvRTVideoNotify);
      free(cpn);
      cpn = npn;
    }
  return Success;
}

static int
XvdiDestroyEncoding(pointer value, XID id)
{
  return Success;
}

static int
XvdiSendVideoNotify(XvPortPtr pPort, DrawablePtr pDraw, int reason)
{
  xvEvent event;
  XvVideoNotifyPtr pn;

  dixLookupResourceByType((pointer *)&pn, pDraw->id, XvRTVideoNotifyList,
			  serverClient, DixReadAccess);

  while (pn) 
    {
      event.u.u.type = XvEventBase + XvVideoNotify;
      event.u.videoNotify.time = currentTime.milliseconds;
      event.u.videoNotify.drawable = pDraw->id;
      event.u.videoNotify.port = pPort->id;
      event.u.videoNotify.reason = reason;
      WriteEventsToClient(pn->client, 1, (xEventPtr)&event);
      pn = pn->next;
    }

  return Success;

}


int
XvdiSendPortNotify(
  XvPortPtr pPort,
  Atom attribute,
  INT32 value
){
  xvEvent event;
  XvPortNotifyPtr pn;

  pn = pPort->pNotify;

  while (pn) 
    {
      event.u.u.type = XvEventBase + XvPortNotify;
      event.u.portNotify.time = currentTime.milliseconds;
      event.u.portNotify.port = pPort->id;
      event.u.portNotify.attribute = attribute;
      event.u.portNotify.value = value;
      WriteEventsToClient(pn->client, 1, (xEventPtr)&event);
      pn = pn->next;
    }

  return Success;

}


#define CHECK_SIZE(dw, dh, sw, sh) {                                  \
  if(!dw || !dh || !sw || !sh)  return Success;                       \
  /* The region code will break these if they are too large */        \
  if((dw > 32767) || (dh > 32767) || (sw > 32767) || (sh > 32767))    \
        return BadValue;                                              \
}


int
XvdiPutVideo(   
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  DrawablePtr pOldDraw;

  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  /* CHECK TO SEE IF PORT IS IN USE; IF SO THEN WE MUST DELIVER INTERRUPTED
     EVENTS TO ANY CLIENTS WHO WANT THEM */

  pOldDraw = pPort->pDraw;
  if ((pOldDraw) && (pOldDraw != pDraw))
    {
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
    }

  (void) (* pPort->pAdaptor->ddPutVideo)(client, pDraw, pPort, pGC,
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);

  if ((pPort->pDraw) && (pOldDraw != pDraw))
    {
      pPort->client = client;
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvStarted);
    }

  pPort->time = currentTime;

  return Success;

}

int
XvdiPutStill(   
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  int status;

  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  pPort->time = currentTime;

  status = (* pPort->pAdaptor->ddPutStill)(client, pDraw, pPort, pGC, 
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);

  return status;

}

int
XvdiPutImage(   
   ClientPtr client, 
   DrawablePtr pDraw, 
   XvPortPtr pPort, 
   GCPtr pGC,
   INT16 src_x, INT16 src_y, 
   CARD16 src_w, CARD16 src_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h,
   XvImagePtr image,
   unsigned char* data,
   Bool sync,
   CARD16 width, CARD16 height
){
  CHECK_SIZE(drw_w, drw_h, src_w, src_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  pPort->time = currentTime;

  return (* pPort->pAdaptor->ddPutImage)(client, pDraw, pPort, pGC, 
					   src_x, src_y, src_w, src_h, 
					   drw_x, drw_y, drw_w, drw_h,
					   image, data, sync, width, height);
}


int
XvdiGetVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  DrawablePtr pOldDraw;

  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  /* CHECK TO SEE IF PORT IS IN USE; IF SO THEN WE MUST DELIVER INTERRUPTED
     EVENTS TO ANY CLIENTS WHO WANT THEM */

  pOldDraw = pPort->pDraw;
  if ((pOldDraw) && (pOldDraw != pDraw))
    {
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
    }

  (void) (* pPort->pAdaptor->ddGetVideo)(client, pDraw, pPort, pGC,
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);

  if ((pPort->pDraw) && (pOldDraw != pDraw))
    {
      pPort->client = client;
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvStarted);
    }

  pPort->time = currentTime;

  return Success;

}

int
XvdiGetStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  int status;

  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  status = (* pPort->pAdaptor->ddGetStill)(client, pDraw, pPort, pGC, 
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);

  pPort->time = currentTime;

  return status;

}

int
XvdiGrabPort(
   ClientPtr client,
   XvPortPtr pPort,
   Time ctime,
   int *p_result
){
  unsigned long id;
  TimeStamp time;

  UpdateCurrentTime();
  time = ClientTimeToServerTime(ctime);

  if (pPort->grab.client && (client != pPort->grab.client))
    {
      *p_result = XvAlreadyGrabbed;
      return Success;
    }

  if ((CompareTimeStamps(time, currentTime) == LATER) ||
      (CompareTimeStamps(time, pPort->time) == EARLIER))
    {
      *p_result = XvInvalidTime;
      return Success;
    }

  if (client == pPort->grab.client)
    {
      *p_result = Success;
      return Success;
    }

  id = FakeClientID(client->index);

  if (!AddResource(id, XvRTGrab, &pPort->grab))
    {
      return BadAlloc;
    }

  /* IF THERE IS ACTIVE VIDEO THEN STOP IT */

  if ((pPort->pDraw) && (client != pPort->client))
    {
      XvdiStopVideo(NULL, pPort, pPort->pDraw);
    }

  pPort->grab.client = client;
  pPort->grab.id = id;

  pPort->time = currentTime;

  *p_result = Success;

  return Success;

}

int
XvdiUngrabPort(
  ClientPtr client,
  XvPortPtr pPort,
  Time ctime
){
  TimeStamp time;

  UpdateCurrentTime();
  time = ClientTimeToServerTime(ctime);

  if ((!pPort->grab.client) || (client != pPort->grab.client))
    {
      return Success;
    }

  if ((CompareTimeStamps(time, currentTime) == LATER) ||
      (CompareTimeStamps(time, pPort->time) == EARLIER))
    {
      return Success;
    }

  /* FREE THE GRAB RESOURCE; AND SET THE GRAB CLIENT TO NULL */

  FreeResource(pPort->grab.id, XvRTGrab);
  pPort->grab.client = NULL;

  pPort->time = currentTime;

  return Success;

}


int
XvdiSelectVideoNotify(
  ClientPtr client,
  DrawablePtr pDraw,
  BOOL onoff
){
  XvVideoNotifyPtr pn,tpn,fpn;
  int rc;

  /* FIND VideoNotify LIST */

  rc = dixLookupResourceByType((pointer *)&pn, pDraw->id, XvRTVideoNotifyList,
			       client, DixWriteAccess);
  if (rc != Success && rc != BadValue)
      return rc;

  /* IF ONE DONES'T EXIST AND NO MASK, THEN JUST RETURN */

  if (!onoff && !pn) return Success;

  /* IF ONE DOESN'T EXIST CREATE IT AND ADD A RESOURCE SO THAT THE LIST
     WILL BE DELETED WHEN THE DRAWABLE IS DESTROYED */

  if (!pn) 
    {
      if (!(tpn = malloc(sizeof(XvVideoNotifyRec))))
	return BadAlloc;
      tpn->next = NULL;
      if (!AddResource(pDraw->id, XvRTVideoNotifyList, tpn))
	{
	  free(tpn);
	  return BadAlloc;
	}
    }
  else
    {
      /* LOOK TO SEE IF ENTRY ALREADY EXISTS */

      fpn = NULL;
      tpn = pn;
      while (tpn)
	{
	  if (tpn->client == client) 
	    {
	      if (!onoff) tpn->client = NULL;
	      return Success;
	    }
	  if (!tpn->client) fpn = tpn; /* TAKE NOTE OF FREE ENTRY */
	  tpn = tpn->next;
	}

      /* IF TUNNING OFF, THEN JUST RETURN */

      if (!onoff) return Success;

      /* IF ONE ISN'T FOUND THEN ALLOCATE ONE AND LINK IT INTO THE LIST */

      if (fpn)
	{
	  tpn = fpn;
	}
      else
	{
	  if (!(tpn = malloc(sizeof(XvVideoNotifyRec))))
	    return BadAlloc;
	  tpn->next = pn->next;
	  pn->next = tpn;
	}
    }

  /* INIT CLIENT PTR IN CASE WE CAN'T ADD RESOURCE */
  /* ADD RESOURCE SO THAT IF CLIENT EXITS THE CLIENT PTR WILL BE CLEARED */

  tpn->client = NULL;
  tpn->id = FakeClientID(client->index);
  AddResource(tpn->id, XvRTVideoNotify, tpn);

  tpn->client = client;
  return Success;

}

int
XvdiSelectPortNotify(
   ClientPtr client,
   XvPortPtr pPort,
   BOOL onoff
){
  XvPortNotifyPtr pn,tpn;

  /* SEE IF CLIENT IS ALREADY IN LIST */

  tpn = NULL;
  pn = pPort->pNotify;
  while (pn)
    {
      if (!pn->client) tpn = pn; /* TAKE NOTE OF FREE ENTRY */
      if (pn->client == client) break;
      pn = pn->next;
    }

  /* IS THE CLIENT ALREADY ON THE LIST? */

  if (pn)
    {
      /* REMOVE IT? */

      if (!onoff)
	{
	  pn->client = NULL;
	  FreeResource(pn->id, XvRTPortNotify);
	}

      return Success;
    }

  /* DIDN'T FIND IT; SO REUSE LIST ELEMENT IF ONE IS FREE OTHERWISE 
     CREATE A NEW ONE AND ADD IT TO THE BEGINNING OF THE LIST */

  if (!tpn)
    {
      if (!(tpn = malloc(sizeof(XvPortNotifyRec))))
	return BadAlloc;
      tpn->next = pPort->pNotify;
      pPort->pNotify = tpn;
    }

  tpn->client = client;
  tpn->id = FakeClientID(client->index);
  AddResource(tpn->id, XvRTPortNotify, tpn);

  return Success;

}

int
XvdiStopVideo(
  ClientPtr client,
  XvPortPtr pPort,
  DrawablePtr pDraw
){
  int status;

  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

  if (!pPort->pDraw || (pPort->pDraw != pDraw)) 
    {
      XvdiSendVideoNotify(pPort, pDraw, XvStopped);
      return Success;
    }

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if ((client) && (pPort->grab.client) && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  XvdiSendVideoNotify(pPort, pDraw, XvStopped);

  status = (* pPort->pAdaptor->ddStopVideo)(client, pPort, pDraw);

  pPort->pDraw = NULL;
  pPort->client = (ClientPtr)client;
  pPort->time = currentTime;

  return status;

}

int
XvdiPreemptVideo(
  ClientPtr client,
  XvPortPtr pPort,
  DrawablePtr pDraw
){
  int status;

  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

  if (!pPort->pDraw || (pPort->pDraw != pDraw)) return Success;

  XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);

  status = (* pPort->pAdaptor->ddStopVideo)(client, pPort, pPort->pDraw);

  pPort->pDraw = NULL;
  pPort->client = (ClientPtr)client;
  pPort->time = currentTime;

  return status;

}

int
XvdiMatchPort(
  XvPortPtr pPort,
  DrawablePtr pDraw
){

  XvAdaptorPtr pa;
  XvFormatPtr pf;
  int nf;

  pa = pPort->pAdaptor;

  if (pa->pScreen != pDraw->pScreen) return BadMatch;

  nf = pa->nFormats;
  pf = pa->pFormats;

  while (nf--)
    {
      if (pf->depth == pDraw->depth)
	return Success;
      pf++;
    }

  return BadMatch;

}

int
XvdiSetPortAttribute(
  ClientPtr client,
  XvPortPtr pPort,
  Atom attribute,
  INT32 value
){
  int status;

  status = (* pPort->pAdaptor->ddSetPortAttribute)(client, pPort, attribute, value);
  if (status == Success)
    XvdiSendPortNotify(pPort, attribute, value);

  return status;
}

int
XvdiGetPortAttribute(
  ClientPtr client,
  XvPortPtr pPort,
  Atom attribute,
  INT32 *p_value
){

  return 
    (* pPort->pAdaptor->ddGetPortAttribute)(client, pPort, attribute, p_value);

}

static void
WriteSwappedVideoNotifyEvent(xvEvent *from, xvEvent *to)

{

  to->u.u.type = from->u.u.type;
  to->u.u.detail = from->u.u.detail;
  cpswaps(from->u.videoNotify.sequenceNumber, 
	  to->u.videoNotify.sequenceNumber);
  cpswapl(from->u.videoNotify.time, to->u.videoNotify.time);
  cpswapl(from->u.videoNotify.drawable, to->u.videoNotify.drawable);
  cpswapl(from->u.videoNotify.port, to->u.videoNotify.port);

}

static void
WriteSwappedPortNotifyEvent(xvEvent *from, xvEvent *to)

{

  to->u.u.type = from->u.u.type;
  to->u.u.detail = from->u.u.detail;
  cpswaps(from->u.portNotify.sequenceNumber, to->u.portNotify.sequenceNumber);
  cpswapl(from->u.portNotify.time, to->u.portNotify.time);
  cpswapl(from->u.portNotify.port, to->u.portNotify.port);
  cpswapl(from->u.portNotify.value, to->u.portNotify.value);

}

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "extnsionst.h"
#include "servermd.h"
#include <X11/Xfuncproto.h>
#include "xvdix.h"
#include <X11/extensions/XvMC.h>
#include <X11/extensions/Xvproto.h>
#include <X11/extensions/XvMCproto.h>
#include "xvmcext.h"
#include "protocol-versions.h"

#ifdef HAS_XVMCSHM
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/shm.h>
#endif /* HAS_XVMCSHM */
   


#define DR_CLIENT_DRIVER_NAME_SIZE 48
#define DR_BUSID_SIZE 48

static DevPrivateKeyRec XvMCScreenKeyRec;
#define XvMCScreenKey (&XvMCScreenKeyRec)
static Bool XvMCInUse;

unsigned long XvMCGeneration = 0;

int XvMCReqCode;
int XvMCEventBase;

static RESTYPE XvMCRTContext;
static RESTYPE XvMCRTSurface;
static RESTYPE XvMCRTSubpicture;

typedef struct {
   int num_adaptors;
   XvMCAdaptorPtr adaptors;
   CloseScreenProcPtr	CloseScreen;
   char clientDriverName[DR_CLIENT_DRIVER_NAME_SIZE];
   char busID[DR_BUSID_SIZE];
   int major;
   int minor;
   int patchLevel;
} XvMCScreenRec, *XvMCScreenPtr; 

#define XVMC_GET_PRIVATE(pScreen) \
    (XvMCScreenPtr)(dixLookupPrivate(&(pScreen)->devPrivates, XvMCScreenKey))


static int
XvMCDestroyContextRes(pointer data, XID id)
{
   XvMCContextPtr pContext = (XvMCContextPtr)data;
   
   pContext->refcnt--;

   if(!pContext->refcnt) {
  	 XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);
	(*pScreenPriv->adaptors[pContext->adapt_num].DestroyContext)(pContext);
	free(pContext);
   }	   

   return Success;
}

static int
XvMCDestroySurfaceRes(pointer data, XID id)
{
   XvMCSurfacePtr pSurface = (XvMCSurfacePtr)data;
   XvMCContextPtr pContext = pSurface->context;
   XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

   (*pScreenPriv->adaptors[pContext->adapt_num].DestroySurface)(pSurface); 
   free(pSurface);

   XvMCDestroyContextRes((pointer)pContext, pContext->context_id);

   return Success;
}


static int
XvMCDestroySubpictureRes(pointer data, XID id)
{
   XvMCSubpicturePtr pSubpict = (XvMCSubpicturePtr)data;
   XvMCContextPtr pContext = pSubpict->context;
   XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

   (*pScreenPriv->adaptors[pContext->adapt_num].DestroySubpicture)(pSubpict); 
   free(pSubpict);

   XvMCDestroyContextRes((pointer)pContext, pContext->context_id);

   return Success;
}

static int 
ProcXvMCQueryVersion(ClientPtr client)
{
    xvmcQueryVersionReply rep;
    /* REQUEST(xvmcQueryVersionReq); */
    REQUEST_SIZE_MATCH(xvmcQueryVersionReq);
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.major = SERVER_XVMC_MAJOR_VERSION;
    rep.minor = SERVER_XVMC_MINOR_VERSION;
    WriteToClient(client, sizeof(xvmcQueryVersionReply), (char*)&rep);
    return Success;
}


static int 
ProcXvMCListSurfaceTypes(ClientPtr client)
{
    XvPortPtr pPort;
    int i;
    XvMCScreenPtr pScreenPriv;
    xvmcListSurfaceTypesReply rep;
    xvmcSurfaceInfo info;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface;
    REQUEST(xvmcListSurfaceTypesReq);
    REQUEST_SIZE_MATCH(xvmcListSurfaceTypesReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if(XvMCInUse) { /* any adaptors at all */
       ScreenPtr pScreen = pPort->pAdaptor->pScreen;
       if((pScreenPriv = XVMC_GET_PRIVATE(pScreen))) {  /* any this screen */
          for(i = 0; i < pScreenPriv->num_adaptors; i++) {
             if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
               adaptor = &(pScreenPriv->adaptors[i]);
               break;
             }
          }
       }
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num = (adaptor) ? adaptor->num_surfaces : 0;
    rep.length = bytes_to_int32(rep.num * sizeof(xvmcSurfaceInfo));
 
    WriteToClient(client, sizeof(xvmcListSurfaceTypesReply), (char*)&rep);

    for(i = 0; i < rep.num; i++) {
	surface = adaptor->surfaces[i];
	info.surface_type_id = surface->surface_type_id;
	info.chroma_format = surface->chroma_format;
	info.max_width = surface->max_width;
	info.max_height = surface->max_height;
	info.subpicture_max_width = surface->subpicture_max_width;
	info.subpicture_max_height = surface->subpicture_max_height;
	info.mc_type = surface->mc_type;
	info.flags = surface->flags;
	WriteToClient(client, sizeof(xvmcSurfaceInfo), (char*)&info);
    }

    return Success;
}

static int 
ProcXvMCCreateContext(ClientPtr client)
{
    XvPortPtr pPort;
    CARD32 *data = NULL;
    int dwords = 0; 
    int i, result, adapt_num = -1;
    ScreenPtr pScreen;
    XvMCContextPtr pContext;
    XvMCScreenPtr pScreenPriv;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface = NULL;
    xvmcCreateContextReply rep;
    REQUEST(xvmcCreateContextReq);
    REQUEST_SIZE_MATCH(xvmcCreateContextReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;

    if(!XvMCInUse) /* no XvMC adaptors */
       return BadMatch;
 
    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen))) /* none this screen */
       return BadMatch;

    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
	if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
	    adaptor = &(pScreenPriv->adaptors[i]);
	    adapt_num = i; 
	    break;
	}
    }

    if(adapt_num < 0) /* none this port */
	return BadMatch;	

    for(i = 0; i < adaptor->num_surfaces; i++) {
        if(adaptor->surfaces[i]->surface_type_id == stuff->surface_type_id) {
            surface = adaptor->surfaces[i];
            break;
        }
    }

    /* adaptor doesn't support this suface_type_id */
    if(!surface) return BadMatch;


    if((stuff->width > surface->max_width) ||
       (stuff->height > surface->max_height))
        return BadValue;

    if(!(pContext = malloc(sizeof(XvMCContextRec)))) {
	return BadAlloc;
    }


    pContext->pScreen = pScreen;
    pContext->adapt_num = adapt_num;
    pContext->context_id = stuff->context_id;
    pContext->surface_type_id = stuff->surface_type_id;
    pContext->width = stuff->width;
    pContext->height = stuff->height;
    pContext->flags = stuff->flags;
    pContext->refcnt = 1;

    result = (*adaptor->CreateContext)(pPort, pContext, &dwords, &data);

    if(result != Success) {
	free(pContext);
	return result;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.width_actual = pContext->width; 
    rep.height_actual = pContext->height; 
    rep.flags_return = pContext->flags; 
    rep.length = dwords;

    WriteToClient(client, sizeof(xvmcCreateContextReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data); 
    AddResource(pContext->context_id, XvMCRTContext, pContext);

    free(data);

    return Success;
}

static int 
ProcXvMCDestroyContext(ClientPtr client)
{
    pointer val;
    int rc;
    REQUEST(xvmcDestroyContextReq);
    REQUEST_SIZE_MATCH(xvmcDestroyContextReq);

    rc = dixLookupResourceByType(&val, stuff->context_id, XvMCRTContext,
				 client, DixDestroyAccess);
    if (rc != Success)
	return rc;

    FreeResource(stuff->context_id, RT_NONE); 

    return Success;
}

static int 
ProcXvMCCreateSurface(ClientPtr client)
{
    CARD32 *data = NULL;
    int dwords = 0;
    int result;
    XvMCContextPtr pContext;
    XvMCSurfacePtr pSurface;
    XvMCScreenPtr pScreenPriv;
    xvmcCreateSurfaceReply rep;
    REQUEST(xvmcCreateSurfaceReq);
    REQUEST_SIZE_MATCH(xvmcCreateSurfaceReq);

    result = dixLookupResourceByType((pointer *)&pContext, stuff->context_id,
				     XvMCRTContext, client, DixUseAccess);
    if (result != Success)
        return result;

    pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

    if(!(pSurface = malloc(sizeof(XvMCSurfaceRec)))) 
        return BadAlloc;

    pSurface->surface_id = stuff->surface_id;
    pSurface->surface_type_id = pContext->surface_type_id;
    pSurface->context = pContext;

    result = (*pScreenPriv->adaptors[pContext->adapt_num].CreateSurface)(
                pSurface, &dwords, &data);

    if(result != Success) {
        free(pSurface);
        return result;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = dwords;

    WriteToClient(client, sizeof(xvmcCreateSurfaceReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data);
    AddResource(pSurface->surface_id, XvMCRTSurface, pSurface);

    free(data);

    pContext->refcnt++;

    return Success;
}

static int 
ProcXvMCDestroySurface(ClientPtr client)
{
    pointer val;
    int rc;
    REQUEST(xvmcDestroySurfaceReq);
    REQUEST_SIZE_MATCH(xvmcDestroySurfaceReq);

    rc = dixLookupResourceByType(&val, stuff->surface_id, XvMCRTSurface,
				 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->surface_id, RT_NONE);

    return Success;
}

static int 
ProcXvMCCreateSubpicture(ClientPtr client)
{
    Bool image_supported = FALSE;
    CARD32 *data = NULL;
    int i, result, dwords = 0;
    XvMCContextPtr pContext;
    XvMCSubpicturePtr pSubpicture;
    XvMCScreenPtr pScreenPriv;
    xvmcCreateSubpictureReply rep;
    XvMCAdaptorPtr adaptor;
    XvMCSurfaceInfoPtr surface = NULL;
    REQUEST(xvmcCreateSubpictureReq);
    REQUEST_SIZE_MATCH(xvmcCreateSubpictureReq);

    result = dixLookupResourceByType((pointer *)&pContext, stuff->context_id,
				     XvMCRTContext, client, DixUseAccess);
    if (result != Success)
        return result;

    pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

    adaptor = &(pScreenPriv->adaptors[pContext->adapt_num]); 

    /* find which surface this context supports */
    for(i = 0; i < adaptor->num_surfaces; i++) {
	if(adaptor->surfaces[i]->surface_type_id == pContext->surface_type_id){
	   surface = adaptor->surfaces[i];
	   break;
	}
    } 

    if(!surface) return BadMatch;

    /* make sure this surface supports that xvimage format */
    if(!surface->compatible_subpictures) return BadMatch;

    for(i = 0; i < surface->compatible_subpictures->num_xvimages; i++) {
      if(surface->compatible_subpictures->xvimage_ids[i] == stuff->xvimage_id) {
	   image_supported = TRUE;
	   break;
      }
    }

    if(!image_supported) return BadMatch;

    /* make sure the size is OK */
    if((stuff->width > surface->subpicture_max_width) ||
       (stuff->height > surface->subpicture_max_height))
	return BadValue;

    if(!(pSubpicture = malloc(sizeof(XvMCSubpictureRec))))
        return BadAlloc;

    pSubpicture->subpicture_id = stuff->subpicture_id;
    pSubpicture->xvimage_id = stuff->xvimage_id;
    pSubpicture->width = stuff->width;
    pSubpicture->height = stuff->height;
    pSubpicture->num_palette_entries = 0; /* overwritten by DDX */
    pSubpicture->entry_bytes = 0;         /* overwritten by DDX */
    pSubpicture->component_order[0] = 0;  /* overwritten by DDX */
    pSubpicture->component_order[1] = 0;
    pSubpicture->component_order[2] = 0;
    pSubpicture->component_order[3] = 0;
    pSubpicture->context = pContext;
   
    result = (*pScreenPriv->adaptors[pContext->adapt_num].CreateSubpicture)(
                pSubpicture, &dwords, &data);

    if(result != Success) {
        free(pSubpicture);
        return result;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.width_actual = pSubpicture->width;
    rep.height_actual = pSubpicture->height;
    rep.num_palette_entries = pSubpicture->num_palette_entries;
    rep.entry_bytes = pSubpicture->entry_bytes;
    rep.component_order[0] = pSubpicture->component_order[0];
    rep.component_order[1] = pSubpicture->component_order[1];
    rep.component_order[2] = pSubpicture->component_order[2];
    rep.component_order[3] = pSubpicture->component_order[3];
    rep.length = dwords;

    WriteToClient(client, sizeof(xvmcCreateSubpictureReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data);
    AddResource(pSubpicture->subpicture_id, XvMCRTSubpicture, pSubpicture);

    free(data);

    pContext->refcnt++;

    return Success;
}

static int 
ProcXvMCDestroySubpicture(ClientPtr client)
{
    pointer val;
    int rc;
    REQUEST(xvmcDestroySubpictureReq);
    REQUEST_SIZE_MATCH(xvmcDestroySubpictureReq);

    rc = dixLookupResourceByType(&val, stuff->subpicture_id, XvMCRTSubpicture,
				 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->subpicture_id, RT_NONE);

    return Success;
}


static int
ProcXvMCListSubpictureTypes(ClientPtr client)
{
    XvPortPtr pPort;
    xvmcListSubpictureTypesReply rep;
    XvMCScreenPtr pScreenPriv;
    ScreenPtr pScreen;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface = NULL;
    xvImageFormatInfo info;
    XvImagePtr pImage;
    int i, j;
    REQUEST(xvmcListSubpictureTypesReq);
    REQUEST_SIZE_MATCH(xvmcListSubpictureTypesReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;

    if (!dixPrivateKeyRegistered(XvMCScreenKey))
        return BadMatch;   /* No XvMC adaptors */

    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen)))
        return BadMatch;   /* None this screen */

    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
        if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
            adaptor = &(pScreenPriv->adaptors[i]);
            break;
        }
    }

    if(!adaptor) return BadMatch;

    for(i = 0; i < adaptor->num_surfaces; i++) {
        if(adaptor->surfaces[i]->surface_type_id == stuff->surface_type_id) {
            surface = adaptor->surfaces[i];
            break;
        }
    }

    if(!surface) return BadMatch;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num = 0;
    if(surface->compatible_subpictures) 
	rep.num = surface->compatible_subpictures->num_xvimages;

    rep.length = bytes_to_int32(rep.num * sizeof(xvImageFormatInfo));

    WriteToClient(client, sizeof(xvmcListSubpictureTypesReply), (char*)&rep);

    for(i = 0; i < rep.num; i++) {
	pImage = NULL;
	for(j = 0; j < adaptor->num_subpictures; j++) {
	    if(surface->compatible_subpictures->xvimage_ids[i] ==
	       adaptor->subpictures[j]->id)
	    {
		pImage = adaptor->subpictures[j];
	        break;
	    }
	}
	if(!pImage) return BadImplementation;

        info.id = pImage->id;      
	info.type = pImage->type;  
        info.byte_order = pImage->byte_order; 
        memcpy(&info.guid, pImage->guid, 16);      
        info.bpp = pImage->bits_per_pixel;         
        info.num_planes = pImage->num_planes;      
        info.depth = pImage->depth;        
        info.red_mask = pImage->red_mask;  
        info.green_mask = pImage->green_mask;      
        info.blue_mask = pImage->blue_mask;        
        info.format = pImage->format;      
        info.y_sample_bits = pImage->y_sample_bits;        
        info.u_sample_bits = pImage->u_sample_bits;        
        info.v_sample_bits = pImage->v_sample_bits;        
        info.horz_y_period = pImage->horz_y_period;        
        info.horz_u_period = pImage->horz_u_period;        
        info.horz_v_period = pImage->horz_v_period;        
        info.vert_y_period = pImage->vert_y_period;        
        info.vert_u_period = pImage->vert_u_period;        
        info.vert_v_period = pImage->vert_v_period;        
        memcpy(&info.comp_order, pImage->component_order, 32);     
        info.scanline_order = pImage->scanline_order;
	WriteToClient(client, sizeof(xvImageFormatInfo), (char*)&info);
    }

    return Success;
}

static int
ProcXvMCGetDRInfo(ClientPtr client)
{
    xvmcGetDRInfoReply rep;
    XvPortPtr pPort;
    ScreenPtr pScreen;
    XvMCScreenPtr pScreenPriv;

#ifdef HAS_XVMCSHM
    volatile CARD32 *patternP;
#endif

    REQUEST(xvmcGetDRInfoReq);
    REQUEST_SIZE_MATCH(xvmcGetDRInfoReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;
    pScreenPriv = XVMC_GET_PRIVATE(pScreen);
    
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.major = pScreenPriv->major;
    rep.minor = pScreenPriv->minor;
    rep.patchLevel = pScreenPriv->patchLevel;
    rep.nameLen = bytes_to_int32(strlen(pScreenPriv->clientDriverName) + 1);
    rep.busIDLen = bytes_to_int32(strlen(pScreenPriv->busID) + 1);

    rep.length = rep.nameLen + rep.busIDLen;
    rep.nameLen <<=2;
    rep.busIDLen <<=2;

    /*
     * Read back to the client what she has put in the shared memory
     * segment she prepared for us.
     */

    rep.isLocal = 1;
#ifdef HAS_XVMCSHM
    patternP = (CARD32 *)shmat( stuff->shmKey, NULL, SHM_RDONLY );
    if ( -1 != (long) patternP) {
        volatile CARD32 *patternC = patternP;
	int i;
	CARD32 magic = stuff->magic;
	
	rep.isLocal = 1;
	i = 1024 / sizeof(CARD32);
	
	while ( i-- ) {
	    if (*patternC++ != magic) {
		rep.isLocal = 0;
		break;
	    }
	    magic = ~magic;
	}
	shmdt( (char *)patternP ); 
    }
#endif /* HAS_XVMCSHM */
    
    WriteToClient(client, sizeof(xvmcGetDRInfoReply), 
		  (char*)&rep);
    if (rep.length) {      
	WriteToClient(client, rep.nameLen, 
		      pScreenPriv->clientDriverName);
	WriteToClient(client, rep.busIDLen, 
		      pScreenPriv->busID);
    }	
    return Success;
}


int (*ProcXvMCVector[xvmcNumRequest])(ClientPtr) = {
  ProcXvMCQueryVersion,
  ProcXvMCListSurfaceTypes,
  ProcXvMCCreateContext,
  ProcXvMCDestroyContext,
  ProcXvMCCreateSurface,
  ProcXvMCDestroySurface,
  ProcXvMCCreateSubpicture,
  ProcXvMCDestroySubpicture,
  ProcXvMCListSubpictureTypes,
  ProcXvMCGetDRInfo
};

static int
ProcXvMCDispatch (ClientPtr client)
{
    REQUEST(xReq);
    
    if(stuff->data < xvmcNumRequest)
	return (*ProcXvMCVector[stuff->data])(client);
    else
	return BadRequest;
}

static int
SProcXvMCDispatch (ClientPtr client)
{
    /* We only support local */
    return BadImplementation;
}

void
XvMCExtensionInit(void)
{
   ExtensionEntry *extEntry;

   if (!dixPrivateKeyRegistered(XvMCScreenKey))
	return;

   if(!(XvMCRTContext = CreateNewResourceType(XvMCDestroyContextRes,
					      "XvMCRTContext")))
	return;

   if(!(XvMCRTSurface = CreateNewResourceType(XvMCDestroySurfaceRes,
					      "XvMCRTSurface")))
	return;

   if(!(XvMCRTSubpicture = CreateNewResourceType(XvMCDestroySubpictureRes,
						 "XvMCRTSubpicture")))
	return;

   extEntry = AddExtension(XvMCName, XvMCNumEvents, XvMCNumErrors, 
                              ProcXvMCDispatch, SProcXvMCDispatch,
                              NULL, StandardMinorOpcode);

   if(!extEntry) return;
  
   XvMCReqCode = extEntry->base;
   XvMCEventBase = extEntry->eventBase;
   SetResourceTypeErrorValue(XvMCRTContext, extEntry->errorBase + XvMCBadContext);
   SetResourceTypeErrorValue(XvMCRTSurface, extEntry->errorBase + XvMCBadSurface);
   SetResourceTypeErrorValue(XvMCRTSubpicture, extEntry->errorBase + XvMCBadSubpicture);
}

static Bool
XvMCCloseScreen (int i, ScreenPtr pScreen)
{
    XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;

    free(pScreenPriv);

    return (*pScreen->CloseScreen)(i, pScreen);
}


int
XvMCScreenInit(ScreenPtr pScreen, int num, XvMCAdaptorPtr pAdapt)
{
   XvMCScreenPtr pScreenPriv;

   if (!dixRegisterPrivateKey(&XvMCScreenKeyRec, PRIVATE_SCREEN, 0))
       return BadAlloc;

   if(!(pScreenPriv = malloc(sizeof(XvMCScreenRec))))
	return BadAlloc;

   dixSetPrivate(&pScreen->devPrivates, XvMCScreenKey, pScreenPriv);

   pScreenPriv->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = XvMCCloseScreen;

   pScreenPriv->num_adaptors = num;
   pScreenPriv->adaptors = pAdapt;
   pScreenPriv->clientDriverName[0] = 0;
   pScreenPriv->busID[0] = 0;
   pScreenPriv->major = 0;
   pScreenPriv->minor = 0;
   pScreenPriv->patchLevel = 0;

   XvMCInUse = TRUE;

   return Success;
}

XvImagePtr XvMCFindXvImage(XvPortPtr pPort, CARD32 id)
{
    XvImagePtr pImage = NULL;
    ScreenPtr pScreen = pPort->pAdaptor->pScreen;
    XvMCScreenPtr pScreenPriv;
    XvMCAdaptorPtr adaptor = NULL;
    int i;

    if (!dixPrivateKeyRegistered(XvMCScreenKey))
        return NULL;

    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen))) 
        return NULL;

    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
       if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
          adaptor = &(pScreenPriv->adaptors[i]);
          break;
       }
    }

    if(!adaptor) return NULL;

    for(i = 0; i < adaptor->num_subpictures; i++) {
        if(adaptor->subpictures[i]->id == id) {
            pImage = adaptor->subpictures[i];
            break;
        }
    }

    return pImage;
}

int
xf86XvMCRegisterDRInfo(ScreenPtr pScreen, char *name,
		       char *busID, int major, int minor,
		       int patchLevel)
{
    XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pScreen);
    strncpy(pScreenPriv->clientDriverName, name,
	    DR_CLIENT_DRIVER_NAME_SIZE);
    strncpy(pScreenPriv->busID, busID, DR_BUSID_SIZE);
    pScreenPriv->major = major;
    pScreenPriv->minor = minor;
    pScreenPriv->patchLevel = patchLevel;
    pScreenPriv->clientDriverName[DR_CLIENT_DRIVER_NAME_SIZE-1] = 0;
    pScreenPriv->busID[DR_BUSID_SIZE-1] = 0;
    return Success;
}


#ifndef _XVMC_H
#define _XVMC_H
#include <X11/extensions/Xv.h>
#include "xvdix.h"

typedef struct {
  int num_xvimages;
  int *xvimage_ids;
} XvMCImageIDList;

typedef struct {
  int surface_type_id;
  int chroma_format;
  int color_description;
  unsigned short max_width;
  unsigned short max_height;
  unsigned short subpicture_max_width;
  unsigned short subpicture_max_height;
  int mc_type;
  int flags;
  XvMCImageIDList *compatible_subpictures;
} XvMCSurfaceInfoRec, *XvMCSurfaceInfoPtr;

typedef struct {
  XID context_id;
  ScreenPtr pScreen;
  int adapt_num;
  int surface_type_id;
  unsigned short width;
  unsigned short height;
  CARD32 flags;
  int refcnt;
  pointer port_priv;
  pointer driver_priv;
} XvMCContextRec, *XvMCContextPtr;

typedef struct {
  XID surface_id;
  int surface_type_id;
  XvMCContextPtr context;
  pointer driver_priv;
} XvMCSurfaceRec, *XvMCSurfacePtr;


typedef struct {
  XID subpicture_id;
  int xvimage_id;
  unsigned short width;
  unsigned short height;
  int num_palette_entries;
  int entry_bytes;
  char component_order[4];
  XvMCContextPtr context;
  pointer driver_priv;
} XvMCSubpictureRec, *XvMCSubpicturePtr;

typedef int (*XvMCCreateContextProcPtr) (
  XvPortPtr port,
  XvMCContextPtr context,
  int *num_priv,
  CARD32 **priv 
);

typedef void (*XvMCDestroyContextProcPtr) (
  XvMCContextPtr context
);

typedef int (*XvMCCreateSurfaceProcPtr) (
  XvMCSurfacePtr surface,
  int *num_priv,
  CARD32 **priv
);

typedef void (*XvMCDestroySurfaceProcPtr) (
  XvMCSurfacePtr surface
);

typedef int (*XvMCCreateSubpictureProcPtr) (
  XvMCSubpicturePtr subpicture,
  int *num_priv,
  CARD32 **priv
);

typedef void (*XvMCDestroySubpictureProcPtr) (
  XvMCSubpicturePtr subpicture
);


typedef struct {
  XvAdaptorPtr			    xv_adaptor;
  int				    num_surfaces;
  XvMCSurfaceInfoPtr		    *surfaces;
  int				    num_subpictures;
  XvImagePtr			    *subpictures;
  XvMCCreateContextProcPtr          CreateContext; 
  XvMCDestroyContextProcPtr         DestroyContext; 
  XvMCCreateSurfaceProcPtr          CreateSurface;  
  XvMCDestroySurfaceProcPtr         DestroySurface; 
  XvMCCreateSubpictureProcPtr       CreateSubpicture; 
  XvMCDestroySubpictureProcPtr      DestroySubpicture;
} XvMCAdaptorRec, *XvMCAdaptorPtr;

#ifndef XorgLoader
extern _X_EXPORT void XvMCExtensionInit(void);

extern _X_EXPORT int XvMCScreenInit(ScreenPtr pScreen,
				    int num,
				    XvMCAdaptorPtr adapt);

extern _X_EXPORT XvImagePtr XvMCFindXvImage(XvPortPtr pPort, CARD32 id);

extern _X_EXPORT int xf86XvMCRegisterDRInfo(ScreenPtr pScreen, char *name,
			   char *busID, int major, int minor, 
			   int patchLevel);
#endif

#endif /* _XVMC_H */
/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "scrnintstr.h"
#include "cursorstr.h"
#include "dixevents.h"
#include "servermd.h"
#include "mipointer.h"
#include "inputstr.h"
#include "windowstr.h"
#include "xace.h"
#include "list.h"

static RESTYPE		CursorClientType;
static RESTYPE		CursorHideCountType;
static RESTYPE		CursorWindowType;
RESTYPE			PointerBarrierType;
static CursorPtr	CursorCurrent[MAXDEVICES];

static DevPrivateKeyRec CursorScreenPrivateKeyRec;
#define CursorScreenPrivateKey (&CursorScreenPrivateKeyRec)

static void deleteCursorHideCountsForScreen (ScreenPtr pScreen);

#define VERIFY_CURSOR(pCursor, cursor, client, access)			\
    do {								\
	int err;							\
	err = dixLookupResourceByType((pointer *) &pCursor, cursor,	\
				      RT_CURSOR, client, access);	\
	if (err != Success) {						\
	    client->errorValue = cursor;				\
	    return err;							\
	}								\
    } while (0)

/*
 * There is a global list of windows selecting for cursor events
 */

typedef struct _CursorEvent *CursorEventPtr;

typedef struct _CursorEvent {
    CursorEventPtr	next;
    CARD32		eventMask;
    ClientPtr		pClient;
    WindowPtr		pWindow;
    XID			clientResource;
} CursorEventRec;

static CursorEventPtr	    cursorEvents;

/*
 * Each screen has a list of clients which have requested
 * that the cursor be hid, and the number of times each
 * client has requested.
*/

typedef struct _CursorHideCountRec *CursorHideCountPtr;

typedef struct _CursorHideCountRec {
    CursorHideCountPtr   pNext;  
    ClientPtr            pClient;
    ScreenPtr            pScreen;
    int                  hideCount;
    XID			 resource;
} CursorHideCountRec;

typedef struct PointerBarrierClient *PointerBarrierClientPtr;

struct PointerBarrierClient {
    ScreenPtr screen;
    struct PointerBarrier barrier;
    struct list entry;
};

/*
 * Wrap DisplayCursor to catch cursor change events
 */

typedef struct _CursorScreen {
    DisplayCursorProcPtr	DisplayCursor;
    CloseScreenProcPtr		CloseScreen;
    ConstrainCursorHarderProcPtr ConstrainCursorHarder;
    CursorHideCountPtr          pCursorHideCounts;
    struct list                 barriers;
} CursorScreenRec, *CursorScreenPtr;

#define GetCursorScreen(s) ((CursorScreenPtr)dixLookupPrivate(&(s)->devPrivates, CursorScreenPrivateKey))
#define GetCursorScreenIfSet(s) GetCursorScreen(s)
#define SetCursorScreen(s,p) dixSetPrivate(&(s)->devPrivates, CursorScreenPrivateKey, p)
#define Wrap(as,s,elt,func)	(((as)->elt = (s)->elt), (s)->elt = func)
#define Unwrap(as,s,elt,backup)	(((backup) = (s)->elt), (s)->elt = (as)->elt)

/* The cursor doesn't show up until the first XDefineCursor() */
static Bool CursorVisible = FALSE;

Bool EnableCursor = TRUE;

static Bool
CursorDisplayCursor (DeviceIntPtr pDev,
                     ScreenPtr pScreen,
		     CursorPtr pCursor)
{
    CursorScreenPtr	cs = GetCursorScreen(pScreen);
    Bool		ret;
    DisplayCursorProcPtr backupProc;

    Unwrap (cs, pScreen, DisplayCursor, backupProc);

    /*
     * Have to check ConnectionInfo to distinguish client requests from
     * initial root window setup.  Not a great way to do it, I admit.
     */
    if (ConnectionInfo)
	CursorVisible = EnableCursor;

    if (cs->pCursorHideCounts != NULL || !CursorVisible) {
	ret = (*pScreen->DisplayCursor) (pDev, pScreen, NullCursor);
    } else {
	ret = (*pScreen->DisplayCursor) (pDev, pScreen, pCursor);
    }

    if (pCursor != CursorCurrent[pDev->id])
    {
	CursorEventPtr	e;

	CursorCurrent[pDev->id] = pCursor;
	for (e = cursorEvents; e; e = e->next)
	{
	    if ((e->eventMask & XFixesDisplayCursorNotifyMask))
	    {
		xXFixesCursorNotifyEvent	ev;
		ev.type = XFixesEventBase + XFixesCursorNotify;
		ev.subtype = XFixesDisplayCursorNotify;
		ev.window = e->pWindow->drawable.id;
		ev.cursorSerial = pCursor->serialNumber;
		ev.timestamp = currentTime.milliseconds;
		ev.name = pCursor->name;
		WriteEventsToClient (e->pClient, 1, (xEvent *) &ev);
	    }
	}
    }
    Wrap (cs, pScreen, DisplayCursor, backupProc);

    return ret;
}

static Bool
CursorCloseScreen (int index, ScreenPtr pScreen)
{
    CursorScreenPtr	cs = GetCursorScreen (pScreen);
    Bool		ret;
    _X_UNUSED CloseScreenProcPtr	close_proc;
    _X_UNUSED DisplayCursorProcPtr	display_proc;
    ConstrainCursorHarderProcPtr constrain_proc;

    Unwrap (cs, pScreen, CloseScreen, close_proc);
    Unwrap (cs, pScreen, DisplayCursor, display_proc);
    Unwrap (cs, pScreen, ConstrainCursorHarder, constrain_proc);
    deleteCursorHideCountsForScreen(pScreen);
    ret = (*pScreen->CloseScreen) (index, pScreen);
    free(cs);
    return ret;
}

#define CursorAllEvents (XFixesDisplayCursorNotifyMask)

static int
XFixesSelectCursorInput (ClientPtr	pClient,
			 WindowPtr	pWindow,
			 CARD32		eventMask)
{
    CursorEventPtr	*prev, e;
    pointer val;
    int rc;

    for (prev = &cursorEvents; (e = *prev); prev = &e->next)
    {
	if (e->pClient == pClient &&
	    e->pWindow == pWindow)
	{
	    break;
	}
    }
    if (!eventMask)
    {
	if (e)
	{
	    FreeResource (e->clientResource, 0);
	}
	return Success;
    }
    if (!e)
    {
	e = (CursorEventPtr) malloc(sizeof (CursorEventRec));
	if (!e)
	    return BadAlloc;

	e->next = 0;
	e->pClient = pClient;
	e->pWindow = pWindow;
	e->clientResource = FakeClientID(pClient->index);

	/*
	 * Add a resource hanging from the window to
	 * catch window destroy
	 */
	rc = dixLookupResourceByType( &val, pWindow->drawable.id,
				      CursorWindowType, serverClient,
				      DixGetAttrAccess);
	if (rc != Success)
	    if (!AddResource (pWindow->drawable.id, CursorWindowType,
			      (pointer) pWindow))
	    {
		free(e);
		return BadAlloc;
	    }

	if (!AddResource (e->clientResource, CursorClientType, (pointer) e))
	    return BadAlloc;

	*prev = e;
    }
    e->eventMask = eventMask;
    return Success;
}

int
ProcXFixesSelectCursorInput (ClientPtr client)
{
    REQUEST (xXFixesSelectCursorInputReq);
    WindowPtr	pWin;
    int		rc;

    REQUEST_SIZE_MATCH (xXFixesSelectCursorInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->eventMask & ~CursorAllEvents)
    {
	client->errorValue = stuff->eventMask;
	return BadValue;
    }
    return XFixesSelectCursorInput (client, pWin, stuff->eventMask);
}

static int
GetBit (unsigned char *line, int x)
{
    unsigned char   mask;
    
    if (screenInfo.bitmapBitOrder == LSBFirst)
	mask = (1 << (x & 7));
    else
	mask = (0x80 >> (x & 7));
    /* XXX assumes byte order is host byte order */
    line += (x >> 3);
    if (*line & mask)
	return 1;
    return 0;
}

int
SProcXFixesSelectCursorInput (ClientPtr client)
{
    register int n;
    REQUEST(xXFixesSelectCursorInputReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    swapl(&stuff->eventMask, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}
    
void
SXFixesCursorNotifyEvent (xXFixesCursorNotifyEvent *from,
			  xXFixesCursorNotifyEvent *to)
{
    to->type = from->type;
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->window, to->window);
    cpswapl (from->cursorSerial, to->cursorSerial);
    cpswapl (from->timestamp, to->timestamp);
    cpswapl (from->name, to->name);
}

static void
CopyCursorToImage (CursorPtr pCursor, CARD32 *image)
{
    int width = pCursor->bits->width;
    int height = pCursor->bits->height;
    int npixels = width * height;
    
#ifdef ARGB_CURSOR
    if (pCursor->bits->argb)
	memcpy (image, pCursor->bits->argb, npixels * sizeof (CARD32));
    else
#endif
    {
	unsigned char	*srcLine = pCursor->bits->source;
	unsigned char	*mskLine = pCursor->bits->mask;
	int		stride = BitmapBytePad (width);
	int		x, y;
	CARD32		fg, bg;
	
	fg = (0xff000000 | 
	      ((pCursor->foreRed & 0xff00) << 8) |
	      (pCursor->foreGreen & 0xff00) |
	      (pCursor->foreBlue >> 8));
	bg = (0xff000000 | 
	      ((pCursor->backRed & 0xff00) << 8) |
	      (pCursor->backGreen & 0xff00) |
	      (pCursor->backBlue >> 8));
	for (y = 0; y < height; y++)
	{
	    for (x = 0; x < width; x++)
	    {
		if (GetBit (mskLine, x))
		{
		    if (GetBit (srcLine, x))
			*image++ = fg;
		    else
			*image++ = bg;
		}
		else
		    *image++ = 0;
	    }
	    srcLine += stride;
	    mskLine += stride;
	}
    }
}

int
ProcXFixesGetCursorImage (ClientPtr client)
{
/*    REQUEST(xXFixesGetCursorImageReq); */
    xXFixesGetCursorImageReply	*rep;
    CursorPtr			pCursor;
    CARD32			*image;
    int				npixels, width, height, rc, x, y;

    REQUEST_SIZE_MATCH(xXFixesGetCursorImageReq);
    pCursor = CursorCurrent[PickPointer(client)->id];
    if (!pCursor)
	return BadCursor;
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, pCursor->id, RT_CURSOR,
		  pCursor, RT_NONE, NULL, DixReadAccess);
    if (rc != Success)
	return rc;
    GetSpritePosition (PickPointer(client), &x, &y);
    width = pCursor->bits->width;
    height = pCursor->bits->height;
    npixels = width * height;
    rep = malloc(sizeof (xXFixesGetCursorImageReply) +
		  npixels * sizeof (CARD32));
    if (!rep)
	return BadAlloc;

    rep->type = X_Reply;
    rep->sequenceNumber = client->sequence;
    rep->length = npixels;
    rep->width = width;
    rep->height = height;
    rep->x = x;
    rep->y = y;
    rep->xhot = pCursor->bits->xhot;
    rep->yhot = pCursor->bits->yhot; 
    rep->cursorSerial = pCursor->serialNumber;

    image = (CARD32 *) (rep + 1);
    CopyCursorToImage (pCursor, image);
    if (client->swapped)
    {
	int n;
	swaps (&rep->sequenceNumber, n);
	swapl (&rep->length, n);
	swaps (&rep->x, n);
	swaps (&rep->y, n);
	swaps (&rep->width, n);
	swaps (&rep->height, n);
	swaps (&rep->xhot, n);
	swaps (&rep->yhot, n);
	swapl (&rep->cursorSerial, n);
	SwapLongs (image, npixels);
    }
    WriteToClient(client, sizeof (xXFixesGetCursorImageReply) +
			 (npixels << 2), (char *) rep);
    free(rep);
    return Success;
}

int
SProcXFixesGetCursorImage (ClientPtr client)
{
    int n;
    REQUEST(xXFixesGetCursorImageReq);
    swaps (&stuff->length, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetCursorName (ClientPtr client)
{
    CursorPtr pCursor;
    char *tchar;
    REQUEST(xXFixesSetCursorNameReq);
    Atom atom;

    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
    tchar = (char *) &stuff[1];
    atom = MakeAtom (tchar, stuff->nbytes, TRUE);
    if (atom == BAD_RESOURCE)
	return BadAlloc;
    
    pCursor->name = atom;
    return Success;
}

int
SProcXFixesSetCursorName (ClientPtr client)
{
    int n;
    REQUEST(xXFixesSetCursorNameReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
    swapl (&stuff->cursor, n);
    swaps (&stuff->nbytes, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesGetCursorName (ClientPtr client)
{
    CursorPtr			pCursor;
    xXFixesGetCursorNameReply	reply;
    REQUEST(xXFixesGetCursorNameReq);
    const char *str;
    int len;

    REQUEST_SIZE_MATCH(xXFixesGetCursorNameReq);
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixGetAttrAccess);
    if (pCursor->name)
	str = NameForAtom (pCursor->name);
    else
	str = "";
    len = strlen (str);
    
    reply.type = X_Reply;
    reply.length = bytes_to_int32(len);
    reply.sequenceNumber = client->sequence;
    reply.atom = pCursor->name;
    reply.nbytes = len;
    if (client->swapped)
    {
	int n;
	swaps (&reply.sequenceNumber, n);
	swapl (&reply.length, n);
	swapl (&reply.atom, n);
	swaps (&reply.nbytes, n);
    }
    WriteReplyToClient(client, sizeof(xXFixesGetCursorNameReply), &reply);
    WriteToClient(client, len, str);
    
    return Success;
}

int
SProcXFixesGetCursorName (ClientPtr client)
{
    int n;
    REQUEST(xXFixesGetCursorNameReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesGetCursorNameReq);
    swapl (&stuff->cursor, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesGetCursorImageAndName (ClientPtr client)
{
/*    REQUEST(xXFixesGetCursorImageAndNameReq); */
    xXFixesGetCursorImageAndNameReply	*rep;
    CursorPtr			pCursor;
    CARD32			*image;
    int				npixels;
    const char			*name;
    int				nbytes, nbytesRound;
    int				width, height;
    int				rc, x, y;

    REQUEST_SIZE_MATCH(xXFixesGetCursorImageAndNameReq);
    pCursor = CursorCurrent[PickPointer(client)->id];
    if (!pCursor)
	return BadCursor;
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, pCursor->id, RT_CURSOR,
		  pCursor, RT_NONE, NULL, DixReadAccess|DixGetAttrAccess);
    if (rc != Success)
	return rc;
    GetSpritePosition (PickPointer(client), &x, &y);
    width = pCursor->bits->width;
    height = pCursor->bits->height;
    npixels = width * height;
    name = pCursor->name ? NameForAtom (pCursor->name) : "";
    nbytes = strlen (name);
    nbytesRound = pad_to_int32(nbytes);
    rep = malloc(sizeof (xXFixesGetCursorImageAndNameReply) +
		  npixels * sizeof (CARD32) + nbytesRound);
    if (!rep)
	return BadAlloc;

    rep->type = X_Reply;
    rep->sequenceNumber = client->sequence;
    rep->length = npixels + bytes_to_int32(nbytesRound);
    rep->width = width;
    rep->height = height;
    rep->x = x;
    rep->y = y;
    rep->xhot = pCursor->bits->xhot;
    rep->yhot = pCursor->bits->yhot; 
    rep->cursorSerial = pCursor->serialNumber;
    rep->cursorName = pCursor->name;
    rep->nbytes = nbytes;

    image = (CARD32 *) (rep + 1);
    CopyCursorToImage (pCursor, image);
    memcpy ((image + npixels), name, nbytes);
    if (client->swapped)
    {
	int n;
	swaps (&rep->sequenceNumber, n);
	swapl (&rep->length, n);
	swaps (&rep->x, n);
	swaps (&rep->y, n);
	swaps (&rep->width, n);
	swaps (&rep->height, n);
	swaps (&rep->xhot, n);
	swaps (&rep->yhot, n);
	swapl (&rep->cursorSerial, n);
	swapl (&rep->cursorName, n);
	swaps (&rep->nbytes, n);
	SwapLongs (image, npixels);
    }
    WriteToClient(client, sizeof (xXFixesGetCursorImageAndNameReply) +
			 (npixels << 2) + nbytesRound, (char *) rep);
    free(rep);
    return Success;
}

int
SProcXFixesGetCursorImageAndName (ClientPtr client)
{
    int n;
    REQUEST(xXFixesGetCursorImageAndNameReq);
    swaps (&stuff->length, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

/*
 * Find every cursor reference in the system, ask testCursor
 * whether it should be replaced with a reference to pCursor.
 */

typedef Bool (*TestCursorFunc) (CursorPtr pOld, pointer closure);

typedef struct {
    RESTYPE type;
    TestCursorFunc testCursor;
    CursorPtr pNew;
    pointer closure;
} ReplaceCursorLookupRec, *ReplaceCursorLookupPtr;

static const RESTYPE    CursorRestypes[] = {
    RT_WINDOW, RT_PASSIVEGRAB, RT_CURSOR
};

#define NUM_CURSOR_RESTYPES (sizeof (CursorRestypes) / sizeof (CursorRestypes[0]))

static Bool
ReplaceCursorLookup (pointer value, XID id, pointer closure)
{
    ReplaceCursorLookupPtr  rcl = (ReplaceCursorLookupPtr) closure;
    WindowPtr		    pWin;
    GrabPtr		    pGrab;
    CursorPtr		    pCursor = 0, *pCursorRef = 0;
    XID			    cursor = 0;

    switch (rcl->type) {
    case RT_WINDOW:
	pWin = (WindowPtr) value;
	if (pWin->optional)
	{
	    pCursorRef = &pWin->optional->cursor;
	    pCursor = *pCursorRef;
	}
	break;
    case RT_PASSIVEGRAB:
	pGrab = (GrabPtr) value;
	pCursorRef = &pGrab->cursor;
	pCursor = *pCursorRef;
	break;
    case RT_CURSOR:
	pCursorRef = 0;
	pCursor = (CursorPtr) value;
	cursor = id;
	break;
    }
    if (pCursor && pCursor != rcl->pNew)
    {
	if ((*rcl->testCursor) (pCursor, rcl->closure))
	{
	    rcl->pNew->refcnt++;
	    /* either redirect reference or update resource database */
	    if (pCursorRef)
		*pCursorRef = rcl->pNew;
	    else
		ChangeResourceValue (id, RT_CURSOR, rcl->pNew);
	    FreeCursor (pCursor, cursor);
	}
    }
    return FALSE;   /* keep walking */
}

static void
ReplaceCursor (CursorPtr pCursor,
	       TestCursorFunc testCursor,
	       pointer closure)
{
    int	clientIndex;
    int resIndex;
    ReplaceCursorLookupRec  rcl;
    
    /* 
     * Cursors exist only in the resource database, windows and grabs.
     * All of these are always pointed at by the resource database.  Walk
     * the whole thing looking for cursors
     */
    rcl.testCursor = testCursor;
    rcl.pNew = pCursor;
    rcl.closure = closure;

    /* for each client */
    for (clientIndex = 0; clientIndex < currentMaxClients; clientIndex++)
    {
	if (!clients[clientIndex])
	    continue;
	for (resIndex = 0; resIndex < NUM_CURSOR_RESTYPES; resIndex++)
	{
	    rcl.type = CursorRestypes[resIndex];
	    /*
	     * This function walks the entire client resource database
	     */
	    LookupClientResourceComplex (clients[clientIndex], 
					 rcl.type, 
					 ReplaceCursorLookup,
					 (pointer) &rcl);
	}
    }
    /* this "knows" that WindowHasNewCursor doesn't depend on it's argument */
    WindowHasNewCursor (screenInfo.screens[0]->root);
}

static Bool 
TestForCursor (CursorPtr pCursor, pointer closure)
{
    return (pCursor == (CursorPtr) closure);
}

int
ProcXFixesChangeCursor (ClientPtr client)
{
    CursorPtr	pSource, pDestination;
    REQUEST(xXFixesChangeCursorReq);

    REQUEST_SIZE_MATCH(xXFixesChangeCursorReq);
    VERIFY_CURSOR (pSource, stuff->source, client,
		   DixReadAccess|DixGetAttrAccess);
    VERIFY_CURSOR (pDestination, stuff->destination, client,
		   DixWriteAccess|DixSetAttrAccess);

    ReplaceCursor (pSource, TestForCursor, (pointer) pDestination);
    return Success;
}

int
SProcXFixesChangeCursor (ClientPtr client)
{
    int n;
    REQUEST(xXFixesChangeCursorReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesChangeCursorReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static Bool
TestForCursorName (CursorPtr pCursor, pointer closure)
{
    Atom *pName = closure;
    return pCursor->name == *pName;
}

int
ProcXFixesChangeCursorByName (ClientPtr client)
{
    CursorPtr	pSource;
    Atom	name;
    char	*tchar;
    REQUEST(xXFixesChangeCursorByNameReq);

    REQUEST_FIXED_SIZE(xXFixesChangeCursorByNameReq, stuff->nbytes);
    VERIFY_CURSOR(pSource, stuff->source, client,
		  DixReadAccess|DixGetAttrAccess);
    tchar = (char *) &stuff[1];
    name = MakeAtom (tchar, stuff->nbytes, FALSE);
    if (name)
	ReplaceCursor (pSource, TestForCursorName, &name);
    return Success;
}

int
SProcXFixesChangeCursorByName (ClientPtr client)
{
    int n;
    REQUEST(xXFixesChangeCursorByNameReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE (xXFixesChangeCursorByNameReq);
    swapl (&stuff->source, n);
    swaps (&stuff->nbytes, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

/*
 * Routines for manipulating the per-screen hide counts list.
 * This list indicates which clients have requested cursor hiding 
 * for that screen.
 */

/* Return the screen's hide-counts list element for the given client */
static CursorHideCountPtr
findCursorHideCount (ClientPtr pClient, ScreenPtr pScreen) 
{
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc;

    for (pChc = cs->pCursorHideCounts; pChc != NULL; pChc = pChc->pNext) {
	if (pChc->pClient == pClient) {
	    return pChc;
	}
    }

    return NULL;           
}

static int
createCursorHideCount (ClientPtr pClient, ScreenPtr pScreen)
{
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc;

    pChc = (CursorHideCountPtr) malloc(sizeof(CursorHideCountRec));
    if (pChc == NULL) {
	return BadAlloc;
    }
    pChc->pClient = pClient;
    pChc->pScreen = pScreen;
    pChc->hideCount = 1;
    pChc->resource = FakeClientID(pClient->index);
    pChc->pNext = cs->pCursorHideCounts;
    cs->pCursorHideCounts = pChc;
    
    /* 
     * Create a resource for this element so it can be deleted
     * when the client goes away.
     */
    if (!AddResource (pChc->resource, CursorHideCountType, 
		      (pointer) pChc)) {
	free(pChc);
	return BadAlloc;
    }

    return Success;
}

/* 
 * Delete the given hide-counts list element from its screen list.
 */
static void
deleteCursorHideCount (CursorHideCountPtr pChcToDel, ScreenPtr pScreen)
{
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc, pNext;
    CursorHideCountPtr pChcLast = NULL;

    pChc = cs->pCursorHideCounts;
    while (pChc != NULL) {
	pNext = pChc->pNext;
	if (pChc == pChcToDel) {
	    free(pChc);
	    if (pChcLast == NULL) {
		cs->pCursorHideCounts = pNext;
	    } else {
		pChcLast->pNext = pNext;
	    }
	    return;
	}
	pChcLast = pChc;
	pChc = pNext;
    }
}

/* 
 * Delete all the hide-counts list elements for this screen.
 */
static void
deleteCursorHideCountsForScreen (ScreenPtr pScreen)
{
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc, pTmp;

    pChc = cs->pCursorHideCounts;
    while (pChc != NULL) {
	pTmp = pChc->pNext;
	FreeResource(pChc->resource, 0);
	pChc = pTmp;
    }
    cs->pCursorHideCounts = NULL;   
}

int 
ProcXFixesHideCursor (ClientPtr client) 
{
    WindowPtr pWin;
    CursorHideCountPtr pChc;
    REQUEST(xXFixesHideCursorReq);
    int ret;

    REQUEST_SIZE_MATCH (xXFixesHideCursorReq);

    ret = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			    client, DixGetAttrAccess);
    if (ret != Success) {
	client->errorValue = stuff->window;
	return ret;
    }

    /* 
     * Has client hidden the cursor before on this screen? 
     * If so, just increment the count. 
     */

    pChc = findCursorHideCount(client, pWin->drawable.pScreen);
    if (pChc != NULL) {
	pChc->hideCount++;
	return Success;
    }

    /* 
     * This is the first time this client has hid the cursor 
     * for this screen.
     */
    ret = XaceHook(XACE_SCREEN_ACCESS, client, pWin->drawable.pScreen,
		   DixHideAccess);
    if (ret != Success)
	return ret;

    ret = createCursorHideCount(client, pWin->drawable.pScreen);

    if (ret == Success) {
	DeviceIntPtr dev;
	for (dev = inputInfo.devices; dev; dev = dev->next)
	{
	    if (IsMaster(dev) && IsPointerDevice(dev))
		CursorDisplayCursor(dev, pWin->drawable.pScreen, CursorCurrent[dev->id]);
	}
    }

    return ret;
}

int 
SProcXFixesHideCursor (ClientPtr client) 
{
    int n;
    REQUEST(xXFixesHideCursorReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesHideCursorReq);
    swapl (&stuff->window, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int 
ProcXFixesShowCursor (ClientPtr client) 
{
    WindowPtr pWin;
    CursorHideCountPtr pChc;
    int rc;
    REQUEST(xXFixesShowCursorReq);

    REQUEST_SIZE_MATCH (xXFixesShowCursorReq);

    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			   client, DixGetAttrAccess);
    if (rc != Success) {
	client->errorValue = stuff->window;
	return rc;
    }

    /* 
     * Has client hidden the cursor on this screen?
     * If not, generate an error.
     */
    pChc = findCursorHideCount(client, pWin->drawable.pScreen);
    if (pChc == NULL) {
	return BadMatch;
    }

    rc = XaceHook(XACE_SCREEN_ACCESS, client, pWin->drawable.pScreen,
		  DixShowAccess);
    if (rc != Success)
	return rc;

    pChc->hideCount--;
    if (pChc->hideCount <= 0) {
	FreeResource(pChc->resource, 0);
    }

    return Success;
}

int 
SProcXFixesShowCursor (ClientPtr client) 
{
    int n;
    REQUEST(xXFixesShowCursorReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesShowCursorReq);
    swapl (&stuff->window, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int
CursorFreeClient (pointer data, XID id)
{
    CursorEventPtr	old = (CursorEventPtr) data;
    CursorEventPtr	*prev, e;
    
    for (prev = &cursorEvents; (e = *prev); prev = &e->next)
    {
	if (e == old)
	{
	    *prev = e->next;
	    free(e);
	    break;
	}
    }
    return 1;
}

static int
CursorFreeHideCount (pointer data, XID id)
{
    CursorHideCountPtr pChc = (CursorHideCountPtr) data;
    ScreenPtr pScreen = pChc->pScreen;
    DeviceIntPtr dev;

    deleteCursorHideCount(pChc, pChc->pScreen);
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
        if (IsMaster(dev) && IsPointerDevice(dev))
            CursorDisplayCursor(dev, pScreen, CursorCurrent[dev->id]);
    }

    return 1;
}

static int
CursorFreeWindow (pointer data, XID id)
{
    WindowPtr		pWindow = (WindowPtr) data;
    CursorEventPtr	e, next;

    for (e = cursorEvents; e; e = next)
    {
	next = e->next;
	if (e->pWindow == pWindow)
	{
	    FreeResource (e->clientResource, 0);
	}
    }
    return 1;
}

static BOOL
barrier_is_horizontal(const struct PointerBarrier *barrier)
{
    return barrier->y1 == barrier->y2;
}

static BOOL
barrier_is_vertical(const struct PointerBarrier *barrier)
{
    return barrier->x1 == barrier->x2;
}

/**
 * @return The set of barrier movement directions the movement vector
 * x1/y1 → x2/y2 represents.
 */
int
barrier_get_direction(int x1, int y1, int x2, int y2)
{
    int direction = 0;

    /* which way are we trying to go */
    if (x2 > x1)
	direction |= BarrierPositiveX;
    if (x2 < x1)
	direction |= BarrierNegativeX;
    if (y2 > y1)
	direction |= BarrierPositiveY;
    if (y2 < y1)
	direction |= BarrierNegativeY;

    return direction;
}

/**
 * Test if the barrier may block movement in the direction defined by
 * x1/y1 → x2/y2. This function only tests whether the directions could be
 * blocked, it does not test if the barrier actually blocks the movement.
 *
 * @return TRUE if the barrier blocks the direction of movement or FALSE
 * otherwise.
 */
BOOL
barrier_is_blocking_direction(const struct PointerBarrier *barrier, int direction)
{
    /* Barriers define which way is ok, not which way is blocking */
    return (barrier->directions & direction) != direction;
}

/**
 * Test if the movement vector x1/y1 → x2/y2 is intersecting with the
 * barrier. A movement vector with the startpoint or endpoint adjacent to
 * the barrier itself counts as intersecting.
 *
 * @param x1 X start coordinate of movement vector
 * @param y1 Y start coordinate of movement vector
 * @param x2 X end coordinate of movement vector
 * @param y2 Y end coordinate of movement vector
 * @param[out] distance The distance between the start point and the
 * intersection with the barrier (if applicable).
 * @return TRUE if the barrier intersects with the given vector
 */
BOOL
barrier_is_blocking(const struct PointerBarrier *barrier,
		    int x1, int y1, int x2, int y2,
		    double *distance)
{
    BOOL rc = FALSE;
    float ua, ub, ud;
    int dir = barrier_get_direction(x1, y1, x2, y2);

    /* Algorithm below doesn't handle edge cases well, hence the extra
     * checks. */
    if (barrier_is_vertical(barrier)) {
	/* handle immediate barrier adjacency, moving away */
	if (dir & BarrierPositiveX && x1 == barrier->x1)
	    return FALSE;
	if (dir & BarrierNegativeX && x1 == (barrier->x1 - 1))
	    return FALSE;
	/* startpoint adjacent to barrier, moving towards -> block */
	if (x1 == barrier->x1 && y1 >= barrier->y1 && y1 <= barrier->y2) {
	    *distance = 0;
	    return TRUE;
	}
    } else {
	/* handle immediate barrier adjacency, moving away */
	if (dir & BarrierPositiveY && y1 == barrier->y1)
	    return FALSE;
	if (dir & BarrierNegativeY && y1 == (barrier->y1 - 1))
	    return FALSE;
	/* startpoint adjacent to barrier, moving towards -> block */
	if (y1 == barrier->y1 && x1 >= barrier->x1 && x1 <= barrier->x2) {
	    *distance = 0;
	    return TRUE;
        }
    }

    /* not an edge case, compute distance */
    ua = 0;
    ud = (barrier->y2 - barrier->y1) * (x2 - x1) - (barrier->x2 - barrier->x1) * (y2 - y1);
    if (ud != 0) {
	ua = ((barrier->x2 - barrier->x1) * (y1 - barrier->y1) -
	     (barrier->y2 - barrier->y1) * (x1 - barrier->x1)) / ud;
	ub = ((x2 - x1) * (y1 - barrier->y1) -
	     (y2 - y1) * (x1 - barrier->x1)) / ud;
	if (ua < 0 || ua > 1 || ub < 0 || ub > 1)
	    ua = 0;
    }

    if (ua > 0 && ua <= 1)
    {
	double ix = barrier->x1 + ua * (barrier->x2 - barrier->x1);
	double iy = barrier->y1 + ua * (barrier->y2 - barrier->y1);

	*distance = sqrt(pow(x1 - ix, 2) + pow(y1 - iy, 2));
	rc = TRUE;
    }

    return rc;
}

/**
 * Find the nearest barrier that is blocking movement from x1/y1 to x2/y2.
 *
 * @param dir Only barriers blocking movement in direction dir are checked
 * @param x1 X start coordinate of movement vector
 * @param y1 Y start coordinate of movement vector
 * @param x2 X end coordinate of movement vector
 * @param y2 Y end coordinate of movement vector
 * @return The barrier nearest to the movement origin that blocks this movement.
 */
static struct PointerBarrier*
barrier_find_nearest(CursorScreenPtr cs, int dir,
		     int x1, int y1, int x2, int y2)
{
    struct PointerBarrierClient *c;
    struct PointerBarrier *nearest = NULL;
    double min_distance = INT_MAX; /* can't get higher than that in X anyway */

    list_for_each_entry(c, &cs->barriers, entry) {
	struct PointerBarrier *b = &c->barrier;
	double distance;

	if (!barrier_is_blocking_direction(b, dir))
	    continue;

	if (barrier_is_blocking(b, x1, y1, x2, y2, &distance))
	{
	    if (min_distance > distance)
	    {
		min_distance = distance;
		nearest = b;
	    }
	}
    }

    return nearest;
}

/**
 * Clamp to the given barrier given the movement direction specified in dir.
 *
 * @param barrier The barrier to clamp to
 * @param dir The movement direction
 * @param[out] x The clamped x coordinate.
 * @param[out] y The clamped x coordinate.
 */
void
barrier_clamp_to_barrier(struct PointerBarrier *barrier, int dir, int *x, int *y)
{
    if (barrier_is_vertical(barrier))
    {
	if ((dir & BarrierNegativeX) & ~barrier->directions)
	    *x = barrier->x1;
	if ((dir & BarrierPositiveX) & ~barrier->directions)
	    *x = barrier->x1 - 1;
    }
    if (barrier_is_horizontal(barrier))
    {
	if ((dir & BarrierNegativeY) & ~barrier->directions)
	    *y = barrier->y1;
	if ((dir & BarrierPositiveY) & ~barrier->directions)
	    *y = barrier->y1 - 1;
    }
}

static void
CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode, int *x, int *y)
{
    CursorScreenPtr cs = GetCursorScreen(screen);

    if (!list_is_empty(&cs->barriers) && !IsFloating(dev) && mode == Relative) {
	int ox, oy;
	int dir;
	struct PointerBarrier *nearest = NULL;

	/* where are we coming from */
	miPointerGetPosition(dev, &ox, &oy);

	/* How this works:
	 * Given the origin and the movement vector, get the nearest barrier
	 * to the origin that is blocking the movement.
	 * Clamp to that barrier.
	 * Then, check from the clamped intersection to the original
	 * destination, again finding the nearest barrier and clamping.
	 */
	dir = barrier_get_direction(ox, oy, *x, *y);

	nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
	if (nearest) {
	    barrier_clamp_to_barrier(nearest, dir, x, y);

	    if (barrier_is_vertical(nearest)) {
		dir &= ~(BarrierNegativeX | BarrierPositiveX);
		ox = *x;
	    } else if (barrier_is_horizontal(nearest)) {
		dir &= ~(BarrierNegativeY | BarrierPositiveY);
		oy = *y;
	    }

	    nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
	    if (nearest) {
		barrier_clamp_to_barrier(nearest, dir, x, y);
	    }
	}
    }

    if (cs->ConstrainCursorHarder) {
	screen->ConstrainCursorHarder = cs->ConstrainCursorHarder;
	screen->ConstrainCursorHarder(dev, screen, mode, x, y);
	screen->ConstrainCursorHarder = CursorConstrainCursorHarder;
    }
}

static struct PointerBarrierClient *
CreatePointerBarrierClient(ScreenPtr screen, ClientPtr client,
			   xXFixesCreatePointerBarrierReq *stuff)
{
    CursorScreenPtr cs = GetCursorScreen(screen);
    struct PointerBarrierClient *ret = malloc(sizeof(*ret));

    if (ret) {
	ret->screen = screen;
	ret->barrier.x1 = min(stuff->x1, stuff->x2);
	ret->barrier.x2 = max(stuff->x1, stuff->x2);
	ret->barrier.y1 = min(stuff->y1, stuff->y2);
	ret->barrier.y2 = max(stuff->y1, stuff->y2);
	ret->barrier.directions = stuff->directions & 0x0f;
	if (barrier_is_horizontal(&ret->barrier))
	    ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
	if (barrier_is_vertical(&ret->barrier))
	    ret->barrier.directions &= ~(BarrierPositiveY | BarrierNegativeY);
	list_add(&ret->entry, &cs->barriers);
    }

    return ret;
}

int
ProcXFixesCreatePointerBarrier (ClientPtr client)
{
    int err;
    WindowPtr pWin;
    struct PointerBarrierClient *barrier;
    struct PointerBarrier b;
    REQUEST (xXFixesCreatePointerBarrierReq);

    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
    LEGAL_NEW_RESOURCE(stuff->barrier, client);

    err = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (err != Success) {
	client->errorValue = stuff->window;
	return err;
    }

    /* This sure does need fixing. */
    if (stuff->num_devices)
	return BadImplementation;

    b.x1 = stuff->x1;
    b.x2 = stuff->x2;
    b.y1 = stuff->y1;
    b.y2 = stuff->y2;

    if (!barrier_is_horizontal(&b) && !barrier_is_vertical(&b))
	return BadValue;

    /* no 0-sized barriers */
    if (barrier_is_horizontal(&b) && barrier_is_vertical(&b))
	return BadValue;

    if (!(barrier = CreatePointerBarrierClient(pWin->drawable.pScreen,
					       client, stuff)))
	return BadAlloc;

    if (!AddResource(stuff->barrier, PointerBarrierType, &barrier->barrier))
	return BadAlloc;

    return Success;
}

int
SProcXFixesCreatePointerBarrier (ClientPtr client)
{
    int n;
    REQUEST(xXFixesCreatePointerBarrierReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
    swapl(&stuff->barrier, n);
    swapl(&stuff->window, n);
    swaps(&stuff->x1, n);
    swaps(&stuff->y1, n);
    swaps(&stuff->x2, n);
    swaps(&stuff->y2, n);
    swapl(&stuff->directions, n);
    return ProcXFixesVector[stuff->xfixesReqType](client);
}

static int
CursorFreeBarrier(void *data, XID id)
{
    struct PointerBarrierClient *b = NULL, *barrier;
    ScreenPtr screen;
    CursorScreenPtr cs;

    barrier = container_of(data, struct PointerBarrierClient, barrier);
    screen = barrier->screen;
    cs = GetCursorScreen(screen);

    /* find and unlink from the screen private */
    list_for_each_entry(b, &cs->barriers, entry) {
	if (b == barrier) {
	    list_del(&b->entry);
	    break;
	}
    }

    free(barrier);
    return Success;
}

int
ProcXFixesDestroyPointerBarrier (ClientPtr client)
{
    int err;
    void *barrier;
    REQUEST (xXFixesDestroyPointerBarrierReq);

    REQUEST_SIZE_MATCH(xXFixesDestroyPointerBarrierReq);

    err = dixLookupResourceByType((void **)&barrier, stuff->barrier,
				  PointerBarrierType, client,
				  DixDestroyAccess);
    if (err != Success) {
	client->errorValue = stuff->barrier;
	return err;
    }

    FreeResource(stuff->barrier, RT_NONE);
    return Success;
}

int
SProcXFixesDestroyPointerBarrier (ClientPtr client)
{
    int n;
    REQUEST(xXFixesDestroyPointerBarrierReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesDestroyPointerBarrierReq);
    swapl(&stuff->barrier, n);
    return ProcXFixesVector[stuff->xfixesReqType](client);
}

Bool
XFixesCursorInit (void)
{
    int	i;

    if (party_like_its_1989)
	CursorVisible = EnableCursor;
    
    if (!dixRegisterPrivateKey(&CursorScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ScreenPtr	pScreen = screenInfo.screens[i];
	CursorScreenPtr	cs;

	cs = (CursorScreenPtr) calloc(1, sizeof (CursorScreenRec));
	if (!cs)
	    return FALSE;
	list_init(&cs->barriers);
	Wrap (cs, pScreen, CloseScreen, CursorCloseScreen);
	Wrap (cs, pScreen, DisplayCursor, CursorDisplayCursor);
	Wrap (cs, pScreen, ConstrainCursorHarder, CursorConstrainCursorHarder);
	cs->pCursorHideCounts = NULL;
	SetCursorScreen (pScreen, cs);
    }
    CursorClientType = CreateNewResourceType(CursorFreeClient,
					     "XFixesCursorClient");
    CursorHideCountType = CreateNewResourceType(CursorFreeHideCount,
						"XFixesCursorHideCount");
    CursorWindowType = CreateNewResourceType(CursorFreeWindow,
					     "XFixesCursorWindow");
    PointerBarrierType = CreateNewResourceType(CursorFreeBarrier,
					      "XFixesPointerBarrier");

    return CursorClientType && CursorHideCountType && CursorWindowType &&
	   PointerBarrierType;
}

noinst_LTLIBRARIES = libxfixes.la

AM_CFLAGS = $(DIX_CFLAGS)

if XORG
sdk_HEADERS = xfixes.h
endif

libxfixes_la_SOURCES = 	\
	cursor.c	\
	region.c	\
	saveset.c	\
	select.c	\
	xfixes.c	\
	xfixes.h	\
	xfixesint.h
/*
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "scrnintstr.h"
#include <picturestr.h>
extern int RenderErrBase;
#include <regionstr.h>
#include <gcstruct.h>
#include <window.h>

RESTYPE RegionResType;

static int
RegionResFree (pointer data, XID id)
{
    RegionPtr    pRegion = (RegionPtr) data;

    RegionDestroy(pRegion);
    return Success;
}

RegionPtr
XFixesRegionCopy (RegionPtr pRegion)
{
    RegionPtr   pNew = RegionCreate(RegionExtents(pRegion),
				      RegionNumRects(pRegion));
    if (!pNew)
	return 0;
    if (!RegionCopy(pNew, pRegion))
    {
	RegionDestroy(pNew);
	return 0;
    }
    return pNew;
}

Bool
XFixesRegionInit (void)
{
    RegionResType = CreateNewResourceType(RegionResFree, "XFixesRegion");

    return RegionResType != 0;
}

int
ProcXFixesCreateRegion (ClientPtr client)
{
    int		things;
    RegionPtr	pRegion;
    REQUEST (xXFixesCreateRegionReq);
    
    REQUEST_AT_LEAST_SIZE(xXFixesCreateRegionReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);
    
    things = (client->req_len << 2) - sizeof (xXFixesCreateRegionReq);
    if (things & 4)
	return BadLength;
    things >>= 3;

    pRegion = RegionFromRects(things, (xRectangle *) (stuff + 1), CT_UNSORTED);
    if (!pRegion)
	return BadAlloc;
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegion (ClientPtr client)
{
    register int n;
    REQUEST(xXFixesCreateRegionReq);
    
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXFixesCreateRegionReq);
    swapl(&stuff->region, n);
    SwapRestS(stuff);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromBitmap (ClientPtr client)
{
    RegionPtr	pRegion;
    PixmapPtr	pPixmap;
    int rc;
    REQUEST (xXFixesCreateRegionFromBitmapReq);

    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromBitmapReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);

    rc = dixLookupResourceByType((pointer *)&pPixmap, stuff->bitmap, RT_PIXMAP,
			   client, DixReadAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->bitmap;
	return rc;
    }
    if (pPixmap->drawable.depth != 1)
	return BadMatch;

    pRegion = BitmapToRegion(pPixmap->drawable.pScreen, pPixmap);

    if (!pRegion)
	return BadAlloc;
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegionFromBitmap (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCreateRegionFromBitmapReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromBitmapReq);
    swapl(&stuff->region, n);
    swapl(&stuff->bitmap, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromWindow (ClientPtr client)
{
    RegionPtr	pRegion;
    Bool	copy = TRUE;
    WindowPtr	pWin;
    int rc;
    REQUEST (xXFixesCreateRegionFromWindowReq);
    
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromWindowReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			   client, DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->window;
	return rc;
    }
    switch (stuff->kind) {
    case WindowRegionBounding:
	pRegion = wBoundingShape(pWin);
	if (!pRegion)
	{
	    pRegion = CreateBoundingShape (pWin);
	    copy = FALSE;
	}
	break;
    case WindowRegionClip:
	pRegion = wClipShape(pWin);
	if (!pRegion)
	{
	    pRegion = CreateClipShape (pWin);
	    copy = FALSE;
	}
	break;
    default:
	client->errorValue = stuff->kind;
	return BadValue;
    }
    if (copy && pRegion)
	pRegion = XFixesRegionCopy (pRegion);
    if (!pRegion)
	return BadAlloc;
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegionFromWindow (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCreateRegionFromWindowReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromWindowReq);
    swapl(&stuff->region, n);
    swapl(&stuff->window, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromGC (ClientPtr client)
{
    RegionPtr	pRegion, pClip;
    GCPtr	pGC;
    int 	rc;
    REQUEST (xXFixesCreateRegionFromGCReq);

    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromGCReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);

    rc = dixLookupGC(&pGC, stuff->gc, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    
    switch (pGC->clientClipType) {
    case CT_PIXMAP:
	pRegion = BitmapToRegion(pGC->pScreen, (PixmapPtr) pGC->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
    case CT_REGION:
	pClip = (RegionPtr) pGC->clientClip;
	pRegion = XFixesRegionCopy (pClip);
	if (!pRegion)
	    return BadAlloc;
	break;
    default:
	return BadImplementation;   /* assume sane server bits */
    }
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegionFromGC (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCreateRegionFromGCReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromGCReq);
    swapl(&stuff->region, n);
    swapl(&stuff->gc, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromPicture (ClientPtr client)
{
    RegionPtr	pRegion;
    PicturePtr	pPicture;
    REQUEST (xXFixesCreateRegionFromPictureReq);

    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromPictureReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);

    VERIFY_PICTURE(pPicture, stuff->picture, client, DixGetAttrAccess);
    
    switch (pPicture->clientClipType) {
    case CT_PIXMAP:
	pRegion = BitmapToRegion(pPicture->pDrawable->pScreen,
				   (PixmapPtr) pPicture->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
    case CT_REGION:
	pRegion = XFixesRegionCopy ((RegionPtr) pPicture->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
    default:
	return BadImplementation;   /* assume sane server bits */
    }
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegionFromPicture (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCreateRegionFromPictureReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromPictureReq);
    swapl(&stuff->region, n);
    swapl(&stuff->picture, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesDestroyRegion (ClientPtr client)
{
    REQUEST (xXFixesDestroyRegionReq);
    RegionPtr	pRegion;

    REQUEST_SIZE_MATCH(xXFixesDestroyRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
    FreeResource (stuff->region, RT_NONE);
    return Success;
}

int
SProcXFixesDestroyRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesDestroyRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesDestroyRegionReq);
    swapl (&stuff->region, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetRegion (ClientPtr client)
{
    int		things;
    RegionPtr	pRegion, pNew;
    REQUEST (xXFixesSetRegionReq);

    REQUEST_AT_LEAST_SIZE(xXFixesSetRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
    
    things = (client->req_len << 2) - sizeof (xXFixesCreateRegionReq);
    if (things & 4)
	return BadLength;
    things >>= 3;

    pNew = RegionFromRects(things, (xRectangle *) (stuff + 1), CT_UNSORTED);
    if (!pNew)
	return BadAlloc;
    if (!RegionCopy(pRegion, pNew))
    {
	RegionDestroy(pNew);
	return BadAlloc;
    }
    RegionDestroy(pNew);
    return Success;
}

int
SProcXFixesSetRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesSetRegionReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXFixesSetRegionReq);
    swapl (&stuff->region, n);
    SwapRestS(stuff);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCopyRegion (ClientPtr client)
{
    RegionPtr	pSource, pDestination;
    REQUEST (xXFixesCopyRegionReq);
    
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
    
    if (!RegionCopy(pDestination, pSource))
	return BadAlloc;

    return Success;
}

int
SProcXFixesCopyRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCopyRegionReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXFixesCopyRegionReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCombineRegion (ClientPtr client)
{
    RegionPtr	pSource1, pSource2, pDestination;
    REQUEST (xXFixesCombineRegionReq);

    REQUEST_SIZE_MATCH (xXFixesCombineRegionReq);
    VERIFY_REGION(pSource1, stuff->source1, client, DixReadAccess);
    VERIFY_REGION(pSource2, stuff->source2, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
    
    switch (stuff->xfixesReqType) {
    case X_XFixesUnionRegion:
	if (!RegionUnion(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
    case X_XFixesIntersectRegion:
	if (!RegionIntersect(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
    case X_XFixesSubtractRegion:
	if (!RegionSubtract(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
    }
    
    return Success;
}

int
SProcXFixesCombineRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCombineRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCombineRegionReq);
    swapl (&stuff->source1, n);
    swapl (&stuff->source2, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesInvertRegion (ClientPtr client)
{
    RegionPtr	pSource, pDestination;
    BoxRec	bounds;
    REQUEST(xXFixesInvertRegionReq);

    REQUEST_SIZE_MATCH(xXFixesInvertRegionReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    /* Compute bounds, limit to 16 bits */
    bounds.x1 = stuff->x;
    bounds.y1 = stuff->y;
    if ((int) stuff->x + (int) stuff->width > MAXSHORT)
	bounds.x2 = MAXSHORT;
    else
	bounds.x2 = stuff->x + stuff->width;
    
    if ((int) stuff->y + (int) stuff->height > MAXSHORT)
	bounds.y2 = MAXSHORT;
    else
	bounds.y2 = stuff->y + stuff->height;

    if (!RegionInverse(pDestination, pSource, &bounds))
	return BadAlloc;

    return Success;
}

int
SProcXFixesInvertRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesInvertRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesInvertRegionReq);
    swapl (&stuff->source, n);
    swaps (&stuff->x, n);
    swaps (&stuff->y, n);
    swaps (&stuff->width, n);
    swaps (&stuff->height, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesTranslateRegion (ClientPtr client)
{
    RegionPtr	pRegion;
    REQUEST(xXFixesTranslateRegionReq);

    REQUEST_SIZE_MATCH(xXFixesTranslateRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);

    RegionTranslate(pRegion, stuff->dx, stuff->dy);
    return Success;
}

int
SProcXFixesTranslateRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesTranslateRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesTranslateRegionReq);
    swapl (&stuff->region, n);
    swaps (&stuff->dx, n);
    swaps (&stuff->dy, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesRegionExtents (ClientPtr client)
{
    RegionPtr	pSource, pDestination;
    REQUEST(xXFixesRegionExtentsReq);

    REQUEST_SIZE_MATCH(xXFixesRegionExtentsReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    RegionReset(pDestination, RegionExtents(pSource));

    return Success;
}

int
SProcXFixesRegionExtents (ClientPtr client)
{
    int n;
    REQUEST(xXFixesRegionExtentsReq);
    
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesRegionExtentsReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesFetchRegion (ClientPtr client)
{
    RegionPtr		    pRegion;
    xXFixesFetchRegionReply *reply;
    xRectangle		    *pRect;
    BoxPtr		    pExtent;
    BoxPtr		    pBox;
    int			    i, nBox;
    REQUEST(xXFixesFetchRegionReq);

    REQUEST_SIZE_MATCH(xXFixesFetchRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixReadAccess);

    pExtent = RegionExtents(pRegion);
    pBox = RegionRects (pRegion);
    nBox = RegionNumRects (pRegion);
    
    reply = malloc(sizeof (xXFixesFetchRegionReply) +
		    nBox * sizeof (xRectangle));
    if (!reply)
	return BadAlloc;
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = nBox << 1;
    reply->x = pExtent->x1;
    reply->y = pExtent->y1;
    reply->width = pExtent->x2 - pExtent->x1;
    reply->height = pExtent->y2 - pExtent->y1;

    pRect = (xRectangle *) (reply + 1);
    for (i = 0; i < nBox; i++)
    {
	pRect[i].x = pBox[i].x1;
	pRect[i].y = pBox[i].y1;
	pRect[i].width = pBox[i].x2 - pBox[i].x1;
	pRect[i].height = pBox[i].y2 - pBox[i].y1;
    }
    if (client->swapped)
    {
	int n;
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swaps (&reply->x, n);
	swaps (&reply->y, n);
	swaps (&reply->width, n);
	swaps (&reply->height, n);
	SwapShorts ((INT16 *) pRect, nBox * 4);
    }
    (void) WriteToClient(client, sizeof (xXFixesFetchRegionReply) +
			 nBox * sizeof (xRectangle), (char *) reply);
    free(reply);
    return Success;
}

int
SProcXFixesFetchRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesFetchRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesFetchRegionReq);
    swapl (&stuff->region, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetGCClipRegion (ClientPtr client)
{
    GCPtr	pGC;
    RegionPtr	pRegion;
    ChangeGCVal	vals[2];
    int		rc;
    REQUEST(xXFixesSetGCClipRegionReq);
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);

    rc = dixLookupGC(&pGC, stuff->gc, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    VERIFY_REGION_OR_NONE (pRegion, stuff->region, client, DixReadAccess);

    if (pRegion)
    {
	pRegion = XFixesRegionCopy (pRegion);
	if (!pRegion)
	    return BadAlloc;
    }
    
    vals[0].val = stuff->xOrigin;
    vals[1].val = stuff->yOrigin;
    ChangeGC (NullClient, pGC, GCClipXOrigin|GCClipYOrigin, vals);
    (*pGC->funcs->ChangeClip)(pGC, pRegion ? CT_REGION : CT_NONE, (pointer)pRegion, 0);

    return Success;
}

int
SProcXFixesSetGCClipRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesSetGCClipRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);
    swapl (&stuff->gc, n);
    swapl (&stuff->region, n);
    swaps (&stuff->xOrigin, n);
    swaps (&stuff->yOrigin, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

typedef	RegionPtr (*CreateDftPtr)(WindowPtr pWin);

int
ProcXFixesSetWindowShapeRegion (ClientPtr client)
{
    WindowPtr	    pWin;
    RegionPtr	    pRegion;
    RegionPtr	    *pDestRegion;
    int rc;
    REQUEST(xXFixesSetWindowShapeRegionReq);

    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->dest, RT_WINDOW,
			   client, DixSetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->dest;
	return rc;
    }
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixWriteAccess);
    switch (stuff->destKind) {
    case ShapeBounding:
    case ShapeClip:
    case ShapeInput:
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }
    if (pRegion)
    {
	pRegion = XFixesRegionCopy (pRegion);
	if (!pRegion)
	    return BadAlloc;
	if (!pWin->optional)
	    MakeWindowOptional (pWin);
	switch (stuff->destKind) {
	default:
	case ShapeBounding:
	    pDestRegion = &pWin->optional->boundingShape;
	    break;
	case ShapeClip:
	    pDestRegion = &pWin->optional->clipShape;
	    break;
	case ShapeInput:
	    pDestRegion = &pWin->optional->inputShape;
	    break;
	}
	if (stuff->xOff || stuff->yOff)
	    RegionTranslate(pRegion, stuff->xOff, stuff->yOff);
    }
    else
    {
	if (pWin->optional)
	{
	    switch (stuff->destKind) {
	    default:
	    case ShapeBounding:
		pDestRegion = &pWin->optional->boundingShape;
		break;
	    case ShapeClip:
		pDestRegion = &pWin->optional->clipShape;
		break;
	    case ShapeInput:
		pDestRegion = &pWin->optional->inputShape;
		break;
	    }
	}
	else
	    pDestRegion = &pRegion; /* a NULL region pointer */
    }
    if (*pDestRegion)
	RegionDestroy(*pDestRegion);
    *pDestRegion = pRegion;
    (*pWin->drawable.pScreen->SetShape) (pWin, stuff->destKind);
    SendShapeNotify (pWin, stuff->destKind);
    return Success;
}

int
SProcXFixesSetWindowShapeRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesSetWindowShapeRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->region, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetPictureClipRegion (ClientPtr client)
{
    PicturePtr		pPicture;
    RegionPtr		pRegion;
    REQUEST(xXFixesSetPictureClipRegionReq);
    
    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixReadAccess);
    
    return SetPictureClipRegion (pPicture, stuff->xOrigin, stuff->yOrigin,
				 pRegion);
}

int
SProcXFixesSetPictureClipRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesSetPictureClipRegionReq);
    
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);
    swapl (&stuff->picture, n);
    swapl (&stuff->region, n);
    swaps (&stuff->xOrigin, n);
    swaps (&stuff->yOrigin, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesExpandRegion (ClientPtr client)
{
    RegionPtr	pSource, pDestination;
    REQUEST (xXFixesExpandRegionReq);
    BoxPtr	pTmp;
    BoxPtr	pSrc;
    int		nBoxes;
    int		i;

    REQUEST_SIZE_MATCH (xXFixesExpandRegionReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
    
    nBoxes = RegionNumRects(pSource);
    pSrc = RegionRects(pSource);
    if (nBoxes)
    {
	pTmp = malloc(nBoxes * sizeof (BoxRec));
	if (!pTmp)
	    return BadAlloc;
	for (i = 0; i < nBoxes; i++)
	{
	    pTmp[i].x1 = pSrc[i].x1 - stuff->left;
	    pTmp[i].x2 = pSrc[i].x2 + stuff->right;
	    pTmp[i].y1 = pSrc[i].y1 - stuff->top;
	    pTmp[i].y2 = pSrc[i].y2 + stuff->bottom;
	}
	RegionEmpty(pDestination);
	for (i = 0; i < nBoxes; i++)
	{
	    RegionRec	r;
	    RegionInit(&r, &pTmp[i], 0);
	    RegionUnion(pDestination, pDestination, &r);
	}
	free(pTmp);
    }
    return Success;
}

int
SProcXFixesExpandRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesExpandRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesExpandRegionReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    swaps (&stuff->left, n);
    swaps (&stuff->right, n);
    swaps (&stuff->top, n);
    swaps (&stuff->bottom, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"

int
PanoramiXFixesSetGCClipRegion (ClientPtr client)
{
    REQUEST(xXFixesSetGCClipRegionReq);
    int		    result = Success, j;
    PanoramiXRes    *gc;
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);

    if ((result = dixLookupResourceByType((void **)&gc, stuff->gc, XRT_GC,
					  client, DixWriteAccess))) {
	client->errorValue = stuff->gc;
	return result;
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = gc->info[j].id;
        result = (*PanoramiXSaveXFixesVector[X_XFixesSetGCClipRegion]) (client);
        if(result != Success) break;
    }

    return result;
}

int
PanoramiXFixesSetWindowShapeRegion (ClientPtr client)
{
    int		    result = Success, j;
    PanoramiXRes    *win;
    REQUEST(xXFixesSetWindowShapeRegionReq);

    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);

    if ((result = dixLookupResourceByType((void **)&win, stuff->dest,
					  XRT_WINDOW, client,
					  DixWriteAccess))) {
	client->errorValue = stuff->dest;
	return result;
    }

    FOR_NSCREENS_FORWARD(j) {
	stuff->dest = win->info[j].id;
	result = (*PanoramiXSaveXFixesVector[X_XFixesSetWindowShapeRegion]) (client);
        if(result != Success) break;
    }

    return result;
}

int
PanoramiXFixesSetPictureClipRegion (ClientPtr client)
{
    REQUEST(xXFixesSetPictureClipRegionReq);
    int		    result = Success, j;
    PanoramiXRes    *pict;

    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);

    if ((result = dixLookupResourceByType((void **)&pict, stuff->picture,
					  XRT_PICTURE, client,
					  DixWriteAccess))) {
	client->errorValue = stuff->picture;
	return result;
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
	result = (*PanoramiXSaveXFixesVector[X_XFixesSetPictureClipRegion]) (client);
        if(result != Success) break;
    }

    return result;
}

#endif
/*
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"

int
ProcXFixesChangeSaveSet(ClientPtr client)
{
    Bool	toRoot, map;
    int		result;
    WindowPtr	pWin;
    REQUEST(xXFixesChangeSaveSetReq);
		  
    REQUEST_SIZE_MATCH(xXFixesChangeSaveSetReq);
    result = dixLookupWindow(&pWin, stuff->window, client, DixManageAccess);
    if (result != Success)
        return result;
    if (client->clientAsMask == (CLIENT_BITS(pWin->drawable.id)))
        return BadMatch;
    if ((stuff->mode != SetModeInsert) && (stuff->mode != SetModeDelete))
    {
	client->errorValue = stuff->mode;
	return BadValue;
    }
    if ((stuff->target != SaveSetNearest) && (stuff->target != SaveSetRoot))
    {
	client->errorValue = stuff->target;
	return BadValue;
    }
    if ((stuff->map != SaveSetMap) && (stuff->map != SaveSetUnmap))
    {
	client->errorValue = stuff->map;
	return BadValue;
    }
    toRoot = (stuff->target == SaveSetRoot);
    map = (stuff->map == SaveSetMap);
    return AlterSaveSetForClient(client, pWin, stuff->mode, toRoot, map);
}

int
SProcXFixesChangeSaveSet(ClientPtr client)
{
    register int n;
    REQUEST(xXFixesChangeSaveSetReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    return (*ProcXFixesVector[stuff->xfixesReqType])(client);
}
/*
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "xace.h"

static RESTYPE		SelectionClientType, SelectionWindowType;
static Bool		SelectionCallbackRegistered = FALSE;

/*
 * There is a global list of windows selecting for selection events
 * on every selection.  This should be plenty efficient for the
 * expected usage, if it does become a problem, it should be easily
 * replaced with a hash table of some kind keyed off the selection atom
 */

typedef struct _SelectionEvent *SelectionEventPtr;

typedef struct _SelectionEvent {
    SelectionEventPtr	next;
    Atom		selection;
    CARD32		eventMask;
    ClientPtr		pClient;
    WindowPtr		pWindow;
    XID			clientResource;
} SelectionEventRec;

static SelectionEventPtr	selectionEvents;

static void
XFixesSelectionCallback (CallbackListPtr *callbacks, pointer data, pointer args)
{
    SelectionEventPtr	e;
    SelectionInfoRec	*info = (SelectionInfoRec *) args;
    Selection		*selection = info->selection;
    int			subtype;
    CARD32		eventMask;
    
    switch (info->kind) {
    case SelectionSetOwner:
	subtype = XFixesSetSelectionOwnerNotify;
	eventMask = XFixesSetSelectionOwnerNotifyMask;
	break;
    case SelectionWindowDestroy:
	subtype = XFixesSelectionWindowDestroyNotify;
	eventMask = XFixesSelectionWindowDestroyNotifyMask;
	break;
    case SelectionClientClose:
	subtype = XFixesSelectionClientCloseNotify;
	eventMask = XFixesSelectionClientCloseNotifyMask;
	break;
    default:
	return;
    }
    for (e = selectionEvents; e; e = e->next)
    {
	if (e->selection == selection->selection && 
	    (e->eventMask & eventMask))
	{
	    xXFixesSelectionNotifyEvent	ev;

	    memset(&ev, 0, sizeof(xXFixesSelectionNotifyEvent));
	    ev.type = XFixesEventBase + XFixesSelectionNotify;
	    ev.subtype = subtype;
	    ev.window = e->pWindow->drawable.id;
	    if (subtype == XFixesSetSelectionOwnerNotify)
		ev.owner = selection->window;
	    else
		ev.owner = 0;
	    ev.selection = e->selection;
	    ev.timestamp = currentTime.milliseconds;
	    ev.selectionTimestamp = selection->lastTimeChanged.milliseconds;
	    WriteEventsToClient (e->pClient, 1, (xEvent *) &ev);
	}
    }
}

static Bool
CheckSelectionCallback (void)
{
    if (selectionEvents)
    {
	if (!SelectionCallbackRegistered)
	{
	    if (!AddCallback (&SelectionCallback, XFixesSelectionCallback, NULL))
		return FALSE;
	    SelectionCallbackRegistered = TRUE;
	}
    }
    else
    {
	if (SelectionCallbackRegistered)
	{
	    DeleteCallback (&SelectionCallback, XFixesSelectionCallback, NULL);
	    SelectionCallbackRegistered = FALSE;
	}
    }
    return TRUE;
}

#define SelectionAllEvents (XFixesSetSelectionOwnerNotifyMask |\
			    XFixesSelectionWindowDestroyNotifyMask |\
			    XFixesSelectionClientCloseNotifyMask)

static int
XFixesSelectSelectionInput (ClientPtr	pClient,
			    Atom	selection,
			    WindowPtr	pWindow,
			    CARD32	eventMask)
{
    pointer val;
    int rc;
    SelectionEventPtr	*prev, e;

    rc = XaceHook(XACE_SELECTION_ACCESS, pClient, selection, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    for (prev = &selectionEvents; (e = *prev); prev = &e->next)
    {
	if (e->selection == selection &&
	    e->pClient == pClient &&
	    e->pWindow == pWindow)
	{
	    break;
	}
    }
    if (!eventMask)
    {
	if (e)
	{
	    FreeResource (e->clientResource, 0);
	}
	return Success;
    }
    if (!e)
    {
	e = (SelectionEventPtr) malloc(sizeof (SelectionEventRec));
	if (!e)
	    return BadAlloc;

	e->next = 0;
	e->selection = selection;
	e->pClient = pClient;
	e->pWindow = pWindow;
	e->clientResource = FakeClientID(pClient->index);

	/*
	 * Add a resource hanging from the window to
	 * catch window destroy
	 */
	rc = dixLookupResourceByType (&val, pWindow->drawable.id,
				      SelectionWindowType, serverClient,
				      DixGetAttrAccess);
	if (rc != Success)
	    if (!AddResource (pWindow->drawable.id, SelectionWindowType,
			      (pointer) pWindow))
	    {
		free(e);
		return BadAlloc;
	    }

	if (!AddResource (e->clientResource, SelectionClientType, (pointer) e))
	    return BadAlloc;

	*prev = e;
	if (!CheckSelectionCallback ())
	{
	    FreeResource (e->clientResource, 0);
	    return BadAlloc;
	}
    }
    e->eventMask = eventMask;
    return Success;
}

int
ProcXFixesSelectSelectionInput (ClientPtr client)
{
    REQUEST (xXFixesSelectSelectionInputReq);
    WindowPtr	pWin;
    int		rc;

    REQUEST_SIZE_MATCH (xXFixesSelectSelectionInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->eventMask & ~SelectionAllEvents)
    {
	client->errorValue = stuff->eventMask;
	return BadValue;
    }
    return XFixesSelectSelectionInput (client, stuff->selection,
				       pWin, stuff->eventMask);
}

int
SProcXFixesSelectSelectionInput (ClientPtr client)
{
    register int n;
    REQUEST(xXFixesSelectSelectionInputReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    swapl(&stuff->selection, n);
    swapl(&stuff->eventMask, n);
    return (*ProcXFixesVector[stuff->xfixesReqType])(client);
}
    
void
SXFixesSelectionNotifyEvent (xXFixesSelectionNotifyEvent *from,
			     xXFixesSelectionNotifyEvent *to)
{
    to->type = from->type;
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->window, to->window);
    cpswapl (from->owner, to->owner);
    cpswapl (from->selection, to->selection);
    cpswapl (from->timestamp, to->timestamp);
    cpswapl (from->selectionTimestamp, to->selectionTimestamp);
}

static int
SelectionFreeClient (pointer data, XID id)
{
    SelectionEventPtr	old = (SelectionEventPtr) data;
    SelectionEventPtr	*prev, e;
    
    for (prev = &selectionEvents; (e = *prev); prev = &e->next)
    {
	if (e == old)
	{
	    *prev = e->next;
	    free(e);
	    CheckSelectionCallback ();
	    break;
	}
    }
    return 1;
}

static int
SelectionFreeWindow (pointer data, XID id)
{
    WindowPtr		pWindow = (WindowPtr) data;
    SelectionEventPtr	e, next;

    for (e = selectionEvents; e; e = next)
    {
	next = e->next;
	if (e->pWindow == pWindow)
	{
	    FreeResource (e->clientResource, 0);
	}
    }
    return 1;
}

Bool
XFixesSelectionInit (void)
{
    SelectionClientType = CreateNewResourceType(SelectionFreeClient,
						"XFixesSelectionClient");
    SelectionWindowType = CreateNewResourceType(SelectionFreeWindow,
						"XFixesSelectionWindow");
    return SelectionClientType && SelectionWindowType;
}
/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "protocol-versions.h"

static unsigned char	XFixesReqCode;
int		XFixesEventBase;
int		XFixesErrorBase;

static DevPrivateKeyRec XFixesClientPrivateKeyRec;
#define XFixesClientPrivateKey (&XFixesClientPrivateKeyRec)

static int
ProcXFixesQueryVersion(ClientPtr client)
{
    XFixesClientPtr pXFixesClient = GetXFixesClient (client);
    xXFixesQueryVersionReply rep;
    register int n;
    REQUEST(xXFixesQueryVersionReq);

    REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);
    memset(&rep, 0, sizeof(xXFixesQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (version_compare(stuff->majorVersion, stuff->minorVersion,
                        SERVER_XFIXES_MAJOR_VERSION, SERVER_XFIXES_MAJOR_VERSION) < 0)
    {
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else {
	rep.majorVersion = SERVER_XFIXES_MAJOR_VERSION;
        rep.minorVersion = SERVER_XFIXES_MINOR_VERSION;
    }

    pXFixesClient->major_version = rep.majorVersion;
    pXFixesClient->minor_version = rep.minorVersion;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xXFixesQueryVersionReply), (char *)&rep);
    return Success;
}

/* Major version controls available requests */
static const int version_requests[] = {
    X_XFixesQueryVersion,	    /* before client sends QueryVersion */
    X_XFixesGetCursorImage,	    /* Version 1 */
    X_XFixesChangeCursorByName,	    /* Version 2 */
    X_XFixesExpandRegion,	    /* Version 3 */
    X_XFixesShowCursor,		    /* Version 4 */
    X_XFixesDestroyPointerBarrier,  /* Version 5 */
};

#define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))
    
int	(*ProcXFixesVector[XFixesNumberRequests])(ClientPtr) = {
/*************** Version 1 ******************/
    ProcXFixesQueryVersion,
    ProcXFixesChangeSaveSet,
    ProcXFixesSelectSelectionInput,
    ProcXFixesSelectCursorInput,
    ProcXFixesGetCursorImage,
/*************** Version 2 ******************/
    ProcXFixesCreateRegion,
    ProcXFixesCreateRegionFromBitmap,
    ProcXFixesCreateRegionFromWindow,
    ProcXFixesCreateRegionFromGC,
    ProcXFixesCreateRegionFromPicture,
    ProcXFixesDestroyRegion,
    ProcXFixesSetRegion,
    ProcXFixesCopyRegion,
    ProcXFixesCombineRegion,
    ProcXFixesCombineRegion,
    ProcXFixesCombineRegion,
    ProcXFixesInvertRegion,
    ProcXFixesTranslateRegion,
    ProcXFixesRegionExtents,
    ProcXFixesFetchRegion,
    ProcXFixesSetGCClipRegion,
    ProcXFixesSetWindowShapeRegion,
    ProcXFixesSetPictureClipRegion,
    ProcXFixesSetCursorName,
    ProcXFixesGetCursorName,
    ProcXFixesGetCursorImageAndName,
    ProcXFixesChangeCursor,
    ProcXFixesChangeCursorByName,
/*************** Version 3 ******************/
    ProcXFixesExpandRegion,
/*************** Version 4 ****************/
    ProcXFixesHideCursor,
    ProcXFixesShowCursor,
/*************** Version 5 ****************/
    ProcXFixesCreatePointerBarrier,
    ProcXFixesDestroyPointerBarrier,
};

static int
ProcXFixesDispatch (ClientPtr client)
{
    REQUEST(xXFixesReq);
    XFixesClientPtr pXFixesClient = GetXFixesClient (client);

    if (pXFixesClient->major_version >= NUM_VERSION_REQUESTS)
	return BadRequest;
    if (stuff->xfixesReqType > version_requests[pXFixesClient->major_version])
	return BadRequest;
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int
SProcXFixesQueryVersion(ClientPtr client)
{
    register int n;
    REQUEST(xXFixesQueryVersionReq);

    swaps(&stuff->length, n);
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int (*SProcXFixesVector[XFixesNumberRequests])(ClientPtr) = {
/*************** Version 1 ******************/
    SProcXFixesQueryVersion,
    SProcXFixesChangeSaveSet,
    SProcXFixesSelectSelectionInput,
    SProcXFixesSelectCursorInput,
    SProcXFixesGetCursorImage,
/*************** Version 2 ******************/
    SProcXFixesCreateRegion,
    SProcXFixesCreateRegionFromBitmap,
    SProcXFixesCreateRegionFromWindow,
    SProcXFixesCreateRegionFromGC,
    SProcXFixesCreateRegionFromPicture,
    SProcXFixesDestroyRegion,
    SProcXFixesSetRegion,
    SProcXFixesCopyRegion,
    SProcXFixesCombineRegion,
    SProcXFixesCombineRegion,
    SProcXFixesCombineRegion,
    SProcXFixesInvertRegion,
    SProcXFixesTranslateRegion,
    SProcXFixesRegionExtents,
    SProcXFixesFetchRegion,
    SProcXFixesSetGCClipRegion,
    SProcXFixesSetWindowShapeRegion,
    SProcXFixesSetPictureClipRegion,
    SProcXFixesSetCursorName,
    SProcXFixesGetCursorName,
    SProcXFixesGetCursorImageAndName,
    SProcXFixesChangeCursor,
    SProcXFixesChangeCursorByName,
/*************** Version 3 ******************/
    SProcXFixesExpandRegion,
/*************** Version 4 ****************/
    SProcXFixesHideCursor,
    SProcXFixesShowCursor,
/*************** Version 5 ****************/
    SProcXFixesCreatePointerBarrier,
    SProcXFixesDestroyPointerBarrier,
};

static int
SProcXFixesDispatch (ClientPtr client)
{
    REQUEST(xXFixesReq);
    if (stuff->xfixesReqType >= XFixesNumberRequests)
	return BadRequest;
    return (*SProcXFixesVector[stuff->xfixesReqType]) (client);
}

static void
XFixesClientCallback (CallbackListPtr	*list,
		      pointer		closure,
		      pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    XFixesClientPtr	pXFixesClient = GetXFixesClient (pClient);

    pXFixesClient->major_version = 0;
    pXFixesClient->minor_version = 0;
}

/*ARGSUSED*/
static void
XFixesResetProc (ExtensionEntry *extEntry)
{
    DeleteCallback (&ClientStateCallback, XFixesClientCallback, 0);
}

void
XFixesExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!dixRegisterPrivateKey(&XFixesClientPrivateKeyRec, PRIVATE_CLIENT, sizeof (XFixesClientRec)))
	return;
    if (!AddCallback (&ClientStateCallback, XFixesClientCallback, 0))
	return;

    if (XFixesSelectionInit() && XFixesCursorInit () && XFixesRegionInit () &&
	(extEntry = AddExtension(XFIXES_NAME, XFixesNumberEvents, 
				 XFixesNumberErrors,
				 ProcXFixesDispatch, SProcXFixesDispatch,
				 XFixesResetProc, StandardMinorOpcode)) != 0)
    {
	XFixesReqCode = (unsigned char)extEntry->base;
	XFixesEventBase = extEntry->eventBase;
	XFixesErrorBase = extEntry->errorBase;
	EventSwapVector[XFixesEventBase + XFixesSelectionNotify] =
	    (EventSwapPtr) SXFixesSelectionNotifyEvent;
	EventSwapVector[XFixesEventBase + XFixesCursorNotify] =
	    (EventSwapPtr) SXFixesCursorNotifyEvent;
	SetResourceTypeErrorValue(RegionResType, XFixesErrorBase + BadRegion);
	SetResourceTypeErrorValue(PointerBarrierType,
				  XFixesErrorBase + BadBarrier);
    }
}

#ifdef PANORAMIX

int (*PanoramiXSaveXFixesVector[XFixesNumberRequests])(ClientPtr);

void
PanoramiXFixesInit (void)
{
    int i;

    for (i = 0; i < XFixesNumberRequests; i++)
	PanoramiXSaveXFixesVector[i] = ProcXFixesVector[i];
    /*
     * Stuff in Xinerama aware request processing hooks
     */
    ProcXFixesVector[X_XFixesSetGCClipRegion] = PanoramiXFixesSetGCClipRegion;
    ProcXFixesVector[X_XFixesSetWindowShapeRegion] = PanoramiXFixesSetWindowShapeRegion;
    ProcXFixesVector[X_XFixesSetPictureClipRegion] = PanoramiXFixesSetPictureClipRegion;
}

void
PanoramiXFixesReset (void)
{
    int i;

    for (i = 0; i < XFixesNumberRequests; i++)
	ProcXFixesVector[i] = PanoramiXSaveXFixesVector[i];
}

#endif
/*
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _XFIXES_H_
#define _XFIXES_H_

#include "resource.h"

extern _X_EXPORT RESTYPE RegionResType;
extern _X_EXPORT RESTYPE PointerBarrierType;
extern _X_EXPORT int XFixesErrorBase;

#define VERIFY_REGION(pRegion, rid, client, mode)			\
    do {								\
	int err;							\
	err = dixLookupResourceByType((pointer *) &pRegion, rid,	\
				      RegionResType, client, mode);	\
	if (err != Success) {						\
	    client->errorValue = rid;					\
	    return err;							\
	}								\
    } while (0)

#define VERIFY_REGION_OR_NONE(pRegion, rid, client, mode) { \
    pRegion = 0; \
    if (rid) VERIFY_REGION(pRegion, rid, client, mode); \
}

extern _X_EXPORT RegionPtr
XFixesRegionCopy (RegionPtr pRegion);

struct PointerBarrier {
    CARD16 x1, x2, y1, y2;
    CARD32 directions;
};


extern int
barrier_get_direction(int, int, int, int);
extern BOOL
barrier_is_blocking(const struct PointerBarrier*, int, int, int, int, double*);
extern BOOL
barrier_is_blocking_direction(const struct PointerBarrier*, int);
extern void
barrier_clamp_to_barrier(struct PointerBarrier *barrier, int dir, int *x, int *y);



#endif /* _XFIXES_H_ */
/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _XFIXESINT_H_
#define _XFIXESINT_H_

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include <X11/extensions/xfixesproto.h>
#include "windowstr.h"
#include "selection.h"
#include "xfixes.h"

extern int		XFixesEventBase;

typedef struct _XFixesClient {
    CARD32	major_version;
    CARD32	minor_version;
} XFixesClientRec, *XFixesClientPtr;

#define GetXFixesClient(pClient) ((XFixesClientPtr)dixLookupPrivate(&(pClient)->devPrivates, XFixesClientPrivateKey))

extern int	(*ProcXFixesVector[XFixesNumberRequests])(ClientPtr);

/* Initialize extension at server startup time */

void
XFixesExtensionInit(void);

/* Save set */
int
ProcXFixesChangeSaveSet(ClientPtr client);
    
int
SProcXFixesChangeSaveSet(ClientPtr client);
    
/* Selection events */
int
ProcXFixesSelectSelectionInput (ClientPtr client);

int
SProcXFixesSelectSelectionInput (ClientPtr client);

void
SXFixesSelectionNotifyEvent (xXFixesSelectionNotifyEvent *from,
			     xXFixesSelectionNotifyEvent *to);
Bool
XFixesSelectionInit (void);

/* Cursor notification */
Bool
XFixesCursorInit (void);
    
int
ProcXFixesSelectCursorInput (ClientPtr client);

int
SProcXFixesSelectCursorInput (ClientPtr client);

void
SXFixesCursorNotifyEvent (xXFixesCursorNotifyEvent *from,
			  xXFixesCursorNotifyEvent *to);

int
ProcXFixesGetCursorImage (ClientPtr client);

int
SProcXFixesGetCursorImage (ClientPtr client);

/* Cursor names (Version 2) */

int
ProcXFixesSetCursorName (ClientPtr client);

int
SProcXFixesSetCursorName (ClientPtr client);

int
ProcXFixesGetCursorName (ClientPtr client);

int
SProcXFixesGetCursorName (ClientPtr client);

int
ProcXFixesGetCursorImageAndName (ClientPtr client);

int
SProcXFixesGetCursorImageAndName (ClientPtr client);

/* Cursor replacement (Version 2) */

int
ProcXFixesChangeCursor (ClientPtr client);

int
SProcXFixesChangeCursor (ClientPtr client);

int
ProcXFixesChangeCursorByName (ClientPtr client);

int
SProcXFixesChangeCursorByName (ClientPtr client);

/* Region objects (Version 2* */
Bool
XFixesRegionInit (void);

int
ProcXFixesCreateRegion (ClientPtr client);

int
SProcXFixesCreateRegion (ClientPtr client);

int
ProcXFixesCreateRegionFromBitmap (ClientPtr client);

int
SProcXFixesCreateRegionFromBitmap (ClientPtr client);

int
ProcXFixesCreateRegionFromWindow (ClientPtr client);

int
SProcXFixesCreateRegionFromWindow (ClientPtr client);

int
ProcXFixesCreateRegionFromGC (ClientPtr client);

int
SProcXFixesCreateRegionFromGC (ClientPtr client);

int
ProcXFixesCreateRegionFromPicture (ClientPtr client);

int
SProcXFixesCreateRegionFromPicture (ClientPtr client);

int
ProcXFixesDestroyRegion (ClientPtr client);

int
SProcXFixesDestroyRegion (ClientPtr client);

int
ProcXFixesSetRegion (ClientPtr client);

int
SProcXFixesSetRegion (ClientPtr client);

int
ProcXFixesCopyRegion (ClientPtr client);

int
SProcXFixesCopyRegion (ClientPtr client);

int
ProcXFixesCombineRegion (ClientPtr client);

int
SProcXFixesCombineRegion (ClientPtr client);

int
ProcXFixesInvertRegion (ClientPtr client);

int
SProcXFixesInvertRegion (ClientPtr client);

int
ProcXFixesTranslateRegion (ClientPtr client);

int
SProcXFixesTranslateRegion (ClientPtr client);

int
ProcXFixesRegionExtents (ClientPtr client);

int
SProcXFixesRegionExtents (ClientPtr client);

int
ProcXFixesFetchRegion (ClientPtr client);

int
SProcXFixesFetchRegion (ClientPtr client);

int
ProcXFixesSetGCClipRegion (ClientPtr client);

int
SProcXFixesSetGCClipRegion (ClientPtr client);

int
ProcXFixesSetWindowShapeRegion (ClientPtr client);

int
SProcXFixesSetWindowShapeRegion (ClientPtr client);

int
ProcXFixesSetPictureClipRegion (ClientPtr client);

int
SProcXFixesSetPictureClipRegion (ClientPtr client);

int
ProcXFixesExpandRegion (ClientPtr client);

int
SProcXFixesExpandRegion (ClientPtr client);

int
PanoramiXFixesSetGCClipRegion (ClientPtr client);

int
PanoramiXFixesSetWindowShapeRegion (ClientPtr client);

int
PanoramiXFixesSetPictureClipRegion (ClientPtr client);

/* Cursor Visibility (Version 4) */

int 
ProcXFixesHideCursor (ClientPtr client);

int 
SProcXFixesHideCursor (ClientPtr client);

int 
ProcXFixesShowCursor (ClientPtr client);

int 
SProcXFixesShowCursor (ClientPtr client);

/* Version 5 */

int
ProcXFixesCreatePointerBarrier (ClientPtr client);

int
SProcXFixesCreatePointerBarrier (ClientPtr client);

int
ProcXFixesDestroyPointerBarrier (ClientPtr client);

int
SProcXFixesDestroyPointerBarrier (ClientPtr client);

/* Xinerama */
extern int (*PanoramiXSaveXFixesVector[XFixesNumberRequests])(ClientPtr);
void PanoramiXFixesInit (void);
void PanoramiXFixesReset (void);

#endif /* _XFIXESINT_H_ */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Function to allow frozen events to be routed from extension input devices.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>

#include "exglobals.h"

#include "allowev.h"
#include "dixevents.h"

/***********************************************************************
 *
 * This procedure allows frozen events to be routed.
 *
 */

int
SProcXAllowDeviceEvents(ClientPtr client)
{
    char n;

    REQUEST(xAllowDeviceEventsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xAllowDeviceEventsReq);
    swapl(&stuff->time, n);
    return (ProcXAllowDeviceEvents(client));
}

/***********************************************************************
 *
 * This procedure allows frozen events to be routed.
 *
 */

int
ProcXAllowDeviceEvents(ClientPtr client)
{
    TimeStamp time;
    DeviceIntPtr thisdev;
    int rc;

    REQUEST(xAllowDeviceEventsReq);
    REQUEST_SIZE_MATCH(xAllowDeviceEventsReq);

    rc = dixLookupDevice(&thisdev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    time = ClientTimeToServerTime(stuff->time);

    switch (stuff->mode) {
    case ReplayThisDevice:
	AllowSome(client, time, thisdev, NOT_GRABBED);
	break;
    case SyncThisDevice:
	AllowSome(client, time, thisdev, FREEZE_NEXT_EVENT);
	break;
    case AsyncThisDevice:
	AllowSome(client, time, thisdev, THAWED);
	break;
    case AsyncOtherDevices:
	AllowSome(client, time, thisdev, THAW_OTHERS);
	break;
    case SyncAll:
	AllowSome(client, time, thisdev, FREEZE_BOTH_NEXT_EVENT);
	break;
    case AsyncAll:
	AllowSome(client, time, thisdev, THAWED_BOTH);
	break;
    default:
	client->errorValue = stuff->mode;
	return BadValue;
    }
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef ALLOWEV_H
#define ALLOWEV_H 1

int SProcXAllowDeviceEvents(ClientPtr	/* client */
    );

int ProcXAllowDeviceEvents(ClientPtr	/* client */
    );

#endif /* ALLOWEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Change Device control attributes for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>	/* control constants */
#include "XIstubs.h"

#include "exglobals.h"
#include "exevents.h"

#include "chgdctl.h"

/***********************************************************************
 *
 * This procedure changes the control attributes for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXChangeDeviceControl(ClientPtr client)
{
    char n;
    xDeviceCtl *ctl;

    REQUEST(xChangeDeviceControlReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceControlReq);
    swaps(&stuff->control, n);
    ctl = (xDeviceCtl*)&stuff[1];
    swaps(&ctl->control, n);
    swaps(&ctl->length, n);
    switch(stuff->control) {
        case DEVICE_ABS_CALIB:
        case DEVICE_ABS_AREA:
        case DEVICE_CORE:
        case DEVICE_ENABLE:
        case DEVICE_RESOLUTION:
            /* hmm. beer. *drool* */
            break;

    }
    return (ProcXChangeDeviceControl(client));
}

/***********************************************************************
 *
 * Change the control attributes.
 *
 */

int
ProcXChangeDeviceControl(ClientPtr client)
{
    unsigned len;
    int i, status, ret = BadValue;
    DeviceIntPtr dev;
    xDeviceResolutionCtl *r;
    xChangeDeviceControlReply rep;
    AxisInfoPtr a;
    CARD32 *resolution;
    xDeviceEnableCtl *e;
    devicePresenceNotify dpn;

    REQUEST(xChangeDeviceControlReq);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceControlReq);

    len = stuff->length - bytes_to_int32(sizeof(xChangeDeviceControlReq));
    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (ret != Success)
        goto out;

    rep.repType = X_Reply;
    rep.RepType = X_ChangeDeviceControl;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    switch (stuff->control) {
    case DEVICE_RESOLUTION:
	r = (xDeviceResolutionCtl *) & stuff[1];
	if ((len < bytes_to_int32(sizeof(xDeviceResolutionCtl))) ||
	    (len != bytes_to_int32(sizeof(xDeviceResolutionCtl)) + r->num_valuators)) {
            ret = BadLength;
            goto out;
	}
	if (!dev->valuator) {
            ret = BadMatch;
            goto out;
	}
	if ((dev->deviceGrab.grab) && !SameClient(dev->deviceGrab.grab, client)) {
	    rep.status = AlreadyGrabbed;
            ret = Success;
            goto out;
	}
	resolution = (CARD32 *) (r + 1);
	if (r->first_valuator + r->num_valuators > dev->valuator->numAxes) {
            ret = BadValue;
            goto out;
	}
	status = ChangeDeviceControl(client, dev, (xDeviceCtl *) r);
	if (status == Success) {
	    a = &dev->valuator->axes[r->first_valuator];
	    for (i = 0; i < r->num_valuators; i++)
		if (*(resolution + i) < (a + i)->min_resolution ||
		    *(resolution + i) > (a + i)->max_resolution)
		    return BadValue;
	    for (i = 0; i < r->num_valuators; i++)
		(a++)->resolution = *resolution++;

            ret = Success;
	} else if (status == DeviceBusy) {
	    rep.status = DeviceBusy;
            ret = Success;
	} else {
            ret = BadMatch;
	}
	break;
    case DEVICE_ABS_CALIB:
    case DEVICE_ABS_AREA:
        /* Calibration is now done through properties, and never had any effect
         * on anything (in the open-source world). Thus, be honest. */
        ret = BadMatch;
        break;
    case DEVICE_CORE:
        /* Sorry, no device core switching no more. If you want a device to
         * send core events, attach it to a master device */
        ret = BadMatch;
        break;
    case DEVICE_ENABLE:
        e = (xDeviceEnableCtl *)&stuff[1];

        status = ChangeDeviceControl(client, dev, (xDeviceCtl *) e);

        if (status == Success) {
            if (e->enable)
                EnableDevice(dev, TRUE);
            else
                DisableDevice(dev, TRUE);
            ret = Success;
        } else if (status == DeviceBusy) {
            rep.status = DeviceBusy;
            ret = Success;
        } else {
            ret = BadMatch;
        }

        break;
    default:
        ret = BadValue;
    }

out:
    if (ret == Success) {
        dpn.type = DevicePresenceNotify;
        dpn.time = currentTime.milliseconds;
        dpn.devchange = DeviceControlChanged;
        dpn.deviceid = dev->id;
        dpn.control = stuff->control;
        SendEventToAllWindows(dev, DevicePresenceNotifyMask,
                              (xEvent *) &dpn, 1);

        WriteReplyToClient(client, sizeof(xChangeDeviceControlReply), &rep);
    }

    return ret;
}

/***********************************************************************
 *
 * This procedure writes the reply for the xChangeDeviceControl function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXChangeDeviceControl(ClientPtr client, int size,
			 xChangeDeviceControlReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGDCTL_H
#define CHGDCTL_H 1

int SProcXChangeDeviceControl(ClientPtr	/* client */
    );

int ProcXChangeDeviceControl(ClientPtr	/* client */
    );

void SRepXChangeDeviceControl(ClientPtr /* client */ ,
			      int /* size */ ,
			      xChangeDeviceControlReply *	/* rep */
    );

#endif /* CHGDCTL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Change feedback control attributes for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>	/* control constants */

#include "exglobals.h"

#include "chgfctl.h"

#define DO_ALL    (-1)

/***********************************************************************
 *
 * This procedure changes the control attributes for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXChangeFeedbackControl(ClientPtr client)
{
    char n;

    REQUEST(xChangeFeedbackControlReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xChangeFeedbackControlReq);
    swapl(&stuff->mask, n);
    return (ProcXChangeFeedbackControl(client));
}

/******************************************************************************
 *
 * This procedure changes KbdFeedbackClass data.
 *
 */

static int
ChangeKbdFeedback(ClientPtr client, DeviceIntPtr dev, long unsigned int mask,
		  KbdFeedbackPtr k, xKbdFeedbackCtl * f)
{
    char n;
    KeybdCtrl kctrl;
    int t;
    int key = DO_ALL;

    if (client->swapped) {
	swaps(&f->length, n);
	swaps(&f->pitch, n);
	swaps(&f->duration, n);
	swapl(&f->led_mask, n);
	swapl(&f->led_values, n);
    }

    kctrl = k->ctrl;
    if (mask & DvKeyClickPercent) {
	t = f->click;
	if (t == -1)
	    t = defaultKeyboardControl.click;
	else if (t < 0 || t > 100) {
	    client->errorValue = t;
	    return BadValue;
	}
	kctrl.click = t;
    }

    if (mask & DvPercent) {
	t = f->percent;
	if (t == -1)
	    t = defaultKeyboardControl.bell;
	else if (t < 0 || t > 100) {
	    client->errorValue = t;
	    return BadValue;
	}
	kctrl.bell = t;
    }

    if (mask & DvPitch) {
	t = f->pitch;
	if (t == -1)
	    t = defaultKeyboardControl.bell_pitch;
	else if (t < 0) {
	    client->errorValue = t;
	    return BadValue;
	}
	kctrl.bell_pitch = t;
    }

    if (mask & DvDuration) {
	t = f->duration;
	if (t == -1)
	    t = defaultKeyboardControl.bell_duration;
	else if (t < 0) {
	    client->errorValue = t;
	    return BadValue;
	}
	kctrl.bell_duration = t;
    }

    if (mask & DvLed) {
	kctrl.leds &= ~(f->led_mask);
	kctrl.leds |= (f->led_mask & f->led_values);
    }

    if (mask & DvKey) {
	key = (KeyCode) f->key;
	if (key < 8 || key > 255) {
	    client->errorValue = key;
	    return BadValue;
	}
	if (!(mask & DvAutoRepeatMode))
	    return BadMatch;
    }

    if (mask & DvAutoRepeatMode) {
	int inx = (key >> 3);
	int kmask = (1 << (key & 7));

	t = (CARD8) f->auto_repeat_mode;
	if (t == AutoRepeatModeOff) {
	    if (key == DO_ALL)
		kctrl.autoRepeat = FALSE;
	    else
		kctrl.autoRepeats[inx] &= ~kmask;
	} else if (t == AutoRepeatModeOn) {
	    if (key == DO_ALL)
		kctrl.autoRepeat = TRUE;
	    else
		kctrl.autoRepeats[inx] |= kmask;
	} else if (t == AutoRepeatModeDefault) {
	    if (key == DO_ALL)
		kctrl.autoRepeat = defaultKeyboardControl.autoRepeat;
	    else
		kctrl.autoRepeats[inx] &= ~kmask;
	    kctrl.autoRepeats[inx] =
		(kctrl.autoRepeats[inx] & ~kmask) |
		(defaultKeyboardControl.autoRepeats[inx] & kmask);
	} else {
	    client->errorValue = t;
	    return BadValue;
	}
    }

    k->ctrl = kctrl;
    (*k->CtrlProc) (dev, &k->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes PtrFeedbackClass data.
 *
 */

static int
ChangePtrFeedback(ClientPtr client, DeviceIntPtr dev, long unsigned int mask,
		  PtrFeedbackPtr p, xPtrFeedbackCtl * f)
{
    char n;
    PtrCtrl pctrl;	/* might get BadValue part way through */

    if (client->swapped) {
	swaps(&f->length, n);
	swaps(&f->num, n);
	swaps(&f->denom, n);
	swaps(&f->thresh, n);
    }

    pctrl = p->ctrl;
    if (mask & DvAccelNum) {
	int accelNum;

	accelNum = f->num;
	if (accelNum == -1)
	    pctrl.num = defaultPointerControl.num;
	else if (accelNum < 0) {
	    client->errorValue = accelNum;
	    return BadValue;
	} else
	    pctrl.num = accelNum;
    }

    if (mask & DvAccelDenom) {
	int accelDenom;

	accelDenom = f->denom;
	if (accelDenom == -1)
	    pctrl.den = defaultPointerControl.den;
	else if (accelDenom <= 0) {
	    client->errorValue = accelDenom;
	    return BadValue;
	} else
	    pctrl.den = accelDenom;
    }

    if (mask & DvThreshold) {
	int threshold;

	threshold = f->thresh;
	if (threshold == -1)
	    pctrl.threshold = defaultPointerControl.threshold;
	else if (threshold < 0) {
	    client->errorValue = threshold;
	    return BadValue;
	} else
	    pctrl.threshold = threshold;
    }

    p->ctrl = pctrl;
    (*p->CtrlProc) (dev, &p->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes IntegerFeedbackClass data.
 *
 */

static int
ChangeIntegerFeedback(ClientPtr client, DeviceIntPtr dev,
		      long unsigned int mask, IntegerFeedbackPtr i,
		      xIntegerFeedbackCtl * f)
{
    char n;

    if (client->swapped) {
	swaps(&f->length, n);
	swapl(&f->int_to_display, n);
    }

    i->ctrl.integer_displayed = f->int_to_display;
    (*i->CtrlProc) (dev, &i->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes StringFeedbackClass data.
 *
 */

static int
ChangeStringFeedback(ClientPtr client, DeviceIntPtr dev,
		     long unsigned int mask, StringFeedbackPtr s,
		     xStringFeedbackCtl * f)
{
    char n;
    int i, j;
    KeySym *syms, *sup_syms;

    syms = (KeySym *) (f + 1);
    if (client->swapped) {
	swaps(&f->length, n);	/* swapped num_keysyms in calling proc */
	SwapLongs((CARD32 *) syms, f->num_keysyms);
    }

    if (f->num_keysyms > s->ctrl.max_symbols)
	return BadValue;

    sup_syms = s->ctrl.symbols_supported;
    for (i = 0; i < f->num_keysyms; i++) {
	for (j = 0; j < s->ctrl.num_symbols_supported; j++)
	    if (*(syms + i) == *(sup_syms + j))
		break;
	if (j == s->ctrl.num_symbols_supported)
	    return BadMatch;
    }

    s->ctrl.num_symbols_displayed = f->num_keysyms;
    for (i = 0; i < f->num_keysyms; i++)
	*(s->ctrl.symbols_displayed + i) = *(syms + i);
    (*s->CtrlProc) (dev, &s->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes BellFeedbackClass data.
 *
 */

static int
ChangeBellFeedback(ClientPtr client, DeviceIntPtr dev,
		   long unsigned int mask, BellFeedbackPtr b,
		   xBellFeedbackCtl * f)
{
    char n;
    int t;
    BellCtrl bctrl;	/* might get BadValue part way through */

    if (client->swapped) {
	swaps(&f->length, n);
	swaps(&f->pitch, n);
	swaps(&f->duration, n);
    }

    bctrl = b->ctrl;
    if (mask & DvPercent) {
	t = f->percent;
	if (t == -1)
	    t = defaultKeyboardControl.bell;
	else if (t < 0 || t > 100) {
	    client->errorValue = t;
	    return BadValue;
	}
	bctrl.percent = t;
    }

    if (mask & DvPitch) {
	t = f->pitch;
	if (t == -1)
	    t = defaultKeyboardControl.bell_pitch;
	else if (t < 0) {
	    client->errorValue = t;
	    return BadValue;
	}
	bctrl.pitch = t;
    }

    if (mask & DvDuration) {
	t = f->duration;
	if (t == -1)
	    t = defaultKeyboardControl.bell_duration;
	else if (t < 0) {
	    client->errorValue = t;
	    return BadValue;
	}
	bctrl.duration = t;
    }
    b->ctrl = bctrl;
    (*b->CtrlProc) (dev, &b->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes LedFeedbackClass data.
 *
 */

static int
ChangeLedFeedback(ClientPtr client, DeviceIntPtr dev, long unsigned int mask,
		  LedFeedbackPtr l, xLedFeedbackCtl * f)
{
    char n;
    LedCtrl lctrl;	/* might get BadValue part way through */

    if (client->swapped) {
	swaps(&f->length, n);
	swapl(&f->led_values, n);
	swapl(&f->led_mask, n);
    }

    f->led_mask &= l->ctrl.led_mask;	/* set only supported leds */
    f->led_values &= l->ctrl.led_mask;	/* set only supported leds */
    if (mask & DvLed) {
	lctrl.led_mask = f->led_mask;
	lctrl.led_values = f->led_values;
	(*l->CtrlProc) (dev, &lctrl);
	l->ctrl.led_values &= ~(f->led_mask);	/* zero changed leds */
	l->ctrl.led_values |= (f->led_mask & f->led_values);	/* OR in set leds */
    }

    return Success;
}

/***********************************************************************
 *
 * Change the control attributes.
 *
 */

int
ProcXChangeFeedbackControl(ClientPtr client)
{
    unsigned len;
    DeviceIntPtr dev;
    KbdFeedbackPtr k;
    PtrFeedbackPtr p;
    IntegerFeedbackPtr i;
    StringFeedbackPtr s;
    BellFeedbackPtr b;
    LedFeedbackPtr l;
    int rc;

    REQUEST(xChangeFeedbackControlReq);
    REQUEST_AT_LEAST_SIZE(xChangeFeedbackControlReq);

    len = stuff->length - bytes_to_int32(sizeof(xChangeFeedbackControlReq));
    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (rc != Success)
	return rc;

    switch (stuff->feedbackid) {
    case KbdFeedbackClass:
	if (len != bytes_to_int32(sizeof(xKbdFeedbackCtl)))
	    return BadLength;

	for (k = dev->kbdfeed; k; k = k->next)
	    if (k->ctrl.id == ((xKbdFeedbackCtl *) & stuff[1])->id)
		return ChangeKbdFeedback(client, dev, stuff->mask, k,
					 (xKbdFeedbackCtl *) & stuff[1]);
	break;
    case PtrFeedbackClass:
	if (len != bytes_to_int32(sizeof(xPtrFeedbackCtl)))
	    return BadLength;

	for (p = dev->ptrfeed; p; p = p->next)
	    if (p->ctrl.id == ((xPtrFeedbackCtl *) & stuff[1])->id)
		return ChangePtrFeedback(client, dev, stuff->mask, p,
					 (xPtrFeedbackCtl *) & stuff[1]);
	break;
    case StringFeedbackClass:
    {
	char n;
	xStringFeedbackCtl *f = ((xStringFeedbackCtl *) & stuff[1]);

	if (client->swapped) {
	    swaps(&f->num_keysyms, n);
	}
	if (len != (bytes_to_int32(sizeof(xStringFeedbackCtl)) + f->num_keysyms))
	    return BadLength;

	for (s = dev->stringfeed; s; s = s->next)
	    if (s->ctrl.id == ((xStringFeedbackCtl *) & stuff[1])->id)
		return ChangeStringFeedback(client, dev, stuff->mask, s,
					    (xStringFeedbackCtl *) & stuff[1]);
	break;
    }
    case IntegerFeedbackClass:
	if (len != bytes_to_int32(sizeof(xIntegerFeedbackCtl)))
	    return BadLength;

	for (i = dev->intfeed; i; i = i->next)
	    if (i->ctrl.id == ((xIntegerFeedbackCtl *) & stuff[1])->id)
		return ChangeIntegerFeedback(client, dev, stuff->mask, i,
					     (xIntegerFeedbackCtl *)&stuff[1]);
	break;
    case LedFeedbackClass:
	if (len != bytes_to_int32(sizeof(xLedFeedbackCtl)))
	    return BadLength;

	for (l = dev->leds; l; l = l->next)
	    if (l->ctrl.id == ((xLedFeedbackCtl *) & stuff[1])->id)
		return ChangeLedFeedback(client, dev, stuff->mask, l,
					 (xLedFeedbackCtl *) & stuff[1]);
	break;
    case BellFeedbackClass:
	if (len != bytes_to_int32(sizeof(xBellFeedbackCtl)))
	    return BadLength;

	for (b = dev->bell; b; b = b->next)
	    if (b->ctrl.id == ((xBellFeedbackCtl *) & stuff[1])->id)
		return ChangeBellFeedback(client, dev, stuff->mask, b,
					  (xBellFeedbackCtl *) & stuff[1]);
	break;
    default:
	break;
    }

    return BadMatch;
}

/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGFCTL_H
#define CHGFCTL_H 1

int SProcXChangeFeedbackControl(ClientPtr	/* client */
    );

int ProcXChangeFeedbackControl(ClientPtr	/* client */
    );

#endif /* CHGFCTL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to change the keyboard device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "globals.h"

#include "exevents.h"
#include "exglobals.h"

#include "chgkbd.h"
#include "chgptr.h"

/***********************************************************************
 *
 * This procedure changes the keyboard device.
 *
 */

int
SProcXChangeKeyboardDevice(ClientPtr client)
{
    char n;

    REQUEST(xChangeKeyboardDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xChangeKeyboardDeviceReq);
    return (ProcXChangeKeyboardDevice(client));
}

/***********************************************************************
 *
 * This procedure is invoked to swap the request bytes if the server and
 * client have a different byte order.
 *
 */

int
ProcXChangeKeyboardDevice(ClientPtr client)
{
    /* REQUEST(xChangeKeyboardDeviceReq); */
    REQUEST_SIZE_MATCH(xChangeKeyboardDeviceReq);

    return BadDevice;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGKBD_H
#define CHGKBD_H 1

int SProcXChangeKeyboardDevice(ClientPtr	/* client */
    );

int ProcXChangeKeyboardDevice(ClientPtr	/* client */
    );

#endif /* CHGKBD_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Change key mapping for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "chgkmap.h"

/***********************************************************************
 *
 * This procedure swaps the request when the client and
 * server have different byte orderings.
 *
 */

int
SProcXChangeDeviceKeyMapping(ClientPtr client)
{
    char n;
    unsigned int count;

    REQUEST(xChangeDeviceKeyMappingReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceKeyMappingReq);
    count = stuff->keyCodes * stuff->keySymsPerKeyCode;
    REQUEST_FIXED_SIZE(xChangeDeviceKeyMappingReq, count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), count);
    return (ProcXChangeDeviceKeyMapping(client));
}

/***********************************************************************
 *
 * Change the device key mapping.
 *
 */

int
ProcXChangeDeviceKeyMapping(ClientPtr client)
{
    int ret;
    unsigned len;
    DeviceIntPtr dev;
    unsigned int count;

    REQUEST(xChangeDeviceKeyMappingReq);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceKeyMappingReq);

    count = stuff->keyCodes * stuff->keySymsPerKeyCode;
    REQUEST_FIXED_SIZE(xChangeDeviceKeyMappingReq, count * sizeof(CARD32));

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (ret != Success)
	return ret;
    len = stuff->length - bytes_to_int32(sizeof(xChangeDeviceKeyMappingReq));

    ret = ChangeKeyMapping(client, dev, len, DeviceMappingNotify,
			   stuff->firstKeyCode, stuff->keyCodes,
			   stuff->keySymsPerKeyCode, (KeySym *) & stuff[1]);

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGKMAP_H
#define CHGKMAP_H 1

int SProcXChangeDeviceKeyMapping(ClientPtr	/* client */
    );

int ProcXChangeDeviceKeyMapping(ClientPtr	/* client */
    );

#endif /* CHGKMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Function to modify the dont-propagate-list for an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>

#include "exevents.h"
#include "exglobals.h"

#include "chgprop.h"
#include "grabdev.h"

/***********************************************************************
 *
 * This procedure returns the extension version.
 *
 */

int
SProcXChangeDeviceDontPropagateList(ClientPtr client)
{
    char n;

    REQUEST(xChangeDeviceDontPropagateListReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceDontPropagateListReq);
    swapl(&stuff->window, n);
    swaps(&stuff->count, n);
    REQUEST_FIXED_SIZE(xChangeDeviceDontPropagateListReq,
                      stuff->count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), stuff->count);
    return (ProcXChangeDeviceDontPropagateList(client));
}

/***********************************************************************
 *
 * This procedure changes the dont-propagate list for the specified window.
 *
 */

int
ProcXChangeDeviceDontPropagateList(ClientPtr client)
{
    int i, rc;
    WindowPtr pWin;
    struct tmask tmp[EMASKSIZE];
    OtherInputMasks *others;

    REQUEST(xChangeDeviceDontPropagateListReq);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceDontPropagateListReq);

    if (stuff->length != bytes_to_int32(sizeof(xChangeDeviceDontPropagateListReq)) +
	stuff->count)
	return BadLength;

    rc = dixLookupWindow(&pWin, stuff->window, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if (stuff->mode != AddToList && stuff->mode != DeleteFromList) {
	client->errorValue = stuff->window;
	return BadMode;
    }

    if ((rc = CreateMaskFromList(client, (XEventClass *) & stuff[1],
				 stuff->count, tmp, NULL,
				 X_ChangeDeviceDontPropagateList)) != Success)
	return rc;

    others = wOtherInputMasks(pWin);
    if (!others && stuff->mode == DeleteFromList)
	return Success;
    for (i = 0; i < EMASKSIZE; i++) {
	if (tmp[i].mask == 0)
	    continue;

	if (stuff->mode == DeleteFromList)
	    tmp[i].mask = (others->dontPropagateMask[i] & ~tmp[i].mask);
	else if (others)
	    tmp[i].mask |= others->dontPropagateMask[i];

	if (DeviceEventSuppressForWindow(pWin, client, tmp[i].mask, i) !=
	    Success)
	    return BadClass;
    }

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGPROP_H
#define CHGPROP_H 1

int SProcXChangeDeviceDontPropagateList(ClientPtr	/* client */
    );

int ProcXChangeDeviceDontPropagateList(ClientPtr	/* client */
    );

#endif /* CHGPROP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to change the pointer device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */

#include "dixevents.h"
#include "exevents.h"
#include "exglobals.h"

#include "chgptr.h"

/***********************************************************************
 *
 * This procedure is invoked to swap the request bytes if the server and
 * client have a different byte order.
 *
 */

int
SProcXChangePointerDevice(ClientPtr client)
{
    char n;

    REQUEST(xChangePointerDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xChangePointerDeviceReq);
    return (ProcXChangePointerDevice(client));
}

/***********************************************************************
 *
 * This procedure changes the device used as the X pointer.
 *
 */

int
ProcXChangePointerDevice(ClientPtr client)
{
    /* REQUEST(xChangePointerDeviceReq); */
    REQUEST_SIZE_MATCH(xChangePointerDeviceReq);

    return BadDevice;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGPTR_H
#define CHGPTR_H 1

int SProcXChangePointerDevice(ClientPtr	/* client */
    );

int ProcXChangePointerDevice(ClientPtr	/* client */
    );

void DeleteFocusClassDeviceStruct(DeviceIntPtr	/* dev */
    );

void SendEventToAllWindows(DeviceIntPtr /* dev */ ,
			   Mask /* mask */ ,
			   xEvent * /* ev */ ,
			   int	/* count */
    );

#endif /* CHGPTR_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to close an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "exglobals.h"

#include "closedev.h"

/***********************************************************************
 *
 * This procedure closes an input device.
 *
 */

int
SProcXCloseDevice(ClientPtr client)
{
    char n;

    REQUEST(xCloseDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xCloseDeviceReq);
    return (ProcXCloseDevice(client));
}

/***********************************************************************
 *
 * Clear out event selections and passive grabs from a window for the
 * specified device.
 *
 */

static void
DeleteDeviceEvents(DeviceIntPtr dev, WindowPtr pWin, ClientPtr client)
{
    InputClientsPtr others;
    OtherInputMasks *pOthers;
    GrabPtr grab, next;

    if ((pOthers = wOtherInputMasks(pWin)) != 0)
	for (others = pOthers->inputClients; others; others = others->next)
	    if (SameClient(others, client))
		others->mask[dev->id] = NoEventMask;

    for (grab = wPassiveGrabs(pWin); grab; grab = next) {
	next = grab->next;
	if ((grab->device == dev) &&
	    (client->clientAsMask == CLIENT_BITS(grab->resource)))
	    FreeResource(grab->resource, RT_NONE);
    }
}

/***********************************************************************
 *
 * Walk througth the window tree, deleting event selections for this client
 * from this device from all windows.
 *
 */

static void
DeleteEventsFromChildren(DeviceIntPtr dev, WindowPtr p1, ClientPtr client)
{
    WindowPtr p2;

    while (p1) {
	p2 = p1->firstChild;
	DeleteDeviceEvents(dev, p1, client);
	DeleteEventsFromChildren(dev, p2, client);
	p1 = p1->nextSib;
    }
}

/***********************************************************************
 *
 * This procedure closes an input device.
 *
 */

int
ProcXCloseDevice(ClientPtr client)
{
    int rc, i;
    WindowPtr pWin, p1;
    DeviceIntPtr d;

    REQUEST(xCloseDeviceReq);
    REQUEST_SIZE_MATCH(xCloseDeviceReq);

    rc = dixLookupDevice(&d, stuff->deviceid, client, DixUseAccess);
    if (rc != Success)
	return rc;

    if (d->deviceGrab.grab && SameClient(d->deviceGrab.grab, client))
	(*d->deviceGrab.DeactivateGrab) (d);	/* release active grab */

    /* Remove event selections from all windows for events from this device
     * and selected by this client.
     * Delete passive grabs from all windows for this device.      */

    for (i = 0; i < screenInfo.numScreens; i++) {
	pWin = screenInfo.screens[i]->root;
	DeleteDeviceEvents(d, pWin, client);
	p1 = pWin->firstChild;
	DeleteEventsFromChildren(d, p1, client);
    }

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CLOSEDEV_H
#define CLOSEDEV_H 1

int SProcXCloseDevice(ClientPtr	/* client */
    );

int ProcXCloseDevice(ClientPtr	/* client */
    );

#endif /* CLOSEDEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to change the keyboard device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "devbell.h"

/***********************************************************************
 *
 * This procedure is invoked to swap the request bytes if the server and
 * client have a different byte order.
 *
 */

int
SProcXDeviceBell(ClientPtr client)
{
    char n;

    REQUEST(xDeviceBellReq);
    swaps(&stuff->length, n);
    return (ProcXDeviceBell(client));
}

/***********************************************************************
 *
 * This procedure rings a bell on an extension device.
 *
 */

int
ProcXDeviceBell(ClientPtr client)
{
    DeviceIntPtr dev;
    KbdFeedbackPtr k;
    BellFeedbackPtr b;
    int rc, base;
    int newpercent;
    CARD8 class;
    pointer ctrl;
    BellProcPtr proc;

    REQUEST(xDeviceBellReq);
    REQUEST_SIZE_MATCH(xDeviceBellReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixBellAccess);
    if (rc != Success) {
	client->errorValue = stuff->deviceid;
	return rc;
    }

    if (stuff->percent < -100 || stuff->percent > 100) {
	client->errorValue = stuff->percent;
	return BadValue;
    }
    if (stuff->feedbackclass == KbdFeedbackClass) {
	for (k = dev->kbdfeed; k; k = k->next)
	    if (k->ctrl.id == stuff->feedbackid)
		break;
	if (!k) {
	    client->errorValue = stuff->feedbackid;
	    return BadValue;
	}
	base = k->ctrl.bell;
	proc = k->BellProc;
	ctrl = (pointer) & (k->ctrl);
	class = KbdFeedbackClass;
    } else if (stuff->feedbackclass == BellFeedbackClass) {
	for (b = dev->bell; b; b = b->next)
	    if (b->ctrl.id == stuff->feedbackid)
		break;
	if (!b) {
	    client->errorValue = stuff->feedbackid;
	    return BadValue;
	}
	base = b->ctrl.percent;
	proc = b->BellProc;
	ctrl = (pointer) & (b->ctrl);
	class = BellFeedbackClass;
    } else {
	client->errorValue = stuff->feedbackclass;
	return BadValue;
    }
    newpercent = (base * stuff->percent) / 100;
    if (stuff->percent < 0)
	newpercent = base + newpercent;
    else
	newpercent = base - newpercent + stuff->percent;
    (*proc) (newpercent, dev, ctrl, class);

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef DEVBELL_H
#define DEVBELL_H 1

int SProcXDeviceBell(ClientPtr	/* client */
    );

int ProcXDeviceBell(ClientPtr	/* client */
    );

#endif /* DEVBELL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Routines to register and initialize extension input devices.
 *  This also contains ProcessOtherEvent, the routine called from DDX
 *  to route extension events.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/geproto.h>
#include "windowstr.h"
#include "miscstruct.h"
#include "region.h"
#include "exevents.h"
#include "extnsionst.h"
#include "exglobals.h"
#include "dixevents.h"	/* DeliverFocusedEvent */
#include "dixgrabs.h"	/* CreateGrab() */
#include "scrnintstr.h"
#include "listdev.h" /* for CopySwapXXXClass */
#include "xace.h"
#include "xiquerydevice.h" /* For List*Info */
#include "eventconvert.h"
#include "eventstr.h"
#include "inpututils.h"

#include <X11/extensions/XKBproto.h>
#include "xkbsrv.h"

#define WID(w) ((w) ? ((w)->drawable.id) : 0)
#define AllModifiersMask ( \
	ShiftMask | LockMask | ControlMask | Mod1Mask | Mod2Mask | \
	Mod3Mask | Mod4Mask | Mod5Mask )
#define AllButtonsMask ( \
	Button1Mask | Button2Mask | Button3Mask | Button4Mask | Button5Mask )

Bool ShouldFreeInputMasks(WindowPtr /* pWin */ ,
				 Bool	/* ignoreSelectedEvents */
    );
static Bool MakeInputMasks(WindowPtr	/* pWin */
    );

/*
 * Only let the given client know of core events which will affect its
 * interpretation of input events, if the client's ClientPointer (or the
 * paired keyboard) is the current device.
 */
int
XIShouldNotify(ClientPtr client, DeviceIntPtr dev)
{
    DeviceIntPtr current_ptr = PickPointer(client);
    DeviceIntPtr current_kbd = GetPairedDevice(current_ptr);

    if (dev == current_kbd || dev == current_ptr)
        return 1;

    return 0;
}

Bool
IsPointerEvent(InternalEvent* event)
{
    switch(event->any.type)
    {
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_Motion:
            /* XXX: enter/leave ?? */
            return TRUE;
        default:
            break;
    }
    return FALSE;
}

/**
 * @return the device matching the deviceid of the device set in the event, or
 * NULL if the event is not an XInput event.
 */
DeviceIntPtr
XIGetDevice(xEvent* xE)
{
    DeviceIntPtr pDev = NULL;

    if (xE->u.u.type == DeviceButtonPress ||
        xE->u.u.type == DeviceButtonRelease ||
        xE->u.u.type == DeviceMotionNotify ||
        xE->u.u.type == ProximityIn ||
        xE->u.u.type == ProximityOut ||
        xE->u.u.type == DevicePropertyNotify)
    {
        int rc;
        int id;

        id = ((deviceKeyButtonPointer*)xE)->deviceid & ~MORE_EVENTS;

        rc = dixLookupDevice(&pDev, id, serverClient, DixUnknownAccess);
        if (rc != Success)
            ErrorF("[dix] XIGetDevice failed on XACE restrictions (%d)\n", rc);
    }
    return pDev;
}


/**
 * Copy the device->key into master->key and send a mapping notify to the
 * clients if appropriate.
 * master->key needs to be allocated by the caller.
 *
 * Device is the slave device. If it is attached to a master device, we may
 * need to send a mapping notify to the client because it causes the MD
 * to change state.
 *
 * Mapping notify needs to be sent in the following cases:
 *      - different slave device on same master
 *      - different master
 *
 * XXX: They way how the code is we also send a map notify if the slave device
 * stays the same, but the master changes. This isn't really necessary though.
 *
 * XXX: this gives you funny behaviour with the ClientPointer. When a
 * MappingNotify is sent to the client, the client usually responds with a
 * GetKeyboardMapping. This will retrieve the ClientPointer's keyboard
 * mapping, regardless of which keyboard sent the last mapping notify request.
 * So depending on the CP setting, your keyboard may change layout in each
 * app...
 *
 * This code is basically the old SwitchCoreKeyboard.
 */

void
CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master)
{
    KeyClassPtr mk = master->key;

    if (device == master)
        return;

    mk->sourceid = device->id;


    if (!XkbCopyDeviceKeymap(master, device))
        FatalError("Couldn't pivot keymap from device to core!\n");
}

/**
 * Copies the feedback classes from device "from" into device "to". Classes
 * are duplicated (not just flipping the pointers). All feedback classes are
 * linked lists, the full list is duplicated.
 */
static void
DeepCopyFeedbackClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;


    if (from->intfeed)
    {
        IntegerFeedbackPtr *i, it;

        if (!to->intfeed)
        {
            classes = to->unused_classes;
            to->intfeed = classes->intfeed;
            classes->intfeed = NULL;
        }

        i = &to->intfeed;
        for (it = from->intfeed; it; it = it->next)
        {
            if (!(*i))
            {
                *i = calloc(1, sizeof(IntegerFeedbackClassRec));
                if (!(*i))
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*i)->CtrlProc = it->CtrlProc;
            (*i)->ctrl     = it->ctrl;

            i = &(*i)->next;
        }
    } else if (to->intfeed && !from->intfeed)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->intfeed = to->intfeed;
        to->intfeed      = NULL;
    }

    if (from->stringfeed)
    {
        StringFeedbackPtr *s, it;

        if (!to->stringfeed)
        {
            classes = to->unused_classes;
            to->stringfeed = classes->stringfeed;
            classes->stringfeed = NULL;
        }

        s = &to->stringfeed;
        for (it = from->stringfeed; it; it = it->next)
        {
            if (!(*s))
            {
                *s = calloc(1, sizeof(StringFeedbackClassRec));
                if (!(*s))
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*s)->CtrlProc = it->CtrlProc;
            (*s)->ctrl     = it->ctrl;

            s = &(*s)->next;
        }
    } else if (to->stringfeed && !from->stringfeed)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->stringfeed = to->stringfeed;
        to->stringfeed      = NULL;
    }

    if (from->bell)
    {
        BellFeedbackPtr *b, it;

        if (!to->bell)
        {
            classes = to->unused_classes;
            to->bell = classes->bell;
            classes->bell = NULL;
        }

        b = &to->bell;
        for (it = from->bell; it; it = it->next)
        {
            if (!(*b))
            {
                *b = calloc(1, sizeof(BellFeedbackClassRec));
                if (!(*b))
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*b)->BellProc = it->BellProc;
            (*b)->CtrlProc = it->CtrlProc;
            (*b)->ctrl     = it->ctrl;

            b = &(*b)->next;
        }
    } else if (to->bell && !from->bell)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->bell = to->bell;
        to->bell      = NULL;
    }

    if (from->leds)
    {
        LedFeedbackPtr *l, it;

        if (!to->leds)
        {
            classes = to->unused_classes;
            to->leds = classes->leds;
            classes->leds = NULL;
        }

        l = &to->leds;
        for (it = from->leds; it; it = it->next)
        {
            if (!(*l))
            {
                *l = calloc(1, sizeof(LedFeedbackClassRec));
                if (!(*l))
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*l)->CtrlProc = it->CtrlProc;
            (*l)->ctrl     = it->ctrl;
            if ((*l)->xkb_sli)
                XkbFreeSrvLedInfo((*l)->xkb_sli);
            (*l)->xkb_sli = XkbCopySrvLedInfo(from, it->xkb_sli, NULL, *l);

            l = &(*l)->next;
        }
    } else if (to->leds && !from->leds)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->leds = to->leds;
        to->leds      = NULL;
    }
}

static void
DeepCopyKeyboardClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;

    /* XkbInitDevice (->XkbInitIndicatorMap->XkbFindSrvLedInfo) relies on the
     * kbdfeed to be set up properly, so let's do the feedback classes first.
     */
    if (from->kbdfeed)
    {
        KbdFeedbackPtr *k, it;

        if (!to->kbdfeed)
        {
            classes = to->unused_classes;

            to->kbdfeed = classes->kbdfeed;
            if (!to->kbdfeed)
                InitKeyboardDeviceStruct(to, NULL, NULL, NULL);
            classes->kbdfeed = NULL;
        }

        k = &to->kbdfeed;
        for(it = from->kbdfeed; it; it = it->next)
        {
            if (!(*k))
            {
                *k = calloc(1, sizeof(KbdFeedbackClassRec));
                if (!*k)
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*k)->BellProc = it->BellProc;
            (*k)->CtrlProc = it->CtrlProc;
            (*k)->ctrl     = it->ctrl;
            if ((*k)->xkb_sli)
                XkbFreeSrvLedInfo((*k)->xkb_sli);
            (*k)->xkb_sli = XkbCopySrvLedInfo(from, it->xkb_sli, *k, NULL);

            k = &(*k)->next;
        }
    } else if (to->kbdfeed && !from->kbdfeed)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->kbdfeed = to->kbdfeed;
        to->kbdfeed      = NULL;
    }

    if (from->key)
    {
        if (!to->key)
        {
            classes = to->unused_classes;
            to->key = classes->key;
            if (!to->key)
                InitKeyboardDeviceStruct(to, NULL, NULL, NULL);
            else
                classes->key = NULL;
        }

        CopyKeyClass(from, to);
    } else if (to->key && !from->key)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->key = to->key;
        to->key      = NULL;
    }

    /* If a SrvLedInfoPtr's flags are XkbSLI_IsDefault, the names and maps
     * pointer point into the xkbInfo->desc struct.  XkbCopySrvLedInfo
     * didn't update the pointers so we need to do it manually here.
     */
    if (to->kbdfeed)
    {
        KbdFeedbackPtr k;

        for (k = to->kbdfeed; k; k = k->next)
        {
            if (!k->xkb_sli)
                continue;
            if (k->xkb_sli->flags & XkbSLI_IsDefault)
            {
                k->xkb_sli->names = to->key->xkbInfo->desc->names->indicators;
                k->xkb_sli->maps = to->key->xkbInfo->desc->indicators->maps;
            }
        }
    }

    /* We can't just copy over the focus class. When an app sets the focus,
     * it'll do so on the master device. Copying the SDs focus means losing
     * the focus.
     * So we only copy the focus class if the device didn't have one,
     * otherwise we leave it as it is.
     */
    if (from->focus)
    {
        if (!to->focus)
        {
            WindowPtr *oldTrace;

            classes = to->unused_classes;
            to->focus = classes->focus;
            if (!to->focus)
            {
                to->focus = calloc(1, sizeof(FocusClassRec));
                if (!to->focus)
                    FatalError("[Xi] no memory for class shift.\n");
            } else
                classes->focus = NULL;

            oldTrace = to->focus->trace;
            memcpy(to->focus, from->focus, sizeof(FocusClassRec));
            to->focus->trace = realloc(oldTrace,
                                  to->focus->traceSize * sizeof(WindowPtr));
            if (!to->focus->trace && to->focus->traceSize)
                FatalError("[Xi] no memory for trace.\n");
            memcpy(to->focus->trace, from->focus->trace,
                    from->focus->traceSize * sizeof(WindowPtr));
            to->focus->sourceid = from->id;
        }
    } else if (to->focus)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->focus = to->focus;
        to->focus      = NULL;
    }

}

static void
DeepCopyPointerClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;

    /* Feedback classes must be copied first */
    if (from->ptrfeed)
    {
        PtrFeedbackPtr *p, it;
        if (!to->ptrfeed)
        {
            classes = to->unused_classes;
            to->ptrfeed = classes->ptrfeed;
            classes->ptrfeed = NULL;
        }

        p = &to->ptrfeed;
        for (it = from->ptrfeed; it; it = it->next)
        {
            if (!(*p))
            {
                *p = calloc(1, sizeof(PtrFeedbackClassRec));
                if (!*p)
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*p)->CtrlProc = it->CtrlProc;
            (*p)->ctrl     = it->ctrl;

            p = &(*p)->next;
        }
    } else if (to->ptrfeed && !from->ptrfeed)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->ptrfeed = to->ptrfeed;
        to->ptrfeed      = NULL;
    }

    if (from->valuator)
    {
        ValuatorClassPtr v;

        if (!to->valuator)
        {
            classes = to->unused_classes;
            to->valuator = classes->valuator;
            if (to->valuator)
                classes->valuator = NULL;
        }

        v = AllocValuatorClass(to->valuator, from->valuator->numAxes);

        if (!v)
            FatalError("[Xi] no memory for class shift.\n");

        to->valuator = v;
        memcpy(v->axes, from->valuator->axes, v->numAxes * sizeof(AxisInfo));

        v->sourceid = from->id;
    } else if (to->valuator && !from->valuator)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->valuator = to->valuator;
        to->valuator      = NULL;
    }

    if (from->button)
    {
        if (!to->button)
        {
            classes = to->unused_classes;
            to->button = classes->button;
            if (!to->button)
            {
                to->button = calloc(1, sizeof(ButtonClassRec));
                if (!to->button)
                    FatalError("[Xi] no memory for class shift.\n");
            } else
                classes->button = NULL;
        }

        if (from->button->xkb_acts)
        {
            if (!to->button->xkb_acts)
            {
                to->button->xkb_acts = calloc(1, sizeof(XkbAction));
                if (!to->button->xkb_acts)
                    FatalError("[Xi] not enough memory for xkb_acts.\n");
            }
            memcpy(to->button->xkb_acts, from->button->xkb_acts,
                    sizeof(XkbAction));
        } else
            free(to->button->xkb_acts);

         memcpy(to->button->labels, from->button->labels,
                from->button->numButtons * sizeof(Atom));
        to->button->sourceid = from->id;
    } else if (to->button && !from->button)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->button = to->button;
        to->button      = NULL;
    }

    if (from->proximity)
    {
        if (!to->proximity)
        {
            classes = to->unused_classes;
            to->proximity = classes->proximity;
            if (!to->proximity)
            {
                to->proximity = calloc(1, sizeof(ProximityClassRec));
                if (!to->proximity)
                    FatalError("[Xi] no memory for class shift.\n");
            } else
                classes->proximity = NULL;
        }
        memcpy(to->proximity, from->proximity, sizeof(ProximityClassRec));
        to->proximity->sourceid = from->id;
    } else if (to->proximity)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->proximity = to->proximity;
        to->proximity      = NULL;
    }
}

/**
 * Copies the CONTENT of the classes of device from into the classes in device
 * to. From and to are identical after finishing.
 *
 * If to does not have classes from currenly has, the classes are stored in
 * to's devPrivates system. Later, we recover it again from there if needed.
 * Saves a few memory allocations.
 */
void
DeepCopyDeviceClasses(DeviceIntPtr from, DeviceIntPtr to, DeviceChangedEvent *dce)
{
    /* generic feedback classes, not tied to pointer and/or keyboard */
    DeepCopyFeedbackClasses(from, to);

    if ((dce->flags & DEVCHANGE_KEYBOARD_EVENT))
        DeepCopyKeyboardClasses(from, to);
    if ((dce->flags & DEVCHANGE_POINTER_EVENT))
        DeepCopyPointerClasses(from, to);
}


/**
 * Send an XI2 DeviceChangedEvent to all interested clients.
 */
void
XISendDeviceChangedEvent(DeviceIntPtr device, DeviceIntPtr master, DeviceChangedEvent *dce)
{
    xXIDeviceChangedEvent *dcce;
    int rc;

    rc = EventToXI2((InternalEvent*)dce, (xEvent**)&dcce);
    if (rc != Success)
    {
        ErrorF("[Xi] event conversion from DCE failed with code %d\n", rc);
        return;
    }

    /* we don't actually swap if there's a NullClient, swapping is done
     * later when event is delivered. */
    SendEventToAllWindows(master, XI_DeviceChangedMask, (xEvent*)dcce, 1);
    free(dcce);
}

static void
ChangeMasterDeviceClasses(DeviceIntPtr device, DeviceChangedEvent *dce)
{
    DeviceIntPtr slave;
    int rc;

    /* For now, we don't have devices that change physically. */
    if (!IsMaster(device))
        return;

    rc = dixLookupDevice(&slave, dce->sourceid, serverClient, DixReadAccess);

    if (rc != Success)
        return; /* Device has disappeared */

    if (IsMaster(slave))
        return;

    if (IsFloating(slave))
        return; /* set floating since the event */

    if (GetMaster(slave, MASTER_ATTACHED)->id != dce->masterid)
        return; /* not our slave anymore, don't care */

    /* FIXME: we probably need to send a DCE for the new slave now */

    device->public.devicePrivate = slave->public.devicePrivate;

    /* FIXME: the classes may have changed since we generated the event. */
    DeepCopyDeviceClasses(slave, device, dce);
    XISendDeviceChangedEvent(slave, device, dce);
}

/**
 * Update the device state according to the data in the event.
 *
 * return values are
 *   DEFAULT ... process as normal
 *   DONT_PROCESS ... return immediately from caller
 */
#define DEFAULT 0
#define DONT_PROCESS 1
int
UpdateDeviceState(DeviceIntPtr device, DeviceEvent* event)
{
    int i;
    int key = 0,
        bit = 0,
        last_valuator;

    KeyClassPtr k       = NULL;
    ButtonClassPtr b    = NULL;
    ValuatorClassPtr v  = NULL;

    /* This event is always the first we get, before the actual events with
     * the data. However, the way how the DDX is set up, "device" will
     * actually be the slave device that caused the event.
     */
    switch(event->type)
    {
        case ET_DeviceChanged:
            ChangeMasterDeviceClasses(device, (DeviceChangedEvent*)event);
            return DONT_PROCESS; /* event has been sent already */
        case ET_Motion:
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ProximityIn:
        case ET_ProximityOut:
            break;
        default:
            /* other events don't update the device */
            return DEFAULT;
    }

    k = device->key;
    v = device->valuator;
    b = device->button;

    key = event->detail.key;
    bit = 1 << (key & 7);

    /* Update device axis */
    /* Check valuators first */
    last_valuator = -1;
    for (i = 0; i < MAX_VALUATORS; i++)
    {
        if (BitIsOn(&event->valuators.mask, i))
        {
            if (!v)
            {
                ErrorF("[Xi] Valuators reported for non-valuator device '%s'. "
                        "Ignoring event.\n", device->name);
                return DONT_PROCESS;
            } else if (v->numAxes < i)
            {
                ErrorF("[Xi] Too many valuators reported for device '%s'. "
                        "Ignoring event.\n", device->name);
                return DONT_PROCESS;
            }
            last_valuator = i;
        }
    }

    for (i = 0; i <= last_valuator && i < v->numAxes; i++)
    {
        if (BitIsOn(&event->valuators.mask, i))
        {
            /* XXX: Relative/Absolute mode */
            v->axisVal[i] = event->valuators.data[i];
            v->axisVal[i] += (event->valuators.data_frac[i] * 1.0f / (1 << 16) / (1 << 16));
        }
    }

    if (event->type == ET_KeyPress) {
        if (!k)
            return DONT_PROCESS;

	/* don't allow ddx to generate multiple downs, but repeats are okay */
	if (key_is_down(device, key, KEY_PROCESSED) && !event->key_repeat)
	    return DONT_PROCESS;

	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
	set_key_down(device, key, KEY_PROCESSED);
    } else if (event->type == ET_KeyRelease) {
        if (!k)
            return DONT_PROCESS;

	if (!key_is_down(device, key, KEY_PROCESSED))	/* guard against duplicates */
	    return DONT_PROCESS;
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
	set_key_up(device, key, KEY_PROCESSED);
    } else if (event->type == ET_ButtonPress) {
        Mask mask;
        if (!b)
            return DONT_PROCESS;

        if (button_is_down(device, key, BUTTON_PROCESSED))
            return DONT_PROCESS;

        set_button_down(device, key, BUTTON_PROCESSED);
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
        if (!b->map[key])
            return DONT_PROCESS;
        b->buttonsDown++;
	b->motionMask = DeviceButtonMotionMask;
        if (b->map[key] <= 5)
	    b->state |= (Button1Mask >> 1) << b->map[key];

        /* Add state and motionMask to the filter for this event */
        mask = DevicePointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, DeviceMotionNotify);
        mask = PointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, MotionNotify);
    } else if (event->type == ET_ButtonRelease) {
        Mask mask;
        if (!b)
            return DONT_PROCESS;

        if (!button_is_down(device, key, BUTTON_PROCESSED))
            return DONT_PROCESS;
        if (IsMaster(device)) {
            DeviceIntPtr sd;

            /*
             * Leave the button down if any slave has the
             * button still down. Note that this depends on the
             * event being delivered through the slave first
             */
            for (sd = inputInfo.devices; sd; sd = sd->next) {
                if (IsMaster(sd) || GetMaster(sd, MASTER_POINTER) != device)
                    continue;
                if (!sd->button)
                    continue;
                for (i = 1; i <= sd->button->numButtons; i++)
                    if (sd->button->map[i] == key &&
                        button_is_down(sd, i, BUTTON_PROCESSED))
                        return DONT_PROCESS;
            }
        }
        set_button_up(device, key, BUTTON_PROCESSED);
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
        if (!b->map[key])
            return DONT_PROCESS;
        if (b->buttonsDown >= 1 && !--b->buttonsDown)
	    b->motionMask = 0;
	if (b->map[key] <= 5)
	    b->state &= ~((Button1Mask >> 1) << b->map[key]);

        /* Add state and motionMask to the filter for this event */
        mask = DevicePointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, DeviceMotionNotify);
        mask = PointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, MotionNotify);
    } else if (event->type == ET_ProximityIn)
	device->proximity->in_proximity = TRUE;
    else if (event->type == ET_ProximityOut)
	device->proximity->in_proximity = FALSE;

    return DEFAULT;
}

/**
 * Main device event processing function.
 * Called from when processing the events from the event queue.
 *
 */
void
ProcessOtherEvent(InternalEvent *ev, DeviceIntPtr device)
{
    GrabPtr grab;
    Bool deactivateDeviceGrab = FALSE;
    int key = 0, rootX, rootY;
    ButtonClassPtr b;
    KeyClassPtr k;
    ValuatorClassPtr v;
    int ret = 0;
    int state, i;
    DeviceIntPtr mouse = NULL, kbd = NULL;
    DeviceEvent *event = &ev->device_event;

    verify_internal_event(ev);

    if (ev->any.type == ET_RawKeyPress ||
        ev->any.type == ET_RawKeyRelease ||
        ev->any.type == ET_RawButtonPress ||
        ev->any.type == ET_RawButtonRelease ||
        ev->any.type == ET_RawMotion)
    {
        DeliverRawEvent(&ev->raw_event, device);
        return;
    }

    if (IsPointerDevice(device))
    {
        kbd = GetPairedDevice(device);
        mouse = device;
        if (!kbd->key) /* can happen with floating SDs */
            kbd = NULL;
    } else
    {
        mouse = GetPairedDevice(device);
        kbd = device;
        if (!mouse->valuator || !mouse->button) /* may be float. SDs */
            mouse = NULL;
    }

    /* State needs to be assembled BEFORE the device is updated. */
    state = (kbd && kbd->key) ? XkbStateFieldFromRec(&kbd->key->xkbInfo->state) : 0;
    state |= (mouse && mouse->button) ? (mouse->button->state) : 0;

    for (i = 0; mouse && mouse->button && i < mouse->button->numButtons; i++)
        if (BitIsOn(mouse->button->down, i))
            SetBit(event->buttons, i);

    if (kbd && kbd->key)
    {
        XkbStatePtr state;
        /* we need the state before the event happens */
        if (event->type == ET_KeyPress || event->type == ET_KeyRelease)
            state = &kbd->key->xkbInfo->prev_state;
        else
            state = &kbd->key->xkbInfo->state;

        event->mods.base = state->base_mods;
        event->mods.latched = state->latched_mods;
        event->mods.locked = state->locked_mods;
        event->mods.effective = state->mods;

        event->group.base = state->base_group;
        event->group.latched = state->latched_group;
        event->group.locked = state->locked_group;
        event->group.effective = state->group;
    }

    ret = UpdateDeviceState(device, event);
    if (ret == DONT_PROCESS)
        return;

    v = device->valuator;
    b = device->button;
    k = device->key;

    if (IsMaster(device) || IsFloating(device))
        CheckMotion(event, device);

    switch (event->type)
    {
        case ET_Motion:
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ProximityIn:
        case ET_ProximityOut:
            GetSpritePosition(device, &rootX, &rootY);
            event->root_x = rootX;
            event->root_y = rootY;
            NoticeEventTime((InternalEvent*)event);
            event->corestate = state;
            key = event->detail.key;
            break;
        default:
            break;
    }

    if (DeviceEventCallback && !syncEvents.playingEvents) {
	DeviceEventInfoRec eventinfo;
	SpritePtr pSprite = device->spriteInfo->sprite;

	/* see comment in EnqueueEvents regarding the next three lines */
	if (ev->any.type == ET_Motion)
	    ev->device_event.root = pSprite->hotPhys.pScreen->root->drawable.id;

	eventinfo.device = device;
	eventinfo.event = ev;
	CallCallbacks(&DeviceEventCallback, (pointer) & eventinfo);
    }

    grab = device->deviceGrab.grab;

    switch(event->type)
    {
        case ET_KeyPress:
            if (!grab && CheckDeviceGrabs(device, event, 0))
                return;
            break;
        case ET_KeyRelease:
            if (grab && device->deviceGrab.fromPassiveGrab &&
                (key == device->deviceGrab.activatingKey) &&
                (device->deviceGrab.grab->type == KeyPress ||
                 device->deviceGrab.grab->type == DeviceKeyPress ||
                 device->deviceGrab.grab->type == XI_KeyPress))
                deactivateDeviceGrab = TRUE;
            break;
        case ET_ButtonPress:
            event->detail.button = b->map[key];
            if (!event->detail.button) { /* there's no button 0 */
                event->detail.button = key;
                return;
            }
            if (!grab && CheckDeviceGrabs(device, event, 0))
            {
                /* if a passive grab was activated, the event has been sent
                 * already */
                return;
            }
            break;
        case ET_ButtonRelease:
            event->detail.button = b->map[key];
            if (!event->detail.button) { /* there's no button 0 */
                event->detail.button = key;
                return;
            }
            if (grab && !b->buttonsDown &&
                device->deviceGrab.fromPassiveGrab &&
                (device->deviceGrab.grab->type == ButtonPress ||
                 device->deviceGrab.grab->type == DeviceButtonPress ||
                 device->deviceGrab.grab->type == XI_ButtonPress))
                deactivateDeviceGrab = TRUE;
        default:
            break;
    }


    if (grab)
        DeliverGrabbedEvent((InternalEvent*)event, device, deactivateDeviceGrab);
    else if (device->focus && !IsPointerEvent((InternalEvent*)ev))
        DeliverFocusedEvent(device, (InternalEvent*)event,
                            GetSpriteWindow(device));
    else
        DeliverDeviceEvents(GetSpriteWindow(device), (InternalEvent*)event,
                            NullGrab, NullWindow, device);

    if (deactivateDeviceGrab == TRUE)
	(*device->deviceGrab.DeactivateGrab) (device);
    event->detail.key = key;
}

int
InitProximityClassDeviceStruct(DeviceIntPtr dev)
{
    ProximityClassPtr proxc;

    proxc = (ProximityClassPtr) malloc(sizeof(ProximityClassRec));
    if (!proxc)
	return FALSE;
    proxc->sourceid = dev->id;
    proxc->in_proximity = TRUE;
    dev->proximity = proxc;
    return TRUE;
}

/**
 * Initialise the device's valuators. The memory must already be allocated,
 * this function merely inits the matching axis (specified through axnum) to
 * sane values.
 *
 * It is a condition that (minval < maxval).
 *
 * @see InitValuatorClassDeviceStruct
 */
void
InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval, int maxval,
		       int resolution, int min_res, int max_res, int mode)
{
    AxisInfoPtr ax;

    if (!dev || !dev->valuator || minval > maxval)
        return;
    if (axnum >= dev->valuator->numAxes)
        return;

    ax = dev->valuator->axes + axnum;

    ax->min_value = minval;
    ax->max_value = maxval;
    ax->resolution = resolution;
    ax->min_resolution = min_res;
    ax->max_resolution = max_res;
    ax->label = label;
    ax->mode = mode;

    if (mode & OutOfProximity)
        dev->proximity->in_proximity = FALSE;
}

static void
FixDeviceStateNotify(DeviceIntPtr dev, deviceStateNotify * ev, KeyClassPtr k,
		     ButtonClassPtr b, ValuatorClassPtr v, int first)
{
    ev->type = DeviceStateNotify;
    ev->deviceid = dev->id;
    ev->time = currentTime.milliseconds;
    ev->classes_reported = 0;
    ev->num_keys = 0;
    ev->num_buttons = 0;
    ev->num_valuators = 0;

    if (b) {
	ev->classes_reported |= (1 << ButtonClass);
	ev->num_buttons = b->numButtons;
	memcpy((char*)ev->buttons, (char*)b->down, 4);
    } else if (k) {
	ev->classes_reported |= (1 << KeyClass);
	ev->num_keys = k->xkbInfo->desc->max_key_code -
                       k->xkbInfo->desc->min_key_code;
	memmove((char *)&ev->keys[0], (char *)k->down, 4);
    }
    if (v) {
	int nval = v->numAxes - first;

	ev->classes_reported |= (1 << ValuatorClass);
	ev->classes_reported |= valuator_get_mode(dev, 0) << ModeBitsShift;
	ev->num_valuators = nval < 3 ? nval : 3;
	switch (ev->num_valuators) {
	case 3:
	    ev->valuator2 = v->axisVal[first + 2];
	case 2:
	    ev->valuator1 = v->axisVal[first + 1];
	case 1:
	    ev->valuator0 = v->axisVal[first];
	    break;
	}
    }
}

static void
FixDeviceValuator(DeviceIntPtr dev, deviceValuator * ev, ValuatorClassPtr v,
		  int first)
{
    int nval = v->numAxes - first;

    ev->type = DeviceValuator;
    ev->deviceid = dev->id;
    ev->num_valuators = nval < 3 ? nval : 3;
    ev->first_valuator = first;
    switch (ev->num_valuators) {
    case 3:
	ev->valuator2 = v->axisVal[first + 2];
    case 2:
	ev->valuator1 = v->axisVal[first + 1];
    case 1:
	ev->valuator0 = v->axisVal[first];
	break;
    }
    first += ev->num_valuators;
}

static void
DeliverStateNotifyEvent(DeviceIntPtr dev, WindowPtr win)
{
    int evcount = 1;
    deviceStateNotify *ev, *sev;
    deviceKeyStateNotify *kev;
    deviceButtonStateNotify *bev;

    KeyClassPtr k;
    ButtonClassPtr b;
    ValuatorClassPtr v;
    int nval = 0, nkeys = 0, nbuttons = 0, first = 0;

    if (!(wOtherInputMasks(win)) ||
        !(wOtherInputMasks(win)->inputEvents[dev->id] & DeviceStateNotifyMask))
        return;

    if ((b = dev->button) != NULL) {
        nbuttons = b->numButtons;
        if (nbuttons > 32)
            evcount++;
    }
    if ((k = dev->key) != NULL) {
        nkeys = k->xkbInfo->desc->max_key_code -
            k->xkbInfo->desc->min_key_code;
        if (nkeys > 32)
            evcount++;
        if (nbuttons > 0) {
            evcount++;
        }
    }
    if ((v = dev->valuator) != NULL) {
        nval = v->numAxes;

        if (nval > 3)
            evcount++;
        if (nval > 6) {
            if (!(k && b))
                evcount++;
            if (nval > 9)
                evcount += ((nval - 7) / 3);
        }
    }

    sev = ev = (deviceStateNotify *) malloc(evcount * sizeof(xEvent));
    FixDeviceStateNotify(dev, ev, NULL, NULL, NULL, first);

    if (b != NULL) {
        FixDeviceStateNotify(dev, ev++, NULL, b, v, first);
        first += 3;
        nval -= 3;
        if (nbuttons > 32) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            bev = (deviceButtonStateNotify *) ev++;
            bev->type = DeviceButtonStateNotify;
            bev->deviceid = dev->id;
            memcpy((char*)&bev->buttons[4], (char*)&b->down[4], DOWN_LENGTH - 4);
        }
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    if (k != NULL) {
        FixDeviceStateNotify(dev, ev++, k, NULL, v, first);
        first += 3;
        nval -= 3;
        if (nkeys > 32) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            kev = (deviceKeyStateNotify *) ev++;
            kev->type = DeviceKeyStateNotify;
            kev->deviceid = dev->id;
            memmove((char *)&kev->keys[0], (char *)&k->down[4], 28);
        }
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    while (nval > 0) {
        FixDeviceStateNotify(dev, ev++, NULL, NULL, v, first);
        first += 3;
        nval -= 3;
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    DeliverEventsToWindow(dev, win, (xEvent *) sev, evcount,
                          DeviceStateNotifyMask, NullGrab);
    free(sev);
}

void
DeviceFocusEvent(DeviceIntPtr dev, int type, int mode, int detail,
		 WindowPtr pWin)
{
    deviceFocus event;
    xXIFocusInEvent *xi2event;
    DeviceIntPtr mouse;
    int btlen, len, i;

    mouse = IsFloating(dev) ? dev : GetMaster(dev, MASTER_POINTER);

    /* XI 2 event */
    btlen = (mouse->button) ? bits_to_bytes(mouse->button->numButtons) : 0;
    btlen = bytes_to_int32(btlen);
    len = sizeof(xXIFocusInEvent) + btlen * 4;

    xi2event = calloc(1, len);
    xi2event->type         = GenericEvent;
    xi2event->extension    = IReqCode;
    xi2event->evtype       = type;
    xi2event->length       = bytes_to_int32(len - sizeof(xEvent));
    xi2event->buttons_len  = btlen;
    xi2event->detail       = detail;
    xi2event->time         = currentTime.milliseconds;
    xi2event->deviceid     = dev->id;
    xi2event->sourceid     = dev->id; /* a device doesn't change focus by itself */
    xi2event->mode         = mode;
    xi2event->root_x       = FP1616(mouse->spriteInfo->sprite->hot.x, 0);
    xi2event->root_y       = FP1616(mouse->spriteInfo->sprite->hot.y, 0);

    for (i = 0; mouse && mouse->button && i < mouse->button->numButtons; i++)
        if (BitIsOn(mouse->button->down, i))
            SetBit(&xi2event[1], i);

    if (dev->key)
    {
        xi2event->mods.base_mods = dev->key->xkbInfo->state.base_mods;
        xi2event->mods.latched_mods = dev->key->xkbInfo->state.latched_mods;
        xi2event->mods.locked_mods = dev->key->xkbInfo->state.locked_mods;
        xi2event->mods.effective_mods = dev->key->xkbInfo->state.mods;

        xi2event->group.base_group = dev->key->xkbInfo->state.base_group;
        xi2event->group.latched_group = dev->key->xkbInfo->state.latched_group;
        xi2event->group.locked_group = dev->key->xkbInfo->state.locked_group;
        xi2event->group.effective_group = dev->key->xkbInfo->state.group;
    }

    FixUpEventFromWindow(dev->spriteInfo->sprite, (xEvent*)xi2event, pWin,
                         None, FALSE);

    DeliverEventsToWindow(dev, pWin, (xEvent*)xi2event, 1,
                          GetEventFilter(dev, (xEvent*)xi2event), NullGrab);

    free(xi2event);

    /* XI 1.x event */
    event.deviceid = dev->id;
    event.mode = mode;
    event.type = (type == XI_FocusIn) ? DeviceFocusIn : DeviceFocusOut;
    event.detail = detail;
    event.window = pWin->drawable.id;
    event.time = currentTime.milliseconds;

    DeliverEventsToWindow(dev, pWin, (xEvent *) & event, 1,
				DeviceFocusChangeMask, NullGrab);

    if (event.type == DeviceFocusIn)
        DeliverStateNotifyEvent(dev, pWin);
}

int
CheckGrabValues(ClientPtr client, GrabParameters* param)
{
    if (param->grabtype != GRABTYPE_CORE &&
        param->grabtype != GRABTYPE_XI &&
        param->grabtype != GRABTYPE_XI2)
    {
        ErrorF("[Xi] grabtype is invalid. This is a bug.\n");
        return BadImplementation;
    }

    if ((param->this_device_mode != GrabModeSync) &&
	(param->this_device_mode != GrabModeAsync)) {
	client->errorValue = param->this_device_mode;
	return BadValue;
    }
    if ((param->other_devices_mode != GrabModeSync) &&
	(param->other_devices_mode != GrabModeAsync)) {
	client->errorValue = param->other_devices_mode;
	return BadValue;
    }

    if (param->grabtype != GRABTYPE_XI2 && (param->modifiers != AnyModifier) &&
        (param->modifiers & ~AllModifiersMask)) {
	client->errorValue = param->modifiers;
	return BadValue;
    }

    if ((param->ownerEvents != xFalse) && (param->ownerEvents != xTrue)) {
	client->errorValue = param->ownerEvents;
	return BadValue;
    }
    return Success;
}

int
GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
           int button, GrabParameters *param, GrabType grabtype,
	   GrabMask *mask)
{
    WindowPtr pWin, confineTo;
    CursorPtr cursor;
    GrabPtr grab;
    int rc, type = -1;
    Mask access_mode = DixGrabAccess;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
	return rc;
    if (param->confineTo == None)
	confineTo = NullWindow;
    else {
	rc = dixLookupWindow(&confineTo, param->confineTo, client, DixSetAttrAccess);
	if (rc != Success)
	    return rc;
    }
    if (param->cursor == None)
	cursor = NullCursor;
    else {
	rc = dixLookupResourceByType((pointer *)&cursor, param->cursor,
				     RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = param->cursor;
	    return rc;
	}
	access_mode |= DixForceAccess;
    }
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
	return rc;
    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if (grabtype == GRABTYPE_XI)
        type = DeviceButtonPress;
    else if (grabtype == GRABTYPE_XI2)
        type = XI_ButtonPress;

    grab = CreateGrab(client->index, dev, modifier_device, pWin, grabtype,
                      mask, param, type, button, confineTo, cursor);
    if (!grab)
	return BadAlloc;
    return AddPassiveGrabToList(client, grab);
}

/**
 * Grab the given key. If grabtype is GRABTYPE_XI, the key is a keycode. If
 * grabtype is GRABTYPE_XI2, the key is a keysym.
 */
int
GrabKey(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
        int key, GrabParameters *param, GrabType grabtype, GrabMask *mask)
{
    WindowPtr pWin;
    GrabPtr grab;
    KeyClassPtr k = dev->key;
    Mask access_mode = DixGrabAccess;
    int rc, type = -1;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
        return rc;
    if (k == NULL)
	return BadMatch;
    if (grabtype == GRABTYPE_XI)
    {
        if ((key > k->xkbInfo->desc->max_key_code ||
                    key < k->xkbInfo->desc->min_key_code)
                && (key != AnyKey)) {
            client->errorValue = key;
            return BadValue;
        }
        type = DeviceKeyPress;
    } else if (grabtype == GRABTYPE_XI2)
        type = XI_KeyPress;

    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
	return rc;

    grab = CreateGrab(client->index, dev, modifier_device, pWin, grabtype,
                      mask, param, type, key, NULL, NULL);
    if (!grab)
	return BadAlloc;
    return AddPassiveGrabToList(client, grab);
}

/* Enter/FocusIn grab */
int
GrabWindow(ClientPtr client, DeviceIntPtr dev, int type,
           GrabParameters *param, GrabMask *mask)
{
    WindowPtr pWin;
    CursorPtr cursor;
    GrabPtr grab;
    Mask access_mode = DixGrabAccess;
    int rc;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
        return rc;

    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (param->cursor == None)
	cursor = NullCursor;
    else {
	rc = dixLookupResourceByType((pointer *)&cursor, param->cursor,
				     RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = param->cursor;
	    return rc;
	}
	access_mode |= DixForceAccess;
    }
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
	return rc;

    grab = CreateGrab(client->index, dev, dev, pWin, GRABTYPE_XI2,
                      mask, param, (type == XIGrabtypeEnter) ? XI_Enter : XI_FocusIn,
                      0, NULL, cursor);

    if (!grab)
        return BadAlloc;

    return AddPassiveGrabToList(client, grab);
}

int
SelectForWindow(DeviceIntPtr dev, WindowPtr pWin, ClientPtr client,
		Mask mask, Mask exclusivemasks)
{
    int mskidx = dev->id;
    int i, ret;
    Mask check;
    InputClientsPtr others;

    check = (mask & exclusivemasks);
    if (wOtherInputMasks(pWin)) {
	if (check & wOtherInputMasks(pWin)->inputEvents[mskidx]) {	/* It is illegal for two different
									 * clients to select on any of the
									 * events for maskcheck. However,
									 * it is OK, for some client to
									 * continue selecting on one of those
									 * events.  */
	    for (others = wOtherInputMasks(pWin)->inputClients; others;
		 others = others->next) {
		if (!SameClient(others, client) && (check &
						    others->mask[mskidx]))
		    return BadAccess;
	    }
	}
	for (others = wOtherInputMasks(pWin)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
		check = others->mask[mskidx];
		others->mask[mskidx] = mask;
		if (mask == 0) {
		    for (i = 0; i < EMASKSIZE; i++)
			if (i != mskidx && others->mask[i] != 0)
			    break;
		    if (i == EMASKSIZE) {
			RecalculateDeviceDeliverableEvents(pWin);
			if (ShouldFreeInputMasks(pWin, FALSE))
			    FreeResource(others->resource, RT_NONE);
			return Success;
		    }
		}
		goto maskSet;
	    }
	}
    }
    check = 0;
    if ((ret = AddExtensionClient(pWin, client, mask, mskidx)) != Success)
	return ret;
  maskSet:
    if (dev->valuator)
	if ((dev->valuator->motionHintWindow == pWin) &&
	    (mask & DevicePointerMotionHintMask) &&
	    !(check & DevicePointerMotionHintMask) && !dev->deviceGrab.grab)
	    dev->valuator->motionHintWindow = NullWindow;
    RecalculateDeviceDeliverableEvents(pWin);
    return Success;
}

int
AddExtensionClient(WindowPtr pWin, ClientPtr client, Mask mask, int mskidx)
{
    InputClientsPtr others;

    if (!pWin->optional && !MakeWindowOptional(pWin))
	return BadAlloc;
    others = calloc(1, sizeof(InputClients));
    if (!others)
	return BadAlloc;
    if (!pWin->optional->inputMasks && !MakeInputMasks(pWin))
	goto bail;
    others->mask[mskidx] = mask;
    others->resource = FakeClientID(client->index);
    others->next = pWin->optional->inputMasks->inputClients;
    pWin->optional->inputMasks->inputClients = others;
    if (!AddResource(others->resource, RT_INPUTCLIENT, (pointer) pWin))
	goto bail;
    return Success;

bail:
    free(others);
    return BadAlloc;
}

static Bool
MakeInputMasks(WindowPtr pWin)
{
    struct _OtherInputMasks *imasks;

    imasks = calloc(1, sizeof(struct _OtherInputMasks));
    if (!imasks)
	return FALSE;
    pWin->optional->inputMasks = imasks;
    return TRUE;
}

void
RecalculateDeviceDeliverableEvents(WindowPtr pWin)
{
    InputClientsPtr others;
    struct _OtherInputMasks *inputMasks;	/* default: NULL */
    WindowPtr pChild, tmp;
    int i, j;

    pChild = pWin;
    while (1) {
	if ((inputMasks = wOtherInputMasks(pChild)) != 0) {
            for (i = 0; i < EMASKSIZE; i++)
                memset(inputMasks->xi2mask[i], 0, sizeof(inputMasks->xi2mask[i]));
	    for (others = inputMasks->inputClients; others;
		 others = others->next) {
		for (i = 0; i < EMASKSIZE; i++)
		    inputMasks->inputEvents[i] |= others->mask[i];
                for (i = 0; i < EMASKSIZE; i++)
                    for (j = 0; j < XI2MASKSIZE; j++)
                        inputMasks->xi2mask[i][j] |= others->xi2mask[i][j];
	    }
	    for (i = 0; i < EMASKSIZE; i++)
		inputMasks->deliverableEvents[i] = inputMasks->inputEvents[i];
	    for (tmp = pChild->parent; tmp; tmp = tmp->parent)
		if (wOtherInputMasks(tmp))
		    for (i = 0; i < EMASKSIZE; i++)
			inputMasks->deliverableEvents[i] |=
			    (wOtherInputMasks(tmp)->deliverableEvents[i]
			     & ~inputMasks->
			     dontPropagateMask[i] & PropagateMask[i]);
	}
	if (pChild->firstChild) {
	    pChild = pChild->firstChild;
	    continue;
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    break;
	pChild = pChild->nextSib;
    }
}

int
InputClientGone(WindowPtr pWin, XID id)
{
    InputClientsPtr other, prev;

    if (!wOtherInputMasks(pWin))
	return Success;
    prev = 0;
    for (other = wOtherInputMasks(pWin)->inputClients; other;
	 other = other->next) {
	if (other->resource == id) {
	    if (prev) {
		prev->next = other->next;
		free(other);
	    } else if (!(other->next)) {
		if (ShouldFreeInputMasks(pWin, TRUE)) {
		    wOtherInputMasks(pWin)->inputClients = other->next;
		    free(wOtherInputMasks(pWin));
		    pWin->optional->inputMasks = (OtherInputMasks *) NULL;
		    CheckWindowOptionalNeed(pWin);
		    free(other);
		} else {
		    other->resource = FakeClientID(0);
		    if (!AddResource(other->resource, RT_INPUTCLIENT,
				     (pointer) pWin))
			return BadAlloc;
		}
	    } else {
		wOtherInputMasks(pWin)->inputClients = other->next;
		free(other);
	    }
	    RecalculateDeviceDeliverableEvents(pWin);
	    return Success;
	}
	prev = other;
    }
    FatalError("client not on device event list");
}

int
SendEvent(ClientPtr client, DeviceIntPtr d, Window dest, Bool propagate,
	  xEvent * ev, Mask mask, int count)
{
    WindowPtr pWin;
    WindowPtr effectiveFocus = NullWindow;	/* only set if dest==InputFocus */
    WindowPtr spriteWin = GetSpriteWindow(d);

    if (dest == PointerWindow)
	pWin = spriteWin;
    else if (dest == InputFocus) {
	WindowPtr inputFocus;

	if (!d->focus)
	    inputFocus = spriteWin;
	else
	    inputFocus = d->focus->win;

	if (inputFocus == FollowKeyboardWin)
	    inputFocus = inputInfo.keyboard->focus->win;

	if (inputFocus == NoneWin)
	    return Success;

	/* If the input focus is PointerRootWin, send the event to where
	 * the pointer is if possible, then perhaps propogate up to root. */
	if (inputFocus == PointerRootWin)
	    inputFocus = GetCurrentRootWindow(d);

	if (IsParent(inputFocus, spriteWin)) {
	    effectiveFocus = inputFocus;
	    pWin = spriteWin;
	} else
	    effectiveFocus = pWin = inputFocus;
    } else
	dixLookupWindow(&pWin, dest, client, DixSendAccess);
    if (!pWin)
	return BadWindow;
    if ((propagate != xFalse) && (propagate != xTrue)) {
	client->errorValue = propagate;
	return BadValue;
    }
    ev->u.u.type |= 0x80;
    if (propagate) {
	for (; pWin; pWin = pWin->parent) {
	    if (DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab))
		return Success;
	    if (pWin == effectiveFocus)
		return Success;
	    if (wOtherInputMasks(pWin))
		mask &= ~wOtherInputMasks(pWin)->dontPropagateMask[d->id];
	    if (!mask)
		break;
	}
    } else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, ev, count))
	DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab);
    return Success;
}

int
SetButtonMapping(ClientPtr client, DeviceIntPtr dev, int nElts, BYTE * map)
{
    int i;
    ButtonClassPtr b = dev->button;

    if (b == NULL)
	return BadMatch;

    if (nElts != b->numButtons) {
	client->errorValue = nElts;
	return BadValue;
    }
    if (BadDeviceMap(&map[0], nElts, 1, 255, &client->errorValue))
	return BadValue;
    for (i = 0; i < nElts; i++)
	if ((b->map[i + 1] != map[i]) && BitIsOn(b->down, i + 1))
	    return MappingBusy;
    for (i = 0; i < nElts; i++)
	b->map[i + 1] = map[i];
    return Success;
}

int
ChangeKeyMapping(ClientPtr client,
		 DeviceIntPtr dev,
		 unsigned len,
		 int type,
		 KeyCode firstKeyCode,
		 CARD8 keyCodes, CARD8 keySymsPerKeyCode, KeySym * map)
{
    KeySymsRec keysyms;
    KeyClassPtr k = dev->key;

    if (k == NULL)
	return BadMatch;

    if (len != (keyCodes * keySymsPerKeyCode))
	return BadLength;

    if ((firstKeyCode < k->xkbInfo->desc->min_key_code) ||
	(firstKeyCode + keyCodes - 1 > k->xkbInfo->desc->max_key_code)) {
	client->errorValue = firstKeyCode;
	return BadValue;
    }
    if (keySymsPerKeyCode == 0) {
	client->errorValue = 0;
	return BadValue;
    }
    keysyms.minKeyCode = firstKeyCode;
    keysyms.maxKeyCode = firstKeyCode + keyCodes - 1;
    keysyms.mapWidth = keySymsPerKeyCode;
    keysyms.map = map;

    XkbApplyMappingChange(dev, &keysyms, firstKeyCode, keyCodes, NULL,
                          serverClient);

    return Success;
}

static void
DeleteDeviceFromAnyExtEvents(WindowPtr pWin, DeviceIntPtr dev)
{
    WindowPtr parent;

    /* Deactivate any grabs performed on this window, before making
     * any input focus changes.
     * Deactivating a device grab should cause focus events. */

    if (dev->deviceGrab.grab && (dev->deviceGrab.grab->window == pWin))
	(*dev->deviceGrab.DeactivateGrab) (dev);

    /* If the focus window is a root window (ie. has no parent)
     * then don't delete the focus from it. */

    if (dev->focus && (pWin == dev->focus->win) && (pWin->parent != NullWindow)) {
	int focusEventMode = NotifyNormal;

	/* If a grab is in progress, then alter the mode of focus events. */

	if (dev->deviceGrab.grab)
	    focusEventMode = NotifyWhileGrabbed;

	switch (dev->focus->revert) {
	case RevertToNone:
	    if (!ActivateFocusInGrab(dev, pWin, NoneWin))
		DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
	    dev->focus->win = NoneWin;
	    dev->focus->traceGood = 0;
	    break;
	case RevertToParent:
	    parent = pWin;
	    do {
		parent = parent->parent;
		dev->focus->traceGood--;
	    }
	    while (!parent->realized);
	    if (!ActivateFocusInGrab(dev, pWin, parent))
		DoFocusEvents(dev, pWin, parent, focusEventMode);
	    dev->focus->win = parent;
	    dev->focus->revert = RevertToNone;
	    break;
	case RevertToPointerRoot:
	    if (!ActivateFocusInGrab(dev, pWin, PointerRootWin))
		DoFocusEvents(dev, pWin, PointerRootWin, focusEventMode);
	    dev->focus->win = PointerRootWin;
	    dev->focus->traceGood = 0;
	    break;
	case RevertToFollowKeyboard:
            {
                DeviceIntPtr kbd = GetMaster(dev, MASTER_KEYBOARD);
                if (!kbd || (kbd == dev && kbd != inputInfo.keyboard))
                    kbd = inputInfo.keyboard;
	    if (kbd->focus->win) {
		if (!ActivateFocusInGrab(dev, pWin, kbd->focus->win))
		    DoFocusEvents(dev, pWin, kbd->focus->win, focusEventMode);
		dev->focus->win = FollowKeyboardWin;
		dev->focus->traceGood = 0;
	    } else {
                if (!ActivateFocusInGrab(dev, pWin, NoneWin))
                    DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
		dev->focus->win = NoneWin;
		dev->focus->traceGood = 0;
	    }
            }
	    break;
	}
    }

    if (dev->valuator)
	if (dev->valuator->motionHintWindow == pWin)
	    dev->valuator->motionHintWindow = NullWindow;
}

void
DeleteWindowFromAnyExtEvents(WindowPtr pWin, Bool freeResources)
{
    int i;
    DeviceIntPtr dev;
    InputClientsPtr ic;
    struct _OtherInputMasks *inputMasks;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
	DeleteDeviceFromAnyExtEvents(pWin, dev);
    }

    for (dev = inputInfo.off_devices; dev; dev = dev->next)
	DeleteDeviceFromAnyExtEvents(pWin, dev);

    if (freeResources)
	while ((inputMasks = wOtherInputMasks(pWin)) != 0) {
	    ic = inputMasks->inputClients;
	    for (i = 0; i < EMASKSIZE; i++)
		inputMasks->dontPropagateMask[i] = 0;
	    FreeResource(ic->resource, RT_NONE);
	}
}

int
MaybeSendDeviceMotionNotifyHint(deviceKeyButtonPointer * pEvents, Mask mask)
{
    DeviceIntPtr dev;

    dixLookupDevice(&dev, pEvents->deviceid & DEVICE_BITS, serverClient,
		    DixReadAccess);
    if (!dev)
        return 0;

    if (pEvents->type == DeviceMotionNotify) {
	if (mask & DevicePointerMotionHintMask) {
	    if (WID(dev->valuator->motionHintWindow) == pEvents->event) {
		return 1;	/* don't send, but pretend we did */
	    }
	    pEvents->detail = NotifyHint;
	} else {
	    pEvents->detail = NotifyNormal;
	}
    }
    return 0;
}

void
CheckDeviceGrabAndHintWindow(WindowPtr pWin, int type,
			     deviceKeyButtonPointer * xE, GrabPtr grab,
			     ClientPtr client, Mask deliveryMask)
{
    DeviceIntPtr dev;

    dixLookupDevice(&dev, xE->deviceid & DEVICE_BITS, serverClient,
		    DixGrabAccess);
    if (!dev)
        return;

    if (type == DeviceMotionNotify)
	dev->valuator->motionHintWindow = pWin;
    else if ((type == DeviceButtonPress) && (!grab) &&
	     (deliveryMask & DeviceButtonGrabMask)) {
	GrabRec tempGrab;

	tempGrab.device = dev;
	tempGrab.resource = client->clientAsMask;
	tempGrab.window = pWin;
	tempGrab.ownerEvents =
	    (deliveryMask & DeviceOwnerGrabButtonMask) ? TRUE : FALSE;
	tempGrab.eventMask = deliveryMask;
	tempGrab.keyboardMode = GrabModeAsync;
	tempGrab.pointerMode = GrabModeAsync;
	tempGrab.confineTo = NullWindow;
	tempGrab.cursor = NullCursor;
        tempGrab.next = NULL;
	(*dev->deviceGrab.ActivateGrab) (dev, &tempGrab, currentTime, TRUE);
    }
}

static Mask
DeviceEventMaskForClient(DeviceIntPtr dev, WindowPtr pWin, ClientPtr client)
{
    InputClientsPtr other;

    if (!wOtherInputMasks(pWin))
	return 0;
    for (other = wOtherInputMasks(pWin)->inputClients; other;
	 other = other->next) {
	if (SameClient(other, client))
	    return other->mask[dev->id];
    }
    return 0;
}

void
MaybeStopDeviceHint(DeviceIntPtr dev, ClientPtr client)
{
    WindowPtr pWin;
    GrabPtr grab = dev->deviceGrab.grab;

    pWin = dev->valuator->motionHintWindow;

    if ((grab && SameClient(grab, client) &&
	 ((grab->eventMask & DevicePointerMotionHintMask) ||
	  (grab->ownerEvents &&
	   (DeviceEventMaskForClient(dev, pWin, client) &
	    DevicePointerMotionHintMask)))) ||
	(!grab &&
	 (DeviceEventMaskForClient(dev, pWin, client) &
	  DevicePointerMotionHintMask)))
	dev->valuator->motionHintWindow = NullWindow;
}

int
DeviceEventSuppressForWindow(WindowPtr pWin, ClientPtr client, Mask mask,
			     int maskndx)
{
    struct _OtherInputMasks *inputMasks = wOtherInputMasks(pWin);

    if (mask & ~PropagateMask[maskndx]) {
	client->errorValue = mask;
	return BadValue;
    }

    if (mask == 0) {
	if (inputMasks)
	    inputMasks->dontPropagateMask[maskndx] = mask;
    } else {
	if (!inputMasks)
	    AddExtensionClient(pWin, client, 0, 0);
	inputMasks = wOtherInputMasks(pWin);
	inputMasks->dontPropagateMask[maskndx] = mask;
    }
    RecalculateDeviceDeliverableEvents(pWin);
    if (ShouldFreeInputMasks(pWin, FALSE))
	FreeResource(inputMasks->inputClients->resource, RT_NONE);
    return Success;
}

Bool
ShouldFreeInputMasks(WindowPtr pWin, Bool ignoreSelectedEvents)
{
    int i;
    Mask allInputEventMasks = 0;
    struct _OtherInputMasks *inputMasks = wOtherInputMasks(pWin);

    for (i = 0; i < EMASKSIZE; i++)
	allInputEventMasks |= inputMasks->dontPropagateMask[i];
    if (!ignoreSelectedEvents)
	for (i = 0; i < EMASKSIZE; i++)
	    allInputEventMasks |= inputMasks->inputEvents[i];
    if (allInputEventMasks == 0)
	return TRUE;
    else
	return FALSE;
}

/***********************************************************************
 *
 * Walk through the window tree, finding all clients that want to know
 * about the Event.
 *
 */

static void
FindInterestedChildren(DeviceIntPtr dev, WindowPtr p1, Mask mask,
                       xEvent * ev, int count)
{
    WindowPtr p2;

    while (p1) {
        p2 = p1->firstChild;
        DeliverEventsToWindow(dev, p1, ev, count, mask, NullGrab);
        FindInterestedChildren(dev, p2, mask, ev, count);
        p1 = p1->nextSib;
    }
}

/***********************************************************************
 *
 * Send an event to interested clients in all windows on all screens.
 *
 */

void
SendEventToAllWindows(DeviceIntPtr dev, Mask mask, xEvent * ev, int count)
{
    int i;
    WindowPtr pWin, p1;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pWin = screenInfo.screens[i]->root;
        if (!pWin)
            continue;
        DeliverEventsToWindow(dev, pWin, ev, count, mask, NullGrab);
        p1 = pWin->firstChild;
        FindInterestedChildren(dev, p1, mask, ev, count);
    }
}

/**
 * Set the XI2 mask for the given client on the given window.
 * @param dev The device to set the mask for.
 * @param win The window to set the mask on.
 * @param client The client setting the mask.
 * @param len Number of bytes in mask.
 * @param mask Event mask in the form of (1 << eventtype)
 */
int
XISetEventMask(DeviceIntPtr dev, WindowPtr win, ClientPtr client,
               unsigned int len, unsigned char* mask)
{
    OtherInputMasks *masks;
    InputClientsPtr others = NULL;

    masks = wOtherInputMasks(win);
    if (masks)
    {
	for (others = wOtherInputMasks(win)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
                memset(others->xi2mask[dev->id], 0,
                       sizeof(others->xi2mask[dev->id]));
                break;
            }
        }
    }

    len = min(len, sizeof(others->xi2mask[dev->id]));

    if (len && !others)
    {
        if (AddExtensionClient(win, client, 0, 0) != Success)
            return BadAlloc;
        others= wOtherInputMasks(win)->inputClients;
    }

    if (others)
        memset(others->xi2mask[dev->id], 0, sizeof(others->xi2mask[dev->id]));

    if (len)
        memcpy(others->xi2mask[dev->id], mask, len);

    RecalculateDeviceDeliverableEvents(win);

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

/*****************************************************************
 *
 * Globals referenced elsewhere in the server.
 *
 */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif
#include "privates.h"

#ifndef EXGLOBALS_H
#define EXGLOBALS_H 1

extern int IReqCode;
extern int IEventBase;
extern int BadDevice;
extern int BadMode;
extern int DeviceBusy;
extern int BadClass;

/* Note: only the ones needed in files other than extinit.c are declared */
extern const Mask DevicePointerMotionMask;
extern const Mask DevicePointerMotionHintMask;
extern const Mask DeviceFocusChangeMask;
extern const Mask DeviceStateNotifyMask;
extern const Mask DeviceMappingNotifyMask;
extern const Mask DeviceOwnerGrabButtonMask;
extern const Mask DeviceButtonGrabMask;
extern const Mask DeviceButtonMotionMask;
extern const Mask DevicePresenceNotifyMask;
extern const Mask DevicePropertyNotifyMask;
extern const Mask XIAllMasks;

extern Mask PropagateMask[];

extern int DeviceValuator;
extern int DeviceKeyPress;
extern int DeviceKeyRelease;
extern int DeviceButtonPress;
extern int DeviceButtonRelease;
extern int DeviceMotionNotify;
extern int DeviceFocusIn;
extern int DeviceFocusOut;
extern int ProximityIn;
extern int ProximityOut;
extern int DeviceStateNotify;
extern int DeviceKeyStateNotify;
extern int DeviceButtonStateNotify;
extern int DeviceMappingNotify;
extern int ChangeDeviceNotify;
extern int DevicePresenceNotify;
extern int DevicePropertyNotify;

extern RESTYPE RT_INPUTCLIENT;

extern DevPrivateKeyRec XIClientPrivateKeyRec;
#define XIClientPrivateKey (&XIClientPrivateKeyRec)

#endif /* EXGLOBALS_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Dispatch routines and initialization routines for the X input extension.
 *
 */
#define ARRAY_SIZE(_a)        (sizeof((_a)) / sizeof((_a)[0]))

#define	 NUMTYPES 15

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"
#include "gcstruct.h"	/* pointer for extnsionst.h */
#include "extnsionst.h"	/* extension entry   */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/geproto.h>
#include "geext.h" /* extension interfaces for ge */

#include "dixevents.h"
#include "exevents.h"
#include "extinit.h"
#include "exglobals.h"
#include "swaprep.h"
#include "privates.h"
#include "protocol-versions.h"

/* modules local to Xi */
#include "allowev.h"
#include "chgdctl.h"
#include "chgfctl.h"
#include "chgkbd.h"
#include "chgprop.h"
#include "chgptr.h"
#include "closedev.h"
#include "devbell.h"
#include "getbmap.h"
#include "getdctl.h"
#include "getfctl.h"
#include "getfocus.h"
#include "getkmap.h"
#include "getmmap.h"
#include "getprop.h"
#include "getselev.h"
#include "getvers.h"
#include "grabdev.h"
#include "grabdevb.h"
#include "grabdevk.h"
#include "gtmotion.h"
#include "listdev.h"
#include "opendev.h"
#include "queryst.h"
#include "selectev.h"
#include "sendexev.h"
#include "chgkmap.h"
#include "setbmap.h"
#include "setdval.h"
#include "setfocus.h"
#include "setmmap.h"
#include "setmode.h"
#include "ungrdev.h"
#include "ungrdevb.h"
#include "ungrdevk.h"
#include "xiallowev.h"
#include "xiselectev.h"
#include "xigrabdev.h"
#include "xipassivegrab.h"
#include "xisetdevfocus.h"
#include "xiproperty.h"
#include "xichangecursor.h"
#include "xichangehierarchy.h"
#include "xigetclientpointer.h"
#include "xiquerydevice.h"
#include "xiquerypointer.h"
#include "xiqueryversion.h"
#include "xisetclientpointer.h"
#include "xiwarppointer.h"


/* Masks for XI events have to be aligned with core event (partially anyway).
 * If DeviceButtonMotionMask is != ButtonMotionMask, event delivery
 * breaks down. The device needs the dev->button->motionMask. If DBMM is
 * the same as BMM, we can ensure that both core and device events can be
 * delivered, without the need for extra structures in the DeviceIntRec. */
const Mask DeviceKeyPressMask             = KeyPressMask;
const Mask DeviceKeyReleaseMask           = KeyReleaseMask;
const Mask DeviceButtonPressMask          = ButtonPressMask;
const Mask DeviceButtonReleaseMask        = ButtonReleaseMask;
const Mask DeviceProximityMask            = (1L << 4);
const Mask DeviceStateNotifyMask          = (1L << 5);
const Mask DevicePointerMotionMask        = PointerMotionMask;
const Mask DevicePointerMotionHintMask    = PointerMotionHintMask;
const Mask DeviceButton1MotionMask        = Button1MotionMask;
const Mask DeviceButton2MotionMask        = Button2MotionMask;
const Mask DeviceButton3MotionMask        = Button3MotionMask;
const Mask DeviceButton4MotionMask        = Button4MotionMask;
const Mask DeviceButton5MotionMask        = Button5MotionMask;
const Mask DeviceButtonMotionMask         = ButtonMotionMask;
const Mask DeviceFocusChangeMask          = (1L << 14);
const Mask DeviceMappingNotifyMask        = (1L << 15);
const Mask ChangeDeviceNotifyMask         = (1L << 16);
const Mask DeviceButtonGrabMask           = (1L << 17);
const Mask DeviceOwnerGrabButtonMask      = (1L << 17);
const Mask DevicePresenceNotifyMask       = (1L << 18);
const Mask DeviceEnterWindowMask          = (1L << 18);
const Mask DeviceLeaveWindowMask          = (1L << 19);
const Mask DevicePropertyNotifyMask       = (1L << 20);
const Mask XIAllMasks                     = (1L << 21) - 1;

int ExtEventIndex;
Mask ExtExclusiveMasks[EMASKSIZE];

static struct dev_type
{
    Atom type;
    char *name;
} dev_type[] = {
    {
    0, XI_KEYBOARD}, {
    0, XI_MOUSE}, {
    0, XI_TABLET}, {
    0, XI_TOUCHSCREEN}, {
    0, XI_TOUCHPAD}, {
    0, XI_BARCODE}, {
    0, XI_BUTTONBOX}, {
    0, XI_KNOB_BOX}, {
    0, XI_ONE_KNOB}, {
    0, XI_NINE_KNOB}, {
    0, XI_TRACKBALL}, {
    0, XI_QUADRATURE}, {
    0, XI_ID_MODULE}, {
    0, XI_SPACEBALL}, {
    0, XI_DATAGLOVE}, {
    0, XI_EYETRACKER}, {
    0, XI_CURSORKEYS}, {
0, XI_FOOTMOUSE}};

CARD8 event_base[numInputClasses];
XExtEventInfo EventInfo[32];

static DeviceIntRec xi_all_devices;
static DeviceIntRec xi_all_master_devices;

/**
 * Dispatch vector. Functions defined in here will be called when the matching
 * request arrives.
 */
static int (*ProcIVector[])(ClientPtr) = {
        NULL,                                   /*  0 */
	ProcXGetExtensionVersion,               /*  1 */
	ProcXListInputDevices,                  /*  2 */
	ProcXOpenDevice,                        /*  3 */
	ProcXCloseDevice,                       /*  4 */
	ProcXSetDeviceMode,                     /*  5 */
	ProcXSelectExtensionEvent,              /*  6 */
	ProcXGetSelectedExtensionEvents,        /*  7 */
	ProcXChangeDeviceDontPropagateList,     /*  8 */
	ProcXGetDeviceDontPropagateList,        /*  9 */
	ProcXGetDeviceMotionEvents,             /* 10 */
	ProcXChangeKeyboardDevice,              /* 11 */
	ProcXChangePointerDevice,               /* 12 */
	ProcXGrabDevice,                        /* 13 */
	ProcXUngrabDevice,                      /* 14 */
	ProcXGrabDeviceKey,                     /* 15 */
	ProcXUngrabDeviceKey,                   /* 16 */
	ProcXGrabDeviceButton,                  /* 17 */
	ProcXUngrabDeviceButton,                /* 18 */
	ProcXAllowDeviceEvents,                 /* 19 */
	ProcXGetDeviceFocus,                    /* 20 */
	ProcXSetDeviceFocus,                    /* 21 */
	ProcXGetFeedbackControl,                /* 22 */
	ProcXChangeFeedbackControl,             /* 23 */
	ProcXGetDeviceKeyMapping,               /* 24 */
	ProcXChangeDeviceKeyMapping,            /* 25 */
	ProcXGetDeviceModifierMapping,          /* 26 */
	ProcXSetDeviceModifierMapping,          /* 27 */
	ProcXGetDeviceButtonMapping,            /* 28 */
	ProcXSetDeviceButtonMapping,            /* 29 */
	ProcXQueryDeviceState,                  /* 30 */
	ProcXSendExtensionEvent,                /* 31 */
	ProcXDeviceBell,                        /* 32 */
	ProcXSetDeviceValuators,                /* 33 */
	ProcXGetDeviceControl,                  /* 34 */
	ProcXChangeDeviceControl,               /* 35 */
        /* XI 1.5 */
        ProcXListDeviceProperties,              /* 36 */
        ProcXChangeDeviceProperty,              /* 37 */
        ProcXDeleteDeviceProperty,              /* 38 */
        ProcXGetDeviceProperty,                 /* 39 */
        /* XI 2 */
        ProcXIQueryPointer,                     /* 40 */
        ProcXIWarpPointer,                      /* 41 */
        ProcXIChangeCursor,                     /* 42 */
        ProcXIChangeHierarchy,                  /* 43 */
        ProcXISetClientPointer,                 /* 44 */
        ProcXIGetClientPointer,                 /* 45 */
        ProcXISelectEvents,                     /* 46 */
        ProcXIQueryVersion,                     /* 47 */
        ProcXIQueryDevice,                      /* 48 */
        ProcXISetFocus,                         /* 49 */
        ProcXIGetFocus,                         /* 50 */
        ProcXIGrabDevice,                       /* 51 */
        ProcXIUngrabDevice,                     /* 52 */
        ProcXIAllowEvents,                      /* 53 */
        ProcXIPassiveGrabDevice,                /* 54 */
        ProcXIPassiveUngrabDevice,              /* 55 */
        ProcXIListProperties,                   /* 56 */
        ProcXIChangeProperty,                   /* 57 */
        ProcXIDeleteProperty,                   /* 58 */
        ProcXIGetProperty,                      /* 59 */
        ProcXIGetSelectedEvents                 /* 60 */
};

/* For swapped clients */
static int (*SProcIVector[])(ClientPtr) = {
        NULL,                                    /*  0 */
	SProcXGetExtensionVersion,               /*  1 */
	SProcXListInputDevices,                  /*  2 */
	SProcXOpenDevice,                        /*  3 */
	SProcXCloseDevice,                       /*  4 */
	SProcXSetDeviceMode,                     /*  5 */
	SProcXSelectExtensionEvent,              /*  6 */
	SProcXGetSelectedExtensionEvents,        /*  7 */
	SProcXChangeDeviceDontPropagateList,     /*  8 */
	SProcXGetDeviceDontPropagateList,        /*  9 */
	SProcXGetDeviceMotionEvents,             /* 10 */
	SProcXChangeKeyboardDevice,              /* 11 */
	SProcXChangePointerDevice,               /* 12 */
	SProcXGrabDevice,                        /* 13 */
	SProcXUngrabDevice,                      /* 14 */
	SProcXGrabDeviceKey,                     /* 15 */
	SProcXUngrabDeviceKey,                   /* 16 */
	SProcXGrabDeviceButton,                  /* 17 */
	SProcXUngrabDeviceButton,                /* 18 */
	SProcXAllowDeviceEvents,                 /* 19 */
	SProcXGetDeviceFocus,                    /* 20 */
	SProcXSetDeviceFocus,                    /* 21 */
	SProcXGetFeedbackControl,                /* 22 */
	SProcXChangeFeedbackControl,             /* 23 */
	SProcXGetDeviceKeyMapping,               /* 24 */
	SProcXChangeDeviceKeyMapping,            /* 25 */
	SProcXGetDeviceModifierMapping,          /* 26 */
	SProcXSetDeviceModifierMapping,          /* 27 */
	SProcXGetDeviceButtonMapping,            /* 28 */
	SProcXSetDeviceButtonMapping,            /* 29 */
	SProcXQueryDeviceState,                  /* 30 */
	SProcXSendExtensionEvent,                /* 31 */
	SProcXDeviceBell,                        /* 32 */
	SProcXSetDeviceValuators,                /* 33 */
	SProcXGetDeviceControl,                  /* 34 */
	SProcXChangeDeviceControl,               /* 35 */
        SProcXListDeviceProperties,              /* 36 */
        SProcXChangeDeviceProperty,              /* 37 */
        SProcXDeleteDeviceProperty,              /* 38 */
        SProcXGetDeviceProperty,                 /* 39 */
        SProcXIQueryPointer,                     /* 40 */
        SProcXIWarpPointer,                      /* 41 */
        SProcXIChangeCursor,                     /* 42 */
        SProcXIChangeHierarchy,                  /* 43 */
        SProcXISetClientPointer,                 /* 44 */
        SProcXIGetClientPointer,                 /* 45 */
        SProcXISelectEvents,                     /* 46 */
        SProcXIQueryVersion,                     /* 47 */
        SProcXIQueryDevice,                      /* 48 */
        SProcXISetFocus,                         /* 49 */
        SProcXIGetFocus,                         /* 50 */
        SProcXIGrabDevice,                       /* 51 */
        SProcXIUngrabDevice,                     /* 52 */
        SProcXIAllowEvents,                      /* 53 */
        SProcXIPassiveGrabDevice,                /* 54 */
        SProcXIPassiveUngrabDevice,              /* 55 */
        SProcXIListProperties,                   /* 56 */
        SProcXIChangeProperty,                   /* 57 */
        SProcXIDeleteProperty,                   /* 58 */
        SProcXIGetProperty,                      /* 59 */
        SProcXIGetSelectedEvents                 /* 60 */
};

/*****************************************************************
 *
 * Globals referenced elsewhere in the server.
 *
 */

int IReqCode = 0;
int IEventBase = 0;
int BadDevice = 0;
static int BadEvent = 1;
int BadMode = 2;
int DeviceBusy = 3;
int BadClass = 4;

int DeviceValuator;
int DeviceKeyPress;
int DeviceKeyRelease;
int DeviceButtonPress;
int DeviceButtonRelease;
int DeviceMotionNotify;
int DeviceFocusIn;
int DeviceFocusOut;
int ProximityIn;
int ProximityOut;
int DeviceStateNotify;
int DeviceKeyStateNotify;
int DeviceButtonStateNotify;
int DeviceMappingNotify;
int ChangeDeviceNotify;
int DevicePresenceNotify;
int DevicePropertyNotify;

RESTYPE RT_INPUTCLIENT;

/*****************************************************************
 *
 * Externs defined elsewhere in the X server.
 *
 */

extern XExtensionVersion XIVersion;


Mask PropagateMask[MAXDEVICES];

/*****************************************************************
 *
 * Versioning support
 *
 */

DevPrivateKeyRec XIClientPrivateKeyRec;

/*****************************************************************
 *
 * Declarations of local routines.
 *
 */

static void
XIClientCallback(CallbackListPtr        *list,
                 pointer                closure,
                 pointer                data)
{
    NewClientInfoRec *clientinfo = (NewClientInfoRec*)data;
    ClientPtr pClient = clientinfo->client;
    XIClientPtr pXIClient;

    pXIClient = dixLookupPrivate(&pClient->devPrivates, XIClientPrivateKey);
    pXIClient->major_version = 0;
    pXIClient->minor_version = 0;
}

/*************************************************************************
 *
 * ProcIDispatch - main dispatch routine for requests to this extension.
 * This routine is used if server and client have the same byte ordering.
 *
 */

static int
ProcIDispatch(ClientPtr client)
{
    REQUEST(xReq);
    if (stuff->data > ARRAY_SIZE(ProcIVector) || !ProcIVector[stuff->data])
        return BadRequest;

    return (*ProcIVector[stuff->data])(client);
}

/*******************************************************************************
 *
 * SProcXDispatch
 *
 * Main swapped dispatch routine for requests to this extension.
 * This routine is used if server and client do not have the same byte ordering.
 *
 */

static int
SProcIDispatch(ClientPtr client)
{
    REQUEST(xReq);
    if (stuff->data > ARRAY_SIZE(SProcIVector) || !SProcIVector[stuff->data])
        return BadRequest;

    return (*SProcIVector[stuff->data])(client);
}

/**********************************************************************
 *
 * SReplyIDispatch
 * Swap any replies defined in this extension.
 *
 */

static void
SReplyIDispatch(ClientPtr client, int len, xGrabDeviceReply * rep)
					/* All we look at is the type field */
{	/* This is common to all replies    */
    if (rep->RepType == X_GetExtensionVersion)
	SRepXGetExtensionVersion(client, len,
				 (xGetExtensionVersionReply *) rep);
    else if (rep->RepType == X_ListInputDevices)
	SRepXListInputDevices(client, len, (xListInputDevicesReply *) rep);
    else if (rep->RepType == X_OpenDevice)
	SRepXOpenDevice(client, len, (xOpenDeviceReply *) rep);
    else if (rep->RepType == X_SetDeviceMode)
	SRepXSetDeviceMode(client, len, (xSetDeviceModeReply *) rep);
    else if (rep->RepType == X_GetSelectedExtensionEvents)
	SRepXGetSelectedExtensionEvents(client, len,
					(xGetSelectedExtensionEventsReply *)
					rep);
    else if (rep->RepType == X_GetDeviceDontPropagateList)
	SRepXGetDeviceDontPropagateList(client, len,
					(xGetDeviceDontPropagateListReply *)
					rep);
    else if (rep->RepType == X_GetDeviceMotionEvents)
	SRepXGetDeviceMotionEvents(client, len,
				   (xGetDeviceMotionEventsReply *) rep);
    else if (rep->RepType == X_GrabDevice)
	SRepXGrabDevice(client, len, (xGrabDeviceReply *) rep);
    else if (rep->RepType == X_GetDeviceFocus)
	SRepXGetDeviceFocus(client, len, (xGetDeviceFocusReply *) rep);
    else if (rep->RepType == X_GetFeedbackControl)
	SRepXGetFeedbackControl(client, len, (xGetFeedbackControlReply *) rep);
    else if (rep->RepType == X_GetDeviceKeyMapping)
	SRepXGetDeviceKeyMapping(client, len,
				 (xGetDeviceKeyMappingReply *) rep);
    else if (rep->RepType == X_GetDeviceModifierMapping)
	SRepXGetDeviceModifierMapping(client, len,
				      (xGetDeviceModifierMappingReply *) rep);
    else if (rep->RepType == X_SetDeviceModifierMapping)
	SRepXSetDeviceModifierMapping(client, len,
				      (xSetDeviceModifierMappingReply *) rep);
    else if (rep->RepType == X_GetDeviceButtonMapping)
	SRepXGetDeviceButtonMapping(client, len,
				    (xGetDeviceButtonMappingReply *) rep);
    else if (rep->RepType == X_SetDeviceButtonMapping)
	SRepXSetDeviceButtonMapping(client, len,
				    (xSetDeviceButtonMappingReply *) rep);
    else if (rep->RepType == X_QueryDeviceState)
	SRepXQueryDeviceState(client, len, (xQueryDeviceStateReply *) rep);
    else if (rep->RepType == X_SetDeviceValuators)
	SRepXSetDeviceValuators(client, len, (xSetDeviceValuatorsReply *) rep);
    else if (rep->RepType == X_GetDeviceControl)
	SRepXGetDeviceControl(client, len, (xGetDeviceControlReply *) rep);
    else if (rep->RepType == X_ChangeDeviceControl)
	SRepXChangeDeviceControl(client, len,
				 (xChangeDeviceControlReply *) rep);
    else if (rep->RepType == X_ListDeviceProperties)
        SRepXListDeviceProperties(client, len, (xListDevicePropertiesReply*)rep);
    else if (rep->RepType == X_GetDeviceProperty)
	SRepXGetDeviceProperty(client, len, (xGetDevicePropertyReply *) rep);
    else if (rep->RepType == X_XIQueryPointer)
	SRepXIQueryPointer(client, len, (xXIQueryPointerReply *) rep);
    else if (rep->RepType == X_XIGetClientPointer)
        SRepXIGetClientPointer(client, len, (xXIGetClientPointerReply*) rep);
    else if (rep->RepType == X_XIQueryVersion)
        SRepXIQueryVersion(client, len, (xXIQueryVersionReply*)rep);
    else if (rep->RepType == X_XIQueryDevice)
        SRepXIQueryDevice(client, len, (xXIQueryDeviceReply*)rep);
    else if (rep->RepType == X_XIGrabDevice)
	SRepXIGrabDevice(client, len, (xXIGrabDeviceReply *) rep);
    else if (rep->RepType == X_XIPassiveGrabDevice)
	SRepXIPassiveGrabDevice(client, len, (xXIPassiveGrabDeviceReply *) rep);
    else if (rep->RepType == X_XIListProperties)
	SRepXIListProperties(client, len, (xXIListPropertiesReply *) rep);
    else if (rep->RepType == X_XIGetProperty)
	SRepXIGetProperty(client, len, (xXIGetPropertyReply *) rep);
    else if (rep->RepType == X_XIGetSelectedEvents)
	SRepXIGetSelectedEvents(client, len, (xXIGetSelectedEventsReply *) rep);
    else if (rep->RepType == X_XIGetFocus)
	SRepXIGetFocus(client, len, (xXIGetFocusReply *) rep);
    else {
	FatalError("XINPUT confused sending swapped reply");
    }
}

/************************************************************************
 *
 * This function swaps the DeviceValuator event.
 *
 */

static void
SEventDeviceValuator(deviceValuator * from, deviceValuator * to)
{
    char n;
    int i;
    INT32 *ip B32;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swaps(&to->device_state, n);
    ip = &to->valuator0;
    for (i = 0; i < 6; i++) {
	swapl((ip + i), n);	/* macro - braces are required      */
    }
}

static void
SEventFocus(deviceFocus * from, deviceFocus * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->time, n);
    swapl(&to->window, n);
}

static void
SDeviceStateNotifyEvent(deviceStateNotify * from, deviceStateNotify * to)
{
    int i;
    char n;
    INT32 *ip B32;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->time, n);
    ip = &to->valuator0;
    for (i = 0; i < 3; i++) {
	swapl((ip + i), n);	/* macro - braces are required      */
    }
}

static void
SDeviceKeyStateNotifyEvent(deviceKeyStateNotify * from,
			   deviceKeyStateNotify * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
}

static void
SDeviceButtonStateNotifyEvent(deviceButtonStateNotify * from,
			      deviceButtonStateNotify * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
}

static void
SChangeDeviceNotifyEvent(changeDeviceNotify * from, changeDeviceNotify * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->time, n);
}

static void
SDeviceMappingNotifyEvent(deviceMappingNotify * from, deviceMappingNotify * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->time, n);
}

static void
SDevicePresenceNotifyEvent (devicePresenceNotify *from, devicePresenceNotify *to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber,n);
    swapl(&to->time, n);
    swaps(&to->control, n);
}

static void
SDevicePropertyNotifyEvent (devicePropertyNotify *from, devicePropertyNotify *to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber,n);
    swapl(&to->time, n);
    swapl(&to->atom, n);
}

static void
SDeviceLeaveNotifyEvent (xXILeaveEvent *from, xXILeaveEvent *to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber,n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swapl(&to->root, n);
    swapl(&to->event, n);
    swapl(&to->child, n);
    swapl(&to->root_x, n);
    swapl(&to->root_y, n);
    swapl(&to->event_x, n);
    swapl(&to->event_y, n);
    swaps(&to->sourceid, n);
    swaps(&to->buttons_len, n);
    swapl(&to->mods.base_mods, n);
    swapl(&to->mods.latched_mods, n);
    swapl(&to->mods.locked_mods, n);
}

static void
SDeviceChangedEvent(xXIDeviceChangedEvent* from, xXIDeviceChangedEvent* to)
{
    char n;
    int i, j;
    xXIAnyInfo *any;

    *to = *from;
    memcpy(&to[1], &from[1], from->length * 4);

    any = (xXIAnyInfo*)&to[1];
    for (i = 0; i < to->num_classes; i++)
    {
        int length = any->length;

        switch(any->type)
        {
            case KeyClass:
                {
                    xXIKeyInfo *ki = (xXIKeyInfo*)any;
                    uint32_t *key = (uint32_t*)&ki[1];
                    for (j = 0; j < ki->num_keycodes; j++, key++)
                        swapl(key, n);
                    swaps(&ki->num_keycodes, n);
                }
                break;
            case ButtonClass:
                {
                    xXIButtonInfo *bi = (xXIButtonInfo*)any;
                    Atom *labels = (Atom*)((char*)bi + sizeof(xXIButtonInfo) +
                                           pad_to_int32(bits_to_bytes(bi->num_buttons)));
                    for (j = 0; j < bi->num_buttons; j++)
                        swapl(&labels[j], n);
                    swaps(&bi->num_buttons, n);
                }
                break;
            case ValuatorClass:
                {
                    xXIValuatorInfo* ai = (xXIValuatorInfo*)any;
                    swapl(&ai->label, n);
                    swapl(&ai->min.integral, n);
                    swapl(&ai->min.frac, n);
                    swapl(&ai->max.integral, n);
                    swapl(&ai->max.frac, n);
                    swapl(&ai->resolution, n);
                    swaps(&ai->number, n);
                }
                break;
        }

        swaps(&any->type, n);
        swaps(&any->length, n);
        swaps(&any->sourceid, n);

        any = (xXIAnyInfo*)((char*)any + length * 4);
    }

    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swaps(&to->num_classes, n);
    swaps(&to->sourceid, n);

}

static void SDeviceEvent(xXIDeviceEvent *from, xXIDeviceEvent *to)
{
    int i;
    char n;
    char *ptr;
    char *vmask;

    memcpy(to, from, sizeof(xEvent) + from->length * 4);

    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swapl(&to->detail, n);
    swapl(&to->root, n);
    swapl(&to->event, n);
    swapl(&to->child, n);
    swapl(&to->root_x, n);
    swapl(&to->root_y, n);
    swapl(&to->event_x, n);
    swapl(&to->event_y, n);
    swaps(&to->buttons_len, n);
    swaps(&to->valuators_len, n);
    swaps(&to->sourceid, n);
    swapl(&to->mods.base_mods, n);
    swapl(&to->mods.latched_mods, n);
    swapl(&to->mods.locked_mods, n);
    swapl(&to->mods.effective_mods, n);
    swapl(&to->flags, n);

    ptr = (char*)(&to[1]);
    ptr += from->buttons_len * 4;
    vmask = ptr; /* valuator mask */
    ptr += from->valuators_len * 4;
    for (i = 0; i < from->valuators_len * 32; i++)
    {
        if (BitIsOn(vmask, i))
        {
            swapl(((uint32_t*)ptr), n);
            ptr += 4;
            swapl(((uint32_t*)ptr), n);
            ptr += 4;
        }
    }
}

static void SDeviceHierarchyEvent(xXIHierarchyEvent *from,
                                  xXIHierarchyEvent *to)
{
    int i;
    char n;
    xXIHierarchyInfo *info;

    *to = *from;
    memcpy(&to[1], &from[1], from->length * 4);
    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swapl(&to->flags, n);
    swaps(&to->num_info, n);

    info = (xXIHierarchyInfo*)&to[1];
    for (i = 0; i< from->num_info; i++)
    {
        swaps(&info->deviceid, n);
        swaps(&info->attachment, n);
        info++;
    }
}

static void SXIPropertyEvent(xXIPropertyEvent *from, xXIPropertyEvent *to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->property, n);
}

static void SRawEvent(xXIRawEvent *from, xXIRawEvent *to)
{
    char n;
    int i;
    FP3232 *values;
    unsigned char *mask;

    memcpy(to, from, sizeof(xEvent) + from->length * 4);

    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swapl(&to->detail, n);


    mask = (unsigned char*)&to[1];
    values = (FP3232*)(mask + from->valuators_len * 4);

    for (i = 0; i < from->valuators_len * 4 * 8; i++)
    {
        if (BitIsOn(mask, i))
        {
            /* for each bit set there are two FP3232 values on the wire, in
             * the order abcABC for data and data_raw. Here we swap as if
             * they were in aAbBcC order because it's easier and really
             * doesn't matter.
             */
            swapl(&values->integral, n);
            swapl(&values->frac, n);
            values++;
            swapl(&values->integral, n);
            swapl(&values->frac, n);
            values++;
        }
    }

    swaps(&to->valuators_len, n);
}


/** Event swapping function for XI2 events. */
void
XI2EventSwap(xGenericEvent *from, xGenericEvent *to)
{
    switch(from->evtype)
    {
        case XI_Enter:
        case XI_Leave:
        case XI_FocusIn:
        case XI_FocusOut:
            SDeviceLeaveNotifyEvent((xXILeaveEvent*)from, (xXILeaveEvent*)to);
            break;
        case XI_DeviceChanged:
            SDeviceChangedEvent((xXIDeviceChangedEvent*)from,
                                (xXIDeviceChangedEvent*)to);
            break;
        case XI_HierarchyChanged:
            SDeviceHierarchyEvent((xXIHierarchyEvent*)from, (xXIHierarchyEvent*)to);
            break;
        case XI_PropertyEvent:
            SXIPropertyEvent((xXIPropertyEvent*)from,
                           (xXIPropertyEvent*)to);
            break;
        case XI_Motion:
        case XI_KeyPress:
        case XI_KeyRelease:
        case XI_ButtonPress:
        case XI_ButtonRelease:
            SDeviceEvent((xXIDeviceEvent*)from, (xXIDeviceEvent*)to);
            break;
        case XI_RawMotion:
        case XI_RawKeyPress:
        case XI_RawKeyRelease:
        case XI_RawButtonPress:
        case XI_RawButtonRelease:
            SRawEvent((xXIRawEvent*)from, (xXIRawEvent*)to);
            break;
        default:
            ErrorF("[Xi] Unknown event type to swap. This is a bug.\n");
            break;
    }
}

/**************************************************************************
 *
 * Allow the specified event to have its propagation suppressed.
 * The default is to not allow suppression of propagation.
 *
 */

static void
AllowPropagateSuppress(Mask mask)
{
    int i;

    for (i = 0; i < MAXDEVICES; i++)
	PropagateMask[i] |= mask;
}

/**************************************************************************
 *
 * Record an event mask where there is no unique corresponding event type.
 * We can't call SetMaskForEvent, since that would clobber the existing
 * mask for that event.  MotionHint and ButtonMotion are examples.
 *
 * Since extension event types will never be less than 64, we can use
 * 0-63 in the EventInfo array as the "type" to be used to look up this
 * mask.  This means that the corresponding macros such as
 * DevicePointerMotionHint must have access to the same constants.
 *
 */

static void
SetEventInfo(Mask mask, int constant)
{
    EventInfo[ExtEventIndex].mask = mask;
    EventInfo[ExtEventIndex++].type = constant;
}

/**************************************************************************
 *
 * Allow the specified event to be restricted to being selected by one
 * client at a time.
 * The default is to allow more than one client to select the event.
 *
 */

static void
SetExclusiveAccess(Mask mask)
{
    int i;

    for (i = 0; i < MAXDEVICES; i++)
	ExtExclusiveMasks[i] |= mask;
}

/**************************************************************************
 *
 * Assign the specified mask to the specified event.
 *
 */

static void
SetMaskForExtEvent(Mask mask, int event)
{
    int i;

    EventInfo[ExtEventIndex].mask = mask;
    EventInfo[ExtEventIndex++].type = event;

    if ((event < LASTEvent) || (event >= 128))
	FatalError("MaskForExtensionEvent: bogus event number");

    for (i = 0; i < MAXDEVICES; i++)
        SetMaskForEvent(i, mask, event);
}

/************************************************************************
 *
 * This function sets up extension event types and masks.
 *
 */

static void
FixExtensionEvents(ExtensionEntry * extEntry)
{
    DeviceValuator = extEntry->eventBase;
    DeviceKeyPress = DeviceValuator + 1;
    DeviceKeyRelease = DeviceKeyPress + 1;
    DeviceButtonPress = DeviceKeyRelease + 1;
    DeviceButtonRelease = DeviceButtonPress + 1;
    DeviceMotionNotify = DeviceButtonRelease + 1;
    DeviceFocusIn = DeviceMotionNotify + 1;
    DeviceFocusOut = DeviceFocusIn + 1;
    ProximityIn = DeviceFocusOut + 1;
    ProximityOut = ProximityIn + 1;
    DeviceStateNotify = ProximityOut + 1;
    DeviceMappingNotify = DeviceStateNotify + 1;
    ChangeDeviceNotify = DeviceMappingNotify + 1;
    DeviceKeyStateNotify = ChangeDeviceNotify + 1;
    DeviceButtonStateNotify = DeviceKeyStateNotify + 1;
    DevicePresenceNotify = DeviceButtonStateNotify + 1;
    DevicePropertyNotify = DevicePresenceNotify + 1;

    event_base[KeyClass] = DeviceKeyPress;
    event_base[ButtonClass] = DeviceButtonPress;
    event_base[ValuatorClass] = DeviceMotionNotify;
    event_base[ProximityClass] = ProximityIn;
    event_base[FocusClass] = DeviceFocusIn;
    event_base[OtherClass] = DeviceStateNotify;

    BadDevice += extEntry->errorBase;
    BadEvent += extEntry->errorBase;
    BadMode += extEntry->errorBase;
    DeviceBusy += extEntry->errorBase;
    BadClass += extEntry->errorBase;

    SetMaskForExtEvent(DeviceKeyPressMask, DeviceKeyPress);
    AllowPropagateSuppress(DeviceKeyPressMask);
    SetCriticalEvent(DeviceKeyPress);

    SetMaskForExtEvent(DeviceKeyReleaseMask, DeviceKeyRelease);
    AllowPropagateSuppress(DeviceKeyReleaseMask);
    SetCriticalEvent(DeviceKeyRelease);

    SetMaskForExtEvent(DeviceButtonPressMask, DeviceButtonPress);
    AllowPropagateSuppress(DeviceButtonPressMask);
    SetCriticalEvent(DeviceButtonPress);

    SetMaskForExtEvent(DeviceButtonReleaseMask, DeviceButtonRelease);
    AllowPropagateSuppress(DeviceButtonReleaseMask);
    SetCriticalEvent(DeviceButtonRelease);

    SetMaskForExtEvent(DeviceProximityMask, ProximityIn);
    SetMaskForExtEvent(DeviceProximityMask, ProximityOut);

    SetMaskForExtEvent(DeviceStateNotifyMask, DeviceStateNotify);

    SetMaskForExtEvent(DevicePointerMotionMask, DeviceMotionNotify);
    AllowPropagateSuppress(DevicePointerMotionMask);
    SetCriticalEvent(DeviceMotionNotify);

    SetEventInfo(DevicePointerMotionHintMask, _devicePointerMotionHint);
    SetEventInfo(DeviceButton1MotionMask, _deviceButton1Motion);
    SetEventInfo(DeviceButton2MotionMask, _deviceButton2Motion);
    SetEventInfo(DeviceButton3MotionMask, _deviceButton3Motion);
    SetEventInfo(DeviceButton4MotionMask, _deviceButton4Motion);
    SetEventInfo(DeviceButton5MotionMask, _deviceButton5Motion);
    SetEventInfo(DeviceButtonMotionMask, _deviceButtonMotion);

    SetMaskForExtEvent(DeviceFocusChangeMask, DeviceFocusIn);
    SetMaskForExtEvent(DeviceFocusChangeMask, DeviceFocusOut);

    SetMaskForExtEvent(DeviceMappingNotifyMask, DeviceMappingNotify);
    SetMaskForExtEvent(ChangeDeviceNotifyMask, ChangeDeviceNotify);

    SetEventInfo(DeviceButtonGrabMask, _deviceButtonGrab);
    SetExclusiveAccess(DeviceButtonGrabMask);

    SetEventInfo(DeviceOwnerGrabButtonMask, _deviceOwnerGrabButton);
    SetEventInfo(DevicePresenceNotifyMask, _devicePresence);
    SetMaskForExtEvent(DevicePropertyNotifyMask, DevicePropertyNotify);

    SetEventInfo(0, _noExtensionEvent);
}

/************************************************************************
 *
 * This function restores extension event types and masks to their
 * initial state.
 *
 */

static void
RestoreExtensionEvents(void)
{
    int i, j;

    IReqCode = 0;
    IEventBase = 0;

    for (i = 0; i < ExtEventIndex - 1; i++) {
	if ((EventInfo[i].type >= LASTEvent) && (EventInfo[i].type < 128))
        {
            for (j = 0; j < MAXDEVICES; j++)
                SetMaskForEvent(j, 0, EventInfo[i].type);
        }
	EventInfo[i].mask = 0;
	EventInfo[i].type = 0;
    }
    ExtEventIndex = 0;
    DeviceValuator = 0;
    DeviceKeyPress = 1;
    DeviceKeyRelease = 2;
    DeviceButtonPress = 3;
    DeviceButtonRelease = 4;
    DeviceMotionNotify = 5;
    DeviceFocusIn = 6;
    DeviceFocusOut = 7;
    ProximityIn = 8;
    ProximityOut = 9;
    DeviceStateNotify = 10;
    DeviceMappingNotify = 11;
    ChangeDeviceNotify = 12;
    DeviceKeyStateNotify = 13;
    DeviceButtonStateNotify = 13;
    DevicePresenceNotify = 14;
    DevicePropertyNotify = 15;

    BadDevice = 0;
    BadEvent = 1;
    BadMode = 2;
    DeviceBusy = 3;
    BadClass = 4;

}

/***********************************************************************
 *
 * IResetProc.
 * Remove reply-swapping routine.
 * Remove event-swapping routine.
 *
 */

static void
IResetProc(ExtensionEntry * unused)
{
    ReplySwapVector[IReqCode] = ReplyNotSwappd;
    EventSwapVector[DeviceValuator] = NotImplemented;
    EventSwapVector[DeviceKeyPress] = NotImplemented;
    EventSwapVector[DeviceKeyRelease] = NotImplemented;
    EventSwapVector[DeviceButtonPress] = NotImplemented;
    EventSwapVector[DeviceButtonRelease] = NotImplemented;
    EventSwapVector[DeviceMotionNotify] = NotImplemented;
    EventSwapVector[DeviceFocusIn] = NotImplemented;
    EventSwapVector[DeviceFocusOut] = NotImplemented;
    EventSwapVector[ProximityIn] = NotImplemented;
    EventSwapVector[ProximityOut] = NotImplemented;
    EventSwapVector[DeviceStateNotify] = NotImplemented;
    EventSwapVector[DeviceKeyStateNotify] = NotImplemented;
    EventSwapVector[DeviceButtonStateNotify] = NotImplemented;
    EventSwapVector[DeviceMappingNotify] = NotImplemented;
    EventSwapVector[ChangeDeviceNotify] = NotImplemented;
    EventSwapVector[DevicePresenceNotify] = NotImplemented;
    EventSwapVector[DevicePropertyNotify] = NotImplemented;
    RestoreExtensionEvents();
}


/***********************************************************************
 *
 * Assign an id and type to an input device.
 *
 */

void
AssignTypeAndName(DeviceIntPtr dev, Atom type, char *name)
{
    dev->xinput_type = type;
    dev->name = strdup(name);
}

/***********************************************************************
 *
 * Make device type atoms.
 *
 */

static void
MakeDeviceTypeAtoms(void)
{
    int i;

    for (i = 0; i < NUMTYPES; i++)
	dev_type[i].type =
	    MakeAtom(dev_type[i].name, strlen(dev_type[i].name), 1);
}

/*****************************************************************************
 *
 *	SEventIDispatch
 *
 *	Swap any events defined in this extension.
 */
#define DO_SWAP(func,type) func ((type *)from, (type *)to)

static void
SEventIDispatch(xEvent * from, xEvent * to)
{
    int type = from->u.u.type & 0177;

    if (type == DeviceValuator)
	DO_SWAP(SEventDeviceValuator, deviceValuator);
    else if (type == DeviceKeyPress) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceKeyRelease) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceButtonPress) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceButtonRelease) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceMotionNotify) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceFocusIn)
	DO_SWAP(SEventFocus, deviceFocus);
    else if (type == DeviceFocusOut)
	DO_SWAP(SEventFocus, deviceFocus);
    else if (type == ProximityIn) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == ProximityOut) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceStateNotify)
	DO_SWAP(SDeviceStateNotifyEvent, deviceStateNotify);
    else if (type == DeviceKeyStateNotify)
	DO_SWAP(SDeviceKeyStateNotifyEvent, deviceKeyStateNotify);
    else if (type == DeviceButtonStateNotify)
	DO_SWAP(SDeviceButtonStateNotifyEvent, deviceButtonStateNotify);
    else if (type == DeviceMappingNotify)
	DO_SWAP(SDeviceMappingNotifyEvent, deviceMappingNotify);
    else if (type == ChangeDeviceNotify)
	DO_SWAP(SChangeDeviceNotifyEvent, changeDeviceNotify);
    else if (type == DevicePresenceNotify)
	DO_SWAP(SDevicePresenceNotifyEvent, devicePresenceNotify);
    else if (type == DevicePropertyNotify)
	DO_SWAP(SDevicePropertyNotifyEvent, devicePropertyNotify);
    else {
	FatalError("XInputExtension: Impossible event!\n");
    }
}

/**********************************************************************
 *
 * IExtensionInit - initialize the input extension.
 *
 * Called from InitExtensions in main() or from QueryExtension() if the
 * extension is dynamically loaded.
 *
 * This extension has several events and errors.
 *
 * XI is mandatory nowadays, so if we fail to init XI, we die.
 */

void
XInputExtensionInit(void)
{
    ExtensionEntry *extEntry;
    XExtensionVersion thisversion = { XI_Present,
        SERVER_XI_MAJOR_VERSION,
        SERVER_XI_MINOR_VERSION,
    };

    if (!dixRegisterPrivateKey(&XIClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(XIClientRec)))
        FatalError("Cannot request private for XI.\n");

    if (!AddCallback(&ClientStateCallback, XIClientCallback, 0))
        FatalError("Failed to add callback to XI.\n");

    extEntry = AddExtension(INAME, IEVENTS, IERRORS, ProcIDispatch,
			    SProcIDispatch, IResetProc, StandardMinorOpcode);
    if (extEntry) {
	IReqCode = extEntry->base;
	IEventBase = extEntry->eventBase;
	XIVersion = thisversion;
	MakeDeviceTypeAtoms();
	RT_INPUTCLIENT = CreateNewResourceType((DeleteType) InputClientGone,
					       "INPUTCLIENT");
	if (!RT_INPUTCLIENT)
	    FatalError("Failed to add resource type for XI.\n");
	FixExtensionEvents(extEntry);
	ReplySwapVector[IReqCode] = (ReplySwapPtr) SReplyIDispatch;
	EventSwapVector[DeviceValuator] = SEventIDispatch;
	EventSwapVector[DeviceKeyPress] = SEventIDispatch;
	EventSwapVector[DeviceKeyRelease] = SEventIDispatch;
	EventSwapVector[DeviceButtonPress] = SEventIDispatch;
	EventSwapVector[DeviceButtonRelease] = SEventIDispatch;
	EventSwapVector[DeviceMotionNotify] = SEventIDispatch;
	EventSwapVector[DeviceFocusIn] = SEventIDispatch;
	EventSwapVector[DeviceFocusOut] = SEventIDispatch;
	EventSwapVector[ProximityIn] = SEventIDispatch;
	EventSwapVector[ProximityOut] = SEventIDispatch;
	EventSwapVector[DeviceStateNotify] = SEventIDispatch;
	EventSwapVector[DeviceKeyStateNotify] = SEventIDispatch;
	EventSwapVector[DeviceButtonStateNotify] = SEventIDispatch;
	EventSwapVector[DeviceMappingNotify] = SEventIDispatch;
	EventSwapVector[ChangeDeviceNotify] = SEventIDispatch;
	EventSwapVector[DevicePresenceNotify] = SEventIDispatch;

	GERegisterExtension(IReqCode, XI2EventSwap);


	memset(&xi_all_devices, 0, sizeof(xi_all_devices));
	memset(&xi_all_master_devices, 0, sizeof(xi_all_master_devices));
	xi_all_devices.id = XIAllDevices;
	xi_all_devices.name = "XIAllDevices";
	xi_all_master_devices.id = XIAllMasterDevices;
	xi_all_master_devices.name = "XIAllMasterDevices";

	inputInfo.all_devices = &xi_all_devices;
	inputInfo.all_master_devices = &xi_all_master_devices;

	XIResetProperties();
    } else {
	FatalError("IExtensionInit: AddExtensions failed\n");
    }
}

/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to return the version of the extension.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "getbmap.h"

/***********************************************************************
 *
 * This procedure gets the button mapping for the specified device.
 *
 */

int
SProcXGetDeviceButtonMapping(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceButtonMappingReq);
    swaps(&stuff->length, n);
    return (ProcXGetDeviceButtonMapping(client));
}

/***********************************************************************
 *
 * This procedure gets the button mapping for the specified device.
 *
 */

int
ProcXGetDeviceButtonMapping(ClientPtr client)
{
    DeviceIntPtr dev;
    xGetDeviceButtonMappingReply rep;
    ButtonClassPtr b;
    int rc;

    REQUEST(xGetDeviceButtonMappingReq);
    REQUEST_SIZE_MATCH(xGetDeviceButtonMappingReq);

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceButtonMapping;
    rep.nElts = 0;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    b = dev->button;
    if (b == NULL)
	return BadMatch;

    rep.nElts = b->numButtons;
    rep.length = bytes_to_int32(rep.nElts);
    WriteReplyToClient(client, sizeof(xGetDeviceButtonMappingReply), &rep);
    (void)WriteToClient(client, rep.nElts, (char *)&b->map[1]);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceButtonMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceButtonMapping(ClientPtr client, int size,
			    xGetDeviceButtonMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETBMAP_H
#define GETBMAP_H 1

int SProcXGetDeviceButtonMapping(ClientPtr	/* client */
    );

int ProcXGetDeviceButtonMapping(ClientPtr	/* client */
    );

void SRepXGetDeviceButtonMapping(ClientPtr /* client */ ,
				 int /* size */ ,
				 xGetDeviceButtonMappingReply *	/* rep */
    );

#endif /* GETBMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Get Device control attributes for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "getdctl.h"

/***********************************************************************
 *
 * This procedure gets the control attributes for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXGetDeviceControl(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceControlReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGetDeviceControlReq);
    swaps(&stuff->control, n);
    return (ProcXGetDeviceControl(client));
}

/***********************************************************************
 *
 * This procedure copies DeviceResolution data, swapping if necessary.
 *
 */

static void
CopySwapDeviceResolution(ClientPtr client, ValuatorClassPtr v, char *buf,
			 int length)
{
    char n;
    AxisInfoPtr a;
    xDeviceResolutionState *r;
    int i, *iptr;

    r = (xDeviceResolutionState *) buf;
    r->control = DEVICE_RESOLUTION;
    r->length = length;
    r->num_valuators = v->numAxes;
    buf += sizeof(xDeviceResolutionState);
    iptr = (int *)buf;
    for (i = 0, a = v->axes; i < v->numAxes; i++, a++)
	*iptr++ = a->resolution;
    for (i = 0, a = v->axes; i < v->numAxes; i++, a++)
	*iptr++ = a->min_resolution;
    for (i = 0, a = v->axes; i < v->numAxes; i++, a++)
	*iptr++ = a->max_resolution;
    if (client->swapped) {
	swaps(&r->control, n);
	swaps(&r->length, n);
	swapl(&r->num_valuators, n);
	iptr = (int *)buf;
	for (i = 0; i < (3 * v->numAxes); i++, iptr++) {
	    swapl(iptr, n);
	}
    }
}

static void CopySwapDeviceCore (ClientPtr client, DeviceIntPtr dev, char *buf)
{
    char n;
    xDeviceCoreState *c = (xDeviceCoreState *) buf;

    c->control = DEVICE_CORE;
    c->length = sizeof(xDeviceCoreState);
    c->status = dev->coreEvents;
    c->iscore = (dev == inputInfo.keyboard || dev == inputInfo.pointer);

    if (client->swapped) {
        swaps(&c->control, n);
        swaps(&c->length, n);
        swaps(&c->status, n);
    }
}

static void CopySwapDeviceEnable (ClientPtr client, DeviceIntPtr dev, char *buf)
{
    char n;
    xDeviceEnableState *e = (xDeviceEnableState *) buf;

    e->control = DEVICE_ENABLE;
    e->length = sizeof(xDeviceEnableState);
    e->enable = dev->enabled;

    if (client->swapped) {
        swaps(&e->control, n);
        swaps(&e->length, n);
        swaps(&e->enable, n);
    }
}

/***********************************************************************
 *
 * This procedure writes the reply for the xGetDeviceControl function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceControl(ClientPtr client, int size, xGetDeviceControlReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}

/***********************************************************************
 *
 * Get the state of the specified device control.
 *
 */

int
ProcXGetDeviceControl(ClientPtr client)
{
    int rc, total_length = 0;
    char *buf, *savbuf;
    DeviceIntPtr dev;
    xGetDeviceControlReply rep;

    REQUEST(xGetDeviceControlReq);
    REQUEST_SIZE_MATCH(xGetDeviceControlReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceControl;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    switch (stuff->control) {
    case DEVICE_RESOLUTION:
	if (!dev->valuator)
	    return BadMatch;
	total_length = sizeof(xDeviceResolutionState) +
	    (3 * sizeof(int) * dev->valuator->numAxes);
	break;
    case DEVICE_ABS_CALIB:
    case DEVICE_ABS_AREA:
        return BadMatch;
    case DEVICE_CORE:
        total_length = sizeof(xDeviceCoreState);
        break;
    case DEVICE_ENABLE:
        total_length = sizeof(xDeviceEnableState);
        break;
    default:
	return BadValue;
    }

    buf = (char *)malloc(total_length);
    if (!buf)
	return BadAlloc;
    savbuf = buf;

    switch (stuff->control) {
    case DEVICE_RESOLUTION:
	CopySwapDeviceResolution(client, dev->valuator, buf, total_length);
	break;
    case DEVICE_CORE:
        CopySwapDeviceCore(client, dev, buf);
        break;
    case DEVICE_ENABLE:
        CopySwapDeviceEnable(client, dev, buf);
        break;
    default:
	break;
    }

    rep.length = bytes_to_int32(total_length);
    WriteReplyToClient(client, sizeof(xGetDeviceControlReply), &rep);
    WriteToClient(client, total_length, savbuf);
    free(savbuf);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETDCTL_H
#define GETDCTL_H 1

int SProcXGetDeviceControl(ClientPtr	/* client */
    );

int ProcXGetDeviceControl(ClientPtr	/* client */
    );

void SRepXGetDeviceControl(ClientPtr /* client */ ,
			   int /* size */ ,
			   xGetDeviceControlReply *	/* rep */
    );

#endif /* GETDCTL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Get feedback control attributes for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "getfctl.h"

/***********************************************************************
 *
 * This procedure gets the control attributes for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXGetFeedbackControl(ClientPtr client)
{
    char n;

    REQUEST(xGetFeedbackControlReq);
    swaps(&stuff->length, n);
    return (ProcXGetFeedbackControl(client));
}

/***********************************************************************
 *
 * This procedure copies KbdFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapKbdFeedback(ClientPtr client, KbdFeedbackPtr k, char **buf)
{
    int i;
    char n;
    xKbdFeedbackState *k2;

    k2 = (xKbdFeedbackState *) * buf;
    k2->class = KbdFeedbackClass;
    k2->length = sizeof(xKbdFeedbackState);
    k2->id = k->ctrl.id;
    k2->click = k->ctrl.click;
    k2->percent = k->ctrl.bell;
    k2->pitch = k->ctrl.bell_pitch;
    k2->duration = k->ctrl.bell_duration;
    k2->led_mask = k->ctrl.leds;
    k2->global_auto_repeat = k->ctrl.autoRepeat;
    for (i = 0; i < 32; i++)
	k2->auto_repeats[i] = k->ctrl.autoRepeats[i];
    if (client->swapped) {
	swaps(&k2->length, n);
	swaps(&k2->pitch, n);
	swaps(&k2->duration, n);
	swapl(&k2->led_mask, n);
	swapl(&k2->led_values, n);
    }
    *buf += sizeof(xKbdFeedbackState);
}

/***********************************************************************
 *
 * This procedure copies PtrFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapPtrFeedback(ClientPtr client, PtrFeedbackPtr p, char **buf)
{
    char n;
    xPtrFeedbackState *p2;

    p2 = (xPtrFeedbackState *) * buf;
    p2->class = PtrFeedbackClass;
    p2->length = sizeof(xPtrFeedbackState);
    p2->id = p->ctrl.id;
    p2->accelNum = p->ctrl.num;
    p2->accelDenom = p->ctrl.den;
    p2->threshold = p->ctrl.threshold;
    if (client->swapped) {
	swaps(&p2->length, n);
	swaps(&p2->accelNum, n);
	swaps(&p2->accelDenom, n);
	swaps(&p2->threshold, n);
    }
    *buf += sizeof(xPtrFeedbackState);
}

/***********************************************************************
 *
 * This procedure copies IntegerFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapIntegerFeedback(ClientPtr client, IntegerFeedbackPtr i, char **buf)
{
    char n;
    xIntegerFeedbackState *i2;

    i2 = (xIntegerFeedbackState *) * buf;
    i2->class = IntegerFeedbackClass;
    i2->length = sizeof(xIntegerFeedbackState);
    i2->id = i->ctrl.id;
    i2->resolution = i->ctrl.resolution;
    i2->min_value = i->ctrl.min_value;
    i2->max_value = i->ctrl.max_value;
    if (client->swapped) {
	swaps(&i2->length, n);
	swapl(&i2->resolution, n);
	swapl(&i2->min_value, n);
	swapl(&i2->max_value, n);
    }
    *buf += sizeof(xIntegerFeedbackState);
}

/***********************************************************************
 *
 * This procedure copies StringFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapStringFeedback(ClientPtr client, StringFeedbackPtr s, char **buf)
{
    int i;
    char n;
    xStringFeedbackState *s2;
    KeySym *kptr;

    s2 = (xStringFeedbackState *) * buf;
    s2->class = StringFeedbackClass;
    s2->length = sizeof(xStringFeedbackState) +
	s->ctrl.num_symbols_supported * sizeof(KeySym);
    s2->id = s->ctrl.id;
    s2->max_symbols = s->ctrl.max_symbols;
    s2->num_syms_supported = s->ctrl.num_symbols_supported;
    *buf += sizeof(xStringFeedbackState);
    kptr = (KeySym *) (*buf);
    for (i = 0; i < s->ctrl.num_symbols_supported; i++)
	*kptr++ = *(s->ctrl.symbols_supported + i);
    if (client->swapped) {
	swaps(&s2->length, n);
	swaps(&s2->max_symbols, n);
	swaps(&s2->num_syms_supported, n);
	kptr = (KeySym *) (*buf);
	for (i = 0; i < s->ctrl.num_symbols_supported; i++, kptr++) {
	    swapl(kptr, n);
	}
    }
    *buf += (s->ctrl.num_symbols_supported * sizeof(KeySym));
}

/***********************************************************************
 *
 * This procedure copies LedFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapLedFeedback(ClientPtr client, LedFeedbackPtr l, char **buf)
{
    char n;
    xLedFeedbackState *l2;

    l2 = (xLedFeedbackState *) * buf;
    l2->class = LedFeedbackClass;
    l2->length = sizeof(xLedFeedbackState);
    l2->id = l->ctrl.id;
    l2->led_values = l->ctrl.led_values;
    l2->led_mask = l->ctrl.led_mask;
    if (client->swapped) {
	swaps(&l2->length, n);
	swapl(&l2->led_values, n);
	swapl(&l2->led_mask, n);
    }
    *buf += sizeof(xLedFeedbackState);
}

/***********************************************************************
 *
 * This procedure copies BellFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapBellFeedback(ClientPtr client, BellFeedbackPtr b, char **buf)
{
    char n;
    xBellFeedbackState *b2;

    b2 = (xBellFeedbackState *) * buf;
    b2->class = BellFeedbackClass;
    b2->length = sizeof(xBellFeedbackState);
    b2->id = b->ctrl.id;
    b2->percent = b->ctrl.percent;
    b2->pitch = b->ctrl.pitch;
    b2->duration = b->ctrl.duration;
    if (client->swapped) {
	swaps(&b2->length, n);
	swaps(&b2->pitch, n);
	swaps(&b2->duration, n);
    }
    *buf += sizeof(xBellFeedbackState);
}

/***********************************************************************
 *
 * This procedure writes the reply for the xGetFeedbackControl function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetFeedbackControl(ClientPtr client, int size,
			xGetFeedbackControlReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_feedbacks, n);
    WriteToClient(client, size, (char *)rep);
}

/***********************************************************************
 *
 * Get the feedback control state.
 *
 */

int
ProcXGetFeedbackControl(ClientPtr client)
{
    int rc, total_length = 0;
    char *buf, *savbuf;
    DeviceIntPtr dev;
    KbdFeedbackPtr k;
    PtrFeedbackPtr p;
    IntegerFeedbackPtr i;
    StringFeedbackPtr s;
    BellFeedbackPtr b;
    LedFeedbackPtr l;
    xGetFeedbackControlReply rep;

    REQUEST(xGetFeedbackControlReq);
    REQUEST_SIZE_MATCH(xGetFeedbackControlReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    rep.repType = X_Reply;
    rep.RepType = X_GetFeedbackControl;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.num_feedbacks = 0;

    for (k = dev->kbdfeed; k; k = k->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xKbdFeedbackState);
    }
    for (p = dev->ptrfeed; p; p = p->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xPtrFeedbackState);
    }
    for (s = dev->stringfeed; s; s = s->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xStringFeedbackState) +
	    (s->ctrl.num_symbols_supported * sizeof(KeySym));
    }
    for (i = dev->intfeed; i; i = i->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xIntegerFeedbackState);
    }
    for (l = dev->leds; l; l = l->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xLedFeedbackState);
    }
    for (b = dev->bell; b; b = b->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xBellFeedbackState);
    }

    if (total_length == 0)
	return BadMatch;

    buf = (char *)malloc(total_length);
    if (!buf)
	return BadAlloc;
    savbuf = buf;

    for (k = dev->kbdfeed; k; k = k->next)
	CopySwapKbdFeedback(client, k, &buf);
    for (p = dev->ptrfeed; p; p = p->next)
	CopySwapPtrFeedback(client, p, &buf);
    for (s = dev->stringfeed; s; s = s->next)
	CopySwapStringFeedback(client, s, &buf);
    for (i = dev->intfeed; i; i = i->next)
	CopySwapIntegerFeedback(client, i, &buf);
    for (l = dev->leds; l; l = l->next)
	CopySwapLedFeedback(client, l, &buf);
    for (b = dev->bell; b; b = b->next)
	CopySwapBellFeedback(client, b, &buf);

    rep.length = bytes_to_int32(total_length);
    WriteReplyToClient(client, sizeof(xGetFeedbackControlReply), &rep);
    WriteToClient(client, total_length, savbuf);
    free(savbuf);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETFCTL_H
#define GETFCTL_H 1

int SProcXGetFeedbackControl(ClientPtr	/* client */
    );

int ProcXGetFeedbackControl(ClientPtr	/* client */
    );

void SRepXGetFeedbackControl(ClientPtr /* client */ ,
			     int /* size */ ,
			     xGetFeedbackControlReply *	/* rep */
    );

#endif /* GETFCTL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to get the focus for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "windowstr.h"	/* focus struct      */
#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "getfocus.h"

/***********************************************************************
 *
 * This procedure gets the focus for a device.
 *
 */

int
SProcXGetDeviceFocus(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceFocusReq);
    swaps(&stuff->length, n);
    return (ProcXGetDeviceFocus(client));
}

/***********************************************************************
 *
 * This procedure gets the focus for a device.
 *
 */

int
ProcXGetDeviceFocus(ClientPtr client)
{
    DeviceIntPtr dev;
    FocusClassPtr focus;
    xGetDeviceFocusReply rep;
    int rc;

    REQUEST(xGetDeviceFocusReq);
    REQUEST_SIZE_MATCH(xGetDeviceFocusReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetFocusAccess);
    if (rc != Success)
	return rc;
    if (!dev->focus)
	return BadDevice;

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceFocus;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    focus = dev->focus;

    if (focus->win == NoneWin)
	rep.focus = None;
    else if (focus->win == PointerRootWin)
	rep.focus = PointerRoot;
    else if (focus->win == FollowKeyboardWin)
	rep.focus = FollowKeyboard;
    else
	rep.focus = focus->win->drawable.id;

    rep.time = focus->time.milliseconds;
    rep.revertTo = focus->revert;
    WriteReplyToClient(client, sizeof(xGetDeviceFocusReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the GetDeviceFocus function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceFocus(ClientPtr client, int size, xGetDeviceFocusReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->focus, n);
    swapl(&rep->time, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETFOCUS_H
#define GETFOCUS_H 1

int SProcXGetDeviceFocus(ClientPtr	/* client */
    );

int ProcXGetDeviceFocus(ClientPtr	/* client */
    );

void SRepXGetDeviceFocus(ClientPtr /* client */ ,
			 int /* size */ ,
			 xGetDeviceFocusReply *	/* rep */
    );

#endif /* GETFOCUS_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Get the key mapping for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "swaprep.h"
#include "xkbsrv.h"
#include "xkbstr.h"

#include "getkmap.h"

/***********************************************************************
 *
 * This procedure gets the key mapping for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXGetDeviceKeyMapping(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceKeyMappingReq);
    swaps(&stuff->length, n);
    return (ProcXGetDeviceKeyMapping(client));
}

/***********************************************************************
 *
 * Get the device key mapping.
 *
 */

int
ProcXGetDeviceKeyMapping(ClientPtr client)
{
    xGetDeviceKeyMappingReply rep;
    DeviceIntPtr dev;
    XkbDescPtr xkb;
    KeySymsPtr syms;
    int rc;

    REQUEST(xGetDeviceKeyMappingReq);
    REQUEST_SIZE_MATCH(xGetDeviceKeyMappingReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    if (dev->key == NULL)
	return BadMatch;
    xkb = dev->key->xkbInfo->desc;

    if (stuff->firstKeyCode < xkb->min_key_code ||
	stuff->firstKeyCode > xkb->max_key_code) {
	client->errorValue = stuff->firstKeyCode;
	return BadValue;
    }

    if (stuff->firstKeyCode + stuff->count > xkb->max_key_code + 1) {
	client->errorValue = stuff->count;
	return BadValue;
    }

    syms = XkbGetCoreMap(dev);
    if (!syms)
        return BadAlloc;

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceKeyMapping;
    rep.sequenceNumber = client->sequence;
    rep.keySymsPerKeyCode = syms->mapWidth;
    rep.length = (syms->mapWidth * stuff->count);	/* KeySyms are 4 bytes */
    WriteReplyToClient(client, sizeof(xGetDeviceKeyMappingReply), &rep);

    client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
    WriteSwappedDataToClient(client,
                             syms->mapWidth * stuff->count * sizeof(KeySym),
                             &syms->map[syms->mapWidth * (stuff->firstKeyCode -
                                                          syms->minKeyCode)]);
    free(syms->map);
    free(syms);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceKeyMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceKeyMapping(ClientPtr client, int size,
			 xGetDeviceKeyMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETKMAP_H
#define GETKMAP_H 1

int SProcXGetDeviceKeyMapping(ClientPtr	/* client */
    );

int ProcXGetDeviceKeyMapping(ClientPtr	/* client */
    );

void SRepXGetDeviceKeyMapping(ClientPtr /* client */ ,
			      int /* size */ ,
			      xGetDeviceKeyMappingReply *	/* rep */
    );

#endif /* GETKMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Get the modifier mapping for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>	/* Request macro     */
#include "exglobals.h"

#include "getmmap.h"

/***********************************************************************
 *
 * This procedure gets the modifier mapping for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXGetDeviceModifierMapping(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceModifierMappingReq);
    swaps(&stuff->length, n);
    return (ProcXGetDeviceModifierMapping(client));
}

/***********************************************************************
 *
 * Get the device Modifier mapping.
 *
 */

int
ProcXGetDeviceModifierMapping(ClientPtr client)
{
    DeviceIntPtr dev;
    xGetDeviceModifierMappingReply rep;
    KeyCode *modkeymap = NULL;
    int ret, max_keys_per_mod;

    REQUEST(xGetDeviceModifierMappingReq);
    REQUEST_SIZE_MATCH(xGetDeviceModifierMappingReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (ret != Success)
	return ret;

    ret = generate_modkeymap(client, dev, &modkeymap, &max_keys_per_mod);
    if (ret != Success)
        return ret;

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceModifierMapping;
    rep.numKeyPerModifier = max_keys_per_mod;
    rep.sequenceNumber = client->sequence;
    /* length counts 4 byte quantities - there are 8 modifiers 1 byte big */
    rep.length = max_keys_per_mod << 1;

    WriteReplyToClient(client, sizeof(xGetDeviceModifierMappingReply), &rep);
    WriteToClient(client, max_keys_per_mod * 8, (char *) modkeymap);

    free(modkeymap);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceModifierMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceModifierMapping(ClientPtr client, int size,
			      xGetDeviceModifierMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETMMAP_H
#define GETMMAP_H 1

int SProcXGetDeviceModifierMapping(ClientPtr	/* client */
    );

int ProcXGetDeviceModifierMapping(ClientPtr	/* client */
    );

void SRepXGetDeviceModifierMapping(ClientPtr /* client */ ,
				   int /* size */ ,
				   xGetDeviceModifierMappingReply *	/* rep */
    );

#endif /* GETMMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Function to return the dont-propagate-list for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structs    */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "swaprep.h"

#include "getprop.h"

extern XExtEventInfo EventInfo[];
extern int ExtEventIndex;

/***********************************************************************
 *
 * Handle a request from a client with a different byte order.
 *
 */

int
SProcXGetDeviceDontPropagateList(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceDontPropagateListReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGetDeviceDontPropagateListReq);
    swapl(&stuff->window, n);
    return (ProcXGetDeviceDontPropagateList(client));
}

/***********************************************************************
 *
 * This procedure lists the input devices available to the server.
 *
 */

int
ProcXGetDeviceDontPropagateList(ClientPtr client)
{
    CARD16 count = 0;
    int i, rc;
    XEventClass *buf = NULL, *tbuf;
    WindowPtr pWin;
    xGetDeviceDontPropagateListReply rep;
    OtherInputMasks *others;

    REQUEST(xGetDeviceDontPropagateListReq);
    REQUEST_SIZE_MATCH(xGetDeviceDontPropagateListReq);

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceDontPropagateList;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.count = 0;

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    if ((others = wOtherInputMasks(pWin)) != 0) {
	for (i = 0; i < EMASKSIZE; i++)
	    ClassFromMask(NULL, others->dontPropagateMask[i], i,
				 &count, COUNT);
	if (count) {
	    rep.count = count;
	    buf = (XEventClass *) malloc(rep.count * sizeof(XEventClass));
	    rep.length = bytes_to_int32(rep.count * sizeof(XEventClass));

	    tbuf = buf;
	    for (i = 0; i < EMASKSIZE; i++)
		tbuf = ClassFromMask(tbuf, others->dontPropagateMask[i], i,
				     NULL, CREATE);
	}
    }

    WriteReplyToClient(client, sizeof(xGetDeviceDontPropagateListReply), &rep);

    if (count) {
	client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	WriteSwappedDataToClient(client, count * sizeof(XEventClass), buf);
	free(buf);
    }
    return Success;
}

/***********************************************************************
 *
 * This procedure gets a list of event classes from a mask word.
 * A single mask may translate to more than one event class.
 *
 */

XEventClass
    * ClassFromMask(XEventClass * buf, Mask mask, int maskndx, CARD16 * count,
		    int mode)
{
    int i, j;
    int id = maskndx;
    Mask tmask = 0x80000000;

    for (i = 0; i < 32; i++, tmask >>= 1)
	if (tmask & mask) {
	    for (j = 0; j < ExtEventIndex; j++)
		if (EventInfo[j].mask == tmask) {
		    if (mode == COUNT)
			(*count)++;
		    else
			*buf++ = (id << 8) | EventInfo[j].type;
		}
	}
    return buf;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceDontPropagateList function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceDontPropagateList(ClientPtr client, int size,
				xGetDeviceDontPropagateListReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->count, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETPROP_H
#define GETPROP_H 1

int SProcXGetDeviceDontPropagateList(ClientPtr	/* client */
    );

int ProcXGetDeviceDontPropagateList(ClientPtr	/* client */
    );

XEventClass *ClassFromMask(XEventClass * /* buf */ ,
			   Mask /* mask */ ,
			   int /* maskndx */ ,
			   CARD16 * /* count */ ,
			   int	/* mode */
    );

void SRepXGetDeviceDontPropagateList(ClientPtr /* client */ ,
				     int /* size */ ,
				     xGetDeviceDontPropagateListReply *	/* rep */
    );

#endif /* GETPROP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to get the current selected events for a given window.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window struct     */
#include "exglobals.h"
#include "swaprep.h"

#include "getprop.h"
#include "getselev.h"

/***********************************************************************
 *
 * This procedure gets the current selected extension events.
 *
 */

int
SProcXGetSelectedExtensionEvents(ClientPtr client)
{
    char n;

    REQUEST(xGetSelectedExtensionEventsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGetSelectedExtensionEventsReq);
    swapl(&stuff->window, n);
    return (ProcXGetSelectedExtensionEvents(client));
}

/***********************************************************************
 *
 * This procedure gets the current device select mask,
 * if the client and server have a different byte ordering.
 *
 */

int
ProcXGetSelectedExtensionEvents(ClientPtr client)
{
    int i, rc, total_length = 0;
    xGetSelectedExtensionEventsReply rep;
    WindowPtr pWin;
    XEventClass *buf = NULL;
    XEventClass *tclient;
    XEventClass *aclient;
    OtherInputMasks *pOthers;
    InputClientsPtr others;

    REQUEST(xGetSelectedExtensionEventsReq);
    REQUEST_SIZE_MATCH(xGetSelectedExtensionEventsReq);

    rep.repType = X_Reply;
    rep.RepType = X_GetSelectedExtensionEvents;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.this_client_count = 0;
    rep.all_clients_count = 0;

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    if ((pOthers = wOtherInputMasks(pWin)) != 0) {
	for (others = pOthers->inputClients; others; others = others->next)
	    for (i = 0; i < EMASKSIZE; i++)
		ClassFromMask(NULL, others->mask[i], i,
					&rep.all_clients_count, COUNT);

	for (others = pOthers->inputClients; others; others = others->next)
	    if (SameClient(others, client)) {
		for (i = 0; i < EMASKSIZE; i++)
		    ClassFromMask(NULL, others->mask[i], i,
					    &rep.this_client_count, COUNT);
		break;
	    }

	total_length = (rep.all_clients_count + rep.this_client_count) *
	    sizeof(XEventClass);
	rep.length = bytes_to_int32(total_length);
	buf = (XEventClass *) malloc(total_length);

	tclient = buf;
	aclient = buf + rep.this_client_count;
	if (others)
	    for (i = 0; i < EMASKSIZE; i++)
		tclient =
		    ClassFromMask(tclient, others->mask[i], i, NULL, CREATE);

	for (others = pOthers->inputClients; others; others = others->next)
	    for (i = 0; i < EMASKSIZE; i++)
		aclient =
		    ClassFromMask(aclient, others->mask[i], i, NULL, CREATE);
    }

    WriteReplyToClient(client, sizeof(xGetSelectedExtensionEventsReply), &rep);

    if (total_length) {
	client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	WriteSwappedDataToClient(client, total_length, buf);
    }
    free(buf);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetSelectedExtensionEvents function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetSelectedExtensionEvents(ClientPtr client, int size,
				xGetSelectedExtensionEventsReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->this_client_count, n);
    swaps(&rep->all_clients_count, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETSELEV_H
#define GETSELEV_H 1

int SProcXGetSelectedExtensionEvents(ClientPtr	/* client */
    );

int ProcXGetSelectedExtensionEvents(ClientPtr	/* client */
    );

void SRepXGetSelectedExtensionEvents(ClientPtr /* client */ ,
				     int /* size */ ,
				     xGetSelectedExtensionEventsReply *	/* rep */
    );

#endif /* GETSELEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to return the version of the extension.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "getvers.h"

XExtensionVersion XIVersion;

/***********************************************************************
 *
 * Handle a request from a client with a different byte order than us.
 *
 */

int
SProcXGetExtensionVersion(ClientPtr client)
{
    char n;

    REQUEST(xGetExtensionVersionReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xGetExtensionVersionReq);
    swaps(&stuff->nbytes, n);
    return (ProcXGetExtensionVersion(client));
}

/***********************************************************************
 *
 * This procedure returns the major/minor version of the X Input extension.
 *
 */

int
ProcXGetExtensionVersion(ClientPtr client)
{
    xGetExtensionVersionReply rep;

    REQUEST(xGetExtensionVersionReq);
    REQUEST_AT_LEAST_SIZE(xGetExtensionVersionReq);

    if (stuff->length != bytes_to_int32(sizeof(xGetExtensionVersionReq) +
			  stuff->nbytes))
	return BadLength;

    memset(&rep, 0, sizeof(xGetExtensionVersionReply));
    rep.repType = X_Reply;
    rep.RepType = X_GetExtensionVersion;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.present = TRUE;
    rep.major_version = XIVersion.major_version;
    rep.minor_version = XIVersion.minor_version;

    WriteReplyToClient(client, sizeof(xGetExtensionVersionReply), &rep);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetExtensionVersion function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetExtensionVersion(ClientPtr client, int size,
			 xGetExtensionVersionReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->major_version, n);
    swaps(&rep->minor_version, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETVERS_H
#define GETVERS_H 1

int SProcXGetExtensionVersion(ClientPtr	/* client */
    );

int ProcXGetExtensionVersion(ClientPtr	/* client */
    );

void SRepXGetExtensionVersion(ClientPtr /* client */ ,
			      int /* size */ ,
			      xGetExtensionVersionReply *	/* rep */
    );

#endif /* GETVERS_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to grab an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "dixevents.h"	/* GrabDevice */

#include "grabdev.h"

extern XExtEventInfo EventInfo[];
extern int ExtEventIndex;

/***********************************************************************
 *
 * Swap the request if the requestor has a different byte order than us.
 *
 */

int
SProcXGrabDevice(ClientPtr client)
{
    char n;

    REQUEST(xGrabDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceReq);
    swapl(&stuff->grabWindow, n);
    swapl(&stuff->time, n);
    swaps(&stuff->event_count, n);

    if (stuff->length != bytes_to_int32(sizeof(xGrabDeviceReq)) + stuff->event_count)
       return BadLength;
    
    SwapLongs((CARD32 *) (&stuff[1]), stuff->event_count);

    return (ProcXGrabDevice(client));
}

/***********************************************************************
 *
 * Grab an extension device.
 *
 */

int
ProcXGrabDevice(ClientPtr client)
{
    int rc;
    xGrabDeviceReply rep;
    DeviceIntPtr dev;
    GrabMask mask;
    struct tmask tmp[EMASKSIZE];

    REQUEST(xGrabDeviceReq);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceReq);

    if (stuff->length != bytes_to_int32(sizeof(xGrabDeviceReq)) + stuff->event_count)
	return BadLength;

    rep.repType = X_Reply;
    rep.RepType = X_GrabDevice;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
    if (rc != Success)
	return rc;

    if ((rc = CreateMaskFromList(client, (XEventClass *) & stuff[1],
				 stuff->event_count, tmp, dev,
				 X_GrabDevice)) != Success)
	return rc;

    mask.xi = tmp[stuff->deviceid].mask;

    rc = GrabDevice(client, dev, stuff->other_devices_mode,
                    stuff->this_device_mode, stuff->grabWindow,
		    stuff->ownerEvents, stuff->time,
		    &mask, GRABTYPE_XI, None, None,
		    &rep.status);

    if (rc != Success)
	return rc;

    WriteReplyToClient(client, sizeof(xGrabDeviceReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure creates an event mask from a list of XEventClasses.
 *
 * Procedure is as follows:
 * An XEventClass is (deviceid << 8 | eventtype). For each entry in the list,
 * get the device. Then run through all available event indices (those are
 * set when XI starts up) and binary OR's the device's mask to whatever the
 * event mask for the given event type was.
 * If an error occurs, it is sent to the client. Errors are generated if
 *  - if the device given in the event classs is invalid
 *  - if the device in the class list is not the device given as parameter (no
 *  error if parameter is NULL)
 *
 * mask has to be size EMASKSIZE and pre-allocated.
 *
 * @param client The client to send the error to (if one occurs)
 * @param list List of event classes as sent from the client.
 * @param count Number of elements in list.
 * @param mask Preallocated mask (size EMASKSIZE).
 * @param dev The device we're creating masks for.
 * @param req The request we're processing. Used to fill in error fields.
 */

int
CreateMaskFromList(ClientPtr client, XEventClass * list, int count,
		   struct tmask *mask, DeviceIntPtr dev, int req)
{
    int rc, i, j;
    int device;
    DeviceIntPtr tdev;

    for (i = 0; i < EMASKSIZE; i++) {
	mask[i].mask = 0;
	mask[i].dev = NULL;
    }

    for (i = 0; i < count; i++, list++) {
	device = *list >> 8;
	if (device > 255)
	    return BadClass;

	rc = dixLookupDevice(&tdev, device, client, DixUseAccess);
	if (rc != BadDevice && rc != Success)
	    return rc;
	if (rc == BadDevice || (dev != NULL && tdev != dev))
	    return BadClass;

	for (j = 0; j < ExtEventIndex; j++)
	    if (EventInfo[j].type == (*list & 0xff)) {
		mask[device].mask |= EventInfo[j].mask;
		mask[device].dev = (Pointer) tdev;
		break;
	    }
    }
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGrabDevice function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGrabDevice(ClientPtr client, int size, xGrabDeviceReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GRABDEV_H
#define GRABDEV_H 1

int SProcXGrabDevice(ClientPtr	/* client */
    );

int ProcXGrabDevice(ClientPtr	/* client */
    );

int CreateMaskFromList(ClientPtr /* client */ ,
		       XEventClass * /* list */ ,
		       int /* count */ ,
		       struct tmask /* mask */ [],
		       DeviceIntPtr /* dev */ ,
		       int	/* req */
    );

void SRepXGrabDevice(ClientPtr /* client */ ,
		     int /* size */ ,
		     xGrabDeviceReply *	/* rep */
    );

#endif /* GRABDEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to grab a button on an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"
#include "xace.h"

#include "grabdev.h"
#include "grabdevb.h"

/***********************************************************************
 *
 * Handle requests from clients with a different byte order.
 *
 */

int
SProcXGrabDeviceButton(ClientPtr client)
{
    char n;

    REQUEST(xGrabDeviceButtonReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceButtonReq);
    swapl(&stuff->grabWindow, n);
    swaps(&stuff->modifiers, n);
    swaps(&stuff->event_count, n);
    REQUEST_FIXED_SIZE(xGrabDeviceButtonReq,
                      stuff->event_count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), stuff->event_count);

    return (ProcXGrabDeviceButton(client));
}

/***********************************************************************
 *
 * Grab a button on an extension device.
 *
 */

int
ProcXGrabDeviceButton(ClientPtr client)
{
    int ret;
    DeviceIntPtr dev;
    DeviceIntPtr mdev;
    XEventClass *class;
    struct tmask tmp[EMASKSIZE];
    GrabParameters param;
    GrabMask mask;

    REQUEST(xGrabDeviceButtonReq);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceButtonReq);

    if (stuff->length !=
	bytes_to_int32(sizeof(xGrabDeviceButtonReq)) + stuff->event_count)
	return BadLength;

    ret = dixLookupDevice(&dev, stuff->grabbed_device, client, DixGrabAccess);
    if (ret != Success)
	return ret;

    if (stuff->modifier_device != UseXKeyboard) {
	ret = dixLookupDevice(&mdev, stuff->modifier_device, client,
			      DixUseAccess);
	if (ret != Success)
	    return ret;
	if (mdev->key == NULL)
	    return BadMatch;
    } else {
	mdev = PickKeyboard(client);
	ret = XaceHook(XACE_DEVICE_ACCESS, client, mdev, DixUseAccess);
	if (ret != Success)
	    return ret;
    }

    class = (XEventClass *) (&stuff[1]);	/* first word of values */

    if ((ret = CreateMaskFromList(client, class,
				  stuff->event_count, tmp, dev,
				  X_GrabDeviceButton)) != Success)
	return ret;

    memset(&param, 0, sizeof(param));
    param.grabtype = GRABTYPE_XI;
    param.ownerEvents = stuff->ownerEvents;
    param.this_device_mode = stuff->this_device_mode;
    param.other_devices_mode = stuff->other_devices_mode;
    param.grabWindow = stuff->grabWindow;
    param.modifiers = stuff->modifiers;
    mask.xi = tmp[stuff->grabbed_device].mask;

    ret = GrabButton(client, dev, mdev, stuff->button, &param,
                     GRABTYPE_XI, &mask);

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GRABDEVB_H
#define GRABDEVB_H 1

int SProcXGrabDeviceButton(ClientPtr	/* client */
    );

int ProcXGrabDeviceButton(ClientPtr	/* client */
    );

#endif /* GRABDEVB_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to grab a key on an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"
#include "xace.h"

#include "grabdev.h"
#include "grabdevk.h"

/***********************************************************************
 *
 * Handle requests from clients with a different byte order.
 *
 */

int
SProcXGrabDeviceKey(ClientPtr client)
{
    char n;

    REQUEST(xGrabDeviceKeyReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceKeyReq);
    swapl(&stuff->grabWindow, n);
    swaps(&stuff->modifiers, n);
    swaps(&stuff->event_count, n);
    REQUEST_FIXED_SIZE(xGrabDeviceKeyReq, stuff->event_count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), stuff->event_count);
    return (ProcXGrabDeviceKey(client));
}

/***********************************************************************
 *
 * Grab a key on an extension device.
 *
 */

int
ProcXGrabDeviceKey(ClientPtr client)
{
    int ret;
    DeviceIntPtr dev;
    DeviceIntPtr mdev;
    XEventClass *class;
    struct tmask tmp[EMASKSIZE];
    GrabParameters param;
    GrabMask mask;

    REQUEST(xGrabDeviceKeyReq);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceKeyReq);

    if (stuff->length != bytes_to_int32(sizeof(xGrabDeviceKeyReq)) + stuff->event_count)
	return BadLength;

    ret = dixLookupDevice(&dev, stuff->grabbed_device, client, DixGrabAccess);
    if (ret != Success)
	return ret;

    if (stuff->modifier_device != UseXKeyboard) {
	ret = dixLookupDevice(&mdev, stuff->modifier_device, client,
			      DixUseAccess);
	if (ret != Success)
	    return ret;
	if (mdev->key == NULL)
	    return BadMatch;
    } else {
	mdev = PickKeyboard(client);
	ret = XaceHook(XACE_DEVICE_ACCESS, client, mdev, DixUseAccess);
	if (ret != Success)
	    return ret;
    }

    class = (XEventClass *) (&stuff[1]);	/* first word of values */

    if ((ret = CreateMaskFromList(client, class,
				  stuff->event_count, tmp, dev,
				  X_GrabDeviceKey)) != Success)
	return ret;


    memset(&param, 0, sizeof(param));
    param.grabtype = GRABTYPE_XI;
    param.ownerEvents = stuff->ownerEvents;
    param.this_device_mode = stuff->this_device_mode;
    param.other_devices_mode = stuff->other_devices_mode;
    param.grabWindow = stuff->grabWindow;
    param.modifiers = stuff->modifiers;
    mask.xi = tmp[stuff->grabbed_device].mask;

    ret = GrabKey(client, dev, mdev, stuff->key, &param, GRABTYPE_XI, &mask);

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GRABDEVK_H
#define GRABDEVK_H 1

int SProcXGrabDeviceKey(ClientPtr	/* client */
    );

int ProcXGrabDeviceKey(ClientPtr	/* client */
    );

#endif /* GRABDEVK_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to get the motion history from an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "gtmotion.h"

/***********************************************************************
 *
 * Swap the request if server and client have different byte ordering.
 *
 */

int
SProcXGetDeviceMotionEvents(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceMotionEventsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGetDeviceMotionEventsReq);
    swapl(&stuff->start, n);
    swapl(&stuff->stop, n);
    return (ProcXGetDeviceMotionEvents(client));
}

/****************************************************************************
 *
 * Get the motion history for an extension pointer devices.
 *
 */

int
ProcXGetDeviceMotionEvents(ClientPtr client)
{
    INT32 *coords = NULL, *bufptr;
    xGetDeviceMotionEventsReply rep;
    unsigned long i;
    int rc, num_events, axes, size = 0;
    unsigned long nEvents;
    DeviceIntPtr dev;
    TimeStamp start, stop;
    int length = 0;
    ValuatorClassPtr v;

    REQUEST(xGetDeviceMotionEventsReq);

    REQUEST_SIZE_MATCH(xGetDeviceMotionEventsReq);
    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixReadAccess);
    if (rc != Success)
	return rc;
    v = dev->valuator;
    if (v == NULL || v->numAxes == 0)
	return BadMatch;
    if (dev->valuator->motionHintWindow)
	MaybeStopDeviceHint(dev, client);
    axes = v->numAxes;
    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceMotionEvents;
    rep.sequenceNumber = client->sequence;
    rep.nEvents = 0;
    rep.axes = axes;
    rep.mode = Absolute; /* XXX we don't do relative at the moment */
    rep.length = 0;
    start = ClientTimeToServerTime(stuff->start);
    stop = ClientTimeToServerTime(stuff->stop);
    if (CompareTimeStamps(start, stop) == LATER ||
	CompareTimeStamps(start, currentTime) == LATER) {
	WriteReplyToClient(client, sizeof(xGetDeviceMotionEventsReply), &rep);
	return Success;
    }
    if (CompareTimeStamps(stop, currentTime) == LATER)
	stop = currentTime;
    num_events = v->numMotionEvents;
    if (num_events) {
        size = sizeof(Time) + (axes * sizeof(INT32));
	rep.nEvents = GetMotionHistory(dev, (xTimecoord **) &coords,/* XXX */
					start.milliseconds, stop.milliseconds,
					(ScreenPtr) NULL, FALSE);
    }
    if (rep.nEvents > 0) {
	length = bytes_to_int32(rep.nEvents * size);
	rep.length = length;
    }
    nEvents = rep.nEvents;
    WriteReplyToClient(client, sizeof(xGetDeviceMotionEventsReply), &rep);
    if (nEvents) {
	if (client->swapped) {
	    char n;

	    bufptr = coords;
	    for (i = 0; i < nEvents * (axes + 1); i++) {
		swapl(bufptr, n);
		bufptr++;
	    }
	}
	WriteToClient(client, length * 4, (char *)coords);
    }
    free(coords);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceMotionEvents function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceMotionEvents(ClientPtr client, int size,
			   xGetDeviceMotionEventsReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->nEvents, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GTMOTION_H
#define GTMOTION_H 1

int SProcXGetDeviceMotionEvents(ClientPtr	/* client */
    );

int ProcXGetDeviceMotionEvents(ClientPtr	/* client */
    );

void SRepXGetDeviceMotionEvents(ClientPtr /* client */ ,
				int /* size */ ,
				xGetDeviceMotionEventsReply *	/* rep */
    );

#endif /* GTMOTION_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to list the available input devices.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "extnsionst.h"
#include "exevents.h"
#include "xace.h"
#include "xkbsrv.h"
#include "xkbstr.h"

#include "listdev.h"


/***********************************************************************
 *
 * This procedure lists the input devices available to the server.
 *
 */

int
SProcXListInputDevices(ClientPtr client)
{
    char n;

    REQUEST(xListInputDevicesReq);
    swaps(&stuff->length, n);
    return (ProcXListInputDevices(client));
}

/***********************************************************************
 *
 * This procedure calculates the size of the information to be returned
 * for an input device.
 *
 */

static void
SizeDeviceInfo(DeviceIntPtr d, int *namesize, int *size)
{
    int chunks;

    *namesize += 1;
    if (d->name)
	*namesize += strlen(d->name);
    if (d->key != NULL)
	*size += sizeof(xKeyInfo);
    if (d->button != NULL)
	*size += sizeof(xButtonInfo);
    if (d->valuator != NULL) {
	chunks = ((int)d->valuator->numAxes + 19) / VPC;
	*size += (chunks * sizeof(xValuatorInfo) +
		  d->valuator->numAxes * sizeof(xAxisInfo));
    }
}

/***********************************************************************
 *
 * This procedure copies data to the DeviceInfo struct, swapping if necessary.
 *
 * We need the extra byte in the allocated buffer, because the trailing null
 * hammers one extra byte, which is overwritten by the next name except for
 * the last name copied.
 *
 */

static void
CopyDeviceName(char **namebuf, char *name)
{
    char *nameptr = (char *)*namebuf;

    if (name) {
	*nameptr++ = strlen(name);
	strcpy(nameptr, name);
	*namebuf += (strlen(name) + 1);
    } else {
	*nameptr++ = 0;
	*namebuf += 1;
    }
}

/***********************************************************************
 *
 * This procedure copies ButtonClass information, swapping if necessary.
 *
 */

static void
CopySwapButtonClass(ClientPtr client, ButtonClassPtr b, char **buf)
{
    char n;
    xButtonInfoPtr b2;

    b2 = (xButtonInfoPtr) * buf;
    b2->class = ButtonClass;
    b2->length = sizeof(xButtonInfo);
    b2->num_buttons = b->numButtons;
    if (client && client->swapped) {
	swaps(&b2->num_buttons, n);	/* macro - braces are required */
    }
    *buf += sizeof(xButtonInfo);
}

/***********************************************************************
 *
 * This procedure copies data to the DeviceInfo struct, swapping if necessary.
 *
 */

static void
CopySwapDevice(ClientPtr client, DeviceIntPtr d, int num_classes,
	       char **buf)
{
    char n;
    xDeviceInfoPtr dev;

    dev = (xDeviceInfoPtr) * buf;

    dev->id = d->id;
    dev->type = d->xinput_type;
    dev->num_classes = num_classes;
    if (IsMaster(d) && IsKeyboardDevice(d))
	dev->use = IsXKeyboard;
    else if (IsMaster(d) && IsPointerDevice(d))
	dev->use = IsXPointer;
    else if (d->valuator && d->button)
        dev->use = IsXExtensionPointer;
    else if (d->key && d->kbdfeed)
        dev->use = IsXExtensionKeyboard;
    else
	dev->use = IsXExtensionDevice;

    if (client->swapped) {
	swapl(&dev->type, n);	/* macro - braces are required */
    }
    *buf += sizeof(xDeviceInfo);
}

/***********************************************************************
 *
 * This procedure copies KeyClass information, swapping if necessary.
 *
 */

static void
CopySwapKeyClass(ClientPtr client, KeyClassPtr k, char **buf)
{
    char n;
    xKeyInfoPtr k2;

    k2 = (xKeyInfoPtr) * buf;
    k2->class = KeyClass;
    k2->length = sizeof(xKeyInfo);
    k2->min_keycode = k->xkbInfo->desc->min_key_code;
    k2->max_keycode = k->xkbInfo->desc->max_key_code;
    k2->num_keys = k2->max_keycode - k2->min_keycode + 1;
    if (client && client->swapped) {
	swaps(&k2->num_keys, n);
    }
    *buf += sizeof(xKeyInfo);
}

/***********************************************************************
 *
 * This procedure copies ValuatorClass information, swapping if necessary.
 *
 * Devices may have up to 255 valuators.  The length of a ValuatorClass is
 * defined to be sizeof(ValuatorClassInfo) + num_axes * sizeof (xAxisInfo).
 * The maximum length is therefore (8 + 255 * 12) = 3068.  However, the
 * length field is one byte.  If a device has more than 20 valuators, we
 * must therefore return multiple valuator classes to the client.
 *
 */

static int
CopySwapValuatorClass(ClientPtr client, DeviceIntPtr dev, char **buf)
{
    int i, j, axes, t_axes;
    char n;
    ValuatorClassPtr v = dev->valuator;
    xValuatorInfoPtr v2;
    AxisInfo *a;
    xAxisInfoPtr a2;

    for (i = 0, axes = v->numAxes; i < ((v->numAxes + 19) / VPC);
	 i++, axes -= VPC) {
	t_axes = axes < VPC ? axes : VPC;
	if (t_axes < 0)
	    t_axes = v->numAxes % VPC;
	v2 = (xValuatorInfoPtr) * buf;
	v2->class = ValuatorClass;
	v2->length = sizeof(xValuatorInfo) + t_axes * sizeof(xAxisInfo);
	v2->num_axes = t_axes;
	v2->mode = valuator_get_mode(dev, 0);
	v2->motion_buffer_size = v->numMotionEvents;
	if (client && client->swapped) {
	    swapl(&v2->motion_buffer_size, n);
	}
	*buf += sizeof(xValuatorInfo);
	a = v->axes + (VPC * i);
	a2 = (xAxisInfoPtr) * buf;
	for (j = 0; j < t_axes; j++) {
	    a2->min_value = a->min_value;
	    a2->max_value = a->max_value;
	    a2->resolution = a->resolution;
	    if (client && client->swapped) {
		swapl(&a2->min_value, n);
		swapl(&a2->max_value, n);
		swapl(&a2->resolution, n);
	    }
	    a2++;
	    a++;
	    *buf += sizeof(xAxisInfo);
	}
    }
    return i;
}

static void
CopySwapClasses(ClientPtr client, DeviceIntPtr dev, CARD8 *num_classes,
                char** classbuf)
{
    if (dev->key != NULL) {
	CopySwapKeyClass(client, dev->key, classbuf);
	(*num_classes)++;
    }
    if (dev->button != NULL) {
	CopySwapButtonClass(client, dev->button, classbuf);
	(*num_classes)++;
    }
    if (dev->valuator != NULL) {
	(*num_classes) +=
	    CopySwapValuatorClass(client, dev, classbuf);
    }
}

/***********************************************************************
 *
 * This procedure lists information to be returned for an input device.
 *
 */

static void
ListDeviceInfo(ClientPtr client, DeviceIntPtr d, xDeviceInfoPtr dev,
	       char **devbuf, char **classbuf, char **namebuf)
{
    CopyDeviceName(namebuf, d->name);
    CopySwapDevice(client, d, 0, devbuf);
    CopySwapClasses(client, d, &dev->num_classes, classbuf);
}

/***********************************************************************
 *
 * This procedure checks if a device should be left off the list.
 *
 */

static Bool
ShouldSkipDevice(ClientPtr client, DeviceIntPtr d)
{
    /* don't send master devices other than VCP/VCK */
    if (!IsMaster(d) || d == inputInfo.pointer || d == inputInfo.keyboard)
    {
        int rc = XaceHook(XACE_DEVICE_ACCESS, client, d, DixGetAttrAccess);
        if (rc == Success)
            return FALSE;
    }
    return TRUE;
}


/***********************************************************************
 *
 * This procedure lists the input devices available to the server.
 *
 * If this request is called by a client that has not issued a
 * GetExtensionVersion request with major/minor version set, we don't send the
 * complete device list. Instead, we only send the VCP, the VCK and floating
 * SDs. This resembles the setup found on XI 1.x machines.
 */

int
ProcXListInputDevices(ClientPtr client)
{
    xListInputDevicesReply rep;
    int numdevs = 0;
    int namesize = 1;	/* need 1 extra byte for strcpy */
    int i = 0, size = 0;
    int total_length;
    char *devbuf, *classbuf, *namebuf, *savbuf;
    Bool *skip;
    xDeviceInfo *dev;
    DeviceIntPtr d;

    REQUEST_SIZE_MATCH(xListInputDevicesReq);

    memset(&rep, 0, sizeof(xListInputDevicesReply));
    rep.repType = X_Reply;
    rep.RepType = X_ListInputDevices;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    /* allocate space for saving skip value */
    skip = calloc(sizeof(Bool), inputInfo.numDevices);
    if (!skip)
        return BadAlloc;

    /* figure out which devices to skip */
    numdevs = 0;
    for (d = inputInfo.devices; d; d = d->next, i++) {
        skip[i] = ShouldSkipDevice(client, d);
        if (skip[i])
            continue;

        SizeDeviceInfo(d, &namesize, &size);
        numdevs++;
    }

    for (d = inputInfo.off_devices; d; d = d->next, i++) {
        skip[i] = ShouldSkipDevice(client, d);
        if (skip[i])
            continue;

        SizeDeviceInfo(d, &namesize, &size);
        numdevs++;
    }

    /* allocate space for reply */
    total_length = numdevs * sizeof(xDeviceInfo) + size + namesize;
    devbuf = (char *)calloc(1, total_length);
    classbuf = devbuf + (numdevs * sizeof(xDeviceInfo));
    namebuf = classbuf + size;
    savbuf = devbuf;

    /* fill in and send reply */
    i = 0;
    dev = (xDeviceInfoPtr) devbuf;
    for (d = inputInfo.devices; d; d = d->next, i++) {
        if (skip[i])
            continue;

        ListDeviceInfo(client, d, dev++, &devbuf, &classbuf, &namebuf);
    }

    for (d = inputInfo.off_devices; d; d = d->next, i++) {
        if (skip[i])
            continue;

        ListDeviceInfo(client, d, dev++, &devbuf, &classbuf, &namebuf);
    }
    rep.ndevices = numdevs;
    rep.length = bytes_to_int32(total_length);
    WriteReplyToClient(client, sizeof(xListInputDevicesReply), &rep);
    WriteToClient(client, total_length, savbuf);
    free(savbuf);
    free(skip);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XListInputDevices function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXListInputDevices(ClientPtr client, int size, xListInputDevicesReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef LISTDEV_H
#define LISTDEV_H 1

#define VPC	20	/* Max # valuators per chunk */

int SProcXListInputDevices(ClientPtr	/* client */
    );

int ProcXListInputDevices(ClientPtr	/* client */
    );

void SRepXListInputDevices(ClientPtr /* client */ ,
			   int /* size */ ,
			   xListInputDevicesReply *	/* rep */
    );

#endif /* LISTDEV_H */
noinst_LTLIBRARIES = libXi.la

AM_CFLAGS = $(DIX_CFLAGS)

libXi_la_SOURCES =	\
	allowev.c \
	allowev.h \
	chgdctl.c \
	chgdctl.h \
	chgfctl.c \
	chgfctl.h \
	chgkbd.c \
	chgkbd.h \
	chgkmap.c \
	chgkmap.h \
	chgprop.c \
	chgprop.h \
	chgptr.c \
	chgptr.h \
	closedev.c \
	closedev.h \
	devbell.c \
	devbell.h \
	exevents.c \
	exglobals.h \
	extinit.c \
	getbmap.c \
	getbmap.h \
	getdctl.c \
	getdctl.h \
	getfctl.c \
	getfctl.h \
	getfocus.c \
	getfocus.h \
	getkmap.c \
	getkmap.h \
	getmmap.c \
	getmmap.h \
	getprop.c \
	getprop.h \
	getselev.c \
	getselev.h \
	getvers.c \
	getvers.h \
	grabdev.c \
	grabdev.h \
	grabdevb.c \
	grabdevb.h \
	grabdevk.c \
	grabdevk.h \
	gtmotion.c \
	gtmotion.h \
	listdev.c \
	listdev.h \
	opendev.c \
	opendev.h \
	queryst.c \
	queryst.h \
	selectev.c \
	selectev.h \
	sendexev.c \
	sendexev.h \
	setbmap.c \
	setbmap.h \
	setdval.c \
	setdval.h \
	setfocus.c \
	setfocus.h \
	setmmap.c \
	setmmap.h \
	setmode.c \
	setmode.h \
	ungrdev.c \
	ungrdev.h \
	ungrdevb.c \
	ungrdevb.h \
	ungrdevk.c \
	ungrdevk.h \
	xiallowev.c \
	xiallowev.h \
	xichangecursor.c \
	xichangecursor.h \
	xichangehierarchy.c \
	xichangehierarchy.h \
	xigetclientpointer.c \
	xigetclientpointer.h \
	xigrabdev.c \
	xigrabdev.h \
	xipassivegrab.h \
	xipassivegrab.c \
	xiproperty.c \
	xiproperty.h \
	xiquerydevice.c \
	xiquerydevice.h \
	xiquerypointer.c \
	xiquerypointer.h \
	xiqueryversion.c \
	xiqueryversion.h \
	xiselectev.c \
	xiselectev.h \
	xisetclientpointer.c \
	xisetclientpointer.h \
	xisetdevfocus.c \
	xisetdevfocus.h \
	xiwarppointer.c \
	xiwarppointer.h

EXTRA_DIST = stubs.c
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to open an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "windowstr.h"	/* window structure  */
#include "exglobals.h"
#include "exevents.h"

#include "opendev.h"

extern CARD8 event_base[];

/***********************************************************************
 *
 * This procedure swaps the request if the server and client have different
 * byte orderings.
 *
 */

int
SProcXOpenDevice(ClientPtr client)
{
    char n;

    REQUEST(xOpenDeviceReq);
    swaps(&stuff->length, n);
    return (ProcXOpenDevice(client));
}

/***********************************************************************
 *
 * This procedure causes the server to open an input device.
 *
 */

int
ProcXOpenDevice(ClientPtr client)
{
    xInputClassInfo evbase[numInputClasses];
    int j = 0;
    int status = Success;
    xOpenDeviceReply rep;
    DeviceIntPtr dev;

    REQUEST(xOpenDeviceReq);
    REQUEST_SIZE_MATCH(xOpenDeviceReq);

    status = dixLookupDevice(&dev, stuff->deviceid, client, DixUseAccess);

    if (status == BadDevice) {  /* not open */
	for (dev = inputInfo.off_devices; dev; dev = dev->next)
	    if (dev->id == stuff->deviceid)
		break;
	if (dev == NULL)
	    return BadDevice;
    } else if (status != Success)
	return status;

    if (IsMaster(dev))
            return BadDevice;

    if (status != Success)
	return status;

    memset(&rep, 0, sizeof(xOpenDeviceReply));
    rep.repType = X_Reply;
    rep.RepType = X_OpenDevice;
    rep.sequenceNumber = client->sequence;
    if (dev->key != NULL) {
	evbase[j].class = KeyClass;
	evbase[j++].event_type_base = event_base[KeyClass];
    }
    if (dev->button != NULL) {
	evbase[j].class = ButtonClass;
	evbase[j++].event_type_base = event_base[ButtonClass];
    }
    if (dev->valuator != NULL) {
	evbase[j].class = ValuatorClass;
	evbase[j++].event_type_base = event_base[ValuatorClass];
    }
    if (dev->kbdfeed != NULL || dev->ptrfeed != NULL || dev->leds != NULL ||
	dev->intfeed != NULL || dev->bell != NULL || dev->stringfeed != NULL) {
	evbase[j].class = FeedbackClass;
	evbase[j++].event_type_base = event_base[FeedbackClass];
    }
    if (dev->focus != NULL) {
	evbase[j].class = FocusClass;
	evbase[j++].event_type_base = event_base[FocusClass];
    }
    if (dev->proximity != NULL) {
	evbase[j].class = ProximityClass;
	evbase[j++].event_type_base = event_base[ProximityClass];
    }
    evbase[j].class = OtherClass;
    evbase[j++].event_type_base = event_base[OtherClass];
    rep.length = bytes_to_int32(j * sizeof(xInputClassInfo));
    rep.num_classes = j;
    WriteReplyToClient(client, sizeof(xOpenDeviceReply), &rep);
    WriteToClient(client, j * sizeof(xInputClassInfo), (char *)evbase);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XOpenDevice function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXOpenDevice(ClientPtr client, int size, xOpenDeviceReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef OPENDEV_H
#define OPENDEV_H 1

int SProcXOpenDevice(ClientPtr	/* client */
    );

int ProcXOpenDevice(ClientPtr	/* client */
    );

void SRepXOpenDevice(ClientPtr /* client */ ,
		     int /* size */ ,
		     xOpenDeviceReply *	/* rep */
    );

#endif /* OPENDEV_H */
/*

Copyright 1998, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/***********************************************************************
 *
 * Request to query the state of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"
#include "xkbsrv.h"
#include "xkbstr.h"

#include "queryst.h"

/***********************************************************************
 *
 * This procedure allows a client to query the state of a device.
 *
 */

int
SProcXQueryDeviceState(ClientPtr client)
{
    char n;

    REQUEST(xQueryDeviceStateReq);
    swaps(&stuff->length, n);
    return (ProcXQueryDeviceState(client));
}

/***********************************************************************
 *
 * This procedure allows frozen events to be routed.
 *
 */

int
ProcXQueryDeviceState(ClientPtr client)
{
    char n;
    int rc, i;
    int num_classes = 0;
    int total_length = 0;
    char *buf, *savbuf;
    KeyClassPtr k;
    xKeyState *tk;
    ButtonClassPtr b;
    xButtonState *tb;
    ValuatorClassPtr v;
    xValuatorState *tv;
    xQueryDeviceStateReply rep;
    DeviceIntPtr dev;
    double *values;

    REQUEST(xQueryDeviceStateReq);
    REQUEST_SIZE_MATCH(xQueryDeviceStateReq);

    rep.repType = X_Reply;
    rep.RepType = X_QueryDeviceState;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixReadAccess);
    if (rc != Success && rc != BadAccess)
	return rc;

    v = dev->valuator;
    if (v != NULL && v->motionHintWindow != NULL)
	MaybeStopDeviceHint(dev, client);

    k = dev->key;
    if (k != NULL) {
	total_length += sizeof(xKeyState);
	num_classes++;
    }

    b = dev->button;
    if (b != NULL) {
	total_length += sizeof(xButtonState);
	num_classes++;
    }

    if (v != NULL) {
	total_length += (sizeof(xValuatorState) + (v->numAxes * sizeof(int)));
	num_classes++;
    }
    buf = (char *)calloc(total_length, 1);
    if (!buf)
	return BadAlloc;
    savbuf = buf;

    if (k != NULL) {
	tk = (xKeyState *) buf;
	tk->class = KeyClass;
	tk->length = sizeof(xKeyState);
	tk->num_keys = k->xkbInfo->desc->max_key_code -
                       k->xkbInfo->desc->min_key_code + 1;
	if (rc != BadAccess)
	    for (i = 0; i < 32; i++)
		tk->keys[i] = k->down[i];
	buf += sizeof(xKeyState);
    }

    if (b != NULL) {
	tb = (xButtonState *) buf;
	tb->class = ButtonClass;
	tb->length = sizeof(xButtonState);
	tb->num_buttons = b->numButtons;
	if (rc != BadAccess)
	    memcpy(tb->buttons, b->down, sizeof(b->down));
	buf += sizeof(xButtonState);
    }

    if (v != NULL) {
	tv = (xValuatorState *) buf;
	tv->class = ValuatorClass;
	tv->length = sizeof(xValuatorState) + v->numAxes * 4;
	tv->num_valuators = v->numAxes;
	tv->mode = valuator_get_mode(dev, 0);
	tv->mode |= (dev->proximity && !dev->proximity->in_proximity) ? OutOfProximity : 0;
	buf += sizeof(xValuatorState);
	for (i = 0, values = v->axisVal; i < v->numAxes; i++) {
	    if (rc != BadAccess)
		*((int *)buf) = *values;
	    values++;
	    if (client->swapped) {
		swapl((int *)buf, n);	/* macro - braces needed */
	    }
	    buf += sizeof(int);
	}
    }

    rep.num_classes = num_classes;
    rep.length = bytes_to_int32(total_length);
    WriteReplyToClient(client, sizeof(xQueryDeviceStateReply), &rep);
    if (total_length > 0)
	WriteToClient(client, total_length, savbuf);
    free(savbuf);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XQueryDeviceState function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXQueryDeviceState(ClientPtr client, int size, xQueryDeviceStateReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef QUERYST_H
#define QUERYST_H 1

int SProcXQueryDeviceState(ClientPtr	/* client */
    );

int ProcXQueryDeviceState(ClientPtr	/* client */
    );

void SRepXQueryDeviceState(ClientPtr /* client */ ,
			   int /* size */ ,
			   xQueryDeviceStateReply *	/* rep */
    );

#endif /* QUERYST_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to select input from an extension device.
 *
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "grabdev.h"
#include "selectev.h"

extern Mask ExtExclusiveMasks[];

static int
HandleDevicePresenceMask(ClientPtr client, WindowPtr win,
                         XEventClass *cls, CARD16 *count)
{
    int i, j;
    Mask mask;

    /* We use the device ID 256 to select events that aren't bound to
     * any device.  For now we only handle the device presence event,
     * but this could be extended to other events that aren't bound to
     * a device.
     *
     * In order not to break in CreateMaskFromList() we remove the
     * entries with device ID 256 from the XEventClass array.
     */

    mask = 0;
    for (i = 0, j = 0; i < *count; i++) {
        if (cls[i] >> 8 != 256) {
            cls[j] = cls[i];
            j++;
            continue;
        }

        switch (cls[i] & 0xff) {
        case _devicePresence:
            mask |= DevicePresenceNotifyMask;
            break;
        }
    }

    *count = j;

    if (mask == 0)
        return Success;

    /* We always only use mksidx = AllDevices for events not bound to
     * devices */
    if (AddExtensionClient (win, client, mask, XIAllDevices) != Success)
        return BadAlloc;

    RecalculateDeviceDeliverableEvents(win);

    return Success;
}

/***********************************************************************
 *
 * Handle requests from clients with a different byte order.
 *
 */

int
SProcXSelectExtensionEvent(ClientPtr client)
{
    char n;

    REQUEST(xSelectExtensionEventReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSelectExtensionEventReq);
    swapl(&stuff->window, n);
    swaps(&stuff->count, n);
    REQUEST_FIXED_SIZE(xSelectExtensionEventReq,
                      stuff->count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), stuff->count);

    return (ProcXSelectExtensionEvent(client));
}

/***********************************************************************
 *
 * This procedure selects input from an extension device.
 *
 */

int
ProcXSelectExtensionEvent(ClientPtr client)
{
    int ret;
    int i;
    WindowPtr pWin;
    struct tmask tmp[EMASKSIZE];

    REQUEST(xSelectExtensionEventReq);
    REQUEST_AT_LEAST_SIZE(xSelectExtensionEventReq);

    if (stuff->length != bytes_to_int32(sizeof(xSelectExtensionEventReq)) + stuff->count)
	return BadLength;

    ret = dixLookupWindow(&pWin, stuff->window, client, DixReceiveAccess);
    if (ret != Success)
	return ret;

    if (HandleDevicePresenceMask(client, pWin, (XEventClass *) & stuff[1],
                                &stuff->count) != Success)
	return BadAlloc;

    if ((ret = CreateMaskFromList(client, (XEventClass *) & stuff[1],
				  stuff->count, tmp, NULL,
				  X_SelectExtensionEvent)) != Success)
	return ret;

    for (i = 0; i < EMASKSIZE; i++)
	if (tmp[i].dev != NULL) {
            if (tmp[i].mask & ~XIAllMasks) {
                client->errorValue = tmp[i].mask;
                return BadValue;
            }
	    if ((ret =
		 SelectForWindow((DeviceIntPtr) tmp[i].dev, pWin, client,
				 tmp[i].mask, ExtExclusiveMasks[i]))!= Success)
		return ret;
	}

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SELECTEV_H
#define SELECTEV_H 1

int SProcXSelectExtensionEvent(ClientPtr	/* client */
    );

int ProcXSelectExtensionEvent(ClientPtr	/* client */
    );

#endif /* SELECTEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to send an extension event.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* Window            */
#include "extnsionst.h" /* EventSwapPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "grabdev.h"
#include "sendexev.h"

extern int lastEvent;	/* Defined in extension.c */

/***********************************************************************
 *
 * Handle requests from clients with a different byte order than us.
 *
 */

int
SProcXSendExtensionEvent(ClientPtr client)
{
    char n;
    CARD32 *p;
    int i;
    xEvent eventT;
    xEvent *eventP;
    EventSwapPtr proc;

    REQUEST(xSendExtensionEventReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);
    swapl(&stuff->destination, n);
    swaps(&stuff->count, n);

    if (stuff->length != bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +
       bytes_to_int32(stuff->num_events * sizeof(xEvent)))
       return BadLength;

    eventP = (xEvent *) & stuff[1];
    for (i = 0; i < stuff->num_events; i++, eventP++) {
	proc = EventSwapVector[eventP->u.u.type & 0177];
	if (proc == NotImplemented)	/* no swapping proc; invalid event type? */
	    return BadValue;
	(*proc) (eventP, &eventT);
	*eventP = eventT;
    }

    p = (CARD32 *)(((xEvent *) & stuff[1]) + stuff->num_events);
    SwapLongs(p, stuff->count);
    return (ProcXSendExtensionEvent(client));
}

/***********************************************************************
 *
 * Send an event to some client, as if it had come from an extension input
 * device.
 *
 */

int
ProcXSendExtensionEvent(ClientPtr client)
{
    int ret;
    DeviceIntPtr dev;
    xEvent *first;
    XEventClass *list;
    struct tmask tmp[EMASKSIZE];

    REQUEST(xSendExtensionEventReq);
    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);

    if (stuff->length != bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +
	(stuff->num_events * bytes_to_int32(sizeof(xEvent))))
	return BadLength;

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);
    if (ret != Success)
	return ret;

    /* The client's event type must be one defined by an extension. */

    first = ((xEvent *) & stuff[1]);
    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&
	  (first->u.u.type < lastEvent))) {
	client->errorValue = first->u.u.type;
	return BadValue;
    }

    list = (XEventClass *) (first + stuff->num_events);
    if ((ret = CreateMaskFromList(client, list, stuff->count, tmp, dev,
				  X_SendExtensionEvent)) != Success)
	return ret;

    ret = (SendEvent(client, dev, stuff->destination,
		     stuff->propagate, (xEvent *) & stuff[1],
		     tmp[stuff->deviceid].mask, stuff->num_events));

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SENDEXEV_H
#define SENDEXEV_H 1

int SProcXSendExtensionEvent(ClientPtr	/* client */
    );

int ProcXSendExtensionEvent(ClientPtr	/* client */
    );

#endif /* SENDEXEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to change the button mapping of an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "setbmap.h"

/***********************************************************************
 *
 * This procedure changes the button mapping.
 *
 */

int
SProcXSetDeviceButtonMapping(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceButtonMappingReq);
    swaps(&stuff->length, n);
    return (ProcXSetDeviceButtonMapping(client));
}

/***********************************************************************
 *
 * This procedure lists the input devices available to the server.
 *
 */

int
ProcXSetDeviceButtonMapping(ClientPtr client)
{
    int ret;
    xSetDeviceButtonMappingReply rep;
    DeviceIntPtr dev;

    REQUEST(xSetDeviceButtonMappingReq);
    REQUEST_AT_LEAST_SIZE(xSetDeviceButtonMappingReq);

    if (stuff->length !=
        bytes_to_int32(sizeof(xSetDeviceButtonMappingReq) + stuff->map_length))
	return BadLength;

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (ret != Success)
        return ret;

    rep.repType = X_Reply;
    rep.RepType = X_SetDeviceButtonMapping;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.status = MappingSuccess;

    ret = ApplyPointerMapping(dev, (CARD8 *) &stuff[1], stuff->map_length, client);
    if (ret == -1)
        return BadValue;
    else if (ret == MappingBusy)
        rep.status = ret;
    else if (ret != Success)
        return ret;

    WriteReplyToClient(client, sizeof(xSetDeviceButtonMappingReply), &rep);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XSetDeviceButtonMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXSetDeviceButtonMapping(ClientPtr client, int size,
			    xSetDeviceButtonMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETBMAP_H
#define SETBMAP_H 1

int SProcXSetDeviceButtonMapping(ClientPtr	/* client */
    );

int ProcXSetDeviceButtonMapping(ClientPtr	/* client */
    );

void SRepXSetDeviceButtonMapping(ClientPtr /* client */ ,
				 int /* size */ ,
				 xSetDeviceButtonMappingReply *	/* rep */
    );

#endif /* SETBMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to change the mode of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "exglobals.h"

#include "setdval.h"

/***********************************************************************
 *
 * Handle a request from a client with a different byte order.
 *
 */

int
SProcXSetDeviceValuators(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceValuatorsReq);
    swaps(&stuff->length, n);
    return (ProcXSetDeviceValuators(client));
}

/***********************************************************************
 *
 * This procedure sets the value of valuators on an extension input device.
 *
 */

int
ProcXSetDeviceValuators(ClientPtr client)
{
    DeviceIntPtr dev;
    xSetDeviceValuatorsReply rep;
    int rc;

    REQUEST(xSetDeviceValuatorsReq);
    REQUEST_AT_LEAST_SIZE(xSetDeviceValuatorsReq);

    rep.repType = X_Reply;
    rep.RepType = X_SetDeviceValuators;
    rep.length = 0;
    rep.status = Success;
    rep.sequenceNumber = client->sequence;

    if (stuff->length != bytes_to_int32(sizeof(xSetDeviceValuatorsReq)) +
	stuff->num_valuators)
	return BadLength;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (dev->valuator == NULL)
	return BadMatch;

    if (stuff->first_valuator + stuff->num_valuators > dev->valuator->numAxes)
	return BadValue;

    if ((dev->deviceGrab.grab) && !SameClient(dev->deviceGrab.grab, client))
	rep.status = AlreadyGrabbed;
    else
	rep.status = SetDeviceValuators(client, dev, (int *)&stuff[1],
					stuff->first_valuator,
					stuff->num_valuators);

    if (rep.status != Success && rep.status != AlreadyGrabbed)
	return rep.status;

    WriteReplyToClient(client, sizeof(xSetDeviceValuatorsReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XSetDeviceValuators function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXSetDeviceValuators(ClientPtr client, int size,
			xSetDeviceValuatorsReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETDVAL_H
#define SETDVAL_H 1

int SProcXSetDeviceValuators(ClientPtr	/* client */
    );

int ProcXSetDeviceValuators(ClientPtr	/* client */
    );

void SRepXSetDeviceValuators(ClientPtr /* client */ ,
			     int /* size */ ,
			     xSetDeviceValuatorsReply *	/* rep */
    );

#endif /* SETDVAL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to set the focus for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "windowstr.h"	/* focus struct      */
#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>

#include "dixevents.h"

#include "exglobals.h"

#include "setfocus.h"

/***********************************************************************
 *
 * This procedure sets the focus for a device.
 *
 */

int
SProcXSetDeviceFocus(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceFocusReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xSetDeviceFocusReq);
    swapl(&stuff->focus, n);
    swapl(&stuff->time, n);
    return (ProcXSetDeviceFocus(client));
}

/***********************************************************************
 *
 * This procedure sets the focus for a device.
 *
 */

int
ProcXSetDeviceFocus(ClientPtr client)
{
    int ret;
    DeviceIntPtr dev;

    REQUEST(xSetDeviceFocusReq);
    REQUEST_SIZE_MATCH(xSetDeviceFocusReq);

    ret = dixLookupDevice(&dev, stuff->device, client, DixSetFocusAccess);
    if (ret != Success)
	return ret;
    if (!dev->focus)
	return BadDevice;

    ret = SetInputFocus(client, dev, stuff->focus, stuff->revertTo,
			stuff->time, TRUE);

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETFOCUS_H
#define SETFOCUS_H 1

int SProcXSetDeviceFocus(ClientPtr	/* client */
    );

int ProcXSetDeviceFocus(ClientPtr	/* client */
    );

#endif /* SETFOCUS_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Set modifier mapping for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "setmmap.h"

/***********************************************************************
 *
 * This procedure sets the modifier mapping for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXSetDeviceModifierMapping(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceModifierMappingReq);
    swaps(&stuff->length, n);
    return (ProcXSetDeviceModifierMapping(client));
}

/***********************************************************************
 *
 * Set the device Modifier mapping.
 *
 */

int
ProcXSetDeviceModifierMapping(ClientPtr client)
{
    int ret;
    xSetDeviceModifierMappingReply rep;
    DeviceIntPtr dev;

    REQUEST(xSetDeviceModifierMappingReq);
    REQUEST_AT_LEAST_SIZE(xSetDeviceModifierMappingReq);

    if (stuff->length != bytes_to_int32(sizeof(xSetDeviceModifierMappingReq)) +
                          (stuff->numKeyPerModifier << 1))
        return BadLength;

    rep.repType = X_Reply;
    rep.RepType = X_SetDeviceModifierMapping;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (ret != Success)
        return ret;

    ret = change_modmap(client, dev, (KeyCode *) &stuff[1],
                        stuff->numKeyPerModifier);
    if (ret == Success)
        ret = MappingSuccess;

    if (ret == MappingSuccess || ret == MappingBusy || ret == MappingFailed) {
	rep.success = ret;
	WriteReplyToClient(client, sizeof(xSetDeviceModifierMappingReply),
			   &rep);
    }
    else if (ret == -1) {
        return BadValue;
    }
    else {
        return ret;
    }

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XSetDeviceModifierMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXSetDeviceModifierMapping(ClientPtr client, int size,
			      xSetDeviceModifierMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETMMAP_H
#define SETMMAP_H 1

int SProcXSetDeviceModifierMapping(ClientPtr	/* client */
    );

int ProcXSetDeviceModifierMapping(ClientPtr	/* client */
    );

void SRepXSetDeviceModifierMapping(ClientPtr /* client */ ,
				   int /* size */ ,
				   xSetDeviceModifierMappingReply *	/* rep */
    );

#endif /* SETMMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to change the mode of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "exglobals.h"

#include "setmode.h"

/***********************************************************************
 *
 * Handle a request from a client with a different byte order.
 *
 */

int
SProcXSetDeviceMode(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceModeReq);
    swaps(&stuff->length, n);
    return (ProcXSetDeviceMode(client));
}

/***********************************************************************
 *
 * This procedure sets the mode of a device.
 *
 */

int
ProcXSetDeviceMode(ClientPtr client)
{
    DeviceIntPtr dev;
    xSetDeviceModeReply rep;
    int rc;

    REQUEST(xSetDeviceModeReq);
    REQUEST_SIZE_MATCH(xSetDeviceModeReq);

    rep.repType = X_Reply;
    rep.RepType = X_SetDeviceMode;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (dev->valuator == NULL)
	return BadMatch;
    if ((dev->deviceGrab.grab) && !SameClient(dev->deviceGrab.grab, client))
	rep.status = AlreadyGrabbed;
    else
	rep.status = SetDeviceMode(client, dev, stuff->mode);

    if (rep.status == Success)
        valuator_set_mode(dev, VALUATOR_MODE_ALL_AXES, stuff->mode);
    else if (rep.status != AlreadyGrabbed)
    {
	switch(rep.status) {
	    case BadMatch:
	    case BadImplementation:
	    case BadAlloc:
		break;
	    default:
		rep.status = BadMode;
	}
	return rep.status;
    }

    WriteReplyToClient(client, sizeof(xSetDeviceModeReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XSetDeviceMode function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXSetDeviceMode(ClientPtr client, int size, xSetDeviceModeReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETMODE_H
#define SETMODE_H 1

int SProcXSetDeviceMode(ClientPtr	/* client */
    );

int ProcXSetDeviceMode(ClientPtr	/* client */
    );

void SRepXSetDeviceMode(ClientPtr /* client */ ,
			int /* size */ ,
			xSetDeviceModeReply *	/* rep */
    );

#endif /* SETMODE_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/*
 * stubs.c -- stub routines for the X server side of the XINPUT
 * extension.  This file is mainly to be used only as documentation.
 * There is not much code here, and you can't get a working XINPUT
 * server just using this.
 * The Xvfb server uses this file so it will compile with the same
 * object files as the real X server for a platform that has XINPUT.
 * Xnest could do the same thing.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "inputstr.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "xace.h"

/****************************************************************************
 *
 * Caller:	ProcXSetDeviceMode
 *
 * Change the mode of an extension device.
 * This function is used to change the mode of a device from reporting
 * relative motion to reporting absolute positional information, and
 * vice versa.
 * The default implementation below is that no such devices are supported.
 *
 */

int
SetDeviceMode(ClientPtr client, DeviceIntPtr dev, int mode)
{
    return BadMatch;
}

/****************************************************************************
 *
 * Caller:	ProcXSetDeviceValuators
 *
 * Set the value of valuators on an extension input device.
 * This function is used to set the initial value of valuators on
 * those input devices that are capable of reporting either relative
 * motion or an absolute position, and allow an initial position to be set.
 * The default implementation below is that no such devices are supported.
 *
 */

int
SetDeviceValuators(ClientPtr client, DeviceIntPtr dev,
		   int *valuators, int first_valuator, int num_valuators)
{
    return BadMatch;
}

/****************************************************************************
 *
 * Caller:	ProcXChangeDeviceControl
 *
 * Change the specified device controls on an extension input device.
 *
 */

int
ChangeDeviceControl(ClientPtr client, DeviceIntPtr dev,
		    xDeviceCtl * control)
{
    return BadMatch;
}


/****************************************************************************
 *
 * Caller: configAddDevice (and others)
 *
 * Add a new device with the specified options.
 *
 */
int
NewInputDeviceRequest(InputOption *options, InputAttributes *attrs,
                      DeviceIntPtr *pdev)
{
    return BadValue;
}

/****************************************************************************
 *
 * Caller: configRemoveDevice (and others)
 *
 * Remove the specified device previously added.
 *
 */
void
DeleteInputDeviceRequest(DeviceIntPtr dev)
{
}
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to release a grab of an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "ungrdev.h"

/***********************************************************************
 *
 * Handle requests from a client with a different byte order.
 *
 */

int
SProcXUngrabDevice(ClientPtr client)
{
    char n;

    REQUEST(xUngrabDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xUngrabDeviceReq);
    swapl(&stuff->time, n);
    return (ProcXUngrabDevice(client));
}

/***********************************************************************
 *
 * Release a grab of an extension device.
 *
 */

int
ProcXUngrabDevice(ClientPtr client)
{
    DeviceIntPtr dev;
    GrabPtr grab;
    TimeStamp time;
    int rc;

    REQUEST(xUngrabDeviceReq);
    REQUEST_SIZE_MATCH(xUngrabDeviceReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    grab = dev->deviceGrab.grab;

    time = ClientTimeToServerTime(stuff->time);
    if ((CompareTimeStamps(time, currentTime) != LATER) &&
	(CompareTimeStamps(time, dev->deviceGrab.grabTime) != EARLIER) &&
	(grab) && SameClient(grab, client) && grab->grabtype == GRABTYPE_XI)
	(*dev->deviceGrab.DeactivateGrab) (dev);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef UNGRDEV_H
#define UNGRDEV_H 1

int SProcXUngrabDevice(ClientPtr	/* client */
    );

int ProcXUngrabDevice(ClientPtr	/* client */
    );

#endif /* UNGRDEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to release a grab of a button on an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "dixgrabs.h"

#include "ungrdevb.h"

#define AllModifiersMask ( \
	ShiftMask | LockMask | ControlMask | Mod1Mask | Mod2Mask | \
	Mod3Mask | Mod4Mask | Mod5Mask )

/***********************************************************************
 *
 * Handle requests from a client with a different byte order.
 *
 */

int
SProcXUngrabDeviceButton(ClientPtr client)
{
    char n;

    REQUEST(xUngrabDeviceButtonReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xUngrabDeviceButtonReq);
    swapl(&stuff->grabWindow, n);
    swaps(&stuff->modifiers, n);
    return (ProcXUngrabDeviceButton(client));
}

/***********************************************************************
 *
 * Release a grab of a button on an extension device.
 *
 */

int
ProcXUngrabDeviceButton(ClientPtr client)
{
    DeviceIntPtr dev;
    DeviceIntPtr mdev;
    WindowPtr pWin;
    GrabRec temporaryGrab;
    int rc;

    REQUEST(xUngrabDeviceButtonReq);
    REQUEST_SIZE_MATCH(xUngrabDeviceButtonReq);

    rc = dixLookupDevice(&dev, stuff->grabbed_device, client, DixGrabAccess);
    if (rc != Success)
	return rc;
    if (dev->button == NULL)
	return BadMatch;

    if (stuff->modifier_device != UseXKeyboard) {
	rc = dixLookupDevice(&mdev, stuff->modifier_device, client,
			     DixReadAccess);
	if (rc != Success)
	    return BadDevice;
	if (mdev->key == NULL)
	    return BadMatch;
    } else
	mdev = PickKeyboard(client);

    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if ((stuff->modifiers != AnyModifier) &&
	(stuff->modifiers & ~AllModifiersMask))
	return BadValue;

    temporaryGrab.resource = client->clientAsMask;
    temporaryGrab.device = dev;
    temporaryGrab.window = pWin;
    temporaryGrab.type = DeviceButtonPress;
    temporaryGrab.grabtype = GRABTYPE_XI;
    temporaryGrab.modifierDevice = mdev;
    temporaryGrab.modifiersDetail.exact = stuff->modifiers;
    temporaryGrab.modifiersDetail.pMask = NULL;
    temporaryGrab.detail.exact = stuff->button;
    temporaryGrab.detail.pMask = NULL;

    DeletePassiveGrabFromList(&temporaryGrab);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef UNGRDEVB_H
#define UNGRDEVB_H 1

int SProcXUngrabDeviceButton(ClientPtr	/* client */
    );

int ProcXUngrabDeviceButton(ClientPtr	/* client */
    );

#endif /* UNGRDEVB_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to release a grab of a key on an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "dixgrabs.h"
#include "xkbsrv.h"
#include "xkbstr.h"

#include "ungrdevk.h"

#define AllModifiersMask ( \
	ShiftMask | LockMask | ControlMask | Mod1Mask | Mod2Mask | \
	Mod3Mask | Mod4Mask | Mod5Mask )

/***********************************************************************
 *
 * Handle requests from a client with a different byte order.
 *
 */

int
SProcXUngrabDeviceKey(ClientPtr client)
{
    char n;

    REQUEST(xUngrabDeviceKeyReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xUngrabDeviceKeyReq);
    swapl(&stuff->grabWindow, n);
    swaps(&stuff->modifiers, n);
    return (ProcXUngrabDeviceKey(client));
}

/***********************************************************************
 *
 * Release a grab of a key on an extension device.
 *
 */

int
ProcXUngrabDeviceKey(ClientPtr client)
{
    DeviceIntPtr dev;
    DeviceIntPtr mdev;
    WindowPtr pWin;
    GrabRec temporaryGrab;
    int rc;

    REQUEST(xUngrabDeviceKeyReq);
    REQUEST_SIZE_MATCH(xUngrabDeviceKeyReq);

    rc = dixLookupDevice(&dev, stuff->grabbed_device, client, DixGrabAccess);
    if (rc != Success)
	return rc;
    if (dev->key == NULL)
	return BadMatch;

    if (stuff->modifier_device != UseXKeyboard) {
	rc = dixLookupDevice(&mdev, stuff->modifier_device, client,
			     DixReadAccess);
	if (rc != Success)
	    return BadDevice;
	if (mdev->key == NULL)
	    return BadMatch;
    } else
	mdev = PickKeyboard(client);

    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if (((stuff->key > dev->key->xkbInfo->desc->max_key_code) ||
	 (stuff->key < dev->key->xkbInfo->desc->min_key_code))
	&& (stuff->key != AnyKey))
	return BadValue;

    if ((stuff->modifiers != AnyModifier) &&
	(stuff->modifiers & ~AllModifiersMask))
	return BadValue;

    temporaryGrab.resource = client->clientAsMask;
    temporaryGrab.device = dev;
    temporaryGrab.window = pWin;
    temporaryGrab.type = DeviceKeyPress;
    temporaryGrab.grabtype = GRABTYPE_XI;
    temporaryGrab.modifierDevice = mdev;
    temporaryGrab.modifiersDetail.exact = stuff->modifiers;
    temporaryGrab.modifiersDetail.pMask = NULL;
    temporaryGrab.detail.exact = stuff->key;
    temporaryGrab.detail.pMask = NULL;

    DeletePassiveGrabFromList(&temporaryGrab);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef UNGRDEVK_H
#define UNGRDEVK_H 1

int SProcXUngrabDeviceKey(ClientPtr	/* client */
    );

int ProcXUngrabDeviceKey(ClientPtr	/* client */
    );

#endif /* UNGRDEVK_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

/***********************************************************************
 *
 * Request to allow some device events.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI2.h>
#include <X11/extensions/XI2proto.h>

#include "exglobals.h" /* BadDevice */
#include "xiallowev.h"

int
SProcXIAllowEvents(ClientPtr client)
{
    char n;

    REQUEST(xXIAllowEventsReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->time, n);

    return ProcXIAllowEvents(client);
}

int
ProcXIAllowEvents(ClientPtr client)
{
    TimeStamp time;
    DeviceIntPtr dev;
    int ret = Success;

    REQUEST(xXIAllowEventsReq);
    REQUEST_SIZE_MATCH(xXIAllowEventsReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (ret != Success)
	return ret;

    time = ClientTimeToServerTime(stuff->time);

    switch (stuff->mode) {
    case XIReplayDevice:
	AllowSome(client, time, dev, NOT_GRABBED);
	break;
    case XISyncDevice:
	AllowSome(client, time, dev, FREEZE_NEXT_EVENT);
	break;
    case XIAsyncDevice:
	AllowSome(client, time, dev, THAWED);
	break;
    case XIAsyncPairedDevice:
        if (IsMaster(dev))
            AllowSome(client, time, dev, THAW_OTHERS);
	break;
    case XISyncPair:
        if (IsMaster(dev))
            AllowSome(client, time, dev, FREEZE_BOTH_NEXT_EVENT);
	break;
    case XIAsyncPair:
        if (IsMaster(dev))
            AllowSome(client, time, dev, THAWED_BOTH);
	break;
    default:
	client->errorValue = stuff->mode;
	ret = BadValue;
    }

    return ret;
}

/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XIALLOWEV_H
#define XIALLOWEV_H 1

int ProcXIAllowEvents(ClientPtr client);
int SProcXIAllowEvents(ClientPtr client);

#endif /* XIALLOWEV_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request to change a given device pointer's cursor.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "input.h"

#include "xichangecursor.h"

/***********************************************************************
 *
 * This procedure allows a client to set one pointer's cursor.
 *
 */

int
SProcXIChangeCursor(ClientPtr client)
{
    char n;

    REQUEST(xXIChangeCursorReq);
    swaps(&stuff->length, n);
    swapl(&stuff->win, n);
    swapl(&stuff->cursor, n);
    swaps(&stuff->deviceid, n);
    REQUEST_SIZE_MATCH(xXIChangeCursorReq);
    return (ProcXIChangeCursor(client));
}

int ProcXIChangeCursor(ClientPtr client)
{
    int rc;
    WindowPtr pWin    = NULL;
    DeviceIntPtr pDev = NULL;
    CursorPtr pCursor = NULL;

    REQUEST(xXIChangeCursorReq);
    REQUEST_SIZE_MATCH(xXIChangeCursorReq);

    rc = dixLookupDevice(&pDev, stuff->deviceid, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;

    if (!IsMaster(pDev) || !IsPointerDevice(pDev))
        return BadDevice;

    if (stuff->win != None)
    {
        rc = dixLookupWindow(&pWin, stuff->win, client, DixSetAttrAccess);
        if (rc != Success)
            return rc;
    }

    if (stuff->cursor == None)
    {
        if (pWin == pWin->drawable.pScreen->root)
            pCursor = rootCursor;
        else
            pCursor = (CursorPtr)None;
    }
    else
    {
	rc = dixLookupResourceByType((pointer *)&pCursor, stuff->cursor,
				     RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	    return rc;
    }

    ChangeWindowDeviceCursor(pWin, pDev, pCursor);

    return Success;
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHDEVCUR_H
#define CHDEVCUR_H 1

int SProcXIChangeCursor(ClientPtr /* client */);
int ProcXIChangeCursor(ClientPtr /* client */);

#endif /* CHDEVCUR_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 * Copyright 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request change in the device hierarchy.
 *
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/geproto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "geext.h"
#include "xace.h"
#include "xiquerydevice.h" /* for GetDeviceUse */

#include "xkbsrv.h"

#include "xichangehierarchy.h"

/**
 * Send the current state of the device hierarchy to all clients.
 */
void XISendDeviceHierarchyEvent(int flags[MAXDEVICES])
{
    xXIHierarchyEvent *ev;
    xXIHierarchyInfo *info;
    DeviceIntRec dummyDev;
    DeviceIntPtr dev;
    int i;

    if (!flags)
        return;

    ev = calloc(1, sizeof(xXIHierarchyEvent) +
                 MAXDEVICES * sizeof(xXIHierarchyInfo));
    if (!ev)
        return;
    ev->type = GenericEvent;
    ev->extension = IReqCode;
    ev->evtype = XI_HierarchyChanged;
    ev->time = GetTimeInMillis();
    ev->flags = 0;
    ev->num_info = inputInfo.numDevices;

    info = (xXIHierarchyInfo*)&ev[1];
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
        info->deviceid = dev->id;
        info->enabled = dev->enabled;
        info->use = GetDeviceUse(dev, &info->attachment);
        info->flags = flags[dev->id];
        ev->flags |= info->flags;
        info++;
    }
    for (dev = inputInfo.off_devices; dev; dev = dev->next)
    {
        info->deviceid = dev->id;
        info->enabled = dev->enabled;
        info->use = GetDeviceUse(dev, &info->attachment);
        info->flags = flags[dev->id];
        ev->flags |= info->flags;
        info++;
    }


    for (i = 0; i < MAXDEVICES; i++)
    {
        if (flags[i] & (XIMasterRemoved | XISlaveRemoved))
        {
            info->deviceid = i;
            info->enabled = FALSE;
            info->flags = flags[i];
            info->use = 0;
            ev->flags |= info->flags;
            ev->num_info++;
            info++;
        }
    }

    ev->length = bytes_to_int32(ev->num_info * sizeof(xXIHierarchyInfo));

    memset(&dummyDev, 0, sizeof(dummyDev));
    dummyDev.id = XIAllDevices;
    dummyDev.type = SLAVE;
    SendEventToAllWindows(&dummyDev, (XI_HierarchyChangedMask >> 8), (xEvent*)ev, 1);
    free(ev);
}


/***********************************************************************
 *
 * This procedure allows a client to change the device hierarchy through
 * adding new master devices, removing them, etc.
 *
 */

int SProcXIChangeHierarchy(ClientPtr client)
{
    char n;

    REQUEST(xXIChangeHierarchyReq);
    swaps(&stuff->length, n);
    return (ProcXIChangeHierarchy(client));
}

static int
add_master(ClientPtr client, xXIAddMasterInfo *c, int flags[MAXDEVICES])
{
    DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
    char* name;
    int rc;

    name = calloc(c->name_len + 1, sizeof(char));
    strncpy(name, (char*)&c[1], c->name_len);

    rc = AllocDevicePair(client, name, &ptr, &keybd,
                         CorePointerProc, CoreKeyboardProc, TRUE);
    if (rc != Success)
        goto unwind;

    if (!c->send_core)
        ptr->coreEvents = keybd->coreEvents =  FALSE;

    /* Allocate virtual slave devices for xtest events */
    rc = AllocXTestDevice(client, name, &XTestptr, &XTestkeybd, ptr, keybd);
    if (rc != Success)
    {
        DeleteInputDeviceRequest(ptr);
        DeleteInputDeviceRequest(keybd);
        goto unwind;
    }

    ActivateDevice(ptr, FALSE);
    ActivateDevice(keybd, FALSE);
    flags[ptr->id] |= XIMasterAdded;
    flags[keybd->id] |= XIMasterAdded;

    ActivateDevice(XTestptr, FALSE);
    ActivateDevice(XTestkeybd, FALSE);
    flags[XTestptr->id] |= XISlaveAdded;
    flags[XTestkeybd->id] |= XISlaveAdded;

    if (c->enable)
    {
        EnableDevice(ptr, FALSE);
        EnableDevice(keybd, FALSE);
        flags[ptr->id] |= XIDeviceEnabled;
        flags[keybd->id] |= XIDeviceEnabled;

        EnableDevice(XTestptr, FALSE);
        EnableDevice(XTestkeybd, FALSE);
        flags[XTestptr->id] |= XIDeviceEnabled;
        flags[XTestkeybd->id] |= XIDeviceEnabled;
    }

    /* Attach the XTest virtual devices to the newly
       created master device */
    AttachDevice(NULL, XTestptr, ptr);
    AttachDevice(NULL, XTestkeybd, keybd);
    flags[XTestptr->id] |= XISlaveAttached;
    flags[XTestkeybd->id] |= XISlaveAttached;

unwind:
    free(name);
    return rc;
}

static int
remove_master(ClientPtr client, xXIRemoveMasterInfo *r,
              int flags[MAXDEVICES])
{
    DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
    int rc = Success;

    if (r->return_mode != XIAttachToMaster &&
        r->return_mode != XIFloating)
        return BadValue;

    rc = dixLookupDevice(&ptr, r->deviceid, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    if (!IsMaster(ptr))
    {
        client->errorValue = r->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* XXX: For now, don't allow removal of VCP, VCK */
    if (ptr == inputInfo.pointer || ptr == inputInfo.keyboard)
    {
        rc = BadDevice;
        goto unwind;
    }


    ptr = GetMaster(ptr, MASTER_POINTER);
    rc = dixLookupDevice(&ptr, ptr->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;
    keybd = GetMaster(ptr, MASTER_KEYBOARD);
    rc = dixLookupDevice(&keybd, keybd->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    XTestptr = GetXTestDevice(ptr);
    rc = dixLookupDevice(&XTestptr, XTestptr->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    XTestkeybd = GetXTestDevice(keybd);
    rc = dixLookupDevice(&XTestkeybd, XTestkeybd->id, client,
                         DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    /* Disabling sends the devices floating, reattach them if
     * desired. */
    if (r->return_mode == XIAttachToMaster)
    {
        DeviceIntPtr attached,
                     newptr,
                     newkeybd;

        rc = dixLookupDevice(&newptr, r->return_pointer, client, DixAddAccess);
        if (rc != Success)
            goto unwind;

        if (!IsMaster(newptr))
        {
            client->errorValue = r->return_pointer;
            rc = BadDevice;
            goto unwind;
        }

        rc = dixLookupDevice(&newkeybd, r->return_keyboard,
                             client, DixAddAccess);
        if (rc != Success)
            goto unwind;

        if (!IsMaster(newkeybd))
        {
            client->errorValue = r->return_keyboard;
            rc = BadDevice;
            goto unwind;
        }

        for (attached = inputInfo.devices; attached; attached = attached->next)
        {
            if (!IsMaster(attached)) {
                if (GetMaster(attached, MASTER_ATTACHED) == ptr)
                {
                    AttachDevice(client, attached, newptr);
                    flags[attached->id] |= XISlaveAttached;
                }
                if (GetMaster(attached, MASTER_ATTACHED) == keybd)
                {
                    AttachDevice(client, attached, newkeybd);
                    flags[attached->id] |= XISlaveAttached;
                }
            }
        }
    }

    /* can't disable until we removed pairing */
    keybd->spriteInfo->paired = NULL;
    ptr->spriteInfo->paired = NULL;
    XTestptr->spriteInfo->paired = NULL;
    XTestkeybd->spriteInfo->paired = NULL;

    /* disable the remove the devices, XTest devices must be done first
       else the sprites they rely on will be destroyed  */
    DisableDevice(XTestptr, FALSE);
    DisableDevice(XTestkeybd, FALSE);
    DisableDevice(keybd, FALSE);
    DisableDevice(ptr, FALSE);
    flags[XTestptr->id] |= XIDeviceDisabled | XISlaveDetached;
    flags[XTestkeybd->id] |= XIDeviceDisabled | XISlaveDetached;
    flags[keybd->id] |= XIDeviceDisabled;
    flags[ptr->id] |= XIDeviceDisabled;

    RemoveDevice(XTestptr, FALSE);
    RemoveDevice(XTestkeybd, FALSE);
    RemoveDevice(keybd, FALSE);
    RemoveDevice(ptr, FALSE);
    flags[XTestptr->id] |= XISlaveRemoved;
    flags[XTestkeybd->id] |= XISlaveRemoved;
    flags[keybd->id] |= XIMasterRemoved;
    flags[ptr->id] |= XIMasterRemoved;

unwind:
    return rc;
}

static int
detach_slave(ClientPtr client, xXIDetachSlaveInfo *c, int flags[MAXDEVICES])
{
    DeviceIntPtr dev;
    int rc;

    rc = dixLookupDevice(&dev, c->deviceid, client, DixManageAccess);
    if (rc != Success)
        goto unwind;

    if (IsMaster(dev))
    {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* Don't allow changes to XTest Devices, these are fixed */
    if (IsXTestDevice(dev, NULL))
    {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    ReleaseButtonsAndKeys(dev);
    AttachDevice(client, dev, NULL);
    flags[dev->id] |= XISlaveDetached;

unwind:
    return rc;
}

static int
attach_slave(ClientPtr client, xXIAttachSlaveInfo *c,
             int flags[MAXDEVICES])
{
    DeviceIntPtr dev;
    DeviceIntPtr newmaster;
    int rc;

    rc = dixLookupDevice(&dev, c->deviceid, client, DixManageAccess);
    if (rc != Success)
        goto unwind;

    if (IsMaster(dev))
    {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* Don't allow changes to XTest Devices, these are fixed */
    if (IsXTestDevice(dev, NULL))
    {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    rc = dixLookupDevice(&newmaster, c->new_master, client, DixAddAccess);
    if (rc != Success)
        goto unwind;
    if (!IsMaster(newmaster))
    {
        client->errorValue = c->new_master;
        rc = BadDevice;
        goto unwind;
    }

    if (!((IsPointerDevice(newmaster) && IsPointerDevice(dev)) ||
        (IsKeyboardDevice(newmaster) && IsKeyboardDevice(dev))))
    {
        rc = BadDevice;
        goto unwind;
    }

    ReleaseButtonsAndKeys(dev);
    AttachDevice(client, dev, newmaster);
    flags[dev->id] |= XISlaveAttached;

unwind:
    return rc;
}



#define SWAPIF(cmd) if (client->swapped) { cmd; }

int
ProcXIChangeHierarchy(ClientPtr client)
{
    xXIAnyHierarchyChangeInfo *any;
    int required_len = sizeof(xXIChangeHierarchyReq);
    char n;
    int rc = Success;
    int flags[MAXDEVICES] = {0};

    REQUEST(xXIChangeHierarchyReq);
    REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);

    if (!stuff->num_changes)
        return rc;

    any = (xXIAnyHierarchyChangeInfo*)&stuff[1];
    while(stuff->num_changes--)
    {
        SWAPIF(swapl(&any->type, n));
        SWAPIF(swaps(&any->length, n));

        required_len += any->length;
        if ((stuff->length * 4) < required_len)
            return BadLength;

        switch(any->type)
        {
            case XIAddMaster:
                {
                    xXIAddMasterInfo* c = (xXIAddMasterInfo*)any;
                    SWAPIF(swaps(&c->name_len, n));

                    rc = add_master(client, c, flags);
                    if (rc != Success)
                        goto unwind;
                }
                break;
            case XIRemoveMaster:
                {
                    xXIRemoveMasterInfo* r = (xXIRemoveMasterInfo*)any;

                    rc = remove_master(client, r, flags);
                    if (rc != Success)
                        goto unwind;
                }
                break;
            case XIDetachSlave:
                {
                    xXIDetachSlaveInfo* c = (xXIDetachSlaveInfo*)any;

                    rc = detach_slave(client, c, flags);
                    if (rc != Success)
                       goto unwind;
                }
                break;
            case XIAttachSlave:
                {
                    xXIAttachSlaveInfo* c = (xXIAttachSlaveInfo*)any;

                    rc = attach_slave(client, c, flags);
                    if (rc != Success)
                       goto unwind;
                }
                break;
        }

        any = (xXIAnyHierarchyChangeInfo*)((char*)any + any->length * 4);
    }

unwind:

    XISendDeviceHierarchyEvent(flags);
    return rc;
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request change in the device hierarchy.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHDEVHIER_H
#define CHDEVHIER_H 1

int SProcXIChangeHierarchy(ClientPtr /* client */);
int ProcXIChangeHierarchy(ClientPtr /* client */);

void XISendDeviceHierarchyEvent(int flags[]);

#endif /* CHDEVHIER_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "extinit.h"	/* LookupDeviceIntRec */
#include "exevents.h"
#include "exglobals.h"

#include "xigetclientpointer.h"

/***********************************************************************
 * This procedure allows a client to query another client's client pointer
 * setting.
 */

int
SProcXIGetClientPointer(ClientPtr client)
{
    char n;
    REQUEST(xXIGetClientPointerReq);

    swaps(&stuff->length, n);
    swapl(&stuff->win, n);
    return ProcXIGetClientPointer(client);
}

int ProcXIGetClientPointer(ClientPtr client)
{
    int rc;
    ClientPtr winclient;
    xXIGetClientPointerReply rep;
    REQUEST(xXIGetClientPointerReq);
    REQUEST_SIZE_MATCH(xXIGetClientPointerReq);

    if (stuff->win != None)
    {
        rc = dixLookupClient(&winclient, stuff->win, client,
                DixGetAttrAccess);

        if (rc != Success)
            return BadWindow;
    } else
        winclient = client;

    rep.repType = X_Reply;
    rep.RepType = X_XIGetClientPointer;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.set = (winclient->clientPtr != NULL);
    rep.deviceid = (winclient->clientPtr) ? winclient->clientPtr->id : 0;

    WriteReplyToClient(client, sizeof(xXIGetClientPointerReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetClientPointer function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXIGetClientPointer(ClientPtr client, int size,
        xXIGetClientPointerReply* rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->deviceid, n);
    WriteToClient(client, size, (char *)rep);
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETCPTR_H
#define GETCPTR_H 1
int SProcXIGetClientPointer(ClientPtr /* client */);
int ProcXIGetClientPointer(ClientPtr /* client */);
void SRepXIGetClientPointer(ClientPtr /* client */,
        int /* size */,
        xXIGetClientPointerReply* /* rep */);

#endif /* GETCPTR_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

/***********************************************************************
 *
 * Request to grab or ungrab input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI2.h>
#include <X11/extensions/XI2proto.h>

#include "exglobals.h" /* BadDevice */
#include "exevents.h"
#include "xigrabdev.h"

int
SProcXIGrabDevice(ClientPtr client)
{
    char n;

    REQUEST(xXIGrabDeviceReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->grab_window, n);
    swapl(&stuff->cursor, n);
    swapl(&stuff->time, n);
    swaps(&stuff->mask_len, n);

    return ProcXIGrabDevice(client);
}

int
ProcXIGrabDevice(ClientPtr client)
{
    DeviceIntPtr dev;
    xXIGrabDeviceReply rep;
    int ret = Success;
    uint8_t status;
    GrabMask mask;
    int mask_len;

    REQUEST(xXIGrabDeviceReq);
    REQUEST_AT_LEAST_SIZE(xXIGrabDeviceReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
    if (ret != Success)
	return ret;

    if (!IsMaster(dev))
        stuff->paired_device_mode = GrabModeAsync;

    if (XICheckInvalidMaskBits(client, (unsigned char*)&stuff[1],
                               stuff->mask_len * 4) != Success)
        return BadValue;

    mask_len = min(sizeof(mask.xi2mask[stuff->deviceid]), stuff->mask_len * 4);
    memset(mask.xi2mask, 0, sizeof(mask.xi2mask));
    memcpy(mask.xi2mask, (char*)&stuff[1], mask_len);

    ret = GrabDevice(client, dev, stuff->grab_mode,
                     stuff->paired_device_mode,
                     stuff->grab_window,
                     stuff->owner_events,
                     stuff->time,
                     &mask,
                     GRABTYPE_XI2,
                     stuff->cursor,
                     None /* confineTo */,
                     &status);

    if (ret != Success)
        return ret;

    rep.repType = X_Reply;
    rep.RepType = X_XIGrabDevice;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.status = status;


    WriteReplyToClient(client, sizeof(rep), &rep);
    return ret;
}

int
SProcXIUngrabDevice(ClientPtr client)
{
    char n;

    REQUEST(xXIUngrabDeviceReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->time, n);

    return ProcXIUngrabDevice(client);
}

int
ProcXIUngrabDevice(ClientPtr client)
{
    DeviceIntPtr dev;
    GrabPtr grab;
    int ret = Success;
    TimeStamp time;

    REQUEST(xXIUngrabDeviceReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (ret != Success)
	return ret;

    grab = dev->deviceGrab.grab;

    time = ClientTimeToServerTime(stuff->time);
    if ((CompareTimeStamps(time, currentTime) != LATER) &&
	(CompareTimeStamps(time, dev->deviceGrab.grabTime) != EARLIER) &&
	(grab) && SameClient(grab, client) && grab->grabtype == GRABTYPE_XI2)
	(*dev->deviceGrab.DeactivateGrab) (dev);

    return Success;
}

void SRepXIGrabDevice(ClientPtr client, int size, xXIGrabDeviceReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XIGRABDEV_H
#define XIGRABDEV_H 1

int ProcXIGrabDevice(ClientPtr client);
int SProcXIGrabDevice(ClientPtr client);

int ProcXIUngrabDevice(ClientPtr client);
int SProcXIUngrabDevice(ClientPtr client);

void SRepXIGrabDevice(ClientPtr client, int size, xXIGrabDeviceReply * rep);

#endif /* XIGRABDEV_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

/***********************************************************************
 *
 * Request to grab or ungrab input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI2.h>
#include <X11/extensions/XI2proto.h>
#include "swaprep.h"

#include "exglobals.h" /* BadDevice */
#include "exevents.h"
#include "xipassivegrab.h"
#include "dixgrabs.h"
#include "misc.h"

int
SProcXIPassiveGrabDevice(ClientPtr client)
{
    int i;
    char n;
    xXIModifierInfo *mods;

    REQUEST(xXIPassiveGrabDeviceReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->grab_window, n);
    swapl(&stuff->cursor, n);
    swapl(&stuff->time, n);
    swapl(&stuff->detail, n);
    swaps(&stuff->mask_len, n);
    swaps(&stuff->num_modifiers, n);

    mods = (xXIModifierInfo*)&stuff[1];

    for (i = 0; i < stuff->num_modifiers; i++, mods++)
    {
        swapl(&mods->base_mods, n);
        swapl(&mods->latched_mods, n);
        swapl(&mods->locked_mods, n);
    }

    return ProcXIPassiveGrabDevice(client);
}

int
ProcXIPassiveGrabDevice(ClientPtr client)
{
    DeviceIntPtr dev, mod_dev;
    xXIPassiveGrabDeviceReply rep;
    int i, ret = Success;
    uint8_t status;
    uint32_t *modifiers;
    xXIGrabModifierInfo *modifiers_failed;
    GrabMask mask;
    GrabParameters param;
    void *tmp;
    int mask_len;
    int n;

    REQUEST(xXIPassiveGrabDeviceReq);
    REQUEST_AT_LEAST_SIZE(xXIPassiveGrabDeviceReq);

    if (stuff->deviceid == XIAllDevices)
        dev = inputInfo.all_devices;
    else if (stuff->deviceid == XIAllMasterDevices)
        dev = inputInfo.all_master_devices;
    else
    {
        ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
        if (ret != Success)
        {
            client->errorValue = stuff->deviceid;
            return ret;
        }
    }

    if (stuff->grab_type != XIGrabtypeButton &&
        stuff->grab_type != XIGrabtypeKeycode &&
        stuff->grab_type != XIGrabtypeEnter &&
        stuff->grab_type != XIGrabtypeFocusIn)
    {
        client->errorValue = stuff->grab_type;
        return BadValue;
    }

    if ((stuff->grab_type == XIGrabtypeEnter ||
         stuff->grab_type == XIGrabtypeFocusIn) && stuff->detail != 0)
    {
        client->errorValue = stuff->detail;
        return BadValue;
    }

    if (XICheckInvalidMaskBits(client, (unsigned char*)&stuff[1],
                               stuff->mask_len * 4) != Success)
        return BadValue;

    mask_len = min(sizeof(mask.xi2mask[stuff->deviceid]), stuff->mask_len * 4);
    memset(mask.xi2mask, 0, sizeof(mask.xi2mask));
    memcpy(mask.xi2mask[stuff->deviceid], &stuff[1], mask_len * 4);

    rep.repType = X_Reply;
    rep.RepType = X_XIPassiveGrabDevice;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.num_modifiers = 0;

    memset(&param, 0, sizeof(param));
    param.grabtype = GRABTYPE_XI2;
    param.ownerEvents = stuff->owner_events;
    param.this_device_mode = stuff->grab_mode;
    param.other_devices_mode = stuff->paired_device_mode;
    param.grabWindow = stuff->grab_window;
    param.cursor = stuff->cursor;

    if (stuff->cursor != None)
    {
        status = dixLookupResourceByType(&tmp, stuff->cursor,
                                         RT_CURSOR, client, DixUseAccess);
	if (status != Success)
	{
	    client->errorValue = stuff->cursor;
	    return status;
	}
    }

    status = dixLookupWindow((WindowPtr*)&tmp, stuff->grab_window, client, DixSetAttrAccess);
    if (status != Success)
	return status;

    status = CheckGrabValues(client, &param);
    if (status != Success)
        return status;

    modifiers = (uint32_t*)&stuff[1] + stuff->mask_len;
    modifiers_failed = calloc(stuff->num_modifiers, sizeof(xXIGrabModifierInfo));
    if (!modifiers_failed)
        return BadAlloc;

    mod_dev = (IsFloating(dev)) ? dev : GetMaster(dev, MASTER_KEYBOARD);

    for (i = 0; i < stuff->num_modifiers; i++, modifiers++)
    {
        param.modifiers = *modifiers;
        switch(stuff->grab_type)
        {
            case XIGrabtypeButton:
                status = GrabButton(client, dev, mod_dev, stuff->detail,
                                    &param, GRABTYPE_XI2, &mask);
                break;
            case XIGrabtypeKeycode:
                status = GrabKey(client, dev, mod_dev, stuff->detail,
                                 &param, GRABTYPE_XI2, &mask);
                break;
            case XIGrabtypeEnter:
            case XIGrabtypeFocusIn:
                status = GrabWindow(client, dev, stuff->grab_type,
                                    &param, &mask);
                break;
        }

        if (status != GrabSuccess)
        {
            xXIGrabModifierInfo *info = modifiers_failed + rep.num_modifiers;

            info->status = status;
            info->modifiers = *modifiers;
            if (client->swapped)
                swapl(&info->modifiers, n);

            rep.num_modifiers++;
            rep.length += bytes_to_int32(sizeof(xXIGrabModifierInfo));
        }
    }

    WriteReplyToClient(client, sizeof(rep), &rep);
    if (rep.num_modifiers)
        WriteToClient(client, rep.length * 4, (char*)modifiers_failed);

    free(modifiers_failed);
    return ret;
}

void
SRepXIPassiveGrabDevice(ClientPtr client, int size,
                        xXIPassiveGrabDeviceReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_modifiers, n);

    WriteToClient(client, size, (char *)rep);
}

int
SProcXIPassiveUngrabDevice(ClientPtr client)
{
    char n;
    int i;
    uint32_t *modifiers;

    REQUEST(xXIPassiveUngrabDeviceReq);

    swaps(&stuff->length, n);
    swapl(&stuff->grab_window, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->detail, n);
    swaps(&stuff->num_modifiers, n);

    modifiers = (uint32_t*)&stuff[1];

    for (i = 0; i < stuff->num_modifiers; i++, modifiers++)
        swapl(modifiers, n);

    return ProcXIPassiveUngrabDevice(client);
}

int
ProcXIPassiveUngrabDevice(ClientPtr client)
{
    DeviceIntPtr dev, mod_dev;
    WindowPtr win;
    GrabRec tempGrab;
    uint32_t* modifiers;
    int i, rc;

    REQUEST(xXIPassiveUngrabDeviceReq);
    REQUEST_AT_LEAST_SIZE(xXIPassiveUngrabDeviceReq);

    if (stuff->deviceid == XIAllDevices)
        dev = inputInfo.all_devices;
    else if (stuff->deviceid == XIAllMasterDevices)
        dev = inputInfo.all_master_devices;
    else
    {
        rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
        if (rc != Success)
	    return rc;
    }

    if (stuff->grab_type != XIGrabtypeButton &&
        stuff->grab_type != XIGrabtypeKeycode &&
        stuff->grab_type != XIGrabtypeEnter &&
        stuff->grab_type != XIGrabtypeFocusIn)
    {
        client->errorValue = stuff->grab_type;
        return BadValue;
    }

    if ((stuff->grab_type == XIGrabtypeEnter ||
         stuff->grab_type == XIGrabtypeFocusIn) && stuff->detail != 0)
    {
        client->errorValue = stuff->detail;
        return BadValue;
    }

    rc = dixLookupWindow(&win, stuff->grab_window, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;

    mod_dev = (IsFloating(dev)) ? dev : GetMaster(dev, MASTER_KEYBOARD);

    tempGrab.resource = client->clientAsMask;
    tempGrab.device = dev;
    tempGrab.window = win;
    switch(stuff->grab_type)
    {
        case XIGrabtypeButton:  tempGrab.type = XI_ButtonPress; break;
        case XIGrabtypeKeycode:  tempGrab.type = XI_KeyPress;    break;
        case XIGrabtypeEnter:   tempGrab.type = XI_Enter;       break;
        case XIGrabtypeFocusIn: tempGrab.type = XI_FocusIn;     break;
    }
    tempGrab.grabtype = GRABTYPE_XI2;
    tempGrab.modifierDevice = mod_dev;
    tempGrab.modifiersDetail.pMask = NULL;
    tempGrab.detail.exact = stuff->detail;
    tempGrab.detail.pMask = NULL;

    modifiers = (uint32_t*)&stuff[1];

    for (i = 0; i < stuff->num_modifiers; i++, modifiers++)
    {
        tempGrab.modifiersDetail.exact = *modifiers;
        DeletePassiveGrabFromList(&tempGrab);
    }

    return Success;
}
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XIPASSIVEGRAB_H
#define XIPASSIVEGRAB_H 1

int SProcXIPassiveUngrabDevice(ClientPtr client);
int ProcXIPassiveUngrabDevice(ClientPtr client);
void SRepXIPassiveGrabDevice(ClientPtr client, int size, xXIPassiveGrabDeviceReply * rep);
int ProcXIPassiveGrabDevice(ClientPtr client);
int SProcXIPassiveGrabDevice(ClientPtr client);

#endif /* XIPASSIVEGRAB_H */
/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WAXIANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WAXIANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/* This code is a modified version of randr/rrproperty.c */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "dix.h"
#include "inputstr.h"
#include <X11/extensions/XI.h>
#include <X11/Xatom.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include "exglobals.h"
#include "exevents.h"
#include "swaprep.h"

#include "xiproperty.h"
#include "xserver-properties.h"

/**
 * Properties used or alloced from inside the server.
 */
static struct dev_properties
{
    Atom type;
    char *name;
} dev_properties[] = {
    {0, XI_PROP_ENABLED},
    {0, XI_PROP_XTEST_DEVICE},
    {0, XATOM_FLOAT},
    {0, ACCEL_PROP_PROFILE_NUMBER},
    {0, ACCEL_PROP_CONSTANT_DECELERATION},
    {0, ACCEL_PROP_ADAPTIVE_DECELERATION},
    {0, ACCEL_PROP_VELOCITY_SCALING},
    {0, AXIS_LABEL_PROP},
    {0, AXIS_LABEL_PROP_REL_X},
    {0, AXIS_LABEL_PROP_REL_Y},
    {0, AXIS_LABEL_PROP_REL_Z},
    {0, AXIS_LABEL_PROP_REL_RX},
    {0, AXIS_LABEL_PROP_REL_RY},
    {0, AXIS_LABEL_PROP_REL_RZ},
    {0, AXIS_LABEL_PROP_REL_HWHEEL},
    {0, AXIS_LABEL_PROP_REL_DIAL},
    {0, AXIS_LABEL_PROP_REL_WHEEL},
    {0, AXIS_LABEL_PROP_REL_MISC},
    {0, AXIS_LABEL_PROP_ABS_X},
    {0, AXIS_LABEL_PROP_ABS_Y},
    {0, AXIS_LABEL_PROP_ABS_Z},
    {0, AXIS_LABEL_PROP_ABS_RX},
    {0, AXIS_LABEL_PROP_ABS_RY},
    {0, AXIS_LABEL_PROP_ABS_RZ},
    {0, AXIS_LABEL_PROP_ABS_THROTTLE},
    {0, AXIS_LABEL_PROP_ABS_RUDDER},
    {0, AXIS_LABEL_PROP_ABS_WHEEL},
    {0, AXIS_LABEL_PROP_ABS_GAS},
    {0, AXIS_LABEL_PROP_ABS_BRAKE},
    {0, AXIS_LABEL_PROP_ABS_HAT0X},
    {0, AXIS_LABEL_PROP_ABS_HAT0Y},
    {0, AXIS_LABEL_PROP_ABS_HAT1X},
    {0, AXIS_LABEL_PROP_ABS_HAT1Y},
    {0, AXIS_LABEL_PROP_ABS_HAT2X},
    {0, AXIS_LABEL_PROP_ABS_HAT2Y},
    {0, AXIS_LABEL_PROP_ABS_HAT3X},
    {0, AXIS_LABEL_PROP_ABS_HAT3Y},
    {0, AXIS_LABEL_PROP_ABS_PRESSURE},
    {0, AXIS_LABEL_PROP_ABS_DISTANCE},
    {0, AXIS_LABEL_PROP_ABS_TILT_X},
    {0, AXIS_LABEL_PROP_ABS_TILT_Y},
    {0, AXIS_LABEL_PROP_ABS_TOOL_WIDTH},
    {0, AXIS_LABEL_PROP_ABS_VOLUME},
    {0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MAJOR},
    {0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MINOR},
    {0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MAJOR},
    {0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MINOR},
    {0, AXIS_LABEL_PROP_ABS_MT_ORIENTATION},
    {0, AXIS_LABEL_PROP_ABS_MT_POSITION_X},
    {0, AXIS_LABEL_PROP_ABS_MT_POSITION_Y},
    {0, AXIS_LABEL_PROP_ABS_MT_TOOL_TYPE},
    {0, AXIS_LABEL_PROP_ABS_MT_BLOB_ID},
    {0, AXIS_LABEL_PROP_ABS_MT_TRACKING_ID},
    {0, AXIS_LABEL_PROP_ABS_MT_PRESSURE},
    {0, AXIS_LABEL_PROP_ABS_MISC},

    {0, BTN_LABEL_PROP},
    {0, BTN_LABEL_PROP_BTN_UNKNOWN},
    {0, BTN_LABEL_PROP_BTN_WHEEL_UP},
    {0, BTN_LABEL_PROP_BTN_WHEEL_DOWN},
    {0, BTN_LABEL_PROP_BTN_HWHEEL_LEFT},
    {0, BTN_LABEL_PROP_BTN_HWHEEL_RIGHT},
    {0, BTN_LABEL_PROP_BTN_0},
    {0, BTN_LABEL_PROP_BTN_1},
    {0, BTN_LABEL_PROP_BTN_2},
    {0, BTN_LABEL_PROP_BTN_3},
    {0, BTN_LABEL_PROP_BTN_4},
    {0, BTN_LABEL_PROP_BTN_5},
    {0, BTN_LABEL_PROP_BTN_6},
    {0, BTN_LABEL_PROP_BTN_7},
    {0, BTN_LABEL_PROP_BTN_8},
    {0, BTN_LABEL_PROP_BTN_9},

    {0, BTN_LABEL_PROP_BTN_LEFT},
    {0, BTN_LABEL_PROP_BTN_RIGHT},
    {0, BTN_LABEL_PROP_BTN_MIDDLE},
    {0, BTN_LABEL_PROP_BTN_SIDE},
    {0, BTN_LABEL_PROP_BTN_EXTRA},
    {0, BTN_LABEL_PROP_BTN_FORWARD},
    {0, BTN_LABEL_PROP_BTN_BACK},
    {0, BTN_LABEL_PROP_BTN_TASK},

    {0, BTN_LABEL_PROP_BTN_TRIGGER},
    {0, BTN_LABEL_PROP_BTN_THUMB},
    {0, BTN_LABEL_PROP_BTN_THUMB2},
    {0, BTN_LABEL_PROP_BTN_TOP},
    {0, BTN_LABEL_PROP_BTN_TOP2},
    {0, BTN_LABEL_PROP_BTN_PINKIE},
    {0, BTN_LABEL_PROP_BTN_BASE},
    {0, BTN_LABEL_PROP_BTN_BASE2},
    {0, BTN_LABEL_PROP_BTN_BASE3},
    {0, BTN_LABEL_PROP_BTN_BASE4},
    {0, BTN_LABEL_PROP_BTN_BASE5},
    {0, BTN_LABEL_PROP_BTN_BASE6},
    {0, BTN_LABEL_PROP_BTN_DEAD},

    {0, BTN_LABEL_PROP_BTN_A},
    {0, BTN_LABEL_PROP_BTN_B},
    {0, BTN_LABEL_PROP_BTN_C},
    {0, BTN_LABEL_PROP_BTN_X},
    {0, BTN_LABEL_PROP_BTN_Y},
    {0, BTN_LABEL_PROP_BTN_Z},
    {0, BTN_LABEL_PROP_BTN_TL},
    {0, BTN_LABEL_PROP_BTN_TR},
    {0, BTN_LABEL_PROP_BTN_TL2},
    {0, BTN_LABEL_PROP_BTN_TR2},
    {0, BTN_LABEL_PROP_BTN_SELECT},
    {0, BTN_LABEL_PROP_BTN_START},
    {0, BTN_LABEL_PROP_BTN_MODE},
    {0, BTN_LABEL_PROP_BTN_THUMBL},
    {0, BTN_LABEL_PROP_BTN_THUMBR},

    {0, BTN_LABEL_PROP_BTN_TOOL_PEN},
    {0, BTN_LABEL_PROP_BTN_TOOL_RUBBER},
    {0, BTN_LABEL_PROP_BTN_TOOL_BRUSH},
    {0, BTN_LABEL_PROP_BTN_TOOL_PENCIL},
    {0, BTN_LABEL_PROP_BTN_TOOL_AIRBRUSH},
    {0, BTN_LABEL_PROP_BTN_TOOL_FINGER},
    {0, BTN_LABEL_PROP_BTN_TOOL_MOUSE},
    {0, BTN_LABEL_PROP_BTN_TOOL_LENS},
    {0, BTN_LABEL_PROP_BTN_TOUCH},
    {0, BTN_LABEL_PROP_BTN_STYLUS},
    {0, BTN_LABEL_PROP_BTN_STYLUS2},
    {0, BTN_LABEL_PROP_BTN_TOOL_DOUBLETAP},
    {0, BTN_LABEL_PROP_BTN_TOOL_TRIPLETAP},

    {0, BTN_LABEL_PROP_BTN_GEAR_DOWN},
    {0, BTN_LABEL_PROP_BTN_GEAR_UP},

    {0, XI_PROP_TRANSFORM}
};

static long XIPropHandlerID = 1;

static void send_property_event(DeviceIntPtr dev, Atom property, int what)
{
        devicePropertyNotify    event;
        xXIPropertyEvent        xi2;
        int state;

        if (what == XIPropertyDeleted)
            state = PropertyDelete;
        else
            state = PropertyNewValue;

        event.type      = DevicePropertyNotify;
        event.deviceid  = dev->id;
        event.state     = state;
        event.atom      = property;
        event.time      = currentTime.milliseconds;
        SendEventToAllWindows(dev, DevicePropertyNotifyMask,
                              (xEvent*)&event, 1);

        xi2.type        = GenericEvent;
        xi2.extension   = IReqCode;
        xi2.length      = 0;
        xi2.evtype      = XI_PropertyEvent;
        xi2.deviceid    = dev->id;
        xi2.time        = currentTime.milliseconds;
        xi2.property    = property;
        xi2.what        = what;
        SendEventToAllWindows(dev, GetEventFilter(dev, (xEvent*)&xi2),
                              (xEvent*)&xi2, 1);
}

static int list_atoms(DeviceIntPtr dev, int *natoms, Atom **atoms_return)
{
    XIPropertyPtr prop;
    Atom *atoms         = NULL;
    int nprops          = 0;

    for (prop = dev->properties.properties; prop; prop = prop->next)
        nprops++;
    if (nprops)
    {
        Atom *a;

        atoms = malloc(nprops * sizeof(Atom));
        if(!atoms)
            return BadAlloc;
        a = atoms;
        for (prop = dev->properties.properties; prop; prop = prop->next, a++)
            *a = prop->propertyName;
    }

    *natoms = nprops;
    *atoms_return = atoms;
    return Success;
}

static int
get_property(ClientPtr client, DeviceIntPtr dev, Atom property, Atom type,
             BOOL delete, int offset, int length,
             int *bytes_after, Atom *type_return, int *format, int *nitems,
             int *length_return, char **data)
{
    unsigned long n, len, ind;
    int rc;
    XIPropertyPtr prop;
    XIPropertyValuePtr prop_value;

    if (!ValidAtom(property))
    {
        client->errorValue = property;
        return BadAtom;
    }
    if ((delete != xTrue) && (delete != xFalse))
    {
        client->errorValue = delete;
        return BadValue;
    }

    if ((type != AnyPropertyType) && !ValidAtom(type))
    {
        client->errorValue = type;
        return BadAtom;
    }

    for (prop = dev->properties.properties; prop; prop = prop->next)
        if (prop->propertyName == property)
            break;

    if (!prop)
    {
        *bytes_after = 0;
        *type_return = None;
        *format = 0;
        *nitems = 0;
        *length_return = 0;
        return Success;
    }

    rc = XIGetDeviceProperty(dev, property, &prop_value);
    if (rc != Success)
    {
        client->errorValue = property;
        return rc;
    }

    /* If the request type and actual type don't match. Return the
    property information, but not the data. */

    if (((type != prop_value->type) && (type != AnyPropertyType)))
    {
        *bytes_after = prop_value->size;
        *format = prop_value->format;
        *length_return = 0;
        *nitems = 0;
        *type_return = prop_value->type;
        return Success;
    }

    /* Return type, format, value to client */
    n = (prop_value->format/8) * prop_value->size; /* size (bytes) of prop */
    ind = offset << 2;

   /* If offset is invalid such that it causes "len" to
            be negative, it's a value error. */

    if (n < ind)
    {
        client->errorValue = offset;
        return BadValue;
    }

    len = min(n - ind, 4 * length);

    *bytes_after = n - (ind + len);
    *format = prop_value->format;
    *length_return = len;
    if (prop_value->format)
        *nitems = len / (prop_value->format / 8);
    else
        *nitems = 0;
    *type_return = prop_value->type;

    *data = (char*)prop_value->data + ind;

    return Success;
}

static int
check_change_property(ClientPtr client, Atom property, Atom type, int format,
                      int mode, int nitems)
{
    if ((mode != PropModeReplace) && (mode != PropModeAppend) &&
        (mode != PropModePrepend))
    {
        client->errorValue = mode;
        return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32))
    {
        client->errorValue = format;
        return BadValue;
    }

    if (!ValidAtom(property))
    {
        client->errorValue = property;
        return BadAtom;
    }
    if (!ValidAtom(type))
    {
        client->errorValue = type;
        return BadAtom;
    }

    return Success;
}

static int
change_property(ClientPtr client, DeviceIntPtr dev, Atom property, Atom type,
                int format, int mode, int len, void *data)
{
    int rc = Success;

    rc = XIChangeDeviceProperty(dev, property, type, format, mode, len, data, TRUE);
    if (rc != Success)
        client->errorValue = property;

    return rc;
}

/**
 * Return the atom assigned to the specified string or 0 if the atom isn't known
 * to the DIX.
 *
 * If name is NULL, None is returned.
 */
Atom
XIGetKnownProperty(char *name)
{
    int i;

    if (!name)
        return None;

    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
    {
        if (strcmp(name, dev_properties[i].name) == 0){
            if (dev_properties[i].type == None){
		dev_properties[i].type =
			    MakeAtom(dev_properties[i].name,
			             strlen(dev_properties[i].name),
			             TRUE);
            }

            return dev_properties[i].type;
        }
    }

    return 0;
}

void
XIResetProperties(void)
{
    int i;

    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
        dev_properties[i].type = None;
}

/**
 * Convert the given property's value(s) into @nelem_return integer values and
 * store them in @buf_return. If @nelem_return is larger than the number of
 * values in the property, @nelem_return is set to the number of values in the
 * property.
 *
 * If *@buf_return is NULL and @nelem_return is 0, memory is allocated
 * automatically and must be freed by the caller.
 *
 * Possible return codes.
 * Success ... No error.
 * BadMatch ... Wrong atom type, atom is not XA_INTEGER
 * BadAlloc ... NULL passed as buffer and allocation failed.
 * BadLength ... @buff is NULL but @nelem_return is non-zero.
 *
 * @param val The property value
 * @param nelem_return The maximum number of elements to return.
 * @param buf_return Pointer to an array of at least @nelem_return values.
 * @return Success or the error code if an error occured.
 */
_X_EXPORT int
XIPropToInt(XIPropertyValuePtr val, int *nelem_return, int **buf_return)
{
    int i;
    int *buf;

    if (val->type != XA_INTEGER)
        return BadMatch;
    if (!*buf_return && *nelem_return)
        return BadLength;

    switch(val->format)
    {
        case 8:
        case 16:
        case 32:
            break;
        default:
            return BadValue;
    }

    buf = *buf_return;

    if (!buf && !(*nelem_return))
    {
        buf = calloc(val->size, sizeof(int));
        if (!buf)
            return BadAlloc;
        *buf_return = buf;
        *nelem_return = val->size;
    } else if (val->size < *nelem_return)
        *nelem_return = val->size;

    for (i = 0; i < val->size && i < *nelem_return; i++)
    {
        switch(val->format)
        {
            case 8:  buf[i] = ((CARD8*)val->data)[i]; break;
            case 16: buf[i] = ((CARD16*)val->data)[i]; break;
            case 32: buf[i] = ((CARD32*)val->data)[i]; break;
        }
    }

    return Success;
}

/**
 * Convert the given property's value(s) into @nelem_return float values and
 * store them in @buf_return. If @nelem_return is larger than the number of
 * values in the property, @nelem_return is set to the number of values in the
 * property.
 *
 * If *@buf_return is NULL and @nelem_return is 0, memory is allocated
 * automatically and must be freed by the caller.
 *
 * Possible errors returned:
 * Success
 * BadMatch ... Wrong atom type, atom is not XA_FLOAT
 * BadValue ... Wrong format, format is not 32
 * BadAlloc ... NULL passed as buffer and allocation failed.
 * BadLength ... @buff is NULL but @nelem_return is non-zero.
 *
 * @param val The property value
 * @param nelem_return The maximum number of elements to return.
 * @param buf_return Pointer to an array of at least @nelem_return values.
 * @return Success or the error code if an error occured.
 */
_X_EXPORT int
XIPropToFloat(XIPropertyValuePtr val, int *nelem_return, float **buf_return)
{
    int i;
    float *buf;

    if (!val->type || val->type != XIGetKnownProperty(XATOM_FLOAT))
        return BadMatch;

    if (val->format != 32)
        return BadValue;
    if (!*buf_return && *nelem_return)
        return BadLength;

    buf = *buf_return;

    if (!buf && !(*nelem_return))
    {
        buf = calloc(val->size, sizeof(float));
        if (!buf)
            return BadAlloc;
        *buf_return = buf;
        *nelem_return = val->size;
    } else if (val->size < *nelem_return)
        *nelem_return = val->size;

    for (i = 0; i < val->size && i < *nelem_return; i++)
           buf[i] = ((float*)val->data)[i];

    return Success;
}

/* Registers a new property handler on the given device and returns a unique
 * identifier for this handler. This identifier is required to unregister the
 * property handler again.
 * @return The handler's identifier or 0 if an error occured.
 */
long
XIRegisterPropertyHandler(DeviceIntPtr         dev,
                          int (*SetProperty) (DeviceIntPtr dev,
                                              Atom property,
                                              XIPropertyValuePtr prop,
                                              BOOL checkonly),
                          int (*GetProperty) (DeviceIntPtr dev,
                                              Atom property),
                          int (*DeleteProperty) (DeviceIntPtr dev,
                                                 Atom property))
{
    XIPropertyHandlerPtr new_handler;

    new_handler = calloc(1, sizeof(XIPropertyHandler));
    if (!new_handler)
        return 0;

    new_handler->id = XIPropHandlerID++;
    new_handler->SetProperty = SetProperty;
    new_handler->GetProperty = GetProperty;
    new_handler->DeleteProperty = DeleteProperty;
    new_handler->next = dev->properties.handlers;
    dev->properties.handlers = new_handler;

    return new_handler->id;
}

void
XIUnregisterPropertyHandler(DeviceIntPtr dev, long id)
{
    XIPropertyHandlerPtr curr, prev = NULL;

    curr = dev->properties.handlers;
    while(curr && curr->id != id)
    {
        prev = curr;
        curr = curr->next;
    }

    if (!curr)
        return;

    if (!prev) /* first one */
        dev->properties.handlers = curr->next;
    else
        prev->next = curr->next;

    free(curr);
}

static XIPropertyPtr
XICreateDeviceProperty (Atom property)
{
    XIPropertyPtr   prop;

    prop = (XIPropertyPtr)malloc(sizeof(XIPropertyRec));
    if (!prop)
        return NULL;

    prop->next          = NULL;
    prop->propertyName  = property;
    prop->value.type   = None;
    prop->value.format = 0;
    prop->value.size   = 0;
    prop->value.data   = NULL;
    prop->deletable    = TRUE;

    return prop;
}

static XIPropertyPtr
XIFetchDeviceProperty(DeviceIntPtr dev, Atom property)
{
    XIPropertyPtr   prop;

    for (prop = dev->properties.properties; prop; prop = prop->next)
        if (prop->propertyName == property)
            return prop;
    return NULL;
}

static void
XIDestroyDeviceProperty (XIPropertyPtr prop)
{
    free(prop->value.data);
    free(prop);
}

/* This function destroys all of the device's property-related stuff,
 * including removing all device handlers.
 * DO NOT CALL FROM THE DRIVER.
 */
void
XIDeleteAllDeviceProperties (DeviceIntPtr device)
{
    XIPropertyPtr               prop, next;
    XIPropertyHandlerPtr        curr_handler, next_handler;

    for (prop = device->properties.properties; prop; prop = next)
    {
        next = prop->next;
        send_property_event(device, prop->propertyName, XIPropertyDeleted);
        XIDestroyDeviceProperty(prop);
    }

    device->properties.properties = NULL;

    /* Now free all handlers */
    curr_handler = device->properties.handlers;
    while(curr_handler)
    {
        next_handler = curr_handler->next;
        free(curr_handler);
        curr_handler = next_handler;
    }

    device->properties.handlers = NULL;
}


int
XIDeleteDeviceProperty (DeviceIntPtr device, Atom property, Bool fromClient)
{
    XIPropertyPtr               prop, *prev;
    int                         rc = Success;

    for (prev = &device->properties.properties; (prop = *prev); prev = &(prop->next))
        if (prop->propertyName == property)
            break;

    if (!prop)
        return Success;

    if (fromClient && !prop->deletable)
        return BadAccess;

    /* Ask handlers if we may delete the property */
    if (device->properties.handlers)
    {
        XIPropertyHandlerPtr handler = device->properties.handlers;
        while(handler)
        {
            if (handler->DeleteProperty)
                rc = handler->DeleteProperty(device, prop->propertyName);
            if (rc != Success)
                return rc;
            handler = handler->next;
        }
    }

    if (prop)
    {
        *prev = prop->next;
        send_property_event(device, prop->propertyName, XIPropertyDeleted);
        XIDestroyDeviceProperty (prop);
    }

    return Success;
}

int
XIChangeDeviceProperty (DeviceIntPtr dev, Atom property, Atom type,
                        int format, int mode, unsigned long len,
                        const pointer value, Bool sendevent)
{
    XIPropertyPtr               prop;
    int                         size_in_bytes;
    int                         total_size;
    unsigned long               total_len;
    XIPropertyValuePtr          prop_value;
    XIPropertyValueRec          new_value;
    Bool                        add = FALSE;
    int                         rc;

    size_in_bytes = format >> 3;

    /* first see if property already exists */
    prop = XIFetchDeviceProperty (dev, property);
    if (!prop)   /* just add to list */
    {
        prop = XICreateDeviceProperty (property);
        if (!prop)
            return BadAlloc;
        add = TRUE;
        mode = PropModeReplace;
    }
    prop_value = &prop->value;

    /* To append or prepend to a property the request format and type
     must match those of the already defined property.  The
     existing format and type are irrelevant when using the mode
     "PropModeReplace" since they will be written over. */

    if ((format != prop_value->format) && (mode != PropModeReplace))
        return BadMatch;
    if ((prop_value->type != type) && (mode != PropModeReplace))
        return BadMatch;
    new_value = *prop_value;
    if (mode == PropModeReplace)
        total_len = len;
    else
        total_len = prop_value->size + len;

    if (mode == PropModeReplace || len > 0)
    {
        pointer            new_data = NULL, old_data = NULL;

        total_size = total_len * size_in_bytes;
        new_value.data = (pointer)malloc(total_size);
        if (!new_value.data && total_size)
        {
            if (add)
                XIDestroyDeviceProperty (prop);
            return BadAlloc;
        }
        new_value.size = len;
        new_value.type = type;
        new_value.format = format;

        switch (mode) {
        case PropModeReplace:
            new_data = new_value.data;
            old_data = NULL;
            break;
        case PropModeAppend:
            new_data = (pointer) (((char *) new_value.data) +
                                  (prop_value->size * size_in_bytes));
            old_data = new_value.data;
            break;
        case PropModePrepend:
            new_data = new_value.data;
            old_data = (pointer) (((char *) new_value.data) +
                                  (prop_value->size * size_in_bytes));
            break;
        }
        if (new_data)
            memcpy ((char *) new_data, (char *) value, len * size_in_bytes);
        if (old_data)
            memcpy ((char *) old_data, (char *) prop_value->data,
                    prop_value->size * size_in_bytes);

        if (dev->properties.handlers)
        {
            XIPropertyHandlerPtr handler;
            BOOL checkonly = TRUE;
            /* run through all handlers with checkonly TRUE, then again with
             * checkonly FALSE. Handlers MUST return error codes on the
             * checkonly run, errors on the second run are ignored */
            do
            {
                handler = dev->properties.handlers;
                while(handler)
                {
                    if (handler->SetProperty)
                    {
                        rc = handler->SetProperty(dev, prop->propertyName,
                                &new_value, checkonly);
                        if (checkonly && rc != Success)
                        {
                            free(new_value.data);
                            return rc;
                        }
                    }
                    handler = handler->next;
                }
                checkonly = !checkonly;
            } while (!checkonly);
        }
        free(prop_value->data);
        *prop_value = new_value;
    } else if (len == 0)
    {
        /* do nothing */
    }

    if (add)
    {
        prop->next = dev->properties.properties;
        dev->properties.properties = prop;
    }

    if (sendevent)
        send_property_event(dev, prop->propertyName,
                            (add) ?  XIPropertyCreated : XIPropertyModified);

    return Success;
}

int
XIGetDeviceProperty (DeviceIntPtr dev, Atom property, XIPropertyValuePtr *value)
{
    XIPropertyPtr   prop = XIFetchDeviceProperty (dev, property);
    int rc;

    if (!prop)
    {
        *value = NULL;
        return BadAtom;
    }

    /* If we can, try to update the property value first */
    if (dev->properties.handlers)
    {
        XIPropertyHandlerPtr handler = dev->properties.handlers;
        while(handler)
        {
            if (handler->GetProperty)
            {
                rc = handler->GetProperty(dev, prop->propertyName);
                if (rc != Success)
                {
                    *value = NULL;
                    return rc;
                }
            }
            handler = handler->next;
        }
    }

    *value = &prop->value;
    return Success;
}

int
XISetDevicePropertyDeletable(DeviceIntPtr dev, Atom property, Bool deletable)
{
    XIPropertyPtr prop = XIFetchDeviceProperty(dev, property);

    if (!prop)
        return BadAtom;

    prop->deletable = deletable;
    return Success;
}

int
ProcXListDeviceProperties (ClientPtr client)
{
    Atom                        *atoms;
    xListDevicePropertiesReply  rep;
    int                         natoms;
    DeviceIntPtr                dev;
    int                         rc = Success;

    REQUEST(xListDevicePropertiesReq);
    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);

    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixListPropAccess);
    if (rc != Success)
        return rc;

    rc = list_atoms(dev, &natoms, &atoms);
    if (rc != Success)
        return rc;

    rep.repType = X_Reply;
    rep.RepType = X_ListDeviceProperties;
    rep.length = natoms;
    rep.sequenceNumber = client->sequence;
    rep.nAtoms = natoms;

    WriteReplyToClient(client, sizeof(xListDevicePropertiesReply), &rep);
    if (natoms)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
        WriteSwappedDataToClient(client, natoms * sizeof(Atom), atoms);
        free(atoms);
    }
    return rc;
}

int
ProcXChangeDeviceProperty (ClientPtr client)
{
    REQUEST(xChangeDevicePropertyReq);
    DeviceIntPtr        dev;
    unsigned long       len;
    int                 totalSize;
    int                 rc;

    REQUEST_AT_LEAST_SIZE(xChangeDevicePropertyReq);
    UpdateCurrentTime();

    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    rc = check_change_property(client, stuff->property, stuff->type,
                               stuff->format, stuff->mode, stuff->nUnits);

    len = stuff->nUnits;
    if (len > (bytes_to_int32(0xffffffff - sizeof(xChangeDevicePropertyReq))))
        return BadLength;

    totalSize = len * (stuff->format/8);
    REQUEST_FIXED_SIZE(xChangeDevicePropertyReq, totalSize);

    rc = change_property(client, dev, stuff->property, stuff->type,
                         stuff->format, stuff->mode, len, (void*)&stuff[1]);
    return rc;
}

int
ProcXDeleteDeviceProperty (ClientPtr client)
{
    REQUEST(xDeleteDevicePropertyReq);
    DeviceIntPtr        dev;
    int                 rc;

    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
    UpdateCurrentTime();
    rc =  dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    if (!ValidAtom(stuff->property))
    {
        client->errorValue = stuff->property;
        return BadAtom;
    }

    rc = XIDeleteDeviceProperty(dev, stuff->property, TRUE);
    return rc;
}

int
ProcXGetDeviceProperty (ClientPtr client)
{
    REQUEST(xGetDevicePropertyReq);
    DeviceIntPtr                dev;
    int                         length;
    int                         rc, format, nitems, bytes_after;
    char                        *data;
    Atom                        type;
    xGetDevicePropertyReply     reply;

    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
    if (stuff->delete)
        UpdateCurrentTime();
    rc = dixLookupDevice (&dev, stuff->deviceid, client,
                           stuff->delete ? DixSetPropAccess :
                           DixGetPropAccess);
    if (rc != Success)
        return rc;

    rc = get_property(client, dev, stuff->property, stuff->type,
            stuff->delete, stuff->longOffset, stuff->longLength,
            &bytes_after, &type, &format, &nitems, &length, &data);

    if (rc != Success)
        return rc;

    reply.repType = X_Reply;
    reply.RepType = X_GetDeviceProperty;
    reply.sequenceNumber = client->sequence;
    reply.deviceid = dev->id;
    reply.nItems = nitems;
    reply.format = format;
    reply.bytesAfter = bytes_after;
    reply.propertyType = type;
    reply.length = bytes_to_int32(length);

    if (stuff->delete && (reply.bytesAfter == 0))
        send_property_event(dev, stuff->property, XIPropertyDeleted);

    WriteReplyToClient(client, sizeof(xGenericReply), &reply);

    if (length)
    {
        switch (reply.format) {
            case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
            case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
            default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
        }
        WriteSwappedDataToClient(client, length, data);
    }

    /* delete the Property */
    if (stuff->delete && (reply.bytesAfter == 0))
    {
        XIPropertyPtr prop, *prev;
        for (prev = &dev->properties.properties; (prop = *prev); prev = &prop->next)
        {
            if (prop->propertyName == stuff->property)
            {
                *prev = prop->next;
                XIDestroyDeviceProperty(prop);
                break;
            }
        }
    }
    return Success;
}


int
SProcXListDeviceProperties (ClientPtr client)
{
    char n;
    REQUEST(xListDevicePropertiesReq);

    swaps(&stuff->length, n);

    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);
    return (ProcXListDeviceProperties(client));
}

int
SProcXChangeDeviceProperty (ClientPtr client)
{
    char n;
    REQUEST(xChangeDevicePropertyReq);

    REQUEST_AT_LEAST_SIZE(xChangeDevicePropertyReq);
    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->nUnits, n);
    return (ProcXChangeDeviceProperty(client));
}

int
SProcXDeleteDeviceProperty (ClientPtr client)
{
    char n;
    REQUEST(xDeleteDevicePropertyReq);

    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
    return (ProcXDeleteDeviceProperty(client));
}

int
SProcXGetDeviceProperty (ClientPtr client)
{
    char n;
    REQUEST(xGetDevicePropertyReq);

    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->longOffset, n);
    swapl(&stuff->longLength, n);
    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
    return (ProcXGetDeviceProperty(client));
}


/* Reply swapping */

void
SRepXListDeviceProperties(ClientPtr client, int size,
                          xListDevicePropertiesReply *rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->nAtoms, n);
    /* properties will be swapped later, see ProcXListDeviceProperties */
    WriteToClient(client, size, (char*)rep);
}

void
SRepXGetDeviceProperty(ClientPtr client, int size,
                       xGetDevicePropertyReply *rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->propertyType, n);
    swapl(&rep->bytesAfter, n);
    swapl(&rep->nItems, n);
    /* data will be swapped, see ProcXGetDeviceProperty */
    WriteToClient(client, size, (char*)rep);
}

/* XI2 Request/reply handling */
int
ProcXIListProperties(ClientPtr client)
{
    Atom                        *atoms;
    xXIListPropertiesReply      rep;
    int                         natoms;
    DeviceIntPtr                dev;
    int                         rc = Success;

    REQUEST(xXIListPropertiesReq);
    REQUEST_SIZE_MATCH(xXIListPropertiesReq);

    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixListPropAccess);
    if (rc != Success)
        return rc;

    rc = list_atoms(dev, &natoms, &atoms);
    if (rc != Success)
        return rc;

    rep.repType = X_Reply;
    rep.RepType = X_XIListProperties;
    rep.length = natoms;
    rep.sequenceNumber = client->sequence;
    rep.num_properties = natoms;

    WriteReplyToClient(client, sizeof(xXIListPropertiesReply), &rep);
    if (natoms)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
        WriteSwappedDataToClient(client, natoms * sizeof(Atom), atoms);
        free(atoms);
    }
    return rc;
}

int
ProcXIChangeProperty(ClientPtr client)
{
    int                 rc;
    DeviceIntPtr        dev;
    int                 totalSize;
    unsigned long       len;

    REQUEST(xXIChangePropertyReq);
    REQUEST_AT_LEAST_SIZE(xXIChangePropertyReq);
    UpdateCurrentTime();

    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    rc = check_change_property(client, stuff->property, stuff->type,
                               stuff->format, stuff->mode, stuff->num_items);
    len = stuff->num_items;
    if (len > bytes_to_int32(0xffffffff - sizeof(xXIChangePropertyReq)))
        return BadLength;

    totalSize = len * (stuff->format/8);
    REQUEST_FIXED_SIZE(xXIChangePropertyReq, totalSize);

    rc = change_property(client, dev, stuff->property, stuff->type,
                         stuff->format, stuff->mode, len, (void*)&stuff[1]);
    return rc;
}

int
ProcXIDeleteProperty(ClientPtr client)
{
    DeviceIntPtr        dev;
    int                 rc;
    REQUEST(xXIDeletePropertyReq);

    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);
    UpdateCurrentTime();
    rc =  dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    if (!ValidAtom(stuff->property))
    {
        client->errorValue = stuff->property;
        return BadAtom;
    }

    rc = XIDeleteDeviceProperty(dev, stuff->property, TRUE);
    return rc;
}


int
ProcXIGetProperty(ClientPtr client)
{
    REQUEST(xXIGetPropertyReq);
    DeviceIntPtr                dev;
    xXIGetPropertyReply         reply;
    int                         length;
    int                         rc, format, nitems, bytes_after;
    char                        *data;
    Atom                        type;

    REQUEST_SIZE_MATCH(xXIGetPropertyReq);
    if (stuff->delete)
        UpdateCurrentTime();
    rc = dixLookupDevice (&dev, stuff->deviceid, client,
                           stuff->delete ? DixSetPropAccess :
                           DixGetPropAccess);
    if (rc != Success)
        return rc;

    rc = get_property(client, dev, stuff->property, stuff->type,
            stuff->delete, stuff->offset, stuff->len,
            &bytes_after, &type, &format, &nitems, &length, &data);

    if (rc != Success)
        return rc;

    reply.repType = X_Reply;
    reply.RepType = X_XIGetProperty;
    reply.sequenceNumber = client->sequence;
    reply.num_items = nitems;
    reply.format = format;
    reply.bytes_after = bytes_after;
    reply.type = type;
    reply.length = bytes_to_int32(length);

    if (length && stuff->delete && (reply.bytes_after == 0))
        send_property_event(dev, stuff->property, XIPropertyDeleted);

    WriteReplyToClient(client, sizeof(xXIGetPropertyReply), &reply);

    if (length)
    {
        switch (reply.format) {
            case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
            case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
            default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
        }
        WriteSwappedDataToClient(client, length, data);
    }

    /* delete the Property */
    if (stuff->delete && (reply.bytes_after == 0))
    {
        XIPropertyPtr prop, *prev;
        for (prev = &dev->properties.properties; (prop = *prev); prev = &prop->next)
        {
            if (prop->propertyName == stuff->property)
            {
                *prev = prop->next;
                XIDestroyDeviceProperty(prop);
                break;
            }
        }
    }

    return Success;
}

int
SProcXIListProperties(ClientPtr client)
{
    char n;
    REQUEST(xXIListPropertiesReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);

    REQUEST_SIZE_MATCH(xXIListPropertiesReq);
    return (ProcXIListProperties(client));
}

int
SProcXIChangeProperty(ClientPtr client)
{
    char n;
    REQUEST(xXIChangePropertyReq);

    REQUEST_AT_LEAST_SIZE(xXIChangePropertyReq);
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->num_items, n);
    return (ProcXIChangeProperty(client));
}

int
SProcXIDeleteProperty(ClientPtr client)
{
    char n;
    REQUEST(xXIDeletePropertyReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);
    return (ProcXIDeleteProperty(client));
}

int
SProcXIGetProperty(ClientPtr client)
{
    char n;
    REQUEST(xXIGetPropertyReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->offset, n);
    swapl(&stuff->len, n);
    REQUEST_SIZE_MATCH(xXIGetPropertyReq);
    return (ProcXIGetProperty(client));
}


void
SRepXIListProperties(ClientPtr client, int size,
                     xXIListPropertiesReply *rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_properties, n);
    /* properties will be swapped later, see ProcXIListProperties */
    WriteToClient(client, size, (char*)rep);
}

void
SRepXIGetProperty(ClientPtr client, int size,
                  xXIGetPropertyReply *rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->type, n);
    swapl(&rep->bytes_after, n);
    swapl(&rep->num_items, n);
    /* data will be swapped, see ProcXIGetProperty */
    WriteToClient(client, size, (char*)rep);
}
/*
 * Copyright © 2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XIPROPERTY_H
#define XIPROPERTY_H 1

int ProcXListDeviceProperties     (ClientPtr client);
int ProcXChangeDeviceProperty     (ClientPtr client);
int ProcXDeleteDeviceProperty     (ClientPtr client);
int ProcXGetDeviceProperty        (ClientPtr client);

/* request swapping */
int SProcXListDeviceProperties    (ClientPtr client);
int SProcXChangeDeviceProperty    (ClientPtr client);
int SProcXDeleteDeviceProperty    (ClientPtr client);
int SProcXGetDeviceProperty       (ClientPtr client);

/* reply swapping */
void SRepXListDeviceProperties(ClientPtr client, int size,
                               xListDevicePropertiesReply *rep);
void SRepXGetDeviceProperty(ClientPtr client, int size,
                            xGetDevicePropertyReply *rep);

/* XI2 request/reply handling  */
int ProcXIListProperties        (ClientPtr client);
int ProcXIChangeProperty        (ClientPtr client);
int ProcXIDeleteProperty        (ClientPtr client);
int ProcXIGetProperty           (ClientPtr client);

int SProcXIListProperties       (ClientPtr client);
int SProcXIChangeProperty       (ClientPtr client);
int SProcXIDeleteProperty       (ClientPtr client);
int SProcXIGetProperty          (ClientPtr client);

void SRepXIListProperties(ClientPtr client, int size,
                          xXIListPropertiesReply *rep);
void SRepXIGetProperty(ClientPtr client, int size,
                       xXIGetPropertyReply *rep);

void XIResetProperties(void);

#endif /* XIPROPERTY_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

/**
 * @file Protocol handling for the XIQueryDevice request/reply.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"
#include <X11/X.h>
#include <X11/Xatom.h>
#include <X11/extensions/XI2proto.h>
#include "xkbstr.h"
#include "xkbsrv.h"
#include "xserver-properties.h"
#include "exevents.h"
#include "xace.h"

#include "xiquerydevice.h"

static Bool ShouldSkipDevice(ClientPtr client, int deviceid, DeviceIntPtr d);
static int
ListDeviceInfo(ClientPtr client, DeviceIntPtr dev, xXIDeviceInfo* info);
static int SizeDeviceInfo(DeviceIntPtr dev);
static void SwapDeviceInfo(DeviceIntPtr dev, xXIDeviceInfo* info);
int
SProcXIQueryDevice(ClientPtr client)
{
    char n;

    REQUEST(xXIQueryDeviceReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);

    return ProcXIQueryDevice(client);
}

int
ProcXIQueryDevice(ClientPtr client)
{
    xXIQueryDeviceReply rep;
    DeviceIntPtr dev = NULL;
    int rc = Success;
    int i = 0, len = 0;
    char *info, *ptr;
    Bool *skip = NULL;

    REQUEST(xXIQueryDeviceReq);
    REQUEST_SIZE_MATCH(xXIQueryDeviceReq);

    if (stuff->deviceid != XIAllDevices && stuff->deviceid != XIAllMasterDevices)
    {
        rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->deviceid;
            return rc;
        }
        len += SizeDeviceInfo(dev);
    }
    else
    {
        skip = calloc(sizeof(Bool), inputInfo.numDevices);
        if (!skip)
            return BadAlloc;

        for (dev = inputInfo.devices; dev; dev = dev->next, i++)
        {
            skip[i] = ShouldSkipDevice(client, stuff->deviceid, dev);
            if (!skip[i])
                len += SizeDeviceInfo(dev);
        }

        for (dev = inputInfo.off_devices; dev; dev = dev->next, i++)
        {
            skip[i] = ShouldSkipDevice(client, stuff->deviceid, dev);
            if (!skip[i])
                len += SizeDeviceInfo(dev);
        }
    }

    info = calloc(1, len);
    if (!info) {
        free(skip);
        return BadAlloc;
    }

    memset(&rep, 0, sizeof(xXIQueryDeviceReply));
    rep.repType = X_Reply;
    rep.RepType = X_XIQueryDevice;
    rep.sequenceNumber = client->sequence;
    rep.length = len/4;
    rep.num_devices = 0;

    ptr = info;
    if (dev)
    {
        len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
        if (client->swapped)
            SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
        info += len;
        rep.num_devices = 1;
    } else
    {
        i = 0;
        for (dev = inputInfo.devices; dev; dev = dev->next, i++)
        {
            if (!skip[i])
            {
                len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
                if (client->swapped)
                    SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
                info += len;
                rep.num_devices++;
            }
        }

        for (dev = inputInfo.off_devices; dev; dev = dev->next, i++)
        {
            if (!skip[i])
            {
                len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
                if (client->swapped)
                    SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
                info += len;
                rep.num_devices++;
            }
        }
    }

    len = rep.length * 4;
    WriteReplyToClient(client, sizeof(xXIQueryDeviceReply), &rep);
    WriteToClient(client, len, ptr);
    free(ptr);
    free(skip);
    return rc;
}

void
SRepXIQueryDevice(ClientPtr client, int size, xXIQueryDeviceReply *rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_devices, n);

    /* Device info is already swapped, see ProcXIQueryDevice */

    WriteToClient(client, size, (char *)rep);
}


/**
 * @return Whether the device should be included in the returned list.
 */
static Bool
ShouldSkipDevice(ClientPtr client, int deviceid, DeviceIntPtr dev)
{
    /* if all devices are not being queried, only master devices are */
    if (deviceid == XIAllDevices || IsMaster(dev))
    {
        int rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixGetAttrAccess);
        if (rc == Success)
            return FALSE;
    }
    return TRUE;
}

/**
 * @return The number of bytes needed to store this device's xXIDeviceInfo
 * (and its classes).
 */
static int
SizeDeviceInfo(DeviceIntPtr dev)
{
    int len = sizeof(xXIDeviceInfo);

    /* 4-padded name */
    len += pad_to_int32(strlen(dev->name));

    return len + SizeDeviceClasses(dev);

}

/*
 * @return The number of bytes needed to store this device's classes.
 */
int
SizeDeviceClasses(DeviceIntPtr dev)
{
    int len = 0;

    if (dev->button)
    {
        len += sizeof(xXIButtonInfo);
        len += dev->button->numButtons * sizeof(Atom);
        len += pad_to_int32(bits_to_bytes(dev->button->numButtons));
    }

    if (dev->key)
    {
        XkbDescPtr xkb = dev->key->xkbInfo->desc;
        len += sizeof(xXIKeyInfo);
        len += (xkb->max_key_code - xkb->min_key_code + 1) * sizeof(uint32_t);
    }

    if (dev->valuator)
        len += sizeof(xXIValuatorInfo) * dev->valuator->numAxes;

    return len;
}


/**
 * Write button information into info.
 * @return Number of bytes written into info.
 */
int
ListButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info, Bool reportState)
{
    unsigned char *bits;
    int mask_len;
    int i;

    if (!dev || !dev->button)
	return 0;

    mask_len = bytes_to_int32(bits_to_bytes(dev->button->numButtons));

    info->type = ButtonClass;
    info->num_buttons = dev->button->numButtons;
    info->length = bytes_to_int32(sizeof(xXIButtonInfo)) +
                   info->num_buttons + mask_len;
    info->sourceid = dev->button->sourceid;

    bits = (unsigned char*)&info[1];
    memset(bits, 0, mask_len * 4);

    if (reportState)
	for (i = 0; i < dev->button->numButtons; i++)
	    if (BitIsOn(dev->button->down, i))
		SetBit(bits, i);

    bits += mask_len * 4;
    memcpy(bits, dev->button->labels, dev->button->numButtons * sizeof(Atom));

    return info->length * 4;
}

static void
SwapButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info)
{
    char n;
    Atom *btn;
    int i;
    swaps(&info->type, n);
    swaps(&info->length, n);
    swaps(&info->sourceid, n);

    for (i = 0, btn = (Atom*)&info[1]; i < info->num_buttons; i++, btn++)
        swaps(btn, n);

    swaps(&info->num_buttons, n);
}

/**
 * Write key information into info.
 * @return Number of bytes written into info.
 */
int
ListKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info)
{
    int i;
    XkbDescPtr xkb = dev->key->xkbInfo->desc;
    uint32_t *kc;

    info->type = KeyClass;
    info->num_keycodes = xkb->max_key_code - xkb->min_key_code + 1;
    info->length = sizeof(xXIKeyInfo)/4 + info->num_keycodes;
    info->sourceid = dev->key->sourceid;

    kc = (uint32_t*)&info[1];
    for (i = xkb->min_key_code; i <= xkb->max_key_code; i++, kc++)
        *kc = i;

    return info->length * 4;
}

static void
SwapKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info)
{
    char n;
    uint32_t *key;
    int i;
    swaps(&info->type, n);
    swaps(&info->length, n);
    swaps(&info->sourceid, n);

    for (i = 0, key = (uint32_t*)&info[1]; i < info->num_keycodes; i++, key++)
        swapl(key, n);

    swaps(&info->num_keycodes, n);
}

/**
 * List axis information for the given axis.
 *
 * @return The number of bytes written into info.
 */
int
ListValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info, int axisnumber,
		 Bool reportState)
{
    ValuatorClassPtr v = dev->valuator;

    info->type = ValuatorClass;
    info->length = sizeof(xXIValuatorInfo)/4;
    info->label = v->axes[axisnumber].label;
    info->min.integral = v->axes[axisnumber].min_value;
    info->min.frac = 0;
    info->max.integral = v->axes[axisnumber].max_value;
    info->max.frac = 0;
    info->value.integral = (int)v->axisVal[axisnumber];
    info->value.frac = (int)(v->axisVal[axisnumber] * (1 << 16) * (1 << 16));
    info->resolution = v->axes[axisnumber].resolution;
    info->number = axisnumber;
    info->mode = valuator_get_mode(dev, axisnumber);
    info->sourceid = v->sourceid;

    if (!reportState)
	info->value = info->min;

    return info->length * 4;
}

static void
SwapValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info)
{
    char n;
    swaps(&info->type, n);
    swaps(&info->length, n);
    swapl(&info->label, n);
    swapl(&info->min.integral, n);
    swapl(&info->min.frac, n);
    swapl(&info->max.integral, n);
    swapl(&info->max.frac, n);
    swaps(&info->number, n);
    swaps(&info->sourceid, n);
}

int GetDeviceUse(DeviceIntPtr dev, uint16_t *attachment)
{
    DeviceIntPtr master = GetMaster(dev, MASTER_ATTACHED);
    int use;

    if (IsMaster(dev))
    {
        DeviceIntPtr paired = GetPairedDevice(dev);
        use = IsPointerDevice(dev) ? XIMasterPointer : XIMasterKeyboard;
        *attachment = (paired ? paired->id : 0);
    } else if (!IsFloating(dev))
    {
        use = IsPointerDevice(master) ? XISlavePointer : XISlaveKeyboard;
        *attachment = master->id;
    } else
        use = XIFloatingSlave;

    return use;
}

/**
 * Write the info for device dev into the buffer pointed to by info.
 *
 * @return The number of bytes used.
 */
static int
ListDeviceInfo(ClientPtr client, DeviceIntPtr dev, xXIDeviceInfo* info)
{
    char *any = (char*)&info[1];
    int len = 0, total_len = 0;

    info->deviceid = dev->id;
    info->use = GetDeviceUse(dev, &info->attachment);
    info->num_classes = 0;
    info->name_len = strlen(dev->name);
    info->enabled = dev->enabled;
    total_len = sizeof(xXIDeviceInfo);

    len = pad_to_int32(info->name_len);
    memset(any, 0, len);
    strncpy(any, dev->name, info->name_len);
    any += len;
    total_len += len;

    total_len += ListDeviceClasses(client, dev, any, &info->num_classes);
    return total_len;
}

/**
 * Write the class info of the device into the memory pointed to by any, set
 * nclasses to the number of classes in total and return the number of bytes
 * written.
 */
int
ListDeviceClasses(ClientPtr client, DeviceIntPtr dev,
		  char *any, uint16_t *nclasses)
{
    int total_len = 0;
    int len;
    int i;
    int rc;

    /* Check if the current device state should be suppressed */
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixReadAccess);

    if (dev->button)
    {
        (*nclasses)++;
        len = ListButtonInfo(dev, (xXIButtonInfo*)any, rc == Success);
        any += len;
        total_len += len;
    }

    if (dev->key)
    {
        (*nclasses)++;
        len = ListKeyInfo(dev, (xXIKeyInfo*)any);
        any += len;
        total_len += len;
    }

    for (i = 0; dev->valuator && i < dev->valuator->numAxes; i++)
    {
        (*nclasses)++;
        len = ListValuatorInfo(dev, (xXIValuatorInfo*)any, i, rc == Success);
        any += len;
        total_len += len;
    }

    return total_len;
}

static void
SwapDeviceInfo(DeviceIntPtr dev, xXIDeviceInfo* info)
{
    char n;
    char *any = (char*)&info[1];
    int i;

    /* Skip over name */
    any += pad_to_int32(info->name_len);

    for (i = 0; i < info->num_classes; i++)
    {
        int len = ((xXIAnyInfo*)any)->length;
        switch(((xXIAnyInfo*)any)->type)
        {
            case XIButtonClass:
                SwapButtonInfo(dev, (xXIButtonInfo*)any);
                break;
            case XIKeyClass:
                SwapKeyInfo(dev, (xXIKeyInfo*)any);
                break;
            case XIValuatorClass:
                SwapValuatorInfo(dev, (xXIValuatorInfo*)any);
                break;
        }

        any += len * 4;
    }

    swaps(&info->deviceid, n);
    swaps(&info->use, n);
    swaps(&info->attachment, n);
    swaps(&info->num_classes, n);
    swaps(&info->name_len, n);

}
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef QUERYDEV_H
#define QUERYDEV_H 1

#include <X11/extensions/XI2proto.h>

int SProcXIQueryDevice(ClientPtr client);
int ProcXIQueryDevice(ClientPtr client);
void SRepXIQueryDevice(ClientPtr client, int size, xXIQueryDeviceReply *rep);
int SizeDeviceClasses(DeviceIntPtr dev);
int ListDeviceClasses(ClientPtr client, DeviceIntPtr dev,
		      char* any, uint16_t* nclasses);
int GetDeviceUse(DeviceIntPtr dev, uint16_t *attachment);
int ListButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info, Bool reportState);
int ListKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info);
int ListValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info,
		     int axisnumber, Bool reportState);
#endif /* QUERYDEV_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request to query the pointer location of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "eventconvert.h"
#include "scrnintstr.h"
#include "xkbsrv.h"

#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

#include "xiquerypointer.h"

/***********************************************************************
 *
 * This procedure allows a client to query the pointer of a device.
 *
 */

int
SProcXIQueryPointer(ClientPtr client)
{
    char n;

    REQUEST(xXIQueryPointerReq);
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->win, n);
    return (ProcXIQueryPointer(client));
}

int
ProcXIQueryPointer(ClientPtr client)
{
    int rc;
    xXIQueryPointerReply rep;
    DeviceIntPtr pDev, kbd;
    WindowPtr pWin, t;
    SpritePtr pSprite;
    XkbStatePtr state;
    char *buttons = NULL;
    int buttons_size = 0; /* size of buttons array */

    REQUEST(xXIQueryPointerReq);
    REQUEST_SIZE_MATCH(xXIQueryPointerReq);

    rc = dixLookupDevice(&pDev, stuff->deviceid, client, DixReadAccess);
    if (rc != Success)
    {
        client->errorValue = stuff->deviceid;
        return rc;
    }

    if (pDev->valuator == NULL || IsKeyboardDevice(pDev) ||
        (!IsMaster(pDev) && !IsFloating(pDev))) /* no attached devices */
    {
        client->errorValue = stuff->deviceid;
        return BadDevice;
    }

    rc = dixLookupWindow(&pWin, stuff->win, client, DixGetAttrAccess);
    if (rc != Success)
    {
        SendErrorToClient(client, IReqCode, X_XIQueryPointer,
                stuff->win, rc);
        return Success;
    }

    if (pDev->valuator->motionHintWindow)
        MaybeStopHint(pDev, client);

    if (IsMaster(pDev))
        kbd = GetPairedDevice(pDev);
    else
        kbd = (pDev->key) ? pDev : NULL;

    pSprite = pDev->spriteInfo->sprite;

    memset(&rep, 0, sizeof(rep));
    rep.repType = X_Reply;
    rep.RepType = X_XIQueryPointer;
    rep.length = 6;
    rep.sequenceNumber = client->sequence;
    rep.root = (GetCurrentRootWindow(pDev))->drawable.id;
    rep.root_x = FP1616(pSprite->hot.x, 0);
    rep.root_y = FP1616(pSprite->hot.y, 0);
    rep.child = None;

    if (kbd)
    {
        state = &kbd->key->xkbInfo->state;
        rep.mods.base_mods = state->base_mods;
        rep.mods.latched_mods = state->latched_mods;
        rep.mods.locked_mods = state->locked_mods;

        rep.group.base_group = state->base_group;
        rep.group.latched_group = state->latched_group;
        rep.group.locked_group = state->locked_group;
    }

    if (pDev->button)
    {
        int i, down;
        rep.buttons_len = bytes_to_int32(bits_to_bytes(pDev->button->numButtons));
        rep.length += rep.buttons_len;
        buttons_size = rep.buttons_len * 4;
        buttons = calloc(1, buttons_size);
        if (!buttons)
            return BadAlloc;

        down = pDev->button->buttonsDown;

        for (i = 0; i < pDev->button->numButtons && down; i++)
        {
            if (BitIsOn(pDev->button->down, i))
            {
                SetBit(buttons, i);
                down--;
            }
        }
    } else
        rep.buttons_len = 0;

    if (pSprite->hot.pScreen == pWin->drawable.pScreen)
    {
        rep.same_screen = xTrue;
        rep.win_x = FP1616(pSprite->hot.x - pWin->drawable.x, 0);
        rep.win_y = FP1616(pSprite->hot.y - pWin->drawable.y, 0);
        for (t = pSprite->win; t; t = t->parent)
            if (t->parent == pWin)
            {
                rep.child = t->drawable.id;
                break;
            }
    } else
    {
        rep.same_screen = xFalse;
        rep.win_x = 0;
        rep.win_y = 0;
    }

#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
        rep.root_x += FP1616(screenInfo.screens[0]->x, 0);
        rep.root_y += FP1616(screenInfo.screens[0]->y, 0);
        if (stuff->win == rep.root)
        {
            rep.win_x += FP1616(screenInfo.screens[0]->x, 0);
            rep.win_y += FP1616(screenInfo.screens[0]->y, 0);
        }
    }
#endif

    WriteReplyToClient(client, sizeof(xXIQueryPointerReply), &rep);
    if (buttons)
        WriteToClient(client, buttons_size, buttons);

    free(buttons);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XIQueryPointer function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXIQueryPointer(ClientPtr client, int size,
                   xXIQueryPointerReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->root, n);
    swapl(&rep->child, n);
    swapl(&rep->root_x, n);
    swapl(&rep->root_y, n);
    swapl(&rep->win_x, n);
    swapl(&rep->win_y, n);
    swaps(&rep->buttons_len, n);

    WriteToClient(client, size, (char *)rep);
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef QUERYDP_H
#define QUERYDP_H 1

int SProcXIQueryPointer(ClientPtr /* client */);
int ProcXIQueryPointer(ClientPtr /* client */);
void SRepXIQueryPointer(ClientPtr /* client */ ,
			int /* size */ ,
			xXIQueryPointerReply *	/* rep */);

#endif /* QUERYDP_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

/**
 * @file xiqueryversion.c
 * Protocol handling for the XIQueryVersion request/reply.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif


#include "inputstr.h"

#include <X11/Xmd.h>
#include <X11/X.h>
#include <X11/extensions/XI2proto.h>

#include "exglobals.h"
#include "exevents.h"
#include "xiqueryversion.h"
#include "misc.h"

extern XExtensionVersion XIVersion; /* defined in getvers.c */
/**
 * Return the supported XI version.
 *
 * Saves the version the client claims to support as well, for future
 * reference.
 */
int
ProcXIQueryVersion(ClientPtr client)
{
    xXIQueryVersionReply rep;
    XIClientPtr pXIClient;
    int major, minor;

    REQUEST(xXIQueryVersionReq);
    REQUEST_SIZE_MATCH(xXIQueryVersionReq);

    /* This request only exists after XI2 */
    if (stuff->major_version < 2)
    {
        client->errorValue = stuff->major_version;
        return BadValue;
    }

    pXIClient = dixLookupPrivate(&client->devPrivates, XIClientPrivateKey);

    if (version_compare(XIVersion.major_version, XIVersion.minor_version,
                        stuff->major_version, stuff->minor_version) > 0)
    {
        major = stuff->major_version;
        minor = stuff->minor_version;
    } else
    {
        major = XIVersion.major_version;
        minor = XIVersion.minor_version;
    }

    pXIClient->major_version = major;
    pXIClient->minor_version = minor;

    memset(&rep, 0, sizeof(xXIQueryVersionReply));
    rep.repType = X_Reply;
    rep.RepType = X_XIQueryVersion;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.major_version = major;
    rep.minor_version = minor;

    WriteReplyToClient(client, sizeof(xXIQueryVersionReply), &rep);

    return Success;
}

/* Swapping routines */

int
SProcXIQueryVersion(ClientPtr client)
{
    char n;

    REQUEST(xXIQueryVersionReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXIQueryVersionReq);
    swaps(&stuff->major_version, n);
    swaps(&stuff->minor_version, n);
    return (ProcXIQueryVersion(client));
}

void
SRepXIQueryVersion(ClientPtr client, int size, xXIQueryVersionReply *rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->major_version, n);
    swaps(&rep->minor_version, n);
    WriteToClient(client, size, (char *)rep);
}
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/extensions/XI2proto.h>

#ifndef QUERYVERSION_H
#define QUERYVERSION_H 1

int SProcXIQueryVersion(ClientPtr client);
int ProcXIQueryVersion(ClientPtr client);
void SRepXIQueryVersion(ClientPtr client, int size, xXIQueryVersionReply* rep);

#endif /* QUERYVERSION_H */
/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif


#include "dixstruct.h"
#include "windowstr.h"
#include "exglobals.h"
#include "exevents.h"
#include <X11/extensions/XI2proto.h>

#include "xiselectev.h"

/**
 * Check the given mask (in len bytes) for invalid mask bits.
 * Invalid mask bits are any bits above XI2LastEvent.
 *
 * @return BadValue if at least one invalid bit is set or Success otherwise.
 */
int XICheckInvalidMaskBits(ClientPtr client, unsigned char *mask, int len)
{
    if (len >= XIMaskLen(XI2LASTEVENT))
    {
        int i;
        for (i = XI2LASTEVENT + 1; i < len * 8; i++)
        {
            if (BitIsOn(mask, i))
            {
                client->errorValue = i;
                return BadValue;
            }
        }
    }

    return Success;
}

int
SProcXISelectEvents(ClientPtr client)
{
    char n;
    int i;
    xXIEventMask* evmask;

    REQUEST(xXISelectEventsReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXISelectEventsReq);
    swapl(&stuff->win, n);
    swaps(&stuff->num_masks, n);

    evmask = (xXIEventMask*)&stuff[1];
    for (i = 0; i < stuff->num_masks; i++)
    {
        swaps(&evmask->deviceid, n);
        swaps(&evmask->mask_len, n);
        evmask = (xXIEventMask*)(((char*)&evmask[1]) + evmask->mask_len * 4);
    }

    return (ProcXISelectEvents(client));
}

int
ProcXISelectEvents(ClientPtr client)
{
    int rc, num_masks;
    WindowPtr win;
    DeviceIntPtr dev;
    DeviceIntRec dummy;
    xXIEventMask *evmask;
    int *types = NULL;
    int len;

    REQUEST(xXISelectEventsReq);
    REQUEST_AT_LEAST_SIZE(xXISelectEventsReq);

    if (stuff->num_masks == 0)
        return BadValue;

    rc = dixLookupWindow(&win, stuff->win, client, DixReceiveAccess);
    if (rc != Success)
        return rc;

    len = sz_xXISelectEventsReq;

    /* check request validity */
    evmask = (xXIEventMask*)&stuff[1];
    num_masks = stuff->num_masks;
    while(num_masks--)
    {
        len += sizeof(xXIEventMask) + evmask->mask_len * 4;

        if (bytes_to_int32(len) > stuff->length)
            return BadLength;

        if (evmask->deviceid != XIAllDevices &&
            evmask->deviceid != XIAllMasterDevices)
            rc = dixLookupDevice(&dev, evmask->deviceid, client, DixUseAccess);
        else {
            /* XXX: XACE here? */
        }
        if (rc != Success)
            return rc;

        /* hierarchy event mask is not allowed on devices */
        if (evmask->deviceid != XIAllDevices && evmask->mask_len >= 1)
        {
            unsigned char *bits = (unsigned char*)&evmask[1];
            if (BitIsOn(bits, XI_HierarchyChanged))
            {
                client->errorValue = XI_HierarchyChanged;
                return BadValue;
            }
        }

        /* Raw events may only be selected on root windows */
        if (win->parent && evmask->mask_len >= 1)
        {
            unsigned char *bits = (unsigned char*)&evmask[1];
            if (BitIsOn(bits, XI_RawKeyPress) ||
                BitIsOn(bits, XI_RawKeyRelease) ||
                BitIsOn(bits, XI_RawButtonPress) ||
                BitIsOn(bits, XI_RawButtonRelease) ||
                BitIsOn(bits, XI_RawMotion))
            {
                client->errorValue = XI_RawKeyPress;
                return BadValue;
            }
        }

        if (XICheckInvalidMaskBits(client, (unsigned char*)&evmask[1],
                                   evmask->mask_len * 4) != Success)
            return BadValue;

        evmask = (xXIEventMask*)(((unsigned char*)evmask) + evmask->mask_len * 4);
        evmask++;
    }

    if (bytes_to_int32(len) != stuff->length)
        return BadLength;

    /* Set masks on window */
    evmask = (xXIEventMask*)&stuff[1];
    num_masks = stuff->num_masks;
    while(num_masks--)
    {
        if (evmask->deviceid == XIAllDevices ||
            evmask->deviceid == XIAllMasterDevices)
        {
            dummy.id = evmask->deviceid;
            dev = &dummy;
        } else
            dixLookupDevice(&dev, evmask->deviceid, client, DixUseAccess);
        if (XISetEventMask(dev, win, client, evmask->mask_len * 4,
                           (unsigned char*)&evmask[1]) != Success)
            return BadAlloc;
        evmask = (xXIEventMask*)(((unsigned char*)evmask) + evmask->mask_len * 4);
        evmask++;
    }

    RecalculateDeliverableEvents(win);

    free(types);
    return Success;
}


int
SProcXIGetSelectedEvents(ClientPtr client)
{
    char n;

    REQUEST(xXIGetSelectedEventsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXIGetSelectedEventsReq);
    swapl(&stuff->win, n);

    return (ProcXIGetSelectedEvents(client));
}

int
ProcXIGetSelectedEvents(ClientPtr client)
{
    int rc, i;
    WindowPtr win;
    char n;
    char *buffer = NULL;
    xXIGetSelectedEventsReply reply;
    OtherInputMasks *masks;
    InputClientsPtr others = NULL;
    xXIEventMask *evmask = NULL;
    DeviceIntPtr dev;

    REQUEST(xXIGetSelectedEventsReq);
    REQUEST_SIZE_MATCH(xXIGetSelectedEventsReq);

    rc = dixLookupWindow(&win, stuff->win, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    reply.repType = X_Reply;
    reply.RepType = X_XIGetSelectedEvents;
    reply.length = 0;
    reply.sequenceNumber = client->sequence;
    reply.num_masks = 0;

    masks = wOtherInputMasks(win);
    if (masks)
    {
	for (others = wOtherInputMasks(win)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
                break;
            }
        }
    }

    if (!others)
    {
        WriteReplyToClient(client, sizeof(xXIGetSelectedEventsReply), &reply);
        return Success;
    }

    buffer = calloc(MAXDEVICES, sizeof(xXIEventMask) + pad_to_int32(XI2MASKSIZE));
    if (!buffer)
        return BadAlloc;

    evmask = (xXIEventMask*)buffer;
    for (i = 0; i < MAXDEVICES; i++)
    {
        int j;
        unsigned char *devmask = others->xi2mask[i];

        if (i > 2)
        {
            rc = dixLookupDevice(&dev, i, client, DixGetAttrAccess);
            if (rc != Success)
                continue;
        }


        for (j = XI2MASKSIZE - 1; j >= 0; j--)
        {
            if (devmask[j] != 0)
            {
                int mask_len = (j + 4)/4; /* j is an index, hence + 4, not + 3 */
                evmask->deviceid = i;
                evmask->mask_len = mask_len;
                reply.num_masks++;
                reply.length += sizeof(xXIEventMask)/4 + evmask->mask_len;

                if (client->swapped)
                {
                    swaps(&evmask->deviceid, n);
                    swaps(&evmask->mask_len, n);
                }

                memcpy(&evmask[1], devmask, j + 1);
                evmask = (xXIEventMask*)((char*)evmask +
                           sizeof(xXIEventMask) + mask_len * 4);
                break;
            }
        }
    }

    WriteReplyToClient(client, sizeof(xXIGetSelectedEventsReply), &reply);

    if (reply.num_masks)
        WriteToClient(client, reply.length * 4, buffer);

    free(buffer);
    return Success;
}

void SRepXIGetSelectedEvents(ClientPtr client,
                            int len, xXIGetSelectedEventsReply *rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_masks, n);
    WriteToClient(client, len, (char *)rep);
}


/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XISELECTEVENTS_H
#define XISELECTEVENTS_H 1

int SProcXISelectEvents(ClientPtr client);
int ProcXISelectEvents(ClientPtr client);
int SProcXIGetSelectedEvents(ClientPtr client);
int ProcXIGetSelectedEvents(ClientPtr client);
void SRepXIGetSelectedEvents(ClientPtr client,
                             int len, xXIGetSelectedEventsReply *rep);

#endif /* _XISELECTEVENTS_H_ */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request to set the client pointer for the owner of the given window.
 * All subsequent calls that are ambiguous will choose the client pointer as
 * default value.
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"

#include "xisetclientpointer.h"

int
SProcXISetClientPointer(ClientPtr client)
{
    char n;

    REQUEST(xXISetClientPointerReq);
    swaps(&stuff->length, n);
    swapl(&stuff->win, n);
    swaps(&stuff->deviceid, n);
    REQUEST_SIZE_MATCH(xXISetClientPointerReq);
    return (ProcXISetClientPointer(client));
}

int
ProcXISetClientPointer(ClientPtr client)
{
    DeviceIntPtr pDev;
    ClientPtr targetClient;
    int rc;

    REQUEST(xXISetClientPointerReq);
    REQUEST_SIZE_MATCH(xXISetClientPointerReq);


    rc = dixLookupDevice(&pDev, stuff->deviceid, client, DixManageAccess);
    if (rc != Success)
    {
        client->errorValue = stuff->deviceid;
        return rc;
    }

    if (!IsMaster(pDev))
    {
        client->errorValue = stuff->deviceid;
        return BadDevice;
    }

    pDev = GetMaster(pDev, MASTER_POINTER);

    if (stuff->win != None)
    {
        rc = dixLookupClient(&targetClient, stuff->win, client,
                DixManageAccess);

        if (rc != Success)
            return BadWindow;

    } else
        targetClient = client;

    rc = SetClientPointer(targetClient, pDev);
    if (rc != Success)
    {
        client->errorValue = stuff->deviceid;
        return rc;
    }

    return Success;
}
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETCPTR_H
#define SETCPTR_H 1

int SProcXISetClientPointer(ClientPtr /* client */);
int ProcXISetClientPointer(ClientPtr /* client */);

#endif /* SETCPTR_H */
/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */
/***********************************************************************
 *
 * Request to set and get an input device's focus.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI2.h>
#include <X11/extensions/XI2proto.h>

#include "exglobals.h" /* BadDevice */
#include "xisetdevfocus.h"

int
SProcXISetFocus(ClientPtr client)
{
    char n;

    REQUEST(xXISetFocusReq);
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->focus, n);
    swapl(&stuff->time, n);

    return ProcXISetFocus(client);
}

int
SProcXIGetFocus(ClientPtr client)
{
    char n;

    REQUEST(xXIGetFocusReq);
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);

    return ProcXIGetFocus(client);
}

int
ProcXISetFocus(ClientPtr client)
{
    DeviceIntPtr dev;
    int ret;

    REQUEST(xXISetFocusReq);
    REQUEST_AT_LEAST_SIZE(xXISetFocusReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixSetFocusAccess);
    if (ret != Success)
	return ret;
    if (!dev->focus)
	return BadDevice;

    return SetInputFocus(client, dev, stuff->focus, RevertToParent,
                        stuff->time, TRUE);
}

int
ProcXIGetFocus(ClientPtr client)
{
    xXIGetFocusReply rep;
    DeviceIntPtr dev;
    int ret;

    REQUEST(xXIGetFocusReq);
    REQUEST_AT_LEAST_SIZE(xXIGetFocusReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGetFocusAccess);
    if (ret != Success)
	return ret;
    if (!dev->focus)
	return BadDevice;

    rep.repType = X_Reply;
    rep.RepType = X_XIGetFocus;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (dev->focus->win == NoneWin)
	rep.focus = None;
    else if (dev->focus->win == PointerRootWin)
	rep.focus = PointerRoot;
    else if (dev->focus->win == FollowKeyboardWin)
	rep.focus = FollowKeyboard;
    else
	rep.focus = dev->focus->win->drawable.id;

    WriteReplyToClient(client, sizeof(xXIGetFocusReply), &rep);
    return Success;
}

void
SRepXIGetFocus(ClientPtr client, int len, xXIGetFocusReply *rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->focus, n);
    WriteToClient(client, len, (char *)rep);
}
/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XISETDEVFOCUS_H
#define XISETDEVFOCUS_H 1

int SProcXISetFocus(ClientPtr client);
int ProcXISetFocus(ClientPtr client);

int SProcXIGetFocus(ClientPtr client);
int ProcXIGetFocus(ClientPtr client);

void SRepXIGetFocus(ClientPtr client, int len, xXIGetFocusReply* rep);
#endif /* XISETDEVFOCUS_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request to Warp the pointer location of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "mipointer.h" /* for miPointerUpdateSprite */


#include "xiwarppointer.h"
/***********************************************************************
 *
 * This procedure allows a client to warp the pointer of a device.
 *
 */

int
SProcXIWarpPointer(ClientPtr client)
{
    char n;

    REQUEST(xXIWarpPointerReq);
    swaps(&stuff->length, n);
    swapl(&stuff->src_win, n);
    swapl(&stuff->dst_win, n);
    swapl(&stuff->src_x, n);
    swapl(&stuff->src_y, n);
    swaps(&stuff->src_width, n);
    swaps(&stuff->src_height, n);
    swapl(&stuff->dst_x, n);
    swapl(&stuff->dst_y, n);
    swaps(&stuff->deviceid, n);
    return (ProcXIWarpPointer(client));
}

int
ProcXIWarpPointer(ClientPtr client)
{
    int rc;
    int x, y;
    WindowPtr dest = NULL;
    DeviceIntPtr pDev;
    SpritePtr pSprite;
    ScreenPtr newScreen;
    int src_x, src_y;
    int dst_x, dst_y;

    REQUEST(xXIWarpPointerReq);
    REQUEST_SIZE_MATCH(xXIWarpPointerReq);

    /* FIXME: panoramix stuff is missing, look at ProcWarpPointer */

    rc = dixLookupDevice(&pDev, stuff->deviceid, client, DixWriteAccess);

    if (rc != Success)
    {
        client->errorValue = stuff->deviceid;
        return rc;
    }

    if ((!IsMaster(pDev) && !IsFloating(pDev)) ||
        (IsMaster(pDev) && !IsPointerDevice(pDev)))
    {
        client->errorValue = stuff->deviceid;
        return BadDevice;
    }

    if (stuff->dst_win != None)
    {
        rc = dixLookupWindow(&dest, stuff->dst_win, client, DixGetAttrAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->dst_win;
            return rc;
        }
    }

    pSprite = pDev->spriteInfo->sprite;
    x = pSprite->hotPhys.x;
    y = pSprite->hotPhys.y;

    src_x = stuff->src_x / (double)(1 << 16);
    src_y = stuff->src_y / (double)(1 << 16);
    dst_x = stuff->dst_x / (double)(1 << 16);
    dst_y = stuff->dst_y / (double)(1 << 16);

    if (stuff->src_win != None)
    {
        int winX, winY;
        WindowPtr src;

        rc = dixLookupWindow(&src, stuff->src_win, client, DixGetAttrAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->src_win;
            return rc;
        }

        winX = src->drawable.x;
        winY = src->drawable.y;
        if (src->drawable.pScreen != pSprite->hotPhys.pScreen ||
                x < winX + src_x ||
                y < winY + src_y ||
                (stuff->src_width != 0 &&
                 winX + src_x + (int)stuff->src_width < 0) ||
                (stuff->src_height != 0 &&
                 winY + src_y + (int)stuff->src_height < y) ||
                !PointInWindowIsVisible(src, x, y))
            return Success;
    }

    if (dest)
    {
        x = dest->drawable.x;
        y = dest->drawable.y;
        newScreen = dest->drawable.pScreen;
    } else
        newScreen = pSprite->hotPhys.pScreen;

    x += dst_x;
    y += dst_y;

    if (x < 0)
        x = 0;
    else if (x > newScreen->width)
        x = newScreen->width - 1;

    if (y < 0)
        y = 0;
    else if (y > newScreen->height)
        y = newScreen->height - 1;

    if (newScreen == pSprite->hotPhys.pScreen)
    {
        if (x < pSprite->physLimits.x1)
            x = pSprite->physLimits.x1;
        else if (x >= pSprite->physLimits.x2)
            x = pSprite->physLimits.x2 - 1;

        if (y < pSprite->physLimits.y1)
            y = pSprite->physLimits.y1;
        else if (y >= pSprite->physLimits.y2)
            y = pSprite->physLimits.y2 - 1;

        if (pSprite->hotShape)
            ConfineToShape(pDev, pSprite->hotShape, &x, &y);
        (*newScreen->SetCursorPosition)(pDev, newScreen, x, y, TRUE);
    } else if (!PointerConfinedToScreen(pDev))
    {
        NewCurrentScreen(pDev, newScreen, x, y);
    }

    /* if we don't update the device, we get a jump next time it moves */
    pDev->last.valuators[0] = x;
    pDev->last.valuators[1] = y;
    pDev->last.remainder[0] = 0;
    pDev->last.remainder[1] = 0;
    miPointerUpdateSprite(pDev);

    /* FIXME: XWarpPointer is supposed to generate an event. It doesn't do it
       here though. */
    return Success;
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef WARPDEVP_H
#define WARPDEVP_H 1

int SProcXIWarpPointer(ClientPtr /* client */);
int ProcXIWarpPointer(ClientPtr	/* client */);

#endif /* WARPDEVP_H */
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include <X11/extensions/XI.h>

/*#define FALLING_TONE	1*/
/*#define RISING_TONE	1*/
#define FALLING_TONE	10
#define RISING_TONE	10
#define	SHORT_TONE	50
#define	SHORT_DELAY	60
#define	LONG_TONE	75
#define	VERY_LONG_TONE	100
#define	LONG_DELAY	85
#define CLICK_DURATION	1

#define	DEEP_PITCH	250
#define	LOW_PITCH	500
#define	MID_PITCH	1000
#define	HIGH_PITCH	2000
#define CLICK_PITCH	1500

static	unsigned long	atomGeneration= 0;
static	Atom	featureOn;
static	Atom	featureOff;
static	Atom	featureChange;
static	Atom	ledOn;
static	Atom	ledOff;
static	Atom	ledChange;
static	Atom	slowWarn;
static	Atom	slowPress;
static	Atom	slowReject;
static	Atom	slowAccept;
static	Atom	slowRelease;
static	Atom	stickyLatch;
static	Atom	stickyLock;
static	Atom	stickyUnlock;
static	Atom	bounceReject;
static  char 	doesPitch = 1;

#define	FEATURE_ON	"AX_FeatureOn"
#define	FEATURE_OFF	"AX_FeatureOff"
#define	FEATURE_CHANGE	"AX_FeatureChange"
#define	LED_ON		"AX_IndicatorOn"
#define	LED_OFF		"AX_IndicatorOff"
#define	LED_CHANGE	"AX_IndicatorChange"
#define	SLOW_WARN	"AX_SlowKeysWarning"
#define	SLOW_PRESS	"AX_SlowKeyPress"
#define	SLOW_REJECT	"AX_SlowKeyReject"
#define	SLOW_ACCEPT	"AX_SlowKeyAccept"
#define	SLOW_RELEASE	"AX_SlowKeyRelease"
#define	STICKY_LATCH	"AX_StickyLatch"
#define	STICKY_LOCK	"AX_StickyLock"
#define	STICKY_UNLOCK	"AX_StickyUnlock"
#define	BOUNCE_REJECT	"AX_BounceKeyReject"

#define	MAKE_ATOM(a)	MakeAtom(a,sizeof(a)-1,TRUE)

static void
_XkbDDXBeepInitAtoms(void)
{
    featureOn= 		MAKE_ATOM(FEATURE_ON);
    featureOff= 	MAKE_ATOM(FEATURE_OFF);
    featureChange= 	MAKE_ATOM(FEATURE_CHANGE);
    ledOn= 		MAKE_ATOM(LED_ON);
    ledOff= 		MAKE_ATOM(LED_OFF);
    ledChange= 		MAKE_ATOM(LED_CHANGE);
    slowWarn= 		MAKE_ATOM(SLOW_WARN);
    slowPress= 		MAKE_ATOM(SLOW_PRESS);
    slowReject= 	MAKE_ATOM(SLOW_REJECT);
    slowAccept= 	MAKE_ATOM(SLOW_ACCEPT);
    slowRelease= 	MAKE_ATOM(SLOW_RELEASE);
    stickyLatch= 	MAKE_ATOM(STICKY_LATCH);
    stickyLock=		MAKE_ATOM(STICKY_LOCK);
    stickyUnlock= 	MAKE_ATOM(STICKY_UNLOCK);
    bounceReject= 	MAKE_ATOM(BOUNCE_REJECT);
    return;
}

static CARD32
_XkbDDXBeepExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
DeviceIntPtr	dev= (DeviceIntPtr)arg;
KbdFeedbackPtr	feed;
KeybdCtrl *	ctrl;
XkbSrvInfoPtr	xkbInfo;
CARD32		next;
int		pitch,duration;
int		oldPitch,oldDuration;
Atom		name;

    if ((dev==NULL)||(dev->key==NULL)||(dev->key->xkbInfo==NULL)||
	(dev->kbdfeed==NULL))
	return 0;
    if (atomGeneration!=serverGeneration) {
	_XkbDDXBeepInitAtoms();
	atomGeneration= serverGeneration;
    }

    feed= dev->kbdfeed;
    ctrl= &feed->ctrl;
    xkbInfo= dev->key->xkbInfo;
    next= 0;
    pitch= oldPitch= ctrl->bell_pitch;
    duration= oldDuration= ctrl->bell_duration;
    name= None;
    switch (xkbInfo->beepType) {
	default:
	    ErrorF("[xkb] Unknown beep type %d\n",xkbInfo->beepType);
	case _BEEP_NONE:
	    duration= 0;
	    break;

	/* When an LED is turned on, we want a high-pitched beep.
	 * When the LED it turned off, we want a low-pitched beep.
	 * If we cannot do pitch, we want a single beep for on and two
	 * beeps for off.
         */
	case _BEEP_LED_ON:
	    if (name==None)	name= ledOn;
	    duration= SHORT_TONE;
	    pitch= HIGH_PITCH;
	    break;
	case _BEEP_LED_OFF:
	    if (name==None)	name= ledOff;
	    duration= SHORT_TONE;
	    pitch= LOW_PITCH;
	    if (!doesPitch && xkbInfo->beepCount<1)
		next = SHORT_DELAY;	    
	    break;

	/* When a Feature is turned on, we want an up-siren.
	 * When a Feature is turned off, we want a down-siren.
	 * If we cannot do pitch, we want a single beep for on and two
	 * beeps for off.
         */
	case _BEEP_FEATURE_ON:
	    if (name==None)	name= featureOn;
	    if (xkbInfo->beepCount<1) {
		pitch= LOW_PITCH;
		duration= VERY_LONG_TONE;
		if (doesPitch)
		    next= SHORT_DELAY;
	    }
	    else {
		pitch= MID_PITCH;
		duration= SHORT_TONE;
	    }
	    break;

	case _BEEP_FEATURE_OFF:
	    if (name==None)	name= featureOff;
	    if (xkbInfo->beepCount<1) {
		pitch= MID_PITCH;
		if (doesPitch)
		     duration= VERY_LONG_TONE;
		else duration= SHORT_TONE;
		next= SHORT_DELAY;
	    }
	    else {
		pitch= LOW_PITCH;
		duration= SHORT_TONE;
	    }
	    break;

	/* Two high beeps indicate an LED or Feature changed
	 * state, but that another LED or Feature is also on.
	 * [[[WDW - This is not in AccessDOS ]]]
	 */
	case _BEEP_LED_CHANGE:
            if (name==None)	name= ledChange;
	case _BEEP_FEATURE_CHANGE:
	    if (name==None)	name= featureChange;
	    duration= SHORT_TONE;
	    pitch= HIGH_PITCH;
	    if (xkbInfo->beepCount<1) {
		next= SHORT_DELAY;
	    }
            break;

	/* Three high-pitched beeps are the warning that SlowKeys
	 * is going to be turned on or off.
	 */	  
	case _BEEP_SLOW_WARN:
	    if (name==None)	name= slowWarn;
	    duration= SHORT_TONE;
	    pitch= HIGH_PITCH;
	    if (xkbInfo->beepCount<2)
		next= SHORT_DELAY;
	    break;

	/* Click on SlowKeys press and accept.
	 * Deep pitch when a SlowKey or BounceKey is rejected.
	 * [[[WDW - Rejects are not in AccessDOS ]]]
	 * If we cannot do pitch, we want single beeps.
	 */	  
        case _BEEP_SLOW_PRESS:
	    if (name==None)	name= slowPress;
	case _BEEP_SLOW_ACCEPT:
	    if (name==None)	name= slowAccept;
	case _BEEP_SLOW_RELEASE:
	    if (name==None)	name= slowRelease;
	    duration= CLICK_DURATION;
	    pitch= CLICK_PITCH;
	    break;
	case _BEEP_BOUNCE_REJECT:
	    if (name==None)	name= bounceReject;
	case _BEEP_SLOW_REJECT:
	    if (name==None)	name= slowReject;
	    duration= SHORT_TONE;
	    pitch= DEEP_PITCH;
	    break;

	/* Low followed by high pitch when a StickyKey is latched.
	 * High pitch when a StickyKey is locked.
	 * Low pitch when unlocked.
         * If we cannot do pitch, two beeps for latch, nothing for
	 * lock, and two for unlock.
	 */	  
	case _BEEP_STICKY_LATCH:
	    if (name==None)	name= stickyLatch;
	    duration= SHORT_TONE;
	    if (xkbInfo->beepCount<1) {
		next= SHORT_DELAY;
		pitch= LOW_PITCH;
	    }
	    else pitch= HIGH_PITCH;
	    break;
	case _BEEP_STICKY_LOCK:
	    if (name==None)	name= stickyLock;
	    if (doesPitch) {
		duration= SHORT_TONE;
		pitch= HIGH_PITCH;
            }
	    break;
	case _BEEP_STICKY_UNLOCK:
	    if (name==None)	name= stickyUnlock;
	    duration= SHORT_TONE;
	    pitch= LOW_PITCH;
	    if (!doesPitch && xkbInfo->beepCount<1)
		next = SHORT_DELAY;	    
	    break;
    }
    if (timer == NULL && duration>0) {
	CARD32		starttime = GetTimeInMillis();
	CARD32		elapsedtime;

	ctrl->bell_duration= duration;
	ctrl->bell_pitch= pitch;
	if (xkbInfo->beepCount==0) {
	     XkbHandleBell(0,0,dev,ctrl->bell,(pointer)ctrl,KbdFeedbackClass,name,None,
									NULL);
	}
	else if (xkbInfo->desc->ctrls->enabled_ctrls&XkbAudibleBellMask) {
	    (*dev->kbdfeed->BellProc)(ctrl->bell,dev,(pointer)ctrl,KbdFeedbackClass);
	}
	ctrl->bell_duration= oldDuration;
	ctrl->bell_pitch= oldPitch;
	xkbInfo->beepCount++;

	/* Some DDX schedule the beep and return immediately, others don't
	   return until the beep is completed.  We measure the time and if
	   it's less than the beep duration, make sure not to schedule the
	   next beep until after the current one finishes. */

	elapsedtime = GetTimeInMillis();
	if (elapsedtime > starttime) { /* watch out for millisecond counter
					  overflow! */
	    elapsedtime -= starttime;
	} else {
	    elapsedtime = 0;
	}
	if (elapsedtime < duration) {
	    next += duration - elapsedtime;
	}

    }
    return next;
}

int
XkbDDXAccessXBeep(DeviceIntPtr dev,unsigned what,unsigned which)
{
XkbSrvInfoRec	*xkbInfo= dev->key->xkbInfo;
CARD32		 next;

    xkbInfo->beepType= what;
    xkbInfo->beepCount= 0;
    next= _XkbDDXBeepExpire(NULL,0,(pointer)dev);
    if (next>0) {
	xkbInfo->beepTimer= TimerSet(xkbInfo->beepTimer,
					0, next,
					_XkbDDXBeepExpire, (pointer)dev);
    }
    return 1;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include <X11/extensions/XI.h>

void
XkbDDXKeybdCtrlProc(DeviceIntPtr dev,KeybdCtrl *ctrl)
{
int realRepeat;

    realRepeat= ctrl->autoRepeat;
    if ((dev->kbdfeed)&&(XkbDDXUsesSoftRepeat(dev)))
	ctrl->autoRepeat= 0;
    if (dev->key && dev->key->xkbInfo && dev->key->xkbInfo->kbdProc)
	(*dev->key->xkbInfo->kbdProc)(dev,ctrl);
    ctrl->autoRepeat= realRepeat;
    return;
}


int
XkbDDXUsesSoftRepeat(DeviceIntPtr pXDev)
{
    return 1;
}

void
XkbDDXChangeControls(DeviceIntPtr dev,XkbControlsPtr old,XkbControlsPtr new)
{
unsigned	changed, i;
unsigned 	char *rep_old, *rep_new, *rep_fb;

    changed= new->enabled_ctrls^old->enabled_ctrls;
    for (rep_old = old->per_key_repeat,
         rep_new = new->per_key_repeat,
	 rep_fb  = dev->kbdfeed->ctrl.autoRepeats,
         i = 0; i < XkbPerKeyBitArraySize; i++) {
        if (rep_old[i] != rep_new[i]) {
            rep_fb[i] = rep_new[i];
            changed &= XkbPerKeyRepeatMask;
        }
    }

    if (changed&XkbPerKeyRepeatMask) {
	if (dev->kbdfeed->CtrlProc)
	    (*dev->kbdfeed->CtrlProc)(dev,&dev->kbdfeed->ctrl);
    }
    return;
}

/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>

int
XkbDDXTerminateServer(DeviceIntPtr dev,KeyCode key,XkbAction *act)
{
    if (dev != inputInfo.keyboard)
        GiveUp(1);

    return 0;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include <X11/extensions/XI.h>

static void
XkbDDXUpdateIndicators(DeviceIntPtr dev,CARD32 new)
{
    dev->kbdfeed->ctrl.leds= new;
    (*dev->kbdfeed->CtrlProc)(dev,&dev->kbdfeed->ctrl);
    return;
}

void
XkbDDXUpdateDeviceIndicators(	DeviceIntPtr		dev,
				XkbSrvLedInfoPtr 	sli,
				CARD32 			new)
{
    if (sli->fb.kf==dev->kbdfeed)
	XkbDDXUpdateIndicators(dev,new);
    else if (sli->class==KbdFeedbackClass) {
	KbdFeedbackPtr	kf;
	kf= sli->fb.kf;
	if (kf && kf->CtrlProc) {
	    (*kf->CtrlProc)(dev,&kf->ctrl);
	}
    }
    else if (sli->class==LedFeedbackClass) {
	LedFeedbackPtr	lf;
	lf= sli->fb.lf;
	if (lf && lf->CtrlProc) {
	    (*lf->CtrlProc)(dev,&lf->ctrl);
	}
    }
    return;
}
/************************************************************
Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XKM.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include <X11/extensions/XI.h>

#ifdef WIN32
/* from ddxLoad.c */
extern const char* Win32TempDir();
extern int Win32System(const char *cmdline);
#undef System
#define System Win32System

#define W32_tmparg " '%s'"
#define W32_tmpfile ,tmpname
#define W32_tmplen strlen(tmpname)+3
#else
#define W32_tmparg
#define W32_tmpfile 
#define W32_tmplen 0
#endif 

/***====================================================================***/

static char *componentDirs[_XkbListNumComponents] = {
	"keycodes", "types", "compat", "symbols", "geometry"
};

/***====================================================================***/

static Status
_AddListComponent(	XkbSrvListInfoPtr	list,
			int			what,
			unsigned		flags,
			char *			str,
			ClientPtr		client)
{
int		slen,wlen;
unsigned char *	wire8;
unsigned short *wire16;
char *		tmp;

    if (list->nTotal>=list->maxRtrn) {
	list->nTotal++;
	return Success;
    }
    tmp= strchr(str,')');
    if ((tmp==NULL)&&((tmp=strchr(str,'('))==NULL)) {
	slen= strlen(str);
	while ((slen>0) && isspace(str[slen-1])) {
	    slen--;
	}
    }
    else {
	slen= (tmp-str+1);
    }
    wlen= (((slen+1)/2)*2)+4;	/* four bytes for flags and length, pad to */
				/* 2-byte boundary */
    if ((list->szPool-list->nPool)<wlen) {
	if (wlen>1024)	list->szPool+= XkbPaddedSize(wlen*2);
	else		list->szPool+= 1024;
	list->pool= realloc(list->pool, list->szPool * sizeof(char));
	if (!list->pool)
	    return BadAlloc;
    }
    wire16= (unsigned short *)&list->pool[list->nPool];
    wire8= (unsigned char *)&wire16[2];
    wire16[0]= flags;
    wire16[1]= slen;
    memcpy(wire8,str,slen);
    if (client->swapped) {
	register int n;
	swaps(&wire16[0],n);
	swaps(&wire16[1],n);
    }
    list->nPool+= wlen;
    list->nFound[what]++;
    list->nTotal++;
    return Success;
}

/***====================================================================***/
static Status
XkbDDXListComponent(	DeviceIntPtr 		dev,
			int			what,
			XkbSrvListInfoPtr	list,
			ClientPtr		client)
{
char 	*file,*map,*tmp,*buf=NULL;
FILE 	*in;
Status	status;
int	rval;
Bool	haveDir;
#ifdef WIN32
char	tmpname[PATH_MAX];
#endif

    if ((list->pattern[what]==NULL)||(list->pattern[what][0]=='\0'))
	return Success;
    file= list->pattern[what];
    map= strrchr(file,'(');
    if (map!=NULL) {
	char *tmp;
	map++;
	tmp= strrchr(map,')');
	if ((tmp==NULL)||(tmp[1]!='\0')) {
	    /* illegal pattern.  No error, but no match */
	    return Success;
	}
    }

    in= NULL;
    haveDir= TRUE;
#ifdef WIN32
    strcpy(tmpname, Win32TempDir());
    strcat(tmpname, "\\xkb_XXXXXX");
    (void) mktemp(tmpname);
#endif
    if (XkbBaseDirectory!=NULL) {
	if ((list->pattern[what][0]=='*')&&(list->pattern[what][1]=='\0')) {
	    if (asprintf(&buf, "%s/%s.dir", XkbBaseDirectory,
			 componentDirs[what]) == -1)
		buf = NULL;
	    else
		in = fopen(buf,"r");
	}
	if (!in) {
	    haveDir= FALSE;
	    free(buf);
	    if (asprintf
		(&buf,
		 "'%s/xkbcomp' '-R%s/%s' -w %ld -l -vlfhpR '%s'" W32_tmparg,
		 XkbBinDirectory, XkbBaseDirectory, componentDirs[what],
		 (long) ((xkbDebugFlags < 2) ? 1 :
			 ((xkbDebugFlags > 10) ? 10 : xkbDebugFlags)),
		 file W32_tmpfile
		    ) == -1)
		buf = NULL;
	}
    }
    else {
	if ((list->pattern[what][0]=='*')&&(list->pattern[what][1]=='\0')) {
	    if (asprintf(&buf, "%s.dir", componentDirs[what]) == -1)
		buf = NULL;
	    else
		in = fopen(buf,"r");
	}
	if (!in) {
	    haveDir= FALSE;
	    free(buf);
	    if (asprintf
		(&buf,
		 "xkbcomp -R%s -w %ld -l -vlfhpR '%s'" W32_tmparg,
		 componentDirs[what],
		 (long)	((xkbDebugFlags < 2) ? 1 :
			 ((xkbDebugFlags > 10) ? 10 : xkbDebugFlags)),
		 file W32_tmpfile
		    ) == -1)
		buf = NULL;
	}
    }
    status= Success;
    if (!haveDir)
    {  
#ifndef WIN32
	in= Popen(buf,"r");
#else
        if (xkbDebugFlags)
            DebugF("[xkb] xkbList executes: %s\n",buf);
	if (System(buf) < 0)
	    ErrorF("[xkb] Could not invoke keymap compiler\n");
	else
	    in= fopen(tmpname, "r");
#endif
    }
    if (!in)
    {
	free(buf);
#ifdef WIN32
	unlink(tmpname);
#endif
	return BadImplementation;
    }
    list->nFound[what]= 0;
    free(buf);
    buf = malloc(PATH_MAX * sizeof(char));
    if (!buf) {
        fclose(in);
        return BadAlloc;
    }
    while ((status==Success)&&((tmp=fgets(buf,PATH_MAX,in))!=NULL)) {
	unsigned flags;
	register unsigned int i;
	if (*tmp=='#') /* comment, skip it */
	    continue;
	if (!strncmp(tmp, "Warning:", 8) || !strncmp(tmp, "        ", 8))
	    /* skip warnings too */
	    continue;
	flags= 0;
	/* each line in the listing is supposed to start with two */
	/* groups of eight characters, which specify the general  */
	/* flags and the flags that are specific to the component */
	/* if they're missing, fail with BadImplementation	  */
	for (i=0;(i<8)&&(status==Success);i++) { /* read the general flags */
	   if (isalpha(*tmp))	flags|= (1L<<i);
	   else if (*tmp!='-')	status= BadImplementation;
	   tmp++;
	}
	if (status != Success)  break;
	if (!isspace(*tmp)) {
	     status= BadImplementation;
	     break;
	}
	else tmp++;
	for (i=0;(i<8)&&(status==Success);i++) { /* read the component flags */
	   if (isalpha(*tmp))	flags|= (1L<<(i+8));
	   else if (*tmp!='-')	status= BadImplementation;
	   tmp++;
	}
	if (status != Success)  break;
	if (isspace(*tmp)) {
	    while (isspace(*tmp)) {
		tmp++;
	    }
	}
	else {
	    status= BadImplementation;
	    break;
	}
	status= _AddListComponent(list,what,flags,tmp,client);
    }
#ifndef WIN32
    if (haveDir)
	fclose(in);
    else if ((rval=Pclose(in))!=0) {
	if (xkbDebugFlags)
	    ErrorF("[xkb] xkbcomp returned exit code %d\n",rval);
    }
#else
    fclose(in);
    unlink(tmpname);
#endif
    free(buf);
    return status;
}

/***====================================================================***/

/* ARGSUSED */
Status
XkbDDXList(DeviceIntPtr	dev,XkbSrvListInfoPtr list,ClientPtr client)
{
Status	status;

    status= XkbDDXListComponent(dev,_XkbListKeycodes,list,client);
    if (status==Success)
	status= XkbDDXListComponent(dev,_XkbListTypes,list,client);
    if (status==Success)
	status= XkbDDXListComponent(dev,_XkbListCompat,list,client);
    if (status==Success)
	status= XkbDDXListComponent(dev,_XkbListSymbols,list,client);
    if (status==Success)
	status= XkbDDXListComponent(dev,_XkbListGeometry,list,client);
    return status;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <ctype.h>
#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XKM.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include <X11/extensions/XI.h>
#include "xkb.h"

	/*
	 * If XKM_OUTPUT_DIR specifies a path without a leading slash, it is
	 * relative to the top-level XKB configuration directory.
	 * Making the server write to a subdirectory of that directory
	 * requires some work in the general case (install procedure
	 * has to create links to /var or somesuch on many machines),
	 * so we just compile into /usr/tmp for now.
	 */
#ifndef XKM_OUTPUT_DIR
#define	XKM_OUTPUT_DIR	"compiled/"
#endif

#define	PRE_ERROR_MSG "\"The XKEYBOARD keymap compiler (xkbcomp) reports:\""
#define	ERROR_PREFIX	"\"> \""
#define	POST_ERROR_MSG1 "\"Errors from xkbcomp are not fatal to the X server\""
#define	POST_ERROR_MSG2 "\"End of messages from xkbcomp\""

#if defined(WIN32)
#define PATHSEPARATOR "\\"
#else
#define PATHSEPARATOR "/"
#endif

#ifdef WIN32

#include <X11/Xwindows.h>
const char* 
Win32TempDir()
{
    static char buffer[PATH_MAX];
    if (GetTempPath(sizeof(buffer), buffer))
    {
        int len;
        buffer[sizeof(buffer)-1] = 0;
        len = strlen(buffer);
        if (len > 0)
            if (buffer[len-1] == '\\')
                buffer[len-1] = 0;
        return buffer;
    }
    if (getenv("TEMP") != NULL)
        return getenv("TEMP");
    else if (getenv("TMP") != NULL)
        return getenv("TEMP");
    else
        return "/tmp";
}

int 
Win32System(const char *cmdline)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwExitCode;
    char *cmd = strdup(cmdline);

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) 
    {
	LPVOID buffer;
	if (!FormatMessage( 
		    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		    FORMAT_MESSAGE_FROM_SYSTEM | 
		    FORMAT_MESSAGE_IGNORE_INSERTS,
		    NULL,
		    GetLastError(),
		    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		    (LPTSTR) &buffer,
		    0,
		    NULL ))
	{
	    ErrorF("[xkb] Starting '%s' failed!\n", cmdline); 
	}
	else
	{
	    ErrorF("[xkb] Starting '%s' failed: %s", cmdline, (char *)buffer); 
	    LocalFree(buffer);
	}

	free(cmd);
	return -1;
    }
    /* Wait until child process exits. */
    WaitForSingleObject( pi.hProcess, INFINITE );

    GetExitCodeProcess( pi.hProcess, &dwExitCode);
    
    /* Close process and thread handles. */
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
    free(cmd);

    return dwExitCode;
}
#undef System
#define System(x) Win32System(x)
#endif

static void
OutputDirectory(
    char* outdir,
    size_t size)
{
#ifndef WIN32
    /* Can we write an xkm and then open it too? */
    if (access(XKM_OUTPUT_DIR, W_OK | X_OK) == 0 && (strlen(XKM_OUTPUT_DIR) < size))
    {
	(void) strcpy (outdir, XKM_OUTPUT_DIR);
    } else
#else
    if (strlen(Win32TempDir()) + 1 < size)
    {
	(void) strcpy(outdir, Win32TempDir());
	(void) strcat(outdir, "\\");
    } else 
#endif
    if (strlen("/tmp/") < size)
    {
	(void) strcpy (outdir, "/tmp/");
    }
}

static Bool
XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
				XkbComponentNamesPtr	names,
				unsigned		want,
				unsigned		need,
				char *			nameRtrn,
				int			nameRtrnLen)
{
    FILE *	out;
    char	*buf = NULL, keymap[PATH_MAX], xkm_output_dir[PATH_MAX];

    const char	*emptystring = "";
    char *xkbbasedirflag = NULL;
    const char	*xkbbindir = emptystring;
    const char	*xkbbindirsep = emptystring;

#ifdef WIN32
    /* WIN32 has no popen. The input must be stored in a file which is
       used as input for xkbcomp. xkbcomp does not read from stdin. */
    char tmpname[PATH_MAX];
    const char *xkmfile = tmpname;
#else
    const char *xkmfile = "-";
#endif

    snprintf(keymap, sizeof(keymap), "server-%s", display);

    OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));

#ifdef WIN32
    strcpy(tmpname, Win32TempDir());
    strcat(tmpname, "\\xkb_XXXXXX");
    (void) mktemp(tmpname);
#endif

    if (XkbBaseDirectory != NULL) {
	if (asprintf(&xkbbasedirflag, "\"-R%s\"", XkbBaseDirectory) == -1)
	    xkbbasedirflag = NULL;
    }

    if (XkbBinDirectory != NULL) {
	int ld = strlen(XkbBinDirectory);
	int lps = strlen(PATHSEPARATOR);

	xkbbindir = XkbBinDirectory;

	if ((ld >= lps) &&
	    (strcmp(xkbbindir + ld - lps, PATHSEPARATOR) != 0)) {
	    xkbbindirsep = PATHSEPARATOR;
	}
    }

    if (asprintf(&buf,
		 "\"%s%sxkbcomp\" -w %d %s -xkm \"%s\" "
		  "-em1 %s -emp %s -eml %s \"%s%s.xkm\"",
		 xkbbindir, xkbbindirsep,
		 ((xkbDebugFlags < 2) ? 1 :
		  ((xkbDebugFlags > 10) ? 10 : (int) xkbDebugFlags)),
		 xkbbasedirflag ? xkbbasedirflag : "", xkmfile,
		 PRE_ERROR_MSG, ERROR_PREFIX, POST_ERROR_MSG1,
		 xkm_output_dir, keymap) == -1)
	buf = NULL;
	DebugF("[xkb] xkb buf: %s\n",buf);
    free(xkbbasedirflag);

    if (!buf) {
        LogMessage(X_ERROR, "XKB: Could not invoke xkbcomp: not enough memory\n");
        return FALSE;
    }
    
#ifndef WIN32
    out= Popen(buf,"w");
#else
    out= fopen(tmpname, "w");
#endif
    
    if (out!=NULL) {
#ifdef DEBUG
    if (xkbDebugFlags) {
       ErrorF("[xkb] XkbDDXCompileKeymapByNames compiling keymap:\n");
       XkbWriteXKBKeymapForNames(stderr,names,xkb,want,need);
    }
#endif
	XkbWriteXKBKeymapForNames(out,names,xkb,want,need);
#ifndef WIN32
	if (Pclose(out)==0)
#else
	if (fclose(out)==0 && System(buf) >= 0)
#endif
	{
            if (xkbDebugFlags)
                DebugF("[xkb] xkb executes: %s\n",buf);
	    if (nameRtrn) {
		strncpy(nameRtrn,keymap,nameRtrnLen);
		nameRtrn[nameRtrnLen-1]= '\0';
	    }
            free(buf);
	    return TRUE;
	}
	else
	    LogMessage(X_ERROR, "Error compiling keymap (%s)\n", keymap);
#ifdef WIN32
        /* remove the temporary file */
        unlink(tmpname);
#endif
    }
    else {
#ifndef WIN32
	LogMessage(X_ERROR, "XKB: Could not invoke xkbcomp\n");
#else
	LogMessage(X_ERROR, "Could not open file %s\n", tmpname);
#endif
    }
    if (nameRtrn)
	nameRtrn[0]= '\0';
    free(buf);
    return FALSE;
}

static FILE *
XkbDDXOpenConfigFile(char *mapName,char *fileNameRtrn,int fileNameRtrnLen)
{
char	buf[PATH_MAX],xkm_output_dir[PATH_MAX];
FILE *	file;

    buf[0]= '\0';
    if (mapName!=NULL) {
	OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));
	if ((XkbBaseDirectory!=NULL)&&(xkm_output_dir[0]!='/')
#ifdef WIN32
                &&(!isalpha(xkm_output_dir[0]) || xkm_output_dir[1]!=':')
#endif
                ) {
            if (snprintf(buf, PATH_MAX, "%s/%s%s.xkm", XkbBaseDirectory,
                         xkm_output_dir, mapName) >= PATH_MAX)
                buf[0] = '\0';
	}
	else
	{
            if (snprintf(buf, PATH_MAX, "%s%s.xkm", xkm_output_dir, mapName)
                >= PATH_MAX)
                buf[0] = '\0';
	}
	if (buf[0] != '\0')
	    file= fopen(buf,"rb");
	else file= NULL;
    }
    else file= NULL;
    if ((fileNameRtrn!=NULL)&&(fileNameRtrnLen>0)) {
	strncpy(fileNameRtrn,buf,fileNameRtrnLen);
	buf[fileNameRtrnLen-1]= '\0';
    }
    return file;
}

unsigned
XkbDDXLoadKeymapByNames(	DeviceIntPtr		keybd,
				XkbComponentNamesPtr	names,
				unsigned		want,
				unsigned		need,
				XkbDescPtr *		xkbRtrn,
				char *			nameRtrn,
				int 			nameRtrnLen)
{
XkbDescPtr      xkb;
FILE	*	file;
char		fileName[PATH_MAX];
unsigned	missing;

    *xkbRtrn = NULL;
    if ((keybd==NULL)||(keybd->key==NULL)||(keybd->key->xkbInfo==NULL))
	 xkb= NULL;
    else xkb= keybd->key->xkbInfo->desc;
    if ((names->keycodes==NULL)&&(names->types==NULL)&&
	(names->compat==NULL)&&(names->symbols==NULL)&&
	(names->geometry==NULL)) {
        LogMessage(X_ERROR, "XKB: No components provided for device %s\n",
                   keybd->name ? keybd->name : "(unnamed keyboard)");
        return 0;
    }
    else if (!XkbDDXCompileKeymapByNames(xkb,names,want,need,
                                         nameRtrn,nameRtrnLen)){
	LogMessage(X_ERROR, "XKB: Couldn't compile keymap\n");
	return 0;
    }
    file= XkbDDXOpenConfigFile(nameRtrn,fileName,PATH_MAX);
    if (file==NULL) {
	LogMessage(X_ERROR, "Couldn't open compiled keymap file %s\n",fileName);
	return 0;
    }
    missing= XkmReadFile(file,need,want,xkbRtrn);
    if (*xkbRtrn==NULL) {
	LogMessage(X_ERROR, "Error loading keymap %s\n",fileName);
	fclose(file);
	(void) unlink (fileName);
	return 0;
    }
    else {
	DebugF("Loaded XKB keymap %s, defined=0x%x\n",fileName,(*xkbRtrn)->defined);
    }
    fclose(file);
    (void) unlink (fileName);
    return (need|want)&(~missing);
}

Bool
XkbDDXNamesFromRules(	DeviceIntPtr		keybd,
			char *			rules_name,
			XkbRF_VarDefsPtr	defs,
			XkbComponentNamesPtr	names)
{
char 		buf[PATH_MAX];
FILE *		file;
Bool		complete;
XkbRF_RulesPtr	rules;

    if (!rules_name)
	return FALSE;

    if (snprintf(buf, PATH_MAX, "%s/rules/%s", XkbBaseDirectory, rules_name)
        >= PATH_MAX) {
        LogMessage(X_ERROR, "XKB: Rules name is too long\n");
        return FALSE;
    }

    file = fopen(buf, "r");
    if (!file) {
        LogMessage(X_ERROR, "XKB: Couldn't open rules file %s\n", buf);
	return FALSE;
    }

    rules = XkbRF_Create();
    if (!rules) {
        LogMessage(X_ERROR, "XKB: Couldn't create rules struct\n");
	fclose(file);
	return FALSE;
    }

    if (!XkbRF_LoadRules(file, rules)) {
        LogMessage(X_ERROR, "XKB: Couldn't parse rules file %s\n", rules_name);
	fclose(file);
	XkbRF_Free(rules,TRUE);
	return FALSE;
    }

    memset(names, 0, sizeof(*names));
    complete = XkbRF_GetComponents(rules,defs,names);
    fclose(file);
    XkbRF_Free(rules, TRUE);

    if (!complete)
        LogMessage(X_ERROR, "XKB: Rules returned no components\n");

    return complete;
}

static Bool
XkbRMLVOtoKcCGST(DeviceIntPtr dev, XkbRMLVOSet *rmlvo, XkbComponentNamesPtr kccgst)
{
    XkbRF_VarDefsRec mlvo;

    mlvo.model = rmlvo->model;
    mlvo.layout = rmlvo->layout;
    mlvo.variant = rmlvo->variant;
    mlvo.options = rmlvo->options;

    return XkbDDXNamesFromRules(dev, rmlvo->rules, &mlvo, kccgst);
}

/**
 * Compile the given RMLVO keymap and return it. Returns the XkbDescPtr on
 * success or NULL on failure. If the components compiled are not a superset
 * or equal to need, the compiliation is treated as failure.
 */
static XkbDescPtr
XkbCompileKeymapForDevice(DeviceIntPtr dev, XkbRMLVOSet *rmlvo, int need)
{
    XkbDescPtr xkb = NULL;
    unsigned int provided;
    XkbComponentNamesRec kccgst = {0};
    char name[PATH_MAX];

    if (XkbRMLVOtoKcCGST(dev, rmlvo, &kccgst)) {
        provided = XkbDDXLoadKeymapByNames(dev, &kccgst, XkmAllIndicesMask, need,
                                           &xkb, name, PATH_MAX);
        if ((need & provided) != need) {
            if (xkb) {
                XkbFreeKeyboard(xkb, 0, TRUE);
                xkb = NULL;
            }
        }
    }

    XkbFreeComponentNames(&kccgst, FALSE);
    return xkb;
}

XkbDescPtr
XkbCompileKeymap(DeviceIntPtr dev, XkbRMLVOSet *rmlvo)
{
    XkbDescPtr xkb;
    unsigned int need;

    if (!dev || !rmlvo) {
        LogMessage(X_ERROR, "XKB: No device or RMLVO specified\n");
        return NULL;
    }

    /* These are the components we really really need */
    need = XkmSymbolsMask | XkmCompatMapMask | XkmTypesMask |
           XkmKeyNamesMask | XkmVirtualModsMask;


    xkb = XkbCompileKeymapForDevice(dev, rmlvo, need);

    if (!xkb) {
        XkbRMLVOSet dflts;

        /* we didn't get what we really needed. And that will likely leave
         * us with a keyboard that doesn't work. Use the defaults instead */
        LogMessage(X_ERROR, "XKB: Failed to load keymap. Loading default "
                   "keymap instead.\n");

        XkbGetRulesDflts(&dflts);

        xkb = XkbCompileKeymapForDevice(dev, &dflts, 0);

        XkbFreeRMLVOSet(&dflts, FALSE);
    }

    return xkb;
}

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include "windowstr.h"
#include <xkbsrv.h>

int
XkbDDXPrivate(DeviceIntPtr dev,KeyCode key,XkbAction *act)
{
    return 0;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>

int
XkbDDXSwitchScreen(DeviceIntPtr dev,KeyCode key,XkbAction *act)
{
    return 1;
}
noinst_LTLIBRARIES = libxkb.la libxkbstubs.la

AM_CFLAGS = $(DIX_CFLAGS)

DDX_SRCS = \
        ddxBeep.c \
        ddxCtrls.c \
        ddxLEDs.c \
        ddxLoad.c \
        ddxList.c

DIX_SRCS = \
        xkb.c \
        xkbUtils.c \
        xkbEvents.c \
        xkbAccessX.c \
        xkbSwap.c \
        xkbLEDs.c \
        xkbInit.c \
        xkbActions.c \
        xkbPrKeyEv.c

# this should be replaced by a common library or something, ideally -d
XKBFILE_SRCS = \
        maprules.c \
        xkmread.c \
        xkbtext.c \
        xkbfmisc.c \
        xkbout.c

X11_SRCS = \
        XKBMisc.c \
        XKBAlloc.c \
        XKBGAlloc.c \
        XKBMAlloc.c

libxkb_la_SOURCES = $(DDX_SRCS) $(DIX_SRCS) $(XKBFILE_SRCS) $(X11_SRCS)
libxkbstubs_la_SOURCES = ddxVT.c ddxPrivate.c ddxKillSrv.c

EXTRA_DIST = xkbDflts.h xkbgeom.h xkb.h

xkbcompileddir = $(XKB_COMPILED_DIR)
dist_xkbcompiled_DATA = README.compiled
/************************************************************
 Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#define X_INCLUDE_STRING_H
#define XOS_USE_NO_LOCKING
#include <X11/Xos_r.h>

#include <X11/Xproto.h>
#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xfuncs.h>
#include <X11/Xatom.h>
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "os.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>

/***====================================================================***/



#define DFLT_LINE_SIZE	128

typedef struct {
	int	line_num;
	int	sz_line;
	int	num_line;
	char	buf[DFLT_LINE_SIZE];
	char *	line;
} InputLine;

static void
InitInputLine(InputLine *line)
{
    line->line_num= 1;
    line->num_line= 0;
    line->sz_line= DFLT_LINE_SIZE;
    line->line=	line->buf;
    return;
}

static void
FreeInputLine(InputLine *line)
{
    if (line->line!=line->buf)
	free(line->line);
    line->line_num= 1;
    line->num_line= 0;
    line->sz_line= DFLT_LINE_SIZE;
    line->line= line->buf;
    return;
}

static int
InputLineAddChar(InputLine *line,int ch)
{
    if (line->num_line>=line->sz_line) {
	if (line->line==line->buf) {
	    line->line= malloc(line->sz_line*2);
	    memcpy(line->line,line->buf,line->sz_line);
	}
	else {
	    line->line= realloc((char *)line->line,line->sz_line*2);
	}
	line->sz_line*= 2;
    }
    line->line[line->num_line++]= ch;
    return ch;
}

#define	ADD_CHAR(l,c)	((l)->num_line<(l)->sz_line?\
				(int)((l)->line[(l)->num_line++]= (c)):\
				InputLineAddChar(l,c))

static Bool
GetInputLine(FILE *file,InputLine *line,Bool checkbang)
{
int	ch;
Bool	endOfFile,spacePending,slashPending,inComment;

     endOfFile= FALSE;
     while ((!endOfFile)&&(line->num_line==0)) {
	spacePending= slashPending= inComment= FALSE;
	while (((ch=getc(file))!='\n')&&(ch!=EOF)) {
	    if (ch=='\\') {
		if ((ch=getc(file))==EOF)
		    break;
		if (ch=='\n') {
		    inComment= FALSE;
		    ch= ' ';
		    line->line_num++;
		}
	    }
	    if (inComment)
		continue;
	    if (ch=='/') {
		if (slashPending) {
		    inComment= TRUE;
		    slashPending= FALSE;
		}
		else {
		    slashPending= TRUE;
		}
		continue;
	    }
	    else if (slashPending) {
		if (spacePending) {
		    ADD_CHAR(line,' ');
		    spacePending= FALSE;
		}
		ADD_CHAR(line,'/');
		slashPending= FALSE;
	    }
	    if (isspace(ch)) {
		while (isspace(ch)&&(ch!='\n')&&(ch!=EOF)) {
		    ch= getc(file);
		}
		if (ch==EOF)
		    break;
		if ((ch!='\n')&&(line->num_line>0))
		    spacePending= TRUE;
		ungetc(ch,file);
	    }
	    else {
		if (spacePending) {
		    ADD_CHAR(line,' ');
		    spacePending= FALSE;
		}
		if (checkbang && ch=='!') {
		    if (line->num_line!=0) {
			DebugF("The '!' legal only at start of line\n");
			DebugF("Line containing '!' ignored\n");
			line->num_line= 0;
			inComment= 0;
			break;
		    }

		}
		ADD_CHAR(line,ch);
	    }
	}
	if (ch==EOF)
	     endOfFile= TRUE;
/*	else line->num_line++;*/
     }
     if ((line->num_line==0)&&(endOfFile))
	return FALSE;
      ADD_CHAR(line,'\0');
      return TRUE;
}

/***====================================================================***/

#define	MODEL		0
#define	LAYOUT		1
#define	VARIANT		2
#define	OPTION		3
#define	KEYCODES	4
#define SYMBOLS		5
#define	TYPES		6
#define	COMPAT		7
#define	GEOMETRY	8
#define	MAX_WORDS	9

#define	PART_MASK	0x000F
#define	COMPONENT_MASK	0x03F0

static	char *	cname[MAX_WORDS] = {
	"model", "layout", "variant", "option", 
	"keycodes", "symbols", "types", "compat", "geometry"
};

typedef	struct _RemapSpec {
	int			number;
	int			num_remap;
	struct	{
		int	word;
		int	index;
                }		remap[MAX_WORDS];
} RemapSpec;

typedef struct _FileSpec {
	char *			name[MAX_WORDS];
	struct _FileSpec *	pending;
} FileSpec;

typedef struct {
	char *			model;
	char *			layout[XkbNumKbdGroups+1];
	char *			variant[XkbNumKbdGroups+1];
	char *			options;
} XkbRF_MultiDefsRec, *XkbRF_MultiDefsPtr;

#define NDX_BUFF_SIZE	4

/***====================================================================***/

static char*
get_index(char *str, int *ndx)
{
   char ndx_buf[NDX_BUFF_SIZE];
   char *end;

   if (*str != '[') {
       *ndx = 0;
       return str;
   }
   str++;
   end = strchr(str, ']');
   if (end == NULL) {
       *ndx = -1;
       return str - 1;
   }
   if ( (end - str) >= NDX_BUFF_SIZE) {
       *ndx = -1;
       return end + 1;
   }
   strncpy(ndx_buf, str, end - str);
   ndx_buf[end - str] = '\0';
   *ndx = atoi(ndx_buf);
   return end + 1;
}

static void
SetUpRemap(InputLine *line,RemapSpec *remap)
{
char *		tok,*str;
unsigned	present, l_ndx_present, v_ndx_present;
register int	i;
int		len, ndx;
_Xstrtokparams	strtok_buf;
Bool		found;


   l_ndx_present = v_ndx_present = present= 0;
   str= &line->line[1];
   len = remap->number;
   memset((char *)remap, 0, sizeof(RemapSpec));
   remap->number = len;
   while ((tok=_XStrtok(str," ",strtok_buf))!=NULL) {
	found= FALSE;
	str= NULL;
	if (strcmp(tok,"=")==0)
	    continue;
	for (i=0;i<MAX_WORDS;i++) {
            len = strlen(cname[i]);
	    if (strncmp(cname[i],tok,len)==0) {
		if(strlen(tok) > len) {
		    char *end = get_index(tok+len, &ndx);
		    if ((i != LAYOUT && i != VARIANT) ||
			*end != '\0' || ndx == -1)
		        break;
		     if (ndx < 1 || ndx > XkbNumKbdGroups) {
		        DebugF("Illegal %s index: %d\n", cname[i], ndx);
		        DebugF("Index must be in range 1..%d\n",
				   XkbNumKbdGroups);
			break;
		     }
                } else {
		    ndx = 0;
                }
		found= TRUE;
		if (present&(1<<i)) {
		    if ((i == LAYOUT && l_ndx_present&(1<<ndx)) ||
			(i == VARIANT && v_ndx_present&(1<<ndx)) ) {
		        DebugF("Component \"%s\" listed twice\n",tok);
		        DebugF("Second definition ignored\n");
		        break;
		    }
		}
		present |= (1<<i);
                if (i == LAYOUT)
                    l_ndx_present |= 1 << ndx;
                if (i == VARIANT)
                    v_ndx_present |= 1 << ndx;
		remap->remap[remap->num_remap].word= i;
		remap->remap[remap->num_remap++].index= ndx;
		break;
	    }
	}
	if (!found) {
	    fprintf(stderr,"Unknown component \"%s\" ignored\n",tok);
	}
   }
   if ((present&PART_MASK)==0) {
	unsigned mask= PART_MASK;
	ErrorF("Mapping needs at least one of ");
	for (i=0; (i<MAX_WORDS); i++) {
	    if ((1L<<i)&mask) {
		mask&= ~(1L<<i);
		if (mask)	DebugF("\"%s,\" ",cname[i]);
		else		DebugF("or \"%s\"\n",cname[i]);
	    }
	}
	DebugF("Illegal mapping ignored\n");
	remap->num_remap= 0;
	return;
   }
   if ((present&COMPONENT_MASK)==0) {
	DebugF("Mapping needs at least one component\n");
	DebugF("Illegal mapping ignored\n");
	remap->num_remap= 0;
	return;
   }
   remap->number++;
   return;
}

static Bool
MatchOneOf(char *wanted,char *vals_defined)
{
char	*str,*next;
int	want_len= strlen(wanted);

    for (str=vals_defined,next=NULL;str!=NULL;str=next) {
	int len;
	next= strchr(str,',');
	if (next) {
	    len= next-str;
	    next++;
	}
	else {
	    len= strlen(str);
	}
	if ((len==want_len)&&(strncmp(wanted,str,len)==0))
	    return TRUE;
    }
    return FALSE;
}

/***====================================================================***/

static Bool
CheckLine(	InputLine *		line,
		RemapSpec *		remap,
		XkbRF_RulePtr		rule,
		XkbRF_GroupPtr		group)
{
char *		str,*tok;
register int	nread, i;
FileSpec	tmp;
_Xstrtokparams	strtok_buf;
Bool 		append = FALSE;

    if (line->line[0]=='!') {
        if (line->line[1] == '$' ||
            (line->line[1] == ' ' && line->line[2] == '$')) {
            char *gname = strchr(line->line, '$');
            char *words = strchr(gname, ' ');
            if(!words)
                return FALSE;
            *words++ = '\0';
            for (; *words; words++) {
                if (*words != '=' && *words != ' ')
                    break;
            }
            if (*words == '\0')
                return FALSE;
            group->name = Xstrdup(gname);
            group->words = Xstrdup(words);
            for (i = 1, words = group->words; *words; words++) {
                 if ( *words == ' ') {
                     *words++ = '\0';
                     i++;
                 }
            }
            group->number = i;
            return TRUE;
        } else {
	    SetUpRemap(line,remap);
	    return FALSE;
        }
    }

    if (remap->num_remap==0) {
	DebugF("Must have a mapping before first line of data\n");
	DebugF("Illegal line of data ignored\n");
	return FALSE;
    }
    memset((char *)&tmp, 0, sizeof(FileSpec));
    str= line->line;
    for (nread= 0;(tok=_XStrtok(str," ",strtok_buf))!=NULL;nread++) {
	str= NULL;
	if (strcmp(tok,"=")==0) {
	    nread--;
	    continue;
	}
	if (nread>remap->num_remap) {
	    DebugF("Too many words on a line\n");
	    DebugF("Extra word \"%s\" ignored\n",tok);
	    continue;
	}
	tmp.name[remap->remap[nread].word]= tok;
	if (*tok == '+' || *tok == '|')
	    append = TRUE;
    }
    if (nread<remap->num_remap) {
	DebugF("Too few words on a line: %s\n", line->line);
	DebugF("line ignored\n");
	return FALSE;
    }

    rule->flags= 0;
    rule->number = remap->number;
    if (tmp.name[OPTION])
	 rule->flags|= XkbRF_Option;
    else if (append)
	 rule->flags|= XkbRF_Append;
    else
	 rule->flags|= XkbRF_Normal;
    rule->model= Xstrdup(tmp.name[MODEL]);
    rule->layout= Xstrdup(tmp.name[LAYOUT]);
    rule->variant= Xstrdup(tmp.name[VARIANT]);
    rule->option= Xstrdup(tmp.name[OPTION]);

    rule->keycodes= Xstrdup(tmp.name[KEYCODES]);
    rule->symbols= Xstrdup(tmp.name[SYMBOLS]);
    rule->types= Xstrdup(tmp.name[TYPES]);
    rule->compat= Xstrdup(tmp.name[COMPAT]);
    rule->geometry= Xstrdup(tmp.name[GEOMETRY]);

    rule->layout_num = rule->variant_num = 0;
    for (i = 0; i < nread; i++) {
        if (remap->remap[i].index) {
	    if (remap->remap[i].word == LAYOUT)
	        rule->layout_num = remap->remap[i].index;
	    if (remap->remap[i].word == VARIANT)
	        rule->variant_num = remap->remap[i].index;
        }
    }
    return TRUE;
}

static char *
_Concat(char *str1,char *str2)
{
int len;

    if ((!str1)||(!str2))
	return str1;
    len= strlen(str1)+strlen(str2)+1;
    str1= realloc(str1,len * sizeof(char));
    if (str1)
	strcat(str1,str2);
    return str1;
}

static void
squeeze_spaces(char *p1)
{
   char *p2;
   for (p2 = p1; *p2; p2++) {
       *p1 = *p2;
       if (*p1 != ' ') p1++;
   }
   *p1 = '\0';
}

static Bool
MakeMultiDefs(XkbRF_MultiDefsPtr mdefs, XkbRF_VarDefsPtr defs)
{

   memset((char *)mdefs, 0, sizeof(XkbRF_MultiDefsRec));
   mdefs->model = defs->model;
   mdefs->options = Xstrdup(defs->options);
   if (mdefs->options) squeeze_spaces(mdefs->options); 

   if (defs->layout) {
       if (!strchr(defs->layout, ',')) {
           mdefs->layout[0] = defs->layout;
       } else {
           char *p;
           int i;
           mdefs->layout[1] = Xstrdup(defs->layout);
	   if (mdefs->layout[1] == NULL)
	      return FALSE;
           squeeze_spaces(mdefs->layout[1]);
           p = mdefs->layout[1];
           for (i = 2; i <= XkbNumKbdGroups; i++) {
              if ((p = strchr(p, ','))) {
                 *p++ = '\0';
                 mdefs->layout[i] = p;
              } else {
                 break;
              }
           }
           if (p && (p = strchr(p, ',')))
              *p = '\0';
       }
   }

   if (defs->variant) {
       if (!strchr(defs->variant, ',')) {
           mdefs->variant[0] = defs->variant;
       } else {
           char *p;
           int i;
           mdefs->variant[1] = Xstrdup(defs->variant);
	   if (mdefs->variant[1] == NULL)
	      return FALSE;
           squeeze_spaces(mdefs->variant[1]);
           p = mdefs->variant[1];
           for (i = 2; i <= XkbNumKbdGroups; i++) {
              if ((p = strchr(p, ','))) {
                 *p++ = '\0';
                 mdefs->variant[i] = p;
              } else {
                 break;
              }
           }
           if (p && (p = strchr(p, ',')))
              *p = '\0';
       }
   }
   return TRUE;
}

static void
FreeMultiDefs(XkbRF_MultiDefsPtr defs)
{
  free(defs->options);
  free(defs->layout[1]);
  free(defs->variant[1]);
}

static void
Apply(char *src, char **dst)
{
    if (src) {
        if (*src == '+' || *src == '!') {
	    *dst= _Concat(*dst, src);
        } else {
            if (*dst == NULL)
	        *dst= Xstrdup(src);
        }
    }
}

static void
XkbRF_ApplyRule(	XkbRF_RulePtr 		rule,
			XkbComponentNamesPtr	names)
{
    rule->flags&= ~XkbRF_PendingMatch; /* clear the flag because it's applied */

    Apply(rule->keycodes, &names->keycodes);
    Apply(rule->symbols,  &names->symbols);
    Apply(rule->types,    &names->types);
    Apply(rule->compat,   &names->compat);
    Apply(rule->geometry, &names->geometry);
}

static Bool
CheckGroup(	XkbRF_RulesPtr          rules,
		char * 			group_name,
		char * 			name)
{
   int i;
   char *p;
   XkbRF_GroupPtr group;

   for (i = 0, group = rules->groups; i < rules->num_groups; i++, group++) {
       if (! strcmp(group->name, group_name)) {
           break;
       }
   }
   if (i == rules->num_groups)
       return FALSE;
   for (i = 0, p = group->words; i < group->number; i++, p += strlen(p)+1) {
       if (! strcmp(p, name)) {
           return TRUE;
       }
   }
   return FALSE;
}

static int
XkbRF_CheckApplyRule(	XkbRF_RulePtr 		rule,
			XkbRF_MultiDefsPtr	mdefs,
			XkbComponentNamesPtr	names,
			XkbRF_RulesPtr          rules)
{
    Bool pending = FALSE;

    if (rule->model != NULL) {
        if(mdefs->model == NULL)
            return 0;
        if (strcmp(rule->model, "*") == 0) {
            pending = TRUE;
        } else {
            if (rule->model[0] == '$') {
               if (!CheckGroup(rules, rule->model, mdefs->model))
                  return 0;
            } else {
	       if (strcmp(rule->model, mdefs->model) != 0)
	          return 0;
	    }
	}
    }
    if (rule->option != NULL) {
	if (mdefs->options == NULL)
	    return 0;
	if ((!MatchOneOf(rule->option,mdefs->options)))
	    return 0;
    }

    if (rule->layout != NULL) {
	if(mdefs->layout[rule->layout_num] == NULL ||
	   *mdefs->layout[rule->layout_num] == '\0')
	    return 0;
        if (strcmp(rule->layout, "*") == 0) {
            pending = TRUE;
        } else {
            if (rule->layout[0] == '$') {
               if (!CheckGroup(rules, rule->layout,
                               mdefs->layout[rule->layout_num]))
                  return 0;
	    } else {
	       if (strcmp(rule->layout, mdefs->layout[rule->layout_num]) != 0)
	           return 0;
	    }
	}
    }
    if (rule->variant != NULL) {
	if (mdefs->variant[rule->variant_num] == NULL ||
	    *mdefs->variant[rule->variant_num] == '\0')
	    return 0;
        if (strcmp(rule->variant, "*") == 0) {
            pending = TRUE;
        } else {
            if (rule->variant[0] == '$') {
               if (!CheckGroup(rules, rule->variant,
                               mdefs->variant[rule->variant_num]))
                  return 0;
            } else {
	       if (strcmp(rule->variant,
                          mdefs->variant[rule->variant_num]) != 0)
	           return 0;
	    }
	}
    }
    if (pending) {
        rule->flags|= XkbRF_PendingMatch;
	return rule->number;
    }
    /* exact match, apply it now */
    XkbRF_ApplyRule(rule,names);
    return rule->number;
}

static void
XkbRF_ClearPartialMatches(XkbRF_RulesPtr rules)
{
register int 	i;
XkbRF_RulePtr	rule;

    for (i=0,rule=rules->rules;i<rules->num_rules;i++,rule++) {
	rule->flags&= ~XkbRF_PendingMatch;
    }
}

static void
XkbRF_ApplyPartialMatches(XkbRF_RulesPtr rules,XkbComponentNamesPtr names)
{
int		i;
XkbRF_RulePtr	rule;

    for (rule = rules->rules, i = 0; i < rules->num_rules; i++, rule++) {
	if ((rule->flags&XkbRF_PendingMatch)==0)
	    continue;
	XkbRF_ApplyRule(rule,names);
    }
}

static void
XkbRF_CheckApplyRules(	XkbRF_RulesPtr 		rules,
			XkbRF_MultiDefsPtr	mdefs,
			XkbComponentNamesPtr	names,
			int			flags)
{
int		i;
XkbRF_RulePtr	rule;
int		skip;

    for (rule = rules->rules, i=0; i < rules->num_rules; rule++, i++) {
	if ((rule->flags & flags) != flags)
	    continue;
	skip = XkbRF_CheckApplyRule(rule, mdefs, names, rules);
	if (skip && !(flags & XkbRF_Option)) {
	    for ( ;(i < rules->num_rules) && (rule->number == skip);
		  rule++, i++);
	    rule--; i--;
	}
    }
}

/***====================================================================***/

static char *
XkbRF_SubstituteVars(char *name, XkbRF_MultiDefsPtr mdefs)
{
char 	*str, *outstr, *orig, *var;
int	len, ndx;

    orig= name;
    str= index(name,'%');
    if (str==NULL)
	return name;
    len= strlen(name);
    while (str!=NULL) {
	char pfx= str[1];
	int   extra_len= 0;
	if ((pfx=='+')||(pfx=='|')||(pfx=='_')||(pfx=='-')) {
	    extra_len= 1;
	    str++;
	}
	else if (pfx=='(') {
	    extra_len= 2;
	    str++;
	}
	var = str + 1;
	str = get_index(var + 1, &ndx);
	if (ndx == -1) {
	    str = index(str,'%');
	    continue;
        }
	if ((*var=='l') && mdefs->layout[ndx] && *mdefs->layout[ndx])
	    len+= strlen(mdefs->layout[ndx])+extra_len;
	else if ((*var=='m')&&mdefs->model)
	    len+= strlen(mdefs->model)+extra_len;
	else if ((*var=='v') && mdefs->variant[ndx] && *mdefs->variant[ndx])
	    len+= strlen(mdefs->variant[ndx])+extra_len;
	if ((pfx=='(')&&(*str==')')) {
	    str++;
	}
	str= index(&str[0],'%');
    }
    name= malloc(len+1);
    str= orig;
    outstr= name;
    while (*str!='\0') {
	if (str[0]=='%') {
	    char pfx,sfx;
	    str++;
	    pfx= str[0];
	    sfx= '\0';
	    if ((pfx=='+')||(pfx=='|')||(pfx=='_')||(pfx=='-')) {
		str++;
	    }
	    else if (pfx=='(') {
		sfx= ')';
		str++;
	    }
	    else pfx= '\0';

	    var = str;
	    str = get_index(var + 1, &ndx);
	    if (ndx == -1) {
	        continue;
            }
	    if ((*var=='l') && mdefs->layout[ndx] && *mdefs->layout[ndx]) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->layout[ndx]);
		outstr+= strlen(mdefs->layout[ndx]);
		if (sfx) *outstr++= sfx;
	    }
	    else if ((*var=='m')&&(mdefs->model)) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->model);
		outstr+= strlen(mdefs->model);
		if (sfx) *outstr++= sfx;
	    }
	    else if ((*var=='v') && mdefs->variant[ndx] && *mdefs->variant[ndx]) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->variant[ndx]);
		outstr+= strlen(mdefs->variant[ndx]);
		if (sfx) *outstr++= sfx;
	    }
	    if ((pfx=='(')&&(*str==')'))
		str++;
	}
	else {
	    *outstr++= *str++;
	}
    }
    *outstr++= '\0';
    if (orig!=name)
	free(orig);
    return name;
}

/***====================================================================***/

Bool
XkbRF_GetComponents(	XkbRF_RulesPtr		rules,
			XkbRF_VarDefsPtr	defs,
			XkbComponentNamesPtr	names)
{
    XkbRF_MultiDefsRec mdefs;

    MakeMultiDefs(&mdefs, defs);

    memset((char *)names, 0, sizeof(XkbComponentNamesRec));
    XkbRF_ClearPartialMatches(rules);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Normal);
    XkbRF_ApplyPartialMatches(rules, names);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Append);
    XkbRF_ApplyPartialMatches(rules, names);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Option);

    if (names->keycodes)
	names->keycodes= XkbRF_SubstituteVars(names->keycodes, &mdefs);
    if (names->symbols)	
	names->symbols=	XkbRF_SubstituteVars(names->symbols, &mdefs);
    if (names->types)
	names->types= XkbRF_SubstituteVars(names->types, &mdefs);
    if (names->compat)
	names->compat= XkbRF_SubstituteVars(names->compat, &mdefs);
    if (names->geometry)
	names->geometry= XkbRF_SubstituteVars(names->geometry, &mdefs);

    FreeMultiDefs(&mdefs);
    return (names->keycodes && names->symbols && names->types &&
		names->compat && names->geometry);
}

static XkbRF_RulePtr
XkbRF_AddRule(XkbRF_RulesPtr	rules)
{
    if (rules->sz_rules<1) {
	rules->sz_rules= 16;
	rules->num_rules= 0;
	rules->rules= calloc(rules->sz_rules, sizeof(XkbRF_RuleRec));
    }
    else if (rules->num_rules>=rules->sz_rules) {
	rules->sz_rules*= 2;
	rules->rules= realloc(rules->rules,
				rules->sz_rules * sizeof(XkbRF_RuleRec));
    }
    if (!rules->rules) {
	rules->sz_rules= rules->num_rules= 0;
	DebugF("Allocation failure in XkbRF_AddRule\n");
	return NULL;
    }
    memset((char *)&rules->rules[rules->num_rules], 0, sizeof(XkbRF_RuleRec));
    return &rules->rules[rules->num_rules++];
}

static XkbRF_GroupPtr
XkbRF_AddGroup(XkbRF_RulesPtr	rules)
{
    if (rules->sz_groups<1) {
	rules->sz_groups= 16;
	rules->num_groups= 0;
	rules->groups= calloc(rules->sz_groups, sizeof(XkbRF_GroupRec));
    }
    else if (rules->num_groups >= rules->sz_groups) {
	rules->sz_groups *= 2;
	rules->groups= realloc(rules->groups,
				rules->sz_groups * sizeof(XkbRF_GroupRec));
    }
    if (!rules->groups) {
	rules->sz_groups= rules->num_groups= 0;
	return NULL;
    }

    memset((char *)&rules->groups[rules->num_groups], 0, sizeof(XkbRF_GroupRec));
    return &rules->groups[rules->num_groups++];
}

Bool
XkbRF_LoadRules(FILE *file, XkbRF_RulesPtr rules)
{
InputLine	line;
RemapSpec	remap;
XkbRF_RuleRec	trule,*rule;
XkbRF_GroupRec  tgroup,*group;

    if (!(rules && file))
	return FALSE;
    memset((char *)&remap, 0, sizeof(RemapSpec));
    memset((char *)&tgroup, 0, sizeof(XkbRF_GroupRec));
    InitInputLine(&line);
    while (GetInputLine(file,&line,TRUE)) {
	if (CheckLine(&line,&remap,&trule,&tgroup)) {
            if (tgroup.number) {
	        if ((group= XkbRF_AddGroup(rules))!=NULL) {
		    *group= tgroup;
		    memset((char *)&tgroup, 0, sizeof(XkbRF_GroupRec));
	        }
	    } else {
	        if ((rule= XkbRF_AddRule(rules))!=NULL) {
		    *rule= trule;
		    memset((char *)&trule, 0, sizeof(XkbRF_RuleRec));
	        }
	    }
	}
	line.num_line= 0;
    }
    FreeInputLine(&line);
    return TRUE;
}

Bool
XkbRF_LoadRulesByName(char *base,char *locale,XkbRF_RulesPtr rules)
{
FILE *		file;
char		buf[PATH_MAX];
Bool		ok;

    if ((!base)||(!rules))
	return FALSE;
    if (locale) {
	if (snprintf(buf, PATH_MAX, "%s-%s", base, locale) >= PATH_MAX)
	    return FALSE;
    }
    else {
	if (strlen(base)+1 > PATH_MAX)
	    return FALSE;
	strcpy(buf,base);
    }

    file= fopen(buf, "r");
    if ((!file)&&(locale)) { /* fallback if locale was specified */
	strcpy(buf,base);
	file= fopen(buf, "r");
    }
    if (!file)
	return FALSE;
    ok= XkbRF_LoadRules(file,rules);
    fclose(file);
    return ok;
}

/***====================================================================***/

XkbRF_RulesPtr
XkbRF_Create(void)
{
    return calloc(1, sizeof( XkbRF_RulesRec));
}

/***====================================================================***/

void
XkbRF_Free(XkbRF_RulesPtr rules,Bool freeRules)
{
int		i;
XkbRF_RulePtr	rule;
XkbRF_GroupPtr	group;

    if (!rules)
	return;
    if (rules->rules) {
	for (i=0,rule=rules->rules;i<rules->num_rules;i++,rule++) {
	    free(rule->model);
	    free(rule->layout);
	    free(rule->variant);
	    free(rule->option);
	    free(rule->keycodes);
	    free(rule->symbols);
	    free(rule->types);
	    free(rule->compat);
	    free(rule->geometry);
	    memset((char *)rule, 0, sizeof(XkbRF_RuleRec));
	}
	free(rules->rules);
	rules->num_rules= rules->sz_rules= 0;
	rules->rules= NULL;
    }

    if (rules->groups) {
	for (i=0, group=rules->groups;i<rules->num_groups;i++,group++) {
	    free(group->name);
	    free(group->words);
	}
	free(rules->groups);
	rules->num_groups= 0;
	rules->groups= NULL;
    }
    if (freeRules)
	free(rules);
    return;
}

The X server uses this directory to store the compiled version of the
current keymap and/or any scratch keymaps used by clients.  The X server
or some other tool might destroy or replace the files in this directory,
so it is not a safe place to store compiled keymaps for long periods of
time.  The default keymap for any server is usually stored in:
     X<num>-default.xkm
where <num> is the display number of the server in question, which makes
it possible for several servers *on the same host* to share the same 
directory.

Unless the X server is modified, sharing this directory between servers on
different hosts could cause problems.
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "extnsionst.h"
#include "xace.h"
#include "xkb.h"
#include "protocol-versions.h"

#include <X11/extensions/XI.h>
#include <X11/extensions/XKMformat.h>

int		XkbEventBase;
static	int	XkbErrorBase;
int		XkbReqCode;
int		XkbKeyboardErrorCode;
CARD32		xkbDebugFlags = 0;
static CARD32	xkbDebugCtrls = 0;

static RESTYPE	RT_XKBCLIENT;

/***====================================================================***/

#define	CHK_DEVICE(dev, id, client, access_mode, lf) {\
    int why;\
    int rc = lf(&(dev), id, client, access_mode, &why);\
    if (rc != Success) {\
	client->errorValue = _XkbErrCode2(why, id);\
	return rc;\
    }\
}

#define	CHK_KBD_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupKeyboard)
#define	CHK_LED_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupLedDevice)
#define	CHK_BELL_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupBellDevice)
#define	CHK_ANY_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupAnyDevice)

#define	CHK_ATOM_ONLY2(a,ev,er) {\
	if (((a)==None)||(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    return er;\
	}\
}
#define	CHK_ATOM_ONLY(a) \
	CHK_ATOM_ONLY2(a,client->errorValue,BadAtom)

#define	CHK_ATOM_OR_NONE3(a,ev,er,ret) {\
	if (((a)!=None)&&(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    (er)= BadAtom;\
	    return ret;\
	}\
}
#define	CHK_ATOM_OR_NONE2(a,ev,er) {\
	if (((a)!=None)&&(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    return er;\
	}\
}
#define	CHK_ATOM_OR_NONE(a) \
	CHK_ATOM_OR_NONE2(a,client->errorValue,BadAtom)

#define	CHK_MASK_LEGAL3(err,mask,legal,ev,er,ret)	{\
	if ((mask)&(~(legal))) { \
	    (ev)= _XkbErrCode2((err),((mask)&(~(legal))));\
	    (er)= BadValue;\
	    return ret;\
	}\
}
#define	CHK_MASK_LEGAL2(err,mask,legal,ev,er)	{\
	if ((mask)&(~(legal))) { \
	    (ev)= _XkbErrCode2((err),((mask)&(~(legal))));\
	    return er;\
	}\
}
#define	CHK_MASK_LEGAL(err,mask,legal) \
	CHK_MASK_LEGAL2(err,mask,legal,client->errorValue,BadValue)

#define	CHK_MASK_MATCH(err,affect,value) {\
	if ((value)&(~(affect))) { \
	    client->errorValue= _XkbErrCode2((err),((value)&(~(affect))));\
	    return BadMatch;\
	}\
}
#define	CHK_MASK_OVERLAP(err,m1,m2) {\
	if ((m1)&(m2)) { \
	    client->errorValue= _XkbErrCode2((err),((m1)&(m2)));\
	    return BadMatch;\
	}\
}
#define	CHK_KEY_RANGE2(err,first,num,x,ev,er) {\
	if (((unsigned)(first)+(num)-1)>(x)->max_key_code) {\
	    (ev)=_XkbErrCode4(err,(first),(num),(x)->max_key_code);\
	    return er;\
	}\
	else if ( (first)<(x)->min_key_code ) {\
	    (ev)=_XkbErrCode3(err+1,(first),xkb->min_key_code);\
	    return er;\
	}\
}
#define	CHK_KEY_RANGE(err,first,num,x)  \
	CHK_KEY_RANGE2(err,first,num,x,client->errorValue,BadValue)

#define	CHK_REQ_KEY_RANGE2(err,first,num,r,ev,er) {\
	if (((unsigned)(first)+(num)-1)>(r)->maxKeyCode) {\
	    (ev)=_XkbErrCode4(err,(first),(num),(r)->maxKeyCode);\
	    return er;\
	}\
	else if ( (first)<(r)->minKeyCode ) {\
	    (ev)=_XkbErrCode3(err+1,(first),(r)->minKeyCode);\
	    return er;\
	}\
}
#define	CHK_REQ_KEY_RANGE(err,first,num,r)  \
	CHK_REQ_KEY_RANGE2(err,first,num,r,client->errorValue,BadValue)

/***====================================================================***/

int
ProcXkbUseExtension(ClientPtr client)
{
    REQUEST(xkbUseExtensionReq);
    xkbUseExtensionReply	rep;
    register int n;
    int	supported;

    REQUEST_SIZE_MATCH(xkbUseExtensionReq);
    if (stuff->wantedMajor != SERVER_XKB_MAJOR_VERSION) {
	/* pre-release version 0.65 is compatible with 1.00 */
	supported= ((SERVER_XKB_MAJOR_VERSION==1)&&
		    (stuff->wantedMajor==0)&&(stuff->wantedMinor==65));
    }
    else supported = 1;

    if ((supported) && (!(client->xkbClientFlags&_XkbClientInitialized))) {
	client->xkbClientFlags= _XkbClientInitialized;
	client->vMajor= stuff->wantedMajor;
	client->vMinor= stuff->wantedMinor;
    }
    else if (xkbDebugFlags&0x1) {
	ErrorF("[xkb] Rejecting client %d (0x%lx) (wants %d.%02d, have %d.%02d)\n",
					client->index,
					(long)client->clientAsMask,
					stuff->wantedMajor,stuff->wantedMinor,
					SERVER_XKB_MAJOR_VERSION,SERVER_XKB_MINOR_VERSION);
    }
    memset(&rep, 0, sizeof(xkbUseExtensionReply));
    rep.type = X_Reply;
    rep.supported = supported;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.serverMajor = SERVER_XKB_MAJOR_VERSION;
    rep.serverMinor = SERVER_XKB_MINOR_VERSION;
    if ( client->swapped ) {
	swaps(&rep.sequenceNumber, n);
	swaps(&rep.serverMajor, n);
	swaps(&rep.serverMinor, n);
    }
    WriteToClient(client,SIZEOF(xkbUseExtensionReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

int
ProcXkbSelectEvents(ClientPtr client)
{
    unsigned		legal;
    DeviceIntPtr 	dev;
    XkbInterestPtr	masks;
    REQUEST(xkbSelectEventsReq);

    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixUseAccess);

    if (((stuff->affectWhich&XkbMapNotifyMask)!=0)&&(stuff->affectMap)) {
	client->mapNotifyMask&= ~stuff->affectMap;
	client->mapNotifyMask|= (stuff->affectMap&stuff->map);
    }
    if ((stuff->affectWhich&(~XkbMapNotifyMask))==0) 
	return Success;

    masks = XkbFindClientResource((DevicePtr)dev,client);
    if (!masks){
	XID id = FakeClientID(client->index);
	if (!AddResource(id,RT_XKBCLIENT,dev))
	    return BadAlloc;
	masks= XkbAddClientResource((DevicePtr)dev,client,id);
    }
    if (masks) {
	union {
	    CARD8	*c8;
	    CARD16	*c16;
	    CARD32	*c32;
	} from,to;
	register unsigned bit,ndx,maskLeft,dataLeft,size;

	from.c8= (CARD8 *)&stuff[1];
	dataLeft= (stuff->length*4)-SIZEOF(xkbSelectEventsReq);
	maskLeft= (stuff->affectWhich&(~XkbMapNotifyMask));
	for (ndx=0,bit=1; (maskLeft!=0); ndx++, bit<<=1) {
	    if ((bit&maskLeft)==0)
		continue;
	    maskLeft&= ~bit;
	    switch (ndx) {
		case XkbNewKeyboardNotify:
		    to.c16= &client->newKeyboardNotifyMask;
		    legal= XkbAllNewKeyboardEventsMask;
		    size= 2;
		    break;
		case XkbStateNotify:
		    to.c16= &masks->stateNotifyMask;
		    legal= XkbAllStateEventsMask;
		    size= 2;
		    break;
		case XkbControlsNotify:
		    to.c32= &masks->ctrlsNotifyMask;
		    legal= XkbAllControlEventsMask;
		    size= 4;
		    break;
		case XkbIndicatorStateNotify:
		    to.c32= &masks->iStateNotifyMask;
		    legal= XkbAllIndicatorEventsMask;
		    size= 4;
		    break;
		case XkbIndicatorMapNotify:
		    to.c32= &masks->iMapNotifyMask;
		    legal= XkbAllIndicatorEventsMask;
		    size= 4;
		    break;
		case XkbNamesNotify:
		    to.c16= &masks->namesNotifyMask;
		    legal= XkbAllNameEventsMask;
		    size= 2;
		    break;
		case XkbCompatMapNotify:
		    to.c8= &masks->compatNotifyMask;
		    legal= XkbAllCompatMapEventsMask;
		    size= 1;
		    break;
		case XkbBellNotify:
		    to.c8= &masks->bellNotifyMask;
		    legal= XkbAllBellEventsMask;
		    size= 1;
		    break;
		case XkbActionMessage:
		    to.c8= &masks->actionMessageMask;
		    legal= XkbAllActionMessagesMask;
		    size= 1;
		    break;
		case XkbAccessXNotify:
		    to.c16= &masks->accessXNotifyMask;
		    legal= XkbAllAccessXEventsMask;
		    size= 2;
		    break;
		case XkbExtensionDeviceNotify:
		    to.c16= &masks->extDevNotifyMask;
		    legal= XkbAllExtensionDeviceEventsMask;
		    size= 2;
		    break;
		default:
		    client->errorValue = _XkbErrCode2(33,bit);
		    return BadValue;
	    }

	    if (stuff->clear&bit) {
		if (size==2)		to.c16[0]= 0;
		else if (size==4)	to.c32[0]= 0;
		else			to.c8[0]=  0;
	    }
	    else if (stuff->selectAll&bit) {
		if (size==2)		to.c16[0]= ~0;
		else if (size==4)	to.c32[0]= ~0;
		else			to.c8[0]=  ~0;
	    }
	    else {
		if (dataLeft<(size*2))
		    return BadLength;
		if (size==2) {
		    CHK_MASK_MATCH(ndx,from.c16[0],from.c16[1]);
		    CHK_MASK_LEGAL(ndx,from.c16[0],legal);
		    to.c16[0]&= ~from.c16[0];
		    to.c16[0]|= (from.c16[0]&from.c16[1]);
		}
		else if (size==4) {
		    CHK_MASK_MATCH(ndx,from.c32[0],from.c32[1]);
		    CHK_MASK_LEGAL(ndx,from.c32[0],legal);
		    to.c32[0]&= ~from.c32[0];
		    to.c32[0]|= (from.c32[0]&from.c32[1]);
		}
		else  {
		    CHK_MASK_MATCH(ndx,from.c8[0],from.c8[1]);
		    CHK_MASK_LEGAL(ndx,from.c8[0],legal);
		    to.c8[0]&= ~from.c8[0];
		    to.c8[0]|= (from.c8[0]&from.c8[1]);
		    size= 2;
		}
		from.c8+= (size*2);
		dataLeft-= (size*2);
	    }
	}
	if (dataLeft>2) {
	    ErrorF("[xkb] Extra data (%d bytes) after SelectEvents\n",dataLeft);
	    return BadLength;
	}
	return Success;
    }
    return BadAlloc;
}

/***====================================================================***/
/**
 * Ring a bell on the given device for the given client.
 */
static int
_XkbBell(ClientPtr client, DeviceIntPtr dev, WindowPtr pWin,
         int bellClass, int bellID, int pitch, int duration,
         int percent, int forceSound, int eventOnly, Atom name)
{
    int         base;
    pointer     ctrl;
    int         oldPitch, oldDuration;
    int         newPercent;

    if (bellClass == KbdFeedbackClass) {
        KbdFeedbackPtr	k;
        if (bellID==XkbDfltXIId)
            k= dev->kbdfeed;
        else {
            for (k=dev->kbdfeed; k; k=k->next) {
                if (k->ctrl.id == bellID)
                    break;
            }
        }
        if (!k) {
            client->errorValue = _XkbErrCode2(0x5,bellID);
            return BadValue;
        }
        base = k->ctrl.bell;
        ctrl = (pointer) &(k->ctrl);
        oldPitch= k->ctrl.bell_pitch;
        oldDuration= k->ctrl.bell_duration;
        if (pitch!=0) {
            if (pitch==-1)
                k->ctrl.bell_pitch= defaultKeyboardControl.bell_pitch;
            else k->ctrl.bell_pitch= pitch;
        }
        if (duration!=0) {
            if (duration==-1)
                k->ctrl.bell_duration= defaultKeyboardControl.bell_duration;
            else k->ctrl.bell_duration= duration;
        }
    }
    else if (bellClass == BellFeedbackClass) {
        BellFeedbackPtr	b;
        if (bellID==XkbDfltXIId)
            b= dev->bell;
        else {
            for (b=dev->bell; b; b=b->next) {
                if (b->ctrl.id == bellID)
                    break;
            }
        }
        if (!b) {
            client->errorValue = _XkbErrCode2(0x6,bellID);
            return BadValue;
        }
        base = b->ctrl.percent;
        ctrl = (pointer) &(b->ctrl);
        oldPitch= b->ctrl.pitch;
        oldDuration= b->ctrl.duration;
        if (pitch!=0) {
            if (pitch==-1)
                b->ctrl.pitch= defaultKeyboardControl.bell_pitch;
            else b->ctrl.pitch= pitch;
        }
        if (duration!=0) {
            if (duration==-1)
                b->ctrl.duration= defaultKeyboardControl.bell_duration;
            else b->ctrl.duration= duration;
        }
    }
    else {
        client->errorValue = _XkbErrCode2(0x7, bellClass);
        return BadValue;
    }

    newPercent = (base * percent)/100;
    if (percent < 0)
         newPercent = base + newPercent;
    else newPercent = base - newPercent + percent;

    XkbHandleBell(forceSound, eventOnly,
                  dev, newPercent, ctrl, bellClass,
                  name, pWin, client);
    if ((pitch!=0)||(duration!=0)) {
        if (bellClass == KbdFeedbackClass) {
            KbdFeedbackPtr      k;
            k= (KbdFeedbackPtr)ctrl;
            if (pitch!=0)
                k->ctrl.bell_pitch= oldPitch;
            if (duration!=0)
                k->ctrl.bell_duration= oldDuration;
        }
        else {
            BellFeedbackPtr     b;
            b= (BellFeedbackPtr)ctrl;
            if (pitch!=0)
                b->ctrl.pitch= oldPitch;
            if (duration!=0)
                b->ctrl.duration= oldDuration;
        }
    }

    return Success;
}

int
ProcXkbBell(ClientPtr client)
{
    REQUEST(xkbBellReq);
    DeviceIntPtr dev;
    WindowPtr	 pWin;
    int rc;

    REQUEST_SIZE_MATCH(xkbBellReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_BELL_DEVICE(dev, stuff->deviceSpec, client, DixBellAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    /* device-independent checks request for sane values */
    if ((stuff->forceSound)&&(stuff->eventOnly)) {
	client->errorValue=_XkbErrCode3(0x1,stuff->forceSound,stuff->eventOnly);
	return BadMatch;
    }
    if (stuff->percent < -100 || stuff->percent > 100) {
	client->errorValue = _XkbErrCode2(0x2,stuff->percent);
	return BadValue;
    }
    if (stuff->duration<-1) {
	client->errorValue = _XkbErrCode2(0x3,stuff->duration);
	return BadValue;
    }
    if (stuff->pitch<-1) {
	client->errorValue = _XkbErrCode2(0x4,stuff->pitch);
	return BadValue;
    }

    if (stuff->bellClass == XkbDfltXIClass) {
	if (dev->kbdfeed!=NULL)
	     stuff->bellClass= KbdFeedbackClass;
	else stuff->bellClass= BellFeedbackClass;
    }

    if (stuff->window!=None) {
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success) {
	    client->errorValue= stuff->window;
	    return rc;
	}
    }
    else pWin= NULL;

    /* Client wants to ring a bell on the core keyboard?
       Ring the bell on the core keyboard (which does nothing, but if that
       fails the client is screwed anyway), and then on all extension devices.
       Fail if the core keyboard fails but not the extension devices.  this
       may cause some keyboards to ding and others to stay silent. Fix
       your client to use explicit keyboards to avoid this.

       dev is the device the client requested.
     */
    rc = _XkbBell(client, dev, pWin, stuff->bellClass, stuff->bellID,
                  stuff->pitch, stuff->duration, stuff->percent,
                  stuff->forceSound, stuff->eventOnly, stuff->name);

    if ((rc == Success) && ((stuff->deviceSpec == XkbUseCoreKbd) ||
                            (stuff->deviceSpec == XkbUseCorePtr)))
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixBellAccess);
                if (rc == Success)
                    _XkbBell(client, other, pWin, stuff->bellClass,
                             stuff->bellID, stuff->pitch, stuff->duration,
                             stuff->percent, stuff->forceSound,
                             stuff->eventOnly, stuff->name);
            }
        }
        rc = Success; /* reset to success, that's what we got for the VCK */
    }

    return rc;
}

/***====================================================================***/

int
ProcXkbGetState(ClientPtr client)
{
    REQUEST(xkbGetStateReq);
    DeviceIntPtr	dev;
    xkbGetStateReply	 rep;
    XkbStateRec		*xkb;

    REQUEST_SIZE_MATCH(xkbGetStateReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb= &dev->key->xkbInfo->state;
    memset(&rep, 0, sizeof(xkbGetStateReply));
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.mods = XkbStateFieldFromRec(xkb) & 0xff;
    rep.baseMods = xkb->base_mods;
    rep.lockedMods = xkb->locked_mods;
    rep.latchedMods = xkb->latched_mods;
    rep.group = xkb->group;
    rep.baseGroup = xkb->base_group;
    rep.latchedGroup = xkb->latched_group;
    rep.lockedGroup = xkb->locked_group;
    rep.compatState = xkb->compat_state;
    rep.ptrBtnState = xkb->ptr_buttons;
    if (client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swaps(&rep.ptrBtnState,n);
    }
    WriteToClient(client, SIZEOF(xkbGetStateReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

int
ProcXkbLatchLockState(ClientPtr client)
{
    int status;
    DeviceIntPtr dev, tmpd;
    XkbStateRec	oldState,*newState;
    CARD16 changed;
    xkbStateNotify sn;
    XkbEventCauseRec cause;

    REQUEST(xkbLatchLockStateReq);
    REQUEST_SIZE_MATCH(xkbLatchLockStateReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);
    CHK_MASK_MATCH(0x01, stuff->affectModLocks, stuff->modLocks);
    CHK_MASK_MATCH(0x01, stuff->affectModLatches, stuff->modLatches);

    status = Success;

    for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
        if ((tmpd == dev) || (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
            if (!tmpd->key || !tmpd->key->xkbInfo)
                continue;

            oldState = tmpd->key->xkbInfo->state;
            newState = &tmpd->key->xkbInfo->state;
            if (stuff->affectModLocks) {
                newState->locked_mods &= ~stuff->affectModLocks;
                newState->locked_mods |= (stuff->affectModLocks & stuff->modLocks);
            }
            if (status == Success && stuff->lockGroup)
                newState->locked_group = stuff->groupLock;
            if (status == Success && stuff->affectModLatches)
                status = XkbLatchModifiers(tmpd, stuff->affectModLatches,
                                           stuff->modLatches);
            if (status == Success && stuff->latchGroup)
                status = XkbLatchGroup(tmpd, stuff->groupLatch);

            if (status != Success)
                return status;

            XkbComputeDerivedState(tmpd->key->xkbInfo);

            changed = XkbStateChangedFlags(&oldState, newState);
            if (changed) {
                sn.keycode = 0;
                sn.eventType = 0;
                sn.requestMajor = XkbReqCode;
                sn.requestMinor = X_kbLatchLockState;
                sn.changed = changed;
                XkbSendStateNotify(tmpd, &sn);
                changed = XkbIndicatorsToUpdate(tmpd, changed, FALSE);
                if (changed) {
                    XkbSetCauseXkbReq(&cause, X_kbLatchLockState, client);
                    XkbUpdateIndicators(tmpd, changed, TRUE, NULL, &cause);
	        }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetControls(ClientPtr client)
{
    xkbGetControlsReply rep;
    XkbControlsPtr	xkb;
    DeviceIntPtr 	dev;
    register int 	n;

    REQUEST(xkbGetControlsReq);
    REQUEST_SIZE_MATCH(xkbGetControlsReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    
    xkb = dev->key->xkbInfo->desc->ctrls;
    rep.type = X_Reply;
    rep.length = bytes_to_int32(SIZEOF(xkbGetControlsReply)-
		  SIZEOF(xGenericReply));
    rep.sequenceNumber = client->sequence;
    rep.deviceID = ((DeviceIntPtr)dev)->id;
    rep.numGroups = xkb->num_groups;
    rep.groupsWrap = xkb->groups_wrap;
    rep.internalMods = xkb->internal.mask;
    rep.ignoreLockMods = xkb->ignore_lock.mask;
    rep.internalRealMods = xkb->internal.real_mods;
    rep.ignoreLockRealMods = xkb->ignore_lock.real_mods;
    rep.internalVMods = xkb->internal.vmods;
    rep.ignoreLockVMods = xkb->ignore_lock.vmods;
    rep.enabledCtrls = xkb->enabled_ctrls;
    rep.repeatDelay = xkb->repeat_delay;
    rep.repeatInterval = xkb->repeat_interval;
    rep.slowKeysDelay = xkb->slow_keys_delay;
    rep.debounceDelay = xkb->debounce_delay;
    rep.mkDelay = xkb->mk_delay;
    rep.mkInterval = xkb->mk_interval;
    rep.mkTimeToMax = xkb->mk_time_to_max;
    rep.mkMaxSpeed = xkb->mk_max_speed;
    rep.mkCurve = xkb->mk_curve;
    rep.mkDfltBtn = xkb->mk_dflt_btn;
    rep.axTimeout = xkb->ax_timeout;
    rep.axtCtrlsMask = xkb->axt_ctrls_mask;
    rep.axtCtrlsValues = xkb->axt_ctrls_values;
    rep.axtOptsMask = xkb->axt_opts_mask;
    rep.axtOptsValues = xkb->axt_opts_values;
    rep.axOptions = xkb->ax_options;
    memcpy(rep.perKeyRepeat,xkb->per_key_repeat,XkbPerKeyBitArraySize);
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length,n);
	swaps(&rep.internalVMods, n);
	swaps(&rep.ignoreLockVMods, n);
	swapl(&rep.enabledCtrls, n);
	swaps(&rep.repeatDelay, n);
	swaps(&rep.repeatInterval, n);
	swaps(&rep.slowKeysDelay, n);
	swaps(&rep.debounceDelay, n);
	swaps(&rep.mkDelay, n);
	swaps(&rep.mkInterval, n);
	swaps(&rep.mkTimeToMax, n);
	swaps(&rep.mkMaxSpeed, n);
	swaps(&rep.mkCurve, n);
	swaps(&rep.axTimeout, n);
	swapl(&rep.axtCtrlsMask, n);
	swapl(&rep.axtCtrlsValues, n);
	swaps(&rep.axtOptsMask, n);
	swaps(&rep.axtOptsValues, n);
	swaps(&rep.axOptions, n);
    }
    WriteToClient(client, SIZEOF(xkbGetControlsReply), (char *)&rep);
    return Success;
}

int
ProcXkbSetControls(ClientPtr client)
{
    DeviceIntPtr 	dev, tmpd;
    XkbSrvInfoPtr	xkbi;
    XkbControlsPtr	ctrl;
    XkbControlsRec	new,old;
    xkbControlsNotify	cn;
    XkbEventCauseRec	cause;
    XkbSrvLedInfoPtr	sli;

    REQUEST(xkbSetControlsReq);
    REQUEST_SIZE_MATCH(xkbSetControlsReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01, stuff->changeCtrls, XkbAllControlsMask);

    for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
        if (!tmpd->key || !tmpd->key->xkbInfo)
            continue;
        if ((tmpd == dev) || (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
            xkbi = tmpd->key->xkbInfo;
            ctrl = xkbi->desc->ctrls;
            new = *ctrl;
            XkbSetCauseXkbReq(&cause, X_kbSetControls, client);

            if (stuff->changeCtrls & XkbInternalModsMask) {
                CHK_MASK_MATCH(0x02, stuff->affectInternalMods,
                               stuff->internalMods);
                CHK_MASK_MATCH(0x03, stuff->affectInternalVMods,
                               stuff->internalVMods);

                new.internal.real_mods &= ~(stuff->affectInternalMods);
                new.internal.real_mods |= (stuff->affectInternalMods &
                                           stuff->internalMods);
                new.internal.vmods &= ~(stuff->affectInternalVMods);
                new.internal.vmods |= (stuff->affectInternalVMods &
                                       stuff->internalVMods);
                new.internal.mask = new.internal.real_mods |
                                    XkbMaskForVMask(xkbi->desc,
                                                    new.internal.vmods);
            }

            if (stuff->changeCtrls & XkbIgnoreLockModsMask) {
                CHK_MASK_MATCH(0x4, stuff->affectIgnoreLockMods,
                               stuff->ignoreLockMods);
                CHK_MASK_MATCH(0x5, stuff->affectIgnoreLockVMods,
                               stuff->ignoreLockVMods);

                new.ignore_lock.real_mods &= ~(stuff->affectIgnoreLockMods);
                new.ignore_lock.real_mods |= (stuff->affectIgnoreLockMods &
                                              stuff->ignoreLockMods);
                new.ignore_lock.vmods &= ~(stuff->affectIgnoreLockVMods);
                new.ignore_lock.vmods |= (stuff->affectIgnoreLockVMods &
                                          stuff->ignoreLockVMods);
                new.ignore_lock.mask = new.ignore_lock.real_mods |
                                       XkbMaskForVMask(xkbi->desc,
                                                       new.ignore_lock.vmods);
            }

            CHK_MASK_MATCH(0x06, stuff->affectEnabledCtrls,
                           stuff->enabledCtrls);
            if (stuff->affectEnabledCtrls) {
                CHK_MASK_LEGAL(0x07, stuff->affectEnabledCtrls,
                               XkbAllBooleanCtrlsMask);

                new.enabled_ctrls &= ~(stuff->affectEnabledCtrls);
                new.enabled_ctrls |= (stuff->affectEnabledCtrls &
                                      stuff->enabledCtrls);
            }

            if (stuff->changeCtrls & XkbRepeatKeysMask) {
                if (stuff->repeatDelay < 1 || stuff->repeatInterval < 1) {
                    client->errorValue = _XkbErrCode3(0x08, stuff->repeatDelay,
                                                      stuff->repeatInterval);
                    return BadValue;
                }

                new.repeat_delay = stuff->repeatDelay;
                new.repeat_interval = stuff->repeatInterval;
            }

            if (stuff->changeCtrls & XkbSlowKeysMask) {
                if (stuff->slowKeysDelay < 1) {
                    client->errorValue = _XkbErrCode2(0x09,
                                                      stuff->slowKeysDelay);
                    return BadValue;
                }

                new.slow_keys_delay = stuff->slowKeysDelay;
            }

            if (stuff->changeCtrls & XkbBounceKeysMask) {
                if (stuff->debounceDelay < 1) {
                    client->errorValue = _XkbErrCode2(0x0A,
                                                      stuff->debounceDelay);
                    return BadValue;
                }

                new.debounce_delay = stuff->debounceDelay;
            }

            if (stuff->changeCtrls & XkbMouseKeysMask) {
                if (stuff->mkDfltBtn > XkbMaxMouseKeysBtn) {
                    client->errorValue = _XkbErrCode2(0x0B, stuff->mkDfltBtn);
                    return BadValue;
                }

                new.mk_dflt_btn = stuff->mkDfltBtn;
            }

            if (stuff->changeCtrls & XkbMouseKeysAccelMask) {
                if (stuff->mkDelay < 1 || stuff->mkInterval < 1 ||
                    stuff->mkTimeToMax < 1 || stuff->mkMaxSpeed < 1 ||
                    stuff->mkCurve < -1000) {
                    client->errorValue = _XkbErrCode2(0x0C,0);
                    return BadValue;
                }

                new.mk_delay = stuff->mkDelay;
                new.mk_interval = stuff->mkInterval;
                new.mk_time_to_max = stuff->mkTimeToMax;
                new.mk_max_speed = stuff->mkMaxSpeed;
                new.mk_curve = stuff->mkCurve;
                AccessXComputeCurveFactor(xkbi, &new);
            }

            if (stuff->changeCtrls & XkbGroupsWrapMask) {
                unsigned act, num;

                act = XkbOutOfRangeGroupAction(stuff->groupsWrap);
                switch (act) {
                case XkbRedirectIntoRange:
                    num = XkbOutOfRangeGroupNumber(stuff->groupsWrap);
                    if (num >= new.num_groups) {
                        client->errorValue = _XkbErrCode3(0x0D, new.num_groups,
                                                          num);
                        return BadValue;
                    }
                case XkbWrapIntoRange:
                case XkbClampIntoRange:
                    break;
                default:
                    client->errorValue = _XkbErrCode2(0x0E, act);
                    return BadValue;
                }

                new.groups_wrap= stuff->groupsWrap;
            }

            CHK_MASK_LEGAL(0x0F, stuff->axOptions, XkbAX_AllOptionsMask);
            if (stuff->changeCtrls & XkbAccessXKeysMask) {
                new.ax_options = stuff->axOptions & XkbAX_AllOptionsMask;
            }
            else {
                if (stuff->changeCtrls & XkbStickyKeysMask) {
                    new.ax_options &= ~(XkbAX_SKOptionsMask);
                    new.ax_options |= (stuff->axOptions & XkbAX_SKOptionsMask);
                }
            
                if (stuff->changeCtrls & XkbAccessXFeedbackMask) {
                    new.ax_options &= ~(XkbAX_FBOptionsMask);
                    new.ax_options |= (stuff->axOptions & XkbAX_FBOptionsMask);
                }
            }

            if (stuff->changeCtrls & XkbAccessXTimeoutMask) {
                if (stuff->axTimeout < 1) {
                    client->errorValue = _XkbErrCode2(0x10, stuff->axTimeout);
                    return BadValue;
                }
                CHK_MASK_MATCH(0x11, stuff->axtCtrlsMask,
                               stuff->axtCtrlsValues);
                CHK_MASK_LEGAL(0x12, stuff->axtCtrlsMask,
                               XkbAllBooleanCtrlsMask);
                CHK_MASK_MATCH(0x13, stuff->axtOptsMask, stuff->axtOptsValues);
                CHK_MASK_LEGAL(0x14, stuff->axtOptsMask, XkbAX_AllOptionsMask);
                new.ax_timeout = stuff->axTimeout;
                new.axt_ctrls_mask = stuff->axtCtrlsMask;
                new.axt_ctrls_values = (stuff->axtCtrlsValues &
                                        stuff->axtCtrlsMask);
                new.axt_opts_mask = stuff->axtOptsMask;
                new.axt_opts_values = (stuff->axtOptsValues &
                                       stuff->axtOptsMask);
            }

            if (stuff->changeCtrls & XkbPerKeyRepeatMask) {
                memcpy(new.per_key_repeat, stuff->perKeyRepeat,
                       XkbPerKeyBitArraySize);
                if (xkbi->repeatKey &&
                    !BitIsOn(new.per_key_repeat, xkbi->repeatKey)) {
                    AccessXCancelRepeatKey(xkbi, xkbi->repeatKey);
                }
            }

            old= *ctrl;
            *ctrl= new;
            XkbDDXChangeControls(tmpd, &old, ctrl);

            if (XkbComputeControlsNotify(tmpd, &old, ctrl, &cn, FALSE)) {
                cn.keycode = 0;
                cn.eventType = 0;
                cn.requestMajor = XkbReqCode;
                cn.requestMinor = X_kbSetControls;
                XkbSendControlsNotify(tmpd, &cn);
            }

            sli = XkbFindSrvLedInfo(tmpd, XkbDfltXIClass, XkbDfltXIId, 0);
            if (sli)
                XkbUpdateIndicators(tmpd, sli->usesControls, TRUE, NULL,
                                    &cause);

            /* If sticky keys were disabled, clear all locks and latches */
            if ((old.enabled_ctrls & XkbStickyKeysMask) &&
                !(ctrl->enabled_ctrls & XkbStickyKeysMask))
                XkbClearAllLatchesAndLocks(tmpd, xkbi, TRUE, &cause);
        }
    }

    return Success;
}

/***====================================================================***/

static int
XkbSizeKeyTypes(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    XkbKeyTypeRec 	*type;
    unsigned		i,len;

    len= 0;
    if (((rep->present&XkbKeyTypesMask)==0)||(rep->nTypes<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->types)) {
	rep->present&= ~XkbKeyTypesMask;
	rep->firstType= rep->nTypes= 0;
	return 0;
    }
    type= &xkb->map->types[rep->firstType];
    for (i=0;i<rep->nTypes;i++,type++){
	len+= SIZEOF(xkbKeyTypeWireDesc);
	if (type->map_count>0) {
	    len+= (type->map_count*SIZEOF(xkbKTMapEntryWireDesc));
	    if (type->preserve)
		len+= (type->map_count*SIZEOF(xkbModsWireDesc));
	}
    }
    return len;
}

static char *
XkbWriteKeyTypes(	XkbDescPtr		xkb,
			xkbGetMapReply *	rep,
			char *			buf,
			ClientPtr 		client)
{
    XkbKeyTypePtr	type;
    unsigned		i;
    xkbKeyTypeWireDesc *wire;

    type= &xkb->map->types[rep->firstType];
    for (i=0;i<rep->nTypes;i++,type++) {
	register unsigned n;
	wire= (xkbKeyTypeWireDesc *)buf;
	wire->mask = type->mods.mask;
	wire->realMods = type->mods.real_mods;
	wire->virtualMods = type->mods.vmods;
	wire->numLevels = type->num_levels;
	wire->nMapEntries = type->map_count;
	wire->preserve = (type->preserve!=NULL);
	if (client->swapped) {
	    register int n;
	    swaps(&wire->virtualMods,n);
	}	

	buf= (char *)&wire[1];
	if (wire->nMapEntries>0) {
	    xkbKTMapEntryWireDesc *	wire;
	    XkbKTMapEntryPtr		entry;
	    wire= (xkbKTMapEntryWireDesc *)buf;
	    entry= type->map;
	    for (n=0;n<type->map_count;n++,wire++,entry++) {
		wire->active= entry->active;
		wire->mask= entry->mods.mask;
		wire->level= entry->level;
		wire->realMods= entry->mods.real_mods;
		wire->virtualMods= entry->mods.vmods;
		if (client->swapped) {
		    register int n;
		    swaps(&wire->virtualMods,n);
		}
	    }
	    buf= (char *)wire;
	    if (type->preserve!=NULL) {
		xkbModsWireDesc *	pwire;
		XkbModsPtr		preserve;
		pwire= (xkbModsWireDesc *)buf;
		preserve= type->preserve;
		for (n=0;n<type->map_count;n++,pwire++,preserve++) {
		    pwire->mask= preserve->mask;
		    pwire->realMods= preserve->real_mods;
		    pwire->virtualMods= preserve->vmods;
		    if (client->swapped) {
			register int n;
			swaps(&pwire->virtualMods,n);
		    }
		}
		buf= (char *)pwire;
	    }
	}
    }
    return buf;
}

static int
XkbSizeKeySyms(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    XkbSymMapPtr	symMap;
    unsigned		i,len;
    unsigned		nSyms,nSymsThisKey;

    if (((rep->present&XkbKeySymsMask)==0)||(rep->nKeySyms<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->key_sym_map)) {
	rep->present&= ~XkbKeySymsMask;
	rep->firstKeySym= rep->nKeySyms= 0;
	rep->totalSyms= 0;
	return 0;
    }
    len= rep->nKeySyms*SIZEOF(xkbSymMapWireDesc);
    symMap = &xkb->map->key_sym_map[rep->firstKeySym];
    for (i=nSyms=0;i<rep->nKeySyms;i++,symMap++) {
	if (symMap->offset!=0) {
	    nSymsThisKey= XkbNumGroups(symMap->group_info)*symMap->width;
	    nSyms+= nSymsThisKey;
	}
    }
    len+= nSyms*4;
    rep->totalSyms= nSyms;
    return len;
}

static int
XkbSizeVirtualMods(XkbDescPtr xkb,xkbGetMapReply *rep)
{
register unsigned i,nMods,bit;

    if (((rep->present&XkbVirtualModsMask)==0)||(rep->virtualMods==0)||
	(!xkb)||(!xkb->server)) {
	rep->present&= ~XkbVirtualModsMask;
	rep->virtualMods= 0;
	return 0;
    }
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
        if (rep->virtualMods&bit)
	    nMods++;
    }
    return XkbPaddedSize(nMods);
}

static char *
XkbWriteKeySyms(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,ClientPtr client)
{
register KeySym *	pSym;
XkbSymMapPtr		symMap;
xkbSymMapWireDesc *	outMap;
register unsigned	i;

    symMap = &xkb->map->key_sym_map[rep->firstKeySym];
    for (i=0;i<rep->nKeySyms;i++,symMap++) {
	outMap = (xkbSymMapWireDesc *)buf;
	outMap->ktIndex[0] = symMap->kt_index[0];
	outMap->ktIndex[1] = symMap->kt_index[1];
	outMap->ktIndex[2] = symMap->kt_index[2];
	outMap->ktIndex[3] = symMap->kt_index[3];
	outMap->groupInfo = symMap->group_info;
	outMap->width= symMap->width;
	outMap->nSyms = symMap->width*XkbNumGroups(symMap->group_info);
	buf= (char *)&outMap[1];
	if (outMap->nSyms==0)
	    continue;

	pSym = &xkb->map->syms[symMap->offset];
	memcpy((char *)buf,(char *)pSym,outMap->nSyms*4);
	if (client->swapped) {
	    register int n,nSyms= outMap->nSyms;
	    swaps(&outMap->nSyms,n);
	    while (nSyms-->0) {
		swapl(buf,n);
		buf+= 4;
	    }
	}
	else buf+= outMap->nSyms*4;
    }
    return buf;
}

static int
XkbSizeKeyActions(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned		i,len,nActs;
    register KeyCode	firstKey;

    if (((rep->present&XkbKeyActionsMask)==0)||(rep->nKeyActs<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->key_acts)) {
	rep->present&= ~XkbKeyActionsMask;
	rep->firstKeyAct= rep->nKeyActs= 0;
	rep->totalActs= 0;
	return 0;
    }
    firstKey= rep->firstKeyAct;
    for (nActs=i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+firstKey]!=0)
	    nActs+= XkbKeyNumActions(xkb,i+firstKey);
    }
    len= XkbPaddedSize(rep->nKeyActs)+(nActs*SIZEOF(xkbActionWireDesc));
    rep->totalActs= nActs;
    return len;
}

static char *
XkbWriteKeyActions(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
{
    unsigned		i;
    CARD8 *		numDesc;
    XkbAnyAction *	actDesc;

    numDesc = (CARD8 *)buf;
    for (i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+rep->firstKeyAct]==0)
	     numDesc[i] = 0;
	else numDesc[i] = XkbKeyNumActions(xkb,(i+rep->firstKeyAct));
    }
    buf+= XkbPaddedSize(rep->nKeyActs);

    actDesc = (XkbAnyAction *)buf;
    for (i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+rep->firstKeyAct]!=0) {
	    unsigned int num;
	    num = XkbKeyNumActions(xkb,(i+rep->firstKeyAct));
	    memcpy((char *)actDesc,
		   (char*)XkbKeyActionsPtr(xkb,(i+rep->firstKeyAct)),
		   num*SIZEOF(xkbActionWireDesc));
	    actDesc+= num;
	}
    }
    buf = (char *)actDesc;
    return buf;
}

static int
XkbSizeKeyBehaviors(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned		i,len,nBhvr;
    XkbBehavior *	bhv;

    if (((rep->present&XkbKeyBehaviorsMask)==0)||(rep->nKeyBehaviors<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->behaviors)) {
	rep->present&= ~XkbKeyBehaviorsMask;
	rep->firstKeyBehavior= rep->nKeyBehaviors= 0;
	rep->totalKeyBehaviors= 0;
	return 0;
    }
    bhv= &xkb->server->behaviors[rep->firstKeyBehavior];
    for (nBhvr=i=0;i<rep->nKeyBehaviors;i++,bhv++) {
	if (bhv->type!=XkbKB_Default)
	    nBhvr++;
    }
    len= nBhvr*SIZEOF(xkbBehaviorWireDesc);
    rep->totalKeyBehaviors= nBhvr;
    return len;
}

static char *
XkbWriteKeyBehaviors(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
{
    unsigned		i;
    xkbBehaviorWireDesc	*wire;
    XkbBehavior		*pBhvr;

    wire = (xkbBehaviorWireDesc *)buf;
    pBhvr= &xkb->server->behaviors[rep->firstKeyBehavior];
    for (i=0;i<rep->nKeyBehaviors;i++,pBhvr++) {
	if (pBhvr->type!=XkbKB_Default) {
	    wire->key=  i+rep->firstKeyBehavior;
	    wire->type= pBhvr->type;
	    wire->data= pBhvr->data;
	    wire++;
	}
    }
    buf = (char *)wire;
    return buf;
}

static int
XkbSizeExplicit(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned	i,len,nRtrn;

    if (((rep->present&XkbExplicitComponentsMask)==0)||(rep->nKeyExplicit<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->explicit)) {
	rep->present&= ~XkbExplicitComponentsMask;
	rep->firstKeyExplicit= rep->nKeyExplicit= 0;
	rep->totalKeyExplicit= 0;
	return 0;
    }
    for (nRtrn=i=0;i<rep->nKeyExplicit;i++) {
	if (xkb->server->explicit[i+rep->firstKeyExplicit]!=0)
	    nRtrn++;
    }
    rep->totalKeyExplicit= nRtrn;
    len= XkbPaddedSize(nRtrn*2); /* two bytes per non-zero explicit component */
    return len;
}

static char *
XkbWriteExplicit(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,ClientPtr client)
{
unsigned	i;
char *		start;
unsigned char *	pExp;

    start= buf;
    pExp= &xkb->server->explicit[rep->firstKeyExplicit];
    for (i=0;i<rep->nKeyExplicit;i++,pExp++) {
	if (*pExp!=0) {
	    *buf++= i+rep->firstKeyExplicit;
	    *buf++= *pExp;
	}
    }
    i= XkbPaddedSize(buf-start)-(buf-start); /* pad to word boundary */
    return buf+i;
}

static int
XkbSizeModifierMap(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned	i,len,nRtrn;

    if (((rep->present&XkbModifierMapMask)==0)||(rep->nModMapKeys<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->modmap)) {
	rep->present&= ~XkbModifierMapMask;
	rep->firstModMapKey= rep->nModMapKeys= 0;
	rep->totalModMapKeys= 0;
	return 0;
    }
    for (nRtrn=i=0;i<rep->nModMapKeys;i++) {
	if (xkb->map->modmap[i+rep->firstModMapKey]!=0)
	    nRtrn++;
    }
    rep->totalModMapKeys= nRtrn;
    len= XkbPaddedSize(nRtrn*2); /* two bytes per non-zero modmap component */
    return len;
}

static char *
XkbWriteModifierMap(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
{
unsigned	i;
char *		start;
unsigned char *	pMap;

    start= buf;
    pMap= &xkb->map->modmap[rep->firstModMapKey];
    for (i=0;i<rep->nModMapKeys;i++,pMap++) {
	if (*pMap!=0) {
	    *buf++= i+rep->firstModMapKey;
	    *buf++= *pMap;
	}
    }
    i= XkbPaddedSize(buf-start)-(buf-start); /* pad to word boundary */
    return buf+i;
}

static int
XkbSizeVirtualModMap(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned	i,len,nRtrn;

    if (((rep->present&XkbVirtualModMapMask)==0)||(rep->nVModMapKeys<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->vmodmap)) {
	rep->present&= ~XkbVirtualModMapMask;
	rep->firstVModMapKey= rep->nVModMapKeys= 0;
	rep->totalVModMapKeys= 0;
	return 0;
    }
    for (nRtrn=i=0;i<rep->nVModMapKeys;i++) {
	if (xkb->server->vmodmap[i+rep->firstVModMapKey]!=0)
	    nRtrn++;
    }
    rep->totalVModMapKeys= nRtrn;
    len= nRtrn*SIZEOF(xkbVModMapWireDesc);
    return len;
}

static char *
XkbWriteVirtualModMap(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
{
unsigned		i;
xkbVModMapWireDesc *	wire;
unsigned short *	pMap;

    wire= (xkbVModMapWireDesc *)buf;
    pMap= &xkb->server->vmodmap[rep->firstVModMapKey];
    for (i=0;i<rep->nVModMapKeys;i++,pMap++) {
	if (*pMap!=0) {
	    wire->key= i+rep->firstVModMapKey;
	    wire->vmods= *pMap;
	    wire++;
	}
    }
    return (char *)wire;
}

static Status
XkbComputeGetMapReplySize(XkbDescPtr xkb,xkbGetMapReply *rep)
{
int	len;

    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    len= XkbSizeKeyTypes(xkb,rep);
    len+= XkbSizeKeySyms(xkb,rep);
    len+= XkbSizeKeyActions(xkb,rep);
    len+= XkbSizeKeyBehaviors(xkb,rep);
    len+= XkbSizeVirtualMods(xkb,rep);
    len+= XkbSizeExplicit(xkb,rep);
    len+= XkbSizeModifierMap(xkb,rep);
    len+= XkbSizeVirtualModMap(xkb,rep);
    rep->length+= (len/4);
    return Success;
}

static int
XkbSendMap(ClientPtr client,XkbDescPtr xkb,xkbGetMapReply *rep)
{
unsigned	i,len;
char		*desc,*start;

    len= (rep->length*4)-(SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply));
    start= desc= calloc(1, len);
    if (!start)
	return BadAlloc;
    if ( rep->nTypes>0 )
	desc = XkbWriteKeyTypes(xkb,rep,desc,client);
    if ( rep->nKeySyms>0 )
	desc = XkbWriteKeySyms(xkb,rep,desc,client);
    if ( rep->nKeyActs>0 )
	desc = XkbWriteKeyActions(xkb,rep,desc,client);
    if ( rep->totalKeyBehaviors>0 )
	desc = XkbWriteKeyBehaviors(xkb,rep,desc,client);
    if ( rep->virtualMods ) {
	register int sz,bit;
	for (i=sz=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	    if (rep->virtualMods&bit) {
		desc[sz++]= xkb->server->vmods[i];
	    }
	}
	desc+= XkbPaddedSize(sz);
    }
    if ( rep->totalKeyExplicit>0 )
	desc= XkbWriteExplicit(xkb,rep,desc,client);
    if ( rep->totalModMapKeys>0 )
	desc= XkbWriteModifierMap(xkb,rep,desc,client);
    if ( rep->totalVModMapKeys>0 )
	desc= XkbWriteVirtualModMap(xkb,rep,desc,client);
    if ((desc-start)!=(len)) {
	ErrorF("[xkb] BOGUS LENGTH in write keyboard desc, expected %d, got %ld\n",
					len, (unsigned long)(desc-start));
    }
    if (client->swapped) {
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swaps(&rep->present,n);
	swaps(&rep->totalSyms,n);
	swaps(&rep->totalActs,n);
    }
    WriteToClient(client, (i=SIZEOF(xkbGetMapReply)), (char *)rep);
    WriteToClient(client, len, start);
    free((char *)start);
    return Success;
}

int
ProcXkbGetMap(ClientPtr client)
{
    DeviceIntPtr	 dev;
    xkbGetMapReply	 rep;
    XkbDescRec		*xkb;
    int			 n,status;

    REQUEST(xkbGetMapReq);
    REQUEST_SIZE_MATCH(xkbGetMapReq);
    
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_OVERLAP(0x01,stuff->full,stuff->partial);
    CHK_MASK_LEGAL(0x02,stuff->full,XkbAllMapComponentsMask);
    CHK_MASK_LEGAL(0x03,stuff->partial,XkbAllMapComponentsMask);

    xkb= dev->key->xkbInfo->desc;
    memset(&rep, 0, sizeof(xkbGetMapReply));
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
    rep.length = (SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply))>>2;
    rep.deviceID = dev->id;
    rep.present = stuff->partial|stuff->full;
    rep.minKeyCode = xkb->min_key_code;
    rep.maxKeyCode = xkb->max_key_code;
    if ( stuff->full&XkbKeyTypesMask ) {
	rep.firstType = 0;
	rep.nTypes = xkb->map->num_types;
    }
    else if (stuff->partial&XkbKeyTypesMask) {
	if (((unsigned)stuff->firstType+stuff->nTypes)>xkb->map->num_types) {
	    client->errorValue = _XkbErrCode4(0x04,xkb->map->num_types,
					stuff->firstType,stuff->nTypes);
	    return BadValue;
	}
	rep.firstType = stuff->firstType;
	rep.nTypes = stuff->nTypes;
    }
    else rep.nTypes = 0;
    rep.totalTypes = xkb->map->num_types;

    n= XkbNumKeys(xkb);
    if ( stuff->full&XkbKeySymsMask ) {
	rep.firstKeySym = xkb->min_key_code;
	rep.nKeySyms = n;
    }
    else if (stuff->partial&XkbKeySymsMask) {
	CHK_KEY_RANGE(0x05,stuff->firstKeySym,stuff->nKeySyms,xkb);
	rep.firstKeySym = stuff->firstKeySym;
	rep.nKeySyms = stuff->nKeySyms;
    }
    else rep.nKeySyms = 0;
    rep.totalSyms= 0;

    if ( stuff->full&XkbKeyActionsMask ) {
	rep.firstKeyAct= xkb->min_key_code;
	rep.nKeyActs= n;
    }
    else if (stuff->partial&XkbKeyActionsMask) {
	CHK_KEY_RANGE(0x07,stuff->firstKeyAct,stuff->nKeyActs,xkb);
	rep.firstKeyAct= stuff->firstKeyAct;
	rep.nKeyActs= stuff->nKeyActs;
    }
    else rep.nKeyActs= 0;
    rep.totalActs= 0;

    if ( stuff->full&XkbKeyBehaviorsMask ) {
	rep.firstKeyBehavior = xkb->min_key_code;
	rep.nKeyBehaviors = n;
    }
    else if (stuff->partial&XkbKeyBehaviorsMask) {
	CHK_KEY_RANGE(0x09,stuff->firstKeyBehavior,stuff->nKeyBehaviors,xkb);
	rep.firstKeyBehavior= stuff->firstKeyBehavior;
	rep.nKeyBehaviors= stuff->nKeyBehaviors;
    }
    else rep.nKeyBehaviors = 0;
    rep.totalKeyBehaviors= 0;

    if (stuff->full&XkbVirtualModsMask)
	rep.virtualMods= ~0;
    else if (stuff->partial&XkbVirtualModsMask)
	rep.virtualMods= stuff->virtualMods;
    
    if (stuff->full&XkbExplicitComponentsMask) {
	rep.firstKeyExplicit= xkb->min_key_code;
	rep.nKeyExplicit= n;
    }
    else if (stuff->partial&XkbExplicitComponentsMask) {
	CHK_KEY_RANGE(0x0B,stuff->firstKeyExplicit,stuff->nKeyExplicit,xkb);
	rep.firstKeyExplicit= stuff->firstKeyExplicit;
	rep.nKeyExplicit= stuff->nKeyExplicit;
    }
    else rep.nKeyExplicit = 0;
    rep.totalKeyExplicit=  0;

    if (stuff->full&XkbModifierMapMask) {
	rep.firstModMapKey= xkb->min_key_code;
	rep.nModMapKeys= n;
    }
    else if (stuff->partial&XkbModifierMapMask) {
	CHK_KEY_RANGE(0x0D,stuff->firstModMapKey,stuff->nModMapKeys,xkb);
	rep.firstModMapKey= stuff->firstModMapKey;
	rep.nModMapKeys= stuff->nModMapKeys;
    }
    else rep.nModMapKeys = 0;
    rep.totalModMapKeys= 0;

    if (stuff->full&XkbVirtualModMapMask) {
	rep.firstVModMapKey= xkb->min_key_code;
	rep.nVModMapKeys= n;
    }
    else if (stuff->partial&XkbVirtualModMapMask) {
	CHK_KEY_RANGE(0x0F,stuff->firstVModMapKey,stuff->nVModMapKeys,xkb);
	rep.firstVModMapKey= stuff->firstVModMapKey;
	rep.nVModMapKeys= stuff->nVModMapKeys;
    }
    else rep.nVModMapKeys = 0;
    rep.totalVModMapKeys= 0;

    if ((status=XkbComputeGetMapReplySize(xkb,&rep))!=Success)
	return status;
    return XkbSendMap(client,xkb,&rep);
}

/***====================================================================***/

static int
CheckKeyTypes(	ClientPtr	client,
		XkbDescPtr	xkb,
		xkbSetMapReq *	req,
		xkbKeyTypeWireDesc **wireRtrn,
		int	 *	nMapsRtrn,
		CARD8 *		mapWidthRtrn)
{
unsigned		nMaps;
register unsigned	i,n;
register CARD8 *	map;
register xkbKeyTypeWireDesc	*wire = *wireRtrn;

    if (req->firstType>((unsigned)xkb->map->num_types)) {
	*nMapsRtrn = _XkbErrCode3(0x01,req->firstType,xkb->map->num_types);
	return 0;
    }
    if (req->flags&XkbSetMapResizeTypes) {
	nMaps = req->firstType+req->nTypes;
	if (nMaps<XkbNumRequiredTypes) {  /* canonical types must be there */
	    *nMapsRtrn= _XkbErrCode4(0x02,req->firstType,req->nTypes,4);
	    return 0;
	}
    }
    else if (req->present&XkbKeyTypesMask) {
	nMaps = xkb->map->num_types;
	if ((req->firstType+req->nTypes)>nMaps) {
	    *nMapsRtrn = req->firstType+req->nTypes;
	    return 0;
	}
    }
    else {
	*nMapsRtrn = xkb->map->num_types;
	for (i=0;i<xkb->map->num_types;i++) {
	    mapWidthRtrn[i] = xkb->map->types[i].num_levels;
	}
	return 1;
    }

    for (i=0;i<req->firstType;i++) {
	mapWidthRtrn[i] = xkb->map->types[i].num_levels;
    }
    for (i=0;i<req->nTypes;i++) {
	unsigned	width;
	if (client->swapped) {
	    register int s;
	    swaps(&wire->virtualMods,s);
	}
	n= i+req->firstType;
	width= wire->numLevels;
	if (width<1) {
	    *nMapsRtrn= _XkbErrCode3(0x04,n,width);
	    return 0;
	}
	else if ((n==XkbOneLevelIndex)&&(width!=1)) { /* must be width 1 */
	    *nMapsRtrn= _XkbErrCode3(0x05,n,width);
	    return 0;
	}
	else if ((width!=2)&&
		 ((n==XkbTwoLevelIndex)||(n==XkbKeypadIndex)||
		  (n==XkbAlphabeticIndex))) {
	    /* TWO_LEVEL, ALPHABETIC and KEYPAD must be width 2 */
	    *nMapsRtrn= _XkbErrCode3(0x05,n,width);
	    return 0;
	}
	if (wire->nMapEntries>0) {
	    xkbKTSetMapEntryWireDesc *	mapWire;
	    xkbModsWireDesc *		preWire;
	    mapWire= (xkbKTSetMapEntryWireDesc *)&wire[1];
	    preWire= (xkbModsWireDesc *)&mapWire[wire->nMapEntries];
	    for (n=0;n<wire->nMapEntries;n++) {
		if (client->swapped) {
		    register int s;
		    swaps(&mapWire[n].virtualMods,s);
		}
		if (mapWire[n].realMods&(~wire->realMods)) {
		    *nMapsRtrn= _XkbErrCode4(0x06,n,mapWire[n].realMods,
						 wire->realMods);
		    return 0;
		}
		if (mapWire[n].virtualMods&(~wire->virtualMods)) {
		    *nMapsRtrn= _XkbErrCode3(0x07,n,mapWire[n].virtualMods);
		    return 0;
		}
		if (mapWire[n].level>=wire->numLevels) {
		    *nMapsRtrn= _XkbErrCode4(0x08,n,wire->numLevels,
						 mapWire[n].level);
		    return 0;
		}
		if (wire->preserve) {
		    if (client->swapped) {
			register int s;
			swaps(&preWire[n].virtualMods,s);
		    }
		    if (preWire[n].realMods&(~mapWire[n].realMods)) {
			*nMapsRtrn= _XkbErrCode4(0x09,n,preWire[n].realMods,
							mapWire[n].realMods);
			return 0;
		    }
		    if (preWire[n].virtualMods&(~mapWire[n].virtualMods)) {
			*nMapsRtrn=_XkbErrCode3(0x0a,n,preWire[n].virtualMods);
			return 0;
		    }
		}
	    }
	    if (wire->preserve)
		 map= (CARD8 *)&preWire[wire->nMapEntries];
	    else map= (CARD8 *)&mapWire[wire->nMapEntries];
	}
	else map= (CARD8 *)&wire[1];
	mapWidthRtrn[i+req->firstType] = wire->numLevels;
	wire= (xkbKeyTypeWireDesc *)map;
    }
    for (i=req->firstType+req->nTypes;i<nMaps;i++) {
	mapWidthRtrn[i] = xkb->map->types[i].num_levels;
    }
    *nMapsRtrn = nMaps;
    *wireRtrn = wire;
    return 1;
}

static int
CheckKeySyms(	ClientPtr		client,
		XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		int			nTypes,
		CARD8 *	 		mapWidths,
		CARD16 *	 	symsPerKey,
		xkbSymMapWireDesc **	wireRtrn,
		int *			errorRtrn)
{
register unsigned	i;
XkbSymMapPtr		map;
xkbSymMapWireDesc*	wire = *wireRtrn;

    if (!(XkbKeySymsMask&req->present))
	return 1;
    CHK_REQ_KEY_RANGE2(0x11,req->firstKeySym,req->nKeySyms,req,(*errorRtrn),0);
    for (i=0;i<req->nKeySyms;i++) {
	KeySym *pSyms;
	register unsigned nG;
	if (client->swapped) {
	    swaps(&wire->nSyms,nG);
	}
	nG = XkbNumGroups(wire->groupInfo);
	if (nG>XkbNumKbdGroups) {
	    *errorRtrn = _XkbErrCode3(0x14,i+req->firstKeySym,nG);
	    return 0;
	}
	if (nG>0) {
	    register int g,w;
	    for (g=w=0;g<nG;g++) {
		if (wire->ktIndex[g]>=(unsigned)nTypes) {
		    *errorRtrn= _XkbErrCode4(0x15,i+req->firstKeySym,g,
		    					   wire->ktIndex[g]);
		    return 0;
		}
		if (mapWidths[wire->ktIndex[g]]>w)
		    w= mapWidths[wire->ktIndex[g]];
	    }
	    if (wire->width!=w) {
		*errorRtrn= _XkbErrCode3(0x16,i+req->firstKeySym,wire->width);
		return 0;
	    }
	    w*= nG;
	    symsPerKey[i+req->firstKeySym] = w;
	    if (w!=wire->nSyms) {
		*errorRtrn=_XkbErrCode4(0x16,i+req->firstKeySym,wire->nSyms,w);
		return 0;
	    }
	}
	else if (wire->nSyms!=0) {
	    *errorRtrn = _XkbErrCode3(0x17,i+req->firstKeySym,wire->nSyms);
	    return 0;
	}
	pSyms = (KeySym *)&wire[1];
	wire = (xkbSymMapWireDesc *)&pSyms[wire->nSyms];
    }

    map = &xkb->map->key_sym_map[i];
    for (;i<=(unsigned)xkb->max_key_code;i++,map++) {
	register int g,nG,w;
	nG= XkbKeyNumGroups(xkb,i);
	for (w=g=0;g<nG;g++)  {
	    if (map->kt_index[g]>=(unsigned)nTypes) {
		*errorRtrn = _XkbErrCode4(0x18,i,g,map->kt_index[g]);
		return 0;
	    }
	    if (mapWidths[map->kt_index[g]]>w)
		    w= mapWidths[map->kt_index[g]];
	}
	symsPerKey[i] = w*nG;
    }
    *wireRtrn = wire;
    return 1;
}

static int
CheckKeyActions(	XkbDescPtr	xkb,
			xkbSetMapReq *	req,
			int		nTypes,
			CARD8 *		mapWidths,
			CARD16 *	symsPerKey,
			CARD8 **	wireRtrn,
			int *		nActsRtrn)
{
int			 nActs;
CARD8 *			 wire = *wireRtrn;
register unsigned	 i;

    if (!(XkbKeyActionsMask&req->present))
	return 1;
    CHK_REQ_KEY_RANGE2(0x21,req->firstKeyAct,req->nKeyActs,req,(*nActsRtrn),0);
    for (nActs=i=0;i<req->nKeyActs;i++) {
	if (wire[0]!=0) {
	    if (wire[0]==symsPerKey[i+req->firstKeyAct])
		nActs+= wire[0];
	    else {
		*nActsRtrn= _XkbErrCode3(0x23,i+req->firstKeyAct,wire[0]);
		return 0;
	    }
	}
	wire++;
    }
    if (req->nKeyActs%4)
	wire+= 4-(req->nKeyActs%4);
    *wireRtrn = (CARD8 *)(((XkbAnyAction *)wire)+nActs);
    *nActsRtrn = nActs;
    return 1;
}

static int
CheckKeyBehaviors(	XkbDescPtr 		xkb,
			xkbSetMapReq *		req,
			xkbBehaviorWireDesc **	wireRtrn,
			int *			errorRtrn)
{
register xkbBehaviorWireDesc *	wire = *wireRtrn;
register XkbServerMapPtr	server = xkb->server;
register unsigned	 	i;
unsigned			first,last;

    if (((req->present&XkbKeyBehaviorsMask)==0)||(req->nKeyBehaviors<1)) {
	req->present&= ~XkbKeyBehaviorsMask;
	req->nKeyBehaviors= 0;
	return 1;
    }
    first= req->firstKeyBehavior;
    last=  req->firstKeyBehavior+req->nKeyBehaviors-1;
    if (first<req->minKeyCode) {
	*errorRtrn = _XkbErrCode3(0x31,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errorRtrn = _XkbErrCode3(0x32,last,req->maxKeyCode);
	return 0;
    }
	
    for (i=0;i<req->totalKeyBehaviors;i++,wire++) {
	if ((wire->key<first)||(wire->key>last)) {
	    *errorRtrn = _XkbErrCode4(0x33,first,last,wire->key);
	    return 0;
	}
	if ((wire->type&XkbKB_Permanent)&&
	    ((server->behaviors[wire->key].type!=wire->type)||
	     (server->behaviors[wire->key].data!=wire->data))) {
	    *errorRtrn = _XkbErrCode3(0x33,wire->key,wire->type);
	    return 0;
	}
	if ((wire->type==XkbKB_RadioGroup)&&
		((wire->data&(~XkbKB_RGAllowNone))>XkbMaxRadioGroups)) {
	    *errorRtrn= _XkbErrCode4(0x34,wire->key,wire->data,
							XkbMaxRadioGroups);
	    return 0;
	}
	if ((wire->type==XkbKB_Overlay1)||(wire->type==XkbKB_Overlay2)) {
	    CHK_KEY_RANGE2(0x35,wire->key,1,xkb,*errorRtrn,0);
	}
    }
    *wireRtrn = wire;
    return 1;
}

static int
CheckVirtualMods(	XkbDescRec *	xkb,
			xkbSetMapReq *	req,
			CARD8 **	wireRtrn,
			int *		errorRtrn)
{
register CARD8		*wire = *wireRtrn;
register unsigned 	 i,nMods,bit;

    if (((req->present&XkbVirtualModsMask)==0)||(req->virtualMods==0))
	return 1;
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (req->virtualMods&bit)
	    nMods++;
    }
    *wireRtrn= (wire+XkbPaddedSize(nMods));
    return 1;
}

static int
CheckKeyExplicit(	XkbDescPtr	xkb,
			xkbSetMapReq *	req,
			CARD8 **	wireRtrn,
			int	*	errorRtrn)
{
register CARD8 *	wire = *wireRtrn;
CARD8	*		start;
register unsigned 	i;
int			first,last;

    if (((req->present&XkbExplicitComponentsMask)==0)||(req->nKeyExplicit<1)) {
	req->present&= ~XkbExplicitComponentsMask;
	req->nKeyExplicit= 0;
	return 1;
    }
    first= req->firstKeyExplicit;
    last=  first+req->nKeyExplicit-1;
    if (first<req->minKeyCode) {
	*errorRtrn = _XkbErrCode3(0x51,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errorRtrn = _XkbErrCode3(0x52,last,req->maxKeyCode);
	return 0;
    }
    start= wire; 
    for (i=0;i<req->totalKeyExplicit;i++,wire+=2) {
	if ((wire[0]<first)||(wire[0]>last)) {
	    *errorRtrn = _XkbErrCode4(0x53,first,last,wire[0]);
	    return 0;
	}
	if (wire[1]&(~XkbAllExplicitMask)) {
	     *errorRtrn= _XkbErrCode3(0x52,~XkbAllExplicitMask,wire[1]);
	     return 0;
	}
    }
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    *wireRtrn= wire;
    return 1;
}

static int
CheckModifierMap(XkbDescPtr xkb,xkbSetMapReq *req,CARD8 **wireRtrn,int *errRtrn)
{
register CARD8 *	wire = *wireRtrn;
CARD8	*		start;
register unsigned 	i;
int			first,last;

    if (((req->present&XkbModifierMapMask)==0)||(req->nModMapKeys<1)) {
	req->present&= ~XkbModifierMapMask;
	req->nModMapKeys= 0;
	return 1;
    }
    first= req->firstModMapKey;
    last=  first+req->nModMapKeys-1;
    if (first<req->minKeyCode) {
	*errRtrn = _XkbErrCode3(0x61,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errRtrn = _XkbErrCode3(0x62,last,req->maxKeyCode);
	return 0;
    }
    start= wire; 
    for (i=0;i<req->totalModMapKeys;i++,wire+=2) {
	if ((wire[0]<first)||(wire[0]>last)) {
	    *errRtrn = _XkbErrCode4(0x63,first,last,wire[0]);
	    return 0;
	}
    }
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    *wireRtrn= wire;
    return 1;
}

static int
CheckVirtualModMap(	XkbDescPtr xkb,
			xkbSetMapReq *req,
			xkbVModMapWireDesc **wireRtrn,
			int *errRtrn)
{
register xkbVModMapWireDesc *	wire = *wireRtrn;
register unsigned 		i;
int				first,last;

    if (((req->present&XkbVirtualModMapMask)==0)||(req->nVModMapKeys<1)) {
	req->present&= ~XkbVirtualModMapMask;
	req->nVModMapKeys= 0;
	return 1;
    }
    first= req->firstVModMapKey;
    last=  first+req->nVModMapKeys-1;
    if (first<req->minKeyCode) {
	*errRtrn = _XkbErrCode3(0x71,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errRtrn = _XkbErrCode3(0x72,last,req->maxKeyCode);
	return 0;
    }
    for (i=0;i<req->totalVModMapKeys;i++,wire++) {
	if ((wire->key<first)||(wire->key>last)) {
	    *errRtrn = _XkbErrCode4(0x73,first,last,wire->key);
	    return 0;
	}
    }
    *wireRtrn= wire;
    return 1;
}

static char *
SetKeyTypes(	XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		xkbKeyTypeWireDesc *	wire,
		XkbChangesPtr		changes)
{
register unsigned	i;
unsigned		first,last;
CARD8			*map;

    if ((unsigned)(req->firstType+req->nTypes)>xkb->map->size_types) {
	i= req->firstType+req->nTypes;
	if (XkbAllocClientMap(xkb,XkbKeyTypesMask,i)!=Success) {
	    return NULL;
	}
    }
    if ((unsigned)(req->firstType+req->nTypes)>xkb->map->num_types)
	xkb->map->num_types= req->firstType+req->nTypes;

    for (i=0;i<req->nTypes;i++) {
	XkbKeyTypePtr		pOld;
	register unsigned 	n;

	if (XkbResizeKeyType(xkb,i+req->firstType,wire->nMapEntries,
				wire->preserve,wire->numLevels)!=Success) {
	    return NULL;
	}
	pOld = &xkb->map->types[i+req->firstType];
	map = (CARD8 *)&wire[1];

	pOld->mods.real_mods = wire->realMods;
	pOld->mods.vmods= wire->virtualMods;
	pOld->num_levels = wire->numLevels;
	pOld->map_count= wire->nMapEntries;

	pOld->mods.mask= pOld->mods.real_mods|
					XkbMaskForVMask(xkb,pOld->mods.vmods);

	if (wire->nMapEntries) {
	    xkbKTSetMapEntryWireDesc *mapWire;
	    xkbModsWireDesc *preWire;
	    unsigned tmp;
	    mapWire= (xkbKTSetMapEntryWireDesc *)map;
	    preWire= (xkbModsWireDesc *)&mapWire[wire->nMapEntries];
	    for (n=0;n<wire->nMapEntries;n++) {
		pOld->map[n].active= 1;
		pOld->map[n].mods.mask= mapWire[n].realMods;
		pOld->map[n].mods.real_mods= mapWire[n].realMods;
		pOld->map[n].mods.vmods= mapWire[n].virtualMods;
		pOld->map[n].level= mapWire[n].level;
		if (mapWire[n].virtualMods!=0) {
		    tmp= XkbMaskForVMask(xkb,mapWire[n].virtualMods);
		    pOld->map[n].active= (tmp!=0);
		    pOld->map[n].mods.mask|= tmp;
		}
		if (wire->preserve) {
		    pOld->preserve[n].real_mods= preWire[n].realMods;
		    pOld->preserve[n].vmods= preWire[n].virtualMods;
		    tmp= XkbMaskForVMask(xkb,preWire[n].virtualMods);
		    pOld->preserve[n].mask= preWire[n].realMods|tmp;
		}
	    }
	    if (wire->preserve)
		 map= (CARD8 *)&preWire[wire->nMapEntries];
	    else map= (CARD8 *)&mapWire[wire->nMapEntries];
	}
	else map= (CARD8 *)&wire[1];
	wire = (xkbKeyTypeWireDesc *)map;
    }
    first= req->firstType;
    last= first+req->nTypes-1; /* last changed type */
    if (changes->map.changed&XkbKeyTypesMask) {
	int oldLast;
	oldLast= changes->map.first_type+changes->map.num_types-1;
	if (changes->map.first_type<first)
	    first= changes->map.first_type;
	if (oldLast>last)
	    last= oldLast;
    }
    changes->map.changed|= XkbKeyTypesMask;
    changes->map.first_type = first;
    changes->map.num_types = (last-first)+1;
    return (char *)wire;
}

static char *
SetKeySyms(	ClientPtr		client,
		XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		xkbSymMapWireDesc *	wire,
		XkbChangesPtr 		changes,
		DeviceIntPtr		dev)
{
register unsigned 	i,s;
XkbSymMapPtr		oldMap;
KeySym *		newSyms;
KeySym *		pSyms;
unsigned		first,last;

    oldMap = &xkb->map->key_sym_map[req->firstKeySym];
    for (i=0;i<req->nKeySyms;i++,oldMap++) {
	pSyms = (KeySym *)&wire[1];
	if (wire->nSyms>0) {
	    newSyms = XkbResizeKeySyms(xkb,i+req->firstKeySym,wire->nSyms);
	    for (s=0;s<wire->nSyms;s++) {
		newSyms[s]= pSyms[s];
	    }
	    if (client->swapped) {
		int n;
		for (s=0;s<wire->nSyms;s++) {
		    swapl(&newSyms[s],n);
		}
	    }
	}
	oldMap->kt_index[0] = wire->ktIndex[0];
	oldMap->kt_index[1] = wire->ktIndex[1];
	oldMap->kt_index[2] = wire->ktIndex[2];
	oldMap->kt_index[3] = wire->ktIndex[3];
	oldMap->group_info = wire->groupInfo;
	oldMap->width = wire->width;
	wire= (xkbSymMapWireDesc *)&pSyms[wire->nSyms];
    }
    first= req->firstKeySym;
    last= first+req->nKeySyms-1;
    if (changes->map.changed&XkbKeySymsMask) {
	int oldLast= (changes->map.first_key_sym+changes->map.num_key_syms-1);
	if (changes->map.first_key_sym<first)
	    first= changes->map.first_key_sym;
	if (oldLast>last)
	    last= oldLast;
    }
    changes->map.changed|= XkbKeySymsMask;
    changes->map.first_key_sym = first;
    changes->map.num_key_syms = (last-first+1);

    s= 0;
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	if (XkbKeyNumGroups(xkb,i)>s)
	    s= XkbKeyNumGroups(xkb,i);
    }
    if (s!=xkb->ctrls->num_groups) {
	xkbControlsNotify	cn;
	XkbControlsRec		old;
	cn.keycode= 0;
	cn.eventType= 0;
	cn.requestMajor= XkbReqCode;
	cn.requestMinor= X_kbSetMap;
	old= *xkb->ctrls;
	xkb->ctrls->num_groups= s;
	if (XkbComputeControlsNotify(dev,&old,xkb->ctrls,&cn,FALSE))
	    XkbSendControlsNotify(dev,&cn);
    }
    return (char *)wire;
}

static char *
SetKeyActions(	XkbDescPtr	xkb,
		xkbSetMapReq *	req,
		CARD8 *		wire,
		XkbChangesPtr	changes)
{
register unsigned	i,first,last;
CARD8 *			nActs = wire;
XkbAction *		newActs;
    
    wire+= XkbPaddedSize(req->nKeyActs);
    for (i=0;i<req->nKeyActs;i++) {
	if (nActs[i]==0)
	    xkb->server->key_acts[i+req->firstKeyAct]= 0;
	else {
	    newActs= XkbResizeKeyActions(xkb,i+req->firstKeyAct,nActs[i]);
	    memcpy((char *)newActs,(char *)wire,
					nActs[i]*SIZEOF(xkbActionWireDesc));
	    wire+= nActs[i]*SIZEOF(xkbActionWireDesc);
	}
    }
    first= req->firstKeyAct;
    last= (first+req->nKeyActs-1);
    if (changes->map.changed&XkbKeyActionsMask) {
	int oldLast;
	oldLast= changes->map.first_key_act+changes->map.num_key_acts-1;
	if (changes->map.first_key_act<first)
	    first= changes->map.first_key_act;
	if (oldLast>last)
	    last= oldLast;
    }
    changes->map.changed|= XkbKeyActionsMask;
    changes->map.first_key_act= first;
    changes->map.num_key_acts= (last-first+1);
    return (char *)wire;
}

static char *
SetKeyBehaviors(	XkbSrvInfoPtr	 xkbi,
    			xkbSetMapReq	*req,
    			xkbBehaviorWireDesc	*wire,
    			XkbChangesPtr	 changes)
{
register unsigned i;
int maxRG = -1;
XkbDescPtr       xkb = xkbi->desc;
XkbServerMapPtr	 server = xkb->server;
unsigned	 first,last;

    first= req->firstKeyBehavior;
    last= req->firstKeyBehavior+req->nKeyBehaviors-1;
    memset(&server->behaviors[first], 0, req->nKeyBehaviors*sizeof(XkbBehavior));
    for (i=0;i<req->totalKeyBehaviors;i++) {
	if ((server->behaviors[wire->key].type&XkbKB_Permanent)==0) {
	    server->behaviors[wire->key].type= wire->type;
	    server->behaviors[wire->key].data= wire->data;
	    if ((wire->type==XkbKB_RadioGroup)&&(((int)wire->data)>maxRG))
		maxRG= wire->data + 1;
	}
	wire++;
    }

    if (maxRG>(int)xkbi->nRadioGroups) {
        int sz = maxRG*sizeof(XkbRadioGroupRec);
        if (xkbi->radioGroups)
             xkbi->radioGroups= realloc(xkbi->radioGroups,sz);
        else xkbi->radioGroups= calloc(1, sz);
        if (xkbi->radioGroups) {
             if (xkbi->nRadioGroups)
                 memset(&xkbi->radioGroups[xkbi->nRadioGroups], 0,
                        (maxRG-xkbi->nRadioGroups)*sizeof(XkbRadioGroupRec));
             xkbi->nRadioGroups= maxRG;
        }
        else xkbi->nRadioGroups= 0;
        /* should compute members here */
    }
    if (changes->map.changed&XkbKeyBehaviorsMask) {
	unsigned oldLast;
	oldLast= changes->map.first_key_behavior+
					changes->map.num_key_behaviors-1;
        if (changes->map.first_key_behavior<req->firstKeyBehavior)
             first= changes->map.first_key_behavior;
        if (oldLast>last)
            last= oldLast;
    }
    changes->map.changed|= XkbKeyBehaviorsMask;
    changes->map.first_key_behavior = first;
    changes->map.num_key_behaviors = (last-first+1);
    return (char *)wire;
}

static char *
SetVirtualMods(XkbSrvInfoPtr xkbi,xkbSetMapReq *req,CARD8 *wire,
						XkbChangesPtr changes)
{
register int 		i,bit,nMods;
XkbServerMapPtr		srv = xkbi->desc->server;

    if (((req->present&XkbVirtualModsMask)==0)||(req->virtualMods==0))
	return (char *)wire;
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (req->virtualMods&bit) {
	    if (srv->vmods[i]!=wire[nMods]) {
		changes->map.changed|= XkbVirtualModsMask;
		changes->map.vmods|= bit;
		srv->vmods[i]= wire[nMods];
	    }
	    nMods++;
	}
    }
    return (char *)(wire+XkbPaddedSize(nMods));
}

static char *
SetKeyExplicit(XkbSrvInfoPtr xkbi,xkbSetMapReq *req,CARD8 *wire,
							XkbChangesPtr changes)
{
register unsigned	i,first,last;
XkbServerMapPtr		xkb = xkbi->desc->server;
CARD8 *			start;

    start= wire;
    first= req->firstKeyExplicit;
    last=  req->firstKeyExplicit+req->nKeyExplicit-1;
    memset(&xkb->explicit[first], 0, req->nKeyExplicit);
    for (i=0;i<req->totalKeyExplicit;i++,wire+= 2) {
	xkb->explicit[wire[0]]= wire[1];
    }
    if (first>0) {
	if (changes->map.changed&XkbExplicitComponentsMask) {
	    int oldLast;
	    oldLast= changes->map.first_key_explicit+
					changes->map.num_key_explicit-1;
	    if (changes->map.first_key_explicit<first)
		first= changes->map.first_key_explicit;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_key_explicit= first;
	changes->map.num_key_explicit= (last-first)+1;
    }
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    return (char *)wire;
}

static char *
SetModifierMap(	XkbSrvInfoPtr	xkbi,
		xkbSetMapReq *	req,
		CARD8 *		wire,
		XkbChangesPtr	changes)
{
register unsigned	i,first,last;
XkbClientMapPtr		xkb = xkbi->desc->map;
CARD8 *			start;

    start= wire;
    first= req->firstModMapKey;
    last=  req->firstModMapKey+req->nModMapKeys-1;
    memset(&xkb->modmap[first], 0, req->nModMapKeys);
    for (i=0;i<req->totalModMapKeys;i++,wire+= 2) {
	xkb->modmap[wire[0]]= wire[1];
    }
    if (first>0) {
	if (changes->map.changed&XkbModifierMapMask) {
	    int oldLast;
	    oldLast= changes->map.first_modmap_key+
						changes->map.num_modmap_keys-1;
	    if (changes->map.first_modmap_key<first)
		first= changes->map.first_modmap_key;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_modmap_key= first;
	changes->map.num_modmap_keys= (last-first)+1;
    }
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    return (char *)wire;
}

static char *
SetVirtualModMap(	XkbSrvInfoPtr		xkbi,
			xkbSetMapReq *		req,
			xkbVModMapWireDesc *	wire,
			XkbChangesPtr 		changes)
{
register unsigned	i,first,last;
XkbServerMapPtr		srv = xkbi->desc->server;

    first= req->firstVModMapKey;
    last=  req->firstVModMapKey+req->nVModMapKeys-1;
    memset(&srv->vmodmap[first], 0, req->nVModMapKeys*sizeof(unsigned short));
    for (i=0;i<req->totalVModMapKeys;i++,wire++) {
	srv->vmodmap[wire->key]= wire->vmods;
    }
    if (first>0) {
	if (changes->map.changed&XkbVirtualModMapMask) {
	    int oldLast;
	    oldLast= changes->map.first_vmodmap_key+
					changes->map.num_vmodmap_keys-1;
	    if (changes->map.first_vmodmap_key<first)
		first= changes->map.first_vmodmap_key;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_vmodmap_key= first;
	changes->map.num_vmodmap_keys= (last-first)+1;
    }
    return (char *)wire;
}

/**
 * Check if the given request can be applied to the given device but don't
 * actually do anything..
 */
static int
_XkbSetMapChecks(ClientPtr client, DeviceIntPtr dev, xkbSetMapReq *req, char* values)
{
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;
    int                 error;
    int                 nTypes = 0, nActions;
    CARD8               mapWidths[XkbMaxLegalKeyCode + 1] = {0};
    CARD16              symsPerKey[XkbMaxLegalKeyCode + 1] = {0};
    XkbSymMapPtr        map;
    int                 i;

    xkbi= dev->key->xkbInfo;
    xkb = xkbi->desc;

    if ((xkb->min_key_code != req->minKeyCode)||
        (xkb->max_key_code != req->maxKeyCode)) {
	if (client->vMajor!=1) { /* pre 1.0 versions of Xlib have a bug */
	    req->minKeyCode= xkb->min_key_code;
	    req->maxKeyCode= xkb->max_key_code;
	}
	else {
	    if (!XkbIsLegalKeycode(req->minKeyCode)) {
		client->errorValue = _XkbErrCode3(2, req->minKeyCode, req->maxKeyCode);
		return BadValue;
	    }
	    if (req->minKeyCode > req->maxKeyCode) {
		client->errorValue = _XkbErrCode3(3, req->minKeyCode, req->maxKeyCode);
		return BadMatch;
	    }
	}
    }

    if ((req->present & XkbKeyTypesMask) &&
	(!CheckKeyTypes(client,xkb,req,(xkbKeyTypeWireDesc **)&values,
						&nTypes,mapWidths))) {
	client->errorValue = nTypes;
	return BadValue;
    }

    /* symsPerKey/mapWidths must be filled regardless of client-side flags */
    map = &xkb->map->key_sym_map[xkb->min_key_code];
    for (i=xkb->min_key_code;i<xkb->max_key_code;i++,map++) {
	register int g,ng,w;
	ng= XkbNumGroups(map->group_info);
	for (w=g=0;g<ng;g++) {
	    if (map->kt_index[g]>=(unsigned)nTypes) {
		client->errorValue = _XkbErrCode4(0x13,i,g,map->kt_index[g]);
		return 0;
	    }
	    if (mapWidths[map->kt_index[g]]>w)
		w= mapWidths[map->kt_index[g]];
	}
	symsPerKey[i] = w*ng;
    }

    if ((req->present & XkbKeySymsMask) &&
	(!CheckKeySyms(client,xkb,req,nTypes,mapWidths,symsPerKey,
					(xkbSymMapWireDesc **)&values,&error))) {
	client->errorValue = error;
	return BadValue;
    }

    if ((req->present & XkbKeyActionsMask) &&
	(!CheckKeyActions(xkb,req,nTypes,mapWidths,symsPerKey,
						(CARD8 **)&values,&nActions))) {
	client->errorValue = nActions;
	return BadValue;
    }

    if ((req->present & XkbKeyBehaviorsMask) &&
	(!CheckKeyBehaviors(xkb,req,(xkbBehaviorWireDesc**)&values,&error))) {
	client->errorValue = error;
	return BadValue;
    }

    if ((req->present & XkbVirtualModsMask) &&
	(!CheckVirtualMods(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbExplicitComponentsMask) &&
	(!CheckKeyExplicit(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbModifierMapMask) &&
	(!CheckModifierMap(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbVirtualModMapMask) &&
	(!CheckVirtualModMap(xkb,req,(xkbVModMapWireDesc **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }

    if (((values-((char *)req))/4)!= req->length) {
	ErrorF("[xkb] Internal error! Bad length in XkbSetMap (after check)\n");
	client->errorValue = values-((char *)&req[1]);
	return BadLength;
    }

    return Success;
}

/**
 * Apply the given request on the given device.
 */
static int
_XkbSetMap(ClientPtr client, DeviceIntPtr dev, xkbSetMapReq *req, char *values)
{
    XkbEventCauseRec	cause;
    XkbChangesRec	change;
    Bool		sentNKN;
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;

    xkbi= dev->key->xkbInfo;
    xkb = xkbi->desc;

    XkbSetCauseXkbReq(&cause,X_kbSetMap,client);
    memset(&change, 0, sizeof(change));
    sentNKN = FALSE;
    if ((xkb->min_key_code!=req->minKeyCode)||
        (xkb->max_key_code!=req->maxKeyCode)) {
	Status			status;
	xkbNewKeyboardNotify	nkn;
	nkn.deviceID = nkn.oldDeviceID = dev->id;
	nkn.oldMinKeyCode = xkb->min_key_code;
	nkn.oldMaxKeyCode = xkb->max_key_code;
	status= XkbChangeKeycodeRange(xkb, req->minKeyCode,
                                      req->maxKeyCode, &change);
	if (status != Success)
	    return status; /* oh-oh. what about the other keyboards? */
	nkn.minKeyCode = xkb->min_key_code;
	nkn.maxKeyCode = xkb->max_key_code;
	nkn.requestMajor = XkbReqCode;
	nkn.requestMinor = X_kbSetMap;
	nkn.changed = XkbNKN_KeycodesMask;
	XkbSendNewKeyboardNotify(dev,&nkn);
	sentNKN = TRUE;
    }

    if (req->present&XkbKeyTypesMask) {
	values = SetKeyTypes(xkb,req,(xkbKeyTypeWireDesc *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeySymsMask) {
	values = SetKeySyms(client,xkb,req,(xkbSymMapWireDesc *)values,&change,dev);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeyActionsMask) {
	values = SetKeyActions(xkb,req,(CARD8 *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeyBehaviorsMask) {
	values= SetKeyBehaviors(xkbi,req,(xkbBehaviorWireDesc *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbVirtualModsMask)
	values= SetVirtualMods(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbExplicitComponentsMask)
	values= SetKeyExplicit(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbModifierMapMask)
	values= SetModifierMap(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbVirtualModMapMask)
	values= SetVirtualModMap(xkbi,req,(xkbVModMapWireDesc *)values,&change);
    if (((values-((char *)req))/4)!=req->length) {
	ErrorF("[xkb] Internal error! Bad length in XkbSetMap (after set)\n");
	client->errorValue = values-((char *)&req[1]);
	return BadLength;
    }
    if (req->flags&XkbSetMapRecomputeActions) {
	KeyCode		first,last,firstMM,lastMM;
	if (change.map.num_key_syms>0) {
	    first= change.map.first_key_sym;
	    last= first+change.map.num_key_syms-1;
	}
	else first= last= 0;
	if (change.map.num_modmap_keys>0) {
	    firstMM= change.map.first_modmap_key;
	    lastMM= first+change.map.num_modmap_keys-1;
	}
	else firstMM= lastMM= 0;
	if ((last>0) && (lastMM>0)) {
	    if (firstMM<first)
		first= firstMM;
	    if (lastMM>last)
		last= lastMM;
	}
	else if (lastMM>0) {
	    first= firstMM;
	    last= lastMM;
	}
	if (last>0) {
	    unsigned check= 0;
	    XkbUpdateActions(dev,first,(last-first+1),&change,&check,&cause);
	    if (check)
		XkbCheckSecondaryEffects(xkbi,check,&change,&cause);
	}
    }
    if (!sentNKN)
	XkbSendNotification(dev,&change,&cause);

    return Success;
allocFailure:
    return BadAlloc;
}


int
ProcXkbSetMap(ClientPtr client)
{
    DeviceIntPtr	dev;
    char *		tmp;
    int                 rc;

    REQUEST(xkbSetMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01,stuff->present,XkbAllMapComponentsMask);

    tmp = (char *)&stuff[1];

    /* Check if we can to the SetMap on the requested device. If this
       succeeds, do the same thing for all extension devices (if needed).
       If any of them fails, fail.  */
    rc = _XkbSetMapChecks(client, dev, stuff, tmp);

    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetMapChecks(client, other, stuff, tmp);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* We know now that we will succed with the SetMap. In theory anyway. */
    rc = _XkbSetMap(client, dev, stuff, tmp);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                    _XkbSetMap(client, other, stuff, tmp);
                /* ignore rc. if the SetMap failed although the check above
                   reported true there isn't much we can do. we still need to
                   set all other devices, hoping that at least they stay in
                   sync. */
            }
        }
    }

    return Success;
}

/***====================================================================***/

static Status
XkbComputeGetCompatMapReplySize(	XkbCompatMapPtr 	compat,
					xkbGetCompatMapReply *	rep)
{
unsigned	 size,nGroups;

    nGroups= 0;
    if (rep->groups!=0) {
	register int i,bit;
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    if (rep->groups&bit)
		nGroups++;
	}
    }
    size= nGroups*SIZEOF(xkbModsWireDesc);
    size+= (rep->nSI*SIZEOF(xkbSymInterpretWireDesc));
    rep->length= size/4;
    return Success;
}

static int
XkbSendCompatMap(	ClientPtr 		client,
			XkbCompatMapPtr 	compat,
			xkbGetCompatMapReply *	rep)
{
char	*	data;
int		size;

    size= rep->length*4;
    if (size>0) {
	data = malloc(size);
	if (data) {
	    register unsigned i,bit;
	    xkbModsWireDesc *	grp;
	    XkbSymInterpretPtr	sym= &compat->sym_interpret[rep->firstSI];
	    xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *)data;
	    for (i=0;i<rep->nSI;i++,sym++,wire++) {
		wire->sym= sym->sym;
		wire->mods= sym->mods;
		wire->match= sym->match;
		wire->virtualMod= sym->virtual_mod;
		wire->flags= sym->flags;
		memcpy((char*)&wire->act,(char*)&sym->act,sz_xkbActionWireDesc);
		if (client->swapped) {
		    register int n;
		    swapl(&wire->sym,n);
		}
	    }
	    if (rep->groups) {
		grp = (xkbModsWireDesc *)wire;
		for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		    if (rep->groups&bit) {
			grp->mask= compat->groups[i].mask;
			grp->realMods= compat->groups[i].real_mods;
			grp->virtualMods= compat->groups[i].vmods;
			if (client->swapped) {
			    register int n;
			    swaps(&grp->virtualMods,n);
			}
			grp++;
		    }
		}
		wire= (xkbSymInterpretWireDesc*)grp;
	    }
	}
	else return BadAlloc;
    }
    else data= NULL;

    if (client->swapped) {
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swaps(&rep->firstSI,n);
	swaps(&rep->nSI,n);
	swaps(&rep->nTotalSI,n);
    }

    WriteToClient(client, SIZEOF(xkbGetCompatMapReply), (char *)rep);
    if (data) {
	WriteToClient(client, size, data);
	free((char *)data);
    }
    return Success;
}

int
ProcXkbGetCompatMap(ClientPtr client)
{
    xkbGetCompatMapReply 	rep;
    DeviceIntPtr 		dev;
    XkbDescPtr			xkb;
    XkbCompatMapPtr		compat;

    REQUEST(xkbGetCompatMapReq);
    REQUEST_SIZE_MATCH(xkbGetCompatMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb = dev->key->xkbInfo->desc;
    compat= xkb->compat;

    rep.type = X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.firstSI = stuff->firstSI;
    rep.nSI = stuff->nSI;
    if (stuff->getAllSI) {
	rep.firstSI = 0;
	rep.nSI = compat->num_si;
    }
    else if ((((unsigned)stuff->nSI)>0)&&
		((unsigned)(stuff->firstSI+stuff->nSI-1)>=compat->num_si)) {
	client->errorValue = _XkbErrCode2(0x05,compat->num_si);
	return BadValue;
    }
    rep.nTotalSI = compat->num_si;
    rep.groups= stuff->groups;
    XkbComputeGetCompatMapReplySize(compat,&rep);
    return XkbSendCompatMap(client,compat,&rep);
}

/**
 * Apply the given request on the given device.
 * If dryRun is TRUE, then value checks are performed, but the device isn't
 * modified.
 */
static int
_XkbSetCompatMap(ClientPtr client, DeviceIntPtr dev,
                 xkbSetCompatMapReq *req, char* data, BOOL dryRun)
{
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;
    XkbCompatMapPtr     compat;
    int                 nGroups;
    unsigned            i,bit;

    xkbi = dev->key->xkbInfo;
    xkb = xkbi->desc;
    compat = xkb->compat;

    if ((req->nSI>0)||(req->truncateSI)) {
	xkbSymInterpretWireDesc *wire;
	if (req->firstSI>compat->num_si) {
	    client->errorValue = _XkbErrCode2(0x02,compat->num_si);
	    return BadValue;
	}
	wire= (xkbSymInterpretWireDesc *)data;
	wire+= req->nSI;
	data = (char *)wire;
    }

    nGroups= 0;
    if (req->groups!=0) {
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    if ( req->groups&bit )
		nGroups++;
	}
    }
    data+= nGroups*SIZEOF(xkbModsWireDesc);
    if (((data-((char *)req))/4)!=req->length) {
	return BadLength;
    }

    /* Done all the checks we can do */
    if (dryRun)
        return Success;

    data = (char *)&req[1];
    if (req->nSI>0) {
	xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *)data;
	XkbSymInterpretPtr	sym;
	unsigned int		skipped = 0;
	if ((unsigned)(req->firstSI+req->nSI)>compat->num_si) {
	    compat->num_si= req->firstSI+req->nSI;
	    compat->sym_interpret= realloc(compat->sym_interpret,
					    compat->num_si * sizeof(XkbSymInterpretRec));
	    if (!compat->sym_interpret) {
		compat->num_si= 0;
		return BadAlloc;
	    }
	}
	else if (req->truncateSI) {
	    compat->num_si = req->firstSI+req->nSI;
	}
	sym = &compat->sym_interpret[req->firstSI];
	for (i=0;i<req->nSI;i++,wire++) {
	    if (client->swapped) {
		int n;
		swapl(&wire->sym,n);
	    }
	    if (wire->sym == NoSymbol && wire->match == XkbSI_AnyOfOrNone &&
		(wire->mods & 0xff) == 0xff &&
		wire->act.type == XkbSA_XFree86Private) {
		ErrorF("XKB: Skipping broken Any+AnyOfOrNone(All) -> Private "
		       "action from client\n");
		skipped++;
		continue;
	    }
	    sym->sym= wire->sym;
	    sym->mods= wire->mods;
	    sym->match= wire->match;
	    sym->flags= wire->flags;
	    sym->virtual_mod= wire->virtualMod;
	    memcpy((char *)&sym->act,(char *)&wire->act,
                   SIZEOF(xkbActionWireDesc));
            sym++;
	}
	if (skipped) {
	    if (req->firstSI + req->nSI < compat->num_si)
		memmove(sym, sym + skipped,
	                (compat->num_si - req->firstSI - req->nSI) *
			 sizeof(*sym));
	    compat->num_si -= skipped;
	}
	data = (char *)wire;
    }
    else if (req->truncateSI) {
	compat->num_si = req->firstSI;
    }

    if (req->groups!=0) {
	unsigned i, bit;
	xkbModsWireDesc *wire = (xkbModsWireDesc *)data;
	for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
	    if (req->groups & bit) {
		if (client->swapped) {
		    int n;
		    swaps(&wire->virtualMods,n);
		}
		compat->groups[i].mask= wire->realMods;
		compat->groups[i].real_mods= wire->realMods;
		compat->groups[i].vmods= wire->virtualMods;
		if (wire->virtualMods!=0) {
		    unsigned tmp;
		    tmp= XkbMaskForVMask(xkb,wire->virtualMods);
		    compat->groups[i].mask|= tmp;
		}
		data+= SIZEOF(xkbModsWireDesc);
		wire= (xkbModsWireDesc *)data;
	    }
	}
    }
    i= XkbPaddedSize((data-((char *)req)));
    if ((i/4)!=req->length) {
	ErrorF("[xkb] Internal length error on read in _XkbSetCompatMap\n");
	return BadLength;
    }

    if (dev->xkb_interest) {
	xkbCompatMapNotify ev;
	ev.deviceID = dev->id;
	ev.changedGroups = req->groups;
	ev.firstSI = req->firstSI;
	ev.nSI = req->nSI;
	ev.nTotalSI = compat->num_si;
	XkbSendCompatMapNotify(dev,&ev);
    }

    if (req->recomputeActions) {
	XkbChangesRec		change;
	unsigned		check;
	XkbEventCauseRec	cause;

	XkbSetCauseXkbReq(&cause,X_kbSetCompatMap,client);
	memset(&change, 0, sizeof(XkbChangesRec));
	XkbUpdateActions(dev,xkb->min_key_code,XkbNumKeys(xkb),&change,&check,
									&cause);
	if (check)
	    XkbCheckSecondaryEffects(xkbi,check,&change,&cause);
	XkbSendNotification(dev,&change,&cause);
    }
    return Success;
}

int
ProcXkbSetCompatMap(ClientPtr client)
{
    DeviceIntPtr        dev;
    char                *data;
    int                 rc;

    REQUEST(xkbSetCompatMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetCompatMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);

    data = (char *)&stuff[1];

    /* check first using a dry-run */
    rc = _XkbSetCompatMap(client, dev, stuff, data, TRUE);
    if (rc != Success)
        return rc;
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    /* dry-run */
                    rc = _XkbSetCompatMap(client, other, stuff, data, TRUE);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* Yay, the dry-runs succeed. Let's apply */
    rc = _XkbSetCompatMap(client, dev, stuff, data, FALSE);
    if (rc != Success)
        return rc;
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetCompatMap(client, other, stuff, data, FALSE);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetIndicatorState(ClientPtr client)
{
    xkbGetIndicatorStateReply 	rep;
    XkbSrvLedInfoPtr		sli;
    DeviceIntPtr 		dev;
    register int 		i;

    REQUEST(xkbGetIndicatorStateReq);
    REQUEST_SIZE_MATCH(xkbGetIndicatorStateReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixReadAccess);

    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,
						XkbXI_IndicatorStateMask);
    if (!sli)
	return BadAlloc;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.state = sli->effectiveState;

    if (client->swapped) {
	swaps(&rep.sequenceNumber,i);
	swapl(&rep.state,i);
    }
    WriteToClient(client, SIZEOF(xkbGetIndicatorStateReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

static Status
XkbComputeGetIndicatorMapReplySize(
    XkbIndicatorPtr		indicators,
    xkbGetIndicatorMapReply	*rep)
{
register int 	i,bit;
int		nIndicators;

    rep->realIndicators = indicators->phys_indicators;
    for (i=nIndicators=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (rep->which&bit)
	    nIndicators++;
    }
    rep->length = (nIndicators*SIZEOF(xkbIndicatorMapWireDesc))/4;
    return Success;
}

static int
XkbSendIndicatorMap(	ClientPtr			client,
			XkbIndicatorPtr			indicators,
			xkbGetIndicatorMapReply *	rep)
{
int 			length;
CARD8 *			map;
register int		i;
register unsigned	bit;

    length = rep->length*4;
    if (length>0) {
	CARD8 *to;
	to= map= malloc(length);
	if (map) {
	    xkbIndicatorMapWireDesc  *wire = (xkbIndicatorMapWireDesc *)to;
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		if (rep->which&bit) {
		    wire->flags= indicators->maps[i].flags;
		    wire->whichGroups= indicators->maps[i].which_groups;
		    wire->groups= indicators->maps[i].groups;
		    wire->whichMods= indicators->maps[i].which_mods;
		    wire->mods= indicators->maps[i].mods.mask;
		    wire->realMods= indicators->maps[i].mods.real_mods;
		    wire->virtualMods= indicators->maps[i].mods.vmods;
		    wire->ctrls= indicators->maps[i].ctrls;
		    if (client->swapped) {
			register int n;
			swaps(&wire->virtualMods,n);
			swapl(&wire->ctrls,n);
		    }
		    wire++;
		}
	    }
	    to = (CARD8 *)wire;
	    if ((to-map)!=length) {
		client->errorValue = _XkbErrCode2(0xff,length);
		free(map);
		return BadLength;
	    }
	}
	else return BadAlloc;
    }
    else map = NULL;
    if (client->swapped) {
	swaps(&rep->sequenceNumber,i);
	swapl(&rep->length,i);
	swapl(&rep->which,i);
	swapl(&rep->realIndicators,i);
    }
    WriteToClient(client, SIZEOF(xkbGetIndicatorMapReply), (char *)rep);
    if (map) {
	WriteToClient(client, length, (char *)map);
	free((char *)map);
    }
    return Success;
}

int
ProcXkbGetIndicatorMap(ClientPtr client)
{
xkbGetIndicatorMapReply rep;
DeviceIntPtr		dev;
XkbDescPtr		xkb;
XkbIndicatorPtr		leds;

    REQUEST(xkbGetIndicatorMapReq);
    REQUEST_SIZE_MATCH(xkbGetIndicatorMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb= dev->key->xkbInfo->desc;
    leds= xkb->indicators;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.which = stuff->which;
    XkbComputeGetIndicatorMapReplySize(leds,&rep);
    return XkbSendIndicatorMap(client,leds,&rep);
}

/**
 * Apply the given map to the given device. Which specifies which components
 * to apply.
 */
static int
_XkbSetIndicatorMap(ClientPtr client, DeviceIntPtr dev,
                    int which, xkbIndicatorMapWireDesc *desc)
{
    XkbSrvInfoPtr       xkbi;
    XkbSrvLedInfoPtr    sli;
    XkbEventCauseRec    cause;
    int                 i, bit;

    xkbi = dev->key->xkbInfo;

    sli= XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId,
						XkbXI_IndicatorMapsMask);
    if (!sli)
	return BadAlloc;

    for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
	if (which & bit) {
	    sli->maps[i].flags = desc->flags;
	    sli->maps[i].which_groups = desc->whichGroups;
	    sli->maps[i].groups = desc->groups;
	    sli->maps[i].which_mods = desc->whichMods;
	    sli->maps[i].mods.mask = desc->mods;
	    sli->maps[i].mods.real_mods = desc->mods;
	    sli->maps[i].mods.vmods= desc->virtualMods;
	    sli->maps[i].ctrls = desc->ctrls;
	    if (desc->virtualMods!=0) {
		unsigned tmp;
		tmp= XkbMaskForVMask(xkbi->desc,desc->virtualMods);
		sli->maps[i].mods.mask= desc->mods|tmp;
	    }
	    desc++;
	}
    }

    XkbSetCauseXkbReq(&cause,X_kbSetIndicatorMap,client);
    XkbApplyLedMapChanges(dev,sli,which,NULL,NULL,&cause);

    return Success;
}

int
ProcXkbSetIndicatorMap(ClientPtr client)
{
    int                 i, bit;
    int                 nIndicators;
    DeviceIntPtr        dev;
    xkbIndicatorMapWireDesc     *from;
    int                 rc;

    REQUEST(xkbSetIndicatorMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetIndicatorMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);

    if (stuff->which==0)
	return Success;

    for (nIndicators=i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (stuff->which&bit)
	    nIndicators++;
    }
    if (stuff->length!=((SIZEOF(xkbSetIndicatorMapReq)+
			(nIndicators*SIZEOF(xkbIndicatorMapWireDesc)))/4)) {
	return BadLength;
    }

    from = (xkbIndicatorMapWireDesc *)&stuff[1];
    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (stuff->which&bit) {
	    if (client->swapped) {
		int n;
		swaps(&from->virtualMods,n);
		swapl(&from->ctrls,n);
	    }
	    CHK_MASK_LEGAL(i,from->whichGroups,XkbIM_UseAnyGroup);
	    CHK_MASK_LEGAL(i,from->whichMods,XkbIM_UseAnyMods);
	    from++;
	}
    }

    from = (xkbIndicatorMapWireDesc *)&stuff[1];
    rc = _XkbSetIndicatorMap(client, dev, stuff->which, from);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess);
                if (rc == Success)
                    _XkbSetIndicatorMap(client, other, stuff->which, from);
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetNamedIndicator(ClientPtr client)
{
    DeviceIntPtr 		dev;
    xkbGetNamedIndicatorReply 	rep;
    register int		i = 0;
    XkbSrvLedInfoPtr		sli;
    XkbIndicatorMapPtr		map = NULL;

    REQUEST(xkbGetNamedIndicatorReq);
    REQUEST_SIZE_MATCH(xkbGetNamedIndicatorReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_LED_DEVICE(dev, stuff->deviceSpec, client, DixReadAccess);
    CHK_ATOM_ONLY(stuff->indicator);

    sli= XkbFindSrvLedInfo(dev,stuff->ledClass,stuff->ledID,0);
    if (!sli)
	return BadAlloc;

    i= 0;
    map= NULL;
    if ((sli->names)&&(sli->maps)) {
        for (i=0;i<XkbNumIndicators;i++) {
            if (stuff->indicator==sli->names[i]) {
                map= &sli->maps[i];
                break;
            }
        }
    }

    rep.type= X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.deviceID = dev->id;
    rep.indicator= stuff->indicator;
    if (map!=NULL) {
	rep.found= 		TRUE;
	rep.on=			((sli->effectiveState&(1<<i))!=0);
	rep.realIndicator=	((sli->physIndicators&(1<<i))!=0);
	rep.ndx= 		i;
	rep.flags= 		map->flags;
	rep.whichGroups= 	map->which_groups;
	rep.groups= 		map->groups;
	rep.whichMods= 		map->which_mods;
	rep.mods= 		map->mods.mask;
	rep.realMods= 		map->mods.real_mods;
	rep.virtualMods= 	map->mods.vmods;
	rep.ctrls= 		map->ctrls;
	rep.supported= 		TRUE;
    }
    else  {
	rep.found= 		FALSE;
	rep.on= 		FALSE;
	rep.realIndicator= 	FALSE;
	rep.ndx= 		XkbNoIndicator;
	rep.flags= 		0;
	rep.whichGroups= 	0;
	rep.groups= 		0;
	rep.whichMods= 		0;
	rep.mods=		0;
	rep.realMods= 		0;
	rep.virtualMods= 	0;
	rep.ctrls= 		0;
	rep.supported= 		TRUE;
    }
    if ( client->swapped ) {
	register int n;
	swapl(&rep.length,n);
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.indicator,n);
	swaps(&rep.virtualMods,n);
	swapl(&rep.ctrls,n);
    }

    WriteToClient(client,SIZEOF(xkbGetNamedIndicatorReply), (char *)&rep);
    return Success;
}


/**
 * Find the IM on the device.
 * Returns the map, or NULL if the map doesn't exist.
 * If the return value is NULL, led_return is undefined. Otherwise, led_return
 * is set to the led index of the map.
 */
static XkbIndicatorMapPtr
_XkbFindNamedIndicatorMap(XkbSrvLedInfoPtr sli, Atom indicator,
                          int *led_return)
{
    XkbIndicatorMapPtr  map;

    /* search for the right indicator */
    map = NULL;
    if (sli->names && sli->maps) {
	int led;

	for (led = 0; (led < XkbNumIndicators) && (map == NULL); led++) {
	    if (sli->names[led] == indicator) {
		map= &sli->maps[led];
		*led_return = led;
		break;
	    }
	}
    }

    return map;
}

/**
 * Creates an indicator map on the device. If dryRun is TRUE, it only checks
 * if creation is possible, but doesn't actually create it.
 */
static int
_XkbCreateIndicatorMap(DeviceIntPtr dev, Atom indicator,
                       int ledClass, int ledID,
                       XkbIndicatorMapPtr *map_return, int *led_return,
                       Bool dryRun)
{
    XkbSrvLedInfoPtr    sli;
    XkbIndicatorMapPtr  map;
    int                 led;

    sli = XkbFindSrvLedInfo(dev, ledClass, ledID, XkbXI_IndicatorsMask);
    if (!sli)
        return BadAlloc;

    map = _XkbFindNamedIndicatorMap(sli, indicator, &led);

    if (!map)
    {
        /* find first unused indicator maps and assign the name to it */
        for (led = 0, map = NULL; (led < XkbNumIndicators) && (map == NULL); led++) {
            if ((sli->names) && (sli->maps) && (sli->names[led] == None) &&
                    (!XkbIM_InUse(&sli->maps[led])))
            {
                map = &sli->maps[led];
                if (!dryRun)
                    sli->names[led] = indicator;
                break;
            }
        }
    }

    if (!map)
        return BadAlloc;

    *led_return = led;
    *map_return = map;
    return Success;
}

static int
_XkbSetNamedIndicator(ClientPtr client, DeviceIntPtr dev,
                      xkbSetNamedIndicatorReq *stuff)
{
    unsigned int                extDevReason;
    unsigned int                statec, namec, mapc;
    XkbSrvLedInfoPtr            sli;
    int                         led = 0;
    XkbIndicatorMapPtr          map;
    DeviceIntPtr                kbd;
    XkbEventCauseRec            cause;
    xkbExtensionDeviceNotify    ed;
    XkbChangesRec               changes;
    int                         rc;

    rc = _XkbCreateIndicatorMap(dev, stuff->indicator, stuff->ledClass,
                                stuff->ledID, &map, &led, FALSE);
    if (rc != Success || !map) /* oh-oh */
        return rc;

    sli = XkbFindSrvLedInfo(dev, stuff->ledClass, stuff->ledID,
                            XkbXI_IndicatorsMask);
    if (!sli)
        return BadAlloc;

    namec = mapc = statec = 0;
    extDevReason = 0;

    namec |= (1<<led);
    sli->namesPresent |= ((stuff->indicator != None) ? (1 << led) : 0);
    extDevReason |= XkbXI_IndicatorNamesMask;

    if (stuff->setMap) {
        map->flags = stuff->flags;
        map->which_groups = stuff->whichGroups;
        map->groups = stuff->groups;
        map->which_mods = stuff->whichMods;
        map->mods.mask = stuff->realMods;
        map->mods.real_mods = stuff->realMods;
        map->mods.vmods= stuff->virtualMods;
        map->ctrls = stuff->ctrls;
        mapc|= (1<<led);
    }

    if ((stuff->setState) && ((map->flags & XkbIM_NoExplicit) == 0))
    {
        if (stuff->on)	sli->explicitState |=  (1<<led);
        else		sli->explicitState &= ~(1<<led);
        statec |= ((sli->effectiveState ^ sli->explicitState) & (1 << led));
    }

    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    XkbSetCauseXkbReq(&cause,X_kbSetNamedIndicator,client);
    if (namec)
        XkbApplyLedNameChanges(dev,sli,namec,&ed,&changes,&cause);
    if (mapc)
        XkbApplyLedMapChanges(dev,sli,mapc,&ed,&changes,&cause);
    if (statec)
        XkbApplyLedStateChanges(dev,sli,statec,&ed,&changes,&cause);

    kbd = dev;
    if ((sli->flags&XkbSLI_HasOwnState)==0)
        kbd = inputInfo.keyboard;
    XkbFlushLedEvents(dev, kbd, sli, &ed, &changes, &cause);

    return Success;
}

int
ProcXkbSetNamedIndicator(ClientPtr client)
{
    int                         rc;
    DeviceIntPtr                dev;
    int                         led = 0;
    XkbIndicatorMapPtr          map;

    REQUEST(xkbSetNamedIndicatorReq);
    REQUEST_SIZE_MATCH(xkbSetNamedIndicatorReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_LED_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);
    CHK_ATOM_ONLY(stuff->indicator);
    CHK_MASK_LEGAL(0x10,stuff->whichGroups,XkbIM_UseAnyGroup);
    CHK_MASK_LEGAL(0x11,stuff->whichMods,XkbIM_UseAnyMods);

    /* Dry-run for checks */
    rc = _XkbCreateIndicatorMap(dev, stuff->indicator,
                                stuff->ledClass, stuff->ledID,
                                &map, &led, TRUE);
    if (rc != Success || !map) /* couldn't be created or didn't exist */
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd ||
        stuff->deviceSpec == XkbUseCorePtr)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev &&
                (other->kbdfeed || other->leds) &&
                (XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess) == Success))
            {
                rc = _XkbCreateIndicatorMap(other, stuff->indicator,
                                            stuff->ledClass, stuff->ledID,
                                            &map, &led, TRUE);
                if (rc != Success || !map)
                    return rc;
            }
        }
    }

    /* All checks passed, let's do it */
    rc = _XkbSetNamedIndicator(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd ||
        stuff->deviceSpec == XkbUseCorePtr)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev &&
                (other->kbdfeed || other->leds) &&
                (XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess) == Success))
            {
                _XkbSetNamedIndicator(client, other, stuff);
            }
        }
    }

    return Success;
}

/***====================================================================***/

static CARD32
_XkbCountAtoms(Atom *atoms,int maxAtoms,int *count)
{
register unsigned int i,bit,nAtoms;
register CARD32 atomsPresent;

    for (i=nAtoms=atomsPresent=0,bit=1;i<maxAtoms;i++,bit<<=1) {
	if (atoms[i]!=None) {
	    atomsPresent|= bit;
	    nAtoms++;
	}
    }
    if (count)
	*count= nAtoms;
    return atomsPresent;
}

static char *
_XkbWriteAtoms(char *wire,Atom *atoms,int maxAtoms,int swap)
{
register unsigned int i;
Atom *atm;

    atm = (Atom *)wire;
    for (i=0;i<maxAtoms;i++) {
	if (atoms[i]!=None) {
	    *atm= atoms[i];
	    if (swap) {
		register int n;
		swapl(atm,n);
	    }
	    atm++;
	}
    }
    return (char *)atm;
}

static Status
XkbComputeGetNamesReplySize(XkbDescPtr xkb,xkbGetNamesReply *rep)
{
register unsigned	which,length;
register int		i;

    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    which= rep->which;
    length= 0;
    if (xkb->names!=NULL) {
	 if (which&XkbKeycodesNameMask)		length++;
	 if (which&XkbGeometryNameMask)		length++;
	 if (which&XkbSymbolsNameMask)		length++;
	 if (which&XkbPhysSymbolsNameMask)	length++;
	 if (which&XkbTypesNameMask)		length++;
	 if (which&XkbCompatNameMask)		length++;
    }
    else which&= ~XkbComponentNamesMask;

    if (xkb->map!=NULL) {
	if (which&XkbKeyTypeNamesMask)
	    length+= xkb->map->num_types;
	rep->nTypes= xkb->map->num_types;
	if (which&XkbKTLevelNamesMask) {
	    XkbKeyTypePtr	pType = xkb->map->types;
	    int			nKTLevels = 0;

	    length+= XkbPaddedSize(xkb->map->num_types)/4;
	    for (i=0;i<xkb->map->num_types;i++,pType++) {
		if (pType->level_names!=NULL)
		    nKTLevels+= pType->num_levels;
	    }
	    rep->nKTLevels= nKTLevels;
	    length+= nKTLevels;
	}
    }
    else {
	rep->nTypes=    0;
	rep->nKTLevels= 0;
	which&= ~(XkbKeyTypeNamesMask|XkbKTLevelNamesMask);
    }

    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    rep->indicators= 0;
    rep->virtualMods= 0;
    rep->groupNames= 0;
    if (xkb->names!=NULL) {
	if (which&XkbIndicatorNamesMask) {
	    int nLeds;
	    rep->indicators= 
		_XkbCountAtoms(xkb->names->indicators,XkbNumIndicators,&nLeds);
	    length+= nLeds;
	    if (nLeds==0)
		which&= ~XkbIndicatorNamesMask;
	}

	if (which&XkbVirtualModNamesMask) {
	    int nVMods;
	    rep->virtualMods= 
		_XkbCountAtoms(xkb->names->vmods,XkbNumVirtualMods,&nVMods);
	    length+= nVMods;
	    if (nVMods==0)
		which&= ~XkbVirtualModNamesMask;
	}

	if (which&XkbGroupNamesMask) {
	    int nGroups;
	    rep->groupNames=
		_XkbCountAtoms(xkb->names->groups,XkbNumKbdGroups,&nGroups);
	    length+= nGroups;
	    if (nGroups==0)
		which&= ~XkbGroupNamesMask;
	}

	if ((which&XkbKeyNamesMask)&&(xkb->names->keys))
	     length+= rep->nKeys;
	else which&= ~XkbKeyNamesMask;

	if ((which&XkbKeyAliasesMask)&&
	    (xkb->names->key_aliases)&&(xkb->names->num_key_aliases>0)) {
	    rep->nKeyAliases= xkb->names->num_key_aliases;
	    length+= rep->nKeyAliases*2;
	} 
	else {
	    which&= ~XkbKeyAliasesMask;
	    rep->nKeyAliases= 0;
	}

	if ((which&XkbRGNamesMask)&&(xkb->names->num_rg>0))
	     length+= xkb->names->num_rg;
	else which&= ~XkbRGNamesMask;
    }
    else {
	which&= ~(XkbIndicatorNamesMask|XkbVirtualModNamesMask);
	which&= ~(XkbGroupNamesMask|XkbKeyNamesMask|XkbKeyAliasesMask);
	which&= ~XkbRGNamesMask;
    }

    rep->length= length;
    rep->which= which;
    return Success;
}

static int
XkbSendNames(ClientPtr client,XkbDescPtr xkb,xkbGetNamesReply *rep)
{
register unsigned 	i,length,which;
char *			start;
char *			desc;
register int            n;

    length= rep->length*4;
    which= rep->which;
    if (client->swapped) {
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swapl(&rep->which,n);
	swaps(&rep->virtualMods,n);
	swapl(&rep->indicators,n);
    }

    start = desc = calloc(1, length);
    if ( !start )
	return BadAlloc;
    if (xkb->names) {
        if (which&XkbKeycodesNameMask) {
            *((CARD32 *)desc)= xkb->names->keycodes;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbGeometryNameMask)  {
            *((CARD32 *)desc)= xkb->names->geometry;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbSymbolsNameMask) {
            *((CARD32 *)desc)= xkb->names->symbols;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbPhysSymbolsNameMask) {
            register CARD32 *atm= (CARD32 *)desc;
            atm[0]= (CARD32)xkb->names->phys_symbols;
            if (client->swapped) {
                swapl(&atm[0],n);
            }
            desc+= 4;
        }
        if (which&XkbTypesNameMask) {
            *((CARD32 *)desc)= (CARD32)xkb->names->types;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbCompatNameMask) {
            *((CARD32 *)desc)= (CARD32)xkb->names->compat;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbKeyTypeNamesMask) {
            register CARD32 *atm= (CARD32 *)desc;
            register XkbKeyTypePtr type= xkb->map->types;

            for (i=0;i<xkb->map->num_types;i++,atm++,type++) {
                *atm= (CARD32)type->name;
                if (client->swapped) {
                    swapl(atm,n);
                }
            }
            desc= (char *)atm;
        }
        if (which&XkbKTLevelNamesMask && xkb->map) {
            XkbKeyTypePtr type = xkb->map->types;
            register CARD32 *atm;
            for (i=0;i<rep->nTypes;i++,type++) {
                *desc++ = type->num_levels;
            }
            desc+= XkbPaddedSize(rep->nTypes)-rep->nTypes;

            atm= (CARD32 *)desc;
            type = xkb->map->types;
            for (i=0;i<xkb->map->num_types;i++,type++) {
                register unsigned l;
                if (type->level_names) {
                    for (l=0;l<type->num_levels;l++,atm++) {
                        *atm= type->level_names[l];
                        if (client->swapped) {
                            swapl(atm,n);
                        }
                    }
                    desc+= type->num_levels*4;
                }
            }
        }
        if (which&XkbIndicatorNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->indicators,XkbNumIndicators,
                                 client->swapped);
        }
        if (which&XkbVirtualModNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->vmods,XkbNumVirtualMods,
                                 client->swapped);
        }
        if (which&XkbGroupNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->groups,XkbNumKbdGroups,
                                 client->swapped);
        }
        if (which&XkbKeyNamesMask) {
            for (i=0;i<rep->nKeys;i++,desc+= sizeof(XkbKeyNameRec)) {
                *((XkbKeyNamePtr)desc)= xkb->names->keys[i+rep->firstKey];
            }
        }
        if (which&XkbKeyAliasesMask) {
            XkbKeyAliasPtr	pAl;
            pAl= xkb->names->key_aliases;
            for (i=0;i<rep->nKeyAliases;i++,pAl++,desc+=2*XkbKeyNameLength) {
                *((XkbKeyAliasPtr)desc)= *pAl;
            }
        }
        if ((which&XkbRGNamesMask)&&(rep->nRadioGroups>0)) {
            register CARD32	*atm= (CARD32 *)desc;
            for (i=0;i<rep->nRadioGroups;i++,atm++) {
                *atm= (CARD32)xkb->names->radio_groups[i];
                if (client->swapped) {
                    swapl(atm,n);
                }
            }
            desc+= rep->nRadioGroups*4;
        }
    }

    if ((desc-start)!=(length)) {
	ErrorF("[xkb] BOGUS LENGTH in write names, expected %d, got %ld\n",
					length, (unsigned long)(desc-start));
    }
    WriteToClient(client, SIZEOF(xkbGetNamesReply), (char *)rep);
    WriteToClient(client, length, start);
    free((char *)start);
    return Success;
}

int
ProcXkbGetNames(ClientPtr client)
{
    DeviceIntPtr	dev;
    XkbDescPtr		xkb;
    xkbGetNamesReply 	rep;

    REQUEST(xkbGetNamesReq);
    REQUEST_SIZE_MATCH(xkbGetNamesReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_LEGAL(0x01,stuff->which,XkbAllNamesMask);

    xkb = dev->key->xkbInfo->desc;
    memset(&rep, 0, sizeof(xkbGetNamesReply));
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.which = stuff->which;
    rep.nTypes = xkb->map->num_types;
    rep.firstKey = xkb->min_key_code;
    rep.nKeys = XkbNumKeys(xkb);
    if (xkb->names!=NULL) {
	rep.nKeyAliases= xkb->names->num_key_aliases;
	rep.nRadioGroups = xkb->names->num_rg;
    }
    else {
	rep.nKeyAliases= rep.nRadioGroups= 0;
    }
    XkbComputeGetNamesReplySize(xkb,&rep);
    return XkbSendNames(client,xkb,&rep);
}

/***====================================================================***/

static CARD32 *
_XkbCheckAtoms(CARD32 *wire,int nAtoms,int swapped,Atom *pError)
{
register int i;

    for (i=0;i<nAtoms;i++,wire++) {
	if (swapped) {
	    register int n;
	    swapl(wire,n);
	}
	if ((((Atom)*wire)!=None)&&(!ValidAtom((Atom)*wire))) {
	    *pError= ((Atom)*wire);
	    return NULL;
	}
    }
    return wire;
}

static CARD32 *
_XkbCheckMaskedAtoms(CARD32 *wire,int nAtoms,CARD32 present,int swapped,
								Atom *pError)
{
register unsigned i,bit;

    for (i=0,bit=1;(i<nAtoms)&&(present);i++,bit<<=1) {
	if ((present&bit)==0)
	    continue;
	if (swapped) {
	    register int n;
	    swapl(wire,n);
	}
	if ((((Atom)*wire)!=None)&&(!ValidAtom(((Atom)*wire)))) {
	    *pError= (Atom)*wire;
	    return NULL;
	}
	wire++;
    }
    return wire;
}

static Atom *
_XkbCopyMaskedAtoms(	Atom	*wire,
    			Atom	*dest,
			int   	 nAtoms,
			CARD32	 present)
{
register int i,bit;

    for (i=0,bit=1;(i<nAtoms)&&(present);i++,bit<<=1) {
	if ((present&bit)==0)
	    continue;
	dest[i]= *wire++;
    }
    return wire;
}

static Bool
_XkbCheckTypeName(Atom name,int typeNdx)
{
const char *	str;

    str= NameForAtom(name);
    if ((strcmp(str,"ONE_LEVEL")==0)||(strcmp(str,"TWO_LEVEL")==0)||
	(strcmp(str,"ALPHABETIC")==0)||(strcmp(str,"KEYPAD")==0))
	return FALSE;
    return TRUE;
}

/**
 * Check the device-dependent data in the request against the device. Returns
 * Success, or the appropriate error code.
 */
static int
_XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
                  xkbSetNamesReq *stuff, CARD32 *data)
{
    XkbDescRec		*xkb;
    XkbNamesRec		*names;
    CARD32		*tmp;
    Atom		 bad;

    tmp = data;
    xkb = dev->key->xkbInfo->desc;
    names = xkb->names;


    if (stuff->which & XkbKeyTypeNamesMask) {
        int i;
        CARD32	*old;
        if ( stuff->nTypes<1 ) {
            client->errorValue = _XkbErrCode2(0x02,stuff->nTypes);
            return BadValue;
        }
        if ((unsigned)(stuff->firstType+stuff->nTypes-1)>=xkb->map->num_types) {
            client->errorValue = _XkbErrCode4(0x03,stuff->firstType,
                    stuff->nTypes,
                    xkb->map->num_types);
            return BadValue;
        }
        if (((unsigned)stuff->firstType)<=XkbLastRequiredType) {
            client->errorValue = _XkbErrCode2(0x04,stuff->firstType);
            return BadAccess;
        }
        old= tmp;
        tmp= _XkbCheckAtoms(tmp,stuff->nTypes,client->swapped,&bad);
        if (!tmp) {
            client->errorValue= bad;
            return BadAtom;
        }
        for (i=0;i<stuff->nTypes;i++,old++) {
            if (!_XkbCheckTypeName((Atom)*old,stuff->firstType+i))
                client->errorValue= _XkbErrCode2(0x05,i);
        }
    }
    if (stuff->which&XkbKTLevelNamesMask) {
        unsigned i;
        XkbKeyTypePtr	type;
        CARD8 *		width;
        if ( stuff->nKTLevels<1 ) {
            client->errorValue = _XkbErrCode2(0x05,stuff->nKTLevels);
            return BadValue;
        }
        if ((unsigned)(stuff->firstKTLevel+stuff->nKTLevels-1)>=
                xkb->map->num_types) {
            client->errorValue = _XkbErrCode4(0x06,stuff->firstKTLevel,
                    stuff->nKTLevels,xkb->map->num_types);
            return BadValue;
        }
        width = (CARD8 *)tmp;
        tmp= (CARD32 *)(((char *)tmp)+XkbPaddedSize(stuff->nKTLevels));
        type = &xkb->map->types[stuff->firstKTLevel];
        for (i=0;i<stuff->nKTLevels;i++,type++) {
            if (width[i]==0)
                continue;
            else if (width[i]!=type->num_levels) {
                client->errorValue= _XkbErrCode4(0x07,i+stuff->firstKTLevel,
                        type->num_levels,width[i]);
                return BadMatch;
            }
            tmp= _XkbCheckAtoms(tmp,width[i],client->swapped,&bad);
            if (!tmp) {
                client->errorValue= bad;
                return BadAtom;
            }
        }
    }
    if (stuff->which&XkbIndicatorNamesMask) {
        if (stuff->indicators==0) {
            client->errorValue= 0x08;
            return BadMatch;
        }
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumIndicators,stuff->indicators,
                client->swapped,&bad);
        if (!tmp) {
            client->errorValue= bad;
            return BadAtom;
        }
    }
    if (stuff->which&XkbVirtualModNamesMask) {
        if (stuff->virtualMods==0) {
            client->errorValue= 0x09;
            return BadMatch;
        }
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumVirtualMods,
                (CARD32)stuff->virtualMods,
                client->swapped,&bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which&XkbGroupNamesMask) {
        if (stuff->groupNames==0) {
            client->errorValue= 0x0a;
            return BadMatch;
        }
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumKbdGroups,
                (CARD32)stuff->groupNames,
                client->swapped,&bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which&XkbKeyNamesMask) {
        if (stuff->firstKey<(unsigned)xkb->min_key_code) {
            client->errorValue= _XkbErrCode3(0x0b,xkb->min_key_code,
                    stuff->firstKey);
            return BadValue;
        }
        if (((unsigned)(stuff->firstKey+stuff->nKeys-1)>xkb->max_key_code)||
                (stuff->nKeys<1)) {
            client->errorValue= _XkbErrCode4(0x0c,xkb->max_key_code,
                    stuff->firstKey,stuff->nKeys);
            return BadValue;
        }
        tmp+= stuff->nKeys;
    }
    if ((stuff->which&XkbKeyAliasesMask)&&(stuff->nKeyAliases>0)) {
        tmp+= stuff->nKeyAliases*2;
    }
    if (stuff->which&XkbRGNamesMask) {
        if ( stuff->nRadioGroups<1 ) {
            client->errorValue= _XkbErrCode2(0x0d,stuff->nRadioGroups);
            return BadValue;
        }
        tmp= _XkbCheckAtoms(tmp,stuff->nRadioGroups,client->swapped,&bad);
        if (!tmp) {
            client->errorValue= bad;
            return BadAtom;
        }
    }
    if ((tmp-((CARD32 *)stuff))!=stuff->length) {
        client->errorValue = stuff->length;
        return BadLength;
    }



    return Success;
}

static int
_XkbSetNames(ClientPtr client, DeviceIntPtr dev, xkbSetNamesReq *stuff)
{
    XkbDescRec		*xkb;
    XkbNamesRec		*names;
    CARD32		*tmp;
    xkbNamesNotify	 nn;

    tmp = (CARD32 *)&stuff[1];
    xkb = dev->key->xkbInfo->desc;
    names = xkb->names;

    if (XkbAllocNames(xkb,stuff->which,stuff->nRadioGroups,
                stuff->nKeyAliases)!=Success) {
        return BadAlloc;
    }

    memset(&nn, 0, sizeof(xkbNamesNotify));
    nn.changed= stuff->which;
    tmp = (CARD32 *)&stuff[1];
    if (stuff->which&XkbKeycodesNameMask)
        names->keycodes= *tmp++;
    if (stuff->which&XkbGeometryNameMask)
        names->geometry= *tmp++;
    if (stuff->which&XkbSymbolsNameMask)
        names->symbols= *tmp++;
    if (stuff->which&XkbPhysSymbolsNameMask)
        names->phys_symbols= *tmp++;
    if (stuff->which&XkbTypesNameMask)
        names->types= *tmp++;
    if (stuff->which&XkbCompatNameMask)
        names->compat= *tmp++;
    if ((stuff->which&XkbKeyTypeNamesMask)&&(stuff->nTypes>0)) {
        register unsigned i;
        register XkbKeyTypePtr type;

        type= &xkb->map->types[stuff->firstType];
        for (i=0;i<stuff->nTypes;i++,type++) {
            type->name= *tmp++;
        }
        nn.firstType= stuff->firstType;
        nn.nTypes= stuff->nTypes;
    }
    if (stuff->which&XkbKTLevelNamesMask) {
        register XkbKeyTypePtr	type;
        register unsigned i;
        CARD8 *width;

        width = (CARD8 *)tmp;
        tmp= (CARD32 *)(((char *)tmp)+XkbPaddedSize(stuff->nKTLevels));
        type= &xkb->map->types[stuff->firstKTLevel];
        for (i=0;i<stuff->nKTLevels;i++,type++) {
            if (width[i]>0) {
                if (type->level_names) {
                    register unsigned n;
                    for (n=0;n<width[i];n++) {
                        type->level_names[n]= tmp[n];
                    }
                }
                tmp+= width[i];
            }
        }
        nn.firstLevelName= 0;
        nn.nLevelNames= stuff->nTypes;
    }
    if (stuff->which&XkbIndicatorNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->indicators,XkbNumIndicators,
                stuff->indicators);
        nn.changedIndicators= stuff->indicators;
    }
    if (stuff->which&XkbVirtualModNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->vmods,XkbNumVirtualMods,
                stuff->virtualMods);
        nn.changedVirtualMods= stuff->virtualMods;
    }
    if (stuff->which&XkbGroupNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->groups,XkbNumKbdGroups,
                stuff->groupNames);
        nn.changedVirtualMods= stuff->groupNames;
    }
    if (stuff->which&XkbKeyNamesMask) {
        memcpy((char*)&names->keys[stuff->firstKey],(char *)tmp,
                stuff->nKeys*XkbKeyNameLength);
        tmp+= stuff->nKeys;
        nn.firstKey= stuff->firstKey;
        nn.nKeys= stuff->nKeys;
    }
    if (stuff->which&XkbKeyAliasesMask) {
        if (stuff->nKeyAliases>0) {
            register int na= stuff->nKeyAliases;	
            if (XkbAllocNames(xkb,XkbKeyAliasesMask,0,na)!=Success)
                return BadAlloc;
            memcpy((char *)names->key_aliases,(char *)tmp,
                    stuff->nKeyAliases*sizeof(XkbKeyAliasRec));
            tmp+= stuff->nKeyAliases*2;
        }
        else if (names->key_aliases!=NULL) {
            free(names->key_aliases);
            names->key_aliases= NULL;
            names->num_key_aliases= 0;
        }
        nn.nAliases= names->num_key_aliases;
    }
    if (stuff->which&XkbRGNamesMask) {
        if (stuff->nRadioGroups>0) {
            register unsigned i,nrg;
            nrg= stuff->nRadioGroups;
            if (XkbAllocNames(xkb,XkbRGNamesMask,nrg,0)!=Success)
                return BadAlloc;

            for (i=0;i<stuff->nRadioGroups;i++) {
                names->radio_groups[i]= tmp[i];
            }
            tmp+= stuff->nRadioGroups;
        }
        else if (names->radio_groups) {
            free(names->radio_groups);
            names->radio_groups= NULL;
            names->num_rg= 0;
        }
        nn.nRadioGroups= names->num_rg;
    }
    if (nn.changed) {
        Bool needExtEvent;
        needExtEvent= (nn.changed&XkbIndicatorNamesMask)!=0;
        XkbSendNamesNotify(dev,&nn);
        if (needExtEvent) {
            XkbSrvLedInfoPtr		sli;
            xkbExtensionDeviceNotify	edev;
            register int		i;
            register unsigned		bit;

            sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,
                    XkbXI_IndicatorsMask);
            sli->namesPresent= 0;
            for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
                if (names->indicators[i]!=None)
                    sli->namesPresent|= bit;
            }
            memset(&edev, 0, sizeof(xkbExtensionDeviceNotify));
            edev.reason=	XkbXI_IndicatorNamesMask;
            edev.ledClass=	KbdFeedbackClass;
            edev.ledID=		dev->kbdfeed->ctrl.id;
            edev.ledsDefined= 	sli->namesPresent|sli->mapsPresent;
            edev.ledState=	sli->effectiveState;
            edev.firstBtn=	0;
            edev.nBtns=		0;
            edev.supported=	XkbXI_AllFeaturesMask;
            edev.unsupported=	0;
            XkbSendExtensionDeviceNotify(dev,client,&edev);
        }
    }
    return Success;
}

int
ProcXkbSetNames(ClientPtr client)
{
    DeviceIntPtr	 dev;
    CARD32		*tmp;
    Atom                 bad;
    int                  rc;

    REQUEST(xkbSetNamesReq);
    REQUEST_AT_LEAST_SIZE(xkbSetNamesReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01,stuff->which,XkbAllNamesMask);

    /* check device-independent stuff */
    tmp = (CARD32 *)&stuff[1];

    if (stuff->which&XkbKeycodesNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbGeometryNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbSymbolsNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbPhysSymbolsNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue= bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbTypesNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbCompatNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }

    /* start of device-dependent tests */
    rc = _XkbSetNamesCheck(client, dev, stuff, tmp);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {

                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetNamesCheck(client, other, stuff, tmp);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* everything is okay -- update names */

    rc = _XkbSetNames(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {

                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                    _XkbSetNames(client, other, stuff);
            }
        }
    }

    /* everything is okay -- update names */

    return Success;
}

/***====================================================================***/

#include "xkbgeom.h"

#define	XkbSizeCountedString(s)  ((s)?((((2+strlen(s))+3)/4)*4):4)

/**
 * Write the zero-terminated string str into wire as a pascal string with a
 * 16-bit length field prefixed before the actual string.
 *
 * @param wire The destination array, usually the wire struct
 * @param str The source string as zero-terminated C string
 * @param swap If TRUE, the length field is swapped.
 *
 * @return The input string in the format <string length><string> with a
 * (swapped) 16 bit string length, non-zero terminated.
 */
static char *
XkbWriteCountedString(char *wire,char *str,Bool swap)
{
    CARD16 len,*pLen, paddedLen;

    if (!str)
        return wire;

    len= strlen(str);
    pLen= (CARD16 *)wire;
    *pLen= len;
    if (swap) {
	register int n;
	swaps(pLen,n);
    }
    paddedLen= pad_to_int32(sizeof(len)+len)-sizeof(len);
    strncpy(&wire[sizeof(len)],str,paddedLen);
    wire+= sizeof(len)+paddedLen;
    return wire;
}

static int
XkbSizeGeomProperties(XkbGeometryPtr geom)
{
register int 	i,size;
XkbPropertyPtr	prop;
    
    for (size=i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	size+= XkbSizeCountedString(prop->name);
	size+= XkbSizeCountedString(prop->value);
    }
    return size;
}

static char *
XkbWriteGeomProperties(char *wire,XkbGeometryPtr geom,Bool swap)
{
register int 	i;
register XkbPropertyPtr	prop;
    
    for (i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	wire= XkbWriteCountedString(wire,prop->name,swap);
	wire= XkbWriteCountedString(wire,prop->value,swap);
    }
    return wire;
}

static int
XkbSizeGeomKeyAliases(XkbGeometryPtr geom)
{
    return geom->num_key_aliases*(2*XkbKeyNameLength);
}

static char *
XkbWriteGeomKeyAliases(char *wire,XkbGeometryPtr geom,Bool swap)
{
register int sz;
    
    sz= geom->num_key_aliases*(XkbKeyNameLength*2);
    if (sz>0) {
	memcpy(wire,(char *)geom->key_aliases,sz);
	wire+= sz;
    }
    return wire;
}

static int
XkbSizeGeomColors(XkbGeometryPtr geom)
{
register int 		i,size;
register XkbColorPtr	color;

    for (i=size=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	size+= XkbSizeCountedString(color->spec);
    }
    return size;
}

static char *
XkbWriteGeomColors(char *wire,XkbGeometryPtr geom,Bool swap)
{
register int		i;
register XkbColorPtr	color;

    for (i=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	wire= XkbWriteCountedString(wire,color->spec,swap);
    }
    return wire;
}

static int
XkbSizeGeomShapes(XkbGeometryPtr geom)
{
register int		i,size;
register XkbShapePtr	shape;

    for (i=size=0,shape=geom->shapes;i<geom->num_shapes;i++,shape++) {
	register int		n;
	register XkbOutlinePtr	ol;
	size+= SIZEOF(xkbShapeWireDesc);
	for (n=0,ol=shape->outlines;n<shape->num_outlines;n++,ol++) {
	    size+= SIZEOF(xkbOutlineWireDesc);
	    size+= ol->num_points*SIZEOF(xkbPointWireDesc);
	}
    }
    return size;
}

static char *
XkbWriteGeomShapes(char *wire,XkbGeometryPtr geom,Bool swap)
{
int			i;
XkbShapePtr		shape;
xkbShapeWireDesc *	shapeWire;

    for (i=0,shape=geom->shapes;i<geom->num_shapes;i++,shape++) {
	register int 		o;
	XkbOutlinePtr		ol;
	xkbOutlineWireDesc *	olWire;
	shapeWire= (xkbShapeWireDesc *)wire;
	shapeWire->name= shape->name;
	shapeWire->nOutlines= shape->num_outlines;
	if (shape->primary!=NULL)
	     shapeWire->primaryNdx= XkbOutlineIndex(shape,shape->primary);
	else shapeWire->primaryNdx= XkbNoShape;
	if (shape->approx!=NULL)
	     shapeWire->approxNdx= XkbOutlineIndex(shape,shape->approx);
	else shapeWire->approxNdx= XkbNoShape;
	shapeWire->pad= 0;
	if (swap) {
	    register int n;
	    swapl(&shapeWire->name,n);
	}
	wire= (char *)&shapeWire[1];
	for (o=0,ol=shape->outlines;o<shape->num_outlines;o++,ol++) {
	    register int	p;
	    XkbPointPtr		pt;
	    xkbPointWireDesc *	ptWire;
	    olWire= (xkbOutlineWireDesc *)wire;
	    olWire->nPoints= ol->num_points;
	    olWire->cornerRadius= ol->corner_radius;
	    olWire->pad= 0;
	    wire= (char *)&olWire[1];
	    ptWire= (xkbPointWireDesc *)wire;
	    for (p=0,pt=ol->points;p<ol->num_points;p++,pt++) {
		ptWire[p].x= pt->x;
		ptWire[p].y= pt->y;
		if (swap) {
		    register int n;
		    swaps(&ptWire[p].x,n);
		    swaps(&ptWire[p].y,n);
		}
	    }
	    wire= (char *)&ptWire[ol->num_points];
	}
    }
    return wire;
}

static int
XkbSizeGeomDoodads(int num_doodads,XkbDoodadPtr doodad)
{
register int	i,size;

    for (i=size=0;i<num_doodads;i++,doodad++) {
	size+= SIZEOF(xkbAnyDoodadWireDesc);
	if (doodad->any.type==XkbTextDoodad) {
	    size+= XkbSizeCountedString(doodad->text.text);
	    size+= XkbSizeCountedString(doodad->text.font);
	}
	else if (doodad->any.type==XkbLogoDoodad) {
	    size+= XkbSizeCountedString(doodad->logo.logo_name);
	}
    }
    return size;
}

static char *
XkbWriteGeomDoodads(char *wire,int num_doodads,XkbDoodadPtr doodad,Bool swap)
{
register int		i;
xkbDoodadWireDesc *	doodadWire;

    for (i=0;i<num_doodads;i++,doodad++) {
	doodadWire= (xkbDoodadWireDesc *)wire;
	wire= (char *)&doodadWire[1];
	memset(doodadWire, 0, SIZEOF(xkbDoodadWireDesc));
	doodadWire->any.name= doodad->any.name;
	doodadWire->any.type= doodad->any.type;
	doodadWire->any.priority= doodad->any.priority;
	doodadWire->any.top= doodad->any.top;
	doodadWire->any.left= doodad->any.left;
	if (swap) {
	    register int n;
	    swapl(&doodadWire->any.name,n);
	    swaps(&doodadWire->any.top,n);
	    swaps(&doodadWire->any.left,n);
	}
	switch (doodad->any.type) {
	    case XkbOutlineDoodad:
	    case XkbSolidDoodad:
		doodadWire->shape.angle= doodad->shape.angle;
		doodadWire->shape.colorNdx= doodad->shape.color_ndx;
		doodadWire->shape.shapeNdx= doodad->shape.shape_ndx;
		if (swap) {
		    register int n;
		    swaps(&doodadWire->shape.angle,n);
		}
		break;
	    case XkbTextDoodad:
		doodadWire->text.angle= doodad->text.angle;
		doodadWire->text.width= doodad->text.width;
		doodadWire->text.height= doodad->text.height;
		doodadWire->text.colorNdx= doodad->text.color_ndx;
		if (swap) {
		    register int n;
		    swaps(&doodadWire->text.angle,n);
		    swaps(&doodadWire->text.width,n);
		    swaps(&doodadWire->text.height,n);
		}
		wire= XkbWriteCountedString(wire,doodad->text.text,swap);
		wire= XkbWriteCountedString(wire,doodad->text.font,swap);
		break;
	    case XkbIndicatorDoodad:
		doodadWire->indicator.shapeNdx= doodad->indicator.shape_ndx;
		doodadWire->indicator.onColorNdx=doodad->indicator.on_color_ndx;
		doodadWire->indicator.offColorNdx=
						doodad->indicator.off_color_ndx;
		break;
	    case XkbLogoDoodad:
		doodadWire->logo.angle= doodad->logo.angle;
		doodadWire->logo.colorNdx= doodad->logo.color_ndx;
		doodadWire->logo.shapeNdx= doodad->logo.shape_ndx;
		wire= XkbWriteCountedString(wire,doodad->logo.logo_name,swap);
		break;
	    default:
		ErrorF("[xkb] Unknown doodad type %d in XkbWriteGeomDoodads\n",
			doodad->any.type);
		ErrorF("[xkb] Ignored\n");
		break;
	}
    }
    return wire;
}

static char *
XkbWriteGeomOverlay(char *wire,XkbOverlayPtr ol,Bool swap)
{
register int		r;
XkbOverlayRowPtr	row;
xkbOverlayWireDesc *	olWire;

   olWire= (xkbOverlayWireDesc *)wire;
   olWire->name= ol->name;
   olWire->nRows= ol->num_rows;
   olWire->pad1= 0;
   olWire->pad2= 0;
   if (swap) {
	register int n;
	swapl(&olWire->name,n);
   }
   wire= (char *)&olWire[1];
   for (r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
   	unsigned int		k;
	XkbOverlayKeyPtr	key;
	xkbOverlayRowWireDesc *	rowWire;
	rowWire= (xkbOverlayRowWireDesc *)wire;
	rowWire->rowUnder= row->row_under;
	rowWire->nKeys= row->num_keys;
	rowWire->pad1= 0;
	wire= (char *)&rowWire[1];
	for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
	    xkbOverlayKeyWireDesc *	keyWire;
	    keyWire= (xkbOverlayKeyWireDesc *)wire;
	    memcpy(keyWire->over,key->over.name,XkbKeyNameLength);
	    memcpy(keyWire->under,key->under.name,XkbKeyNameLength);
	    wire= (char *)&keyWire[1];
	}
   }
   return wire;
}

static int
XkbSizeGeomSections(XkbGeometryPtr geom)
{
register int 	i,size;
XkbSectionPtr	section;

    for (i=size=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	size+= SIZEOF(xkbSectionWireDesc);
	if (section->rows) {
	    int		r;
	    XkbRowPtr	row;
	    for (r=0,row=section->rows;r<section->num_rows;row++,r++) {
		size+= SIZEOF(xkbRowWireDesc);
		size+= row->num_keys*SIZEOF(xkbKeyWireDesc);
	    }
	}
	if (section->doodads)
	    size+= XkbSizeGeomDoodads(section->num_doodads,section->doodads);
	if (section->overlays) {
	    int			o;
	    XkbOverlayPtr	ol;
	    for (o=0,ol=section->overlays;o<section->num_overlays;o++,ol++) {
		int			r;
		XkbOverlayRowPtr	row;
		size+= SIZEOF(xkbOverlayWireDesc);
		for (r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
		   size+= SIZEOF(xkbOverlayRowWireDesc);
		   size+= row->num_keys*SIZEOF(xkbOverlayKeyWireDesc);
		}
	    }
	}
    }
    return size;
}

static char *
XkbWriteGeomSections(char *wire,XkbGeometryPtr geom,Bool swap)
{
register int		i;
XkbSectionPtr		section;
xkbSectionWireDesc *	sectionWire;

    for (i=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	sectionWire= (xkbSectionWireDesc *)wire;
	sectionWire->name= section->name;
	sectionWire->top= section->top;
	sectionWire->left= section->left;
	sectionWire->width= section->width;
	sectionWire->height= section->height;
	sectionWire->angle= section->angle;
	sectionWire->priority= section->priority;
	sectionWire->nRows= section->num_rows;
	sectionWire->nDoodads= section->num_doodads;
	sectionWire->nOverlays= section->num_overlays;
	sectionWire->pad= 0;
	if (swap) {
	    register int n;
	    swapl(&sectionWire->name,n);
	    swaps(&sectionWire->top,n);
	    swaps(&sectionWire->left,n);
	    swaps(&sectionWire->width,n);
	    swaps(&sectionWire->height,n);
	    swaps(&sectionWire->angle,n);
	}
	wire= (char *)&sectionWire[1];
	if (section->rows) {
	    int			r;
	    XkbRowPtr		row;
	    xkbRowWireDesc *	rowWire;
	    for (r=0,row=section->rows;r<section->num_rows;r++,row++) {
		rowWire= (xkbRowWireDesc *)wire;
		rowWire->top= row->top;
		rowWire->left= row->left;
		rowWire->nKeys= row->num_keys;
		rowWire->vertical= row->vertical;
		rowWire->pad= 0;
		if (swap) {
		    register int n;
		    swaps(&rowWire->top,n);
		    swaps(&rowWire->left,n);
		}
		wire= (char *)&rowWire[1];
		if (row->keys) {
		    int			k;
		    XkbKeyPtr		key;
		    xkbKeyWireDesc *	keyWire;
		    keyWire= (xkbKeyWireDesc *)wire;
		    for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
			memcpy(keyWire[k].name,key->name.name,XkbKeyNameLength);
			keyWire[k].gap= key->gap;
			keyWire[k].shapeNdx= key->shape_ndx;
			keyWire[k].colorNdx= key->color_ndx;
			if (swap) {
			    register int n;
			    swaps(&keyWire[k].gap,n);
			}
		    }
		    wire= (char *)&keyWire[row->num_keys];
		}
	    }
	}
	if (section->doodads) {
	    wire= XkbWriteGeomDoodads(wire,
	    			      section->num_doodads,section->doodads,
				      swap);
	}
	if (section->overlays) {
	    register int o;
	    for (o=0;o<section->num_overlays;o++) {
		wire= XkbWriteGeomOverlay(wire,&section->overlays[o],swap);
	    }
	}
    }
    return wire;
}

static Status
XkbComputeGetGeometryReplySize(	XkbGeometryPtr		geom,
				xkbGetGeometryReply *	rep,
				Atom			name)
{
int	len;

    if (geom!=NULL) {
	len= XkbSizeCountedString(geom->label_font);
	len+= XkbSizeGeomProperties(geom);
	len+= XkbSizeGeomColors(geom);
	len+= XkbSizeGeomShapes(geom);
	len+= XkbSizeGeomSections(geom);
	len+= XkbSizeGeomDoodads(geom->num_doodads,geom->doodads);
	len+= XkbSizeGeomKeyAliases(geom);
	rep->length= len/4;
	rep->found= TRUE;
	rep->name= geom->name;
	rep->widthMM= geom->width_mm;
	rep->heightMM= geom->height_mm;
	rep->nProperties= geom->num_properties;
	rep->nColors= geom->num_colors;
	rep->nShapes= geom->num_shapes;
	rep->nSections= geom->num_sections;
	rep->nDoodads= geom->num_doodads;
	rep->nKeyAliases= geom->num_key_aliases;
	rep->baseColorNdx= XkbGeomColorIndex(geom,geom->base_color);
	rep->labelColorNdx= XkbGeomColorIndex(geom,geom->label_color);
    }
    else {
	rep->length= 0;
	rep->found= FALSE;
	rep->name= name;
	rep->widthMM= rep->heightMM= 0;
	rep->nProperties= rep->nColors= rep->nShapes= 0;
	rep->nSections= rep->nDoodads= 0;
	rep->nKeyAliases= 0;
	rep->labelColorNdx= rep->baseColorNdx= 0;
    }
    return Success;
}

static int
XkbSendGeometry(	ClientPtr		client,
			XkbGeometryPtr		geom,
			xkbGetGeometryReply *	rep,
			Bool			freeGeom)
{
    char	*desc,*start;
    int		 len;

    if (geom!=NULL) {
	len= rep->length*4;
	start= desc= malloc(len);
	if (!start)
	    return BadAlloc;
	desc=  XkbWriteCountedString(desc,geom->label_font,client->swapped);
	if ( rep->nProperties>0 )
	    desc = XkbWriteGeomProperties(desc,geom,client->swapped);
	if ( rep->nColors>0 )
	    desc = XkbWriteGeomColors(desc,geom,client->swapped);
	if ( rep->nShapes>0 )
	    desc = XkbWriteGeomShapes(desc,geom,client->swapped);
	if ( rep->nSections>0 )
	    desc = XkbWriteGeomSections(desc,geom,client->swapped);
	if ( rep->nDoodads>0 )
	    desc = XkbWriteGeomDoodads(desc,geom->num_doodads,geom->doodads,
							  client->swapped);
	if ( rep->nKeyAliases>0 )
	    desc = XkbWriteGeomKeyAliases(desc,geom,client->swapped);
	if ((desc-start)!=(len)) {
	    ErrorF("[xkb] BOGUS LENGTH in XkbSendGeometry, expected %d, got %ld\n",
			len, (unsigned long)(desc-start));
	}
    }
    else {
	len= 0;
	start= NULL;
    }
    if (client->swapped) {
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swapl(&rep->name,n);
	swaps(&rep->widthMM,n);
	swaps(&rep->heightMM,n);
	swaps(&rep->nProperties,n);
	swaps(&rep->nColors,n);
	swaps(&rep->nShapes,n);
	swaps(&rep->nSections,n);
	swaps(&rep->nDoodads,n);
	swaps(&rep->nKeyAliases,n);
    }
    WriteToClient(client, SIZEOF(xkbGetGeometryReply), (char *)rep);
    if (len>0)
	WriteToClient(client, len, start);
    if (start!=NULL)
	free((char *)start);
    if (freeGeom)
	XkbFreeGeometry(geom,XkbGeomAllMask,TRUE);
    return Success;
}

int
ProcXkbGetGeometry(ClientPtr client)
{
    DeviceIntPtr 	dev;
    xkbGetGeometryReply rep;
    XkbGeometryPtr	geom;
    Bool		shouldFree;
    Status		status;

    REQUEST(xkbGetGeometryReq);
    REQUEST_SIZE_MATCH(xkbGetGeometryReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    geom= XkbLookupNamedGeometry(dev,stuff->name,&shouldFree);
    rep.type= X_Reply;
    rep.deviceID= dev->id;
    rep.sequenceNumber= client->sequence;
    rep.length= 0;
    status= XkbComputeGetGeometryReplySize(geom,&rep,stuff->name);
    if (status!=Success)
	 return status;
    else return XkbSendGeometry(client,geom,&rep,shouldFree);
}

/***====================================================================***/

static char *
_GetCountedString(char **wire_inout,Bool swap)
{
char *	wire,*str;
CARD16	len,*plen;

    wire= *wire_inout;
    plen= (CARD16 *)wire;
    if (swap) {
	register int n;
	swaps(plen,n);
    }
    len= *plen;
    str= malloc(len+1);
    if (str) {
	memcpy(str,&wire[2],len);
	str[len]= '\0';
    }
    wire+= XkbPaddedSize(len+2);
    *wire_inout= wire;
    return str;
}

static Status
_CheckSetDoodad(	char **		wire_inout,
			XkbGeometryPtr	geom,
			XkbSectionPtr	section,
			ClientPtr	client)
{
char *			wire;
xkbDoodadWireDesc *	dWire;
XkbDoodadPtr		doodad;

    dWire= (xkbDoodadWireDesc *)(*wire_inout);
    wire= (char *)&dWire[1];
    if (client->swapped) {
	register int n;
	swapl(&dWire->any.name,n);
	swaps(&dWire->any.top,n);
	swaps(&dWire->any.left,n);
	swaps(&dWire->any.angle,n);
    }
    CHK_ATOM_ONLY(dWire->any.name);
    doodad= XkbAddGeomDoodad(geom,section,dWire->any.name);
    if (!doodad)
	return BadAlloc;
    doodad->any.type= dWire->any.type;
    doodad->any.priority= dWire->any.priority;
    doodad->any.top= dWire->any.top;
    doodad->any.left= dWire->any.left;
    doodad->any.angle= dWire->any.angle;
    switch (doodad->any.type) {
	case XkbOutlineDoodad:
	case XkbSolidDoodad:
	    if (dWire->shape.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x40,geom->num_colors,
							dWire->shape.colorNdx);
		return BadMatch;
	    }
	    if (dWire->shape.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x41,geom->num_shapes,
							dWire->shape.shapeNdx);
		return BadMatch;
	    }
	    doodad->shape.color_ndx= dWire->shape.colorNdx;
	    doodad->shape.shape_ndx= dWire->shape.shapeNdx;
	    break;
	case XkbTextDoodad:
	    if (dWire->text.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x42,geom->num_colors,
							dWire->text.colorNdx);
		return BadMatch;
	    }
	    if (client->swapped) {
		register int n;
		swaps(&dWire->text.width,n);
		swaps(&dWire->text.height,n);
	    }
	    doodad->text.width= dWire->text.width;
	    doodad->text.height= dWire->text.height;
	    doodad->text.color_ndx= dWire->text.colorNdx;
	    doodad->text.text= _GetCountedString(&wire,client->swapped);
	    doodad->text.font= _GetCountedString(&wire,client->swapped);
	    break;
	case XkbIndicatorDoodad:
	    if (dWire->indicator.onColorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x43,geom->num_colors,
						dWire->indicator.onColorNdx);
		return BadMatch;
	    }
	    if (dWire->indicator.offColorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x44,geom->num_colors,
						dWire->indicator.offColorNdx);
		return BadMatch;
	    }
	    if (dWire->indicator.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x45,geom->num_shapes,
						dWire->indicator.shapeNdx);
		return BadMatch;
	    }
	    doodad->indicator.shape_ndx= dWire->indicator.shapeNdx;
	    doodad->indicator.on_color_ndx= dWire->indicator.onColorNdx;
	    doodad->indicator.off_color_ndx= dWire->indicator.offColorNdx;
	    break;
	case XkbLogoDoodad:
	    if (dWire->logo.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x46,geom->num_colors,
							dWire->logo.colorNdx);
		return BadMatch;
	    }
	    if (dWire->logo.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x47,geom->num_shapes,
							dWire->logo.shapeNdx);
		return BadMatch;
	    }
	    doodad->logo.color_ndx= dWire->logo.colorNdx;
	    doodad->logo.shape_ndx= dWire->logo.shapeNdx;
	    doodad->logo.logo_name= _GetCountedString(&wire,client->swapped);
	    break;
	default:
	    client->errorValue= _XkbErrCode2(0x4F,dWire->any.type);
	    return BadValue;
    }
    *wire_inout= wire;
    return Success;
}

static Status
_CheckSetOverlay(	char **		wire_inout,
			XkbGeometryPtr	geom,
			XkbSectionPtr	section,
			ClientPtr	client)
{
register int		r;
char *			wire;
XkbOverlayPtr		ol;
xkbOverlayWireDesc *	olWire;
xkbOverlayRowWireDesc *	rWire;

    wire= *wire_inout;
    olWire= (xkbOverlayWireDesc *)wire;
    if (client->swapped) {
	register int n;
	swapl(&olWire->name,n);
    }
    CHK_ATOM_ONLY(olWire->name);
    ol= XkbAddGeomOverlay(section,olWire->name,olWire->nRows);
    rWire= (xkbOverlayRowWireDesc *)&olWire[1];
    for (r=0;r<olWire->nRows;r++) {
	register int		k;
	xkbOverlayKeyWireDesc *	kWire;
	XkbOverlayRowPtr	row;

	if (rWire->rowUnder>section->num_rows) {
	    client->errorValue= _XkbErrCode4(0x20,r,section->num_rows,
							rWire->rowUnder);
	    return BadMatch;
	}
	row= XkbAddGeomOverlayRow(ol,rWire->rowUnder,rWire->nKeys);
	kWire= (xkbOverlayKeyWireDesc *)&rWire[1];
	for (k=0;k<rWire->nKeys;k++,kWire++) {
	    if (XkbAddGeomOverlayKey(ol,row,
	    		(char *)kWire->over,(char *)kWire->under)==NULL) {
		client->errorValue= _XkbErrCode3(0x21,r,k);
		return BadMatch;
	    }	
	}
	rWire= (xkbOverlayRowWireDesc *)kWire;
    }
    olWire= (xkbOverlayWireDesc *)rWire;
    wire= (char *)olWire;
    *wire_inout= wire;
    return Success;
}

static Status
_CheckSetSections( 	XkbGeometryPtr		geom,
			xkbSetGeometryReq *	req,
			char **			wire_inout,
			ClientPtr		client)
{
Status			status;
register int		s;
char *			wire;
xkbSectionWireDesc *	sWire;
XkbSectionPtr		section;

    wire= *wire_inout;
    if (req->nSections<1)
	return Success;
    sWire= (xkbSectionWireDesc *)wire;
    for (s=0;s<req->nSections;s++) {
	register int		r;
	xkbRowWireDesc *	rWire;
	if (client->swapped) {
	    register int n;
	    swapl(&sWire->name,n);
	    swaps(&sWire->top,n);
	    swaps(&sWire->left,n);
	    swaps(&sWire->width,n);
	    swaps(&sWire->height,n);
	    swaps(&sWire->angle,n);
	}
	CHK_ATOM_ONLY(sWire->name);
	section= XkbAddGeomSection(geom,sWire->name,sWire->nRows,
					sWire->nDoodads,sWire->nOverlays);
	if (!section)
	    return BadAlloc;
	section->priority=	sWire->priority;
	section->top=		sWire->top;
	section->left=		sWire->left;
	section->width=		sWire->width;
	section->height=	sWire->height;
	section->angle=		sWire->angle;
	rWire= (xkbRowWireDesc *)&sWire[1];
	for (r=0;r<sWire->nRows;r++) {
	    register int	k;
	    XkbRowPtr		row;
	    xkbKeyWireDesc *	kWire;
	    if (client->swapped) {
		register int n;
		swaps(&rWire->top,n);
		swaps(&rWire->left,n);
	    }
	    row= XkbAddGeomRow(section,rWire->nKeys);
	    if (!row)
		return BadAlloc;
	    row->top= rWire->top;
	    row->left= rWire->left;
	    row->vertical= rWire->vertical;
	    kWire= (xkbKeyWireDesc *)&rWire[1];
	    for (k=0;k<rWire->nKeys;k++) {
		XkbKeyPtr	key;
		key= XkbAddGeomKey(row);
		if (!key)
		    return BadAlloc;
		memcpy(key->name.name,kWire[k].name,XkbKeyNameLength);
		key->gap= kWire[k].gap;
		key->shape_ndx= kWire[k].shapeNdx;
		key->color_ndx= kWire[k].colorNdx;
		if (key->shape_ndx>=geom->num_shapes) {
		    client->errorValue= _XkbErrCode3(0x10,key->shape_ndx,
							  geom->num_shapes);
		    return BadMatch;
		}
		if (key->color_ndx>=geom->num_colors) {
		    client->errorValue= _XkbErrCode3(0x11,key->color_ndx,
							  geom->num_colors);
		    return BadMatch;
		}
	    }
	    rWire= (xkbRowWireDesc *)&kWire[rWire->nKeys];
	}
	wire= (char *)rWire;
	if (sWire->nDoodads>0) {
	    register int d;
	    for (d=0;d<sWire->nDoodads;d++) {
		status=_CheckSetDoodad(&wire,geom,section,client);
		if (status!=Success)
		    return status;
	    }
	}
	if (sWire->nOverlays>0) {
	    register int o;
	    for (o=0;o<sWire->nOverlays;o++) {
		status= _CheckSetOverlay(&wire,geom,section,client);
		if (status!=Success)
		    return status;
	    }
	}
	sWire= (xkbSectionWireDesc *)wire;
    }
    wire= (char *)sWire;
    *wire_inout= wire;
    return Success;
}

static Status
_CheckSetShapes( 	XkbGeometryPtr		geom,
			xkbSetGeometryReq *	req,
			char **			wire_inout,
			ClientPtr		client)
{
register int	i;
char *		wire;

    wire= *wire_inout;
    if (req->nShapes<1) {
	client->errorValue= _XkbErrCode2(0x06,req->nShapes);
	return BadValue;
    }
    else {
	xkbShapeWireDesc *	shapeWire;
	XkbShapePtr		shape;
	register int		o;
	shapeWire= (xkbShapeWireDesc *)wire;
	for (i=0;i<req->nShapes;i++) {
	    xkbOutlineWireDesc *	olWire;
	    XkbOutlinePtr		ol;
	    shape= XkbAddGeomShape(geom,shapeWire->name,shapeWire->nOutlines);
	    if (!shape)
		return BadAlloc;
	    olWire= (xkbOutlineWireDesc *)(&shapeWire[1]);
	    for (o=0;o<shapeWire->nOutlines;o++) {
		register int		p;
		XkbPointPtr		pt;
		xkbPointWireDesc *	ptWire;

		ol= XkbAddGeomOutline(shape,olWire->nPoints);
		if (!ol)
		    return BadAlloc;
		ol->corner_radius=	olWire->cornerRadius;
		ptWire= (xkbPointWireDesc *)&olWire[1];
		for (p=0,pt=ol->points;p<olWire->nPoints;p++,pt++) {
		    pt->x= ptWire[p].x;
		    pt->y= ptWire[p].y;
		    if (client->swapped) {
			register int n;
			swaps(&pt->x,n);
			swaps(&pt->y,n);
		    }
		}
		ol->num_points= olWire->nPoints;
		olWire= (xkbOutlineWireDesc *)(&ptWire[olWire->nPoints]);
	    }
	    if (shapeWire->primaryNdx!=XkbNoShape)
		shape->primary= &shape->outlines[shapeWire->primaryNdx];
	    if (shapeWire->approxNdx!=XkbNoShape)
		shape->approx= &shape->outlines[shapeWire->approxNdx];
	    shapeWire= (xkbShapeWireDesc *)olWire;
	}
	wire= (char *)shapeWire;
    }
    if (geom->num_shapes!=req->nShapes) {
	client->errorValue= _XkbErrCode3(0x07,geom->num_shapes,req->nShapes);
	return BadMatch;
    }

    *wire_inout= wire;
    return Success;
}

static Status
_CheckSetGeom(	XkbGeometryPtr		geom,
		xkbSetGeometryReq *	req,
		ClientPtr 		client)
{
register int	i;
Status		status;
char *		wire;

    wire= (char *)&req[1];
    geom->label_font= _GetCountedString(&wire,client->swapped);

    for (i=0;i<req->nProperties;i++) {
	char *name,*val;
	name= _GetCountedString(&wire,client->swapped);
        if (!name)
            return BadAlloc;
	val= _GetCountedString(&wire,client->swapped);
        if (!val) {
            free(name);
            return BadAlloc;
        }
	if (XkbAddGeomProperty(geom,name,val)==NULL) {
            free(name);
            free(val);
	    return BadAlloc;
        }
        free(name);
        free(val);
    }

    if (req->nColors<2) {
	client->errorValue= _XkbErrCode3(0x01,2,req->nColors);
	return BadValue;
    }
    if (req->baseColorNdx>req->nColors) {
	client->errorValue=_XkbErrCode3(0x03,req->nColors,req->baseColorNdx);
	return BadMatch;
    }
    if (req->labelColorNdx>req->nColors) {
	client->errorValue= _XkbErrCode3(0x03,req->nColors,req->labelColorNdx);
	return BadMatch;
    }
    if (req->labelColorNdx==req->baseColorNdx) {
	client->errorValue= _XkbErrCode3(0x04,req->baseColorNdx,
                                         req->labelColorNdx);
	return BadMatch;
    }

    for (i=0;i<req->nColors;i++) {
	char *name;
	name= _GetCountedString(&wire,client->swapped);
	if (!name)
            return BadAlloc;
        if (!XkbAddGeomColor(geom,name,geom->num_colors)) {
            free(name);
	    return BadAlloc;
        }
        free(name);
    }
    if (req->nColors!=geom->num_colors) {
	client->errorValue= _XkbErrCode3(0x05,req->nColors,geom->num_colors);
	return BadMatch;
    }
    geom->label_color= &geom->colors[req->labelColorNdx];
    geom->base_color= &geom->colors[req->baseColorNdx];

    if ((status=_CheckSetShapes(geom,req,&wire,client))!=Success)
	return status;

    if ((status=_CheckSetSections(geom,req,&wire,client))!=Success)
	return status;

    for (i=0;i<req->nDoodads;i++) {
	status=_CheckSetDoodad(&wire,geom,NULL,client);
	if (status!=Success)
	    return status;
    }

    for (i=0;i<req->nKeyAliases;i++) {
	if (XkbAddGeomKeyAlias(geom,&wire[XkbKeyNameLength],wire)==NULL)
	    return BadAlloc;
	wire+= 2*XkbKeyNameLength;
    }
    return Success;
}

static int
_XkbSetGeometry(ClientPtr client, DeviceIntPtr dev, xkbSetGeometryReq *stuff)
{
    XkbDescPtr		xkb;
    Bool		new_name;
    xkbNewKeyboardNotify	nkn;
    XkbGeometryPtr	geom,old;
    XkbGeometrySizesRec	sizes;
    Status		status;

    xkb= dev->key->xkbInfo->desc;
    old= xkb->geom;
    xkb->geom= NULL;

    sizes.which=		XkbGeomAllMask;
    sizes.num_properties=	stuff->nProperties;
    sizes.num_colors=	stuff->nColors;
    sizes.num_shapes=	stuff->nShapes;
    sizes.num_sections=	stuff->nSections;
    sizes.num_doodads=	stuff->nDoodads;
    sizes.num_key_aliases=	stuff->nKeyAliases;
    if ((status= XkbAllocGeometry(xkb,&sizes))!=Success) {
        xkb->geom= old;
        return status;
    }
    geom= xkb->geom;
    geom->name= stuff->name;
    geom->width_mm= stuff->widthMM;
    geom->height_mm= stuff->heightMM;
    if ((status= _CheckSetGeom(geom,stuff,client))!=Success) {
        XkbFreeGeometry(geom,XkbGeomAllMask,TRUE);
        xkb->geom= old;
        return status;
    }
    new_name= (xkb->names->geometry!=geom->name);
    xkb->names->geometry= geom->name;
    if (old)
        XkbFreeGeometry(old,XkbGeomAllMask,TRUE);
    if (new_name) {
        xkbNamesNotify	nn;
        memset(&nn, 0, sizeof(xkbNamesNotify));
        nn.changed= XkbGeometryNameMask;
        XkbSendNamesNotify(dev,&nn);
    }
    nkn.deviceID= nkn.oldDeviceID= dev->id;
    nkn.minKeyCode= nkn.oldMinKeyCode= xkb->min_key_code;
    nkn.maxKeyCode= nkn.oldMaxKeyCode= xkb->max_key_code;
    nkn.requestMajor=	XkbReqCode;
    nkn.requestMinor=	X_kbSetGeometry;
    nkn.changed=	XkbNKN_GeometryMask;
    XkbSendNewKeyboardNotify(dev,&nkn);
    return Success;
}

int
ProcXkbSetGeometry(ClientPtr client)
{
    DeviceIntPtr        dev;
    int                 rc;

    REQUEST(xkbSetGeometryReq);
    REQUEST_AT_LEAST_SIZE(xkbSetGeometryReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    rc = _XkbSetGeometry(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                    _XkbSetGeometry(client, other, stuff);
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbPerClientFlags(ClientPtr client)
{
    DeviceIntPtr 		dev;
    xkbPerClientFlagsReply 	rep;
    XkbInterestPtr		interest;
    Mask access_mode = DixGetAttrAccess | DixSetAttrAccess;

    REQUEST(xkbPerClientFlagsReq);
    REQUEST_SIZE_MATCH(xkbPerClientFlagsReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);
    CHK_MASK_LEGAL(0x01,stuff->change,XkbPCF_AllFlagsMask);
    CHK_MASK_MATCH(0x02,stuff->change,stuff->value);

    interest = XkbFindClientResource((DevicePtr)dev,client);
    memset(&rep, 0, sizeof(xkbPerClientFlagsReply));
    rep.type= X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    if (stuff->change) {
	client->xkbClientFlags&= ~stuff->change;
	client->xkbClientFlags|= stuff->value;
    }
    if (stuff->change&XkbPCF_AutoResetControlsMask) {
	Bool	want;
	want= stuff->value&XkbPCF_AutoResetControlsMask;
	if (interest && !want) {
	    interest->autoCtrls= interest->autoCtrlValues= 0;
	}
	else if (want && (!interest)) {
	    XID id = FakeClientID(client->index);
	    if (!AddResource(id,RT_XKBCLIENT,dev))
		return BadAlloc;
	    interest= XkbAddClientResource((DevicePtr)dev,client,id);
	    if (!interest)
		return BadAlloc;
	}
	if (interest && want ) {
	    register unsigned affect;
	    affect= stuff->ctrlsToChange;

	    CHK_MASK_LEGAL(0x03,affect,XkbAllBooleanCtrlsMask);
	    CHK_MASK_MATCH(0x04,affect,stuff->autoCtrls);
	    CHK_MASK_MATCH(0x05,stuff->autoCtrls,stuff->autoCtrlValues);

	    interest->autoCtrls&= ~affect;
	    interest->autoCtrlValues&= ~affect;
	    interest->autoCtrls|= stuff->autoCtrls&affect;
	    interest->autoCtrlValues|= stuff->autoCtrlValues&affect;
	}
    }
    rep.supported = XkbPCF_AllFlagsMask;
    rep.value= client->xkbClientFlags&XkbPCF_AllFlagsMask;
    if (interest) {
	rep.autoCtrls= interest->autoCtrls;
	rep.autoCtrlValues= interest->autoCtrlValues;
    }
    else {
	rep.autoCtrls= rep.autoCtrlValues= 0;
    }
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.supported,n);
	swapl(&rep.value,n);
	swapl(&rep.autoCtrls,n);
	swapl(&rep.autoCtrlValues,n);
    }
    WriteToClient(client,SIZEOF(xkbPerClientFlagsReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

/* all latin-1 alphanumerics, plus parens, minus, underscore, slash */
/* and wildcards */
static unsigned char componentSpecLegal[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0xa7, 0xff, 0x87,
        0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff
};

/* same as above but accepts percent, plus and bar too */
static unsigned char componentExprLegal[] = {
        0x00, 0x00, 0x00, 0x00, 0x20, 0xaf, 0xff, 0x87,
        0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x17,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff
};

static char *
GetComponentSpec(unsigned char **pWire,Bool allowExpr,int *errRtrn)
{
int		len;
register int	i;
unsigned char	*wire,*str,*tmp,*legal;

    if (allowExpr)	legal= &componentExprLegal[0];
    else		legal= &componentSpecLegal[0];

    wire= *pWire;
    len= (*(unsigned char *)wire++);
    if (len>0) {
	str= calloc(1, len+1);
	if (str) {
	    tmp= str;
	    for (i=0;i<len;i++) {
		if (legal[(*wire)/8]&(1<<((*wire)%8)))
		    *tmp++= *wire++;
		else wire++;
	    }
	    if (tmp!=str)
		*tmp++= '\0';
	    else {
		free(str);
		str= NULL;
	    }
	}
	else {
	    *errRtrn= BadAlloc;
	}
    }
    else {
	str= NULL;
    }
    *pWire= wire;
    return (char *)str;
}

/***====================================================================***/

int
ProcXkbListComponents(ClientPtr client)
{
    DeviceIntPtr 		dev;
    xkbListComponentsReply 	rep;
    unsigned			len;
    int				status;
    unsigned char *		str;
    XkbSrvListInfoRec		list;

    REQUEST(xkbListComponentsReq);
    REQUEST_AT_LEAST_SIZE(xkbListComponentsReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    status= Success;
    str= (unsigned char *)&stuff[1];
    memset(&list, 0, sizeof(XkbSrvListInfoRec));
    list.maxRtrn= stuff->maxNames;
    list.pattern[_XkbListKeycodes]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListTypes]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListCompat]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListSymbols]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListGeometry]= GetComponentSpec(&str,FALSE,&status);
    if (status!=Success)
	return status;
    len= str-((unsigned char *)stuff);
    if ((XkbPaddedSize(len)/4)!=stuff->length)
	return BadLength;
    if ((status=XkbDDXList(dev,&list,client))!=Success) {
	free(list.pool);
	list.pool = NULL;
	return status;
    }
    memset(&rep, 0, sizeof(xkbListComponentsReply));
    rep.type= X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = XkbPaddedSize(list.nPool)/4;
    rep.nKeymaps = 0;
    rep.nKeycodes = list.nFound[_XkbListKeycodes];
    rep.nTypes = list.nFound[_XkbListTypes];
    rep.nCompatMaps = list.nFound[_XkbListCompat];
    rep.nSymbols = list.nFound[_XkbListSymbols];
    rep.nGeometries = list.nFound[_XkbListGeometry];
    rep.extra=	0;
    if (list.nTotal>list.maxRtrn)
	rep.extra = (list.nTotal-list.maxRtrn);
    if (client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.nKeymaps,n);
	swaps(&rep.nKeycodes,n);
	swaps(&rep.nTypes,n);
	swaps(&rep.nCompatMaps,n);
	swaps(&rep.nSymbols,n);
	swaps(&rep.nGeometries,n);
	swaps(&rep.extra,n);
    }
    WriteToClient(client,SIZEOF(xkbListComponentsReply),(char *)&rep);
    if (list.nPool && list.pool) {
	WriteToClient(client,XkbPaddedSize(list.nPool), (char *)list.pool);
	free(list.pool);
	list.pool= NULL;
    }
    return Success;
}

/***====================================================================***/

int
ProcXkbGetKbdByName(ClientPtr client)
{
    DeviceIntPtr 		dev;
    DeviceIntPtr                tmpd;
    DeviceIntPtr                master;
    xkbGetKbdByNameReply 	rep = {0};
    xkbGetMapReply		mrep = {0};
    xkbGetCompatMapReply	crep = {0};
    xkbGetIndicatorMapReply	irep = {0};
    xkbGetNamesReply		nrep = {0};
    xkbGetGeometryReply		grep = {0};
    XkbComponentNamesRec	names = {0};
    XkbDescPtr			xkb, new;
    unsigned char *		str;
    char 			mapFile[PATH_MAX];
    unsigned			len;
    unsigned			fwant,fneed,reported;
    int				status;
    Bool			geom_changed;
    XkbSrvLedInfoPtr            old_sli;
    XkbSrvLedInfoPtr            sli;
    Mask access_mode = DixGetAttrAccess | DixManageAccess;

    REQUEST(xkbGetKbdByNameReq);
    REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);
    master = GetMaster(dev, MASTER_KEYBOARD);

    xkb = dev->key->xkbInfo->desc;
    status= Success;
    str= (unsigned char *)&stuff[1];
    if (GetComponentSpec(&str,TRUE,&status)) /* keymap, unsupported */
        return BadMatch;
    names.keycodes= GetComponentSpec(&str,TRUE,&status);
    names.types= GetComponentSpec(&str,TRUE,&status);
    names.compat= GetComponentSpec(&str,TRUE,&status);
    names.symbols= GetComponentSpec(&str,TRUE,&status);
    names.geometry= GetComponentSpec(&str,TRUE,&status);
    if (status!=Success)
	return status;
    len= str-((unsigned char *)stuff);
    if ((XkbPaddedSize(len)/4)!=stuff->length)
	return BadLength;

    CHK_MASK_LEGAL(0x01,stuff->want,XkbGBN_AllComponentsMask);
    CHK_MASK_LEGAL(0x02,stuff->need,XkbGBN_AllComponentsMask);
    
    if (stuff->load)
	 fwant= XkbGBN_AllComponentsMask;
    else fwant= stuff->want|stuff->need;
    if ((!names.compat)&&
        (fwant&(XkbGBN_CompatMapMask|XkbGBN_IndicatorMapMask))) {
        names.compat= Xstrdup("%");
    }
    if ((!names.types)&&(fwant&(XkbGBN_TypesMask))) {
        names.types= Xstrdup("%");
    }
    if ((!names.symbols)&&(fwant&XkbGBN_SymbolsMask)) {
        names.symbols= Xstrdup("%");
    }
    geom_changed= ((names.geometry!=NULL)&&(strcmp(names.geometry,"%")!=0));
    if ((!names.geometry)&&(fwant&XkbGBN_GeometryMask)) {
        names.geometry= Xstrdup("%");
        geom_changed= FALSE;
    }

    memset(mapFile, 0, PATH_MAX);
    rep.type= X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.minKeyCode = xkb->min_key_code;
    rep.maxKeyCode = xkb->max_key_code;
    rep.loaded=	FALSE;
    fwant= XkbConvertGetByNameComponents(TRUE,stuff->want)|XkmVirtualModsMask;
    fneed= XkbConvertGetByNameComponents(TRUE,stuff->need);
    rep.reported= XkbConvertGetByNameComponents(FALSE,fwant|fneed);
    if (stuff->load) {
	fneed|= XkmKeymapRequired;
	fwant|= XkmKeymapLegal;
    }
    if ((fwant|fneed)&XkmSymbolsMask) {
	fneed|= XkmKeyNamesIndex|XkmTypesIndex;
	fwant|= XkmIndicatorsIndex;
    }

    /* We pass dev in here so we can get the old names out if needed. */
    rep.found = XkbDDXLoadKeymapByNames(dev,&names,fwant,fneed,&new,
                                        mapFile,PATH_MAX);
    rep.newKeyboard= FALSE;
    rep.pad1= rep.pad2= rep.pad3= rep.pad4= 0;

    stuff->want|= stuff->need;
    if (new==NULL)
	rep.reported= 0;
    else {
	if (stuff->load)
	    rep.loaded= TRUE;
	if (stuff->load || 
		((rep.reported&XkbGBN_SymbolsMask) && (new->compat))) {
	    XkbChangesRec changes;
	    memset(&changes, 0, sizeof(changes));
	    XkbUpdateDescActions(new,
			new->min_key_code,XkbNumKeys(new),
			&changes);
	}

	if (new->map==NULL)
	    rep.reported&= ~(XkbGBN_SymbolsMask|XkbGBN_TypesMask);
	else if (rep.reported&(XkbGBN_SymbolsMask|XkbGBN_TypesMask)) {
	    mrep.type= X_Reply;
	    mrep.deviceID = dev->id;
	    mrep.sequenceNumber= client->sequence;
	    mrep.length = ((SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply))>>2);
	    mrep.minKeyCode = new->min_key_code;
	    mrep.maxKeyCode = new->max_key_code;
	    mrep.present = 0;
	    mrep.totalSyms = mrep.totalActs =
		mrep.totalKeyBehaviors= mrep.totalKeyExplicit= 
		mrep.totalModMapKeys= mrep.totalVModMapKeys= 0;
	    if (rep.reported&(XkbGBN_TypesMask|XkbGBN_ClientSymbolsMask)) {
		mrep.present|= XkbKeyTypesMask;
		mrep.firstType = 0;
		mrep.nTypes = mrep.totalTypes= new->map->num_types;
	    }
	    else {
		mrep.firstType = mrep.nTypes= 0;
		mrep.totalTypes= 0;
	    }
	    if (rep.reported&XkbGBN_ClientSymbolsMask) {
		mrep.present|= (XkbKeySymsMask|XkbModifierMapMask);
		mrep.firstKeySym = mrep.firstModMapKey= new->min_key_code;
		mrep.nKeySyms = mrep.nModMapKeys= XkbNumKeys(new);
	    }
	    else {
		mrep.firstKeySym= mrep.firstModMapKey= 0;
		mrep.nKeySyms= mrep.nModMapKeys= 0;
	    }
	    if (rep.reported&XkbGBN_ServerSymbolsMask) {
		mrep.present|= XkbAllServerInfoMask;
		mrep.virtualMods= ~0;
		mrep.firstKeyAct = mrep.firstKeyBehavior = 
			mrep.firstKeyExplicit = new->min_key_code;
		mrep.nKeyActs = mrep.nKeyBehaviors = 
			mrep.nKeyExplicit = XkbNumKeys(new);
		mrep.firstVModMapKey= new->min_key_code;
		mrep.nVModMapKeys= XkbNumKeys(new);
	    }
	    else {
		mrep.virtualMods= 0;
		mrep.firstKeyAct= mrep.firstKeyBehavior= 
			mrep.firstKeyExplicit = 0;
		mrep.nKeyActs= mrep.nKeyBehaviors= mrep.nKeyExplicit= 0;
	    }
	    XkbComputeGetMapReplySize(new,&mrep);
	    rep.length+= SIZEOF(xGenericReply)/4+mrep.length;
	}
	if (new->compat==NULL)
	    rep.reported&= ~XkbGBN_CompatMapMask;
	else if (rep.reported&XkbGBN_CompatMapMask) {
	    crep.type= X_Reply;
	    crep.deviceID= dev->id;
	    crep.sequenceNumber= client->sequence;
	    crep.length= 0;
	    crep.groups= XkbAllGroupsMask;
	    crep.firstSI= 0;
	    crep.nSI= crep.nTotalSI= new->compat->num_si;
	    XkbComputeGetCompatMapReplySize(new->compat,&crep);
	    rep.length+= SIZEOF(xGenericReply)/4+crep.length;
	}
	if (new->indicators==NULL)
	    rep.reported&= ~XkbGBN_IndicatorMapMask;
	else if (rep.reported&XkbGBN_IndicatorMapMask) {
	    irep.type= X_Reply;
	    irep.deviceID= dev->id;
	    irep.sequenceNumber= client->sequence;
	    irep.length= 0;
	    irep.which= XkbAllIndicatorsMask;
	    XkbComputeGetIndicatorMapReplySize(new->indicators,&irep);
	    rep.length+= SIZEOF(xGenericReply)/4+irep.length;
	}
	if (new->names==NULL)
	    rep.reported&= ~(XkbGBN_OtherNamesMask|XkbGBN_KeyNamesMask);
	else if (rep.reported&(XkbGBN_OtherNamesMask|XkbGBN_KeyNamesMask)) {
	    nrep.type= X_Reply;
	    nrep.deviceID= dev->id;
	    nrep.sequenceNumber= client->sequence;
	    nrep.length= 0;
	    nrep.minKeyCode= new->min_key_code;
	    nrep.maxKeyCode= new->max_key_code;
	    if (rep.reported&XkbGBN_OtherNamesMask) {
		nrep.which= XkbAllNamesMask;
		if (new->map!=NULL)
		     nrep.nTypes= new->map->num_types;
		else nrep.nTypes= 0;
		nrep.nKTLevels= 0;
		nrep.groupNames= XkbAllGroupsMask;
		nrep.virtualMods= XkbAllVirtualModsMask;
		nrep.indicators= XkbAllIndicatorsMask;
		nrep.nRadioGroups= new->names->num_rg;
	    }
	    else {
		nrep.which= 0;
		nrep.nTypes= 0;
		nrep.nKTLevels= 0;
		nrep.groupNames= 0;
		nrep.virtualMods= 0;
		nrep.indicators= 0;
		nrep.nRadioGroups= 0;
	    }
	    if (rep.reported&XkbGBN_KeyNamesMask) {
		nrep.which|= XkbKeyNamesMask;
		nrep.firstKey= new->min_key_code;
		nrep.nKeys= XkbNumKeys(new);
		nrep.nKeyAliases= new->names->num_key_aliases;
		if (nrep.nKeyAliases)
		    nrep.which|= XkbKeyAliasesMask;
	    }
	    else {
		nrep.which&= ~(XkbKeyNamesMask|XkbKeyAliasesMask);
		nrep.firstKey= nrep.nKeys= 0;
		nrep.nKeyAliases= 0;
	    }
	    XkbComputeGetNamesReplySize(new,&nrep);
	    rep.length+= SIZEOF(xGenericReply)/4+nrep.length;
	}
	if (new->geom==NULL)
	    rep.reported&= ~XkbGBN_GeometryMask;
	else if (rep.reported&XkbGBN_GeometryMask) {
	    grep.type= X_Reply;
	    grep.deviceID= dev->id;
	    grep.sequenceNumber= client->sequence;
	    grep.length= 0;
	    grep.found= TRUE;
	    grep.pad= 0;
	    grep.widthMM= grep.heightMM= 0;
	    grep.nProperties= grep.nColors= grep.nShapes= 0;
	    grep.nSections= grep.nDoodads= 0;
	    grep.baseColorNdx= grep.labelColorNdx= 0;
	    XkbComputeGetGeometryReplySize(new->geom,&grep,None);
	    rep.length+= SIZEOF(xGenericReply)/4+grep.length;
	}
    }

    reported= rep.reported;
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.found,n);
	swaps(&rep.reported,n);
    }
    WriteToClient(client,SIZEOF(xkbGetKbdByNameReply), (char *)&rep);
    if (reported&(XkbGBN_SymbolsMask|XkbGBN_TypesMask))
	XkbSendMap(client,new,&mrep);
    if (reported&XkbGBN_CompatMapMask)
	XkbSendCompatMap(client,new->compat,&crep);
    if (reported&XkbGBN_IndicatorMapMask)
	XkbSendIndicatorMap(client,new->indicators,&irep);
    if (reported&(XkbGBN_KeyNamesMask|XkbGBN_OtherNamesMask))
	XkbSendNames(client,new,&nrep);
    if (reported&XkbGBN_GeometryMask)
	XkbSendGeometry(client,new->geom,&grep,FALSE);
    if (rep.loaded) {
	XkbDescPtr		old_xkb;
	xkbNewKeyboardNotify 	nkn;
	int 			i,nG,nTG;
	old_xkb= xkb;
	xkb= new;
	dev->key->xkbInfo->desc= xkb;
	new= old_xkb; /* so it'll get freed automatically */

	*xkb->ctrls= *old_xkb->ctrls;
	for (nG=nTG=0,i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    nG= XkbKeyNumGroups(xkb,i);
	    if (nG>=XkbNumKbdGroups) {
		nTG= XkbNumKbdGroups;
		break;
	    }
	    if (nG>nTG) {
		nTG= nG;
	    }
	}
	xkb->ctrls->num_groups= nTG;

	nkn.deviceID= nkn.oldDeviceID= dev->id;
	nkn.minKeyCode= new->min_key_code;
	nkn.maxKeyCode= new->max_key_code;
	nkn.oldMinKeyCode= xkb->min_key_code;
	nkn.oldMaxKeyCode= xkb->max_key_code;
	nkn.requestMajor= XkbReqCode;
	nkn.requestMinor= X_kbGetKbdByName;
	nkn.changed= XkbNKN_KeycodesMask;
	if (geom_changed)
	    nkn.changed|= XkbNKN_GeometryMask;
	XkbSendNewKeyboardNotify(dev,&nkn);

        /* Update the map and LED info on the device itself, as well as
         * any slaves if it's an MD, or its MD if it's an SD and was the
         * last device used on that MD. */
        for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
            if (tmpd != dev && GetMaster(tmpd, MASTER_KEYBOARD) != dev &&
                (tmpd != master || dev != master->lastSlave))
                continue;

            if (tmpd != dev)
                XkbCopyDeviceKeymap(tmpd, dev);

            if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) {
                old_sli = tmpd->kbdfeed->xkb_sli;
                tmpd->kbdfeed->xkb_sli = NULL;
                sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0);
                if (sli) {
                    sli->explicitState = old_sli->explicitState;
                    sli->effectiveState = old_sli->effectiveState;
                }
                tmpd->kbdfeed->xkb_sli = sli;
                XkbFreeSrvLedInfo(old_sli);
            }
        }
    }
    if ((new!=NULL)&&(new!=xkb)) {
	XkbFreeKeyboard(new,XkbAllComponentsMask,TRUE);
	new= NULL;
    }
    XkbFreeComponentNames(&names, FALSE);
    return Success;
}

/***====================================================================***/

static int
ComputeDeviceLedInfoSize(	DeviceIntPtr		dev,
				unsigned int		what,
				XkbSrvLedInfoPtr	sli)
{
int			nNames,nMaps;
register unsigned 	n,bit;

    if (sli==NULL)
	return 0;
    nNames= nMaps= 0;
    if ((what&XkbXI_IndicatorNamesMask)==0)
	sli->namesPresent= 0;
    if ((what&XkbXI_IndicatorMapsMask)==0)
	sli->mapsPresent= 0;

    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
	if (sli->names && sli->names[n]!=None) {
	    sli->namesPresent|= bit;
	    nNames++;
	}
	if (sli->maps && XkbIM_InUse(&sli->maps[n])) {
	    sli->mapsPresent|= bit;
	    nMaps++;
	}
    }
    return (nNames*4)+(nMaps*SIZEOF(xkbIndicatorMapWireDesc));
}

static int 
CheckDeviceLedFBs(	DeviceIntPtr			dev,
			int				class,
			int				id,
			xkbGetDeviceInfoReply *		rep,
			ClientPtr			client)
{
int			nFBs= 0;
int			length= 0;
Bool			classOk;

    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
	else {
	    client->errorValue= _XkbErrCode2(XkbErr_BadClass,class);
	    return XkbKeyboardErrorCode;
	}
    }
    classOk= FALSE;
    if ((dev->kbdfeed)&&((class==KbdFeedbackClass)||(class==XkbAllXIClasses))) {
	KbdFeedbackPtr kf;
	classOk= TRUE;
	for (kf= dev->kbdfeed;(kf);kf=kf->next) {
	    if ((id!=XkbAllXIIds)&&(id!=XkbDfltXIId)&&(id!=kf->ctrl.id))
		continue;
	    nFBs++;
	    length+= SIZEOF(xkbDeviceLedsWireDesc);
	    if (!kf->xkb_sli)
		kf->xkb_sli= XkbAllocSrvLedInfo(dev,kf,NULL,0);
	    length+= ComputeDeviceLedInfoSize(dev,rep->present,kf->xkb_sli);
	    if (id!=XkbAllXIIds)
		break;
	}
    }
    if ((dev->leds)&&((class==LedFeedbackClass)||(class==XkbAllXIClasses))) {
	LedFeedbackPtr lf;
	classOk= TRUE;
	for (lf= dev->leds;(lf);lf=lf->next) {
	    if ((id!=XkbAllXIIds)&&(id!=XkbDfltXIId)&&(id!=lf->ctrl.id))
		continue;
	    nFBs++;
	    length+= SIZEOF(xkbDeviceLedsWireDesc);
	    if (!lf->xkb_sli)
		lf->xkb_sli= XkbAllocSrvLedInfo(dev,NULL,lf,0);
	    length+= ComputeDeviceLedInfoSize(dev,rep->present,lf->xkb_sli);
	    if (id!=XkbAllXIIds)
		break;
	}
    }
    if (nFBs>0) {
        rep->nDeviceLedFBs= nFBs;
        rep->length+= (length/4);
	return Success;
    }
    if (classOk) client->errorValue= _XkbErrCode2(XkbErr_BadId,id);
    else	 client->errorValue= _XkbErrCode2(XkbErr_BadClass,class);
    return XkbKeyboardErrorCode;
}

static int
SendDeviceLedInfo(	XkbSrvLedInfoPtr	sli,
			ClientPtr		client)
{
xkbDeviceLedsWireDesc	wire;
int			length;

    length= 0;
    wire.ledClass= 		sli->class;
    wire.ledID= 		sli->id;
    wire.namesPresent= 		sli->namesPresent;
    wire.mapsPresent=   	sli->mapsPresent;
    wire.physIndicators= 	sli->physIndicators;
    wire.state=			sli->effectiveState;
    if (client->swapped) {
	register int n;
	swaps(&wire.ledClass,n);
	swaps(&wire.ledID,n);
	swapl(&wire.namesPresent,n);
	swapl(&wire.mapsPresent,n);
	swapl(&wire.physIndicators,n);
	swapl(&wire.state,n);
    }
    WriteToClient(client,SIZEOF(xkbDeviceLedsWireDesc),(char *)&wire);
    length+= SIZEOF(xkbDeviceLedsWireDesc);
    if (sli->namesPresent|sli->mapsPresent) {
	register unsigned i,bit;
	if (sli->namesPresent) {
	    CARD32	awire;
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		if (sli->namesPresent&bit) {
		    awire= (CARD32)sli->names[i];
		    if (client->swapped) {
			register int n;
			swapl(&awire,n);
		    }
		    WriteToClient(client,4,(char *)&awire);
		    length+= 4;
		}
	    }
	}
	if (sli->mapsPresent) {
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		xkbIndicatorMapWireDesc	iwire;
		if (sli->mapsPresent&bit) {
		    iwire.flags= 	sli->maps[i].flags;
		    iwire.whichGroups=	sli->maps[i].which_groups;
		    iwire.groups=	sli->maps[i].groups;
		    iwire.whichMods=	sli->maps[i].which_mods;
		    iwire.mods=		sli->maps[i].mods.mask;
		    iwire.realMods=	sli->maps[i].mods.real_mods;
		    iwire.virtualMods=	sli->maps[i].mods.vmods;
		    iwire.ctrls= 	sli->maps[i].ctrls;
		    if (client->swapped) {
			register int n;
			swaps(&iwire.virtualMods,n);
			swapl(&iwire.ctrls,n);
		    }
		    WriteToClient(client,SIZEOF(xkbIndicatorMapWireDesc),
								(char *)&iwire);
		    length+= SIZEOF(xkbIndicatorMapWireDesc);
		}
	    }
	}
    }
    return length;
}

static int
SendDeviceLedFBs(	DeviceIntPtr	dev,
			int		class,
			int		id,
			unsigned	wantLength,
			ClientPtr	client)
{
int			length= 0;

    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
    }
    if ((dev->kbdfeed)&&
	((class==KbdFeedbackClass)||(class==XkbAllXIClasses))) {
	KbdFeedbackPtr kf;
	for (kf= dev->kbdfeed;(kf);kf=kf->next) {
	    if ((id==XkbAllXIIds)||(id==XkbDfltXIId)||(id==kf->ctrl.id)) {
		length+= SendDeviceLedInfo(kf->xkb_sli,client);
		if (id!=XkbAllXIIds)
		    break;
	    }
	}
    }
    if ((dev->leds)&&
	((class==LedFeedbackClass)||(class==XkbAllXIClasses))) {
	LedFeedbackPtr lf;
	for (lf= dev->leds;(lf);lf=lf->next) {
	    if ((id==XkbAllXIIds)||(id==XkbDfltXIId)||(id==lf->ctrl.id)) {
		length+= SendDeviceLedInfo(lf->xkb_sli,client);
		if (id!=XkbAllXIIds)
		    break;
	    }
	}
    }
    if (length==wantLength)
	 return Success;
    else return BadLength;
}

int
ProcXkbGetDeviceInfo(ClientPtr client)
{
DeviceIntPtr		dev;
xkbGetDeviceInfoReply	rep;
int			status,nDeviceLedFBs;
unsigned		length,nameLen;
CARD16			ledClass,ledID;
unsigned		wanted;
char *			str;

    REQUEST(xkbGetDeviceInfoReq);
    REQUEST_SIZE_MATCH(xkbGetDeviceInfoReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    wanted= stuff->wanted;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_LEGAL(0x01,wanted,XkbXI_AllDeviceFeaturesMask);

    if ((!dev->button)||((stuff->nBtns<1)&&(!stuff->allBtns)))
	wanted&= ~XkbXI_ButtonActionsMask;
    if ((!dev->kbdfeed)&&(!dev->leds))
	wanted&= ~XkbXI_IndicatorsMask;

    nameLen= XkbSizeCountedString(dev->name);
    memset((char *)&rep, 0, SIZEOF(xkbGetDeviceInfoReply));
    rep.type = X_Reply;
    rep.deviceID= dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = nameLen/4;
    rep.present = wanted;
    rep.supported = XkbXI_AllDeviceFeaturesMask;
    rep.unsupported = 0;
    rep.firstBtnWanted = rep.nBtnsWanted = 0;
    rep.firstBtnRtrn = rep.nBtnsRtrn = 0;
    if (dev->button)
	 rep.totalBtns= dev->button->numButtons;
    else rep.totalBtns= 0;
    rep.devType=	dev->xinput_type;
    rep.hasOwnState=	(dev->key && dev->key->xkbInfo);
    rep.nDeviceLedFBs = 0;
    if (dev->kbdfeed)	rep.dfltKbdFB= dev->kbdfeed->ctrl.id;
    else		rep.dfltKbdFB= XkbXINone;
    if (dev->leds)	rep.dfltLedFB= dev->leds->ctrl.id;
    else		rep.dfltLedFB= XkbXINone;

    ledClass= stuff->ledClass;
    ledID= stuff->ledID;

    rep.firstBtnWanted= rep.nBtnsWanted= 0;
    rep.firstBtnRtrn= rep.nBtnsRtrn= 0;
    if (wanted&XkbXI_ButtonActionsMask) {
	if (stuff->allBtns) {
	    stuff->firstBtn= 0;
	    stuff->nBtns= dev->button->numButtons;
	}

	if ((stuff->firstBtn+stuff->nBtns)>dev->button->numButtons) {
	    client->errorValue = _XkbErrCode4(0x02,dev->button->numButtons,
							stuff->firstBtn,
							stuff->nBtns);
	    return BadValue;
	}
	else {
	    rep.firstBtnWanted= stuff->firstBtn;
	    rep.nBtnsWanted= stuff->nBtns;
	    if (dev->button->xkb_acts!=NULL) {
		XkbAction *act;
		register int i;

		rep.firstBtnRtrn= stuff->firstBtn;
		rep.nBtnsRtrn= stuff->nBtns;
		act= &dev->button->xkb_acts[rep.firstBtnWanted];
		for (i=0;i<rep.nBtnsRtrn;i++,act++) {
		    if (act->type!=XkbSA_NoAction)
			break;
		}
		rep.firstBtnRtrn+=	i;
		rep.nBtnsRtrn-=		i;
		act= &dev->button->xkb_acts[rep.firstBtnRtrn+rep.nBtnsRtrn-1];
		for (i=0;i<rep.nBtnsRtrn;i++,act--) {
		    if (act->type!=XkbSA_NoAction)
			break;
		}
		rep.nBtnsRtrn-=		i;
	    }
	    rep.length+= (rep.nBtnsRtrn*SIZEOF(xkbActionWireDesc))/4;
	}
    }

    if (wanted&XkbXI_IndicatorsMask) {
	status= CheckDeviceLedFBs(dev,ledClass,ledID,&rep,client);
	if (status!=Success)
	    return status;
    }
    length= rep.length*4;
    nDeviceLedFBs = rep.nDeviceLedFBs;
    if (client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.present,n);
	swaps(&rep.supported,n);
	swaps(&rep.unsupported,n);
	swaps(&rep.nDeviceLedFBs,n);
	swapl(&rep.type,n);
	swaps(&rep.dfltKbdFB, n);
	swaps(&rep.dfltLedFB, n);
	swapl(&rep.devType, n);
    }
    WriteToClient(client,SIZEOF(xkbGetDeviceInfoReply), (char *)&rep);

    str= malloc(nameLen);
    if (!str) 
	return BadAlloc;
    XkbWriteCountedString(str,dev->name,client->swapped);
    WriteToClient(client,nameLen,str);
    free(str);
    length-= nameLen;

    if (rep.nBtnsRtrn>0) {
	int			sz;
	xkbActionWireDesc *	awire;
	sz= rep.nBtnsRtrn*SIZEOF(xkbActionWireDesc);
	awire= (xkbActionWireDesc *)&dev->button->xkb_acts[rep.firstBtnRtrn];
	WriteToClient(client,sz,(char *)awire);
	length-= sz;
    }
    if (nDeviceLedFBs>0) {
	status= SendDeviceLedFBs(dev,ledClass,ledID,length,client);
	if (status!=Success)
	    return status;
    }
    else if (length!=0)  {
	ErrorF("[xkb] Internal Error!  BadLength in ProcXkbGetDeviceInfo\n");
	ErrorF("[xkb]                  Wrote %d fewer bytes than expected\n",length);
	return BadLength;
    }
    return Success;
}

static char *
CheckSetDeviceIndicators(	char *		wire,
				DeviceIntPtr	dev,
				int		num,
				int *		status_rtrn,
				ClientPtr	client)
{
xkbDeviceLedsWireDesc *	ledWire;
int			i;
XkbSrvLedInfoPtr 	sli;

    ledWire= (xkbDeviceLedsWireDesc *)wire;
    for (i=0;i<num;i++) {
	if (client->swapped) {
	   register int n;
	   swaps(&ledWire->ledClass,n);
	   swaps(&ledWire->ledID,n);
	   swapl(&ledWire->namesPresent,n);
	   swapl(&ledWire->mapsPresent,n);
	   swapl(&ledWire->physIndicators,n);
	}

        sli= XkbFindSrvLedInfo(dev,ledWire->ledClass,ledWire->ledID,
							XkbXI_IndicatorsMask);
	if (sli!=NULL) {
	    register int n;
	    register unsigned bit;
	    int nMaps,nNames;
	    CARD32 *atomWire;
	    xkbIndicatorMapWireDesc *mapWire;

	    nMaps= nNames= 0;
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->namesPresent&bit)
		    nNames++;
		if (ledWire->mapsPresent&bit)
		    nMaps++;
	    }
	    atomWire= (CARD32 *)&ledWire[1];
	    if (nNames>0) {
		for (n=0;n<nNames;n++) {
		    if (client->swapped) {
			register int t;
			swapl(atomWire,t);
		    }
		    CHK_ATOM_OR_NONE3(((Atom)(*atomWire)),client->errorValue,
							*status_rtrn,NULL);
		    atomWire++;
		}
	    }
	    mapWire= (xkbIndicatorMapWireDesc *)atomWire;
	    if (nMaps>0) {
		for (n=0;n<nMaps;n++) {
		    if (client->swapped) {
			register int t;
			swaps(&mapWire->virtualMods,t);
			swapl(&mapWire->ctrls,t);
		    }
		    CHK_MASK_LEGAL3(0x21,mapWire->whichGroups,
						XkbIM_UseAnyGroup,
						client->errorValue,
						*status_rtrn,NULL);
		    CHK_MASK_LEGAL3(0x22,mapWire->whichMods,XkbIM_UseAnyMods,
						client->errorValue,
						*status_rtrn,NULL);
		    mapWire++;
		}
	    }
	    ledWire= (xkbDeviceLedsWireDesc *)mapWire;
	}
	else {
	    /* SHOULD NEVER HAPPEN */
	    return (char *)ledWire;
	}
    }
    return (char *)ledWire;
}

static char *
SetDeviceIndicators(	char *			wire,
			DeviceIntPtr		dev,
			unsigned		changed,
			int			num,
			int *			status_rtrn,
			ClientPtr		client,
			xkbExtensionDeviceNotify *ev)
{
xkbDeviceLedsWireDesc *		ledWire;
int				i;
XkbEventCauseRec		cause;
unsigned			namec,mapc,statec;
xkbExtensionDeviceNotify	ed;
XkbChangesRec			changes;
DeviceIntPtr			kbd;

    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    XkbSetCauseXkbReq(&cause,X_kbSetDeviceInfo,client);
    ledWire= (xkbDeviceLedsWireDesc *)wire;
    for (i=0;i<num;i++) {
	register int			n;
	register unsigned 		bit;
	CARD32 *			atomWire;
	xkbIndicatorMapWireDesc *	mapWire;
	XkbSrvLedInfoPtr		sli;

	namec= mapc= statec= 0;
    	sli= XkbFindSrvLedInfo(dev,ledWire->ledClass,ledWire->ledID,
						XkbXI_IndicatorMapsMask);
	if (!sli) {
	    /* SHOULD NEVER HAPPEN!! */
	    return (char *)ledWire;
	}

	atomWire= (CARD32 *)&ledWire[1];
	if (changed&XkbXI_IndicatorNamesMask) {
	    namec= sli->namesPresent|ledWire->namesPresent;
	    memset((char *)sli->names, 0, XkbNumIndicators*sizeof(Atom));
	}
	if (ledWire->namesPresent) {
	    sli->namesPresent= ledWire->namesPresent;
	    memset((char *)sli->names, 0, XkbNumIndicators*sizeof(Atom));
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->namesPresent&bit) {
		     sli->names[n]= (Atom)*atomWire;
		     if (sli->names[n]==None)
			ledWire->namesPresent&= ~bit;
		     atomWire++; 
		}
	    }
	}
	mapWire= (xkbIndicatorMapWireDesc *)atomWire;
	if (changed&XkbXI_IndicatorMapsMask) {
	    mapc= sli->mapsPresent|ledWire->mapsPresent;
	    sli->mapsPresent= ledWire->mapsPresent;
	    memset((char*)sli->maps, 0, XkbNumIndicators*sizeof(XkbIndicatorMapRec));
	}
	if (ledWire->mapsPresent) {
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->mapsPresent&bit) {
		    sli->maps[n].flags=		mapWire->flags;
		    sli->maps[n].which_groups=	mapWire->whichGroups;
		    sli->maps[n].groups=	mapWire->groups;
		    sli->maps[n].which_mods=	mapWire->whichMods;
		    sli->maps[n].mods.mask=	mapWire->mods;
		    sli->maps[n].mods.real_mods=mapWire->realMods;
		    sli->maps[n].mods.vmods=	mapWire->virtualMods;
		    sli->maps[n].ctrls=		mapWire->ctrls;
		    mapWire++; 
		}
	    }
	}
	if (changed&XkbXI_IndicatorStateMask) {
	    statec= sli->effectiveState^ledWire->state;
	    sli->explicitState&= ~statec;
	    sli->explicitState|= (ledWire->state&statec);
	}
	if (namec)
	    XkbApplyLedNameChanges(dev,sli,namec,&ed,&changes,&cause);
	if (mapc)
	    XkbApplyLedMapChanges(dev,sli,mapc,&ed,&changes,&cause);
	if (statec)
	    XkbApplyLedStateChanges(dev,sli,statec,&ed,&changes,&cause);

	kbd= dev;
	if ((sli->flags&XkbSLI_HasOwnState)==0)
	    kbd = inputInfo.keyboard;

	XkbFlushLedEvents(dev,kbd,sli,&ed,&changes,&cause);
	ledWire= (xkbDeviceLedsWireDesc *)mapWire;
    }
    return (char *)ledWire;
}


static int
_XkbSetDeviceInfo(ClientPtr client, DeviceIntPtr dev,
                  xkbSetDeviceInfoReq *stuff)
{
    char                       *wire;

    wire= (char *)&stuff[1];
    if (stuff->change&XkbXI_ButtonActionsMask) {
	if (!dev->button) {
	    client->errorValue = _XkbErrCode2(XkbErr_BadClass,ButtonClass);
	    return XkbKeyboardErrorCode;
	}
	if ((stuff->firstBtn+stuff->nBtns)>dev->button->numButtons) {
	    client->errorValue= _XkbErrCode4(0x02,stuff->firstBtn,stuff->nBtns,
						dev->button->numButtons);
	    return BadMatch;
	}
	wire+= (stuff->nBtns*SIZEOF(xkbActionWireDesc));
    }
    if (stuff->change&XkbXI_IndicatorsMask) {
	int status= Success;
	wire= CheckSetDeviceIndicators(wire,dev,stuff->nDeviceLedFBs,
							&status,client);
	if (status!=Success)
	    return status;
    }
    if (((wire-((char *)stuff))/4)!=stuff->length)
	return BadLength;

    return Success;
}

static int
_XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,
                       xkbSetDeviceInfoReq *stuff)
{
    char                       *wire;
    xkbExtensionDeviceNotify    ed;

    memset((char *)&ed, 0, SIZEOF(xkbExtensionDeviceNotify));
    ed.deviceID=	dev->id;
    wire= (char *)&stuff[1];
    if (stuff->change&XkbXI_ButtonActionsMask) {
	int			nBtns,sz,i;
	XkbAction *		acts;
	DeviceIntPtr		kbd;

	nBtns= dev->button->numButtons;
	acts= dev->button->xkb_acts;
	if (acts==NULL) {
	    acts= calloc(nBtns, sizeof(XkbAction));
	    if (!acts)
		return BadAlloc;
	    dev->button->xkb_acts= acts;
	}
	sz= stuff->nBtns*SIZEOF(xkbActionWireDesc);
	memcpy((char *)&acts[stuff->firstBtn],(char *)wire,sz);
	wire+= sz;
	ed.reason|=	XkbXI_ButtonActionsMask;
	ed.firstBtn=	stuff->firstBtn;
	ed.nBtns=	stuff->nBtns;

	if (dev->key)	kbd= dev;
	else		kbd= inputInfo.keyboard;
	acts= &dev->button->xkb_acts[stuff->firstBtn];
	for (i=0;i<stuff->nBtns;i++,acts++) {
	    if (acts->type!=XkbSA_NoAction)
		XkbSetActionKeyMods(kbd->key->xkbInfo->desc,acts,0);
	}
    }
    if (stuff->change&XkbXI_IndicatorsMask) {
	int status= Success;
	wire= SetDeviceIndicators(wire,dev,stuff->change,
				  stuff->nDeviceLedFBs, &status,client,&ed);
	if (status!=Success)
	    return status;
    }
    if ((stuff->change)&&(ed.reason))
	XkbSendExtensionDeviceNotify(dev,client,&ed);
    return Success;
}

int
ProcXkbSetDeviceInfo(ClientPtr client)
{
    DeviceIntPtr        dev;
    int                 rc;

    REQUEST(xkbSetDeviceInfoReq);
    REQUEST_AT_LEAST_SIZE(xkbSetDeviceInfoReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01,stuff->change,XkbXI_AllFeaturesMask);

    rc = _XkbSetDeviceInfoCheck(client, dev, stuff);

    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd || stuff->deviceSpec == XkbUseCorePtr)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if (((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev) &&
                ((stuff->deviceSpec == XkbUseCoreKbd && other->key) ||
                (stuff->deviceSpec == XkbUseCorePtr && other->button)))
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetDeviceInfoCheck(client, other, stuff);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* checks done, apply */
    rc = _XkbSetDeviceInfo(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd || stuff->deviceSpec == XkbUseCorePtr)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if (((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev) &&
                ((stuff->deviceSpec == XkbUseCoreKbd && other->key) ||
                (stuff->deviceSpec == XkbUseCorePtr && other->button)))
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetDeviceInfo(client, other, stuff);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbSetDebuggingFlags(ClientPtr client)
{
CARD32 				newFlags,newCtrls,extraLength;
xkbSetDebuggingFlagsReply 	rep;
int rc;

    REQUEST(xkbSetDebuggingFlagsReq);
    REQUEST_AT_LEAST_SIZE(xkbSetDebuggingFlagsReq);

    rc = XaceHook(XACE_SERVER_ACCESS, client, DixDebugAccess);
    if (rc != Success)
	return rc;

    newFlags=  xkbDebugFlags&(~stuff->affectFlags);
    newFlags|= (stuff->flags&stuff->affectFlags);
    newCtrls=  xkbDebugCtrls&(~stuff->affectCtrls);
    newCtrls|= (stuff->ctrls&stuff->affectCtrls);
    if (xkbDebugFlags || newFlags || stuff->msgLength) {
	ErrorF("[xkb] XkbDebug: Setting debug flags to 0x%lx\n",(long)newFlags);
	if (newCtrls!=xkbDebugCtrls)
	    ErrorF("[xkb] XkbDebug: Setting debug controls to 0x%lx\n",(long)newCtrls);
    }
    extraLength= (stuff->length<<2)-sz_xkbSetDebuggingFlagsReq;
    if (stuff->msgLength>0) {
	char *msg;
	if (extraLength<XkbPaddedSize(stuff->msgLength)) {
	    ErrorF("[xkb] XkbDebug: msgLength= %d, length= %ld (should be %d)\n",
			stuff->msgLength,(long)extraLength,
			XkbPaddedSize(stuff->msgLength));
	    return BadLength;
	}
	msg= (char *)&stuff[1];
	if (msg[stuff->msgLength-1]!='\0') {
	    ErrorF("[xkb] XkbDebug: message not null-terminated\n");
	    return BadValue;
	}
	ErrorF("[xkb] XkbDebug: %s\n",msg);
    }
    xkbDebugFlags = newFlags;
    xkbDebugCtrls = newCtrls;

    rep.type= X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.currentFlags = newFlags;
    rep.currentCtrls = newCtrls;
    rep.supportedFlags = ~0;
    rep.supportedCtrls = ~0;
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.currentFlags, n);
	swapl(&rep.currentCtrls, n);
	swapl(&rep.supportedFlags, n);
	swapl(&rep.supportedCtrls, n);
    }
    WriteToClient(client,SIZEOF(xkbSetDebuggingFlagsReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

static int
ProcXkbDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_kbUseExtension:
	return ProcXkbUseExtension(client);
    case X_kbSelectEvents:
	return ProcXkbSelectEvents(client);
    case X_kbBell:
	return ProcXkbBell(client);
    case X_kbGetState:
	return ProcXkbGetState(client);
    case X_kbLatchLockState:
	return ProcXkbLatchLockState(client);
    case X_kbGetControls:
	return ProcXkbGetControls(client);
    case X_kbSetControls:
	return ProcXkbSetControls(client);
    case X_kbGetMap:
	return ProcXkbGetMap(client);
    case X_kbSetMap:
	return ProcXkbSetMap(client);
    case X_kbGetCompatMap:
	return ProcXkbGetCompatMap(client);
    case X_kbSetCompatMap:
	return ProcXkbSetCompatMap(client);
    case X_kbGetIndicatorState:
	return ProcXkbGetIndicatorState(client);
    case X_kbGetIndicatorMap:
	return ProcXkbGetIndicatorMap(client);
    case X_kbSetIndicatorMap:
	return ProcXkbSetIndicatorMap(client);
    case X_kbGetNamedIndicator:
	return ProcXkbGetNamedIndicator(client);
    case X_kbSetNamedIndicator:
	return ProcXkbSetNamedIndicator(client);
    case X_kbGetNames:
	return ProcXkbGetNames(client);
    case X_kbSetNames:
	return ProcXkbSetNames(client);
    case X_kbGetGeometry:
	return ProcXkbGetGeometry(client);
    case X_kbSetGeometry:
	return ProcXkbSetGeometry(client);
    case X_kbPerClientFlags:
	return ProcXkbPerClientFlags(client);
    case X_kbListComponents:
	return ProcXkbListComponents(client);
    case X_kbGetKbdByName:
	return ProcXkbGetKbdByName(client);
    case X_kbGetDeviceInfo:
	return ProcXkbGetDeviceInfo(client);
    case X_kbSetDeviceInfo:
	return ProcXkbSetDeviceInfo(client);
    case X_kbSetDebuggingFlags:
	return ProcXkbSetDebuggingFlags(client);
    default:
	return BadRequest;
    }
}

static int
XkbClientGone(pointer data,XID id)
{
    DevicePtr	pXDev = (DevicePtr)data;

    if (!XkbRemoveResourceClient(pXDev,id)) {
	ErrorF("[xkb] Internal Error! bad RemoveResourceClient in XkbClientGone\n");
    }
    return 1;
}

void
XkbExtensionInit(void)
{
    ExtensionEntry *extEntry;

    RT_XKBCLIENT = CreateNewResourceType(XkbClientGone, "XkbClient");
    if (!RT_XKBCLIENT)
	return;

    if (!XkbInitPrivates())
	return;

    if ((extEntry = AddExtension(XkbName, XkbNumberEvents, XkbNumberErrors,
				 ProcXkbDispatch, SProcXkbDispatch,
				 NULL, StandardMinorOpcode))) {
	XkbReqCode = (unsigned char)extEntry->base;
	XkbEventBase = (unsigned char)extEntry->eventBase;
	XkbErrorBase = (unsigned char)extEntry->errorBase;
	XkbKeyboardErrorCode = XkbErrorBase+XkbKeyboard;
    }
    return;
}


#ifndef _XKB_H
#define _XKB_H

extern int ProcXkbUseExtension(ClientPtr client);
extern int ProcXkbSelectEvents(ClientPtr client);
extern int ProcXkbBell(ClientPtr client);
extern int ProcXkbGetState(ClientPtr client);
extern int ProcXkbLatchLockState(ClientPtr client);
extern int ProcXkbGetControls(ClientPtr client);
extern int ProcXkbSetControls(ClientPtr client);
extern int ProcXkbGetMap(ClientPtr client);
extern int ProcXkbSetMap(ClientPtr client);
extern int ProcXkbGetCompatMap(ClientPtr client);
extern int ProcXkbSetCompatMap(ClientPtr client);
extern int ProcXkbGetIndicatorState(ClientPtr client);
extern int ProcXkbGetIndicatorMap(ClientPtr client);
extern int ProcXkbSetIndicatorMap(ClientPtr client);
extern int ProcXkbGetNamedIndicator(ClientPtr client);
extern int ProcXkbSetNamedIndicator(ClientPtr client);
extern int ProcXkbGetNames(ClientPtr client);
extern int ProcXkbSetNames(ClientPtr client);
extern int ProcXkbGetGeometry(ClientPtr client);
extern int ProcXkbSetGeometry(ClientPtr client);
extern int ProcXkbPerClientFlags(ClientPtr client);
extern int ProcXkbListComponents(ClientPtr client);
extern int ProcXkbGetKbdByName(ClientPtr client);
extern int ProcXkbGetDeviceInfo(ClientPtr client);
extern int ProcXkbSetDeviceInfo(ClientPtr client);
extern int ProcXkbSetDebuggingFlags(ClientPtr client);

extern void XkbExtensionInit(void);
#endif
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "exglobals.h"
#include <X11/extensions/XIproto.h>
#include "inputstr.h"
#include "eventstr.h"
#include <xkbsrv.h>
#if !defined(WIN32)
#include <sys/time.h>
#endif

int	XkbDfltRepeatDelay=	660;
int	XkbDfltRepeatInterval=	40;

#define	DFLT_TIMEOUT_CTRLS (XkbAX_KRGMask|XkbStickyKeysMask|XkbMouseKeysMask)
#define	DFLT_TIMEOUT_OPTS  (XkbAX_IndicatorFBMask)

unsigned short	XkbDfltAccessXTimeout= 	120;
unsigned int	XkbDfltAccessXTimeoutMask= DFLT_TIMEOUT_CTRLS;
static unsigned int XkbDfltAccessXTimeoutValues= 0;
static unsigned int XkbDfltAccessXTimeoutOptionsMask= DFLT_TIMEOUT_OPTS;
static unsigned int XkbDfltAccessXTimeoutOptionsValues= 0;
unsigned int	XkbDfltAccessXFeedback= XkbAccessXFeedbackMask;
unsigned short	XkbDfltAccessXOptions=  XkbAX_AllOptionsMask & ~(XkbAX_IndicatorFBMask|XkbAX_SKReleaseFBMask|XkbAX_SKRejectFBMask);

void
AccessXComputeCurveFactor(XkbSrvInfoPtr xkbi,XkbControlsPtr ctrls)
{
    xkbi->mouseKeysCurve= 1.0+(((double)ctrls->mk_curve)*0.001);
    xkbi->mouseKeysCurveFactor= ( ((double)ctrls->mk_max_speed)/
	pow((double)ctrls->mk_time_to_max,xkbi->mouseKeysCurve));
    return;
}

void
AccessXInit(DeviceIntPtr keybd)
{
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;

    xkbi->shiftKeyCount= 0;
    xkbi->mouseKeysCounter= 0;
    xkbi->inactiveKey= 0;
    xkbi->slowKey= 0;
    xkbi->repeatKey= 0;
    xkbi->krgTimerActive= _OFF_TIMER;
    xkbi->beepType= _BEEP_NONE;
    xkbi->beepCount= 0;
    xkbi->mouseKeyTimer= NULL;
    xkbi->slowKeysTimer= NULL;
    xkbi->bounceKeysTimer= NULL;
    xkbi->repeatKeyTimer= NULL;
    xkbi->krgTimer= NULL;
    xkbi->beepTimer= NULL;
    ctrls->repeat_delay = XkbDfltRepeatDelay;
    ctrls->repeat_interval = XkbDfltRepeatInterval;
    ctrls->debounce_delay = 300;
    ctrls->slow_keys_delay = 300;
    ctrls->mk_delay = 160;
    ctrls->mk_interval = 40;
    ctrls->mk_time_to_max = 30;
    ctrls->mk_max_speed = 30;
    ctrls->mk_curve = 500;
    ctrls->mk_dflt_btn = 1;
    ctrls->ax_timeout = XkbDfltAccessXTimeout;
    ctrls->axt_ctrls_mask = XkbDfltAccessXTimeoutMask;
    ctrls->axt_ctrls_values = XkbDfltAccessXTimeoutValues;
    ctrls->axt_opts_mask = XkbDfltAccessXTimeoutOptionsMask;
    ctrls->axt_opts_values = XkbDfltAccessXTimeoutOptionsValues;
    if (XkbDfltAccessXTimeout)
	ctrls->enabled_ctrls |= XkbAccessXTimeoutMask;
    else
	ctrls->enabled_ctrls &= ~XkbAccessXTimeoutMask;
    ctrls->enabled_ctrls |= XkbDfltAccessXFeedback;
    ctrls->ax_options = XkbDfltAccessXOptions; 
    AccessXComputeCurveFactor(xkbi,ctrls);
    return;
}

/************************************************************************/
/*									*/
/* AccessXKeyboardEvent							*/
/*									*/
/*	Generate a synthetic keyboard event.				*/
/*									*/
/************************************************************************/
static void 
AccessXKeyboardEvent(DeviceIntPtr	keybd,
				 int		type,
				 BYTE		keyCode,
				 Bool		isRepeat)
{
    DeviceEvent event;
    memset(&event, 0, sizeof(DeviceEvent));
    event.header = ET_Internal;
    event.type = type;
    event.detail.key = keyCode;
    event.time = GetTimeInMillis();
    event.length = sizeof(DeviceEvent);
    event.key_repeat = isRepeat;
    event.sourceid = keybd->id;
    event.deviceid = keybd->id;

    if (xkbDebugFlags&0x8) {
	DebugF("[xkb] AXKE: Key %d %s\n", keyCode,
               (event.type == ET_KeyPress ? "down" : "up"));
    }

    XkbProcessKeyboardEvent(&event, keybd);
    return;
} /* AccessXKeyboardEvent */

/************************************************************************/
/*									*/
/* AccessXKRGTurnOn							*/
/*									*/
/*	Turn the keyboard response group on.				*/
/*									*/
/************************************************************************/
static void
AccessXKRGTurnOn(DeviceIntPtr dev,CARD16 KRGControl,xkbControlsNotify	*pCN)
{
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old= *ctrls;
    ctrls->enabled_ctrls |= (KRGControl&XkbAX_KRGMask);
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_ON,KRGControl);
    return;
    
} /* AccessXKRGTurnOn */

/************************************************************************/
/*									*/
/* AccessXKRGTurnOff							*/
/*									*/
/*	Turn the keyboard response group off.				*/
/*									*/
/************************************************************************/
static void 
AccessXKRGTurnOff(DeviceIntPtr dev,xkbControlsNotify *pCN)
{
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old = *ctrls;
    ctrls->enabled_ctrls &= ~XkbAX_KRGMask;
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	unsigned changes= old.enabled_ctrls^ctrls->enabled_ctrls;
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_OFF,changes);
    }
    return;
    
} /* AccessXKRGTurnOff */

/************************************************************************/
/*									*/
/* AccessXStickyKeysTurnOn						*/
/*									*/
/*	Turn StickyKeys on.						*/
/*									*/
/************************************************************************/
static void
AccessXStickyKeysTurnOn(DeviceIntPtr dev,xkbControlsNotify *pCN)
{
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old = *ctrls;
    ctrls->enabled_ctrls |= XkbStickyKeysMask;
    xkbi->shiftKeyCount = 0;
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_ON,XkbStickyKeysMask);
    }
    return;
    
} /* AccessXStickyKeysTurnOn */

/************************************************************************/
/*									*/
/* AccessXStickyKeysTurnOff						*/
/*									*/
/*	Turn StickyKeys off.						*/
/*									*/
/************************************************************************/
static void
AccessXStickyKeysTurnOff(DeviceIntPtr dev,xkbControlsNotify *pCN)
{
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old = *ctrls;
    ctrls->enabled_ctrls &= ~XkbStickyKeysMask;
    xkbi->shiftKeyCount = 0;
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);

    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_OFF,XkbStickyKeysMask);
    }
#ifndef NO_CLEAR_LATCHES_FOR_STICKY_KEYS_OFF
    XkbClearAllLatchesAndLocks(dev,xkbi,FALSE,&cause);
#endif
    return;
} /* AccessXStickyKeysTurnOff */

static CARD32
AccessXKRGExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
XkbSrvInfoPtr		xkbi= ((DeviceIntPtr)arg)->key->xkbInfo;
xkbControlsNotify	cn;

    if (xkbi->krgTimerActive==_KRG_WARN_TIMER) {
	XkbDDXAccessXBeep((DeviceIntPtr)arg,_BEEP_SLOW_WARN,XkbStickyKeysMask);
	xkbi->krgTimerActive= _KRG_TIMER;
	return 4000;
    }
    xkbi->krgTimerActive= _OFF_TIMER;
    cn.keycode = 0;
    cn.eventType = 0;
    cn.requestMajor = 0;
    cn.requestMinor = 0;
    if (xkbi->desc->ctrls->enabled_ctrls&XkbSlowKeysMask)
	 AccessXKRGTurnOff((DeviceIntPtr)arg,&cn);
    else AccessXKRGTurnOn((DeviceIntPtr)arg,XkbSlowKeysMask,&cn);
    return 0;
}

static CARD32
AccessXRepeatKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
DeviceIntPtr    dev = (DeviceIntPtr) arg;
XkbSrvInfoPtr	xkbi = dev->key->xkbInfo;

    if (xkbi->repeatKey == 0)
	return 0;

    AccessXKeyboardEvent(dev, ET_KeyPress, xkbi->repeatKey, TRUE);

    return xkbi->desc->ctrls->repeat_interval;
}

void
AccessXCancelRepeatKey(XkbSrvInfoPtr xkbi,KeyCode key)
{
    if (xkbi->repeatKey==key)
	xkbi->repeatKey= 0;
    return;
}

static CARD32
AccessXSlowKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
DeviceIntPtr	keybd;
XkbSrvInfoPtr	xkbi;
XkbDescPtr	xkb;
XkbControlsPtr	ctrls;

    keybd= 	(DeviceIntPtr)arg;
    xkbi= 	keybd->key->xkbInfo;
    xkb= 	xkbi->desc;
    ctrls= 	xkb->ctrls;
    if (xkbi->slowKey!=0) {
	xkbAccessXNotify ev;
	KeySym *sym= XkbKeySymsPtr(xkb,xkbi->slowKey);
	ev.detail= XkbAXN_SKAccept;
	ev.keycode= xkbi->slowKey;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKAcceptFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_SLOW_ACCEPT,XkbSlowKeysMask);
	AccessXKeyboardEvent(keybd, ET_KeyPress,xkbi->slowKey,FALSE);
	/* check for magic sequences */
	if ((ctrls->enabled_ctrls&XkbAccessXKeysMask) &&
	    ((sym[0]==XK_Shift_R)||(sym[0]==XK_Shift_L)))
	    xkbi->shiftKeyCount++;

	/* Start repeating if necessary.  Stop autorepeating if the user
	 * presses a non-modifier key that doesn't autorepeat.
	 */
	if (keybd->kbdfeed->ctrl.autoRepeat && 
	    ((xkbi->slowKey != xkbi->mouseKey) || (!xkbi->mouseKeysAccel)) &&
	     (ctrls->enabled_ctrls&XkbRepeatKeysMask)) {
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,xkbi->slowKey)) {
		xkbi->repeatKey = xkbi->slowKey;
		xkbi->repeatKeyTimer= TimerSet(xkbi->repeatKeyTimer,
					0, ctrls->repeat_delay,
					AccessXRepeatKeyExpire, (pointer)keybd);
	    }
	}
    }
    return 0;
}

static CARD32
AccessXBounceKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
XkbSrvInfoPtr	xkbi= ((DeviceIntPtr)arg)->key->xkbInfo;

    xkbi->inactiveKey= 0;
    return 0;
}

static CARD32
AccessXTimeoutExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
DeviceIntPtr		dev = (DeviceIntPtr)arg;
XkbSrvInfoPtr		xkbi= dev->key->xkbInfo;
XkbControlsPtr		ctrls= xkbi->desc->ctrls;
XkbControlsRec		old;
xkbControlsNotify	cn;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    if (xkbi->lastPtrEventTime) {
	unsigned timeToWait = (ctrls->ax_timeout*1000);
	unsigned timeElapsed = (now-xkbi->lastPtrEventTime);

	if (timeToWait > timeElapsed)
	    return timeToWait - timeElapsed;
    }
    old= *ctrls;
    xkbi->shiftKeyCount= 0;
    ctrls->enabled_ctrls&= ~ctrls->axt_ctrls_mask;
    ctrls->enabled_ctrls|= 
	(ctrls->axt_ctrls_values&ctrls->axt_ctrls_mask);
    if (ctrls->axt_opts_mask) {
	ctrls->ax_options&= ~ctrls->axt_opts_mask;
	ctrls->ax_options|= (ctrls->axt_opts_values&ctrls->axt_opts_mask);
    }
    if (XkbComputeControlsNotify(dev,&old,ctrls,&cn,FALSE)) {
	cn.keycode = 0;
	cn.eventType = 0;
	cn.requestMajor = 0;
	cn.requestMinor = 0;
	XkbSendControlsNotify(dev,&cn);
    }
    XkbSetCauseUnknown(&cause);
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (ctrls->ax_options!=old.ax_options) {
	unsigned set,cleared,bell;
	set= ctrls->ax_options&(~old.ax_options);
	cleared= (~ctrls->ax_options)&old.ax_options;
	if (set && cleared)	bell= _BEEP_FEATURE_CHANGE;
	else if (set)		bell= _BEEP_FEATURE_ON;
	else 			bell= _BEEP_FEATURE_OFF;
	XkbDDXAccessXBeep(dev,bell,XkbAccessXTimeoutMask);
    }
    xkbi->krgTimerActive= _OFF_TIMER;
    return 0;
}


/************************************************************************/
/*									*/
/* AccessXFilterPressEvent						*/
/*									*/
/* Filter events before they get any further if SlowKeys is turned on.	*/
/* In addition, this routine handles the ever so popular magic key	*/
/* acts for turning various accessibility features on/off.		*/
/*									*/
/* Returns TRUE if this routine has discarded the event.		*/
/* Returns FALSE if the event needs further processing.			*/
/*									*/
/************************************************************************/
Bool
AccessXFilterPressEvent(	DeviceEvent*	event,
				DeviceIntPtr	keybd)
{
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;
Bool		ignoreKeyEvent = FALSE;
KeyCode		key = event->detail.key;
KeySym *	sym = XkbKeySymsPtr(xkbi->desc,key);

    if (ctrls->enabled_ctrls&XkbAccessXKeysMask) {
	/* check for magic sequences */
	if ((sym[0]==XK_Shift_R)||(sym[0]==XK_Shift_L)) {
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_SlowWarnFBMask)) {
		xkbi->krgTimerActive = _KRG_WARN_TIMER;
		xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 4000,
					AccessXKRGExpire, (pointer)keybd);
	    }
	    else {
		xkbi->krgTimerActive = _KRG_TIMER;
		xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 8000,
					AccessXKRGExpire, (pointer)keybd);
	    }
	    if (!(ctrls->enabled_ctrls & XkbSlowKeysMask)) {
		CARD32 now= GetTimeInMillis();
		if ((now-xkbi->lastShiftEventTime)>15000)
		     xkbi->shiftKeyCount= 1;
		else xkbi->shiftKeyCount++;
		xkbi->lastShiftEventTime= now;
	    }
	}
	else {
	    if (xkbi->krgTimerActive) {
		xkbi->krgTimer= TimerSet(xkbi->krgTimer,0, 0, NULL, NULL);
		xkbi->krgTimerActive= _OFF_TIMER;
	    }
	}
    }
	
    /* Don't transmit the KeyPress if SlowKeys is turned on;
     * The wakeup handler will synthesize one for us if the user
     * has held the key long enough.
     */
    if (ctrls->enabled_ctrls & XkbSlowKeysMask) {
	xkbAccessXNotify	ev;
	/* If key was already pressed, ignore subsequent press events
	 * from the server's autorepeat
	 */
	if(xkbi->slowKey == key)
	    return TRUE;
	ev.detail= XkbAXN_SKPress;
	ev.keycode= key;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKPressFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_SLOW_PRESS,XkbSlowKeysMask);
	xkbi->slowKey= key;
	xkbi->slowKeysTimer = TimerSet(xkbi->slowKeysTimer,
				 0, ctrls->slow_keys_delay,
				 AccessXSlowKeyExpire, (pointer)keybd);
	ignoreKeyEvent = TRUE;
    }

    /* Don't transmit the KeyPress if BounceKeys is turned on
     * and the user pressed the same key within a given time period
     * from the last release.
     */
    else if ((ctrls->enabled_ctrls & XkbBounceKeysMask) && 
					(key == xkbi->inactiveKey)) {
	if (XkbAX_NeedFeedback(ctrls,XkbAX_BKRejectFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_BOUNCE_REJECT,XkbBounceKeysMask);
	ignoreKeyEvent = TRUE;
    }

    /* Start repeating if necessary.  Stop autorepeating if the user
     * presses a non-modifier key that doesn't autorepeat.
     */
    if (XkbDDXUsesSoftRepeat(keybd)) {
	if ((keybd->kbdfeed->ctrl.autoRepeat) &&
		((ctrls->enabled_ctrls&(XkbSlowKeysMask|XkbRepeatKeysMask))==
							XkbRepeatKeysMask)) {
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,key)) {
		if (xkbDebugFlags&0x10)
		    DebugF("Starting software autorepeat...\n");
		if (xkbi->repeatKey == key)
		    ignoreKeyEvent = TRUE;
		else {
		    xkbi->repeatKey = key;
		    xkbi->repeatKeyTimer= TimerSet(xkbi->repeatKeyTimer,
			    0, ctrls->repeat_delay,
			    AccessXRepeatKeyExpire, (pointer)keybd);
		}
	    }
	}
    }
    
    /* Check for two keys being pressed at the same time.  This section
     * essentially says the following:
     *
     *	If StickyKeys is on, and a modifier is currently being held down,
     *  and one of the following is true:  the current key is not a modifier
     *  or the currentKey is a modifier, but not the only modifier being
     *  held down, turn StickyKeys off if the TwoKeys off ctrl is set.
     */
    if ((ctrls->enabled_ctrls & XkbStickyKeysMask) && 
				(xkbi->state.base_mods!=0) &&
				(XkbAX_NeedOption(ctrls,XkbAX_TwoKeysMask))) {
	xkbControlsNotify cn;
	cn.keycode = key;
	cn.eventType = KeyPress;
	cn.requestMajor = 0;
	cn.requestMinor = 0;
	AccessXStickyKeysTurnOff(keybd,&cn);
    }
    
    if (!ignoreKeyEvent)
	XkbProcessKeyboardEvent(event, keybd);
    return ignoreKeyEvent;
} /* AccessXFilterPressEvent */

/************************************************************************/
/*									*/
/* AccessXFilterReleaseEvent						*/
/*									*/
/* Filter events before they get any further if SlowKeys is turned on.	*/
/* In addition, this routine handles the ever so popular magic key	*/
/* acts for turning various accessibility features on/off.		*/
/*									*/
/* Returns TRUE if this routine has discarded the event.		*/
/* Returns FALSE if the event needs further processing.			*/
/*									*/
/************************************************************************/
Bool
AccessXFilterReleaseEvent(	DeviceEvent*	event,
				DeviceIntPtr	keybd)
{
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;
KeyCode		key = event->detail.key;
Bool		ignoreKeyEvent = FALSE;
    
    /* Don't transmit the KeyRelease if BounceKeys is on and
     * this is the release of a key that was ignored due to 
     * BounceKeys.
     */
    if (ctrls->enabled_ctrls & XkbBounceKeysMask) {
	if ((key!=xkbi->mouseKey)&&(!BitIsOn(keybd->key->down,key)))
	    ignoreKeyEvent = TRUE;
	xkbi->inactiveKey= key;
	xkbi->bounceKeysTimer= TimerSet(xkbi->bounceKeysTimer, 0,
					ctrls->debounce_delay,
					AccessXBounceKeyExpire, (pointer)keybd);
    }

    /* Don't transmit the KeyRelease if SlowKeys is turned on and
     * the user didn't hold the key long enough.  We know we passed
     * the key if the down bit was set by CoreProcessKeyboadEvent.
     */
    if (ctrls->enabled_ctrls & XkbSlowKeysMask) {
	xkbAccessXNotify	ev;
	unsigned		beep_type;
	ev.keycode= key;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	if (BitIsOn(keybd->key->down,key) || (xkbi->mouseKey == key)) {
	    ev.detail= XkbAXN_SKRelease;
	    beep_type= _BEEP_SLOW_RELEASE;
	}
	else {
	    ev.detail= XkbAXN_SKReject;
	    beep_type= _BEEP_SLOW_REJECT;
	    ignoreKeyEvent = TRUE;
	}
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKRejectFBMask)) {
	    XkbDDXAccessXBeep(keybd,beep_type,XkbSlowKeysMask);
	}
	if (xkbi->slowKey==key)
	    xkbi->slowKey= 0;
    }

    /* Stop Repeating if the user releases the key that is currently
     * repeating.
     */
    if (xkbi->repeatKey==key) {
	xkbi->repeatKey= 0;
    }

    if ((ctrls->enabled_ctrls&XkbAccessXTimeoutMask)&&(ctrls->ax_timeout>0)) {
	xkbi->lastPtrEventTime= 0;
	xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 
					ctrls->ax_timeout*1000,
					AccessXTimeoutExpire, (pointer)keybd);
	xkbi->krgTimerActive= _ALL_TIMEOUT_TIMER;
    }
    else if (xkbi->krgTimerActive!=_OFF_TIMER) {
	xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 0, NULL, NULL);
	xkbi->krgTimerActive= _OFF_TIMER;
    }
	
    /* Keep track of how many times the Shift key has been pressed.
     * If it has been pressed and released 5 times in a row, toggle
     * the state of StickyKeys.
     */
    if ((!ignoreKeyEvent)&&(xkbi->shiftKeyCount)) {
	KeySym *pSym= XkbKeySymsPtr(xkbi->desc,key);
	if ((pSym[0]!=XK_Shift_L)&&(pSym[0]!=XK_Shift_R)) {
	    xkbi->shiftKeyCount= 0;
	}
	else if (xkbi->shiftKeyCount>=5) {
	     xkbControlsNotify cn;
	     cn.keycode = key;
	     cn.eventType = KeyPress;
	     cn.requestMajor = 0;
	     cn.requestMinor = 0;
	     if (ctrls->enabled_ctrls & XkbStickyKeysMask)
		AccessXStickyKeysTurnOff(keybd,&cn);
	     else
		AccessXStickyKeysTurnOn(keybd,&cn);
	     xkbi->shiftKeyCount= 0;
	}
    }
    
    if (!ignoreKeyEvent)
	XkbProcessKeyboardEvent(event, keybd);
    return ignoreKeyEvent;
    
} /* AccessXFilterReleaseEvent */

/************************************************************************/
/*									*/
/* ProcessPointerEvent							*/
/*									*/
/* This routine merely sets the shiftKeyCount and clears the keyboard   */
/* response group timer (if necessary) on a mouse event.  This is so	*/
/* multiple shifts with just the mouse and shift-drags with the mouse	*/
/* don't accidentally turn on StickyKeys or the Keyboard Response Group.*/
/*									*/
/************************************************************************/
extern int xkbDevicePrivateIndex;
extern void xkbUnwrapProc(DeviceIntPtr, DeviceHandleProc, pointer);
void
ProcessPointerEvent(	InternalEvent   *ev,
			DeviceIntPtr    mouse)
{
DeviceIntPtr	dev;
XkbSrvInfoPtr	xkbi = NULL;
unsigned 	changed = 0;
ProcessInputProc backupproc;
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(mouse);
DeviceEvent     *event = &ev->device_event;

    dev = IsFloating(mouse) ? mouse : GetMaster(mouse, MASTER_KEYBOARD);

    if (dev && dev->key)
    {
	xkbi = dev->key->xkbInfo;
	xkbi->shiftKeyCount = 0;
	xkbi->lastPtrEventTime= event->time;
    }

    if (event->type == ET_ButtonPress) {
	    changed |= XkbPointerButtonMask;
    }
    else if (event->type == ET_ButtonRelease) {
	if (xkbi) {
	    xkbi->lockedPtrButtons&= ~(1 << (event->detail.key & 0x7));

            if (IsMaster(dev))
            {
                DeviceIntPtr source;
                int rc;
                rc = dixLookupDevice(&source, event->sourceid, serverClient, DixWriteAccess);
                if (rc != Success)
                    ErrorF("[xkb] bad sourceid '%d' on button release event.\n", event->sourceid);
                else if (!IsXTestDevice(source, GetMaster(dev, MASTER_POINTER)))
                    XkbFakeDeviceButton(dev, FALSE, event->detail.key);
            }
	}

	changed |= XkbPointerButtonMask;
    }

    UNWRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr, backupproc);
    mouse->public.processInputProc(ev, mouse);
    COND_WRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr,
				     backupproc, xkbUnwrapProc);

    if (!xkbi)
	return;

    xkbi->state.ptr_buttons = (mouse->button) ? mouse->button->state : 0;
    
    /* clear any latched modifiers */
    if ( xkbi->state.latched_mods && (event->type == ET_ButtonRelease) ) {
	unsigned 		changed_leds;
	XkbStateRec		oldState;
	XkbSrvLedInfoPtr	sli;

	sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
	oldState= xkbi->state;
	XkbLatchModifiers(dev,0xFF,0x00);

	XkbComputeDerivedState(xkbi);
	changed |= XkbStateChangedFlags(&oldState,&xkbi->state);
	if (changed&sli->usedComponents) {
	    changed_leds= XkbIndicatorsToUpdate(dev,changed,FALSE);
	    if (changed_leds) {
		XkbEventCauseRec	cause;
		XkbSetCauseKey(&cause,(event->detail.key & 0x7), event->type);
		XkbUpdateIndicators(dev,changed_leds,TRUE,NULL,&cause);
	    }
	}
    }

    if (((xkbi->flags&_XkbStateNotifyInProgress)==0)&&(changed!=0)) {
	xkbStateNotify	sn;
	sn.keycode= event->detail.key;
	sn.eventType= event->type;
	sn.requestMajor = sn.requestMinor = 0;
	sn.changed= changed;
	XkbSendStateNotify(dev,&sn);
    }

} /* ProcessPointerEvent */




/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "exevents.h"
#include "eventstr.h"
#include <xkbsrv.h>
#include "xkb.h"
#include <ctype.h>
#include "mi.h"
#include "mipointer.h"
#include "inpututils.h"
#define EXTENSION_EVENT_BASE 64

DevPrivateKeyRec xkbDevicePrivateKeyRec;

void XkbFakeDeviceButton(DeviceIntPtr dev,Bool press,int button);
static void XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags,int x,int y);

void
xkbUnwrapProc(DeviceIntPtr device, DeviceHandleProc proc,
                   pointer data)
{
    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(device);
    ProcessInputProc backupproc;
    if(xkbPrivPtr->unwrapProc)
	xkbPrivPtr->unwrapProc = NULL;

    UNWRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr, backupproc);
    proc(device,data);
    COND_WRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr,
				 backupproc,xkbUnwrapProc);
}

Bool
XkbInitPrivates(void)
{
    return dixRegisterPrivateKey(&xkbDevicePrivateKeyRec, PRIVATE_DEVICE, sizeof(xkbDeviceInfoRec));
}

void
XkbSetExtension(DeviceIntPtr device, ProcessInputProc proc)
{
    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(device);
    WRAP_PROCESS_INPUT_PROC(device, xkbPrivPtr, proc, xkbUnwrapProc);
}

/***====================================================================***/

static XkbAction
_FixUpAction(XkbDescPtr xkb,XkbAction *act)
{
static XkbAction	fake;

    if (XkbIsPtrAction(act)&&(!(xkb->ctrls->enabled_ctrls&XkbMouseKeysMask))) {
	fake.type = XkbSA_NoAction;
	return fake;
    }
    if (xkb->ctrls->enabled_ctrls&XkbStickyKeysMask) {
	if (act->any.type==XkbSA_SetMods) {
	    fake.mods.type = XkbSA_LatchMods;
	    fake.mods.mask = act->mods.mask;
	    if (XkbAX_NeedOption(xkb->ctrls,XkbAX_LatchToLockMask))
		 fake.mods.flags= XkbSA_ClearLocks|XkbSA_LatchToLock;
	    else fake.mods.flags= XkbSA_ClearLocks;
	    return fake;
	}
	if (act->any.type==XkbSA_SetGroup) {
	    fake.group.type = XkbSA_LatchGroup;
	    if (XkbAX_NeedOption(xkb->ctrls,XkbAX_LatchToLockMask))
		 fake.group.flags= XkbSA_ClearLocks|XkbSA_LatchToLock;
	    else fake.group.flags= XkbSA_ClearLocks;
	    XkbSASetGroup(&fake.group,XkbSAGroup(&act->group));
	    return fake;
	}
    }
    return *act;
}

static XkbAction
XkbGetKeyAction(XkbSrvInfoPtr xkbi,XkbStatePtr xkbState,CARD8 key)
{
int			effectiveGroup;
int			col;
XkbDescPtr		xkb;
XkbKeyTypePtr		type;
XkbAction *		pActs;
static XkbAction 	fake;

    xkb= xkbi->desc;
    if (!XkbKeyHasActions(xkb,key) || !XkbKeycodeInRange(xkb,key)) {
	fake.type = XkbSA_NoAction;
	return fake;
    }
    pActs= XkbKeyActionsPtr(xkb,key);
    col= 0;

    effectiveGroup = XkbGetEffectiveGroup(xkbi, xkbState, key);
    if (effectiveGroup != XkbGroup1Index)
        col += (effectiveGroup * XkbKeyGroupsWidth(xkb, key));

    type= XkbKeyKeyType(xkb,key,effectiveGroup);
    if (type->map!=NULL) {
	register unsigned		i,mods;
	register XkbKTMapEntryPtr	entry;
	mods= xkbState->mods&type->mods.mask;
	for (entry= type->map,i=0;i<type->map_count;i++,entry++) {
	    if ((entry->active)&&(entry->mods.mask==mods)) {
		col+= entry->level;
		break;
	    }
	}
    }
    if (pActs[col].any.type==XkbSA_NoAction)
	return pActs[col];
    fake= _FixUpAction(xkb,&pActs[col]);
    return fake;
}

static XkbAction
XkbGetButtonAction(DeviceIntPtr kbd,DeviceIntPtr dev,int button)
{
XkbAction fake;
   if ((dev->button)&&(dev->button->xkb_acts)) {
	if (dev->button->xkb_acts[button-1].any.type!=XkbSA_NoAction) {
	    fake= _FixUpAction(kbd->key->xkbInfo->desc,
					&dev->button->xkb_acts[button-1]);
	    return fake;
	}
   }
   fake.any.type= XkbSA_NoAction;
   return fake;
}

/***====================================================================***/

#define	SYNTHETIC_KEYCODE	1
#define	BTN_ACT_FLAG		0x100

static int
_XkbFilterSetState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *pAction)
{
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = ((pAction->mods.mask&XkbSA_ClearLocks)!=0);
	filter->priv = 0;
	filter->filter = _XkbFilterSetState;
	if (pAction->type==XkbSA_SetMods) {
	    filter->upAction = *pAction;
	    xkbi->setMods= pAction->mods.mask;
	}
	else {
	    xkbi->groupChange = XkbSAGroup(&pAction->group);
	    if (pAction->group.flags&XkbSA_GroupAbsolute)
		xkbi->groupChange-= xkbi->state.base_group;
	    filter->upAction= *pAction;
	    XkbSASetGroup(&filter->upAction.group,xkbi->groupChange);
	}
    }
    else if (filter->keycode==keycode) {
	if (filter->upAction.type==XkbSA_SetMods) {
	    xkbi->clearMods = filter->upAction.mods.mask;
	    if (filter->upAction.mods.flags&XkbSA_ClearLocks) {
		xkbi->state.locked_mods&= ~filter->upAction.mods.mask;
	    }
	}
	else {
	    if (filter->upAction.group.flags&XkbSA_ClearLocks) {
		xkbi->state.locked_group = 0;
	    }
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.group);
	}
	filter->active = 0;
    }
    else {
	filter->upAction.mods.flags&= ~XkbSA_ClearLocks;
	filter->filterOthers = 0;
    }
    return 1;
}

#define	LATCH_KEY_DOWN	1
#define	LATCH_PENDING	2
#define	NO_LATCH	3

static int
_XkbFilterLatchState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{

    if (filter->keycode==0) {			/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 1;
	filter->priv = LATCH_KEY_DOWN;
	filter->filter = _XkbFilterLatchState;
	if (pAction->type==XkbSA_LatchMods) {
	    filter->upAction = *pAction;
	    xkbi->setMods = pAction->mods.mask;
	}
	else {
	    xkbi->groupChange = XkbSAGroup(&pAction->group);
	    if (pAction->group.flags&XkbSA_GroupAbsolute)
		 xkbi->groupChange-= xkbi->state.base_group;
	    filter->upAction= *pAction;
	    XkbSASetGroup(&filter->upAction.group,xkbi->groupChange);
	}
    }
    else if ( pAction && (filter->priv==LATCH_PENDING) ) {
	if (((1<<pAction->type)&XkbSA_BreakLatch)!=0) {
	    filter->active = 0;
	    if (filter->upAction.type==XkbSA_LatchMods)
		 xkbi->state.latched_mods&= ~filter->upAction.mods.mask;
	    else xkbi->state.latched_group-=XkbSAGroup(&filter->upAction.group);
	}
	else if ((pAction->type==filter->upAction.type)&&
		 (pAction->mods.flags==filter->upAction.mods.flags)&&
		 (pAction->mods.mask==filter->upAction.mods.mask)) {
	    if (filter->upAction.mods.flags&XkbSA_LatchToLock) {
		XkbControlsPtr ctrls= xkbi->desc->ctrls;
		if (filter->upAction.type==XkbSA_LatchMods)
		     pAction->mods.type= XkbSA_LockMods;
		else pAction->group.type= XkbSA_LockGroup;
		if (XkbAX_NeedFeedback(ctrls,XkbAX_StickyKeysFBMask)&&
		    		(ctrls->enabled_ctrls&XkbStickyKeysMask)) {
		    XkbDDXAccessXBeep(xkbi->device,_BEEP_STICKY_LOCK,
						XkbStickyKeysMask);
		}
	    }
	    else {
		if (filter->upAction.type==XkbSA_LatchMods)
		     pAction->mods.type= XkbSA_SetMods;
		else pAction->group.type= XkbSA_SetGroup;
	    }
	    if (filter->upAction.type==XkbSA_LatchMods)
		 xkbi->state.latched_mods&= ~filter->upAction.mods.mask;
	    else xkbi->state.latched_group-=XkbSAGroup(&filter->upAction.group);
	    filter->active = 0;
	}
    }
    else if (filter->keycode==keycode) {	/* release */
	XkbControlsPtr	ctrls= xkbi->desc->ctrls;
	int		needBeep;
	int		beepType= _BEEP_NONE;

	needBeep= ((ctrls->enabled_ctrls&XkbStickyKeysMask)&&
			XkbAX_NeedFeedback(ctrls,XkbAX_StickyKeysFBMask));
	if (filter->upAction.type==XkbSA_LatchMods) {
	    xkbi->clearMods = filter->upAction.mods.mask;
	    if ((filter->upAction.mods.flags&XkbSA_ClearLocks)&&
		 (xkbi->clearMods&xkbi->state.locked_mods)==xkbi->clearMods) {
		xkbi->state.locked_mods&= ~xkbi->clearMods;
		filter->priv= NO_LATCH;
		beepType= _BEEP_STICKY_UNLOCK;
	    }
	}
	else {
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.group);
	    if ((filter->upAction.group.flags&XkbSA_ClearLocks)&&
						(xkbi->state.locked_group)) {
		xkbi->state.locked_group = 0;
		filter->priv = NO_LATCH;
		beepType= _BEEP_STICKY_UNLOCK;
	    }
	}
	if (filter->priv==NO_LATCH) {
	    filter->active= 0;
	}
	else {
	    filter->priv= LATCH_PENDING;
	    if (filter->upAction.type==XkbSA_LatchMods) {
		xkbi->state.latched_mods |= filter->upAction.mods.mask;
		needBeep = xkbi->state.latched_mods ? needBeep : 0;
		xkbi->state.latched_mods |= filter->upAction.mods.mask;
	    }
	    else {
		xkbi->state.latched_group+= XkbSAGroup(&filter->upAction.group);
	    }
	    if (needBeep && (beepType==_BEEP_NONE))
		beepType= _BEEP_STICKY_LATCH;
	}
	if (needBeep && (beepType!=_BEEP_NONE))
	    XkbDDXAccessXBeep(xkbi->device,beepType,XkbStickyKeysMask);
    }
    else if (filter->priv==LATCH_KEY_DOWN) {
	filter->priv= NO_LATCH;
	filter->filterOthers = 0;
    }
    return 1;
}

static int
_XkbFilterLockState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    if (pAction&&(pAction->type==XkbSA_LockGroup)) {
	if (pAction->group.flags&XkbSA_GroupAbsolute)
	     xkbi->state.locked_group= XkbSAGroup(&pAction->group);
	else xkbi->state.locked_group+= XkbSAGroup(&pAction->group);
	return 1;
    }
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv = 0;
	filter->filter = _XkbFilterLockState;
	filter->upAction = *pAction;
	xkbi->state.locked_mods^= pAction->mods.mask;
	xkbi->setMods = pAction->mods.mask;
    }
    else if (filter->keycode==keycode) {
	filter->active = 0;
	xkbi->clearMods = filter->upAction.mods.mask;
    }
    return 1;
}

#define	ISO_KEY_DOWN		0
#define	NO_ISO_LOCK		1

static int
_XkbFilterISOLock(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{

    if (filter->keycode==0) {		/* initial press */
	CARD8	flags= pAction->iso.flags;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 1;
	filter->priv = ISO_KEY_DOWN;
	filter->upAction = *pAction;
	filter->filter = _XkbFilterISOLock;
	if (flags&XkbSA_ISODfltIsGroup) {
	    xkbi->groupChange = XkbSAGroup(&pAction->iso);
	    xkbi->setMods = 0;
	}
	else {
	    xkbi->setMods = pAction->iso.mask;
	    xkbi->groupChange = 0;
	}
	if ((!(flags&XkbSA_ISONoAffectMods))&&(xkbi->state.base_mods)) {
	    filter->priv= NO_ISO_LOCK;
	    xkbi->state.locked_mods^= xkbi->state.base_mods;
	}
	if ((!(flags&XkbSA_ISONoAffectGroup))&&(xkbi->state.base_group)) {
/* 6/22/93 (ef) -- lock groups if group key is down first */
	}
	if (!(flags&XkbSA_ISONoAffectPtr)) {
/* 6/22/93 (ef) -- lock mouse buttons if they're down */
	}
    }
    else if (filter->keycode==keycode) {
	CARD8	flags= filter->upAction.iso.flags;

	if (flags&XkbSA_ISODfltIsGroup) {
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.iso);
	    xkbi->clearMods = 0;
	    if (filter->priv==ISO_KEY_DOWN)
		xkbi->state.locked_group+= XkbSAGroup(&filter->upAction.iso);
	}
	else {
	    xkbi->clearMods= filter->upAction.iso.mask;
	    xkbi->groupChange= 0;
	    if (filter->priv==ISO_KEY_DOWN)
		xkbi->state.locked_mods^= filter->upAction.iso.mask;
	}
	filter->active = 0;
    }
    else if (pAction) {
	CARD8	flags= filter->upAction.iso.flags;

	switch (pAction->type) {
	    case XkbSA_SetMods: case XkbSA_LatchMods:
		if (!(flags&XkbSA_ISONoAffectMods)) {
		    pAction->type= XkbSA_LockMods;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_SetGroup: case XkbSA_LatchGroup:
		if (!(flags&XkbSA_ISONoAffectGroup)) {
		    pAction->type= XkbSA_LockGroup;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_PtrBtn:
		if (!(flags&XkbSA_ISONoAffectPtr)) {
		     pAction->type= XkbSA_LockPtrBtn;
		     filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_SetControls:
		if (!(flags&XkbSA_ISONoAffectCtrls)) {
		    pAction->type= XkbSA_LockControls;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	}
    }
    return 1;
}


static CARD32
_XkbPtrAccelExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
XkbSrvInfoPtr	xkbi= (XkbSrvInfoPtr)arg;
XkbControlsPtr	ctrls= xkbi->desc->ctrls;
int		dx,dy;

    if (xkbi->mouseKey==0)
	return 0;

    if (xkbi->mouseKeysAccel) {
	if ((xkbi->mouseKeysCounter)<ctrls->mk_time_to_max) {
	    double step;
	    xkbi->mouseKeysCounter++;
	    step= xkbi->mouseKeysCurveFactor*
		 pow((double)xkbi->mouseKeysCounter,xkbi->mouseKeysCurve);
	    if (xkbi->mouseKeysDX<0)
		 dx= floor( ((double)xkbi->mouseKeysDX)*step );
	    else dx=  ceil( ((double)xkbi->mouseKeysDX)*step );
	    if (xkbi->mouseKeysDY<0)
		 dy= floor( ((double)xkbi->mouseKeysDY)*step );
	    else dy=  ceil( ((double)xkbi->mouseKeysDY)*step );
	}
	else {
	    dx= xkbi->mouseKeysDX*ctrls->mk_max_speed;
	    dy= xkbi->mouseKeysDY*ctrls->mk_max_speed;
	}
	if (xkbi->mouseKeysFlags&XkbSA_MoveAbsoluteX)
	    dx= xkbi->mouseKeysDX;
	if (xkbi->mouseKeysFlags&XkbSA_MoveAbsoluteY)
	    dy= xkbi->mouseKeysDY;
    }
    else {
	dx= xkbi->mouseKeysDX;
	dy= xkbi->mouseKeysDY;
    }
    XkbFakePointerMotion(xkbi->device, xkbi->mouseKeysFlags,dx,dy);
    return xkbi->desc->ctrls->mk_interval;
}

static int
_XkbFilterPointerMove(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
int	x,y;
Bool	accel;

    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterPointerMove;
	filter->upAction= *pAction;
	xkbi->mouseKeysCounter= 0;
	xkbi->mouseKey= keycode;
	accel= ((pAction->ptr.flags&XkbSA_NoAcceleration)==0);
	x= XkbPtrActionX(&pAction->ptr);
	y= XkbPtrActionY(&pAction->ptr);
	XkbFakePointerMotion(xkbi->device, pAction->ptr.flags,x,y);
	AccessXCancelRepeatKey(xkbi,keycode);
	xkbi->mouseKeysAccel= accel&&
		(xkbi->desc->ctrls->enabled_ctrls&XkbMouseKeysAccelMask);
	xkbi->mouseKeysFlags= pAction->ptr.flags;
	xkbi->mouseKeysDX= XkbPtrActionX(&pAction->ptr);
	xkbi->mouseKeysDY= XkbPtrActionY(&pAction->ptr);
	xkbi->mouseKeyTimer= TimerSet(xkbi->mouseKeyTimer, 0,
				xkbi->desc->ctrls->mk_delay,
				_XkbPtrAccelExpire,(pointer)xkbi);
    }
    else if (filter->keycode==keycode) {
	filter->active = 0;
	if (xkbi->mouseKey==keycode) {
	    xkbi->mouseKey= 0;
	    xkbi->mouseKeyTimer= TimerSet(xkbi->mouseKeyTimer, 0, 0,
							NULL, NULL);
	}
    }
    return 0;
}

static int
_XkbFilterPointerBtn(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    if (filter->keycode==0) {		/* initial press */
	int	button= pAction->btn.button;

	if (button==XkbSA_UseDfltButton)
	    button = xkbi->desc->ctrls->mk_dflt_btn;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterPointerBtn;
	filter->upAction= *pAction;
	filter->upAction.btn.button= button;
	switch (pAction->type) {
	    case XkbSA_LockPtrBtn:
		if (((xkbi->lockedPtrButtons&(1<<button))==0)&&
			((pAction->btn.flags&XkbSA_LockNoLock)==0)) {
		    xkbi->lockedPtrButtons|= (1<<button);
		    AccessXCancelRepeatKey(xkbi,keycode);
		    XkbFakeDeviceButton(xkbi->device, 1, button);
		    filter->upAction.type= XkbSA_NoAction;
		}
		break;
	    case XkbSA_PtrBtn:
		{
		    register int i,nClicks;
		    AccessXCancelRepeatKey(xkbi,keycode);
		    if (pAction->btn.count>0) {
			nClicks= pAction->btn.count;
			for (i=0;i<nClicks;i++) {
			    XkbFakeDeviceButton(xkbi->device, 1, button);
			    XkbFakeDeviceButton(xkbi->device, 0, button);
			}
			filter->upAction.type= XkbSA_NoAction;
		    }
		    else XkbFakeDeviceButton(xkbi->device, 1, button);
		}
		break;
	    case XkbSA_SetPtrDflt:
		{
		    XkbControlsPtr	ctrls= xkbi->desc->ctrls;
		    XkbControlsRec	old;
		    xkbControlsNotify	cn;

		    old= *ctrls;
		    AccessXCancelRepeatKey(xkbi,keycode);
		    switch (pAction->dflt.affect) {
			case XkbSA_AffectDfltBtn:
			    if (pAction->dflt.flags&XkbSA_DfltBtnAbsolute)
				ctrls->mk_dflt_btn= 
					XkbSAPtrDfltValue(&pAction->dflt);
			    else {
				ctrls->mk_dflt_btn+=
					XkbSAPtrDfltValue(&pAction->dflt);
				if (ctrls->mk_dflt_btn>5)
				    ctrls->mk_dflt_btn= 5;
				else if (ctrls->mk_dflt_btn<1)
				    ctrls->mk_dflt_btn= 1;
			    }
			    break;
			default:
			    ErrorF(
		"Attempt to change unknown pointer default (%d) ignored\n",
							pAction->dflt.affect);
			    break;
		    }
		    if (XkbComputeControlsNotify(xkbi->device,
						&old,xkbi->desc->ctrls,
						&cn,FALSE)) {
			cn.keycode = keycode;
                        /* XXX: what about DeviceKeyPress? */
			cn.eventType = KeyPress;
			cn.requestMajor = 0;
			cn.requestMinor = 0;
			XkbSendControlsNotify(xkbi->device,&cn);
		    }
		}
		break;
	}
    }
    else if (filter->keycode==keycode) {
	int	button= filter->upAction.btn.button;

	switch (filter->upAction.type) {
	    case XkbSA_LockPtrBtn:
		if (((filter->upAction.btn.flags&XkbSA_LockNoUnlock)!=0)||
				((xkbi->lockedPtrButtons&(1<<button))==0)) {
		    break;
		}
		xkbi->lockedPtrButtons&= ~(1<<button);

		if (IsMaster(xkbi->device))
		{
		    XkbMergeLockedPtrBtns(xkbi->device);
                    /* One SD still has lock set, don't post event */
		    if ((xkbi->lockedPtrButtons & (1 << button)) != 0)
			break;
		}

		/* fallthrough */
	    case XkbSA_PtrBtn:
		XkbFakeDeviceButton(xkbi->device, 0, button);
		break;
	}
	filter->active = 0;
    }
    return 0;
}

static int
_XkbFilterControls(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
XkbControlsRec		old;
XkbControlsPtr		ctrls;
DeviceIntPtr		kbd;
unsigned int		change;
XkbEventCauseRec	cause;

    kbd= xkbi->device;
    ctrls= xkbi->desc->ctrls;
    old= *ctrls;
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	change= XkbActionCtrls(&pAction->ctrls);
	filter->priv = change;
	filter->filter = _XkbFilterControls;
	filter->upAction = *pAction;

	if (pAction->type==XkbSA_LockControls) {
	    filter->priv= (ctrls->enabled_ctrls&change);
	    change&= ~ctrls->enabled_ctrls;
	}

	if (change) {
	    xkbControlsNotify	cn;
	    XkbSrvLedInfoPtr	sli;

	    ctrls->enabled_ctrls|= change;
	    if (XkbComputeControlsNotify(kbd,&old,ctrls,&cn,FALSE)) {
		cn.keycode = keycode;
                /* XXX: what about DeviceKeyPress? */
		cn.eventType = KeyPress;
		cn.requestMajor = 0;
		cn.requestMinor = 0;
		XkbSendControlsNotify(kbd,&cn);
	    }

	    XkbSetCauseKey(&cause,keycode,KeyPress);

	    /* If sticky keys were disabled, clear all locks and latches */
	    if ((old.enabled_ctrls&XkbStickyKeysMask)&&
		(!(ctrls->enabled_ctrls&XkbStickyKeysMask))) {
		XkbClearAllLatchesAndLocks(kbd,xkbi,FALSE,&cause);
    	    }
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	    XkbUpdateIndicators(kbd,sli->usesControls,TRUE,NULL,&cause);
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
		XkbDDXAccessXBeep(kbd,_BEEP_FEATURE_ON,change);
	}
    }
    else if (filter->keycode==keycode) {
	change= filter->priv;
	if (change) {
	    xkbControlsNotify 	cn;
	    XkbSrvLedInfoPtr	sli;

	    ctrls->enabled_ctrls&= ~change;
	    if (XkbComputeControlsNotify(kbd,&old,ctrls,&cn,FALSE)) {
		cn.keycode = keycode;
		cn.eventType = KeyRelease;
		cn.requestMajor = 0;
		cn.requestMinor = 0;
		XkbSendControlsNotify(kbd,&cn);
	    }

	    XkbSetCauseKey(&cause,keycode,KeyRelease);
	    /* If sticky keys were disabled, clear all locks and latches */
	    if ((old.enabled_ctrls&XkbStickyKeysMask)&&
		(!(ctrls->enabled_ctrls&XkbStickyKeysMask))) {
		XkbClearAllLatchesAndLocks(kbd,xkbi,FALSE,&cause);
    	    }
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	    XkbUpdateIndicators(kbd,sli->usesControls,TRUE,NULL,&cause);
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
		XkbDDXAccessXBeep(kbd,_BEEP_FEATURE_OFF,change);
	}
	filter->keycode= 0;
	filter->active= 0;
    }
    return 1;
}

static int
_XkbFilterActionMessage(XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
XkbMessageAction *	pMsg;
DeviceIntPtr		kbd;

    kbd= xkbi->device;
    if (filter->keycode==0) {		/* initial press */
	pMsg= &pAction->msg;
	if ((pMsg->flags&XkbSA_MessageOnRelease)||
	    ((pMsg->flags&XkbSA_MessageGenKeyEvent)==0)) {
	    filter->keycode = keycode;
	    filter->active = 1;
	    filter->filterOthers = 0;
	    filter->priv = 0;
	    filter->filter = _XkbFilterActionMessage;
	    filter->upAction = *pAction;
	}
	if (pMsg->flags&XkbSA_MessageOnPress)  {
	    xkbActionMessage	msg;

	    msg.keycode= keycode;
	    msg.press= 1;
	    msg.keyEventFollows=((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
	    memcpy((char *)msg.message,
				(char *)pMsg->message,XkbActionMessageLength);
	    XkbSendActionMessage(kbd,&msg);
	}
	return ((pAction->msg.flags&XkbSA_MessageGenKeyEvent)!=0);
    }
    else if (filter->keycode==keycode) {
	pMsg= &filter->upAction.msg;
	if (pMsg->flags&XkbSA_MessageOnRelease) {
	    xkbActionMessage	msg;

	    msg.keycode= keycode;
	    msg.press= 0;
	    msg.keyEventFollows=((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
	    memcpy((char *)msg.message,(char *)pMsg->message,
						XkbActionMessageLength);
	    XkbSendActionMessage(kbd,&msg);
	}
	filter->keycode= 0;
	filter->active= 0;
	return ((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
    }
    return 0;
}

static int
_XkbFilterRedirectKey(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
DeviceEvent	ev;
int		x,y;
XkbStateRec	old;
unsigned	mods,mask;
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(xkbi->device);
ProcessInputProc backupproc;

    /* never actually used uninitialised, but gcc isn't smart enough
     * to work that out. */
    memset(&old, 0, sizeof(old));
    memset(&ev, 0, sizeof(ev));

    if ((filter->keycode!=0)&&(filter->keycode!=keycode))
	return 1;

    GetSpritePosition(xkbi->device, &x,&y);
    ev.header = ET_Internal;
    ev.length = sizeof(DeviceEvent);
    ev.time = GetTimeInMillis();
    ev.root_x = x;
    ev.root_y = y;

    if (filter->keycode==0) {		/* initial press */
	if ((pAction->redirect.new_key<xkbi->desc->min_key_code)||
	    (pAction->redirect.new_key>xkbi->desc->max_key_code)) {
	    return 1;
	}
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv = 0;
	filter->filter = _XkbFilterRedirectKey;
	filter->upAction = *pAction;

        ev.type = ET_KeyPress;
        ev.detail.key = pAction->redirect.new_key;

        mask= XkbSARedirectVModsMask(&pAction->redirect);
        mods= XkbSARedirectVMods(&pAction->redirect);
        if (mask) XkbVirtualModsToReal(xkbi->desc,mask,&mask);
        if (mods) XkbVirtualModsToReal(xkbi->desc,mods,&mods);
        mask|= pAction->redirect.mods_mask;
        mods|= pAction->redirect.mods;

	if ( mask || mods ) {
	    old= xkbi->state;
	    xkbi->state.base_mods&= ~mask;
	    xkbi->state.base_mods|= (mods&mask);
	    xkbi->state.latched_mods&= ~mask;
	    xkbi->state.latched_mods|= (mods&mask);
	    xkbi->state.locked_mods&= ~mask;
	    xkbi->state.locked_mods|= (mods&mask);
	    XkbComputeDerivedState(xkbi);
	}

	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr, backupproc);
	xkbi->device->public.processInputProc((InternalEvent*)&ev, xkbi->device);
	COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr,
				     backupproc,xkbUnwrapProc);
	
	if ( mask || mods )
	    xkbi->state= old;
    }
    else if (filter->keycode==keycode) {

        ev.type = ET_KeyRelease;
        ev.detail.key = filter->upAction.redirect.new_key;

        mask= XkbSARedirectVModsMask(&filter->upAction.redirect);
        mods= XkbSARedirectVMods(&filter->upAction.redirect);
        if (mask) XkbVirtualModsToReal(xkbi->desc,mask,&mask);
        if (mods) XkbVirtualModsToReal(xkbi->desc,mods,&mods);
        mask|= filter->upAction.redirect.mods_mask;
        mods|= filter->upAction.redirect.mods;

	if ( mask || mods ) {
	    old= xkbi->state;
	    xkbi->state.base_mods&= ~mask;
	    xkbi->state.base_mods|= (mods&mask);
	    xkbi->state.latched_mods&= ~mask;
	    xkbi->state.latched_mods|= (mods&mask);
	    xkbi->state.locked_mods&= ~mask;
	    xkbi->state.locked_mods|= (mods&mask);
	    XkbComputeDerivedState(xkbi);
	}

	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr, backupproc);
	xkbi->device->public.processInputProc((InternalEvent*)&ev, xkbi->device);
	COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr,
				     backupproc,xkbUnwrapProc);

	if ( mask || mods )
	    xkbi->state= old;

	filter->keycode= 0;
	filter->active= 0;
    }
    return 0;
}

static int
_XkbFilterSwitchScreen(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    DeviceIntPtr dev = xkbi->device;
    if (dev == inputInfo.keyboard)
        return 0;

    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->filter = _XkbFilterSwitchScreen;
	AccessXCancelRepeatKey(xkbi, keycode);
	XkbDDXSwitchScreen(dev,keycode,pAction);
        return 0; 
    }
    else if (filter->keycode==keycode) {
	filter->active= 0;
        return 0; 
    }
    return 1;
}

static int
_XkbFilterXF86Private(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    DeviceIntPtr dev = xkbi->device;
    if (dev == inputInfo.keyboard)
        return 0;

    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->filter = _XkbFilterXF86Private;
	XkbDDXPrivate(dev,keycode,pAction);
        return 0; 
    }
    else if (filter->keycode==keycode) {
	filter->active= 0;
        return 0; 
    }
    return 1;
}


static int
_XkbFilterDeviceBtn(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
DeviceIntPtr	dev;
int		button;

    if (xkbi->device == inputInfo.keyboard)
        return 0;

    if (filter->keycode==0) {		/* initial press */
	_XkbLookupButtonDevice(&dev, pAction->devbtn.device, serverClient,
			       DixUnknownAccess, &button);
	if (!dev || !dev->public.on)
	    return 1;

	button= pAction->devbtn.button;
	if ((button<1)||(button>dev->button->numButtons))
	    return 1;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterDeviceBtn;
	filter->upAction= *pAction;
	switch (pAction->type) {
	    case XkbSA_LockDeviceBtn:
		if ((pAction->devbtn.flags&XkbSA_LockNoLock)||
		    BitIsOn(dev->button->down, button))
		    return 0;
		XkbFakeDeviceButton(dev,TRUE,button);
		filter->upAction.type= XkbSA_NoAction;
		break;
	    case XkbSA_DeviceBtn:
		if (pAction->devbtn.count>0) {
		    int nClicks,i;
		    nClicks= pAction->btn.count;
		    for (i=0;i<nClicks;i++) {
			XkbFakeDeviceButton(dev,TRUE,button);
			XkbFakeDeviceButton(dev,FALSE,button);
		    }
		    filter->upAction.type= XkbSA_NoAction;
		}
		else XkbFakeDeviceButton(dev,TRUE,button);
		break;
	}
    }
    else if (filter->keycode==keycode) {
	int	button;

	filter->active= 0;
	_XkbLookupButtonDevice(&dev, filter->upAction.devbtn.device,
			       serverClient, DixUnknownAccess, &button);
	if (!dev || !dev->public.on)
	    return 1;

	button= filter->upAction.btn.button;
	switch (filter->upAction.type) {
	    case XkbSA_LockDeviceBtn:
		if ((filter->upAction.devbtn.flags&XkbSA_LockNoUnlock)||
		    !BitIsOn(dev->button->down, button))
		    return 0;
		XkbFakeDeviceButton(dev,FALSE,button);
		break;
	    case XkbSA_DeviceBtn:
		XkbFakeDeviceButton(dev,FALSE,button);
		break;
	}
	filter->active = 0;
    }
    return 0;
}

static XkbFilterPtr
_XkbNextFreeFilter(
	XkbSrvInfoPtr xkbi
)
{
register int	i;

    if (xkbi->szFilters==0) {
	xkbi->szFilters = 4;
	xkbi->filters = calloc(xkbi->szFilters, sizeof(XkbFilterRec));
	/* 6/21/93 (ef) -- XXX! deal with allocation failure */
    }
    for (i=0;i<xkbi->szFilters;i++) {
	if (!xkbi->filters[i].active) {
	    xkbi->filters[i].keycode = 0;
	    return &xkbi->filters[i];
	}
    }
    xkbi->szFilters*=2;
    xkbi->filters= realloc(xkbi->filters,
                            xkbi->szFilters * sizeof(XkbFilterRec));
    /* 6/21/93 (ef) -- XXX! deal with allocation failure */
    memset(&xkbi->filters[xkbi->szFilters/2], 0,
            (xkbi->szFilters/2)*sizeof(XkbFilterRec));
    return &xkbi->filters[xkbi->szFilters/2];
}

static int
_XkbApplyFilters(XkbSrvInfoPtr xkbi,unsigned kc,XkbAction *pAction)
{
register int	i,send;

    send= 1;
    for (i=0;i<xkbi->szFilters;i++) {
	if ((xkbi->filters[i].active)&&(xkbi->filters[i].filter))
	    send= ((*xkbi->filters[i].filter)(xkbi,&xkbi->filters[i],kc,pAction) 
                    && send);
    }
    return send;
}

void
XkbHandleActions(DeviceIntPtr dev, DeviceIntPtr kbd, DeviceEvent* event)
{
int		key,bit,i;
XkbSrvInfoPtr	xkbi;
KeyClassPtr	keyc;
int		changed,sendEvent;
Bool		genStateNotify;
XkbAction	act;
XkbFilterPtr	filter;
Bool		keyEvent;
Bool		pressEvent;
ProcessInputProc backupproc;
    
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(dev);

    keyc= kbd->key;
    xkbi= keyc->xkbInfo;
    key= event->detail.key;
    /* The state may change, so if we're not in the middle of sending a state
     * notify, prepare for it */
    if ((xkbi->flags&_XkbStateNotifyInProgress)==0) {
	xkbi->prev_state = xkbi->state;
	xkbi->flags|= _XkbStateNotifyInProgress;
	genStateNotify= TRUE;
    }
    else genStateNotify= FALSE;

    xkbi->clearMods = xkbi->setMods = 0;
    xkbi->groupChange = 0;

    sendEvent = 1;
    keyEvent= ((event->type == ET_KeyPress) || (event->type == ET_KeyRelease));
    pressEvent= ((event->type == ET_KeyPress)|| (event->type == ET_ButtonPress));

    if (pressEvent) {
	if (keyEvent)	
	    act = XkbGetKeyAction(xkbi,&xkbi->state,key);
	else {
	    act = XkbGetButtonAction(kbd,dev,key);
	    key|= BTN_ACT_FLAG;
	}
	sendEvent = _XkbApplyFilters(xkbi,key,&act);
	if (sendEvent) {
	    switch (act.type) {
		case XkbSA_SetMods:
		case XkbSA_SetGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent = _XkbFilterSetState(xkbi,filter,key,&act);
		    break;
		case XkbSA_LatchMods:
		case XkbSA_LatchGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterLatchState(xkbi,filter,key,&act);
		    break;
		case XkbSA_LockMods:
		case XkbSA_LockGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterLockState(xkbi,filter,key,&act);
		    break;
		case XkbSA_ISOLock:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterISOLock(xkbi,filter,key,&act);
		    break;
		case XkbSA_MovePtr:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterPointerMove(xkbi,filter,key,&act);
		    break;
		case XkbSA_PtrBtn:
		case XkbSA_LockPtrBtn:
		case XkbSA_SetPtrDflt:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterPointerBtn(xkbi,filter,key,&act);
		    break;
		case XkbSA_Terminate:
		    sendEvent= XkbDDXTerminateServer(dev,key,&act);
		    break;
		case XkbSA_SwitchScreen:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterSwitchScreen(xkbi,filter,key,&act);
		    break;
		case XkbSA_SetControls:
		case XkbSA_LockControls:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterControls(xkbi,filter,key,&act);
		    break;
		case XkbSA_ActionMessage:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterActionMessage(xkbi,filter,key,&act);
		    break;
		case XkbSA_RedirectKey:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterRedirectKey(xkbi,filter,key,&act);
		    break;
		case XkbSA_DeviceBtn:
		case XkbSA_LockDeviceBtn:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterDeviceBtn(xkbi,filter,key,&act);
		    break;
		case XkbSA_XFree86Private:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterXF86Private(xkbi,filter,key,&act);
		    break;
	    }
	}
    }
    else {
	if (!keyEvent)
	    key|= BTN_ACT_FLAG;
	sendEvent = _XkbApplyFilters(xkbi,key,NULL);
    }

    if (xkbi->groupChange!=0)
	xkbi->state.base_group+= xkbi->groupChange;
    if (xkbi->setMods) {
	for (i=0,bit=1; xkbi->setMods; i++,bit<<=1 ) {
	    if (xkbi->setMods&bit) {
		keyc->modifierKeyCount[i]++;
		xkbi->state.base_mods|= bit;
		xkbi->setMods&= ~bit;
	    }
	}
    }
    if (xkbi->clearMods) {
	for (i=0,bit=1; xkbi->clearMods; i++,bit<<=1 ) {
	    if (xkbi->clearMods&bit) {
		keyc->modifierKeyCount[i]--;
		if (keyc->modifierKeyCount[i]<=0) {
		    xkbi->state.base_mods&= ~bit;
		    keyc->modifierKeyCount[i] = 0;
		}
		xkbi->clearMods&= ~bit;
	    }
	}
    }

    if (sendEvent) {
        DeviceIntPtr tmpdev;
	if (keyEvent)
            tmpdev = dev;
        else
            tmpdev = GetPairedDevice(dev);

        UNWRAP_PROCESS_INPUT_PROC(tmpdev,xkbPrivPtr, backupproc);
        dev->public.processInputProc((InternalEvent*)event, tmpdev);
        COND_WRAP_PROCESS_INPUT_PROC(tmpdev, xkbPrivPtr,
                                     backupproc,xkbUnwrapProc);
    }
    else if (keyEvent) {
	FixKeyState(event, dev);
    }

    XkbComputeDerivedState(xkbi);
    changed = XkbStateChangedFlags(&xkbi->prev_state,&xkbi->state);
    if (genStateNotify) {
	if (changed) {
	    xkbStateNotify	sn;
	    sn.keycode= key;
	    sn.eventType= event->type;
	    sn.requestMajor = sn.requestMinor = 0;
	    sn.changed= changed;
	    XkbSendStateNotify(dev,&sn);
	}
	xkbi->flags&= ~_XkbStateNotifyInProgress;
    }
    changed= XkbIndicatorsToUpdate(dev,changed,FALSE);
    if (changed) {
	XkbEventCauseRec	cause;
	XkbSetCauseKey(&cause, key, event->type);
	XkbUpdateIndicators(dev,changed,FALSE,NULL,&cause);
    }
    return;
}

int
XkbLatchModifiers(DeviceIntPtr pXDev,CARD8 mask,CARD8 latches)
{
XkbSrvInfoPtr	xkbi;
XkbFilterPtr	filter;
XkbAction	act;
unsigned	clear;

    if ( pXDev && pXDev->key && pXDev->key->xkbInfo ) {
	xkbi = pXDev->key->xkbInfo;
	clear= (mask&(~latches));
	xkbi->state.latched_mods&= ~clear;
	/* Clear any pending latch to locks.
	 */
	act.type = XkbSA_NoAction;
	_XkbApplyFilters(xkbi,SYNTHETIC_KEYCODE,&act);
	act.type = XkbSA_LatchMods;
	act.mods.flags = 0;
	act.mods.mask  = mask&latches;
	filter = _XkbNextFreeFilter(xkbi);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,&act);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,(XkbAction *)NULL);
	return Success;
    }
    return BadValue;
}

int
XkbLatchGroup(DeviceIntPtr pXDev,int group)
{
XkbSrvInfoPtr	xkbi;
XkbFilterPtr	filter;
XkbAction	act;

    if ( pXDev && pXDev->key && pXDev->key->xkbInfo ) {
	xkbi = pXDev->key->xkbInfo;
	act.type = XkbSA_LatchGroup;
	act.group.flags = 0;
	XkbSASetGroup(&act.group,group);
	filter = _XkbNextFreeFilter(xkbi);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,&act);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,(XkbAction *)NULL);
	return Success;
    }
    return BadValue;
}

/***====================================================================***/

void
XkbClearAllLatchesAndLocks(	DeviceIntPtr		dev,
				XkbSrvInfoPtr		xkbi,
				Bool			genEv,
				XkbEventCausePtr	cause)
{
XkbStateRec	os;
xkbStateNotify	sn;

    sn.changed= 0;
    os= xkbi->state;
    if (os.latched_mods) { /* clear all latches */
	XkbLatchModifiers(dev,~0,0);
	sn.changed|= XkbModifierLatchMask;
    }
    if (os.latched_group) {
	XkbLatchGroup(dev,0);
	sn.changed|= XkbGroupLatchMask;
    }
    if (os.locked_mods) {
	xkbi->state.locked_mods= 0;
	sn.changed|= XkbModifierLockMask;
    }
    if (os.locked_group) {
	xkbi->state.locked_group= 0;
	sn.changed|= XkbGroupLockMask;
    }
    if ( genEv && sn.changed) {
	CARD32 	changed;

	XkbComputeDerivedState(xkbi);
	sn.keycode= 		cause->kc;
	sn.eventType=		cause->event;
	sn.requestMajor= 	cause->mjr;
	sn.requestMinor= 	cause->mnr;
	sn.changed= XkbStateChangedFlags(&os,&xkbi->state);
	XkbSendStateNotify(dev,&sn);
	changed= XkbIndicatorsToUpdate(dev,sn.changed,FALSE);
	if (changed) {
	    XkbUpdateIndicators(dev,changed,TRUE,NULL,cause);
	}
    }
    return;
}

/*
 * The event is injected into the event processing, not the EQ. Thus,
 * ensure that we restore the master after the event sequence to the
 * original set of classes. Otherwise, the master remains on the XTEST
 * classes and drops events that don't fit into the XTEST layout (e.g.
 * events with more than 2 valuators).
 *
 * FIXME: EQ injection in the processing stage is not designed for, so this
 * is a rather awkward hack. The event list returned by GetPointerEvents()
 * and friends is always prefixed with a DCE if the last _posted_ device was
 * different. For normal events, this sequence then resets the master during
 * the processing stage. Since we inject the PointerKey events in the
 * processing stage though, we need to manually reset to restore the
 * previous order, because the events already in the EQ must be sent for the
 * right device.
 * So we post-fix the event list we get from GPE with a DCE back to the
 * previous slave device.
 *
 * First one on drinking island wins!
 */
static void
InjectPointerKeyEvents(DeviceIntPtr dev, int type, int button, int flags, ValuatorMask *mask)
{
    ScreenPtr           pScreen;
    InternalEvent*      events;
    int                 nevents, i;
    DeviceIntPtr        ptr, mpointer, lastSlave = NULL;
    Bool                saveWait;

    if (IsMaster(dev)) {
        mpointer = GetMaster(dev, MASTER_POINTER);
        lastSlave = mpointer->lastSlave;
        ptr = GetXTestDevice(mpointer);
    } else if (IsFloating(dev))
        ptr = dev;
    else
        return;


    events = InitEventList(GetMaximumEventsNum() + 1);
    OsBlockSignals();
    pScreen = miPointerGetScreen(ptr);
    saveWait = miPointerSetWaitForUpdate(pScreen, FALSE);
    nevents = GetPointerEvents(events, ptr, type, button, flags, mask);
    if (IsMaster(dev) && (lastSlave && lastSlave != ptr))
        UpdateFromMaster(&events[nevents], lastSlave, DEVCHANGE_POINTER_EVENT, &nevents);
    miPointerSetWaitForUpdate(pScreen, saveWait);
    OsReleaseSignals();

    for (i = 0; i < nevents; i++)
        mieqProcessDeviceEvent(ptr, &events[i], NULL);

    FreeEventList(events, GetMaximumEventsNum());

}

static void
XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags,int x,int y)
{
    ValuatorMask        mask;
    int                 gpe_flags = 0;

    /* ignore attached SDs */
    if (!IsMaster(dev) && !IsFloating(dev))
        return;

    if (flags & XkbSA_MoveAbsoluteX || flags & XkbSA_MoveAbsoluteY)
        gpe_flags = POINTER_ABSOLUTE;
    else
        gpe_flags = POINTER_RELATIVE;

    valuator_mask_set_range(&mask, 0, 2, (int[]){x, y});

    InjectPointerKeyEvents(dev, MotionNotify, 0, gpe_flags, &mask);
}

void
XkbFakeDeviceButton(DeviceIntPtr dev,Bool press,int button)
{
    DeviceIntPtr        ptr;
    int                 down;

    /* If dev is a slave device, and the SD is attached, do nothing. If we'd
     * post through the attached master pointer we'd get duplicate events.
     *
     * if dev is a master keyboard, post through the XTEST device
     *
     * if dev is a floating slave, post through the device itself.
     */

    if (IsMaster(dev)) {
        DeviceIntPtr mpointer = GetMaster(dev, MASTER_POINTER);
        ptr = GetXTestDevice(mpointer);
    } else if (IsFloating(dev))
        ptr = dev;
    else
        return;

    down = button_is_down(ptr, button, BUTTON_PROCESSED);
    if (press == down)
        return;

    InjectPointerKeyEvents(dev, press ? ButtonPress : ButtonRelease,
                           button, 0, NULL);
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <xkbsrv.h>
#include "xkbgeom.h"
#include <os.h>
#include <string.h>

/***===================================================================***/

/*ARGSUSED*/
Status
XkbAllocCompatMap(XkbDescPtr xkb,unsigned which,unsigned nSI)
{
XkbCompatMapPtr	compat;
XkbSymInterpretRec *prev_interpret;

    if (!xkb)
	return BadMatch;
    if (xkb->compat) {
	if (xkb->compat->size_si>=nSI)
	    return Success;
	compat= xkb->compat;
	compat->size_si= nSI;
	if (compat->sym_interpret==NULL)
	    compat->num_si= 0;
	prev_interpret = compat->sym_interpret;
	compat->sym_interpret= realloc(compat->sym_interpret,
					nSI * sizeof(XkbSymInterpretRec));
	if (compat->sym_interpret==NULL) {
	    free(prev_interpret);
	    compat->size_si= compat->num_si= 0;
	    return BadAlloc;
	}
	if (compat->num_si!=0) {
	    memset(&compat->sym_interpret[compat->num_si], 0,
		   (compat->size_si - compat->num_si) * sizeof(XkbSymInterpretRec));
	}
	return Success;
    }
   compat= calloc(1, sizeof(XkbCompatMapRec));
    if (compat==NULL)
	return BadAlloc;
    if (nSI>0) {
	compat->sym_interpret= calloc(nSI, sizeof(XkbSymInterpretRec));
	if (!compat->sym_interpret) {
	    free(compat);
	    return BadAlloc;
	}
    }
    compat->size_si= nSI;
    compat->num_si= 0;
    memset((char *)&compat->groups[0], 0, XkbNumKbdGroups*sizeof(XkbModsRec));
    xkb->compat= compat;
    return Success;
}


void
XkbFreeCompatMap(XkbDescPtr xkb,unsigned which,Bool freeMap)
{
register XkbCompatMapPtr compat;

    if ((xkb==NULL)||(xkb->compat==NULL))
	return;
    compat= xkb->compat;
    if (freeMap)
	which= XkbAllCompatMask;
    if (which&XkbGroupCompatMask)
	memset((char *)&compat->groups[0], 0, XkbNumKbdGroups*sizeof(XkbModsRec));
    if (which&XkbSymInterpMask) {
	if ((compat->sym_interpret)&&(compat->size_si>0))
	    free(compat->sym_interpret);
	compat->size_si= compat->num_si= 0;
	compat->sym_interpret= NULL;
    }
    if (freeMap) {
	free(compat);
	xkb->compat= NULL;
    }
    return;
}

/***===================================================================***/

Status
XkbAllocNames(XkbDescPtr xkb,unsigned which,int nTotalRG,int nTotalAliases)
{
XkbNamesPtr	names;

    if (xkb==NULL)
	return BadMatch;
    if (xkb->names==NULL) {
	xkb->names = calloc(1, sizeof(XkbNamesRec));
	if (xkb->names==NULL)
	    return BadAlloc;
    }
    names= xkb->names;
    if ((which&XkbKTLevelNamesMask)&&(xkb->map!=NULL)&&(xkb->map->types!=NULL)){
	register int	i;
	XkbKeyTypePtr	type;

	type= xkb->map->types;
	for (i=0;i<xkb->map->num_types;i++,type++) {
	    if (type->level_names==NULL) {
		type->level_names= calloc(type->num_levels, sizeof(Atom));
		if (type->level_names==NULL)
		    return BadAlloc;
	    }
	}
    }
    if ((which&XkbKeyNamesMask)&&(names->keys==NULL)) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code)) 
	    return BadValue;
	names->keys= calloc((xkb->max_key_code+1), sizeof(XkbKeyNameRec));
	if (names->keys==NULL)
	    return BadAlloc;
    }
    if ((which&XkbKeyAliasesMask)&&(nTotalAliases>0)) {
	if (names->key_aliases==NULL) {
	    names->key_aliases= calloc(nTotalAliases, sizeof(XkbKeyAliasRec));
	}
	else if (nTotalAliases>names->num_key_aliases) {
	    XkbKeyAliasRec *prev_aliases = names->key_aliases;

	    names->key_aliases= realloc(names->key_aliases,
					 nTotalAliases * sizeof(XkbKeyAliasRec));
	    if (names->key_aliases!=NULL) {
		memset(&names->key_aliases[names->num_key_aliases], 0,
			(nTotalAliases - names->num_key_aliases) * sizeof(XkbKeyAliasRec));
	    } else {
		free(prev_aliases);
	    }
	}
	if (names->key_aliases==NULL) {
	    names->num_key_aliases= 0;
	    return BadAlloc;
	}
	names->num_key_aliases= nTotalAliases;
    }
    if ((which&XkbRGNamesMask)&&(nTotalRG>0)) {
	if (names->radio_groups==NULL) {
	    names->radio_groups= calloc(nTotalRG, sizeof(Atom));
	}
	else if (nTotalRG>names->num_rg) {
	    Atom *prev_radio_groups = names->radio_groups;

	    names->radio_groups= realloc(names->radio_groups,
					  nTotalRG * sizeof(Atom));
	    if (names->radio_groups!=NULL) {
		memset(&names->radio_groups[names->num_rg], 0,
			(nTotalRG - names->num_rg) * sizeof(Atom));
	    } else {
		free(prev_radio_groups);
	    }
	}
	if (names->radio_groups==NULL)
	    return BadAlloc;
	names->num_rg= nTotalRG;
    }
    return Success;
}

void
XkbFreeNames(XkbDescPtr xkb,unsigned which,Bool freeMap)
{
XkbNamesPtr	names;

    if ((xkb==NULL)||(xkb->names==NULL))
	return;
    names= xkb->names;
    if (freeMap)
	which= XkbAllNamesMask; 
    if (which&XkbKTLevelNamesMask) {
	XkbClientMapPtr	map= xkb->map;
	if ((map!=NULL)&&(map->types!=NULL)) {
	    register int 		i;
	    register XkbKeyTypePtr	type;
	    type= map->types;
	    for (i=0;i<map->num_types;i++,type++) {
		free(type->level_names);
		type->level_names = NULL;
	    }
	}
    }
    if ((which&XkbKeyNamesMask)&&(names->keys!=NULL)) {
	free(names->keys);
	names->keys= NULL;
	names->num_keys= 0;
    }
    if ((which&XkbKeyAliasesMask)&&(names->key_aliases)){
	free(names->key_aliases);
	names->key_aliases=NULL;
	names->num_key_aliases=0;
    }
    if ((which&XkbRGNamesMask)&&(names->radio_groups)) {
	free(names->radio_groups);
	names->radio_groups= NULL;
	names->num_rg= 0;
    }
    if (freeMap) {
	free(names);
	xkb->names= NULL;
    }
    return;
}

/***===================================================================***/

/*ARGSUSED*/
Status
XkbAllocControls(XkbDescPtr xkb,unsigned which)
{
    if (xkb==NULL)
	return BadMatch;

    if (xkb->ctrls==NULL) {
	xkb->ctrls= calloc(1, sizeof(XkbControlsRec));
	if (!xkb->ctrls)
	    return BadAlloc;
    }
    return Success;
}

/*ARGSUSED*/
static void
XkbFreeControls(XkbDescPtr xkb,unsigned which,Bool freeMap)
{
    if (freeMap && (xkb!=NULL) && (xkb->ctrls!=NULL)) {
	free(xkb->ctrls);
	xkb->ctrls= NULL;
    }
    return;
}

/***===================================================================***/

Status
XkbAllocIndicatorMaps(XkbDescPtr xkb)
{
    if (xkb==NULL)
	return BadMatch;
    if (xkb->indicators==NULL) {
	xkb->indicators= calloc(1, sizeof(XkbIndicatorRec));
	if (!xkb->indicators)
	    return BadAlloc;
    }
    return Success;
}

static void
XkbFreeIndicatorMaps(XkbDescPtr xkb)
{
    if ((xkb!=NULL)&&(xkb->indicators!=NULL)) {
	free(xkb->indicators);
	xkb->indicators= NULL;
    }
    return;
}

/***====================================================================***/

XkbDescRec	*
XkbAllocKeyboard(void)
{
XkbDescRec *xkb;

    xkb = calloc(1, sizeof(XkbDescRec));
    if (xkb)
	xkb->device_spec= XkbUseCoreKbd;
    return xkb;
}

void
XkbFreeKeyboard(XkbDescPtr xkb,unsigned which,Bool freeAll)
{
    if (xkb==NULL)
	return;
    if (freeAll)
	which= XkbAllComponentsMask;
    if (which&XkbClientMapMask)
	XkbFreeClientMap(xkb,XkbAllClientInfoMask,TRUE);
    if (which&XkbServerMapMask)
	XkbFreeServerMap(xkb,XkbAllServerInfoMask,TRUE);
    if (which&XkbCompatMapMask)
	XkbFreeCompatMap(xkb,XkbAllCompatMask,TRUE);
    if (which&XkbIndicatorMapMask)
	XkbFreeIndicatorMaps(xkb);
    if (which&XkbNamesMask)
	XkbFreeNames(xkb,XkbAllNamesMask,TRUE);
    if ((which&XkbGeometryMask) && (xkb->geom!=NULL)) {
	XkbFreeGeometry(xkb->geom,XkbGeomAllMask,TRUE);
        /* PERHAPS BONGHITS etc */
        xkb->geom = NULL;
    }
    if (which&XkbControlsMask)
	XkbFreeControls(xkb,XkbAllControlsMask,TRUE);
    if (freeAll)
	free(xkb);
    return;
}


/***====================================================================***/

void
XkbFreeComponentNames(XkbComponentNamesPtr names, Bool freeNames)
{
    if (names)
    {
        free(names->keycodes);
        free(names->types);
        free(names->compat);
        free(names->symbols);
        free(names->geometry);
        memset(names, 0, sizeof(XkbComponentNamesRec));
    }
    if (freeNames)
        free(names);
}
/* This file generated automatically by xkbcomp */
/* DO  NOT EDIT */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef DEFAULT_H
#define DEFAULT_H 1

#define GET_ATOM(d,s)	MakeAtom(s,strlen(s),1)
#define DPYTYPE	char *
#define NUM_KEYS	1

#define	vmod_NumLock	0
#define	vmod_Alt	1
#define	vmod_LevelThree	2
#define	vmod_AltGr	3
#define	vmod_ScrollLock	4

#define	vmod_NumLockMask	(1<<0)
#define	vmod_AltMask	(1<<1)
#define	vmod_LevelThreeMask	(1<<2)
#define	vmod_AltGrMask	(1<<3)
#define	vmod_ScrollLockMask	(1<<4)

/* types name is "default" */
static Atom lnames_ONE_LEVEL[1];

static XkbKTMapEntryRec map_TWO_LEVEL[1]= {
    { 1,      1, {       ShiftMask,       ShiftMask,               0 } }
};
static Atom lnames_TWO_LEVEL[2];

static XkbKTMapEntryRec map_ALPHABETIC[2]= {
    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
    { 1,      0, {        LockMask,        LockMask,               0 } }
};
static XkbModsRec preserve_ALPHABETIC[2]= {
    {                 0,               0,               0 },
    {          LockMask,        LockMask,               0 }
};
static Atom lnames_ALPHABETIC[2];

static XkbKTMapEntryRec map_KEYPAD[2]= {
    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
    { 0,      1, {               0,               0, vmod_NumLockMask } }
};
static Atom lnames_KEYPAD[2];

static XkbKTMapEntryRec map_PC_BREAK[1]= {
    { 1,      1, {     ControlMask,     ControlMask,               0 } }
};
static Atom lnames_PC_BREAK[2];

static XkbKTMapEntryRec map_PC_SYSRQ[1]= {
    { 0,      1, {               0,               0,    vmod_AltMask } }
};
static Atom lnames_PC_SYSRQ[2];

static XkbKTMapEntryRec map_CTRL_ALT[1]= {
    { 0,      1, {     ControlMask,     ControlMask,    vmod_AltMask } }
};
static Atom lnames_CTRL_ALT[2];

static XkbKTMapEntryRec map_THREE_LEVEL[3]= {
    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
    { 0,      2, {               0,               0, vmod_LevelThreeMask } },
    { 0,      2, {       ShiftMask,       ShiftMask, vmod_LevelThreeMask } }
};
static Atom lnames_THREE_LEVEL[3];

static XkbKTMapEntryRec map_SHIFT_ALT[1]= {
    { 0,      1, {       ShiftMask,       ShiftMask,    vmod_AltMask } }
};
static Atom lnames_SHIFT_ALT[2];

static XkbKeyTypeRec dflt_types[]= {
    {
	{               0,               0,               0 },
	1,
	0,	NULL,	NULL,
	None,	lnames_ONE_LEVEL
    },
    {
	{       ShiftMask,       ShiftMask,               0 },
	2,
	1,	map_TWO_LEVEL,	NULL,
	None,	lnames_TWO_LEVEL
    },
    {
	{ ShiftMask|LockMask, ShiftMask|LockMask,               0 },
	2,
	2,	map_ALPHABETIC,	preserve_ALPHABETIC,
	None,	lnames_ALPHABETIC
    },
    {
	{       ShiftMask,       ShiftMask, vmod_NumLockMask },
	2,
	2,	map_KEYPAD,	NULL,
	None,	lnames_KEYPAD
    },
    {
	{     ControlMask,     ControlMask,               0 },
	2,
	1,	map_PC_BREAK,	NULL,
	None,	lnames_PC_BREAK
    },
    {
	{               0,               0,    vmod_AltMask },
	2,
	1,	map_PC_SYSRQ,	NULL,
	None,	lnames_PC_SYSRQ
    },
    {
	{     ControlMask,     ControlMask,    vmod_AltMask },
	2,
	1,	map_CTRL_ALT,	NULL,
	None,	lnames_CTRL_ALT
    },
    {
	{       ShiftMask,       ShiftMask, vmod_LevelThreeMask },
	3,
	3,	map_THREE_LEVEL,	NULL,
	None,	lnames_THREE_LEVEL
    },
    {
	{       ShiftMask,       ShiftMask,    vmod_AltMask },
	2,
	1,	map_SHIFT_ALT,	NULL,
	None,	lnames_SHIFT_ALT
    }
};
#define num_dflt_types (sizeof(dflt_types)/sizeof(XkbKeyTypeRec))


static void
initTypeNames(DPYTYPE dpy)
{
    dflt_types[0].name= GET_ATOM(dpy,"ONE_LEVEL");
    lnames_ONE_LEVEL[0]=	GET_ATOM(dpy,"Any");
    dflt_types[1].name= GET_ATOM(dpy,"TWO_LEVEL");
    lnames_TWO_LEVEL[0]=	GET_ATOM(dpy,"Base");
    lnames_TWO_LEVEL[1]=	GET_ATOM(dpy,"Shift");
    dflt_types[2].name= GET_ATOM(dpy,"ALPHABETIC");
    lnames_ALPHABETIC[0]=	GET_ATOM(dpy,"Base");
    lnames_ALPHABETIC[1]=	GET_ATOM(dpy,"Caps");
    dflt_types[3].name= GET_ATOM(dpy,"KEYPAD");
    lnames_KEYPAD[0]=	GET_ATOM(dpy,"Base");
    lnames_KEYPAD[1]=	GET_ATOM(dpy,"Number");
    dflt_types[4].name= GET_ATOM(dpy,"PC_BREAK");
    lnames_PC_BREAK[0]=	GET_ATOM(dpy,"Base");
    lnames_PC_BREAK[1]=	GET_ATOM(dpy,"Control");
    dflt_types[5].name= GET_ATOM(dpy,"PC_SYSRQ");
    lnames_PC_SYSRQ[0]=	GET_ATOM(dpy,"Base");
    lnames_PC_SYSRQ[1]=	GET_ATOM(dpy,"Alt");
    dflt_types[6].name= GET_ATOM(dpy,"CTRL+ALT");
    lnames_CTRL_ALT[0]=	GET_ATOM(dpy,"Base");
    lnames_CTRL_ALT[1]=	GET_ATOM(dpy,"Ctrl+Alt");
    dflt_types[7].name= GET_ATOM(dpy,"THREE_LEVEL");
    lnames_THREE_LEVEL[0]=	GET_ATOM(dpy,"Base");
    lnames_THREE_LEVEL[1]=	GET_ATOM(dpy,"Shift");
    lnames_THREE_LEVEL[2]=	GET_ATOM(dpy,"Level3");
    dflt_types[8].name= GET_ATOM(dpy,"SHIFT+ALT");
    lnames_SHIFT_ALT[0]=	GET_ATOM(dpy,"Base");
    lnames_SHIFT_ALT[1]=	GET_ATOM(dpy,"Shift+Alt");
}
/* compat name is "default" */
static XkbSymInterpretRec dfltSI[69]= {
    {    XK_ISO_Level2_Latch, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_Exactly, ShiftMask,
         255,
       {      XkbSA_LatchMods, { 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Eisu_Shift, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Eisu_toggle, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Kana_Shift, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Kana_Lock, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Shift_Lock, 0x0000,
         XkbSI_AnyOf, ShiftMask|LockMask,
         255,
       {       XkbSA_LockMods, { 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Num_Lock, 0x0000,
         XkbSI_AnyOf, 0xff,
         0,
       {       XkbSA_LockMods, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_Alt_L, 0x0000,
         XkbSI_AnyOf, 0xff,
         1,
       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Alt_R, 0x0000,
         XkbSI_AnyOf, 0xff,
         1,
       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Scroll_Lock, 0x0000,
         XkbSI_AnyOf, 0xff,
         4,
       {       XkbSA_LockMods, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Lock, 0x0000,
         XkbSI_AnyOf, 0xff,
         255,
       {        XkbSA_ISOLock, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Level3_Shift, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOf, 0xff,
         2,
       {        XkbSA_SetMods, { 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 } } },
    {    XK_ISO_Level3_Latch, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOf, 0xff,
         2,
       {      XkbSA_LatchMods, { 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 } } },
    {    XK_Mode_switch, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
         3,
       {       XkbSA_SetGroup, { 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_1, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_End, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_2, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_Down, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_3, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_Next, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_4, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Left, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_6, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Right, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_7, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_Home, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_8, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_Up, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_9, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_Prior, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_5, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Begin, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_F1, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Divide, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_F2, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Multiply, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_F3, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Subtract, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Separator, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Add, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_0, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Insert, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Decimal, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Delete, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Button_Dflt, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Button1, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Button2, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Button3, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DblClick_Dflt, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DblClick1, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DblClick2, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DblClick3, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Drag_Dflt, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Drag1, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Drag2, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Drag3, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_EnableKeys, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00 } } },
    {    XK_Pointer_Accelerate, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00 } } },
    {    XK_Pointer_DfltBtnNext, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DfltBtnPrev, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_AccessX_Enable, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00 } } },
    {    XK_Terminate_Server, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {      XkbSA_Terminate, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Group_Latch, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
         3,
       {     XkbSA_LatchGroup, { 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Next_Group, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
         3,
       {      XkbSA_LockGroup, { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Prev_Group, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
         3,
       {      XkbSA_LockGroup, { 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_First_Group, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {      XkbSA_LockGroup, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Last_Group, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {      XkbSA_LockGroup, { 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    NoSymbol, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_LockMods, { 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    NoSymbol, 0x0000,
         XkbSI_AnyOf, 0xff,
         255,
       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } }
};
#define num_dfltSI (sizeof(dfltSI)/sizeof(XkbSymInterpretRec))

static XkbCompatMapRec compatMap= {
    dfltSI,
    {   /* group compatibility */
        {            0,            0,            0 },
        {            0,            0, vmod_AltGrMask },
        {            0,            0, vmod_AltGrMask },
        {            0,            0, vmod_AltGrMask }
    },
    num_dfltSI, num_dfltSI
};

static void
initIndicatorNames(DPYTYPE dpy,XkbDescPtr xkb)
{
    xkb->names->indicators[ 0]=	GET_ATOM(dpy,"Caps Lock");
    xkb->names->indicators[ 1]=	GET_ATOM(dpy,"Num Lock");
    xkb->names->indicators[ 2]=	GET_ATOM(dpy,"Shift Lock");
    xkb->names->indicators[ 3]=	GET_ATOM(dpy,"Mouse Keys");
    xkb->names->indicators[ 4]=	GET_ATOM(dpy,"Scroll Lock");
    xkb->names->indicators[ 5]=	GET_ATOM(dpy,"Group 2");
}
#endif /* DEFAULT_H */
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "inputstr.h"
#include "exevents.h"
#include "exglobals.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include "xkb.h"

/***====================================================================***/

/*
 * This function sends out two kinds of notification:
 *   - Core mapping notify events sent to clients for whom kbd is the
 *     current core ('picked') keyboard _and_ have not explicitly
 *     selected for XKB mapping notify events;
 *   - Xi mapping events, sent unconditionally to all clients who have
 *     explicitly selected for them (including those who have explicitly
 *     selected for XKB mapping notify events!).
 */
static void
XkbSendLegacyMapNotify(DeviceIntPtr kbd, CARD16 xkb_event, CARD16 changed,
                       int first_key, int num_keys)
{
    int i;
    int keymap_changed = 0;
    int modmap_changed = 0;
    xEvent core_mn;
    deviceMappingNotify xi_mn;
    CARD32 time = GetTimeInMillis();

    if (xkb_event == XkbNewKeyboardNotify) {
        if (changed & XkbNKN_KeycodesMask) {
            keymap_changed = 1;
            modmap_changed = 1;
        }
    }
    else if (xkb_event == XkbMapNotify) {
        if (changed & XkbKeySymsMask)
            keymap_changed = 1;
        if (changed & XkbModifierMapMask)
            modmap_changed = 1;
    }
    if (!keymap_changed && !modmap_changed)
        return;

    core_mn.u.u.type = MappingNotify;
    xi_mn.type = DeviceMappingNotify;
    xi_mn.deviceid = kbd->id;
    xi_mn.time = time;

    /* 0 is serverClient. */
    for (i = 1; i < currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        /* XKB allows clients to restrict the MappingNotify events sent to
         * them.  This was broken for three years.  Sorry. */
        if (xkb_event == XkbMapNotify &&
            (clients[i]->xkbClientFlags & _XkbClientInitialized) &&
            !(clients[i]->mapNotifyMask & changed))
            continue;
        /* Emulate previous server behaviour: any client which has activated
         * XKB will not receive core events emulated from a NewKeyboardNotify
         * at all. */
        if (xkb_event == XkbNewKeyboardNotify &&
            (clients[i]->xkbClientFlags & _XkbClientInitialized))
            continue;

        /* Don't send core events to clients who don't know about us. */
        if (!XIShouldNotify(clients[i], kbd))
            continue;

        if (keymap_changed) {
            core_mn.u.mappingNotify.request = MappingKeyboard;

            /* Clip the keycode range to what the client knows about, so it
             * doesn't freak out. */
            if (first_key >= clients[i]->minKC)
                core_mn.u.mappingNotify.firstKeyCode = first_key;
            else
                core_mn.u.mappingNotify.firstKeyCode = clients[i]->minKC;
            if (first_key + num_keys - 1 <= clients[i]->maxKC)
                core_mn.u.mappingNotify.count = num_keys;
            else
                core_mn.u.mappingNotify.count = clients[i]->maxKC -
                                                 clients[i]->minKC + 1;

            WriteEventsToClient(clients[i], 1, &core_mn);
        }
        if (modmap_changed) {
            core_mn.u.mappingNotify.request = MappingModifier;
            core_mn.u.mappingNotify.firstKeyCode = 0;
            core_mn.u.mappingNotify.count = 0;
            WriteEventsToClient(clients[i], 1, &core_mn);
        }
    }

    /* Hmm, maybe we can accidentally generate Xi events for core devices
     * here? Clients might be upset, but that seems better than the
     * alternative of stale keymaps. -ds */
    if (keymap_changed) {
        xi_mn.request = MappingKeyboard;
        xi_mn.firstKeyCode = first_key;
        xi_mn.count = num_keys;
        SendEventToAllWindows(kbd, DeviceMappingNotifyMask, (xEvent *) &xi_mn,
                              1);
    }
    if (modmap_changed) {
        xi_mn.request = MappingModifier;
        xi_mn.firstKeyCode = 0;
        xi_mn.count = 0;
        SendEventToAllWindows(kbd, DeviceMappingNotifyMask, (xEvent *) &xi_mn,
                              1);
    }
}

/***====================================================================***/

void
XkbSendNewKeyboardNotify(DeviceIntPtr kbd,xkbNewKeyboardNotify *pNKN)
{
    int i;
    Time time = GetTimeInMillis();
    CARD16 changed = pNKN->changed;

    pNKN->type = XkbEventCode + XkbEventBase;
    pNKN->xkbType = XkbNewKeyboardNotify;

    for (i=1; i<currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        if (!(clients[i]->newKeyboardNotifyMask & changed))
            continue;

        pNKN->sequenceNumber = clients[i]->sequence;
        pNKN->time = time;
        pNKN->changed = changed;
        if (clients[i]->swapped) {
            int n;
            swaps(&pNKN->sequenceNumber,n);
            swapl(&pNKN->time,n);
            swaps(&pNKN->changed,n);
        }
        WriteToClient(clients[i], sizeof(xEvent), pNKN);

        if (changed & XkbNKN_KeycodesMask) {
            clients[i]->minKC = pNKN->minKeyCode;
            clients[i]->maxKC = pNKN->maxKeyCode;
        }
    }

    XkbSendLegacyMapNotify(kbd, XkbNewKeyboardNotify, changed, pNKN->minKeyCode,
                           pNKN->maxKeyCode - pNKN->minKeyCode + 1);

    return;
}

/***====================================================================***/

void
XkbSendStateNotify(DeviceIntPtr kbd,xkbStateNotify *pSN)
{
XkbSrvInfoPtr	xkbi;
XkbStatePtr	state;
XkbInterestPtr	interest;
Time 		time;
register CARD16	changed,bState;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
	return;
    xkbi = kbd->key->xkbInfo;
    state= &xkbi->state;

    pSN->type = XkbEventCode + XkbEventBase;
    pSN->xkbType = XkbStateNotify;
    pSN->deviceID = kbd->id;
    pSN->time = time = GetTimeInMillis();
    pSN->mods = state->mods;
    pSN->baseMods = state->base_mods;
    pSN->latchedMods = state->latched_mods;
    pSN->lockedMods = state->locked_mods;
    pSN->group = state->group;
    pSN->baseGroup = state->base_group;
    pSN->latchedGroup = state->latched_group;
    pSN->lockedGroup = state->locked_group;
    pSN->compatState = state->compat_state;
    pSN->grabMods = state->grab_mods;
    pSN->compatGrabMods = state->compat_grab_mods;
    pSN->lookupMods = state->lookup_mods;
    pSN->compatLookupMods = state->compat_lookup_mods;
    pSN->ptrBtnState = state->ptr_buttons;
    changed = pSN->changed;
    bState= pSN->ptrBtnState;

    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->stateNotifyMask&changed)) {
	    pSN->sequenceNumber = interest->client->sequence;
	    pSN->time = time;
	    pSN->changed = changed;
	    pSN->ptrBtnState = bState;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pSN->sequenceNumber,n);
		swapl(&pSN->time,n);
		swaps(&pSN->changed,n);
		swaps(&pSN->ptrBtnState,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pSN);
	}
	interest= interest->next;
    }
    return;
}

/***====================================================================***/

/*
 * This function sends out XKB mapping notify events to clients which
 * have explicitly selected for them.  Core and Xi events are handled by
 * XkbSendLegacyMapNotify. */
void
XkbSendMapNotify(DeviceIntPtr kbd, xkbMapNotify *pMN)
{
    int i;
    CARD32 time = GetTimeInMillis();
    CARD16 changed = pMN->changed;
    XkbSrvInfoPtr xkbi = kbd->key->xkbInfo;

    pMN->minKeyCode = xkbi->desc->min_key_code;
    pMN->maxKeyCode = xkbi->desc->max_key_code;
    pMN->type = XkbEventCode + XkbEventBase;
    pMN->xkbType = XkbMapNotify;
    pMN->deviceID = kbd->id;

    /* 0 is serverClient. */
    for (i = 1; i < currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        if (!(clients[i]->mapNotifyMask & changed))
            continue;

        pMN->time = time;
        pMN->sequenceNumber = clients[i]->sequence;
        pMN->changed = changed;

        if (clients[i]->swapped) {
            int n;
            swaps(&pMN->sequenceNumber, n);
            swapl(&pMN->time, n);
            swaps(&pMN->changed, n);
        }
        WriteToClient(clients[i], sizeof(xEvent), pMN);
    }

    XkbSendLegacyMapNotify(kbd, XkbMapNotify, changed, pMN->firstKeySym,
                           pMN->nKeySyms);
}

int
XkbComputeControlsNotify(	DeviceIntPtr	 	kbd,
				XkbControlsPtr		old,
				XkbControlsPtr		new,
				xkbControlsNotify *	pCN,
				Bool			forceCtrlProc)
{
int		i;
CARD32 		changedControls;

    changedControls= 0;

    if (!kbd || !kbd->kbdfeed)
        return 0;
    
    if (old->enabled_ctrls!=new->enabled_ctrls)
	changedControls|= XkbControlsEnabledMask;
    if ((old->repeat_delay!=new->repeat_delay)||
	(old->repeat_interval!=new->repeat_interval))
	changedControls|= XkbRepeatKeysMask;
    for (i = 0; i < XkbPerKeyBitArraySize; i++)
	if (old->per_key_repeat[i] != new->per_key_repeat[i])
	    changedControls|= XkbPerKeyRepeatMask;
    if (old->slow_keys_delay!=new->slow_keys_delay)
	changedControls|= XkbSlowKeysMask;
    if (old->debounce_delay!=new->debounce_delay)
	changedControls|= XkbBounceKeysMask;
    if ((old->mk_delay!=new->mk_delay)||
	(old->mk_interval!=new->mk_interval)||
	(old->mk_dflt_btn!=new->mk_dflt_btn))
	changedControls|= XkbMouseKeysMask;
    if ((old->mk_time_to_max!=new->mk_time_to_max)||
	(old->mk_curve!=new->mk_curve)||
	(old->mk_max_speed!=new->mk_max_speed))
	changedControls|= XkbMouseKeysAccelMask;
    if (old->ax_options!=new->ax_options)
	changedControls|= XkbAccessXKeysMask;
    if ((old->ax_options^new->ax_options) & XkbAX_SKOptionsMask)
	changedControls|= XkbStickyKeysMask;
    if ((old->ax_options^new->ax_options) & XkbAX_FBOptionsMask)
	changedControls|= XkbAccessXFeedbackMask;
    if ((old->ax_timeout!=new->ax_timeout)||
	(old->axt_ctrls_mask!=new->axt_ctrls_mask)||
	(old->axt_ctrls_values!=new->axt_ctrls_values)||
	(old->axt_opts_mask!=new->axt_opts_mask)||
	(old->axt_opts_values!= new->axt_opts_values)) {
	changedControls|= XkbAccessXTimeoutMask;
    }
    if ((old->internal.mask!=new->internal.mask)||
	(old->internal.real_mods!=new->internal.real_mods)||
	(old->internal.vmods!=new->internal.vmods))
	changedControls|= XkbInternalModsMask;
    if ((old->ignore_lock.mask!=new->ignore_lock.mask)||
	(old->ignore_lock.real_mods!=new->ignore_lock.real_mods)||
	(old->ignore_lock.vmods!=new->ignore_lock.vmods))
	changedControls|= XkbIgnoreLockModsMask;

    if (new->enabled_ctrls&XkbRepeatKeysMask)
	 kbd->kbdfeed->ctrl.autoRepeat=TRUE;
    else kbd->kbdfeed->ctrl.autoRepeat=FALSE;

    if (kbd->kbdfeed && kbd->kbdfeed->CtrlProc &&
	(changedControls || forceCtrlProc))
	(*kbd->kbdfeed->CtrlProc)(kbd, &kbd->kbdfeed->ctrl);

    if ((!changedControls)&&(old->num_groups==new->num_groups))
	return 0;

    if (!kbd->xkb_interest)
	return 0;

    pCN->changedControls = changedControls;
    pCN->enabledControls = new->enabled_ctrls;
    pCN->enabledControlChanges = (new->enabled_ctrls^old->enabled_ctrls);
    pCN->numGroups = new->num_groups;

    return 1;
}

void
XkbSendControlsNotify(DeviceIntPtr kbd,xkbControlsNotify *pCN)
{
int			initialized;
CARD32 		 	changedControls, enabledControls, enabledChanges = 0;
XkbSrvInfoPtr		xkbi;
XkbInterestPtr		interest;
Time 		 	time = 0;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
	return;
    xkbi = kbd->key->xkbInfo;
 
    initialized = 0;
    enabledControls = xkbi->desc->ctrls->enabled_ctrls;
    changedControls = pCN->changedControls;
    pCN->numGroups= xkbi->desc->ctrls->num_groups;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->ctrlsNotifyMask&changedControls)) {
	    if (!initialized) {
		pCN->type = XkbEventCode + XkbEventBase;
		pCN->xkbType = XkbControlsNotify;
		pCN->deviceID = kbd->id;
		pCN->time = time = GetTimeInMillis();
		enabledChanges = pCN->enabledControlChanges;
		initialized= 1;
	    }
	    pCN->changedControls = changedControls;
	    pCN->enabledControls = enabledControls;
	    pCN->enabledControlChanges = enabledChanges;
	    pCN->sequenceNumber = interest->client->sequence;
	    pCN->time = time;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pCN->sequenceNumber,n);
		swapl(&pCN->changedControls,n);
		swapl(&pCN->enabledControls,n);
		swapl(&pCN->enabledControlChanges,n);
		swapl(&pCN->time,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pCN);
	}
	interest= interest->next;
    }
    return;
}

static void
XkbSendIndicatorNotify(DeviceIntPtr kbd,int xkbType,xkbIndicatorNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD32		state,changed;

    interest = kbd->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    state = pEv->state;
    changed = pEv->changed;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (((xkbType==XkbIndicatorStateNotify)&&
				(interest->iStateNotifyMask&changed))||
	     ((xkbType==XkbIndicatorMapNotify)&&
	    			(interest->iMapNotifyMask&changed)))) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = xkbType;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->changed = changed;
	    pEv->state = state;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swapl(&pEv->changed,n);
		swapl(&pEv->state,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}


void
XkbHandleBell(	BOOL		 force,
		BOOL		 eventOnly,
		DeviceIntPtr	 kbd,
		CARD8		 percent,
		pointer		 pCtrl,
		CARD8		 class,
		Atom		 name,
		WindowPtr	 pWin,
		ClientPtr	 pClient)
{
xkbBellNotify	bn;
int		initialized;
XkbSrvInfoPtr	xkbi;
XkbInterestPtr	interest;
CARD8		id;
CARD16		pitch,duration;
Time 		time = 0;
XID		winID = 0;

    if (!kbd->key || !kbd->key->xkbInfo)
        return;

    xkbi = kbd->key->xkbInfo;

    if ((force||(xkbi->desc->ctrls->enabled_ctrls&XkbAudibleBellMask))&&
							(!eventOnly)) {
        if (kbd->kbdfeed->BellProc)
            (*kbd->kbdfeed->BellProc)(percent,kbd,(pointer)pCtrl,class);
    }
    interest = kbd->xkb_interest;
    if ((!interest)||(force))
	return;

    if ((class==0)||(class==KbdFeedbackClass)) {
	KeybdCtrl *pKeyCtrl= (KeybdCtrl *)pCtrl;
	id= pKeyCtrl->id;
	pitch= pKeyCtrl->bell_pitch;
	duration= pKeyCtrl->bell_duration;
    }
    else if (class==BellFeedbackClass) {
	BellCtrl *pBellCtrl= (BellCtrl *)pCtrl;
	id= pBellCtrl->id;
	pitch= pBellCtrl->pitch;
	duration= pBellCtrl->duration;
    }
    else return;
 
    initialized = 0;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->bellNotifyMask)) {
	    if (!initialized) {
		time = GetTimeInMillis();
		bn.type = XkbEventCode + XkbEventBase;
		bn.xkbType = XkbBellNotify;
		bn.deviceID = kbd->id;
		bn.bellClass = class;
		bn.bellID = id;
		bn.percent= percent;
		bn.eventOnly = (eventOnly!=0);
		winID= (pWin?pWin->drawable.id:None);
		initialized= 1;
	    }
	    bn.sequenceNumber = interest->client->sequence;
	    bn.time = time;
	    bn.pitch = pitch;
	    bn.duration = duration;
	    bn.name = name;
	    bn.window=  winID;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&bn.sequenceNumber,n);
		swapl(&bn.time,n);
		swaps(&bn.pitch,n);
		swaps(&bn.duration,n);
		swapl(&bn.name,n);
		swapl(&bn.window,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)&bn);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendAccessXNotify(DeviceIntPtr kbd,xkbAccessXNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		sk_delay,db_delay;

    interest = kbd->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    sk_delay= pEv->slowKeysDelay;
    db_delay= pEv->debounceDelay;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->accessXNotifyMask&(1<<pEv->detail))) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbAccessXNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->slowKeysDelay = sk_delay;
	    pEv->debounceDelay = db_delay;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->slowKeysDelay,n);
		swaps(&pEv->debounceDelay,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendNamesNotify(DeviceIntPtr kbd,xkbNamesNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		changed,changedVirtualMods;
CARD32		changedIndicators;

    interest = kbd->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    changed= pEv->changed;
    changedIndicators= pEv->changedIndicators;
    changedVirtualMods= pEv->changedVirtualMods;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->namesNotifyMask&pEv->changed)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbNamesNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->changed = changed;
	    pEv->changedIndicators = changedIndicators;
	    pEv->changedVirtualMods= changedVirtualMods;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->changed,n);
		swapl(&pEv->changedIndicators,n);
		swaps(&pEv->changedVirtualMods,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendCompatMapNotify(DeviceIntPtr kbd,xkbCompatMapNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		firstSI = 0, nSI = 0, nTotalSI = 0;

    interest = kbd->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->compatNotifyMask)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbCompatMapNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		firstSI= pEv->firstSI;
		nSI= pEv->nSI;
		nTotalSI= pEv->nTotalSI;
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->firstSI = firstSI;
	    pEv->nSI = nSI;
	    pEv->nTotalSI = nTotalSI;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->firstSI,n);
		swaps(&pEv->nSI,n);
		swaps(&pEv->nTotalSI,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendActionMessage(DeviceIntPtr kbd,xkbActionMessage *pEv)
{
int		 initialized;
XkbSrvInfoPtr	 xkbi;
XkbInterestPtr	 interest;
Time 		 time = 0;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
	return;
 
    xkbi = kbd->key->xkbInfo;

    initialized = 0;
    pEv->mods= xkbi->state.mods;
    pEv->group= xkbi->state.group;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->actionMessageMask)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbActionMessage;
		pEv->deviceID = kbd->id;
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendExtensionDeviceNotify(	DeviceIntPtr 			dev,
				ClientPtr			client,
				xkbExtensionDeviceNotify *	pEv)
{
int		 initialized;
XkbInterestPtr	 interest;
Time 		 time = 0;
CARD32		 defined, state;
CARD16		 reason;

    interest = dev->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    reason= pEv->reason;
    defined= pEv->ledsDefined;
    state= pEv->ledState;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->extDevNotifyMask&reason)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbExtensionDeviceNotify;
		pEv->deviceID = dev->id;
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    else {
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time;
		pEv->ledsDefined= defined;
		pEv->ledState= state;
		pEv->reason= reason;
		pEv->supported= XkbXI_AllFeaturesMask;
	    }
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swapl(&pEv->ledsDefined,n);
		swapl(&pEv->ledState,n);
		swaps(&pEv->reason,n);
		swaps(&pEv->supported,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendNotification(	DeviceIntPtr		kbd,
			XkbChangesPtr		pChanges,
			XkbEventCausePtr	cause)
{
XkbSrvLedInfoPtr	sli;

    sli= NULL;
    if (pChanges->state_changes) {
	xkbStateNotify sn;
	sn.changed= pChanges->state_changes;
	sn.keycode= cause->kc;
	sn.eventType= cause->event;
	sn.requestMajor= cause->mjr;
	sn.requestMinor= cause->mnr;
	XkbSendStateNotify(kbd,&sn);
    }
    if (pChanges->map.changed) {
	xkbMapNotify mn;
	memset(&mn, 0, sizeof(xkbMapNotify));
	mn.changed= pChanges->map.changed;
	mn.firstType= pChanges->map.first_type;
	mn.nTypes= pChanges->map.num_types;
	mn.firstKeySym= pChanges->map.first_key_sym;
	mn.nKeySyms= pChanges->map.num_key_syms;
	mn.firstKeyAct= pChanges->map.first_key_act;
	mn.nKeyActs= pChanges->map.num_key_acts;
	mn.firstKeyBehavior= pChanges->map.first_key_behavior;
	mn.nKeyBehaviors= pChanges->map.num_key_behaviors;
	mn.virtualMods= pChanges->map.vmods;
	mn.firstKeyExplicit= pChanges->map.first_key_explicit;
	mn.nKeyExplicit= pChanges->map.num_key_explicit;
	mn.firstModMapKey= pChanges->map.first_modmap_key;
	mn.nModMapKeys= pChanges->map.num_modmap_keys;
	mn.firstVModMapKey= pChanges->map.first_vmodmap_key;
	mn.nVModMapKeys= pChanges->map.num_vmodmap_keys;
	XkbSendMapNotify(kbd,&mn);
    }
    if ((pChanges->ctrls.changed_ctrls)||
	(pChanges->ctrls.enabled_ctrls_changes)) {
	xkbControlsNotify cn;
	memset(&cn, 0, sizeof(xkbControlsNotify));
	cn.changedControls= pChanges->ctrls.changed_ctrls;
	cn.enabledControlChanges= pChanges->ctrls.enabled_ctrls_changes;
	cn.keycode= cause->kc;
	cn.eventType= cause->event;
	cn.requestMajor= cause->mjr;
	cn.requestMinor= cause->mnr;
	XkbSendControlsNotify(kbd,&cn);
    }
    if (pChanges->indicators.map_changes) {
	xkbIndicatorNotify in;
	if (sli==NULL)
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	memset(&in, 0, sizeof(xkbIndicatorNotify));
	in.state= sli->effectiveState;
	in.changed= pChanges->indicators.map_changes;
	XkbSendIndicatorNotify(kbd,XkbIndicatorMapNotify,&in);
    }
    if (pChanges->indicators.state_changes) {
	xkbIndicatorNotify in;
	if (sli==NULL)
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	memset(&in, 0, sizeof(xkbIndicatorNotify));
	in.state= sli->effectiveState;
	in.changed= pChanges->indicators.state_changes;
	XkbSendIndicatorNotify(kbd,XkbIndicatorStateNotify,&in);
    }
    if (pChanges->names.changed) {
	xkbNamesNotify nn;
	memset(&nn, 0, sizeof(xkbNamesNotify));
	nn.changed= pChanges->names.changed;
	nn.firstType= pChanges->names.first_type;
	nn.nTypes= pChanges->names.num_types;
	nn.firstLevelName= pChanges->names.first_lvl;
	nn.nLevelNames= pChanges->names.num_lvls;
	nn.nRadioGroups= pChanges->names.num_rg;
	nn.changedVirtualMods= pChanges->names.changed_vmods;
	nn.changedIndicators= pChanges->names.changed_indicators;
	XkbSendNamesNotify(kbd,&nn);
    }
    if ((pChanges->compat.changed_groups)||(pChanges->compat.num_si>0)) {
	xkbCompatMapNotify cmn;
	memset(&cmn, 0, sizeof(xkbCompatMapNotify));
	cmn.changedGroups= pChanges->compat.changed_groups;
	cmn.firstSI= pChanges->compat.first_si;
	cmn.nSI= pChanges->compat.num_si;
	cmn.nTotalSI= kbd->key->xkbInfo->desc->compat->num_si;
	XkbSendCompatMapNotify(kbd,&cmn);
    }
    return;
}

/***====================================================================***/

void
XkbFilterEvents(ClientPtr client,int nEvents,xEvent *xE)
{
    DeviceIntPtr dev = NULL;
    XkbSrvInfoPtr xkbi;
    CARD8 type = xE[0].u.u.type;

    if (xE->u.u.type & EXTENSION_EVENT_BASE)
        dev = XIGetDevice(xE);

    if (!dev)
        dev = PickKeyboard(client);

    if (!dev->key)
        return;

    xkbi = dev->key->xkbInfo;

    if (client->xkbClientFlags & _XkbClientInitialized) {
	if ((xkbDebugFlags&0x10)&&
            (type == KeyPress || type == KeyRelease ||
             type == DeviceKeyPress || type == DeviceKeyRelease))
	    DebugF("[xkb] XkbFilterWriteEvents (XKB client): state 0x%04x\n",
                   xE[0].u.keyButtonPointer.state);

	if (dev->deviceGrab.grab != NullGrab && dev->deviceGrab.fromPassiveGrab &&
	    (type == KeyPress || type == KeyRelease ||
             type == DeviceKeyPress || type == DeviceKeyRelease)) {
	    unsigned int state, flags;

	    flags = client->xkbClientFlags;
	    state = xkbi->state.compat_grab_mods;
	    if (flags & XkbPCF_GrabsUseXKBStateMask) {
		int group;
		if (flags & XkbPCF_LookupStateWhenGrabbed) {
		     group = xkbi->state.group;
		     state = xkbi->state.lookup_mods;
		}
		else {
		    state = xkbi->state.grab_mods;
		    group = xkbi->state.base_group + xkbi->state.latched_group;
		    if (group < 0 || group >= xkbi->desc->ctrls->num_groups)
			group = XkbAdjustGroup(group, xkbi->desc->ctrls);
		}
		state = XkbBuildCoreState(state, group);
	    }
	    else if (flags & XkbPCF_LookupStateWhenGrabbed) {
		state = xkbi->state.compat_lookup_mods;
            }
	    xE[0].u.keyButtonPointer.state = state;
	}
    }
    else {
        if ((xkbDebugFlags & 0x4) &&
	    (xE[0].u.u.type == KeyPress || xE[0].u.u.type==KeyRelease ||
             xE[0].u.u.type == DeviceKeyPress ||
             xE[0].u.u.type == DeviceKeyRelease)) {
	    DebugF("[xkb] XKbFilterWriteEvents (non-XKB):\n");
	    DebugF("[xkb] event= 0x%04x\n",xE[0].u.keyButtonPointer.state);
	    DebugF("[xkb] lookup= 0x%02x, grab= 0x%02x\n",
                   xkbi->state.lookup_mods, xkbi->state.grab_mods);
	    DebugF("[xkb] compat lookup= 0x%02x, grab= 0x%02x\n",
		   xkbi->state.compat_lookup_mods, xkbi->state.compat_grab_mods);
	}
	if (type >= KeyPress && type <= MotionNotify) {
	    CARD16 old, new;

	    old = xE[0].u.keyButtonPointer.state & ~0x1f00;
	    new = xE[0].u.keyButtonPointer.state & 0x1F00;

	    if (old == XkbStateFieldFromRec(&xkbi->state))
		new |= xkbi->state.compat_lookup_mods;
	    else
                new |= xkbi->state.compat_grab_mods;
	    xE[0].u.keyButtonPointer.state = new;
	}
	else if (type == EnterNotify || type == LeaveNotify) {
	    xE[0].u.enterLeave.state &= 0x1F00;
	    xE[0].u.enterLeave.state |= xkbi->state.compat_grab_mods;
	}
        else if (type >= DeviceKeyPress && type <= DeviceMotionNotify) {
            CARD16 old, new;
            deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer*) &xE[0];

            old = kbp->state & ~0x1F00;
            new = kbp->state & 0x1F00;
	    if (old == XkbStateFieldFromRec(&xkbi->state))
		new |= xkbi->state.compat_lookup_mods;
	    else
                new |= xkbi->state.compat_grab_mods;
            kbp->state = new;
        }
    }
}

/***====================================================================***/

XkbInterestPtr
XkbFindClientResource(DevicePtr inDev,ClientPtr client)
{
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;

    if ( dev->xkb_interest ) {
	interest = dev->xkb_interest;
	while (interest){
	    if (interest->client==client) {
		return interest;
	    }
	    interest = interest->next;
	}
    }
    return NULL;
}

XkbInterestPtr
XkbAddClientResource(DevicePtr inDev,ClientPtr client,XID id)
{
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;

    interest = dev->xkb_interest;
    while (interest) {
	if (interest->client==client)
	    return ((interest->resource==id)?interest:NULL);
	interest = interest->next;
    }
    interest = calloc(1, sizeof(XkbInterestRec));
    if (interest) {
	interest->dev = dev;
	interest->client = client;
	interest->resource = id;
	interest->next = dev->xkb_interest;
	dev->xkb_interest= interest;
	return interest;
    }
    return NULL;
}

int
XkbRemoveResourceClient(DevicePtr inDev,XID id) 
{
XkbSrvInfoPtr	xkbi;
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;
Bool		found;
unsigned long	autoCtrls,autoValues;
ClientPtr	client = NULL;

    found= FALSE;

    if (!dev->key || !dev->key->xkbInfo)
        return found;

    autoCtrls= autoValues= 0;
    if ( dev->xkb_interest ) {
	interest = dev->xkb_interest;
	if (interest && (interest->resource==id)){
	    dev->xkb_interest = interest->next;
	    autoCtrls= interest->autoCtrls;
	    autoValues= interest->autoCtrlValues;
	    client= interest->client;
	    free(interest);
	    found= TRUE;
	}
	while ((!found)&&(interest->next)) {
	    if (interest->next->resource==id) {
		XkbInterestPtr	victim = interest->next;
		interest->next = victim->next;
		autoCtrls= victim->autoCtrls;
		autoValues= victim->autoCtrlValues;
		client= victim->client;
		free(victim);
		found= TRUE;
	    }
	    interest = interest->next;
	}
    }
    if (found && autoCtrls && dev->key && dev->key->xkbInfo ) {
	XkbEventCauseRec cause;

	xkbi= dev->key->xkbInfo;
	XkbSetCauseXkbReq(&cause,X_kbPerClientFlags,client);
	XkbEnableDisableControls(xkbi,autoCtrls,autoValues,NULL,&cause);
    }
    return found;
}
/************************************************************
 Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include <X11/Xos.h>
#include <X11/Xfuncs.h>
#include <X11/extensions/XKMformat.h>

#include <X11/X.h>
#include <X11/keysym.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS	1
#include <xkbsrv.h>
#include "xkbgeom.h"
#include "xkb.h"

unsigned
_XkbKSCheckCase(KeySym ks)
{
unsigned	set,rtrn;

    set= (ks & (~0xff)) >> 8;
    rtrn= 0;
    switch (set) {
	case 0:		/* latin 1 */
	    if (((ks>=XK_A)&&(ks<=XK_Z))||
		((ks>=XK_Agrave)&&(ks<=XK_THORN)&&(ks!=XK_multiply))) {
		rtrn|= _XkbKSUpper;
	    }
	    if (((ks>=XK_a)&&(ks<=XK_z))||
		((ks>=XK_ssharp)&&(ks<=XK_ydiaeresis)&&(ks!=XK_division))) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 1:		/* latin 2 */
	    if (((ks>=XK_Aogonek)&&(ks<=XK_Zabovedot)&&(ks!=XK_breve))||
		((ks>=XK_Racute)&&(ks<=XK_Tcedilla))) {
		rtrn|= _XkbKSUpper;
	    }
	    if (((ks>=XK_aogonek)&&(ks<=XK_zabovedot)&&(ks!=XK_ogonek)&&(ks!=XK_caron)&&(ks!=XK_doubleacute))||
		((ks>=XK_racute)&&(ks<=XK_tcedilla))) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 2:		/* latin 3 */
	    if (((ks>=XK_Hstroke)&&(ks<=XK_Jcircumflex))||
		((ks>=XK_Cabovedot)&&(ks<=XK_Scircumflex))) {
		rtrn|= _XkbKSUpper;
	    }
	    if (((ks>=XK_hstroke)&&(ks<=XK_jcircumflex))||
		((ks>=XK_cabovedot)&&(ks<=XK_scircumflex))) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 3:		/* latin 4 */
	    if (((ks>=XK_Rcedilla)&&(ks<=XK_Tslash))||
	        (ks==XK_ENG)||
		((ks>=XK_Amacron)&&(ks<=XK_Umacron))) {
		rtrn|= _XkbKSUpper;
	    }
	    if ((ks==XK_kra)||
	        ((ks>=XK_rcedilla)&&(ks<=XK_tslash))||
	        (ks==XK_eng)||
		((ks>=XK_amacron)&&(ks<=XK_umacron))) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 18:		/* latin 8 */
	    if ((ks==XK_Wcircumflex)||
		(ks==XK_Ycircumflex)||
		(ks==XK_Babovedot)||
		(ks==XK_Dabovedot)||
		(ks==XK_Fabovedot)||
		(ks==XK_Mabovedot)||
		(ks==XK_Pabovedot)||
		(ks==XK_Sabovedot)||
		(ks==XK_Tabovedot)||
		(ks==XK_Wgrave)||
		(ks==XK_Wacute)||
		(ks==XK_Wdiaeresis)||
		(ks==XK_Ygrave)) {
		rtrn|= _XkbKSUpper;
	    }
	    if ((ks==XK_wcircumflex)||
		(ks==XK_ycircumflex)||
		(ks==XK_babovedot)||
		(ks==XK_dabovedot)||
		(ks==XK_fabovedot)||
		(ks==XK_mabovedot)||
		(ks==XK_pabovedot)||
		(ks==XK_sabovedot)||
		(ks==XK_tabovedot)||
		(ks==XK_wgrave)||
		(ks==XK_wacute)||
		(ks==XK_wdiaeresis)||
		(ks==XK_ygrave)) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 19:		/* latin 9 */
	    if ((ks==XK_OE)||(ks==XK_Ydiaeresis)) {
		rtrn|= _XkbKSUpper;
	    }
	    if (ks==XK_oe) {
		rtrn|= _XkbKSLower;
	    }
	    break;
    }
    return rtrn;
}

/***===================================================================***/

static Bool
XkbWriteSectionFromName(FILE *file,char *sectionName,char *name)
{
    fprintf(file,"    xkb_%-20s { include \"%s\" };\n",sectionName,name);
    return TRUE;
}

#define	NEED_DESC(n) ((!n)||((n)[0]=='+')||((n)[0]=='|')||(strchr((n),'%')))
#define	COMPLETE(n)  ((n)&&(!NEED_DESC(n)))

/* ARGSUSED */
static void
_AddIncl(	FILE *		file,
		XkbDescPtr 	xkb,
		Bool 		topLevel,
		Bool 		showImplicit,
		int 		index,
		void *		priv)
{
    if ((priv)&&(strcmp((char *)priv,"%")!=0))
	fprintf(file,"    include \"%s\"\n",(char *)priv);
    return;
}

Bool
XkbWriteXKBKeymapForNames(	FILE *			file,
				XkbComponentNamesPtr	names,
				XkbDescPtr		xkb,
				unsigned		want,
				unsigned		need)
{
const char *	tmp;
unsigned	complete;
XkbNamesPtr	old_names;
int		multi_section;
unsigned	wantNames,wantConfig,wantDflts;

    complete= 0;
    if (COMPLETE(names->keycodes))	complete|= XkmKeyNamesMask;
    if (COMPLETE(names->types))		complete|= XkmTypesMask;
    if (COMPLETE(names->compat))	complete|= XkmCompatMapMask;
    if (COMPLETE(names->symbols))	complete|= XkmSymbolsMask;
    if (COMPLETE(names->geometry))	complete|= XkmGeometryMask;
    want|= (complete|need);
    if (want&XkmSymbolsMask)
	want|= XkmKeyNamesMask|XkmTypesMask;

    if (want==0)
	return FALSE;

    if (xkb) {
        old_names = xkb->names;

        xkb->defined = 0;
        /* Wow would it ever be neat if we didn't need this noise. */
        if (xkb->names && xkb->names->keys)
            xkb->defined |= XkmKeyNamesMask;
        if (xkb->map && xkb->map->types)
            xkb->defined |= XkmTypesMask;
        if (xkb->compat)
            xkb->defined |= XkmCompatMapMask;
        if (xkb->map && xkb->map->num_syms)
            xkb->defined |= XkmSymbolsMask;
        if (xkb->indicators)
            xkb->defined |= XkmIndicatorsMask;
        if (xkb->geom)
            xkb->defined |= XkmGeometryMask;
    }
    else {
        old_names= NULL;
    }

    wantConfig= want&(~complete);
    if (xkb!=NULL) {
	if (wantConfig&XkmTypesMask) {
	    if ((!xkb->map) || (xkb->map->num_types<XkbNumRequiredTypes))
		wantConfig&= ~XkmTypesMask;
	}
	if (wantConfig&XkmCompatMapMask) {
	    if ((!xkb->compat) || (xkb->compat->num_si<1))
		wantConfig&= ~XkmCompatMapMask;
	}
	if (wantConfig&XkmSymbolsMask) {
	    if ((!xkb->map) || (!xkb->map->key_sym_map))
		wantConfig&= ~XkmSymbolsMask;
	}
	if (wantConfig&XkmIndicatorsMask) {
	    if (!xkb->indicators)
		wantConfig&= ~XkmIndicatorsMask;
	}
	if (wantConfig&XkmKeyNamesMask) {
	    if ((!xkb->names)||(!xkb->names->keys))
		wantConfig&= ~XkmKeyNamesMask;
	}
	if ((wantConfig&XkmGeometryMask)&&(!xkb->geom))
	    wantConfig&= ~XkmGeometryMask;
    }
    else {
	wantConfig= 0;
    }
    complete|= wantConfig;

    wantDflts= 0;
    wantNames= want&(~complete);
    if ((xkb!=NULL) && (old_names!=NULL)) {
	if (wantNames&XkmTypesMask) {
	    if (old_names->types!=None) {
		tmp= NameForAtom(old_names->types);
		names->types= Xstrdup(tmp);
	    }
	    else {
		wantDflts|= XkmTypesMask;
	    }
	    complete|= XkmTypesMask; 
	}
	if (wantNames&XkmCompatMapMask) {
	    if (old_names->compat!=None) {
		tmp= NameForAtom(old_names->compat);
		names->compat= Xstrdup(tmp);
	    }
	    else wantDflts|= XkmCompatMapMask;
	    complete|= XkmCompatMapMask; 
	}
	if (wantNames&XkmSymbolsMask) {
	    if (old_names->symbols==None)
		return FALSE;
	    tmp= NameForAtom(old_names->symbols);
	    names->symbols= Xstrdup(tmp);
	    complete|= XkmSymbolsMask; 
	}
	if (wantNames&XkmKeyNamesMask) {
	   if (old_names->keycodes!=None) {
		tmp= NameForAtom(old_names->keycodes);
		names->keycodes= Xstrdup(tmp);
	    }
	    else wantDflts|= XkmKeyNamesMask;
	    complete|= XkmKeyNamesMask;
	}
	if (wantNames&XkmGeometryMask) {
	    if (old_names->geometry==None)
		return FALSE;
	    tmp= NameForAtom(old_names->geometry);
	    names->geometry= Xstrdup(tmp);
	    complete|= XkmGeometryMask; 
	    wantNames&= ~XkmGeometryMask;
	}
    }
    if (complete&XkmCompatMapMask)
	complete|= XkmIndicatorsMask|XkmVirtualModsMask;
    else if (complete&(XkmSymbolsMask|XkmTypesMask))
	complete|= XkmVirtualModsMask;
    if (need & (~complete))
	return FALSE;
    if ((complete&XkmSymbolsMask)&&((XkmKeyNamesMask|XkmTypesMask)&(~complete)))
	return FALSE;

    multi_section= 1;
    if (((complete&XkmKeymapRequired)==XkmKeymapRequired)&&
	((complete&(~XkmKeymapLegal))==0)) {
	fprintf(file,"xkb_keymap \"default\" {\n");
    }
    else if (((complete&XkmSemanticsRequired)==XkmSemanticsRequired)&&
	((complete&(~XkmSemanticsLegal))==0)) {
	fprintf(file,"xkb_semantics \"default\" {\n");
    }
    else if (((complete&XkmLayoutRequired)==XkmLayoutRequired)&&
	((complete&(~XkmLayoutLegal))==0)) {
	fprintf(file,"xkb_layout \"default\" {\n");
    }
    else if (XkmSingleSection(complete&(~XkmVirtualModsMask))) {
	multi_section= 0;
    }
    else {
	return FALSE;
    }

    wantNames= complete&(~(wantConfig|wantDflts));
    if (wantConfig&XkmKeyNamesMask)
	XkbWriteXKBKeycodes(file,xkb,FALSE,FALSE,_AddIncl,names->keycodes);
    else if (wantDflts&XkmKeyNamesMask)
	fprintf(stderr,"Default symbols not implemented yet!\n");
    else if (wantNames&XkmKeyNamesMask)
	XkbWriteSectionFromName(file,"keycodes",names->keycodes);

    if (wantConfig&XkmTypesMask)
	XkbWriteXKBKeyTypes(file,xkb,FALSE,FALSE,_AddIncl,names->types);
    else if (wantDflts&XkmTypesMask)
	fprintf(stderr,"Default types not implemented yet!\n");
    else if (wantNames&XkmTypesMask)
	XkbWriteSectionFromName(file,"types",names->types);

    if (wantConfig&XkmCompatMapMask)
	XkbWriteXKBCompatMap(file,xkb,FALSE,FALSE,_AddIncl,names->compat);
    else if (wantDflts&XkmCompatMapMask)
	fprintf(stderr,"Default interps not implemented yet!\n");
    else if (wantNames&XkmCompatMapMask)
	XkbWriteSectionFromName(file,"compatibility",names->compat);

    if (wantConfig&XkmSymbolsMask)
	XkbWriteXKBSymbols(file,xkb,FALSE,FALSE,_AddIncl,names->symbols);
    else if (wantNames&XkmSymbolsMask)
	XkbWriteSectionFromName(file,"symbols",names->symbols);

    if (wantConfig&XkmGeometryMask)
	XkbWriteXKBGeometry(file,xkb,FALSE,FALSE,_AddIncl,names->geometry);
    else if (wantNames&XkmGeometryMask)
	XkbWriteSectionFromName(file,"geometry",names->geometry);

    if (multi_section)
	fprintf(file,"};\n");
    return TRUE;
}

/***====================================================================***/

int
XkbFindKeycodeByName(XkbDescPtr xkb,char *name,Bool use_aliases)
{
register int	i;

    if ((!xkb)||(!xkb->names)||(!xkb->names->keys))
	return 0;
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	if (strncmp(xkb->names->keys[i].name,name,XkbKeyNameLength)==0)
	    return i;
    }
    if (!use_aliases)
	return 0;
    if (xkb->geom && xkb->geom->key_aliases) {
	XkbKeyAliasPtr	a;
	a= xkb->geom->key_aliases;
	for (i=0;i<xkb->geom->num_key_aliases;i++,a++) {
	    if (strncmp(name,a->alias,XkbKeyNameLength)==0)
		return XkbFindKeycodeByName(xkb,a->real,FALSE);
	}
    }
    if (xkb->names && xkb->names->key_aliases) {
	XkbKeyAliasPtr	a;
	a= xkb->names->key_aliases;
	for (i=0;i<xkb->names->num_key_aliases;i++,a++) {
	    if (strncmp(name,a->alias,XkbKeyNameLength)==0)
		return XkbFindKeycodeByName(xkb,a->real,FALSE);
	}
    }
    return 0;
}


unsigned
XkbConvertGetByNameComponents(Bool toXkm,unsigned orig)
{
unsigned	rtrn;

    rtrn= 0;
    if (toXkm) {
	if (orig&XkbGBN_TypesMask)		rtrn|= XkmTypesMask;
	if (orig&XkbGBN_CompatMapMask)		rtrn|= XkmCompatMapMask;
	if (orig&XkbGBN_SymbolsMask)		rtrn|= XkmSymbolsMask;
	if (orig&XkbGBN_IndicatorMapMask)	rtrn|= XkmIndicatorsMask;
	if (orig&XkbGBN_KeyNamesMask)		rtrn|= XkmKeyNamesMask;
	if (orig&XkbGBN_GeometryMask)		rtrn|= XkmGeometryMask;
    }
    else {
	if (orig&XkmTypesMask)			rtrn|= XkbGBN_TypesMask;
	if (orig&XkmCompatMapMask)		rtrn|= XkbGBN_CompatMapMask;
	if (orig&XkmSymbolsMask)		rtrn|= XkbGBN_SymbolsMask;
	if (orig&XkmIndicatorsMask)		rtrn|= XkbGBN_IndicatorMapMask;
	if (orig&XkmKeyNamesMask)		rtrn|= XkbGBN_KeyNamesMask;
	if (orig&XkmGeometryMask)		rtrn|= XkbGBN_GeometryMask;
	if (orig!=0)				rtrn|= XkbGBN_OtherNamesMask;
    }
    return rtrn;
}

/***====================================================================***/

#define	UNMATCHABLE(c)	(((c)=='(')||((c)==')')||((c)=='/'))

Bool
XkbNameMatchesPattern(char *name,char *ptrn)
{
    while (ptrn[0]!='\0') {
	if (name[0]=='\0') {
	    if (ptrn[0]=='*') {
		ptrn++;
		continue;
	    }
	    return FALSE;
	}
	if (ptrn[0]=='?') {
	    if (UNMATCHABLE(name[0]))
		return FALSE;
	}
	else if (ptrn[0]=='*') {
	    if ((!UNMATCHABLE(name[0]))&&XkbNameMatchesPattern(name+1,ptrn))
		return TRUE;
	    return XkbNameMatchesPattern(name,ptrn+1);
	}
	else if (ptrn[0]!=name[0])
	    return FALSE;
	name++;
	ptrn++;
    }
    /* if we get here, the pattern is exhausted (-:just like me:-) */
    return name[0]=='\0';
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif


#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <xkbsrv.h>
#include "xkbgeom.h"

/***====================================================================***/

static void 
_XkbFreeGeomLeafElems(	Bool			freeAll,
			int			first,
			int 			count,
			unsigned short *	num_inout,
			unsigned short *	sz_inout,
			char **			elems,
			unsigned int		elem_sz)
{
    if ((freeAll)||(*elems==NULL)) {
	*num_inout= *sz_inout= 0;
	free(*elems);
	*elems = NULL;
	return;
    }

    if ((first>=(*num_inout))||(first<0)||(count<1))
	return;

    if (first+count>=(*num_inout)) { 
	/* truncating the array is easy */
	(*num_inout)= first;
    }
    else {
	char *	ptr;
	int 	extra;
	ptr= *elems;
	extra= ((*num_inout)-(first+count))*elem_sz;
	if (extra>0)
	    memmove(&ptr[first*elem_sz],&ptr[(first+count)*elem_sz],extra);
	(*num_inout)-= count;
    }
    return;
}

typedef void (*ContentsClearFunc)(
		char *		/* priv */
);

static void 
_XkbFreeGeomNonLeafElems(	Bool			freeAll,
				int			first,
				int 			count,
				unsigned short *	num_inout,
				unsigned short *	sz_inout,
				char **			elems,
				unsigned int		elem_sz,
				ContentsClearFunc	freeFunc)
{
register int i;
register char *ptr;

    if (freeAll) {
	first= 0;
	count= (*num_inout);
    }
    else if ((first>=(*num_inout))||(first<0)||(count<1))
	return;
    else if (first+count>(*num_inout))
	count= (*num_inout)-first;
    if (*elems==NULL)
	return;

    if (freeFunc) {
	ptr= *elems;
	ptr+= first*elem_sz;
	for (i=0;i<count;i++) {
	    (*freeFunc)(ptr);
	    ptr+= elem_sz;
	}
    }
    if (freeAll) {
	(*num_inout)= (*sz_inout)= 0;
	free(*elems);
	*elems = NULL;
    }
    else if (first+count>=(*num_inout))
	*num_inout= first;
    else {
	i= ((*num_inout)-(first+count))*elem_sz;
	ptr= *elems;
	memmove(&ptr[first*elem_sz],&ptr[(first+count)*elem_sz],i);
	(*num_inout)-= count;
    }
    return;
}

/***====================================================================***/

static void
_XkbClearProperty(char *prop_in)
{
XkbPropertyPtr	prop= (XkbPropertyPtr)prop_in;

    free(prop->name);
    prop->name = NULL;
    free(prop->value);
    prop->value = NULL;
    return;
}

void
XkbFreeGeomProperties(	XkbGeometryPtr	geom,
			int		first,
			int		count,
			Bool		freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_properties,&geom->sz_properties,
				(char **)&geom->properties,
				sizeof(XkbPropertyRec),_XkbClearProperty);
    return;
}

/***====================================================================***/

void
XkbFreeGeomKeyAliases(	XkbGeometryPtr	geom,
			int		first,
			int		count,
			Bool		freeAll)
{	
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&geom->num_key_aliases,&geom->sz_key_aliases,
				(char **)&geom->key_aliases,
				sizeof(XkbKeyAliasRec));
    return;
}

/***====================================================================***/

static void
_XkbClearColor(char *color_in)
{
XkbColorPtr	color= (XkbColorPtr)color_in;

    free(color->spec);
    return;
}

void
XkbFreeGeomColors(XkbGeometryPtr geom,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_colors,&geom->sz_colors,
				(char **)&geom->colors,
				sizeof(XkbColorRec),_XkbClearColor);
    return;
}

/***====================================================================***/

void
XkbFreeGeomPoints(XkbOutlinePtr outline,int first,int count,Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&outline->num_points,&outline->sz_points,
				(char **)&outline->points,
				sizeof(XkbPointRec));
    return;
}

/***====================================================================***/

static void
_XkbClearOutline(char *outline_in)
{
XkbOutlinePtr	outline= (XkbOutlinePtr)outline_in;

    if (outline->points!=NULL)
	XkbFreeGeomPoints(outline,0,outline->num_points,TRUE);
    return;
}

void
XkbFreeGeomOutlines(XkbShapePtr	shape,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&shape->num_outlines,&shape->sz_outlines,
				(char **)&shape->outlines,
				sizeof(XkbOutlineRec),_XkbClearOutline);
	
    return;
}

/***====================================================================***/

static void
_XkbClearShape(char *shape_in)
{
XkbShapePtr	shape= (XkbShapePtr)shape_in;

    if (shape->outlines)
	XkbFreeGeomOutlines(shape,0,shape->num_outlines,TRUE);
    return;
}

void
XkbFreeGeomShapes(XkbGeometryPtr geom,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_shapes,&geom->sz_shapes,
				(char **)&geom->shapes,
				sizeof(XkbShapeRec),_XkbClearShape);
    return;
}

/***====================================================================***/

void 
XkbFreeGeomOverlayKeys(XkbOverlayRowPtr row,int first,int count,Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&row->num_keys,&row->sz_keys,
				(char **)&row->keys,
				sizeof(XkbOverlayKeyRec));
    return;
}

/***====================================================================***/

static void
_XkbClearOverlayRow(char *row_in)
{
XkbOverlayRowPtr	row= (XkbOverlayRowPtr)row_in;

    if (row->keys!=NULL)
	XkbFreeGeomOverlayKeys(row,0,row->num_keys,TRUE);
    return;
}

void
XkbFreeGeomOverlayRows(XkbOverlayPtr overlay,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&overlay->num_rows,&overlay->sz_rows,
				(char **)&overlay->rows,
				sizeof(XkbOverlayRowRec),_XkbClearOverlayRow);
    return;
}

/***====================================================================***/

static void
_XkbClearOverlay(char *overlay_in)
{
XkbOverlayPtr	overlay= (XkbOverlayPtr)overlay_in;

    if (overlay->rows!=NULL)
	XkbFreeGeomOverlayRows(overlay,0,overlay->num_rows,TRUE);
    return;
}

void
XkbFreeGeomOverlays(XkbSectionPtr section,int first,int	count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&section->num_overlays,&section->sz_overlays,
				(char **)&section->overlays,
				sizeof(XkbOverlayRec),_XkbClearOverlay);
    return;
}

/***====================================================================***/

void
XkbFreeGeomKeys(XkbRowPtr row,int first,int count,Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&row->num_keys,&row->sz_keys,
				(char **)&row->keys,
				sizeof(XkbKeyRec));
    return;
}

/***====================================================================***/

static void
_XkbClearRow(char *row_in)
{
XkbRowPtr	row= (XkbRowPtr)row_in;

    if (row->keys!=NULL)
	XkbFreeGeomKeys(row,0,row->num_keys,TRUE);
    return;
}

void
XkbFreeGeomRows(XkbSectionPtr section,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&section->num_rows,&section->sz_rows,
				(char **)&section->rows,
				sizeof(XkbRowRec),_XkbClearRow);
}

/***====================================================================***/

static void
_XkbClearSection(char *section_in)
{
XkbSectionPtr	section= (XkbSectionPtr)section_in;

    if (section->rows!=NULL)
	XkbFreeGeomRows(section,0,section->num_rows,TRUE);
    if (section->doodads!=NULL) {
	XkbFreeGeomDoodads(section->doodads,section->num_doodads,TRUE);
	section->doodads= NULL;
    }
    return;
}

void
XkbFreeGeomSections(XkbGeometryPtr geom,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_sections,&geom->sz_sections,
				(char **)&geom->sections,
				sizeof(XkbSectionRec),_XkbClearSection);
    return;
}

/***====================================================================***/

static void
_XkbClearDoodad(char *doodad_in)
{
XkbDoodadPtr	doodad= (XkbDoodadPtr)doodad_in;

    switch (doodad->any.type) {
   	case XkbTextDoodad: 
	    {
		free(doodad->text.text);
		doodad->text.text = NULL;
		free(doodad->text.font);
		doodad->text.font = NULL;
	    }
	    break;
   	case XkbLogoDoodad: 
	    {
		free(doodad->logo.logo_name);
		doodad->logo.logo_name = NULL;
	    }
	    break;
    }
    return;
}

void
XkbFreeGeomDoodads(XkbDoodadPtr doodads,int nDoodads,Bool freeAll)
{
register int 		i;
register XkbDoodadPtr	doodad;

    if (doodads) {
	for (i=0,doodad= doodads;i<nDoodads;i++,doodad++) {
	    _XkbClearDoodad((char *)doodad);
	}
	if (freeAll)
	    free(doodads);
    }
    return;
}

void
XkbFreeGeometry(XkbGeometryPtr geom,unsigned which,Bool freeMap)
{
    if (geom==NULL)
	return;
    if (freeMap)
	which= XkbGeomAllMask;
    if ((which&XkbGeomPropertiesMask)&&(geom->properties!=NULL))
	XkbFreeGeomProperties(geom,0,geom->num_properties,TRUE);
    if ((which&XkbGeomColorsMask)&&(geom->colors!=NULL))
	XkbFreeGeomColors(geom,0,geom->num_colors,TRUE);
    if ((which&XkbGeomShapesMask)&&(geom->shapes!=NULL))
	XkbFreeGeomShapes(geom,0,geom->num_shapes,TRUE);
    if ((which&XkbGeomSectionsMask)&&(geom->sections!=NULL))
	XkbFreeGeomSections(geom,0,geom->num_sections,TRUE);
    if ((which&XkbGeomDoodadsMask)&&(geom->doodads!= NULL)) {
	XkbFreeGeomDoodads(geom->doodads,geom->num_doodads,TRUE);
	geom->doodads= NULL;
	geom->num_doodads= geom->sz_doodads= 0;
    }
    if ((which&XkbGeomKeyAliasesMask)&&(geom->key_aliases!=NULL))
	XkbFreeGeomKeyAliases(geom,0,geom->num_key_aliases,TRUE);
    if (freeMap) {
	free(geom->label_font);
	geom->label_font = NULL;
	free(geom);
    }
    return;
}

/***====================================================================***/

/**
 * Resize and clear an XKB geometry item array. The array size may
 * grow or shrink unlike in _XkbGeomAlloc.
 *
 * @param buffer[in,out]  buffer to reallocate and clear
 * @param szItems[in]     currently allocated item count for "buffer"
 * @param nrItems[in]     required item count for "buffer"
 * @param itemSize[in]    size of a single item in "buffer"
 * @param clearance[in]   items to clear after reallocation
 *
 * @see _XkbGeomAlloc
 *
 * @return TRUE if reallocation succeeded. Otherwise FALSE is returned
 *         and contents of "buffer" aren't touched.
 */
Bool
XkbGeomRealloc(void **buffer, int szItems, int nrItems,
               int itemSize, XkbGeomClearance clearance)
{
    void *items;
    int clearBegin;
    /* Check validity of arguments. */
    if (!buffer)
        return FALSE;
    items = *buffer;
    if (!((items && (szItems > 0)) || (!items && !szItems)))
        return FALSE;
    /* Check if there is need to resize. */
    if (nrItems != szItems)
        if (!(items = realloc(items, nrItems * itemSize)))
            return FALSE;
    /* Clear specified items to zero. */
    switch (clearance)
    {
    case XKB_GEOM_CLEAR_EXCESS:
        clearBegin = szItems;
        break;
    case XKB_GEOM_CLEAR_ALL:
        clearBegin = 0;
        break;
    case XKB_GEOM_CLEAR_NONE:
    default:
        clearBegin = nrItems;
        break;
    }
    if (items && (clearBegin < nrItems))
        memset((char *)items + (clearBegin * itemSize), 0, (nrItems - clearBegin) * itemSize);
    *buffer = items;
    return TRUE;
}

static Status
_XkbGeomAlloc(	void **		old,
		unsigned short *	num,
		unsigned short *	total,
		int			num_new,
		size_t			sz_elem)
{
    if (num_new<1)
	return Success;
    if ((*old)==NULL)
	*num= *total= 0;

    if ((*num)+num_new<=(*total))
	return Success;

    *total= (*num)+num_new;

    if (!XkbGeomRealloc(old, *num, *total, sz_elem, XKB_GEOM_CLEAR_EXCESS))
    {
	free(*old);
	(*old)= NULL;
	*total= *num= 0;
	return BadAlloc;
    }

    return Success;
}

#define	_XkbAllocProps(g,n) _XkbGeomAlloc((void *)&(g)->properties,\
				&(g)->num_properties,&(g)->sz_properties,\
				(n),sizeof(XkbPropertyRec))
#define	_XkbAllocColors(g,n) _XkbGeomAlloc((void *)&(g)->colors,\
				&(g)->num_colors,&(g)->sz_colors,\
				(n),sizeof(XkbColorRec))
#define	_XkbAllocShapes(g,n) _XkbGeomAlloc((void *)&(g)->shapes,\
				&(g)->num_shapes,&(g)->sz_shapes,\
				(n),sizeof(XkbShapeRec))
#define	_XkbAllocSections(g,n) _XkbGeomAlloc((void *)&(g)->sections,\
				&(g)->num_sections,&(g)->sz_sections,\
				(n),sizeof(XkbSectionRec))
#define	_XkbAllocDoodads(g,n) _XkbGeomAlloc((void *)&(g)->doodads,\
				&(g)->num_doodads,&(g)->sz_doodads,\
				(n),sizeof(XkbDoodadRec))
#define	_XkbAllocKeyAliases(g,n) _XkbGeomAlloc((void *)&(g)->key_aliases,\
				&(g)->num_key_aliases,&(g)->sz_key_aliases,\
				(n),sizeof(XkbKeyAliasRec))

#define	_XkbAllocOutlines(s,n) _XkbGeomAlloc((void *)&(s)->outlines,\
				&(s)->num_outlines,&(s)->sz_outlines,\
				(n),sizeof(XkbOutlineRec))
#define	_XkbAllocRows(s,n) _XkbGeomAlloc((void *)&(s)->rows,\
				&(s)->num_rows,&(s)->sz_rows,\
				(n),sizeof(XkbRowRec))
#define	_XkbAllocPoints(o,n) _XkbGeomAlloc((void *)&(o)->points,\
				&(o)->num_points,&(o)->sz_points,\
				(n),sizeof(XkbPointRec))
#define	_XkbAllocKeys(r,n) _XkbGeomAlloc((void *)&(r)->keys,\
				&(r)->num_keys,&(r)->sz_keys,\
				(n),sizeof(XkbKeyRec))
#define	_XkbAllocOverlays(s,n) _XkbGeomAlloc((void *)&(s)->overlays,\
				&(s)->num_overlays,&(s)->sz_overlays,\
				(n),sizeof(XkbOverlayRec))
#define	_XkbAllocOverlayRows(o,n) _XkbGeomAlloc((void *)&(o)->rows,\
				&(o)->num_rows,&(o)->sz_rows,\
				(n),sizeof(XkbOverlayRowRec))
#define	_XkbAllocOverlayKeys(r,n) _XkbGeomAlloc((void *)&(r)->keys,\
				&(r)->num_keys,&(r)->sz_keys,\
				(n),sizeof(XkbOverlayKeyRec))
    
Status
XkbAllocGeomProps(XkbGeometryPtr geom,int nProps)
{
    return _XkbAllocProps(geom,nProps);
}

Status
XkbAllocGeomColors(XkbGeometryPtr geom,int nColors)
{
    return _XkbAllocColors(geom,nColors);
}

Status
XkbAllocGeomKeyAliases(XkbGeometryPtr geom,int nKeyAliases)
{
    return _XkbAllocKeyAliases(geom,nKeyAliases);
}

Status
XkbAllocGeomShapes(XkbGeometryPtr geom,int nShapes)
{
    return _XkbAllocShapes(geom,nShapes);
}

Status
XkbAllocGeomSections(XkbGeometryPtr geom,int nSections)
{
    return _XkbAllocSections(geom,nSections);
}

Status
XkbAllocGeomOverlays(XkbSectionPtr section,int nOverlays)
{
    return _XkbAllocOverlays(section,nOverlays);
}

Status
XkbAllocGeomOverlayRows(XkbOverlayPtr overlay,int nRows)
{
    return _XkbAllocOverlayRows(overlay,nRows);
}

Status
XkbAllocGeomOverlayKeys(XkbOverlayRowPtr row,int nKeys)
{
    return _XkbAllocOverlayKeys(row,nKeys);
}

Status
XkbAllocGeomDoodads(XkbGeometryPtr geom,int nDoodads)
{
    return _XkbAllocDoodads(geom,nDoodads);
}

Status
XkbAllocGeomSectionDoodads(XkbSectionPtr section,int nDoodads)
{
    return _XkbAllocDoodads(section,nDoodads);
}

Status
XkbAllocGeomOutlines(XkbShapePtr shape,int nOL)
{
    return _XkbAllocOutlines(shape,nOL);
}

Status
XkbAllocGeomRows(XkbSectionPtr section,int nRows)
{
    return _XkbAllocRows(section,nRows);
}

Status
XkbAllocGeomPoints(XkbOutlinePtr ol,int nPts)
{
    return _XkbAllocPoints(ol,nPts);
}

Status
XkbAllocGeomKeys(XkbRowPtr row,int nKeys)
{
    return _XkbAllocKeys(row,nKeys);
}

Status
XkbAllocGeometry(XkbDescPtr xkb,XkbGeometrySizesPtr sizes)
{
XkbGeometryPtr	geom;
Status		rtrn;

    if (xkb->geom==NULL) {
	xkb->geom= calloc(1, sizeof(XkbGeometryRec));
	if (!xkb->geom)
	    return BadAlloc;
    }
    geom= xkb->geom;
    if ((sizes->which&XkbGeomPropertiesMask)&&
	((rtrn=_XkbAllocProps(geom,sizes->num_properties))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomColorsMask)&&
	((rtrn=_XkbAllocColors(geom,sizes->num_colors))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomShapesMask)&&
	((rtrn=_XkbAllocShapes(geom,sizes->num_shapes))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomSectionsMask)&&
	((rtrn=_XkbAllocSections(geom,sizes->num_sections))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomDoodadsMask)&&
	((rtrn=_XkbAllocDoodads(geom,sizes->num_doodads))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomKeyAliasesMask)&&
	((rtrn=_XkbAllocKeyAliases(geom,sizes->num_key_aliases))!=Success)) {
	goto BAIL;
    }
    return Success;
BAIL:
    XkbFreeGeometry(geom,XkbGeomAllMask,TRUE);
    xkb->geom= NULL;
    return rtrn;
}

/***====================================================================***/

XkbPropertyPtr
XkbAddGeomProperty(XkbGeometryPtr geom,char *name,char *value)
{
register int i;
register XkbPropertyPtr prop;

    if ((!geom)||(!name)||(!value))
	return NULL;
    for (i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	if ((prop->name)&&(strcmp(name,prop->name)==0)) {
	    free(prop->value);
	    prop->value= strdup(value);
	    return prop;
	}    
    }
    if ((geom->num_properties>=geom->sz_properties)&&
					(_XkbAllocProps(geom,1)!=Success)) {
	return NULL;
    }
    prop= &geom->properties[geom->num_properties];
    prop->name= strdup(name);
    if (!prop->name)
	return NULL;
    prop->value= strdup(value);
    if (!prop->value) {
	free(prop->name);
	prop->name= NULL;
	return NULL;
    }
    geom->num_properties++;
    return prop;
}

XkbKeyAliasPtr
XkbAddGeomKeyAlias(XkbGeometryPtr geom,char *aliasStr,char *realStr)
{
register int i;
register XkbKeyAliasPtr alias;

    if ((!geom)||(!aliasStr)||(!realStr)||(!aliasStr[0])||(!realStr[0]))
	return NULL;
    for (i=0,alias=geom->key_aliases;i<geom->num_key_aliases;i++,alias++) {
	if (strncmp(alias->alias,aliasStr,XkbKeyNameLength)==0) {
	    memset(alias->real, 0, XkbKeyNameLength);
	    strncpy(alias->real,realStr,XkbKeyNameLength);
	    return alias;
	}
    }
    if ((geom->num_key_aliases>=geom->sz_key_aliases)&&
				(_XkbAllocKeyAliases(geom,1)!=Success)) {
	return NULL;
    }
    alias= &geom->key_aliases[geom->num_key_aliases];
    memset(alias, 0, sizeof(XkbKeyAliasRec));
    strncpy(alias->alias,aliasStr,XkbKeyNameLength);
    strncpy(alias->real,realStr,XkbKeyNameLength);
    geom->num_key_aliases++;
    return alias;
}

XkbColorPtr
XkbAddGeomColor(XkbGeometryPtr geom,char *spec,unsigned int pixel)
{
register int i;
register XkbColorPtr color;

    if ((!geom)||(!spec))
	return NULL;
    for (i=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	if ((color->spec)&&(strcmp(color->spec,spec)==0)) {
	    color->pixel= pixel;
	    return color;
	}
    }
    if ((geom->num_colors>=geom->sz_colors)&&
					(_XkbAllocColors(geom,1)!=Success)) {
	return NULL;
    }
    color= &geom->colors[geom->num_colors];
    color->pixel= pixel;
    color->spec= strdup(spec);
    if (!color->spec)
	return NULL;
    geom->num_colors++;
    return color;
}

XkbOutlinePtr
XkbAddGeomOutline(XkbShapePtr shape,int sz_points)
{
XkbOutlinePtr	outline;

    if ((!shape)||(sz_points<0))
	return NULL;
    if ((shape->num_outlines>=shape->sz_outlines)&&
					(_XkbAllocOutlines(shape,1)!=Success)) {
	return NULL;
    }
    outline= &shape->outlines[shape->num_outlines];
    memset(outline, 0, sizeof(XkbOutlineRec));
    if ((sz_points>0)&&(_XkbAllocPoints(outline,sz_points)!=Success))
	return NULL;
    shape->num_outlines++;
    return outline;
}

XkbShapePtr
XkbAddGeomShape(XkbGeometryPtr geom,Atom name,int sz_outlines)
{
XkbShapePtr	shape;
register int	i;

    if ((!geom)||(!name)||(sz_outlines<0))
	return NULL;
    if (geom->num_shapes>0) {
	for (shape=geom->shapes,i=0;i<geom->num_shapes;i++,shape++) {
	    if (name==shape->name)
		return shape;
	}
    }
    if ((geom->num_shapes>=geom->sz_shapes)&&
					(_XkbAllocShapes(geom,1)!=Success))
	return NULL;
    shape= &geom->shapes[geom->num_shapes];
    memset(shape, 0, sizeof(XkbShapeRec));
    if ((sz_outlines>0)&&(_XkbAllocOutlines(shape,sz_outlines)!=Success))
	return NULL;
    shape->name= name;
    shape->primary= shape->approx= NULL;
    geom->num_shapes++;
    return shape;
}

XkbKeyPtr
XkbAddGeomKey(XkbRowPtr row)
{
XkbKeyPtr	key;
    if (!row)
	return NULL;
    if ((row->num_keys>=row->sz_keys)&&(_XkbAllocKeys(row,1)!=Success))
	return NULL;
    key= &row->keys[row->num_keys++];
    memset(key, 0, sizeof(XkbKeyRec));
    return key;
}

XkbRowPtr
XkbAddGeomRow(XkbSectionPtr section,int sz_keys)
{
XkbRowPtr	row;

    if ((!section)||(sz_keys<0))
	return NULL;
    if ((section->num_rows>=section->sz_rows)&&
    					(_XkbAllocRows(section,1)!=Success))
	return NULL;
    row= &section->rows[section->num_rows];
    memset(row, 0, sizeof(XkbRowRec));
    if ((sz_keys>0)&&(_XkbAllocKeys(row,sz_keys)!=Success))
	return NULL;
    section->num_rows++;
    return row;
}

XkbSectionPtr
XkbAddGeomSection(	XkbGeometryPtr	geom,
			Atom		name,
			int		sz_rows,
			int		sz_doodads,
			int		sz_over)
{
register int	i;
XkbSectionPtr	section;

    if ((!geom)||(name==None)||(sz_rows<0))
	return NULL;
    for (i=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	if (section->name!=name)
	    continue;
	if (((sz_rows>0)&&(_XkbAllocRows(section,sz_rows)!=Success))||
	    ((sz_doodads>0)&&(_XkbAllocDoodads(section,sz_doodads)!=Success))||
	    ((sz_over>0)&&(_XkbAllocOverlays(section,sz_over)!=Success)))
	    return NULL;
	return section;
    }
    if ((geom->num_sections>=geom->sz_sections)&&
					(_XkbAllocSections(geom,1)!=Success))
	return NULL;
    section= &geom->sections[geom->num_sections];
    if ((sz_rows>0)&&(_XkbAllocRows(section,sz_rows)!=Success))
	return NULL;
    if ((sz_doodads>0)&&(_XkbAllocDoodads(section,sz_doodads)!=Success)) {
	if (section->rows) {
	    free(section->rows);
	    section->rows= NULL;
	    section->sz_rows= section->num_rows= 0;
	}
	return NULL;
    }
    section->name= name;
    geom->num_sections++;
    return section;
}

XkbDoodadPtr
XkbAddGeomDoodad(XkbGeometryPtr geom,XkbSectionPtr section,Atom name)
{
XkbDoodadPtr	old,doodad;
register int	i,nDoodads;

    if ((!geom)||(name==None))
	return NULL;
    if ((section!=NULL)&&(section->num_doodads>0)) {
	old= section->doodads;
	nDoodads= section->num_doodads;
    }
    else {
	old= geom->doodads;
	nDoodads= geom->num_doodads;
    }
    for (i=0,doodad=old;i<nDoodads;i++,doodad++) {
	if (doodad->any.name==name)
	    return doodad;
    }
    if (section) {
	if ((section->num_doodads>=geom->sz_doodads)&&
	    (_XkbAllocDoodads(section,1)!=Success)) {
	    return NULL;
	}
	doodad= &section->doodads[section->num_doodads++];
    }
    else {
	if ((geom->num_doodads>=geom->sz_doodads)&&
					(_XkbAllocDoodads(geom,1)!=Success))
	    return NULL;
	doodad= &geom->doodads[geom->num_doodads++];
    }
    memset(doodad, 0, sizeof(XkbDoodadRec));
    doodad->any.name= name;
    return doodad;
}

XkbOverlayKeyPtr
XkbAddGeomOverlayKey(	XkbOverlayPtr		overlay,
			XkbOverlayRowPtr 	row,
			char *			over,
			char *			under)
{
register int	i;
XkbOverlayKeyPtr key;
XkbSectionPtr	section;
XkbRowPtr	row_under;
Bool		found;

    if ((!overlay)||(!row)||(!over)||(!under))
	return NULL;
    section= overlay->section_under;
    if (row->row_under>=section->num_rows)
	return NULL;
    row_under= &section->rows[row->row_under];
    for (i=0,found=FALSE;i<row_under->num_keys;i++) {
	if (strncmp(under,row_under->keys[i].name.name,XkbKeyNameLength)==0) {
	    found= TRUE;
	    break;
	}
    }
    if (!found)
   	return NULL; 
    if ((row->num_keys>=row->sz_keys)&&(_XkbAllocOverlayKeys(row,1)!=Success))
	return NULL;
    key= &row->keys[row->num_keys];
    strncpy(key->under.name,under,XkbKeyNameLength);
    strncpy(key->over.name,over,XkbKeyNameLength);
    row->num_keys++;
    return key;
}

XkbOverlayRowPtr
XkbAddGeomOverlayRow(XkbOverlayPtr overlay,int row_under,int sz_keys)
{
register int		i;
XkbOverlayRowPtr	row;

    if ((!overlay)||(sz_keys<0))
	return NULL;
    if (row_under>=overlay->section_under->num_rows)
	return NULL;
    for (i=0;i<overlay->num_rows;i++) {
	if (overlay->rows[i].row_under==row_under) {
	    row= &overlay->rows[i];
	    if ((row->sz_keys<sz_keys)&&
				(_XkbAllocOverlayKeys(row,sz_keys)!=Success)) {
		return NULL;
	    }
	    return &overlay->rows[i];
	}
    }
    if ((overlay->num_rows>=overlay->sz_rows)&&
				(_XkbAllocOverlayRows(overlay,1)!=Success))
	return NULL;
    row= &overlay->rows[overlay->num_rows];
    memset(row, 0, sizeof(XkbOverlayRowRec));
    if ((sz_keys>0)&&(_XkbAllocOverlayKeys(row,sz_keys)!=Success))
	return NULL;
    row->row_under= row_under;
    overlay->num_rows++;
    return row;
}

XkbOverlayPtr
XkbAddGeomOverlay(XkbSectionPtr section,Atom name,int sz_rows)
{
register int	i;
XkbOverlayPtr	overlay;

    if ((!section)||(name==None)||(sz_rows==0))
	return NULL;

    for (i=0,overlay=section->overlays;i<section->num_overlays;i++,overlay++) {
	if (overlay->name==name) {
	    if ((sz_rows>0)&&(_XkbAllocOverlayRows(overlay,sz_rows)!=Success))
		return NULL;
	    return overlay;
	}
    }
    if ((section->num_overlays>=section->sz_overlays)&&
				(_XkbAllocOverlays(section,1)!=Success))
	return NULL;
    overlay= &section->overlays[section->num_overlays];
    if ((sz_rows>0)&&(_XkbAllocOverlayRows(overlay,sz_rows)!=Success))
	return NULL;
    overlay->name= name;
    overlay->section_under= section;
    section->num_overlays++;
    return overlay;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifndef _XKBGEOM_H_
#define	_XKBGEOM_H_

#include "xkbstr.h"

#define XkbAddGeomKeyAlias 		SrvXkbAddGeomKeyAlias
#define XkbAddGeomColor 		SrvXkbAddGeomColor
#define XkbAddGeomDoodad		SrvXkbAddGeomDoodad
#define XkbAddGeomKey			SrvXkbAddGeomKey
#define XkbAddGeomOutline		SrvXkbAddGeomOutline
#define XkbAddGeomOverlay		SrvXkbAddGeomOverlay
#define XkbAddGeomOverlayRow		SrvXkbAddGeomOverlayRow
#define	XkbAddGeomOverlayKey		SrvXkbAddGeomOverlayKey
#define XkbAddGeomProperty		SrvXkbAddGeomProperty
#define XkbAddGeomRow			SrvXkbAddGeomRow
#define XkbAddGeomSection		SrvXkbAddGeomSection
#define XkbAddGeomShape			SrvXkbAddGeomShape
#define XkbAllocGeomKeyAliases		SrvXkbAllocGeomKeyAliases
#define XkbAllocGeomColors		SrvXkbAllocGeomColors
#define XkbAllocGeomDoodads		SrvXkbAllocGeomDoodads
#define XkbAllocGeomKeys		SrvXkbAllocGeomKeys
#define XkbAllocGeomOutlines		SrvXkbAllocGeomOutlines
#define XkbAllocGeomPoints		SrvXkbAllocGeomPoints
#define XkbAllocGeomProps		SrvXkbAllocGeomProps
#define XkbAllocGeomRows		SrvXkbAllocGeomRows
#define XkbAllocGeomSectionDoodads	SrvXkbAllocGeomSectionDoodads
#define XkbAllocGeomSections		SrvXkbAllocGeomSections
#define	XkbAllocGeomOverlays		SrvXkbAllocGeomOverlays
#define	XkbAllocGeomOverlayRows		SrvXkbAllocGeomOverlayRows
#define	XkbAllocGeomOverlayKeys		SrvXkbAllocGeomOverlayKeys
#define XkbAllocGeomShapes		SrvXkbAllocGeomShapes
#define XkbAllocGeometry		SrvXkbAllocGeometry
#define XkbFreeGeomKeyAliases		SrvXkbFreeGeomKeyAliases
#define XkbFreeGeomColors		SrvXkbFreeGeomColors
#define XkbFreeGeomDoodads		SrvXkbFreeGeomDoodads
#define XkbFreeGeomProperties		SrvXkbFreeGeomProperties
#define	XkbFreeGeomOverlayKeys		SrvXkbFreeGeomOverlayKeys
#define	XkbFreeGeomOverlayRows		SrvXkbFreeGeomOverlayRows
#define	XkbFreeGeomOverlays		SrvXkbFreeGeomOverlays
#define	XkbFreeGeomKeys			SrvXkbFreeGeomKeys
#define	XkbFreeGeomRows			SrvXkbFreeGeomRows
#define XkbFreeGeomSections		SrvXkbFreeGeomSections
#define	XkbFreeGeomPoints		SrvXkbFreeGeomPoints
#define	XkbFreeGeomOutlines		SrvXkbFreeGeomOutlines
#define XkbFreeGeomShapes		SrvXkbFreeGeomShapes
#define XkbFreeGeometry			SrvXkbFreeGeometry

typedef	struct _XkbProperty {
	char	*name;
	char	*value;
} XkbPropertyRec,*XkbPropertyPtr;

typedef struct _XkbColor {
	unsigned int 	pixel;
	char *		spec;
} XkbColorRec,*XkbColorPtr;

typedef	struct _XkbPoint {
	short	x;
	short	y;
} XkbPointRec, *XkbPointPtr;

typedef struct	_XkbBounds {
	short	x1,y1;
	short	x2,y2;
} XkbBoundsRec, *XkbBoundsPtr;
#define	XkbBoundsWidth(b)	(((b)->x2)-((b)->x1))
#define	XkbBoundsHeight(b)	(((b)->y2)-((b)->y1))

typedef struct _XkbOutline {
	unsigned short	num_points;
	unsigned short	sz_points;
	unsigned short	corner_radius;
	XkbPointPtr	points;
} XkbOutlineRec, *XkbOutlinePtr;

typedef struct _XkbShape {
	Atom	 	 name;
	unsigned short	 num_outlines;
	unsigned short	 sz_outlines;
	XkbOutlinePtr	 outlines;
	XkbOutlinePtr	 approx;
	XkbOutlinePtr	 primary;
	XkbBoundsRec	 bounds;
} XkbShapeRec, *XkbShapePtr;
#define	XkbOutlineIndex(s,o)	((int)((o)-&(s)->outlines[0]))

typedef struct _XkbShapeDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short		 top;
	short		 left;
	short	 	 angle;
	unsigned short	 color_ndx;
	unsigned short	 shape_ndx;
} XkbShapeDoodadRec, *XkbShapeDoodadPtr;
#define	XkbShapeDoodadColor(g,d)	(&(g)->colors[(d)->color_ndx])
#define	XkbShapeDoodadShape(g,d)	(&(g)->shapes[(d)->shape_ndx])
#define	XkbSetShapeDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
#define	XkbSetShapeDoodadShape(g,d,s)	((d)->shape_ndx= (s)-&(g)->shapes[0])

typedef struct _XkbTextDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short	 	 top;
	short	 	 left;
	short	 	 angle;
	short	 	 width;
	short		 height;
	unsigned short	 color_ndx;
	char *		 text;
	char *		 font;
} XkbTextDoodadRec, *XkbTextDoodadPtr;
#define	XkbTextDoodadColor(g,d)	(&(g)->colors[(d)->color_ndx])
#define	XkbSetTextDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])

typedef struct _XkbIndicatorDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short	 	 top;
	short	 	 left;
	short		 angle;
	unsigned short	 shape_ndx;
	unsigned short	 on_color_ndx;
	unsigned short	 off_color_ndx;
} XkbIndicatorDoodadRec, *XkbIndicatorDoodadPtr;
#define	XkbIndicatorDoodadShape(g,d)	(&(g)->shapes[(d)->shape_ndx])
#define	XkbIndicatorDoodadOnColor(g,d)	(&(g)->colors[(d)->on_color_ndx])
#define	XkbIndicatorDoodadOffColor(g,d)	(&(g)->colors[(d)->off_color_ndx])
#define	XkbSetIndicatorDoodadOnColor(g,d,c) \
				((d)->on_color_ndx= (c)-&(g)->colors[0])
#define	XkbSetIndicatorDoodadOffColor(g,d,c) \
				((d)->off_color_ndx= (c)-&(g)->colors[0])
#define	XkbSetIndicatorDoodadShape(g,d,s) \
				((d)->shape_ndx= (s)-&(g)->shapes[0])

typedef struct _XkbLogoDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short		 top;
	short		 left;
	short	 	 angle;
	unsigned short	 color_ndx;
	unsigned short	 shape_ndx;
	char *		 logo_name;
} XkbLogoDoodadRec, *XkbLogoDoodadPtr;
#define	XkbLogoDoodadColor(g,d)		(&(g)->colors[(d)->color_ndx])
#define	XkbLogoDoodadShape(g,d)		(&(g)->shapes[(d)->shape_ndx])
#define	XkbSetLogoDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
#define	XkbSetLogoDoodadShape(g,d,s)	((d)->shape_ndx= (s)-&(g)->shapes[0])

typedef struct _XkbAnyDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short	 	 top;
	short	 	 left;
	short		 angle;
} XkbAnyDoodadRec, *XkbAnyDoodadPtr;

typedef union _XkbDoodad {
	XkbAnyDoodadRec		any;
	XkbShapeDoodadRec	shape;
	XkbTextDoodadRec	text;
	XkbIndicatorDoodadRec	indicator;
	XkbLogoDoodadRec	logo;
} XkbDoodadRec, *XkbDoodadPtr;

#define	XkbUnknownDoodad	0
#define	XkbOutlineDoodad	1
#define	XkbSolidDoodad		2
#define	XkbTextDoodad		3
#define	XkbIndicatorDoodad	4
#define	XkbLogoDoodad		5

typedef struct _XkbKey {
	XkbKeyNameRec	 name;
	short		 gap;
	unsigned char	 shape_ndx;
	unsigned char	 color_ndx;
} XkbKeyRec, *XkbKeyPtr;
#define	XkbKeyShape(g,k)	(&(g)->shapes[(k)->shape_ndx])
#define	XkbKeyColor(g,k)	(&(g)->colors[(k)->color_ndx])
#define	XkbSetKeyShape(g,k,s)	((k)->shape_ndx= (s)-&(g)->shapes[0])
#define	XkbSetKeyColor(g,k,c)	((k)->color_ndx= (c)-&(g)->colors[0])

typedef struct _XkbRow {
	short	 	top;
	short	 	left;
	unsigned short	num_keys;
	unsigned short	sz_keys;
	int		vertical;
	XkbKeyPtr	keys;
	XkbBoundsRec	bounds;
} XkbRowRec, *XkbRowPtr;

typedef struct _XkbSection {
	Atom		 name;
	unsigned char	 priority;
	short	 	 top;
	short	 	 left;
	unsigned short	 width;
	unsigned short	 height;
	short	 	 angle;
	unsigned short	 num_rows;
	unsigned short	 num_doodads;
	unsigned short	 num_overlays;
	unsigned short	 sz_rows;
	unsigned short	 sz_doodads;
	unsigned short	 sz_overlays;
	XkbRowPtr	 rows;
	XkbDoodadPtr	 doodads;
	XkbBoundsRec	 bounds;
	struct _XkbOverlay *overlays;
} XkbSectionRec, *XkbSectionPtr;

typedef	struct _XkbOverlayKey {
	XkbKeyNameRec	over;
	XkbKeyNameRec	under;
} XkbOverlayKeyRec,*XkbOverlayKeyPtr;

typedef struct _XkbOverlayRow {
	unsigned short		row_under;
	unsigned short		num_keys;
	unsigned short		sz_keys;
	XkbOverlayKeyPtr	keys;
} XkbOverlayRowRec,*XkbOverlayRowPtr;

typedef struct _XkbOverlay {
	Atom			name;
	XkbSectionPtr		section_under;
	unsigned short		num_rows;
	unsigned short		sz_rows;
	XkbOverlayRowPtr	rows;
	XkbBoundsPtr		bounds;
} XkbOverlayRec,*XkbOverlayPtr;

typedef struct _XkbGeometry {
	Atom		 name;
	unsigned short	 width_mm;
	unsigned short	 height_mm;
	char *		 label_font;
	XkbColorPtr	 label_color;
	XkbColorPtr	 base_color;
	unsigned short	 sz_properties;
	unsigned short	 sz_colors;
	unsigned short	 sz_shapes;
	unsigned short   sz_sections;
	unsigned short	 sz_doodads;
	unsigned short	 sz_key_aliases;
	unsigned short	 num_properties;
	unsigned short	 num_colors;
	unsigned short	 num_shapes;
	unsigned short	 num_sections;
	unsigned short	 num_doodads;
	unsigned short	 num_key_aliases;
	XkbPropertyPtr	 properties;
	XkbColorPtr	 colors;
	XkbShapePtr	 shapes;
	XkbSectionPtr	 sections;
	XkbDoodadPtr	 doodads;
	XkbKeyAliasPtr	 key_aliases;
} XkbGeometryRec;
#define	XkbGeomColorIndex(g,c)	((int)((c)-&(g)->colors[0]))

#define	XkbGeomPropertiesMask	(1<<0)
#define	XkbGeomColorsMask	(1<<1)
#define	XkbGeomShapesMask	(1<<2)
#define	XkbGeomSectionsMask	(1<<3)
#define	XkbGeomDoodadsMask	(1<<4)
#define	XkbGeomKeyAliasesMask	(1<<5)
#define	XkbGeomAllMask		(0x3f)

typedef struct _XkbGeometrySizes {
	unsigned int	which;
	unsigned short	num_properties;
	unsigned short	num_colors;
	unsigned short	num_shapes;
	unsigned short	num_sections;
	unsigned short	num_doodads;
	unsigned short	num_key_aliases;
} XkbGeometrySizesRec,*XkbGeometrySizesPtr;

/**
 * Specifies which items should be cleared in an XKB geometry array
 * when the array is reallocated.
 */
typedef enum
{
    XKB_GEOM_CLEAR_NONE,   /* Don't clear any items, just reallocate.   */
    XKB_GEOM_CLEAR_EXCESS, /* Clear new extra items after reallocation. */
    XKB_GEOM_CLEAR_ALL     /* Clear all items after reallocation.       */
} XkbGeomClearance;

extern	XkbPropertyPtr
XkbAddGeomProperty(
    XkbGeometryPtr	/* geom */,
    char *		/* name */,
    char *		/* value */
);

extern	XkbKeyAliasPtr
XkbAddGeomKeyAlias(
    XkbGeometryPtr	/* geom */,
    char *		/* alias */,
    char *		/* real */
);

extern	XkbColorPtr
XkbAddGeomColor(
    XkbGeometryPtr	/* geom */,
    char *		/* spec */,
    unsigned int	/* pixel */
);

extern	XkbOutlinePtr
XkbAddGeomOutline(
    XkbShapePtr		/* shape */,
    int			/* sz_points */
);

extern XkbShapePtr
XkbAddGeomShape(
    XkbGeometryPtr	/* geom */,
    Atom		/* name */,
    int			/* sz_outlines */
);

extern XkbKeyPtr
XkbAddGeomKey(
    XkbRowPtr		/* row */
);

extern XkbRowPtr
XkbAddGeomRow(
    XkbSectionPtr	/* section */,
    int			/* sz_keys */
);

extern XkbSectionPtr
XkbAddGeomSection(
    XkbGeometryPtr	/* geom */,
    Atom		/* name */,
    int			/* sz_rows */,
    int			/* sz_doodads */,
    int			/* sz_overlays */
);

extern XkbOverlayPtr
XkbAddGeomOverlay(
    XkbSectionPtr	/* section */,
    Atom		/* name */,
    int			/* sz_rows */
);

extern XkbOverlayRowPtr
XkbAddGeomOverlayRow(
    XkbOverlayPtr	/* overlay */,
    int			/* row_under */,
    int			/* sz_keys */
);

extern XkbOverlayKeyPtr
XkbAddGeomOverlayKey(
    XkbOverlayPtr	/* overlay */,
    XkbOverlayRowPtr	/* row */,
    char *		/* over */,
    char *		/* under */
);

extern XkbDoodadPtr
XkbAddGeomDoodad(
    XkbGeometryPtr	/* geom */,
    XkbSectionPtr	/* section */,
    Atom		/* name */
);


extern void
XkbFreeGeomKeyAliases(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomColors(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomDoodads(
    XkbDoodadPtr	/* doodads */,
    int			/* nDoodads */,
    Bool		/* freeAll */
);


extern void
XkbFreeGeomProperties(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomOverlayKeys(
    XkbOverlayRowPtr	/* row */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomOverlayRows(
    XkbOverlayPtr	/* overlay */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomOverlays(
    XkbSectionPtr	/* section */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomKeys(
    XkbRowPtr		/* row */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomRows(
    XkbSectionPtr	/* section */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomSections(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);


extern void
XkbFreeGeomPoints(
    XkbOutlinePtr	/* outline */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomOutlines(
    XkbShapePtr		/* shape */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomShapes(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeometry(
    XkbGeometryPtr	/* geom */,
    unsigned int	/* which */,
    Bool		/* freeMap */
);

extern Bool
XkbGeomRealloc(
    void **		/* buffer */,
    int			/* szItems */,
    int			/* nrItems */,
    int			/* itemSize */,
    XkbGeomClearance	/* clearance */
);

extern Status
XkbAllocGeomProps(
    XkbGeometryPtr	/* geom */,
    int			/* nProps */
);

extern Status
XkbAllocGeomKeyAliases(
    XkbGeometryPtr	/* geom */,
    int			/* nAliases */
);

extern Status
XkbAllocGeomColors(
    XkbGeometryPtr	/* geom */,
    int			/* nColors */
);

extern Status
XkbAllocGeomShapes(
    XkbGeometryPtr	/* geom */,
    int			/* nShapes */
);

extern Status
XkbAllocGeomSections(
    XkbGeometryPtr	/* geom */,
    int			/* nSections */
);

extern Status
XkbAllocGeomOverlays(
    XkbSectionPtr	/* section */,
    int			/* num_needed */
);

extern Status
XkbAllocGeomOverlayRows(
    XkbOverlayPtr	/* overlay */,
    int			/* num_needed */
);

extern Status
XkbAllocGeomOverlayKeys(
    XkbOverlayRowPtr	/* row */,
    int			/* num_needed */
);

extern Status
XkbAllocGeomDoodads(
    XkbGeometryPtr	/* geom */,
    int			/* nDoodads */
);

extern Status
XkbAllocGeomSectionDoodads(
    XkbSectionPtr	/* section */,
    int			/* nDoodads */
);

extern Status
XkbAllocGeomOutlines(
    XkbShapePtr		/* shape */,
    int			/* nOL */
);

extern Status
XkbAllocGeomRows(
    XkbSectionPtr	/* section */,
    int			/* nRows */
);

extern Status
XkbAllocGeomPoints(
    XkbOutlinePtr	/* ol */,
    int			/* nPts */
);

extern Status
XkbAllocGeomKeys(
    XkbRowPtr		/* row */,
    int			/* nKeys */
);

extern	Status
XkbAllocGeometry(
	XkbDescPtr		/* xkb */,
	XkbGeometrySizesPtr	/* sizes */
);

extern	Bool
XkbComputeShapeTop(
	XkbShapePtr		/* shape */,
	XkbBoundsPtr		/* bounds */
);

extern	Bool
XkbComputeShapeBounds(
	XkbShapePtr		/* shape */
);

extern	Bool
XkbComputeRowBounds(
	XkbGeometryPtr		/* geom */,
	XkbSectionPtr		/* section */,
	XkbRowPtr		/* row */
);

extern	Bool
XkbComputeSectionBounds(
	XkbGeometryPtr		/* geom */,
	XkbSectionPtr		/* section */
);

extern	char *
XkbFindOverlayForKey(
	XkbGeometryPtr		/* geom */,
	XkbSectionPtr		/* wanted */,
	char *			/* under */
);

#endif /* _XKBGEOM_H_ */
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "inputstr.h"
#include "opaque.h"
#include "property.h"
#include "scrnintstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "xkbgeom.h"
#include <X11/extensions/XKMformat.h>
#include "xkbfile.h"
#include "xkb.h"

#define	CREATE_ATOM(s)	MakeAtom(s,sizeof(s)-1,1)

#if defined(__alpha) || defined(__alpha__)
#define	LED_COMPOSE	2
#define LED_CAPS	3
#define	LED_SCROLL	4
#define	LED_NUM		5
#define	PHYS_LEDS	0x1f
#else
#ifdef sun
#define LED_NUM		1
#define	LED_SCROLL	2
#define	LED_COMPOSE	3
#define LED_CAPS	4
#define	PHYS_LEDS	0x0f
#else
#define	LED_CAPS	1
#define	LED_NUM		2
#define	LED_SCROLL	3
#define	PHYS_LEDS	0x07
#endif
#endif

#define	MAX_TOC	16
typedef struct	_SrvXkmInfo {
	DeviceIntPtr	dev;
	FILE *		file;
	XkbDescPtr	xkb;
} SrvXkmInfo;


/***====================================================================***/

#ifndef XKB_DFLT_RULES_PROP
#define	XKB_DFLT_RULES_PROP	TRUE
#endif

char	*		XkbBaseDirectory=	XKB_BASE_DIRECTORY;
char	*		XkbBinDirectory=	XKB_BIN_DIRECTORY;
static int	 	XkbWantAccessX=		0;	

static char *		XkbRulesDflt=		NULL;
static char *		XkbModelDflt=		NULL;
static char *		XkbLayoutDflt=		NULL;
static char *		XkbVariantDflt=		NULL;
static char *		XkbOptionsDflt=		NULL;

static char *           XkbRulesUsed=   NULL;
static char *		XkbModelUsed=	NULL;
static char *		XkbLayoutUsed=	NULL;
static char *		XkbVariantUsed=	NULL;
static char *		XkbOptionsUsed=	NULL;

static XkbDescPtr	xkb_cached_map = NULL;

static Bool		XkbWantRulesProp=	XKB_DFLT_RULES_PROP;

/***====================================================================***/

/**
 * Get the current default XKB rules.
 * Caller must free the data in rmlvo.
 */
void
XkbGetRulesDflts(XkbRMLVOSet *rmlvo)
{
    if (XkbRulesDflt)   rmlvo->rules = XkbRulesDflt;
    else                rmlvo->rules = XKB_DFLT_RULES;
    if (XkbModelDflt)	rmlvo->model= XkbModelDflt;
    else		rmlvo->model= XKB_DFLT_MODEL;
    if (XkbLayoutDflt)	rmlvo->layout= XkbLayoutDflt;
    else		rmlvo->layout= XKB_DFLT_LAYOUT;
    if (XkbVariantDflt)	rmlvo->variant= XkbVariantDflt;
    else		rmlvo->variant= XKB_DFLT_VARIANT;
    if (XkbOptionsDflt)	rmlvo->options= XkbOptionsDflt;
    else		rmlvo->options= XKB_DFLT_OPTIONS;

    rmlvo->rules = strdup(rmlvo->rules);
    rmlvo->model = strdup(rmlvo->model);
    rmlvo->layout = strdup(rmlvo->layout);
    rmlvo->variant = strdup(rmlvo->variant);
    rmlvo->options = strdup(rmlvo->options);
}

void
XkbFreeRMLVOSet(XkbRMLVOSet *rmlvo, Bool freeRMLVO)
{
    if (!rmlvo)
        return;

    free(rmlvo->rules);
    free(rmlvo->model);
    free(rmlvo->layout);
    free(rmlvo->variant);
    free(rmlvo->options);

    if (freeRMLVO)
        free(rmlvo);
    else
        memset(rmlvo, 0, sizeof(XkbRMLVOSet));
}

static Bool
XkbWriteRulesProp(ClientPtr client, pointer closure)
{
int 			len,out;
Atom			name;
char *			pval;

    len= (XkbRulesUsed?strlen(XkbRulesUsed):0);
    len+= (XkbModelUsed?strlen(XkbModelUsed):0);
    len+= (XkbLayoutUsed?strlen(XkbLayoutUsed):0);
    len+= (XkbVariantUsed?strlen(XkbVariantUsed):0);
    len+= (XkbOptionsUsed?strlen(XkbOptionsUsed):0);
    if (len<1)
	return TRUE;

    len+= 5; /* trailing NULs */

    name= MakeAtom(_XKB_RF_NAMES_PROP_ATOM,strlen(_XKB_RF_NAMES_PROP_ATOM),1);
    if (name==None) {
	ErrorF("[xkb] Atom error: %s not created\n",_XKB_RF_NAMES_PROP_ATOM);
	return TRUE;
    }
    pval= (char*) malloc(len);
    if (!pval) {
	ErrorF("[xkb] Allocation error: %s proprerty not created\n",
						_XKB_RF_NAMES_PROP_ATOM);
	return TRUE;
    }
    out= 0;
    if (XkbRulesUsed) {
	strcpy(&pval[out],XkbRulesUsed);
	out+= strlen(XkbRulesUsed);
    }
    pval[out++]= '\0';
    if (XkbModelUsed) {
	strcpy(&pval[out],XkbModelUsed);
	out+= strlen(XkbModelUsed);
    } 
    pval[out++]= '\0';
    if (XkbLayoutUsed) {
	strcpy(&pval[out],XkbLayoutUsed);
	out+= strlen(XkbLayoutUsed);
    }
    pval[out++]= '\0';
    if (XkbVariantUsed) {
	strcpy(&pval[out],XkbVariantUsed);
	out+= strlen(XkbVariantUsed);
    }
    pval[out++]= '\0';
    if (XkbOptionsUsed) {
	strcpy(&pval[out],XkbOptionsUsed);
	out+= strlen(XkbOptionsUsed);
    }
    pval[out++]= '\0';
    if (out!=len) {
	ErrorF("[xkb] Internal Error! bad size (%d!=%d) for _XKB_RULES_NAMES\n",
								out,len);
    }
    dixChangeWindowProperty(serverClient, screenInfo.screens[0]->root, name, XA_STRING, 8,
			    PropModeReplace, len, pval, TRUE);
    free(pval);
    return TRUE;
}

static void
XkbSetRulesUsed(XkbRMLVOSet *rmlvo)
{
    free(XkbRulesUsed);
    XkbRulesUsed= (rmlvo->rules?Xstrdup(rmlvo->rules):NULL);
    free(XkbModelUsed);
    XkbModelUsed= (rmlvo->model?Xstrdup(rmlvo->model):NULL);
    free(XkbLayoutUsed);
    XkbLayoutUsed= (rmlvo->layout?Xstrdup(rmlvo->layout):NULL);
    free(XkbVariantUsed);
    XkbVariantUsed= (rmlvo->variant?Xstrdup(rmlvo->variant):NULL);
    free(XkbOptionsUsed);
    XkbOptionsUsed= (rmlvo->options?Xstrdup(rmlvo->options):NULL);
    if (XkbWantRulesProp)
	QueueWorkProc(XkbWriteRulesProp,NULL,NULL);
    return;
}

void
XkbSetRulesDflts(XkbRMLVOSet *rmlvo)
{
    if (rmlvo->rules) {
        free(XkbRulesDflt);
        XkbRulesDflt= Xstrdup(rmlvo->rules);
    }
    if (rmlvo->model) {
	free(XkbModelDflt);
	XkbModelDflt= Xstrdup(rmlvo->model);
    }
    if (rmlvo->layout) {
	free(XkbLayoutDflt);
	XkbLayoutDflt= Xstrdup(rmlvo->layout);
    }
    if (rmlvo->variant) {
	free(XkbVariantDflt);
	XkbVariantDflt= Xstrdup(rmlvo->variant);
    }
    if (rmlvo->options) {
	free(XkbOptionsDflt);
	XkbOptionsDflt= Xstrdup(rmlvo->options);
    }
    return;
}

void
XkbDeleteRulesDflts(void)
{
    free(XkbRulesDflt);
    XkbRulesDflt = NULL;
    free(XkbModelDflt);
    XkbModelDflt = NULL;
    free(XkbLayoutDflt);
    XkbLayoutDflt = NULL;
    free(XkbVariantDflt);
    XkbVariantDflt = NULL;
    free(XkbOptionsDflt);
    XkbOptionsDflt = NULL;

    XkbFreeKeyboard(xkb_cached_map, XkbAllComponentsMask, TRUE);
    xkb_cached_map = NULL;
}

#define DIFFERS(a, b) (strcmp((a) ? (a) : "", (b) ? (b) : "") != 0)

static Bool
XkbCompareUsedRMLVO(XkbRMLVOSet *rmlvo)
{
    if (DIFFERS(rmlvo->rules, XkbRulesUsed) ||
        DIFFERS(rmlvo->model, XkbModelUsed) ||
        DIFFERS(rmlvo->layout, XkbLayoutUsed) ||
        DIFFERS(rmlvo->variant, XkbVariantUsed) ||
        DIFFERS(rmlvo->options, XkbOptionsUsed))
        return FALSE;
    return TRUE;
}

#undef DIFFERS

/***====================================================================***/

#include "xkbDflts.h"

static Bool
XkbInitKeyTypes(XkbDescPtr xkb)
{
    if (xkb->defined & XkmTypesMask)
        return TRUE;

    initTypeNames(NULL);
    if (XkbAllocClientMap(xkb,XkbKeyTypesMask,num_dflt_types)!=Success)
	return FALSE;
    if (XkbCopyKeyTypes(dflt_types,xkb->map->types,num_dflt_types)!=
    								 Success) {
	return FALSE;
    }
    xkb->map->size_types= xkb->map->num_types= num_dflt_types;
    return TRUE;
}

static void
XkbInitRadioGroups(XkbSrvInfoPtr xkbi)
{
    xkbi->nRadioGroups = 0;
    xkbi->radioGroups = NULL;
    return;
}


static Status
XkbInitCompatStructs(XkbDescPtr xkb)
{
register int 	i;
XkbCompatMapPtr	compat;

    if (xkb->defined & XkmCompatMapMask)
        return TRUE;

    if (XkbAllocCompatMap(xkb,XkbAllCompatMask,num_dfltSI)!=Success)
	return BadAlloc;
    compat = xkb->compat;
    if (compat->sym_interpret) {
	compat->num_si = num_dfltSI;
	memcpy((char *)compat->sym_interpret,(char *)dfltSI,sizeof(dfltSI));
    }
    for (i=0;i<XkbNumKbdGroups;i++) {
	compat->groups[i]= compatMap.groups[i];
	if (compat->groups[i].vmods!=0) {
	    unsigned mask;
	    mask= XkbMaskForVMask(xkb,compat->groups[i].vmods);
	    compat->groups[i].mask= compat->groups[i].real_mods|mask;
	}
	else compat->groups[i].mask= compat->groups[i].real_mods;
    }
    return Success;
}

static void
XkbInitSemantics(XkbDescPtr xkb)
{
    XkbInitKeyTypes(xkb);
    XkbInitCompatStructs(xkb);
    return;
}

/***====================================================================***/

static Status
XkbInitNames(XkbSrvInfoPtr xkbi)
{
XkbDescPtr	xkb;
XkbNamesPtr	names;
Status		rtrn;
Atom		unknown;

    xkb= xkbi->desc;
    if ((rtrn=XkbAllocNames(xkb,XkbAllNamesMask,0,0))!=Success)
	return rtrn;
    unknown= CREATE_ATOM("unknown");
    names = xkb->names;
    if (names->keycodes==None)		names->keycodes= unknown;
    if (names->geometry==None)		names->geometry= unknown;
    if (names->phys_symbols==None)	names->phys_symbols= unknown;
    if (names->symbols==None)		names->symbols= unknown;
    if (names->types==None)		names->types= unknown;
    if (names->compat==None)		names->compat= unknown;
    if (!(xkb->defined & XkmVirtualModsMask)) {
        if (names->vmods[vmod_NumLock]==None)
            names->vmods[vmod_NumLock]= CREATE_ATOM("NumLock");
        if (names->vmods[vmod_Alt]==None)
            names->vmods[vmod_Alt]= CREATE_ATOM("Alt");
        if (names->vmods[vmod_AltGr]==None)
            names->vmods[vmod_AltGr]= CREATE_ATOM("ModeSwitch");
    }

    if (!(xkb->defined & XkmIndicatorsMask) ||
        !(xkb->defined & XkmGeometryMask)) {
        initIndicatorNames(NULL,xkb);
        if (names->indicators[LED_CAPS-1]==None)
            names->indicators[LED_CAPS-1] = CREATE_ATOM("Caps Lock");
        if (names->indicators[LED_NUM-1]==None)
            names->indicators[LED_NUM-1] = CREATE_ATOM("Num Lock");
        if (names->indicators[LED_SCROLL-1]==None)
            names->indicators[LED_SCROLL-1] = CREATE_ATOM("Scroll Lock");
#ifdef LED_COMPOSE
        if (names->indicators[LED_COMPOSE-1]==None)
            names->indicators[LED_COMPOSE-1] = CREATE_ATOM("Compose");
#endif
    }

    if (xkb->geom!=NULL)
	 names->geometry= xkb->geom->name;
    else names->geometry= unknown;

    return Success;
}

static Status
XkbInitIndicatorMap(XkbSrvInfoPtr xkbi)
{
XkbDescPtr		xkb;
XkbIndicatorPtr		map;
XkbSrvLedInfoPtr	sli;

    xkb= xkbi->desc;
    if (XkbAllocIndicatorMaps(xkb)!=Success)
	return BadAlloc;

    if (!(xkb->defined & XkmIndicatorsMask)) {
        map= xkb->indicators;
        map->phys_indicators = PHYS_LEDS;
        map->maps[LED_CAPS-1].flags= XkbIM_NoExplicit;
        map->maps[LED_CAPS-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_CAPS-1].mods.mask= LockMask;
        map->maps[LED_CAPS-1].mods.real_mods= LockMask;

        map->maps[LED_NUM-1].flags= XkbIM_NoExplicit;
        map->maps[LED_NUM-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_NUM-1].mods.mask= 0;
        map->maps[LED_NUM-1].mods.real_mods= 0;
        map->maps[LED_NUM-1].mods.vmods= vmod_NumLockMask;

        map->maps[LED_SCROLL-1].flags= XkbIM_NoExplicit;
        map->maps[LED_SCROLL-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_SCROLL-1].mods.mask= Mod3Mask;
        map->maps[LED_SCROLL-1].mods.real_mods= Mod3Mask;
    }

    sli= XkbFindSrvLedInfo(xkbi->device,XkbDfltXIClass,XkbDfltXIId,0);
    if (sli)
	XkbCheckIndicatorMaps(xkbi->device,sli,XkbAllIndicatorsMask);

    return Success;
}

static Status
XkbInitControls(DeviceIntPtr pXDev,XkbSrvInfoPtr xkbi)
{
XkbDescPtr	xkb;
XkbControlsPtr	ctrls;

    xkb= xkbi->desc;
    /* 12/31/94 (ef) -- XXX! Should check if controls loaded from file */
    if (XkbAllocControls(xkb,XkbAllControlsMask)!=Success)
	FatalError("Couldn't allocate keyboard controls\n");
    ctrls= xkb->ctrls;
    if (!(xkb->defined & XkmSymbolsMask))
        ctrls->num_groups = 1;
    ctrls->groups_wrap = XkbSetGroupInfo(1,XkbWrapIntoRange,0);
    ctrls->internal.mask = 0;
    ctrls->internal.real_mods = 0;
    ctrls->internal.vmods = 0;
    ctrls->ignore_lock.mask = 0;
    ctrls->ignore_lock.real_mods = 0;
    ctrls->ignore_lock.vmods = 0;
    ctrls->enabled_ctrls = XkbAccessXTimeoutMask|XkbRepeatKeysMask|
				XkbMouseKeysAccelMask|XkbAudibleBellMask|
				XkbIgnoreGroupLockMask;
    if (XkbWantAccessX)
	ctrls->enabled_ctrls|= XkbAccessXKeysMask;
    AccessXInit(pXDev);
    return Success;
}

_X_EXPORT Bool
InitKeyboardDeviceStruct(DeviceIntPtr dev, XkbRMLVOSet *rmlvo,
                         BellProcPtr bell_func, KbdCtrlProcPtr ctrl_func)
{
    int	i;
    unsigned int check;
    XkbSrvInfoPtr xkbi;
    XkbDescPtr xkb;
    XkbSrvLedInfoPtr sli;
    XkbChangesRec changes;
    XkbEventCauseRec cause;
    XkbRMLVOSet rmlvo_dflts = { NULL };

    if (dev->key || dev->kbdfeed)
	return FALSE;

    if (!rmlvo)
    {
        rmlvo = &rmlvo_dflts;
        XkbGetRulesDflts(rmlvo);
    }


    memset(&changes, 0, sizeof(changes));
    XkbSetCauseUnknown(&cause);

    dev->key = calloc(1, sizeof(*dev->key));
    if (!dev->key) {
        ErrorF("XKB: Failed to allocate key class\n");
        return FALSE;
    }
    dev->key->sourceid = dev->id;

    dev->kbdfeed = calloc(1, sizeof(*dev->kbdfeed));
    if (!dev->kbdfeed) {
        ErrorF("XKB: Failed to allocate key feedback class\n");
        goto unwind_key;
    }

    xkbi = calloc(1, sizeof(*xkbi));
    if (!xkbi) {
        ErrorF("XKB: Failed to allocate XKB info\n");
        goto unwind_kbdfeed;
    }
    dev->key->xkbInfo = xkbi;

    if (xkb_cached_map && !XkbCompareUsedRMLVO(rmlvo)) {
        XkbFreeKeyboard(xkb_cached_map, XkbAllComponentsMask, TRUE);
        xkb_cached_map = NULL;
    }

    if (xkb_cached_map)
        LogMessageVerb(X_INFO, 4, "XKB: Reusing cached keymap\n");
    else {
        xkb_cached_map = XkbCompileKeymap(dev, rmlvo);
        if (!xkb_cached_map) {
            ErrorF("XKB: Failed to compile keymap\n");
            goto unwind_info;
        }
    }

    xkb = XkbAllocKeyboard();
    if (!xkb) {
        ErrorF("XKB: Failed to allocate keyboard description\n");
        goto unwind_info;
    }

    if (!XkbCopyKeymap(xkb, xkb_cached_map)) {
        ErrorF("XKB: Failed to copy keymap\n");
        goto unwind_desc;
    }
    xkb->defined = xkb_cached_map->defined;
    xkb->flags = xkb_cached_map->flags;
    xkb->device_spec = xkb_cached_map->device_spec;
    xkbi->desc = xkb;

    if (xkb->min_key_code == 0)
        xkb->min_key_code = 8;
    if (xkb->max_key_code == 0)
        xkb->max_key_code = 255;

    i = XkbNumKeys(xkb) / 3 + 1;
    if (XkbAllocClientMap(xkb, XkbAllClientInfoMask, 0) != Success)
        goto unwind_desc;
    if (XkbAllocServerMap(xkb, XkbAllServerInfoMask, i) != Success)
        goto unwind_desc;

    xkbi->dfltPtrDelta = 1;
    xkbi->device = dev;

    XkbInitSemantics(xkb);
    XkbInitNames(xkbi);
    XkbInitRadioGroups(xkbi);

    XkbInitControls(dev, xkbi);

    XkbInitIndicatorMap(xkbi);

    XkbUpdateActions(dev, xkb->min_key_code, XkbNumKeys(xkb), &changes,
                     &check, &cause);

    InitFocusClassDeviceStruct(dev);

    xkbi->kbdProc = ctrl_func;
    dev->kbdfeed->BellProc = bell_func;
    dev->kbdfeed->CtrlProc = XkbDDXKeybdCtrlProc;

    dev->kbdfeed->ctrl = defaultKeyboardControl;
    if (dev->kbdfeed->ctrl.autoRepeat)
        xkb->ctrls->enabled_ctrls |= XkbRepeatKeysMask;

    memcpy(dev->kbdfeed->ctrl.autoRepeats, xkb->ctrls->per_key_repeat,
           XkbPerKeyBitArraySize);

    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    if (sli)
	XkbCheckIndicatorMaps(dev, sli, XkbAllIndicatorsMask);
    else
        DebugF("XKB: No indicator feedback in XkbFinishInit!\n");

    dev->kbdfeed->CtrlProc(dev,&dev->kbdfeed->ctrl);

    XkbSetRulesDflts(rmlvo);
    XkbSetRulesUsed(rmlvo);
    XkbFreeRMLVOSet(&rmlvo_dflts, FALSE);

    return TRUE;

unwind_desc:
    XkbFreeKeyboard(xkb, 0, TRUE);
unwind_info:
    free(xkbi);
    dev->key->xkbInfo = NULL;
unwind_kbdfeed:
    free(dev->kbdfeed);
    dev->kbdfeed = NULL;
unwind_key:
    free(dev->key);
    dev->key = NULL;
    return FALSE;
}


/***====================================================================***/

	/*
	 * Be very careful about what does and doesn't get freed by this 
	 * function.  To reduce fragmentation, XkbInitDevice allocates a 
	 * single huge block per device and divides it up into most of the 
	 * fixed-size structures for the device.   Don't free anything that
	 * is part of this larger block.
	 */
void
XkbFreeInfo(XkbSrvInfoPtr xkbi)
{
    free(xkbi->radioGroups);
    xkbi->radioGroups = NULL;
    if (xkbi->mouseKeyTimer) {
	TimerFree(xkbi->mouseKeyTimer);
	xkbi->mouseKeyTimer= NULL;
    }
    if (xkbi->slowKeysTimer) {
	TimerFree(xkbi->slowKeysTimer);
	xkbi->slowKeysTimer= NULL;
    }
    if (xkbi->bounceKeysTimer) {
	TimerFree(xkbi->bounceKeysTimer);
	xkbi->bounceKeysTimer= NULL;
    }
    if (xkbi->repeatKeyTimer) {
	TimerFree(xkbi->repeatKeyTimer);
	xkbi->repeatKeyTimer= NULL;
    }
    if (xkbi->krgTimer) {
	TimerFree(xkbi->krgTimer);
	xkbi->krgTimer= NULL;
    }
    xkbi->beepType= _BEEP_NONE;
    if (xkbi->beepTimer) {
	TimerFree(xkbi->beepTimer);
	xkbi->beepTimer= NULL;
    }
    if (xkbi->desc) {
	XkbFreeKeyboard(xkbi->desc,XkbAllComponentsMask,TRUE);
	xkbi->desc= NULL;
    }
    free(xkbi);
    return;
}

/***====================================================================***/

extern int	XkbDfltRepeatDelay;
extern int	XkbDfltRepeatInterval;

extern unsigned short	XkbDfltAccessXTimeout;
extern unsigned int	XkbDfltAccessXTimeoutMask;
extern unsigned int	XkbDfltAccessXFeedback;
extern unsigned char	XkbDfltAccessXOptions;

int
XkbProcessArguments(int argc,char *argv[],int i)
{
    if (strncmp(argv[i], "-xkbdir", 7) == 0) {
	if(++i < argc) {
#if !defined(WIN32) && !defined(__CYGWIN__)
	    if (getuid() != geteuid()) {
		LogMessage(X_WARNING, "-xkbdir is not available for setuid X servers\n");
		return -1;
	    } else
#endif
	    {
		if (strlen(argv[i]) < PATH_MAX) {
		    XkbBaseDirectory= argv[i];
		    return 2;
	        } else {
		    LogMessage(X_ERROR, "-xkbdir pathname too long\n");
		    return -1;
		}
	    }
	}
	else {
	    return -1;
	}
    }
    else if ((strncmp(argv[i],"-accessx",8)==0)||
                 (strncmp(argv[i],"+accessx",8)==0)) {
	int j=1;	    
	if (argv[i][0]=='-')        
	    XkbWantAccessX= 0;
	else {
	    XkbWantAccessX= 1;
	    
	    if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		XkbDfltAccessXTimeout = atoi(argv[++i]);
		j++;

		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    /*
		     * presumption that the reasonably useful range of
		     * values fits in 0..MAXINT since SunOS 4 doesn't
		     * have strtoul.
		     */
		    XkbDfltAccessXTimeoutMask=(unsigned int)
					      strtol(argv[++i],NULL,16); 
		    j++;
		}
		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    if (argv[++i][0] == '1' ) 
			XkbDfltAccessXFeedback=XkbAccessXFeedbackMask;
		    else
			XkbDfltAccessXFeedback=0;
		    j++;
		}
		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    XkbDfltAccessXOptions=(unsigned char)
					   strtol(argv[++i],NULL,16);
		    j++;
		}
	    }
	}
	return j;
    }
    if ((strcmp(argv[i], "-ardelay") == 0) ||
        (strcmp (argv[i], "-ar1") == 0)) {	/* -ardelay int */
	if (++i >= argc) UseMsg ();
	XkbDfltRepeatDelay = (long)atoi(argv[i]);
	return 2;
    }
    if ((strcmp(argv[i], "-arinterval") == 0) ||
        (strcmp (argv[i], "-ar2") == 0)) {	/* -arinterval int */
	if (++i >= argc) UseMsg ();
	XkbDfltRepeatInterval = (long)atoi(argv[i]);
	return 2;
    }
    return 0;
}

void
XkbUseMsg(void)
{
    ErrorF("[+-]accessx [ timeout [ timeout_mask [ feedback [ options_mask] ] ] ]\n");
    ErrorF("                       enable/disable accessx key sequences\n");
    ErrorF("-ardelay               set XKB autorepeat delay\n");
    ErrorF("-arinterval            set XKB autorepeat interval\n");
}
/************************************************************
Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"

#include <X11/extensions/XI.h>
#include <xkbsrv.h>
#include "xkb.h"

/***====================================================================***/

	/*
	 * unsigned
	 * XkbIndicatorsToUpdate(dev,changed,check_devs_rtrn)
	 *
	 * Given a keyboard and a set of state components that have changed,
	 * this function returns the indicators on the default keyboard 
	 * feedback that might be affected.   It also reports whether or not 
	 * any extension devices might be affected in check_devs_rtrn.
	 */

unsigned
XkbIndicatorsToUpdate(	DeviceIntPtr	dev,
			unsigned long 	state_changes,
			Bool		enable_changes)
{
register unsigned	update=	0;
XkbSrvLedInfoPtr	sli;

    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);

    if (!sli)
        return update;

    if (state_changes&(XkbModifierStateMask|XkbGroupStateMask))
	update|= sli->usesEffective;
    if (state_changes&(XkbModifierBaseMask|XkbGroupBaseMask))
	update|= sli->usesBase;
    if (state_changes&(XkbModifierLatchMask|XkbGroupLatchMask))
	update|= sli->usesLatched;
    if (state_changes&(XkbModifierLockMask|XkbGroupLockMask))
	update|= sli->usesLocked;
    if (state_changes&XkbCompatStateMask)
	update|= sli->usesCompat;
    if (enable_changes)
	update|= sli->usesControls;
    return update;
}

/***====================================================================***/

	/*
	 * Bool
	 *XkbApplyLEDChangeToKeyboard(xkbi,map,on,change)
	 *
	 * Some indicators "drive" the keyboard when their state is explicitly 
	 * changed, as described in section 9.2.1 of the XKB protocol spec.
	 * This function updates the state and controls for the keyboard 
	 * specified by 'xkbi' to reflect any changes that are required 
	 * when the indicator described by 'map' is turned on or off.  The
	 * extent of the changes is reported in change, which must be defined.
	 */
static Bool
XkbApplyLEDChangeToKeyboard(	XkbSrvInfoPtr		xkbi,
				XkbIndicatorMapPtr	map,
				Bool			on,
				XkbChangesPtr		change)
{
Bool		ctrlChange,stateChange;
XkbStatePtr	state;

    if ((map->flags&XkbIM_NoExplicit)||((map->flags&XkbIM_LEDDrivesKB)==0))
	return FALSE;
    ctrlChange= stateChange= FALSE;
    if (map->ctrls) {
	XkbControlsPtr	ctrls= xkbi->desc->ctrls;
	unsigned 	old;

	old= ctrls->enabled_ctrls;
	if (on)	ctrls->enabled_ctrls|= map->ctrls;
	else	ctrls->enabled_ctrls&= ~map->ctrls;
	if (old!=ctrls->enabled_ctrls) {
	    change->ctrls.changed_ctrls= XkbControlsEnabledMask;
	    change->ctrls.enabled_ctrls_changes= old^ctrls->enabled_ctrls;
	    ctrlChange= TRUE;
	}
    }
    state= &xkbi->state;
    if ((map->groups)&&((map->which_groups&(~XkbIM_UseBase))!=0)) {
	register int i;
	register unsigned bit,match;

	if (on)	match= (map->groups)&XkbAllGroupsMask;
	else 	match= (~map->groups)&XkbAllGroupsMask;
	if (map->which_groups&(XkbIM_UseLocked|XkbIM_UseEffective)) {
	    for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		if (bit&match)
		    break;
	    }
	    if (map->which_groups&XkbIM_UseLatched)
		XkbLatchGroup(xkbi->device,0); /* unlatch group */
	    state->locked_group= i;
	    stateChange= TRUE;
	}
	else if (map->which_groups&(XkbIM_UseLatched|XkbIM_UseEffective)) {
	    for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		if (bit&match)
		    break;
	    }
	    state->locked_group= 0;
	    XkbLatchGroup(xkbi->device,i);
	    stateChange= TRUE;
	}
    }
    if ((map->mods.mask)&&((map->which_mods&(~XkbIM_UseBase))!=0)) {
	if (map->which_mods&(XkbIM_UseLocked|XkbIM_UseEffective)) {
	    register unsigned long old;
	    old= state->locked_mods;
	    if (on)	state->locked_mods|= map->mods.mask;
	    else	state->locked_mods&= ~map->mods.mask;
	    if (state->locked_mods!=old)
		stateChange= TRUE;
	}
	if (map->which_mods&(XkbIM_UseLatched|XkbIM_UseEffective)) {
	    register unsigned long newmods;
	    newmods= state->latched_mods;
	    if (on)	newmods|=  map->mods.mask;
	    else	newmods&= ~map->mods.mask;
	    if (newmods!=state->locked_mods) {
		newmods&= map->mods.mask;
		XkbLatchModifiers(xkbi->device,map->mods.mask,newmods);
		stateChange= TRUE;
	    }
	}
    }
    return stateChange || ctrlChange;
}
	
	/*
	 * Bool
	 * ComputeAutoState(map,state,ctrls)
	 *
	 * This function reports the effect of applying the specified
	 * indicator map given the specified state and controls, as
	 * described in section 9.2 of the XKB protocol specification.
	 */

static Bool
ComputeAutoState(	XkbIndicatorMapPtr	map,
			XkbStatePtr 		state,
			XkbControlsPtr 		ctrls)
{
Bool 			on;
CARD8 			mods,group;

    on= FALSE;
    mods= group= 0;
    if (map->which_mods&XkbIM_UseAnyMods) {
	if (map->which_mods&XkbIM_UseBase)
	    mods|= state->base_mods;
	if (map->which_mods&XkbIM_UseLatched)
	    mods|= state->latched_mods;
	if (map->which_mods&XkbIM_UseLocked)
	    mods|= state->locked_mods;
	if (map->which_mods&XkbIM_UseEffective)
	    mods|= state->mods;
	if (map->which_mods&XkbIM_UseCompat)
	    mods|= state->compat_state;
	on = ((map->mods.mask&mods)!=0);
	on = on||((mods==0)&&(map->mods.mask==0)&&(map->mods.vmods==0));
    }
    if (map->which_groups&XkbIM_UseAnyGroup) {
	if (map->which_groups&XkbIM_UseBase)
	    group|= (1L << state->base_group);
	if (map->which_groups&XkbIM_UseLatched)
	    group|= (1L << state->latched_group);
	if (map->which_groups&XkbIM_UseLocked)
	    group|= (1L << state->locked_group);
	if (map->which_groups&XkbIM_UseEffective)
	    group|= (1L << state->group);
	on = on||(((map->groups&group)!=0)||(map->groups==0));
    }
    if (map->ctrls)
	on = on||(ctrls->enabled_ctrls&map->ctrls);
    return on;
}


static void
XkbUpdateLedAutoState(	DeviceIntPtr			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			maps_to_check,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbStatePtr			state;
XkbControlsPtr			ctrls;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
register unsigned		i,bit,affected;
register XkbIndicatorMapPtr	map;
unsigned			oldState;

    if ((maps_to_check==0)||(sli->maps==NULL)||(sli->mapsPresent==0))
	return;

    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= inputInfo.keyboard;

    state= &kbd->key->xkbInfo->state;
    ctrls= kbd->key->xkbInfo->desc->ctrls;
    affected= maps_to_check;
    oldState= sli->effectiveState;
    sli->autoState&= ~affected;
    for (i=0,bit=1;(i<XkbNumIndicators)&&(affected);i++,bit<<=1) {
	if ((affected&bit)==0)
	    continue;
	affected&= ~bit;
	map= &sli->maps[i];
	if((!(map->flags&XkbIM_NoAutomatic))&&ComputeAutoState(map,state,ctrls))
	    sli->autoState|= bit;
    }
    sli->effectiveState= (sli->autoState|sli->explicitState);
    affected= sli->effectiveState^oldState;
    if (affected==0)
	return;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) {
	if (changes==NULL) {
	    changes= &my_changes;
	    memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->indicators.state_changes|= affected;
    }

    ed->reason|=	XkbXI_IndicatorStateMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    return;
}

static void
XkbUpdateAllDeviceIndicators(XkbChangesPtr changes,XkbEventCausePtr cause)
{
DeviceIntPtr		edev;
XkbSrvLedInfoPtr	sli;

    for (edev=inputInfo.devices;edev!=NULL;edev=edev->next) {
	if (edev->kbdfeed) {
	    KbdFeedbackPtr	kf;
	    for (kf=edev->kbdfeed;kf!=NULL;kf=kf->next) {
		if ((kf->xkb_sli==NULL)||(kf->xkb_sli->maps==NULL))
		    continue;
		sli= kf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
	if (edev->leds) {
	    LedFeedbackPtr	lf;
	    for (lf=edev->leds;lf!=NULL;lf=lf->next) {
		if ((lf->xkb_sli==NULL)||(lf->xkb_sli->maps==NULL))
		    continue;
		sli= lf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
    }
    return;
}


/***====================================================================***/

	/*
	 * void
	 * XkbSetIndicators(dev,affect,values,cause)
	 *
	 * Attempts to change the indicators specified in 'affect' to the
	 * states specified in 'values' for the default keyboard feedback
	 * on the keyboard specified by 'dev.'   Attempts to change indicator
	 * state might be ignored or have no affect, depending on the XKB
	 * indicator map for any affected indicators, as described in section
	 * 9.2 of the XKB protocol specification.
	 *
	 * If 'changes' is non-NULL, this function notes any changes to the
	 * keyboard state, controls, or indicator state that result from this
	 * attempted change.   If 'changes' is NULL, this function generates
	 * XKB events to report any such changes to interested clients.
	 *
	 * If 'cause' is non-NULL, it specifies the reason for the change, 
	 * as reported in some XKB events.   If it is NULL, this function 
	 * assumes that the change is the result of a core protocol 
	 * ChangeKeyboardMapping request.
	 */

void
XkbSetIndicators(	DeviceIntPtr		dev,
			CARD32			affect,
			CARD32			values,
			XkbEventCausePtr	cause)
{
XkbSrvLedInfoPtr		sli;
XkbChangesRec			changes;
xkbExtensionDeviceNotify	ed;
unsigned 			side_affected;

    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    sli->explicitState&= ~affect;
    sli->explicitState|= (affect&values);
    XkbApplyLedStateChanges(dev,sli,affect,&ed,&changes,cause);

    side_affected= 0;
    if (changes.state_changes!=0)
	side_affected|= XkbIndicatorsToUpdate(dev,changes.state_changes,FALSE);
    if (changes.ctrls.enabled_ctrls_changes)
	side_affected|= sli->usesControls;

    if (side_affected) {
	XkbUpdateLedAutoState(dev,sli,side_affected,&ed,&changes,cause);
	affect|= side_affected;
    }
    if (changes.state_changes || changes.ctrls.enabled_ctrls_changes)
	XkbUpdateAllDeviceIndicators(NULL,cause);

    XkbFlushLedEvents(dev,dev,sli,&ed,&changes,cause);
    return;
}

/***====================================================================***/

/***====================================================================***/

	/*
	 * void
	 * XkbUpdateIndicators(dev,update,check_edevs,changes,cause)
	 *
	 * Applies the indicator maps for any indicators specified in
	 * 'update' from the default keyboard feedback on the device
	 * specified by 'dev.' 
	 *
	 * If 'changes' is NULL, this function generates and XKB events
	 * required to report the necessary changes, otherwise it simply
	 * notes the indicators with changed state.
	 *
	 * If 'check_edevs' is TRUE, this function also checks the indicator
	 * maps for any open extension devices that have them, and updates
	 * the state of any extension device indicators as necessary.
	 */

void
XkbUpdateIndicators(	DeviceIntPtr		dev,
			register CARD32		update,
			Bool			check_edevs,
			XkbChangesPtr		changes,
			XkbEventCausePtr	cause)
{
XkbSrvLedInfoPtr	sli;

    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateLedAutoState(dev,sli,update,NULL,changes,cause);
    if (check_edevs)
	XkbUpdateAllDeviceIndicators(changes,cause);
    return;
}

/***====================================================================***/

/***====================================================================***/

	/*
	 * void
	 * XkbCheckIndicatorMaps(dev,sli,which)
	 *
	 * Updates the 'indicator accelerators' for the indicators specified
	 * by 'which' in the feedback specified by 'sli.' The indicator 
	 * accelerators are internal to the server and are used to simplify 
	 * and speed up the process of figuring out which indicators might 
	 * be affected by a particular change in keyboard state or controls.
	 */

void
XkbCheckIndicatorMaps(DeviceIntPtr dev,XkbSrvLedInfoPtr sli,unsigned which)
{
register unsigned	i,bit;
XkbIndicatorMapPtr	map;
XkbDescPtr		xkb;

    if ((sli->flags&XkbSLI_HasOwnState)==0)
        return;

    sli->usesBase&=	 ~which;
    sli->usesLatched&=	 ~which;
    sli->usesLocked&=	 ~which;
    sli->usesEffective&= ~which;
    sli->usesCompat&=	 ~which;
    sli->usesControls&=	 ~which;
    sli->mapsPresent&=	 ~which;

    xkb= dev->key->xkbInfo->desc;
    for (i=0,bit=1,map=sli->maps;i<XkbNumIndicators;i++,bit<<=1,map++) {
	if (which&bit) {
	    CARD8		what;

	    if (!map || !XkbIM_InUse(map))
		continue;
	    sli->mapsPresent|= bit;

	    what= (map->which_mods|map->which_groups);
	    if (what&XkbIM_UseBase)
		 sli->usesBase|= bit;
	    if (what&XkbIM_UseLatched)
		 sli->usesLatched|= bit;
	    if (what&XkbIM_UseLocked)
		 sli->usesLocked|= bit;
	    if (what&XkbIM_UseEffective)
		 sli->usesEffective|= bit;
	    if (what&XkbIM_UseCompat)
		 sli->usesCompat|= bit;
	    if (map->ctrls)
		 sli->usesControls|= bit;

	    map->mods.mask= map->mods.real_mods;
	    if (map->mods.vmods!=0) {
		map->mods.mask|= XkbMaskForVMask(xkb,map->mods.vmods);
	    }
	}
    }
    sli->usedComponents= 0;
    if (sli->usesBase)
	sli->usedComponents|= XkbModifierBaseMask|XkbGroupBaseMask;
    if (sli->usesLatched)
	sli->usedComponents|= XkbModifierLatchMask|XkbGroupLatchMask;
    if (sli->usesLocked)
	sli->usedComponents|= XkbModifierLockMask|XkbGroupLockMask;
    if (sli->usesEffective)
	sli->usedComponents|= XkbModifierStateMask|XkbGroupStateMask;
    if (sli->usesCompat)
	sli->usedComponents|= XkbCompatStateMask;
    return;
}

/***====================================================================***/

	/*
	 * XkbSrvLedInfoPtr
	 * XkbAllocSrvLedInfo(dev,kf,lf,needed_parts)
	 *
	 * Allocates an XkbSrvLedInfoPtr for the feedback specified by either
	 * 'kf' or 'lf' on the keyboard specified by 'dev.'
	 *
	 * If 'needed_parts' is non-zero, this function makes sure that any
	 * of the parts speicified therein are allocated.
	 */
XkbSrvLedInfoPtr
XkbAllocSrvLedInfo(	DeviceIntPtr		dev,
			KbdFeedbackPtr		kf,
			LedFeedbackPtr		lf,
			unsigned		needed_parts)
{
XkbSrvLedInfoPtr	sli;
Bool			checkAccel;
Bool			checkNames;

    sli= NULL;
    checkAccel= checkNames= FALSE;
    if ((kf!=NULL)&&(kf->xkb_sli==NULL)) {
	kf->xkb_sli= sli= calloc(1, sizeof(XkbSrvLedInfoRec));
	if (sli==NULL)
	    return NULL; /* ALLOCATION ERROR */
	if (dev->key && dev->key->xkbInfo)
	     sli->flags= XkbSLI_HasOwnState;
	else sli->flags= 0;	
	sli->class=	KbdFeedbackClass;
	sli->id=	kf->ctrl.id;
	sli->fb.kf=	kf;

	sli->autoState=		0;
	sli->explicitState=	kf->ctrl.leds;
	sli->effectiveState=	kf->ctrl.leds;

	if ((kf==dev->kbdfeed) && (dev->key) && (dev->key->xkbInfo)) {
	    XkbDescPtr	xkb;
	    xkb= dev->key->xkbInfo->desc;
	    sli->flags|= 		XkbSLI_IsDefault;
	    sli->physIndicators=	xkb->indicators->phys_indicators;
	    sli->names=			xkb->names->indicators;
	    sli->maps=			xkb->indicators->maps;
	    checkNames= checkAccel=	TRUE;
	}
	else {
	    sli->physIndicators=	XkbAllIndicatorsMask;
	    sli->names=			NULL;
	    sli->maps=			NULL;
	}
    }
    else if ((kf!=NULL)&&((kf->xkb_sli->flags&XkbSLI_IsDefault)!=0)) {
	XkbDescPtr	xkb;
	xkb= dev->key->xkbInfo->desc;
	sli= kf->xkb_sli;
	sli->physIndicators=	xkb->indicators->phys_indicators;
	if (xkb->names->indicators!=sli->names) {
	    checkNames= TRUE;
	    sli->names= xkb->names->indicators;
	}
	if (xkb->indicators->maps!=sli->maps) {
	    checkAccel= TRUE;
	    sli->maps= xkb->indicators->maps;
	}
    }
    else if ((lf!=NULL)&&(lf->xkb_sli==NULL)) {
	lf->xkb_sli= sli= calloc(1, sizeof(XkbSrvLedInfoRec));
	if (sli==NULL)
	    return NULL; /* ALLOCATION ERROR */
	if (dev->key && dev->key->xkbInfo)
	     sli->flags= XkbSLI_HasOwnState;
	else sli->flags= 0;	
	sli->class=	LedFeedbackClass;
	sli->id=	lf->ctrl.id;
	sli->fb.lf=	lf;

	sli->physIndicators=	lf->ctrl.led_mask;
	sli->autoState=		0;
	sli->explicitState=	lf->ctrl.led_values;
	sli->effectiveState=	lf->ctrl.led_values;
	sli->maps=		NULL;
	sli->names=		NULL;
    }
    else
	return NULL;
    if ((sli->names==NULL)&&(needed_parts&XkbXI_IndicatorNamesMask))
	sli->names= calloc(XkbNumIndicators, sizeof(Atom));
    if ((sli->maps==NULL)&&(needed_parts&XkbXI_IndicatorMapsMask))
	sli->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    if (checkNames) {
	register unsigned i,bit;
	sli->namesPresent=	0;
	for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	    if (sli->names[i]!=None)
		sli->namesPresent|= bit;
	}
    }
    if (checkAccel)
	 XkbCheckIndicatorMaps(dev,sli,XkbAllIndicatorsMask);
    return sli;
}

void
XkbFreeSrvLedInfo(XkbSrvLedInfoPtr sli)
{
    if ((sli->flags&XkbSLI_IsDefault)==0) {
	free(sli->maps);
	free(sli->names);
    }
    sli->maps= NULL;
    sli->names= NULL;
    free(sli);
    return;
}

/*
 * XkbSrvLedInfoPtr
 * XkbCopySrvLedInfo(dev,src,kf,lf)
 *
 * Takes the given XkbSrvLedInfoPtr and duplicates it. A deep copy is made,
 * thus the new copy behaves like the original one and can be freed with
 * XkbFreeSrvLedInfo.
 */
XkbSrvLedInfoPtr
XkbCopySrvLedInfo(	DeviceIntPtr		from,
			XkbSrvLedInfoPtr	src,
			KbdFeedbackPtr		kf,
			LedFeedbackPtr		lf)
{
    XkbSrvLedInfoPtr sli_new = NULL;

    if (!src)
	goto finish;

    sli_new = calloc(1, sizeof( XkbSrvLedInfoRec));
    if (!sli_new)
	goto finish;

    memcpy(sli_new, src, sizeof(XkbSrvLedInfoRec));
    if (sli_new->class == KbdFeedbackClass)
	sli_new->fb.kf = kf;
    else
	sli_new->fb.lf = lf;

    if (!(sli_new->flags & XkbSLI_IsDefault)) {
	sli_new->names= calloc(XkbNumIndicators, sizeof(Atom));
	sli_new->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    } /* else sli_new->names/maps is pointing to
	dev->key->xkbInfo->desc->names->indicators;
	dev->key->xkbInfo->desc->names->indicators; */

finish:
    return sli_new;
}

/***====================================================================***/

	/*
	 * XkbSrvLedInfoPtr
	 * XkbFindSrvLedInfo(dev,class,id,needed_parts)
	 *
	 * Finds the XkbSrvLedInfoPtr for the specified 'class' and 'id'
	 * on the device specified by 'dev.'   If the class and id specify
	 * a valid device feedback, this function returns the existing 
	 * feedback or allocates a new one.
	 *
	 */

XkbSrvLedInfoPtr
XkbFindSrvLedInfo(	DeviceIntPtr		dev,
			unsigned		class,
			unsigned		id,
			unsigned		needed_parts)
{
XkbSrvLedInfoPtr	sli;

    /* optimization to check for most common case */
    if (((class==XkbDfltXIClass)&&(id==XkbDfltXIId))&&(dev->kbdfeed)) {
	XkbSrvLedInfoPtr	sli;
	sli= dev->kbdfeed->xkb_sli;
	if (dev->kbdfeed->xkb_sli==NULL) {
	    sli= XkbAllocSrvLedInfo(dev,dev->kbdfeed,NULL,needed_parts);
	    dev->kbdfeed->xkb_sli= sli;
	}
	return dev->kbdfeed->xkb_sli;
    }

    sli= NULL;
    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
	else 			return NULL;
    }
    if (class==KbdFeedbackClass) {
	KbdFeedbackPtr	kf;
	for (kf=dev->kbdfeed;kf!=NULL;kf=kf->next) {
	    if ((id==XkbDfltXIId)||(id==kf->ctrl.id)) {
		if (kf->xkb_sli==NULL)
		    kf->xkb_sli= XkbAllocSrvLedInfo(dev,kf,NULL,needed_parts);
		sli= kf->xkb_sli;
		break;
	    }	
	}
    }
    else if (class==LedFeedbackClass) {
	LedFeedbackPtr	lf;
	for (lf=dev->leds;lf!=NULL;lf=lf->next) {
	    if ((id==XkbDfltXIId)||(id==lf->ctrl.id)) {
		if (lf->xkb_sli==NULL)
		    lf->xkb_sli= XkbAllocSrvLedInfo(dev,NULL,lf,needed_parts);
		sli= lf->xkb_sli;
		break;
	    }	
	}
    }
    if (sli) {
	if ((sli->names==NULL)&&(needed_parts&XkbXI_IndicatorNamesMask))
	    sli->names= calloc(XkbNumIndicators, sizeof(Atom));
	if ((sli->maps==NULL)&&(needed_parts&XkbXI_IndicatorMapsMask))
	    sli->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    }
    return sli;
}

/***====================================================================***/

void
XkbFlushLedEvents(	DeviceIntPtr			dev,
			DeviceIntPtr			kbd,
			XkbSrvLedInfoPtr		sli,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
    if (changes) {
	if (changes->indicators.state_changes)
	    XkbDDXUpdateDeviceIndicators(dev,sli,sli->effectiveState);
	XkbSendNotification(kbd,changes,cause);
	memset((char *)changes, 0, sizeof(XkbChangesRec));

	if (XkbAX_NeedFeedback(kbd->key->xkbInfo->desc->ctrls, XkbAX_IndicatorFBMask)) {
		if (sli->effectiveState)
			/* it appears that the which parameter is not used */
			XkbDDXAccessXBeep(dev, _BEEP_LED_ON, XkbAccessXFeedbackMask);
		else
			XkbDDXAccessXBeep(dev, _BEEP_LED_OFF, XkbAccessXFeedbackMask);
	}
    }
    if (ed) {
	if (ed->reason) {
	    if ((dev!=kbd)&&(ed->reason&XkbXI_IndicatorStateMask))
		XkbDDXUpdateDeviceIndicators(dev,sli,sli->effectiveState);
	    XkbSendExtensionDeviceNotify(dev,cause->client,ed);
	}
	memset((char *)ed, 0, sizeof(XkbExtensionDeviceNotify));
    }
    return;
}

/***====================================================================***/

void
XkbApplyLedNameChanges(	DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_names,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;

    if (changed_names==0)
	return;
    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= inputInfo.keyboard;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) { 
	if (changes==NULL) {
	   changes= &my_changes;
	   memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->names.changed|= XkbIndicatorNamesMask;
	changes->names.changed_indicators|= changed_names;
    }

    ed->reason|=	XkbXI_IndicatorNamesMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    return;
}
/***====================================================================***/

	/*
	 * void
	 * XkbApplyLedMapChanges(dev,sli,changed_maps,changes,cause)
	 *
	 * Handles all of the secondary effects of the changes to the
	 * feedback specified by 'sli' on the device specified by 'dev.'
	 * 
	 * If 'changed_maps' specifies any indicators, this function generates
	 * XkbExtensionDeviceNotify events and possibly IndicatorMapNotify
	 * events to report the changes, and recalculates the effective
	 * state of each indicator with a changed map.  If any indicators
	 * change state, the server generates XkbExtensionDeviceNotify and
	 * XkbIndicatorStateNotify events as appropriate.
	 *
	 * If 'changes' is non-NULL, this function updates it to reflect
	 * any changes to the keyboard state or controls or to the 'core'
	 * indicator names, maps, or state.   If 'changes' is NULL, this
	 * function generates XKB events as needed to report the changes.
	 * If 'dev' is not a keyboard device, any changes are reported
	 * for the core keyboard.
	 *
	 * The 'cause' specifies the reason for the event (key event or
	 * request) for the change, as reported in some XKB events.
	 */

void
XkbApplyLedMapChanges(	DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_maps,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;

    if (changed_maps==0)
	return;
    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= inputInfo.keyboard;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) {
	if (changes==NULL) {
	    changes= &my_changes;
	    memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->indicators.map_changes|= changed_maps;
    }

    XkbCheckIndicatorMaps(dev,sli,changed_maps);

    ed->reason|=	XkbXI_IndicatorMapsMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;

    XkbUpdateLedAutoState(dev,sli,changed_maps,ed,changes,cause);

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    return;
}

/***====================================================================***/

void
XkbApplyLedStateChanges(DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_leds,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
XkbSrvInfoPtr			xkbi;
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
register unsigned		i,bit,affected;
XkbIndicatorMapPtr		map;
unsigned			oldState;
Bool				kb_changed;

    if (changed_leds==0)
	return;
    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= inputInfo.keyboard;
    xkbi= kbd->key->xkbInfo;

    if (changes==NULL) {
	changes= &my_changes;
	memset((char *)changes, 0, sizeof(XkbChangesRec));
    }

    kb_changed= FALSE;
    affected= changed_leds;
    oldState= sli->effectiveState;
    for (i=0,bit=1;(i<XkbNumIndicators)&&(affected);i++,bit<<=1) {
	if ((affected&bit)==0)
	    continue;
	affected&= ~bit;
	map= &sli->maps[i];
	if (map->flags&XkbIM_NoExplicit) {
	    sli->explicitState&= ~bit;
	    continue;
	}
	if (map->flags&XkbIM_LEDDrivesKB) {
	    Bool on= ((sli->explicitState&bit)!=0);
	    if (XkbApplyLEDChangeToKeyboard(xkbi,map,on,changes))
		kb_changed= TRUE;
	}
    }
    sli->effectiveState= (sli->autoState|sli->explicitState);
    affected= sli->effectiveState^oldState;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if (affected&&(ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault))
	changes->indicators.state_changes|= affected;
    if (affected) {
	ed->reason|=		XkbXI_IndicatorStateMask;
	ed->ledClass= 		sli->class;
	ed->ledID=		sli->id;
	ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
	ed->ledState=		sli->effectiveState;
	ed->unsupported=	0;
	ed->supported=		XkbXI_AllFeaturesMask;
    }

    if (kb_changed) {
	XkbComputeDerivedState(kbd->key->xkbInfo);
	XkbUpdateLedAutoState(dev,sli,sli->mapsPresent,ed,changes,cause);
    }

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    if (kb_changed)
	XkbUpdateAllDeviceIndicators(NULL,cause);
    return;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#elif defined(HAVE_CONFIG_H)
#include <config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <X11/keysym.h>
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>

/***====================================================================***/

Status
XkbAllocClientMap(XkbDescPtr xkb,unsigned which,unsigned nTotalTypes)
{
register int	i;
XkbClientMapPtr map;

    if ((xkb==NULL)||((nTotalTypes>0)&&(nTotalTypes<XkbNumRequiredTypes)))
	return BadValue;
    if ((which&XkbKeySymsMask)&&
	((!XkbIsLegalKeycode(xkb->min_key_code))||
	 (!XkbIsLegalKeycode(xkb->max_key_code))||
	 (xkb->max_key_code<xkb->min_key_code))) {
        DebugF("bad keycode (%d,%d) in XkbAllocClientMap\n",
				xkb->min_key_code,xkb->max_key_code);
	return BadValue;
    }

    if (xkb->map==NULL) {
	map= calloc(1, sizeof(XkbClientMapRec));
	if (map==NULL)
	    return BadAlloc;
	xkb->map= map;
    }
    else map= xkb->map;

    if ((which&XkbKeyTypesMask)&&(nTotalTypes>0)) {
	if (map->types==NULL) {
	    map->types= calloc(nTotalTypes, sizeof(XkbKeyTypeRec));
	    if (map->types==NULL)
		return BadAlloc;
	    map->num_types= 0;
	    map->size_types= nTotalTypes;
	}
	else if (map->size_types<nTotalTypes) {
	    XkbKeyTypeRec *prev_types = map->types;

	    map->types= realloc(map->types,nTotalTypes * sizeof(XkbKeyTypeRec));
	    if (map->types==NULL) {
		free(prev_types);
		map->num_types= map->size_types= 0;
		return BadAlloc;
	    }
	    map->size_types= nTotalTypes;
	    memset(&map->types[map->num_types], 0,
		  ((map->size_types-map->num_types)*sizeof(XkbKeyTypeRec)));
	}
    }
    if (which&XkbKeySymsMask) {
	int nKeys= XkbNumKeys(xkb);
	if (map->syms==NULL) {
	    map->size_syms= (nKeys*15)/10;
	    map->syms= calloc(map->size_syms, sizeof(KeySym));
	    if (!map->syms) {
		map->size_syms= 0;
		return BadAlloc;
	    }
	    map->num_syms= 1;
	    map->syms[0]= NoSymbol;
	}
	if (map->key_sym_map==NULL) {
	    i= xkb->max_key_code+1;
	    map->key_sym_map= calloc(i, sizeof(XkbSymMapRec));
	    if (map->key_sym_map==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbModifierMapMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->modmap==NULL) {
	    i= xkb->max_key_code+1;
	    map->modmap= calloc(i, sizeof(unsigned char));
	    if (map->modmap==NULL)
		return BadAlloc;
	}
    }
    return Success;
}

Status
XkbAllocServerMap(XkbDescPtr xkb,unsigned which,unsigned nNewActions)
{
register int	i;
XkbServerMapPtr map;

    if (xkb==NULL)
	return BadMatch;
    if (xkb->server==NULL) {
	map= calloc(1, sizeof(XkbServerMapRec));
	if (map==NULL)
	    return BadAlloc;
	for (i=0;i<XkbNumVirtualMods;i++) {
	    map->vmods[i]= XkbNoModifierMask;
	}
	xkb->server= map;
    }
    else map= xkb->server;
    if (which&XkbExplicitComponentsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->explicit==NULL) {
	    i= xkb->max_key_code+1;
	    map->explicit= calloc(i, sizeof(unsigned char));
	    if (map->explicit==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbKeyActionsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
        if (nNewActions<1)
	    nNewActions= 1;
	if (map->acts==NULL) {
	    map->acts= calloc((nNewActions+1), sizeof(XkbAction));
	    if (map->acts==NULL)
		return BadAlloc;
	    map->num_acts= 1;
	    map->size_acts= nNewActions+1;
	}
	else if ((map->size_acts-map->num_acts)<nNewActions) {
	    unsigned need;
	    XkbAction *prev_acts = map->acts;
	    need= map->num_acts+nNewActions;
	    map->acts= realloc(map->acts,need * sizeof(XkbAction));
	    if (map->acts==NULL) {
		free(prev_acts);
	        map->num_acts= map->size_acts= 0;
	        return BadAlloc;
	    }
	    map->size_acts= need;
	    memset(&map->acts[map->num_acts], 0,
		    ((map->size_acts-map->num_acts)*sizeof(XkbAction)));
	}
	if (map->key_acts==NULL) {
	    i= xkb->max_key_code+1;
	    map->key_acts= calloc(i, sizeof(unsigned short));
	    if (map->key_acts==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbKeyBehaviorsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->behaviors==NULL) {
	    i= xkb->max_key_code+1;
	    map->behaviors= calloc(i, sizeof(XkbBehavior));
	    if (map->behaviors==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbVirtualModMapMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->vmodmap==NULL) {
	    i= xkb->max_key_code+1;
	    map->vmodmap= calloc(i, sizeof(unsigned short));
	    if (map->vmodmap==NULL)
		return BadAlloc;
	}
    }
    return Success;
}

/***====================================================================***/

static Status
XkbCopyKeyType(XkbKeyTypePtr from,XkbKeyTypePtr into)
{
    if ((!from)||(!into))
	return BadMatch;
    free(into->map);
    into->map = NULL;
    free(into->preserve);
    into->preserve = NULL;
    free(into->level_names);
    into->level_names = NULL;
    *into= *from;
    if ((from->map)&&(into->map_count>0)) {
	into->map= calloc(into->map_count, sizeof(XkbKTMapEntryRec));
	if (!into->map)
	    return BadAlloc;
	memcpy(into->map,from->map,into->map_count*sizeof(XkbKTMapEntryRec));
    }
    if ((from->preserve)&&(into->map_count>0)) {
	into->preserve= calloc(into->map_count, sizeof(XkbModsRec));
	if (!into->preserve)
	    return BadAlloc;
	memcpy(into->preserve,from->preserve,
				into->map_count*sizeof(XkbModsRec));
    }
    if ((from->level_names)&&(into->num_levels>0)) {
	into->level_names= calloc(into->num_levels, sizeof(Atom));
	if (!into->level_names)
	    return BadAlloc;
	memcpy(into->level_names,from->level_names,
				 into->num_levels*sizeof(Atom));
    }
    return Success;
}

Status
XkbCopyKeyTypes(XkbKeyTypePtr from,XkbKeyTypePtr into,int num_types)
{
register int i,rtrn;

    if ((!from)||(!into)||(num_types<0))
	return BadMatch;
    for (i=0;i<num_types;i++) {
	if ((rtrn= XkbCopyKeyType(from++,into++))!=Success)
	    return rtrn;
    }
    return Success;
}

Status
XkbResizeKeyType(	XkbDescPtr	xkb,
			int		type_ndx,
			int		map_count,
			Bool		want_preserve,
			int		new_num_lvls)
{
XkbKeyTypePtr	type;
KeyCode		matchingKeys[XkbMaxKeyCount],nMatchingKeys;

    if ((type_ndx<0)||(type_ndx>=xkb->map->num_types)||(map_count<0)||
    							(new_num_lvls<1))
	return BadValue;
    switch (type_ndx) {
	case XkbOneLevelIndex:
	    if (new_num_lvls!=1)
		return BadMatch;
	    break;
	case XkbTwoLevelIndex:
	case XkbAlphabeticIndex:
	case XkbKeypadIndex:
	    if (new_num_lvls!=2)
		return BadMatch;
	    break;
    }
    type= &xkb->map->types[type_ndx];
    if (map_count==0) {
	free(type->map);
	type->map= NULL;
	free(type->preserve);
	type->preserve= NULL;
	type->map_count= 0;
    }
    else {
	XkbKTMapEntryRec *prev_map = type->map;

	if ((map_count>type->map_count)||(type->map==NULL))
	    type->map = realloc(type->map,map_count * sizeof(XkbKTMapEntryRec));
	if (!type->map) {
	    free(prev_map);
	    return BadAlloc;
	}
	if (want_preserve) {
	    XkbModsRec *prev_preserve = type->preserve;

	    if ((map_count>type->map_count)||(type->preserve==NULL)) {
		type->preserve = realloc(type->preserve,
					  map_count * sizeof(XkbModsRec));
	    }
	    if (!type->preserve) {
		free(prev_preserve);
		return BadAlloc;
	    }
	}
	else {
	    free(type->preserve);
	    type->preserve = NULL;
	}
	type->map_count= map_count;
    }

    if ((new_num_lvls>type->num_levels)||(type->level_names==NULL)) {
	Atom * prev_level_names = type->level_names;

	type->level_names = realloc(type->level_names,
				     new_num_lvls * sizeof(Atom));
	if (!type->level_names) {
	    free(prev_level_names);
	    return BadAlloc;
	}
    }
    /*
     * Here's the theory:
     *    If the width of the type changed, we might have to resize the symbol
     * maps for any keys that use the type for one or more groups.  This is
     * expensive, so we'll try to cull out any keys that are obviously okay:
     * In any case:
     *    - keys that have a group width <= the old width are okay (because
     *      they could not possibly have been associated with the old type)
     * If the key type increased in size:
     *    - keys that already have a group width >= to the new width are okay
     *    + keys that have a group width >= the old width but < the new width
     *      might have to be enlarged.
     * If the key type decreased in size:
     *    - keys that have a group width > the old width don't have to be
     *      resized (because they must have some other wider type associated 
     *      with some group).
     *    + keys that have a group width == the old width might have to be
     *      shrunk.
     * The possibilities marked with '+' require us to examine the key types
     * associated with each group for the key.
     */
    memset(matchingKeys, 0, XkbMaxKeyCount*sizeof(KeyCode));
    nMatchingKeys= 0;
    if (new_num_lvls>type->num_levels) {
	int	 		nTotal;
	KeySym	*		newSyms;
	int			width,match,nResize;
	register int		i,g,nSyms;

	nResize= 0;
	for (nTotal=1,i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    width= XkbKeyGroupsWidth(xkb,i);
	    if (width<type->num_levels)
		continue;
	    for (match=0,g=XkbKeyNumGroups(xkb,i)-1;(g>=0)&&(!match);g--) {
		if (XkbKeyKeyTypeIndex(xkb,i,g)==type_ndx) {
		    matchingKeys[nMatchingKeys++]= i;
		    match= 1;
		}
	    }
	    if ((!match)||(width>=new_num_lvls))
		nTotal+= XkbKeyNumSyms(xkb,i);
	    else {
		nTotal+= XkbKeyNumGroups(xkb,i)*new_num_lvls;
		nResize++;
	    }
	}
	if (nResize>0) {
	    int nextMatch;
	    xkb->map->size_syms= (nTotal*15)/10;
	    newSyms = calloc(xkb->map->size_syms, sizeof(KeySym));
	    if (newSyms==NULL)
		return BadAlloc;
	    nextMatch= 0;
	    nSyms= 1;
	    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
		if (matchingKeys[nextMatch]==i) {
		    KeySym *pOld;
		    nextMatch++;
		    width= XkbKeyGroupsWidth(xkb,i);
		    pOld= XkbKeySymsPtr(xkb,i);
		    for (g=XkbKeyNumGroups(xkb,i)-1;g>=0;g--) {
			memcpy(&newSyms[nSyms+(new_num_lvls*g)],&pOld[width*g],
							width*sizeof(KeySym));
		    }
		    xkb->map->key_sym_map[i].offset= nSyms;
		    nSyms+= XkbKeyNumGroups(xkb,i)*new_num_lvls;
		}
		else {
		    memcpy(&newSyms[nSyms],XkbKeySymsPtr(xkb,i),
					XkbKeyNumSyms(xkb,i)*sizeof(KeySym));
		    xkb->map->key_sym_map[i].offset= nSyms;
		    nSyms+= XkbKeyNumSyms(xkb,i);
		}
	    }
	    type->num_levels= new_num_lvls;
	    free(xkb->map->syms);
	    xkb->map->syms= newSyms;
	    xkb->map->num_syms= nSyms;
	    return Success;
	}
    }
    else if (new_num_lvls<type->num_levels) {
	int 		width,match;
	register int	g,i;
	for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    width= XkbKeyGroupsWidth(xkb,i);
	    if (width<type->num_levels)
		continue;
	    for (match=0,g=XkbKeyNumGroups(xkb,i)-1;(g>=0)&&(!match);g--) {
		if (XkbKeyKeyTypeIndex(xkb,i,g)==type_ndx) {
		    matchingKeys[nMatchingKeys++]= i;
		    match= 1;
		}
	    }
	}
    }
    if (nMatchingKeys>0) {
	int 		key,firstClear;
	register int	i,g;
	if (new_num_lvls>type->num_levels)
	     firstClear= type->num_levels;
	else firstClear= new_num_lvls;
	for (i=0;i<nMatchingKeys;i++) {
	    KeySym *	pSyms;
	    int		width,nClear;

	    key= matchingKeys[i];
	    width= XkbKeyGroupsWidth(xkb,key);
	    nClear= width-firstClear;
	    pSyms= XkbKeySymsPtr(xkb,key);
	    for (g=XkbKeyNumGroups(xkb,key)-1;g>=0;g--) {
		if (XkbKeyKeyTypeIndex(xkb,key,g)==type_ndx) {
		    if (nClear>0)
			memset(&pSyms[g*width+firstClear], 0, nClear*sizeof(KeySym));
		}
	    }
	}
    }
    type->num_levels= new_num_lvls;
    return Success;
}

KeySym *
XkbResizeKeySyms(XkbDescPtr xkb,int key,int needed)
{
register int i,nSyms,nKeySyms;
unsigned nOldSyms;
KeySym	*newSyms;

    if (needed==0) {
	xkb->map->key_sym_map[key].offset= 0;
	return xkb->map->syms;
    }
    nOldSyms= XkbKeyNumSyms(xkb,key);
    if (nOldSyms>=(unsigned)needed) {
	return XkbKeySymsPtr(xkb,key);
    }
    if (xkb->map->size_syms-xkb->map->num_syms>=(unsigned)needed) {
	if (nOldSyms>0) {
	    memcpy(&xkb->map->syms[xkb->map->num_syms],XkbKeySymsPtr(xkb,key),
						nOldSyms*sizeof(KeySym));
	}
	if ((needed-nOldSyms)>0) {
	    memset(&xkb->map->syms[xkb->map->num_syms+XkbKeyNumSyms(xkb, key)],
                   0, (needed-nOldSyms)*sizeof(KeySym));
	}
	xkb->map->key_sym_map[key].offset = xkb->map->num_syms;
	xkb->map->num_syms+= needed;
	return &xkb->map->syms[xkb->map->key_sym_map[key].offset];
    }
    xkb->map->size_syms+= (needed>32?needed:32);
    newSyms = calloc(xkb->map->size_syms, sizeof(KeySym));
    if (newSyms==NULL)
	return NULL;
    newSyms[0]= NoSymbol;
    nSyms = 1;
    for (i=xkb->min_key_code;i<=(int)xkb->max_key_code;i++) {
	int nCopy;

	nCopy= nKeySyms= XkbKeyNumSyms(xkb,i);
	if ((nKeySyms==0)&&(i!=key))
	    continue;
	if (i==key)
	    nKeySyms= needed;
	if (nCopy!=0)
	   memcpy(&newSyms[nSyms],XkbKeySymsPtr(xkb,i),nCopy*sizeof(KeySym));
	if (nKeySyms>nCopy)
	    memset(&newSyms[nSyms+nCopy], 0, (nKeySyms-nCopy)*sizeof(KeySym));
	xkb->map->key_sym_map[i].offset = nSyms;
	nSyms+= nKeySyms;
    }
    free(xkb->map->syms);
    xkb->map->syms = newSyms;
    xkb->map->num_syms = nSyms;
    return &xkb->map->syms[xkb->map->key_sym_map[key].offset];
}

static unsigned
_ExtendRange(	unsigned int 	old_flags,
		unsigned int	flag,
		KeyCode		newKC,
		KeyCode *	old_min,
		unsigned char *	old_num)
{
    if ((old_flags&flag)==0) {
	old_flags|= flag;
	*old_min= newKC;
	*old_num= 1;
    }
    else {
	int	last= (*old_min)+(*old_num)-1;
	if (newKC<*old_min) {
	    *old_min= newKC;
	    *old_num= (last-newKC)+1;
	}
	else if (newKC>last) {
	    *old_num= (newKC-(*old_min))+1;
	}
    }
    return old_flags;
}

Status
XkbChangeKeycodeRange(	XkbDescPtr	xkb,
			int 		minKC,
			int 		maxKC,
			XkbChangesPtr	changes)
{
int	tmp;

    if ((!xkb)||(minKC<XkbMinLegalKeyCode)||(maxKC>XkbMaxLegalKeyCode))
	return BadValue;
    if (minKC>maxKC)
	return BadMatch;
    if (minKC<xkb->min_key_code) {
	if (changes)
	    changes->map.min_key_code= minKC;
	tmp= xkb->min_key_code-minKC;
	if (xkb->map)  {
	    if (xkb->map->key_sym_map) {
		memset((char *)&xkb->map->key_sym_map[minKC], 0,
					tmp*sizeof(XkbSymMapRec));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbKeySymsMask,minKC,
	    					&changes->map.first_key_sym,
	    					&changes->map.num_key_syms);
		}
	    }
	    if (xkb->map->modmap) {
		memset((char *)&xkb->map->modmap[minKC], 0, tmp);
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbModifierMapMask,minKC,
	    					&changes->map.first_modmap_key,
	    					&changes->map.num_modmap_keys);
		}
	    }
	}
	if (xkb->server) {
	    if (xkb->server->behaviors) {
		memset((char *)&xkb->server->behaviors[minKC], 0,
						tmp*sizeof(XkbBehavior));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyBehaviorsMask,minKC,
    					&changes->map.first_key_behavior,
    					&changes->map.num_key_behaviors);
		}
	    }
	    if (xkb->server->key_acts) {
		memset((char *)&xkb->server->key_acts[minKC], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyActionsMask,minKC,
    					&changes->map.first_key_act,
    					&changes->map.num_key_acts);
		}
	    }
	    if (xkb->server->vmodmap) {
		memset((char *)&xkb->server->vmodmap[minKC], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbVirtualModMapMask,minKC,
		    			&changes->map.first_modmap_key,
    					&changes->map.num_vmodmap_keys);
		}
	    }
	}
	if ((xkb->names)&&(xkb->names->keys)) {
	    memset((char *)&xkb->names->keys[minKC], 0, tmp*sizeof(XkbKeyNameRec));
	    if (changes) {
		changes->names.changed= _ExtendRange(changes->names.changed,
					XkbKeyNamesMask,minKC,
					&changes->names.first_key,
    					&changes->names.num_keys);
	    }
	}
	xkb->min_key_code= minKC;
    }
    if (maxKC>xkb->max_key_code) {
	if (changes)
	    changes->map.max_key_code= maxKC;
	tmp= maxKC-xkb->max_key_code;
	if (xkb->map)  {
	    if (xkb->map->key_sym_map) {
		XkbSymMapRec *prev_key_sym_map = xkb->map->key_sym_map;

		xkb->map->key_sym_map = realloc(xkb->map->key_sym_map,
						(maxKC+1) * sizeof(XkbSymMapRec));
		if (!xkb->map->key_sym_map) {
		    free(prev_key_sym_map);
		    return BadAlloc;
		}
		memset((char *)&xkb->map->key_sym_map[xkb->max_key_code], 0,
					tmp*sizeof(XkbSymMapRec));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbKeySymsMask,maxKC,
	    					&changes->map.first_key_sym,
	    					&changes->map.num_key_syms);
		}
	    }
	    if (xkb->map->modmap) {
		unsigned char *prev_modmap = xkb->map->modmap;

		xkb->map->modmap = realloc(xkb->map->modmap,
					    (maxKC+1) * sizeof(unsigned char));
		if (!xkb->map->modmap) {
		    free(prev_modmap);
		    return BadAlloc;
		}
		memset((char *)&xkb->map->modmap[xkb->max_key_code], 0, tmp);
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbModifierMapMask,maxKC,
	    					&changes->map.first_modmap_key,
	    					&changes->map.num_modmap_keys);
		}
	    }
	}
	if (xkb->server) {
	    if (xkb->server->behaviors) {
		XkbBehavior *prev_behaviors = xkb->server->behaviors;

		xkb->server->behaviors = realloc(xkb->server->behaviors,
						(maxKC+1) * sizeof(XkbBehavior));
		if (!xkb->server->behaviors) {
		    free(prev_behaviors);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->behaviors[xkb->max_key_code], 0,
						tmp*sizeof(XkbBehavior));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyBehaviorsMask,maxKC,
    					&changes->map.first_key_behavior,
    					&changes->map.num_key_behaviors);
		}
	    }
	    if (xkb->server->key_acts) {
		unsigned short *prev_key_acts = xkb->server->key_acts;

		xkb->server->key_acts= realloc(xkb->server->key_acts,
						(maxKC+1) * sizeof(unsigned short));
		if (!xkb->server->key_acts) {
		    free(prev_key_acts);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->key_acts[xkb->max_key_code], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyActionsMask,maxKC,
    					&changes->map.first_key_act,
    					&changes->map.num_key_acts);
		}
	    }
	    if (xkb->server->vmodmap) {
		unsigned short *prev_vmodmap = xkb->server->vmodmap;

		xkb->server->vmodmap= realloc(xkb->server->vmodmap,
						(maxKC+1) * sizeof(unsigned short));
		if (!xkb->server->vmodmap) {
		    free(prev_vmodmap);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->vmodmap[xkb->max_key_code], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbVirtualModMapMask,maxKC,
		    			&changes->map.first_modmap_key,
    					&changes->map.num_vmodmap_keys);
		}
	    }
	}
	if ((xkb->names)&&(xkb->names->keys)) {
	    XkbKeyNameRec *prev_keys = xkb->names->keys;

	    xkb->names->keys = realloc(xkb->names->keys,
					(maxKC+1) * sizeof(XkbKeyNameRec));
	    if (!xkb->names->keys) {
		free(prev_keys);
		return BadAlloc;
	    }
	    memset((char *)&xkb->names->keys[xkb->max_key_code], 0,
	    					tmp*sizeof(XkbKeyNameRec));
	    if (changes) {
		changes->names.changed= _ExtendRange(changes->names.changed,
					XkbKeyNamesMask,maxKC,
					&changes->names.first_key,
    					&changes->names.num_keys);
	    }
	}
	xkb->max_key_code= maxKC;
    }
    return Success;
}

XkbAction *
XkbResizeKeyActions(XkbDescPtr xkb,int key,int needed)
{
register int i,nActs;
XkbAction *newActs;

    if (needed==0) {
	xkb->server->key_acts[key]= 0;
	return NULL;
    }
    if (XkbKeyHasActions(xkb,key)&&(XkbKeyNumSyms(xkb,key)>=(unsigned)needed))
	return XkbKeyActionsPtr(xkb,key);
    if (xkb->server->size_acts-xkb->server->num_acts>=(unsigned)needed) {
	xkb->server->key_acts[key]= xkb->server->num_acts;
	xkb->server->num_acts+= needed;
	return &xkb->server->acts[xkb->server->key_acts[key]];
    }
    xkb->server->size_acts= xkb->server->num_acts+needed+8;
    newActs = calloc(xkb->server->size_acts, sizeof(XkbAction));
    if (newActs==NULL)
	return NULL;
    newActs[0].type = XkbSA_NoAction;
    nActs = 1;
    for (i=xkb->min_key_code;i<=(int)xkb->max_key_code;i++) {
	int nKeyActs,nCopy;

	if ((xkb->server->key_acts[i]==0)&&(i!=key))
	    continue;

	nCopy= nKeyActs= XkbKeyNumActions(xkb,i);
	if (i==key) {
	    nKeyActs= needed;
	    if (needed<nCopy)
		nCopy= needed;
	}

	if (nCopy>0)
	    memcpy(&newActs[nActs],XkbKeyActionsPtr(xkb,i),
						nCopy*sizeof(XkbAction));
	if (nCopy<nKeyActs)
	    memset(&newActs[nActs+nCopy], 0, (nKeyActs-nCopy)*sizeof(XkbAction));
	xkb->server->key_acts[i]= nActs;
	nActs+= nKeyActs;
    }
    free(xkb->server->acts);
    xkb->server->acts = newActs;
    xkb->server->num_acts= nActs;
    return &xkb->server->acts[xkb->server->key_acts[key]];
}

void
XkbFreeClientMap(XkbDescPtr xkb,unsigned what,Bool freeMap)
{
XkbClientMapPtr	map;

    if ((xkb==NULL)||(xkb->map==NULL))
	return;
    if (freeMap)
	what= XkbAllClientInfoMask;
    map= xkb->map;
    if (what&XkbKeyTypesMask) {
	if (map->types!=NULL) {
	    if (map->num_types>0) {
		register int 	i;
		XkbKeyTypePtr	type;
		for (i=0,type=map->types;i<map->num_types;i++,type++) {
		    free(type->map);
		    type->map = NULL;
		    free(type->preserve);
		    type->preserve = NULL;
		    type->map_count= 0;
		    free(type->level_names);
		    type->level_names = NULL;
		}
	    }
	    free(map->types);
	    map->num_types= map->size_types= 0;
	    map->types= NULL;
	}
    }
    if (what&XkbKeySymsMask) {
	free(map->key_sym_map);
	map->key_sym_map = NULL;
	if (map->syms!=NULL) {
	    free(map->syms);
	    map->size_syms= map->num_syms= 0;
	    map->syms= NULL;
	}
    }
    if ((what&XkbModifierMapMask)&&(map->modmap!=NULL)) {
	free(map->modmap);
	map->modmap= NULL;
    }
    if (freeMap) {
	free(xkb->map);
	xkb->map= NULL;
    }
    return;
}

void
XkbFreeServerMap(XkbDescPtr xkb,unsigned what,Bool freeMap)
{
XkbServerMapPtr	map;

    if ((xkb==NULL)||(xkb->server==NULL))
	return;
    if (freeMap)
	what= XkbAllServerInfoMask;
    map= xkb->server;
    if ((what&XkbExplicitComponentsMask)&&(map->explicit!=NULL)) {
	free(map->explicit);
	map->explicit= NULL;
    }
    if (what&XkbKeyActionsMask) {
	free(map->key_acts);
	map->key_acts = NULL;
	if (map->acts!=NULL) {
	    free(map->acts);
	    map->num_acts= map->size_acts= 0;
	    map->acts= NULL;
	}
    }
    if ((what&XkbKeyBehaviorsMask)&&(map->behaviors!=NULL)) {
	free(map->behaviors);
	map->behaviors= NULL;
    }
    if ((what&XkbVirtualModMapMask)&&(map->vmodmap!=NULL)) {
	free(map->vmodmap);
	map->vmodmap= NULL;
    }

    if (freeMap) {
	free(xkb->server);
	xkb->server= NULL;
    }
    return;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#elif defined(HAVE_CONFIG_H)
#include <config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <X11/keysym.h>
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>

/***====================================================================***/

#define	CORE_SYM(i)	(i<map_width?core_syms[i]:NoSymbol)
#define	XKB_OFFSET(g,l)	(((g)*groupsWidth)+(l))

int
XkbKeyTypesForCoreSymbols(	XkbDescPtr	xkb,
				int		map_width,
				KeySym *	core_syms,
				unsigned int 	protected,
    				int *		types_inout,
				KeySym *	xkb_syms_rtrn)
{
register int	i;
unsigned int	empty;
int		nSyms[XkbNumKbdGroups];
int		nGroups,tmp,groupsWidth;
BOOL		replicated = FALSE;

    /* Section 12.2 of the protocol describes this process in more detail */
    /* Step 1:  find the # of symbols in the core mapping per group */
    groupsWidth= 2;
    for (i=0;i<XkbNumKbdGroups;i++) {
	if ((protected&(1<<i))&&(types_inout[i]<xkb->map->num_types)) {
	    nSyms[i]= xkb->map->types[types_inout[i]].num_levels;
	    if (nSyms[i]>groupsWidth)
		groupsWidth= nSyms[i];
	}
	else {
	    types_inout[i]= XkbTwoLevelIndex;	/* don't really know, yet */
	    nSyms[i]= 2;
	}
    }
    if (nSyms[XkbGroup1Index]<2)
	nSyms[XkbGroup1Index]= 2;
    if (nSyms[XkbGroup2Index]<2)
	nSyms[XkbGroup2Index]= 2;
    /* Step 2:	Copy the symbols from the core ordering to XKB ordering	*/
    /*		symbols in the core are in the order:			*/
    /*		G1L1 G1L2 G2L1 G2L2 [G1L[3-n]] [G2L[3-n]] [G3L*] [G3L*]	*/
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,0)]= CORE_SYM(0);
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,1)]= CORE_SYM(1);
    for (i=2;i<nSyms[XkbGroup1Index];i++) {
	xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,i)]= CORE_SYM(2+i);
    }
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,0)]= CORE_SYM(2);
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,1)]= CORE_SYM(3);
    tmp= 2+(nSyms[XkbGroup1Index]-2); /* offset to extra group2 syms */
    for (i=2;i<nSyms[XkbGroup2Index];i++) {
	xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,i)]= CORE_SYM(tmp+i);
    }

    /* Special case: if only the first group is explicit, and the symbols
     * replicate across all groups, then we have a Section 12.4 replication */
    if ((protected & ~XkbExplicitKeyType1Mask) == 0)
    {
        int j, width = nSyms[XkbGroup1Index];

        replicated = TRUE;

        /* Check ABAB in ABABCDECDEABCDE */
        if ((width > 0 && CORE_SYM(0) != CORE_SYM(2)) ||
            (width > 1 && CORE_SYM(1) != CORE_SYM(3)))
            replicated = FALSE;

        /* Check CDECDE in ABABCDECDEABCDE */
        for (i = 2; i < width && replicated; i++)
        {
            if (CORE_SYM(2 + i) != CORE_SYM(i + width))
                replicated = FALSE;
        }

        /* Check ABCDE in ABABCDECDEABCDE */
        for (j = 2; replicated &&
                    j < XkbNumKbdGroups &&
                    map_width >= width * (j + 1); j++)
        {
            for (i = 0; i < width && replicated; i++)
            {
                if (CORE_SYM(((i < 2) ? i : 2 + i)) != CORE_SYM(i + width * j))
                    replicated = FALSE;
            }
        }
    }

    if (replicated)
    {
	nSyms[XkbGroup2Index]= 0;
	nSyms[XkbGroup3Index]= 0;
	nSyms[XkbGroup4Index]= 0;
	nGroups= 1;
    } else
    {
        tmp= nSyms[XkbGroup1Index]+nSyms[XkbGroup2Index];
        if ((tmp>=map_width)&&
                ((protected&(XkbExplicitKeyType3Mask|XkbExplicitKeyType4Mask))==0)) {
            nSyms[XkbGroup3Index]= 0;
            nSyms[XkbGroup4Index]= 0;
            nGroups= 2;
        } else
        {
            nGroups= 3;
            for (i=0;i<nSyms[XkbGroup3Index];i++,tmp++) {
                xkb_syms_rtrn[XKB_OFFSET(XkbGroup3Index,i)]= CORE_SYM(tmp);
            }
            if ((tmp<map_width)||(protected&XkbExplicitKeyType4Mask)) {
                nGroups= 4;
                for (i=0;i<nSyms[XkbGroup4Index];i++,tmp++) {
                    xkb_syms_rtrn[XKB_OFFSET(XkbGroup4Index,i)]= CORE_SYM(tmp);
                }
            }
            else {
                nSyms[XkbGroup4Index]= 0;
            }
        }
    }
    /* steps 3&4: alphanumeric expansion,  assign canonical types */
    empty= 0;
    for (i=0;i<nGroups;i++) {
	KeySym *syms;
	syms= &xkb_syms_rtrn[XKB_OFFSET(i,0)];
	if ((nSyms[i]>1)&&(syms[1]==NoSymbol)&&(syms[0]!=NoSymbol)) {
	    KeySym upper,lower;
	    XkbConvertCase(syms[0],&lower,&upper);
	    if (upper!=lower) {
		xkb_syms_rtrn[XKB_OFFSET(i,0)]= lower;
		xkb_syms_rtrn[XKB_OFFSET(i,1)]= upper;
		if ((protected&(1<<i))==0)
		    types_inout[i]= XkbAlphabeticIndex;
	    }
	    else if ((protected&(1<<i))==0) {
		types_inout[i]= XkbOneLevelIndex;
	/*	nSyms[i]=	1;*/
	    }
	}
	if (((protected&(1<<i))==0)&&(types_inout[i]==XkbTwoLevelIndex)) {
	    if (XkbKSIsKeypad(syms[0])||XkbKSIsKeypad(syms[1]))
		types_inout[i]= XkbKeypadIndex;
	    else {
		KeySym upper,lower;
		XkbConvertCase(syms[0],&lower,&upper);
		if ((syms[0]==lower)&&(syms[1]==upper))
		    types_inout[i]= XkbAlphabeticIndex;
	    }
	}
	if (syms[0]==NoSymbol) {
	    register int n;
	    Bool	found;
	    for (n=1,found=FALSE;(!found)&&(n<nSyms[i]);n++) {
		found= (syms[n]!=NoSymbol);
	    }
	    if (!found)
		empty|= (1<<i);
	}
    }
    /* step 5: squoosh out empty groups */
    if (empty) {
	for (i=nGroups-1;i>=0;i--) {
	    if (((empty&(1<<i))==0)||(protected&(1<<i)))
		break;
	    nGroups--;
	}
    }
    if (nGroups<1)
	return 0;

    /* step 6: replicate group 1 into group two, if necessary */
    if ((nGroups>1)&&((empty&(XkbGroup1Mask|XkbGroup2Mask))==XkbGroup2Mask)) {
	if ((protected&(XkbExplicitKeyType1Mask|XkbExplicitKeyType2Mask))==0) {
	    nSyms[XkbGroup2Index]= nSyms[XkbGroup1Index];
	    types_inout[XkbGroup2Index]= types_inout[XkbGroup1Index];
	    memcpy((char *)&xkb_syms_rtrn[2],(char *)xkb_syms_rtrn,
							2*sizeof(KeySym));
	}
	else if (types_inout[XkbGroup1Index]==types_inout[XkbGroup2Index]) {
	    memcpy((char *)&xkb_syms_rtrn[nSyms[XkbGroup1Index]],
	    				(char *)xkb_syms_rtrn,
					nSyms[XkbGroup1Index]*sizeof(KeySym));
	}
    }

    /* step 7: check for all groups identical or all width 1
     *
     * Special feature: if group 1 has an explicit type and all other groups
     * have canonical types with same symbols, we assume it's info lost from
     * the core replication.
     */
    if (nGroups>1) {
	Bool sameType,allOneLevel, canonical = TRUE;
	allOneLevel= (xkb->map->types[types_inout[0]].num_levels==1);
	for (i=1,sameType=TRUE;(allOneLevel||sameType)&&(i<nGroups);i++) {
	    sameType=(sameType&&(types_inout[i]==types_inout[XkbGroup1Index]));
	    if (allOneLevel)
		allOneLevel= (xkb->map->types[types_inout[i]].num_levels==1);
	    if (types_inout[i] > XkbLastRequiredType)
		canonical = FALSE;
	}
	if (((sameType) || canonical)&&
	    (!(protected&(XkbExplicitKeyTypesMask&~XkbExplicitKeyType1Mask)))){
	    register int s;
	    Bool	identical;
	    for (i=1,identical=TRUE;identical&&(i<nGroups);i++) {
		KeySym *syms;
                if (nSyms[i] != nSyms[XkbGroup1Index])
                    identical = FALSE;
		syms= &xkb_syms_rtrn[XKB_OFFSET(i,0)];
		for (s=0;identical&&(s<nSyms[i]);s++) {
		    if (syms[s]!=xkb_syms_rtrn[s])
			identical= FALSE;
		}
	    }
	    if (identical)
		nGroups= 1;
	}
	if (allOneLevel && (nGroups>1)) {
	    KeySym *syms;
	    syms= &xkb_syms_rtrn[nSyms[XkbGroup1Index]];
	    nSyms[XkbGroup1Index]= 1;
	    for (i=1;i<nGroups;i++) {
		xkb_syms_rtrn[i]= syms[0];
		syms+= nSyms[i];
		nSyms[i]= 1;
	    }
	}
    }
    return nGroups;
}

static XkbSymInterpretPtr
_XkbFindMatchingInterp(	XkbDescPtr	xkb,
			KeySym 		sym,
			unsigned int	real_mods,
			unsigned int	level)
{
register unsigned	 i;
XkbSymInterpretPtr	 interp,rtrn;
CARD8			 mods;

    rtrn= NULL;
    interp= xkb->compat->sym_interpret;
    for (i=0;i<xkb->compat->num_si;i++,interp++) {
	if ((interp->sym==NoSymbol)||(sym==interp->sym)) {
	    int match;
	    if ((level==0)||((interp->match&XkbSI_LevelOneOnly)==0))
		 mods= real_mods;
	    else mods= 0;
	    switch (interp->match&XkbSI_OpMask) {
		case XkbSI_NoneOf:
		    match= ((interp->mods&mods)==0);
		    break;
		case XkbSI_AnyOfOrNone:
		    match= ((mods==0)||((interp->mods&mods)!=0));
		    break;
		case XkbSI_AnyOf:
		    match= ((interp->mods&mods)!=0);
		    break;
		case XkbSI_AllOf:
		    match= ((interp->mods&mods)==interp->mods);
		    break;
		case XkbSI_Exactly:
		    match= (interp->mods==mods);
		    break;
		default:
		    match= 0;
		    break;
	    }
	    if (match) {
		if (interp->sym!=NoSymbol) {
		    return interp;
		}
		else if (rtrn==NULL) {
		    rtrn= interp;
		}
	    }
	}
    }
    return rtrn;
}

static void
_XkbAddKeyChange(KeyCode *pFirst,unsigned char *pNum,KeyCode newKey)
{
KeyCode	last;

    last= (*pFirst)+(*pNum);
    if (newKey<*pFirst) {
	*pFirst= newKey;
	*pNum= (last-newKey)+1;
    }
    else if (newKey>last) {
	*pNum= (last-*pFirst)+1;
    }
    return;
}

static void
_XkbSetActionKeyMods(XkbDescPtr xkb,XkbAction *act,unsigned mods)
{
unsigned	tmp;

    switch (act->type) {
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (act->mods.flags&XkbSA_UseModMapMods)
		act->mods.real_mods= act->mods.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->mods))!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->mods.mask|= tmp;
	    }
	    break;
	case XkbSA_ISOLock:
	    if (act->iso.flags&XkbSA_UseModMapMods)
		act->iso.real_mods= act->iso.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->iso))!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->iso.mask|= tmp;
	    }
	    break;
    }
    return;
}

#define	IBUF_SIZE	8

Bool
XkbApplyCompatMapToKey(XkbDescPtr xkb,KeyCode key,XkbChangesPtr changes)
{
KeySym *		syms;
unsigned char 		explicit,mods;
XkbSymInterpretPtr	*interps,ibuf[IBUF_SIZE]; 
int			n,nSyms,found;
unsigned		changed,tmp;

    if ((!xkb)||(!xkb->map)||(!xkb->map->key_sym_map)||
    			(!xkb->compat)||(!xkb->compat->sym_interpret)||
			(key<xkb->min_key_code)||(key>xkb->max_key_code)) {
	return FALSE;
    }
    if (((!xkb->server)||(!xkb->server->key_acts))&&
		(XkbAllocServerMap(xkb,XkbAllServerInfoMask,0)!=Success)) {
	return FALSE;
    }
    changed= 0;	/* keeps track of what has changed in _this_ call */
    explicit= xkb->server->explicit[key];
    if (explicit&XkbExplicitInterpretMask) /* nothing to do */
	return TRUE;
    mods= (xkb->map->modmap?xkb->map->modmap[key]:0);
    nSyms= XkbKeyNumSyms(xkb,key);
    syms= XkbKeySymsPtr(xkb,key);
    if (nSyms>IBUF_SIZE) {
	interps= calloc(nSyms, sizeof(XkbSymInterpretPtr));
	if (interps==NULL) {
	    interps= ibuf;
	    nSyms= IBUF_SIZE;
	}
    }
    else {
	interps= ibuf;
    }
    found= 0;
    for (n=0;n<nSyms;n++) {
	unsigned level= (n%XkbKeyGroupsWidth(xkb,key));
	interps[n]= NULL;
	if (syms[n]!=NoSymbol) {
	    interps[n]= _XkbFindMatchingInterp(xkb,syms[n],mods,level);
	    if (interps[n]&&interps[n]->act.type!=XkbSA_NoAction)
		found++;
	    else interps[n]= NULL;
	}
    }
    /* 1/28/96 (ef) -- XXX! WORKING HERE */
    if (!found) {
	if (xkb->server->key_acts[key]!=0) {
	    xkb->server->key_acts[key]= 0;
	    changed|= XkbKeyActionsMask;
	}
    }
    else {
	XkbAction *pActs;
	unsigned int	new_vmodmask;
	changed|= XkbKeyActionsMask;
	pActs= XkbResizeKeyActions(xkb,key,nSyms);
	if (!pActs) {
            if (nSyms > IBUF_SIZE)
                free(interps);
	    return FALSE;
        }
	new_vmodmask= 0;
	for (n=0;n<nSyms;n++) {
	    if (interps[n]) {
		unsigned effMods;

		pActs[n]= *((XkbAction *)&interps[n]->act);
		if ((n==0)||((interps[n]->match&XkbSI_LevelOneOnly)==0)) {
		     effMods= mods;
		     if (interps[n]->virtual_mod!=XkbNoModifier)
			new_vmodmask|= (1<<interps[n]->virtual_mod);
		}
		else effMods= 0;
		_XkbSetActionKeyMods(xkb,&pActs[n],effMods);
	    }
	    else pActs[n].type= XkbSA_NoAction;
	}
	if (((explicit&XkbExplicitVModMapMask)==0)&&
				(xkb->server->vmodmap[key]!=new_vmodmask)) {
	    changed|= XkbVirtualModMapMask;
	    xkb->server->vmodmap[key]= new_vmodmask;
	}
	if (interps[0]) {
	    if ((interps[0]->flags&XkbSI_LockingKey)&&
				((explicit&XkbExplicitBehaviorMask)==0)) {
		xkb->server->behaviors[key].type= XkbKB_Lock;
		changed|= XkbKeyBehaviorsMask;
	    }
	    if (((explicit&XkbExplicitAutoRepeatMask)==0)&&(xkb->ctrls)) {
		CARD8 old;
		old= BitIsOn(xkb->ctrls->per_key_repeat, key);
		if (interps[0]->flags&XkbSI_AutoRepeat)
		    SetBit(xkb->ctrls->per_key_repeat, key);
		else
		    ClearBit(xkb->ctrls->per_key_repeat, key);
		if (changes && old != BitIsOn(xkb->ctrls->per_key_repeat, key))
		    changes->ctrls.changed_ctrls|= XkbPerKeyRepeatMask;
	    }
	}
    }
    if ((!found)||(interps[0]==NULL)) {
	if (((explicit&XkbExplicitAutoRepeatMask)==0)&&(xkb->ctrls)) {
	    CARD8 old;
	    old = BitIsOn(xkb->ctrls->per_key_repeat, key);
	    SetBit(xkb->ctrls->per_key_repeat, key);
	    if (changes && (old != BitIsOn(xkb->ctrls->per_key_repeat, key)))
		changes->ctrls.changed_ctrls|= XkbPerKeyRepeatMask;
	}
	if (((explicit&XkbExplicitBehaviorMask)==0)&&
		(xkb->server->behaviors[key].type==XkbKB_Lock)) {
		xkb->server->behaviors[key].type= XkbKB_Default;
		changed|= XkbKeyBehaviorsMask;
	}
    }
    if (changes) {
	XkbMapChangesPtr	mc;
	mc= &changes->map;
	tmp= (changed&mc->changed);
	if (tmp&XkbKeyActionsMask)
	    _XkbAddKeyChange(&mc->first_key_act,&mc->num_key_acts,key);
	else if (changed&XkbKeyActionsMask) {
	    mc->changed|= XkbKeyActionsMask;
	    mc->first_key_act= key;
	    mc->num_key_acts= 1;
	}
	if (tmp&XkbKeyBehaviorsMask) {
	    _XkbAddKeyChange(&mc->first_key_behavior,&mc->num_key_behaviors,
	    								key);
	}
	else if (changed&XkbKeyBehaviorsMask) {
	    mc->changed|= XkbKeyBehaviorsMask;
	    mc->first_key_behavior= key;
	    mc->num_key_behaviors= 1;
	}
	if (tmp&XkbVirtualModMapMask)
	    _XkbAddKeyChange(&mc->first_vmodmap_key,&mc->num_vmodmap_keys,key);
	else if (changed&XkbVirtualModMapMask) {
	    mc->changed|= XkbVirtualModMapMask;
	    mc->first_vmodmap_key= key;
	    mc->num_vmodmap_keys= 1;
	}
	mc->changed|= changed;
    }
    if (interps!=ibuf)
	free(interps);
    return TRUE;
}

Status
XkbChangeTypesOfKey(	XkbDescPtr		 xkb,
			int		 	 key,
			int			 nGroups,
			unsigned	 	 groups,
			int	* 	 	 newTypesIn,
			XkbMapChangesPtr	 changes)
{
XkbKeyTypePtr	pOldType,pNewType;
register int	i;
int		width,nOldGroups,oldWidth,newTypes[XkbNumKbdGroups];

    if ((!xkb) || (!XkbKeycodeInRange(xkb,key)) || (!xkb->map) ||
	(!xkb->map->types)||(!newTypesIn)||((groups&XkbAllGroupsMask)==0)||
	(nGroups>XkbNumKbdGroups)) {
	return BadMatch;
    }
    if (nGroups==0) {
	for (i=0;i<XkbNumKbdGroups;i++) {
	    xkb->map->key_sym_map[key].kt_index[i]= XkbOneLevelIndex;
	}
	i= xkb->map->key_sym_map[key].group_info;
	i= XkbSetNumGroups(i,0);
	xkb->map->key_sym_map[key].group_info= i;
	XkbResizeKeySyms(xkb,key,0);
	return Success;
    }

    nOldGroups= XkbKeyNumGroups(xkb,key);
    oldWidth= XkbKeyGroupsWidth(xkb,key);
    for (width=i=0;i<nGroups;i++) {
	if (groups&(1<<i))
	     newTypes[i]=  newTypesIn[i];
	else if (i<nOldGroups)
	     newTypes[i]= XkbKeyKeyTypeIndex(xkb,key,i);
	else if (nOldGroups>0)
	     newTypes[i]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup1Index);
	else newTypes[i]= XkbTwoLevelIndex;
	if (newTypes[i]>xkb->map->num_types)
	    return BadMatch;
	pNewType= &xkb->map->types[newTypes[i]];
	if (pNewType->num_levels>width)
	    width= pNewType->num_levels;
    }
    if ((xkb->ctrls)&&(nGroups>xkb->ctrls->num_groups))
	xkb->ctrls->num_groups= nGroups;
    if ((width!=oldWidth)||(nGroups!=nOldGroups)) {
	KeySym		oldSyms[XkbMaxSymsPerKey],*pSyms;
	int		nCopy;

	if (nOldGroups==0) {
	    pSyms= XkbResizeKeySyms(xkb,key,width*nGroups);
	    if (pSyms!=NULL) {
		i= xkb->map->key_sym_map[key].group_info;
		i= XkbSetNumGroups(i,nGroups);
		xkb->map->key_sym_map[key].group_info= i;
		xkb->map->key_sym_map[key].width= width;
		for (i=0;i<nGroups;i++) {
		    xkb->map->key_sym_map[key].kt_index[i]= newTypes[i];
		}
		return Success;
	    }
	    return BadAlloc;
	}
	pSyms= XkbKeySymsPtr(xkb,key);
	memcpy(oldSyms,pSyms,XkbKeyNumSyms(xkb,key)*sizeof(KeySym));
	pSyms= XkbResizeKeySyms(xkb,key,width*nGroups);
	if (pSyms==NULL)
	    return BadAlloc;
	memset(pSyms, 0, width*nGroups*sizeof(KeySym));
	for (i=0;(i<nGroups)&&(i<nOldGroups);i++) {
	    pOldType= XkbKeyKeyType(xkb,key,i);
	    pNewType= &xkb->map->types[newTypes[i]];
	    if (pNewType->num_levels>pOldType->num_levels)
		 nCopy= pOldType->num_levels;
	    else nCopy= pNewType->num_levels;
	    memcpy(&pSyms[i*width],&oldSyms[i*oldWidth],nCopy*sizeof(KeySym));
	}
	if (XkbKeyHasActions(xkb,key)) {
	    XkbAction	oldActs[XkbMaxSymsPerKey],*pActs;
	    pActs= XkbKeyActionsPtr(xkb,key);
	    memcpy(oldActs,pActs,XkbKeyNumSyms(xkb,key)*sizeof(XkbAction));
	    pActs= XkbResizeKeyActions(xkb,key,width*nGroups);
	    if (pActs==NULL)
		return BadAlloc;
	    memset(pActs, 0, width*nGroups*sizeof(XkbAction));
	    for (i=0;(i<nGroups)&&(i<nOldGroups);i++) {
		pOldType= XkbKeyKeyType(xkb,key,i);
		pNewType= &xkb->map->types[newTypes[i]];
		if (pNewType->num_levels>pOldType->num_levels)
		     nCopy= pOldType->num_levels;
		else nCopy= pNewType->num_levels;
		memcpy(&pActs[i*width],&oldActs[i*oldWidth],
						nCopy*sizeof(XkbAction));
	    }
	}
	i= xkb->map->key_sym_map[key].group_info;
	i= XkbSetNumGroups(i,nGroups);
	xkb->map->key_sym_map[key].group_info= i;
	xkb->map->key_sym_map[key].width= width;
    }
    width= 0;
    for (i=0;i<nGroups;i++) {
	xkb->map->key_sym_map[key].kt_index[i]= newTypes[i];
	if (xkb->map->types[newTypes[i]].num_levels>width)
	    width= xkb->map->types[newTypes[i]].num_levels;
    }
    xkb->map->key_sym_map[key].width= width;
    if (changes!=NULL) {
	if (changes->changed&XkbKeySymsMask) {
	    _XkbAddKeyChange(&changes->first_key_sym,&changes->num_key_syms,
	    								key);
	}
	else {
	    changes->changed|= XkbKeySymsMask;
	    changes->first_key_sym= key;
	    changes->num_key_syms= 1;
	}
    }
    return Success;
}

/***====================================================================***/

Bool
XkbVirtualModsToReal(XkbDescPtr xkb,unsigned virtual_mask,unsigned *mask_rtrn)
{
register int i,bit;
register unsigned mask;

    if (xkb==NULL)
	return FALSE;
    if (virtual_mask==0) {
	*mask_rtrn= 0;
	return TRUE;
    }
    if (xkb->server==NULL)
	return FALSE;
    for (i=mask=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (virtual_mask&bit)
	    mask|= xkb->server->vmods[i];
    }
    *mask_rtrn= mask;
    return TRUE;
}

/***====================================================================***/

static Bool
XkbUpdateActionVirtualMods(XkbDescPtr xkb,XkbAction *act,unsigned changed)
{
unsigned int	tmp;

    switch (act->type) {
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (((tmp= XkbModActionVMods(&act->mods))&changed)!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->mods.mask= act->mods.real_mods;
		act->mods.mask|= tmp;
		return TRUE;
	    }
	    break;
	case XkbSA_ISOLock:
	    if ((((tmp= XkbModActionVMods(&act->iso))!=0)&changed)!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->iso.mask= act->iso.real_mods;
		act->iso.mask|= tmp;
		return TRUE;
	    }
	    break;
    }
    return FALSE;
}

static void
XkbUpdateKeyTypeVirtualMods(	XkbDescPtr	xkb,
				XkbKeyTypePtr	type,
				unsigned int	changed,
				XkbChangesPtr 	changes)
{
register unsigned int	i;
unsigned int		mask;

    XkbVirtualModsToReal(xkb,type->mods.vmods,&mask);
    type->mods.mask= type->mods.real_mods|mask;
    if ((type->map_count>0)&&(type->mods.vmods!=0)) {
	XkbKTMapEntryPtr entry;
	for (i=0,entry=type->map;i<type->map_count;i++,entry++) {
	    if (entry->mods.vmods!=0) {
		XkbVirtualModsToReal(xkb,entry->mods.vmods,&mask);
		entry->mods.mask=entry->mods.real_mods|mask;
		/* entry is active if vmods are bound*/
	    	entry->active= (mask!=0);
	    }
	    else entry->active= 1;
	}
    }
    if (changes) {
	int	type_ndx;
	type_ndx= type-xkb->map->types;
	if ((type_ndx<0)||(type_ndx>xkb->map->num_types))
	    return;
	if (changes->map.changed&XkbKeyTypesMask) {
	    int last;
	    last= changes->map.first_type+changes->map.num_types-1;
	    if (type_ndx<changes->map.first_type) {
		changes->map.first_type= type_ndx;
		changes->map.num_types= (last-type_ndx)+1;
	    }
	    else if (type_ndx>last) {
		changes->map.num_types= (type_ndx-changes->map.first_type)+1;
	    }
	}
	else {
	    changes->map.changed|= XkbKeyTypesMask;
	    changes->map.first_type= type_ndx;
	    changes->map.num_types= 1;
	}
    }
    return;
}

Bool
XkbApplyVirtualModChanges(XkbDescPtr xkb,unsigned changed,XkbChangesPtr changes)
{
register int	i;
unsigned int	checkState = 0;

    if ((!xkb) || (!xkb->map) || (changed==0))
	return FALSE;
    for (i=0;i<xkb->map->num_types;i++) {
	if (xkb->map->types[i].mods.vmods & changed)
	XkbUpdateKeyTypeVirtualMods(xkb,&xkb->map->types[i],changed,changes);
    }
    if (changed&xkb->ctrls->internal.vmods) {
	unsigned int	newMask;
	XkbVirtualModsToReal(xkb,xkb->ctrls->internal.vmods,&newMask);
	newMask|= xkb->ctrls->internal.real_mods;
	if (xkb->ctrls->internal.mask!=newMask) {
	    xkb->ctrls->internal.mask= newMask;
	    if (changes) {
		changes->ctrls.changed_ctrls|= XkbInternalModsMask;
		checkState= TRUE;
	    }
	}
    }
    if (changed&xkb->ctrls->ignore_lock.vmods) {
	unsigned int	newMask;
	XkbVirtualModsToReal(xkb,xkb->ctrls->ignore_lock.vmods,&newMask);
	newMask|= xkb->ctrls->ignore_lock.real_mods;
	if (xkb->ctrls->ignore_lock.mask!=newMask) {
	    xkb->ctrls->ignore_lock.mask= newMask;
	    if (changes) {
		changes->ctrls.changed_ctrls|= XkbIgnoreLockModsMask;
		checkState= TRUE;
	    }
	}
    }
    if (xkb->indicators!=NULL) {
	XkbIndicatorMapPtr map;
	map= &xkb->indicators->maps[0];
	for (i=0;i<XkbNumIndicators;i++,map++) {
	    if (map->mods.vmods&changed) {
		unsigned int newMask;
		XkbVirtualModsToReal(xkb,map->mods.vmods,&newMask);
		newMask|= map->mods.real_mods;
		if (newMask!=map->mods.mask) {
		    map->mods.mask= newMask;
		    if (changes) {
			changes->indicators.map_changes|= (1<<i);
			checkState= TRUE;
		    }
		}
	    }
	}
    }
    if (xkb->compat!=NULL) {
	XkbCompatMapPtr	compat;
	compat= xkb->compat;
	for (i=0;i<XkbNumKbdGroups;i++) {
	    unsigned int newMask;
	    XkbVirtualModsToReal(xkb,compat->groups[i].vmods,&newMask);
	    newMask|= compat->groups[i].real_mods;
	    if (compat->groups[i].mask!=newMask) {
		compat->groups[i].mask= newMask;
		if (changes) {
		    changes->compat.changed_groups|= (1<<i);
		    checkState= TRUE;
		}
	    }
	}
    }
    if (xkb->map && xkb->server) {
	int highChange = 0, lowChange = -1;
	for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    if (XkbKeyHasActions(xkb,i)) {
		register XkbAction *pAct;
		register int n;

		pAct= XkbKeyActionsPtr(xkb,i);
		for (n=XkbKeyNumActions(xkb,i);n>0;n--,pAct++) {
		    if ((pAct->type!=XkbSA_NoAction)&&
			XkbUpdateActionVirtualMods(xkb,pAct,changed)) {
			if (lowChange<0)
			    lowChange= i;
			highChange= i;
		    }
		}
	    }
	}
	if (changes && (lowChange>0)) { /* something changed */
	    if (changes->map.changed&XkbKeyActionsMask) {
		int last;
		if (changes->map.first_key_act<lowChange)
		    lowChange= changes->map.first_key_act;
		last= changes->map.first_key_act+changes->map.num_key_acts-1;
		if (last>highChange)
		    highChange= last;
	    }
	    changes->map.changed|= 	XkbKeyActionsMask;
	    changes->map.first_key_act=	lowChange;
	    changes->map.num_key_acts=	(highChange-lowChange)+1;
	}
    }
    return checkState;
}
/************************************************************
 Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <X11/Xfuncs.h>

#include <X11/X.h>
#include <X11/keysym.h>
#include <X11/Xproto.h>
#include <X11/extensions/XKMformat.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS	1
#include <xkbsrv.h>

#include "xkbgeom.h"
#include "xkbfile.h"

#define	VMOD_HIDE_VALUE	0
#define	VMOD_SHOW_VALUE	1
#define	VMOD_COMMENT_VALUE 2

static Bool
WriteXKBVModDecl(FILE *file,XkbDescPtr xkb,int showValue)
{
register int 	i,nMods;
Atom *		vmodNames;

    if (xkb==NULL)
	return FALSE;
    if (xkb->names!=NULL)
	 vmodNames= xkb->names->vmods;
    else vmodNames= NULL;

    for (i=nMods=0;i<XkbNumVirtualMods;i++) {
	if ((vmodNames!=NULL)&&(vmodNames[i]!=None)) {
	    if (nMods==0)	fprintf(file,"    virtual_modifiers ");
	    else		fprintf(file,",");
	    fprintf(file,"%s",XkbAtomText(vmodNames[i],XkbXKBFile));
	    if ((showValue!=VMOD_HIDE_VALUE)&&
		(xkb->server)&&(xkb->server->vmods[i]!=XkbNoModifierMask)) {
		if (showValue==VMOD_COMMENT_VALUE) {
		    fprintf(file,"/* = %s */",
			XkbModMaskText(xkb->server->vmods[i],XkbXKBFile));
		}
		else  {
		    fprintf(file,"= %s",
			XkbModMaskText(xkb->server->vmods[i],XkbXKBFile));
		}
	    }
	    nMods++;
	}
    }
    if (nMods>0)
	fprintf(file,";\n\n");
    return TRUE;
}

/***====================================================================***/

static Bool
WriteXKBAction(FILE *file,XkbDescPtr xkb,XkbAnyAction *action)
{
    fprintf(file,"%s",XkbActionText(xkb,(XkbAction *)action,XkbXKBFile));
    return TRUE;
}

/***====================================================================***/

Bool
XkbWriteXKBKeycodes(	FILE *			file,
			XkbDescPtr		xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
Atom			kcName;
register unsigned 	i;
char *			alternate;

    if ((!xkb)||(!xkb->names)||(!xkb->names->keys)) {
	_XkbLibError(_XkbErrMissingNames,"XkbWriteXKBKeycodes",0);
	return FALSE;
    }
    kcName= xkb->names->keycodes;
    if (kcName!=None)
	 fprintf(file,"xkb_keycodes \"%s\" {\n",
					XkbAtomText(kcName,XkbXKBFile));
    else fprintf(file,"xkb_keycodes {\n");
    fprintf(file,"    minimum = %d;\n",xkb->min_key_code);
    fprintf(file,"    maximum = %d;\n",xkb->max_key_code);
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	if (xkb->names->keys[i].name[0]!='\0') {
	    if (XkbFindKeycodeByName(xkb,xkb->names->keys[i].name,TRUE)!=i)
		 alternate= "alternate ";
	    else alternate= "";
	    fprintf(file,"    %s%6s = %d;\n",alternate,
			XkbKeyNameText(xkb->names->keys[i].name,XkbXKBFile),
			i);
	}
    }
    if (xkb->indicators!=NULL) {
	for (i=0;i<XkbNumIndicators;i++) {
	    char *type;
	    if (xkb->indicators->phys_indicators&(1<<i))
			type= "    ";
	    else	type= "    virtual ";
	    if (xkb->names->indicators[i]!=None) {
		fprintf(file,"%sindicator %d = \"%s\";\n",type,i+1,
			XkbAtomText(xkb->names->indicators[i],XkbXKBFile));
	    }
	}
    }
    if (xkb->names->key_aliases!=NULL) {
	XkbKeyAliasPtr	pAl;
	pAl= xkb->names->key_aliases;
	for (i=0;i<xkb->names->num_key_aliases;i++,pAl++) {
	    fprintf(file,"    alias %6s = %6s;\n",
			XkbKeyNameText(pAl->alias,XkbXKBFile),
			XkbKeyNameText(pAl->real,XkbXKBFile));
	}
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmKeyNamesIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}

Bool
XkbWriteXKBKeyTypes(	FILE *			file,
			XkbDescPtr              xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
register unsigned	i,n;
XkbKeyTypePtr		type;
XkbKTMapEntryPtr	entry;

    if ((!xkb)||(!xkb->map)||(!xkb->map->types)) {
	_XkbLibError(_XkbErrMissingTypes,"XkbWriteXKBKeyTypes",0);
	return FALSE;
    }
    if (xkb->map->num_types<XkbNumRequiredTypes) {
	_XkbLibError(_XkbErrMissingReqTypes,"XkbWriteXKBKeyTypes",0);
	return 0;
    }
    if ((xkb->names==NULL)||(xkb->names->types==None))
	 fprintf(file,"xkb_types {\n\n");
    else fprintf(file,"xkb_types \"%s\" {\n\n",
			XkbAtomText(xkb->names->types,XkbXKBFile));
    WriteXKBVModDecl(file,xkb,
			(showImplicit?VMOD_COMMENT_VALUE:VMOD_HIDE_VALUE));

    type= xkb->map->types;
    for (i=0;i<xkb->map->num_types;i++,type++) {
	fprintf(file,"    type \"%s\" {\n",
		XkbAtomText(type->name,XkbXKBFile));
	fprintf(file,"        modifiers= %s;\n",
	       XkbVModMaskText(xkb,type->mods.real_mods,type->mods.vmods,
								XkbXKBFile));
	entry= type->map;
	for (n=0;n<type->map_count;n++,entry++) {
	    char *str;	
	    str=XkbVModMaskText(xkb,entry->mods.real_mods,entry->mods.vmods,
								XkbXKBFile);
	    fprintf(file,"        map[%s]= Level%d;\n",str,entry->level+1);
	    if ((type->preserve)&&((type->preserve[n].real_mods)||
				   (type->preserve[n].vmods))) {
		fprintf(file,"        preserve[%s]= ",str);
		fprintf(file,"%s;\n",XkbVModMaskText(xkb,
					type->preserve[n].real_mods,
					type->preserve[n].vmods,
					XkbXKBFile));
	    }
	}
	if (type->level_names!=NULL) {
	    Atom *name= type->level_names;
	    for (n=0;n<type->num_levels;n++,name++) {
		if ((*name)==None)
		    continue;
		fprintf(file,"        level_name[Level%d]= \"%s\";\n",n+1,
					XkbAtomText(*name,XkbXKBFile));
	    }
	}
	fprintf(file,"    };\n");
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmTypesIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}

static Bool
WriteXKBIndicatorMap(	FILE *			file,
			XkbDescPtr              xkb,
			Atom			name,
			XkbIndicatorMapPtr	led,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{

    fprintf(file,"    indicator \"%s\" {\n",NameForAtom(name));
    if (led->flags&XkbIM_NoExplicit)
	fprintf(file,"        !allowExplicit;\n");
    if (led->flags&XkbIM_LEDDrivesKB)
	fprintf(file,"        indicatorDrivesKeyboard;\n");
    if (led->which_groups!=0) {
	if (led->which_groups!=XkbIM_UseEffective) {
	    fprintf(file,"        whichGroupState= %s;\n",
			XkbIMWhichStateMaskText(led->which_groups,XkbXKBFile));
	}
	fprintf(file,"        groups= 0x%02x;\n",led->groups);
    }
    if (led->which_mods!=0) {
	if (led->which_mods!=XkbIM_UseEffective) {
	    fprintf(file,"        whichModState= %s;\n",
			XkbIMWhichStateMaskText(led->which_mods,XkbXKBFile));
	}
	fprintf(file,"        modifiers= %s;\n",
			XkbVModMaskText(xkb,
					led->mods.real_mods,led->mods.vmods,
					XkbXKBFile));
    }
    if (led->ctrls!=0) {
	fprintf(file,"        controls= %s;\n",
			XkbControlsMaskText(led->ctrls,XkbXKBFile));
    }
    if (addOn)
	(*addOn)(file,xkb,FALSE,TRUE,XkmIndicatorsIndex,priv);
    fprintf(file,"    };\n");
    return TRUE;
}

Bool
XkbWriteXKBCompatMap(	FILE *			file,
			XkbDescPtr              xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
register unsigned	i;
XkbSymInterpretPtr	interp;

    if ((!xkb)||(!xkb->compat)||(!xkb->compat->sym_interpret)) {
	_XkbLibError(_XkbErrMissingCompatMap,"XkbWriteXKBCompatMap",0);
	return FALSE;
    }
    if ((xkb->names==NULL)||(xkb->names->compat==None))
	 fprintf(file,"xkb_compatibility {\n\n");
    else fprintf(file,"xkb_compatibility \"%s\" {\n\n",
			XkbAtomText(xkb->names->compat,XkbXKBFile));
    WriteXKBVModDecl(file,xkb,
			(showImplicit?VMOD_COMMENT_VALUE:VMOD_HIDE_VALUE));

    fprintf(file,"    interpret.useModMapMods= AnyLevel;\n");
    fprintf(file,"    interpret.repeat= FALSE;\n");
    fprintf(file,"    interpret.locking= FALSE;\n");
    interp= xkb->compat->sym_interpret;
    for (i=0;i<xkb->compat->num_si;i++,interp++) {
	fprintf(file,"    interpret %s+%s(%s) {\n",	
				((interp->sym==NoSymbol)?"Any":
					XkbKeysymText(interp->sym,XkbXKBFile)),
				XkbSIMatchText(interp->match,XkbXKBFile),
				XkbModMaskText(interp->mods,XkbXKBFile));
	if (interp->virtual_mod!=XkbNoModifier) {
	    fprintf(file,"        virtualModifier= %s;\n",
		XkbVModIndexText(xkb,interp->virtual_mod,XkbXKBFile));
	}
	if (interp->match&XkbSI_LevelOneOnly)
	    fprintf(file,"        useModMapMods=level1;\n");
	if (interp->flags&XkbSI_LockingKey)
	    fprintf(file,"        locking= TRUE;\n");
	if (interp->flags&XkbSI_AutoRepeat)
	    fprintf(file,"        repeat= TRUE;\n");
	fprintf(file,"        action= ");
	WriteXKBAction(file,xkb,&interp->act);
	fprintf(file,";\n");
	fprintf(file,"    };\n");
    }
    for (i=0;i<XkbNumKbdGroups;i++) {
	XkbModsPtr	gc;

	gc= &xkb->compat->groups[i];
	if ((gc->real_mods==0)&&(gc->vmods==0))
	    continue;
	fprintf(file,"    group %d = %s;\n",i+1,XkbVModMaskText(xkb,
							gc->real_mods,gc->vmods,
							XkbXKBFile));
    }
    if (xkb->indicators) {
	for (i=0;i<XkbNumIndicators;i++) {
	    XkbIndicatorMapPtr map= &xkb->indicators->maps[i];
	    if ((map->flags!=0)||(map->which_groups!=0)||(map->groups!=0)||
		(map->which_mods!=0)||
		(map->mods.real_mods!=0)||(map->mods.vmods!=0)||
		(map->ctrls!=0)) {
		WriteXKBIndicatorMap(file,xkb,xkb->names->indicators[i],map,
								addOn,priv);
	    }
	}
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmCompatMapIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}

Bool
XkbWriteXKBSymbols(	FILE *			file,
			XkbDescPtr              xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
register unsigned	i,tmp;
XkbClientMapPtr		map;
XkbServerMapPtr		srv;
Bool			showActions;

    if (!xkb) {
	_XkbLibError(_XkbErrMissingSymbols,"XkbWriteXKBSymbols",0);
	return FALSE;
    }

    map= xkb->map;
    if ((!map)||(!map->syms)||(!map->key_sym_map)) {
	_XkbLibError(_XkbErrMissingSymbols,"XkbWriteXKBSymbols",0);
	return FALSE;
    }
    if ((!xkb->names)||(!xkb->names->keys)) {
	_XkbLibError(_XkbErrMissingNames,"XkbWriteXKBSymbols",0);
	return FALSE;
    }
    if ((xkb->names==NULL)||(xkb->names->symbols==None))
	 fprintf(file,"xkb_symbols {\n\n");
    else fprintf(file,"xkb_symbols \"%s\" {\n\n",
			XkbAtomText(xkb->names->symbols,XkbXKBFile));
    for (tmp=i=0;i<XkbNumKbdGroups;i++) {
	if (xkb->names->groups[i]!=None) {
	    fprintf(file,"    name[group%d]=\"%s\";\n",i+1,
			XkbAtomText(xkb->names->groups[i],XkbXKBFile));
	    tmp++;
	}
    }
    if (tmp>0)
	fprintf(file,"\n");
    srv= xkb->server;
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	Bool	simple;
	if ((int)XkbKeyNumSyms(xkb,i)<1)
	    continue;
	if (XkbFindKeycodeByName(xkb,xkb->names->keys[i].name,TRUE)!=i)
	    continue;
	simple= TRUE;
	fprintf(file,"    key %6s {",
			XkbKeyNameText(xkb->names->keys[i].name,XkbXKBFile));
	if (srv->explicit) {
	    if (((srv->explicit[i]&XkbExplicitKeyTypesMask)!=0)||
	   						(showImplicit)) {
		int 	typeNdx,g;
		Bool	multi;
		char *	comment="  ";

		if ((srv->explicit[i]&XkbExplicitKeyTypesMask)==0)
		    comment= "//";
		multi= FALSE;
		typeNdx= XkbKeyKeyTypeIndex(xkb,i,0);
		for (g=1;(g<XkbKeyNumGroups(xkb,i))&&(!multi);g++) {
		    if (XkbKeyKeyTypeIndex(xkb,i,g)!=typeNdx)
			multi= TRUE;
		}
		if (multi) {
		    for (g=0;g<XkbKeyNumGroups(xkb,i);g++) {
			typeNdx= XkbKeyKeyTypeIndex(xkb,i,g);
			if (srv->explicit[i]&(1<<g)) {
			    fprintf(file,"\n%s      type[group%d]= \"%s\",",
			    	comment,g+1,
				XkbAtomText(map->types[typeNdx].name,
			    	XkbXKBFile));
			}
			else if (showImplicit) {
			    fprintf(file,"\n//      type[group%d]= \"%s\",",g+1,
				XkbAtomText(map->types[typeNdx].name,
			    	XkbXKBFile));
			}
		    }
		}
		else {
		    fprintf(file,"\n%s      type= \"%s\",",comment,
				XkbAtomText(map->types[typeNdx].name,
			    	XkbXKBFile));
		}
		simple= FALSE;
	    }
	    if (((srv->explicit[i]&XkbExplicitAutoRepeatMask)!=0)&&
		    					  (xkb->ctrls!=NULL)) {
		if (xkb->ctrls->per_key_repeat[i/8]&(1<<(i%8)))
		     fprintf(file,"\n        repeat= Yes,");
		else fprintf(file,"\n        repeat= No,");
		simple= FALSE;
	    }
	    if ((xkb->server!=NULL)&&(xkb->server->vmodmap!=NULL)&&
					(xkb->server->vmodmap[i]!=0)) {
		if ((srv->explicit[i]&XkbExplicitVModMapMask)!=0) {
		    fprintf(file,"\n        virtualMods= %s,",
				XkbVModMaskText(xkb,0,
						xkb->server->vmodmap[i],
						XkbXKBFile));
		}
		else if (showImplicit) {
		    fprintf(file,"\n//      virtualMods= %s,",
				XkbVModMaskText(xkb,0,
						xkb->server->vmodmap[i],
						XkbXKBFile));
		}
	    }
	}
	switch (XkbOutOfRangeGroupAction(XkbKeyGroupInfo(xkb,i))) {
	    case XkbClampIntoRange:
		fprintf(file,"\n        groupsClamp,");
		break;
	    case XkbRedirectIntoRange:
		fprintf(file,"\n        groupsRedirect= Group%d,",
			XkbOutOfRangeGroupNumber(XkbKeyGroupInfo(xkb,i))+1);
		break;
	}
	if (srv->behaviors!=NULL) {
	    unsigned type;
	    type= srv->behaviors[i].type&XkbKB_OpMask;

	    if (type!=XkbKB_Default) {
		simple= FALSE;
		fprintf(file,"\n        %s,",
			XkbBehaviorText(xkb,&srv->behaviors[i],XkbXKBFile));
	    }
	}
	if ((srv->explicit==NULL) || showImplicit ||
	    ((srv->explicit[i]&XkbExplicitInterpretMask)!=0))
	     showActions= XkbKeyHasActions(xkb,i);
	else showActions= FALSE;
	
	if (((unsigned)XkbKeyNumGroups(xkb,i)>1)||showActions)
	    simple= FALSE;
	if (simple) {
	    KeySym *syms;
	    unsigned s;

	    syms= XkbKeySymsPtr(xkb,i);
	    fprintf(file,"         [ ");
	    for (s=0;s<XkbKeyGroupWidth(xkb,i,XkbGroup1Index);s++) {
		if (s!=0)
		    fprintf(file,", ");
		fprintf(file,"%15s",XkbKeysymText(*syms++,XkbXKBFile));
	    }
	    fprintf(file," ] };\n");
	}
	else {
	    unsigned g,s;
	    KeySym *syms;
	    XkbAction *acts;
	    syms= XkbKeySymsPtr(xkb,i);
	    acts= XkbKeyActionsPtr(xkb,i);
	    for (g=0;g<XkbKeyNumGroups(xkb,i);g++) {
		if (g!=0)
		    fprintf(file,",");
		fprintf(file,"\n        symbols[Group%d]= [ ",g+1);
		for (s=0;s<XkbKeyGroupWidth(xkb,i,g);s++) {
		    if (s!=0)
			fprintf(file,", ");
		    fprintf(file,"%15s",XkbKeysymText(syms[s],XkbXKBFile));
		}
		fprintf(file," ]");
		syms+= XkbKeyGroupsWidth(xkb,i);
		if (showActions) {
		    fprintf(file,",\n        actions[Group%d]= [ ",g+1);
		    for (s=0;s<XkbKeyGroupWidth(xkb,i,g);s++) {
			if (s!=0)
			    fprintf(file,", ");
			WriteXKBAction(file,xkb,(XkbAnyAction *)&acts[s]);
		    }
		    fprintf(file," ]");
		    acts+= XkbKeyGroupsWidth(xkb,i);
		}
	    }
	    fprintf(file,"\n    };\n");
	}
    }
    if (map && map->modmap) {
	for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    if (map->modmap[i]!=0) {
		register int n,bit;
		for (bit=1,n=0;n<XkbNumModifiers;n++,bit<<=1) {
		    if (map->modmap[i]&bit) {
			char buf[5];
			memcpy(buf,xkb->names->keys[i].name,4);
			buf[4]= '\0';
			fprintf(file,"    modifier_map %s { <%s> };\n",
					XkbModIndexText(n,XkbXKBFile),buf);
		    }
		}
	    }
	}
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmSymbolsIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}

static Bool
WriteXKBOutline(	FILE *		file,
			XkbShapePtr	shape,
			XkbOutlinePtr	outline,
			int		lastRadius,
			int		first,
			int		indent)
{
register int	i;
XkbPointPtr	pt;
char *		iStr;

    fprintf(file,"%s",iStr= XkbIndentText(first));
    if (first!=indent)
	iStr= XkbIndentText(indent);
    if (outline->corner_radius!=lastRadius) {
	fprintf(file,"corner= %s,",
			XkbGeomFPText(outline->corner_radius,XkbMessage));
	if (shape!=NULL) {
	    fprintf(file,"\n%s",iStr);
	}
    }
    if (shape) {
	if (outline==shape->approx)
	    fprintf(file,"approx= ");
	else if (outline==shape->primary)
	    fprintf(file,"primary= ");
    }
    fprintf(file,"{");
    for (pt=outline->points,i=0;i<outline->num_points;i++,pt++) {
	if (i==0)		fprintf(file," ");
	else if ((i%4)==0)	fprintf(file,",\n%s  ",iStr);
	else			fprintf(file,", ");
	fprintf(file,"[ %3s, %3s ]",XkbGeomFPText(pt->x,XkbXKBFile),
				  XkbGeomFPText(pt->y,XkbXKBFile));
    }
    fprintf(file," }");
    return TRUE;
}

static Bool
WriteXKBDoodad(	FILE *		file,
		unsigned	indent,
		XkbGeometryPtr	geom,
		XkbDoodadPtr	doodad)
{
register char *	i_str;
XkbShapePtr	shape;
XkbColorPtr	color;

    i_str= XkbIndentText(indent);
    fprintf(file,"%s%s \"%s\" {\n",i_str,
				XkbDoodadTypeText(doodad->any.type,XkbMessage),
				XkbAtomText(doodad->any.name,XkbMessage));
    fprintf(file,"%s    top=      %s;\n",i_str,
				 XkbGeomFPText(doodad->any.top,XkbXKBFile));
    fprintf(file,"%s    left=     %s;\n",i_str,
				XkbGeomFPText(doodad->any.left,XkbXKBFile));
    fprintf(file,"%s    priority= %d;\n",i_str,doodad->any.priority);
    switch (doodad->any.type) {
	case XkbOutlineDoodad:
	case XkbSolidDoodad:
	    if (doodad->shape.angle!=0) {
		fprintf(file,"%s    angle=  %s;\n",i_str,
			     XkbGeomFPText(doodad->shape.angle,XkbXKBFile));
	    }
	    if (doodad->shape.color_ndx!=0) {
		fprintf(file,"%s    color= \"%s\";\n",i_str,
			     XkbShapeDoodadColor(geom,&doodad->shape)->spec);
	    }
	    shape= XkbShapeDoodadShape(geom,&doodad->shape);
	    fprintf(file,"%s    shape= \"%s\";\n",i_str,
			    XkbAtomText(shape->name,XkbXKBFile));
	    break;
	case XkbTextDoodad:
	    if (doodad->text.angle!=0) {
		fprintf(file,"%s    angle=  %s;\n",i_str,
			     XkbGeomFPText(doodad->text.angle,XkbXKBFile));
	    }
	    if (doodad->text.width!=0) {
		fprintf(file,"%s    width=  %s;\n",i_str,
			     XkbGeomFPText(doodad->text.width,XkbXKBFile));

	    }
	    if (doodad->text.height!=0) {
		fprintf(file,"%s    height=  %s;\n",i_str,
			     XkbGeomFPText(doodad->text.height,XkbXKBFile));

	    }
	    if (doodad->text.color_ndx!=0) {
		color= XkbTextDoodadColor(geom,&doodad->text);
		fprintf(file,"%s    color= \"%s\";\n",i_str,
			     XkbStringText(color->spec,XkbXKBFile));
	    }
	    fprintf(file,"%s    XFont= \"%s\";\n",i_str,
	    		     XkbStringText(doodad->text.font,XkbXKBFile));
	    fprintf(file,"%s    text=  \"%s\";\n",i_str,
	    		    XkbStringText(doodad->text.text,XkbXKBFile));
	    break;
	case XkbIndicatorDoodad:
	    shape= XkbIndicatorDoodadShape(geom,&doodad->indicator);
	    color= XkbIndicatorDoodadOnColor(geom,&doodad->indicator);
	    fprintf(file,"%s    onColor= \"%s\";\n",i_str,
	    		    XkbStringText(color->spec,XkbXKBFile));
	    color= XkbIndicatorDoodadOffColor(geom,&doodad->indicator);
	    fprintf(file,"%s    offColor= \"%s\";\n",i_str,
	    		    XkbStringText(color->spec,XkbXKBFile));
	    fprintf(file,"%s    shape= \"%s\";\n",i_str,
			     XkbAtomText(shape->name,XkbXKBFile));
	    break;
	case XkbLogoDoodad:
	    fprintf(file,"%s    logoName= \"%s\";\n",i_str,
			     XkbStringText(doodad->logo.logo_name,XkbXKBFile));
	    if (doodad->shape.angle!=0) {
		fprintf(file,"%s    angle=  %s;\n",i_str,
			     XkbGeomFPText(doodad->logo.angle,XkbXKBFile));
	    }
	    if (doodad->shape.color_ndx!=0) {
		fprintf(file,"%s    color= \"%s\";\n",i_str,
			     XkbLogoDoodadColor(geom,&doodad->logo)->spec);
	    }
	    shape= XkbLogoDoodadShape(geom,&doodad->logo);
	    fprintf(file,"%s    shape= \"%s\";\n",i_str,
			    XkbAtomText(shape->name,XkbXKBFile));
	    break;
    }
    fprintf(file,"%s};\n",i_str);
    return TRUE;
}

/*ARGSUSED*/
static Bool
WriteXKBOverlay(	FILE *		file,
			unsigned	indent,
			XkbGeometryPtr	geom,
			XkbOverlayPtr	ol)
{
register char *		i_str;
int			r,k,nOut;
XkbOverlayRowPtr	row;
XkbOverlayKeyPtr	key;

    i_str= XkbIndentText(indent);
    if (ol->name!=None) {
	 fprintf(file,"%soverlay \"%s\" {\n",i_str,
    					XkbAtomText(ol->name,XkbMessage));
    }
    else fprintf(file,"%soverlay {\n",i_str);
    for (nOut=r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
	for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
	    char *over,*under;
	    over= XkbKeyNameText(key->over.name,XkbXKBFile);
	    under= XkbKeyNameText(key->under.name,XkbXKBFile);
	    if (nOut==0)
		 fprintf(file,"%s    %6s=%6s",i_str,under,over);
	    else if ((nOut%4)==0)
		 fprintf(file,",\n%s    %6s=%6s",i_str,under,over);
	    else fprintf(file,", %6s=%6s",under,over);
	    nOut++;
	}
    }
    fprintf(file,"\n%s};\n",i_str);
    return TRUE;
}

static Bool
WriteXKBSection(	FILE *		file,
			XkbSectionPtr 	s,
			XkbGeometryPtr	geom)
{
register int	i;
XkbRowPtr	row;
int		dfltKeyColor = 0;

    fprintf(file,"    section \"%s\" {\n",
				XkbAtomText(s->name,XkbXKBFile));
    if (s->rows&&(s->rows->num_keys>0)) {
	dfltKeyColor= s->rows->keys[0].color_ndx;
	fprintf(file,"        key.color= \"%s\";\n",
		XkbStringText(geom->colors[dfltKeyColor].spec,XkbXKBFile));
    }
    fprintf(file,"        priority=  %d;\n",s->priority);
    fprintf(file,"        top=       %s;\n",XkbGeomFPText(s->top,XkbXKBFile));
    fprintf(file,"        left=      %s;\n",XkbGeomFPText(s->left,XkbXKBFile));
    fprintf(file,"        width=     %s;\n",XkbGeomFPText(s->width,XkbXKBFile));
    fprintf(file,"        height=    %s;\n",
					XkbGeomFPText(s->height,XkbXKBFile));
    if (s->angle!=0) {
	fprintf(file,"        angle=  %s;\n",
					XkbGeomFPText(s->angle,XkbXKBFile));
    }
    for (i=0,row=s->rows;i<s->num_rows;i++,row++) {
	fprintf(file,"        row {\n");
	fprintf(file,"            top=  %s;\n",
					XkbGeomFPText(row->top,XkbXKBFile));
	fprintf(file,"            left= %s;\n",
					XkbGeomFPText(row->left,XkbXKBFile));
	if (row->vertical)
	    fprintf(file,"            vertical;\n");
	if (row->num_keys>0) {
	    register int 	k;
	    register XkbKeyPtr	key;
	    int			forceNL=0;
	    int			nThisLine= 0;
	    fprintf(file,"            keys {\n");
	    for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
		XkbShapePtr	shape;
		if (key->color_ndx!=dfltKeyColor)
		    forceNL= 1;
		if (k==0) {
		     fprintf(file,"                ");
		     nThisLine= 0;
		}
		else if (((nThisLine%2)==1)||(forceNL)) {
		     fprintf(file,",\n                ");
		     forceNL= nThisLine= 0;
		}
		else {
		     fprintf(file,", ");
		     nThisLine++;
		}
		shape= XkbKeyShape(geom,key);
		fprintf(file,"{ %6s, \"%s\", %3s",
		      XkbKeyNameText(key->name.name,XkbXKBFile),
		      XkbAtomText(shape->name,XkbXKBFile),
		      XkbGeomFPText(key->gap,XkbXKBFile));
		if (key->color_ndx!=dfltKeyColor) {
		    fprintf(file,", color=\"%s\"",XkbKeyColor(geom,key)->spec);
		    forceNL= 1;
		}
		fprintf(file," }");
	    }
	    fprintf(file,"\n            };\n");
	}
	fprintf(file,"        };\n");
    }
    if (s->doodads!=NULL) {
	XkbDoodadPtr	doodad;
	for (i=0,doodad=s->doodads;i<s->num_doodads;i++,doodad++) {
	    WriteXKBDoodad(file,8,geom,doodad);
	}
    }
    if (s->overlays!=NULL) {
	XkbOverlayPtr	ol;
	for (i=0,ol=s->overlays;i<s->num_overlays;i++,ol++) {
	    WriteXKBOverlay(file,8,geom,ol);
	}
    }
    fprintf(file,"    }; // End of \"%s\" section\n\n",
				XkbAtomText(s->name,XkbXKBFile));
    return TRUE;
}

Bool
XkbWriteXKBGeometry(	FILE *			file,
			XkbDescPtr              xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
register unsigned	i,n;
XkbGeometryPtr		geom;

    if ((!xkb)||(!xkb->geom)) {
	_XkbLibError(_XkbErrMissingGeometry,"XkbWriteXKBGeometry",0);
	return FALSE;
    }
    geom= xkb->geom;
    if (geom->name==None)
	 fprintf(file,"xkb_geometry {\n\n");
    else fprintf(file,"xkb_geometry \"%s\" {\n\n",
				XkbAtomText(geom->name,XkbXKBFile));
    fprintf(file,"    width=       %s;\n",
				XkbGeomFPText(geom->width_mm,XkbXKBFile));
    fprintf(file,"    height=      %s;\n\n",
				XkbGeomFPText(geom->height_mm,XkbXKBFile));

    if (geom->key_aliases!=NULL) {
	XkbKeyAliasPtr	pAl;
	pAl= geom->key_aliases;
	for (i=0;i<geom->num_key_aliases;i++,pAl++) {
	    fprintf(file,"    alias %6s = %6s;\n",
				XkbKeyNameText(pAl->alias,XkbXKBFile),
				XkbKeyNameText(pAl->real,XkbXKBFile));
	}
	fprintf(file,"\n");
    }

    if (geom->base_color!=NULL)
	fprintf(file,"    baseColor=   \"%s\";\n",
			XkbStringText(geom->base_color->spec,XkbXKBFile));
    if (geom->label_color!=NULL)
	fprintf(file,"    labelColor=  \"%s\";\n",
			XkbStringText(geom->label_color->spec,XkbXKBFile));
    if (geom->label_font!=NULL)
	fprintf(file,"    xfont=       \"%s\";\n",
			XkbStringText(geom->label_font,XkbXKBFile));
    if ((geom->num_colors>0)&&(showImplicit)) {
	XkbColorPtr	color;
	for (color=geom->colors,i=0;i<geom->num_colors;i++,color++) {
		fprintf(file,"//     color[%d]= \"%s\"\n",i,
				XkbStringText(color->spec,XkbXKBFile));
	}
	fprintf(file,"\n");
    }
    if (geom->num_properties>0) {
	XkbPropertyPtr	prop;
	for (prop=geom->properties,i=0;i<geom->num_properties;i++,prop++) {
	    fprintf(file,"    %s= \"%s\";\n",prop->name,
    				XkbStringText(prop->value,XkbXKBFile));
	}
	fprintf(file,"\n");
    }
    if (geom->num_shapes>0) {
	XkbShapePtr	shape;
	XkbOutlinePtr	outline;
	int		lastR;
	for (shape=geom->shapes,i=0;i<geom->num_shapes;i++,shape++) {
	    lastR=0;
	    fprintf(file,"    shape \"%s\" {",
				   XkbAtomText(shape->name,XkbXKBFile));
	    outline= shape->outlines;
	    if (shape->num_outlines>1) {
		for (n=0;n<shape->num_outlines;n++,outline++) {
		    if (n==0)	fprintf(file,"\n");
		    else	fprintf(file,",\n");
		    WriteXKBOutline(file,shape,outline,lastR,8,8);
		    lastR= outline->corner_radius;
		}
		fprintf(file,"\n    };\n");
	    }
	    else {
		WriteXKBOutline(file,NULL,outline,lastR,1,8);
		fprintf(file," };\n");
	    }
	}
    }
    if (geom->num_sections>0) {
	XkbSectionPtr	section;
	for (section=geom->sections,i=0;i<geom->num_sections;i++,section++){
	    WriteXKBSection(file,section,geom);
	}
    }
    if (geom->num_doodads>0) {
	XkbDoodadPtr	doodad;
	for (i=0,doodad=geom->doodads;i<geom->num_doodads;i++,doodad++) {
	    WriteXKBDoodad(file,4,geom,doodad);
	}
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmGeometryIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "exevents.h"
#include "eventstr.h"
#include <xkbsrv.h>
#include <ctype.h>
#include "events.h"

/***====================================================================***/

void
XkbProcessKeyboardEvent(DeviceEvent *event, DeviceIntPtr keybd)
{
KeyClassPtr	keyc = keybd->key;
XkbSrvInfoPtr	xkbi;
int		key;
XkbBehavior	behavior;
unsigned        ndx;

    xkbi = keyc->xkbInfo;
    key = event->detail.key;
    if (xkbDebugFlags & 0x8)
	DebugF("[xkb] XkbPKE: Key %d %s\n",key,(event->type == ET_KeyPress?"down":"up"));

    if (xkbi->repeatKey == key && event->type== ET_KeyRelease &&
        !(xkbi->desc->ctrls->enabled_ctrls & XkbRepeatKeysMask))
	AccessXCancelRepeatKey(xkbi, key);

    behavior = xkbi->desc->server->behaviors[key];
    /* The "permanent" flag indicates a hard-wired behavior that occurs */
    /* below XKB, such as a key that physically locks.   XKB does not   */
    /* do anything to implement the behavior, but it *does* report that */
    /* key is hardwired */

    if (!(behavior.type & XkbKB_Permanent)) {
	switch (behavior.type) {
	    case XkbKB_Default:
                /* Neither of these should happen in practice, but ignore them
                   anyway. */
		if (event->type == ET_KeyPress && !event->key_repeat &&
                    key_is_down(keybd, key, KEY_PROCESSED))
                    return;
		else if (event->type == ET_KeyRelease &&
                         !key_is_down(keybd, key, KEY_PROCESSED))
                    return;
		break;
	    case XkbKB_Lock:
		if (event->type == ET_KeyRelease)
		    return;
		else if (key_is_down(keybd, key, KEY_PROCESSED))
                    event->type = ET_KeyRelease;
		break;
	    case XkbKB_RadioGroup:
		ndx= (behavior.data&(~XkbKB_RGAllowNone));
		if ( ndx<xkbi->nRadioGroups ) {
		    XkbRadioGroupPtr	rg;

		    if (event->type == ET_KeyRelease)
		        return;

		    rg = &xkbi->radioGroups[ndx];
		    if ( rg->currentDown == event->detail.key) {
		        if (behavior.data&XkbKB_RGAllowNone) {
		            event->type = ET_KeyRelease;
			    XkbHandleActions(keybd, keybd, event);
			    rg->currentDown= 0;
		        }
		        return;
		    }
		    if ( rg->currentDown!=0 ) {
			int key = event->detail.key;
			event->type = ET_KeyRelease;
			event->detail.key = rg->currentDown;
			XkbHandleActions(keybd, keybd, event);
			event->type = ET_KeyPress;
			event->detail.key = key;
		    }
		    rg->currentDown= key;
		}
		else ErrorF("[xkb] InternalError! Illegal radio group %d\n",ndx);
		break;
	    case XkbKB_Overlay1: case XkbKB_Overlay2:
		{
		    unsigned	which;
		    if (behavior.type==XkbKB_Overlay1)	which= XkbOverlay1Mask;
		    else				which= XkbOverlay2Mask;
		    if ( (xkbi->desc->ctrls->enabled_ctrls&which)==0 )
			break;
		    if ((behavior.data>=xkbi->desc->min_key_code)&&
			(behavior.data<=xkbi->desc->max_key_code)) {
                        event->detail.key = behavior.data;
			/* 9/11/94 (ef) -- XXX! need to match release with */
			/*                 press even if the state of the  */
			/*                 corresponding overlay control   */
			/*                 changes while the key is down   */
		    }
		}
		break;
	    default:
		ErrorF("[xkb] unknown key behavior 0x%04x\n",behavior.type);
		break;
	}
    }
    XkbHandleActions(keybd, keybd, event);
    return;
}

void
ProcessKeyboardEvent(InternalEvent *ev, DeviceIntPtr keybd)
{

    KeyClassPtr keyc = keybd->key;
    XkbSrvInfoPtr xkbi = NULL;
    ProcessInputProc backup_proc;
    xkbDeviceInfoPtr xkb_priv = XKBDEVICEINFO(keybd);
    DeviceEvent *event = &ev->device_event;
    int is_press = (event->type == ET_KeyPress);
    int is_release = (event->type == ET_KeyRelease);

    /* We're only interested in key events. */
    if (!is_press && !is_release) {
        UNWRAP_PROCESS_INPUT_PROC(keybd, xkb_priv, backup_proc);
        keybd->public.processInputProc(ev, keybd);
        COND_WRAP_PROCESS_INPUT_PROC(keybd, xkb_priv, backup_proc,
                                     xkbUnwrapProc);
        return;
    }

    xkbi = keyc->xkbInfo;

    /* If AccessX filters are active, then pass it through to
     * AccessXFilter{Press,Release}Event; else, punt to
     * XkbProcessKeyboardEvent.
     *
     * If AXF[PK]E don't intercept anything (which they probably won't),
     * they'll punt through XPKE anyway. */
    if ((xkbi->desc->ctrls->enabled_ctrls & XkbAllFilteredEventsMask)) {
        if (is_press)
            AccessXFilterPressEvent(event, keybd);
        else if (is_release)
            AccessXFilterReleaseEvent(event, keybd);
        return;
    }
    else {
        XkbProcessKeyboardEvent(event, keybd);
    }

    return;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "stdio.h"
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <xkbsrv.h>
#include "xkbstr.h"
#include "extnsionst.h"
#include "xkb.h"

	/*
	 * REQUEST SWAPPING
	 */
static int
SProcXkbUseExtension(ClientPtr client)
{
register int n;

    REQUEST(xkbUseExtensionReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbUseExtensionReq);
    swaps(&stuff->wantedMajor,n);
    swaps(&stuff->wantedMinor,n);
    return ProcXkbUseExtension(client);
}

static int
SProcXkbSelectEvents(ClientPtr client)
{
register int n;

    REQUEST(xkbSelectEventsReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->affectWhich,n);
    swaps(&stuff->clear,n);
    swaps(&stuff->selectAll,n);
    swaps(&stuff->affectMap,n);
    swaps(&stuff->map,n);
    if ((stuff->affectWhich&(~XkbMapNotifyMask))!=0)  {
	union {
	    BOOL	*b;
	    CARD8	*c8;
	    CARD16	*c16;
	    CARD32	*c32;
	} from;
	register unsigned bit,ndx,maskLeft,dataLeft,size;

	from.c8= (CARD8 *)&stuff[1];
	dataLeft= (stuff->length*4)-SIZEOF(xkbSelectEventsReq);
	maskLeft= (stuff->affectWhich&(~XkbMapNotifyMask));
	for (ndx=0,bit=1; (maskLeft!=0); ndx++, bit<<=1) {
	    if (((bit&maskLeft)==0)||(ndx==XkbMapNotify))
		continue;
	    maskLeft&= ~bit;
	    if ((stuff->selectAll&bit)||(stuff->clear&bit))
		continue;
	    switch (ndx) {
		case XkbNewKeyboardNotify:
		case XkbStateNotify:
		case XkbNamesNotify:
		case XkbAccessXNotify:
		case XkbExtensionDeviceNotify:
		    size= 2;
		    break;
		case XkbControlsNotify:
		case XkbIndicatorStateNotify:
		case XkbIndicatorMapNotify:
		    size= 4;
		    break;
		case XkbBellNotify:
		case XkbActionMessage:
		case XkbCompatMapNotify:
		    size= 1;
		    break;
		default:
		    client->errorValue = _XkbErrCode2(0x1,bit);
		    return BadValue;
	    }
	    if (dataLeft<(size*2))
		return BadLength;
	    if (size==2) {
		swaps(&from.c16[0],n);
		swaps(&from.c16[1],n);
	    }
	    else if (size==4) {
		swapl(&from.c32[0],n);
		swapl(&from.c32[1],n);
	    }
	    else {
		size= 2;
	    }
	    from.c8+= (size*2);
	    dataLeft-= (size*2);
	}
	if (dataLeft>2) {
	    ErrorF("[xkb] Extra data (%d bytes) after SelectEvents\n",dataLeft);
	    return BadLength;
	}
    }
    return ProcXkbSelectEvents(client);
}

static int
SProcXkbBell(ClientPtr client)
{
register int	n;

    REQUEST(xkbBellReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbBellReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->bellClass,n);
    swaps(&stuff->bellID,n);
    swapl(&stuff->name,n);
    swapl(&stuff->window,n);
    swaps(&stuff->pitch,n);
    swaps(&stuff->duration,n);
    return ProcXkbBell(client);
}

static int
SProcXkbGetState(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetStateReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetStateReq);
    swaps(&stuff->deviceSpec,n);
    return ProcXkbGetState(client);
}

static int
SProcXkbLatchLockState(ClientPtr client)
{
register int 	n;

    REQUEST(xkbLatchLockStateReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbLatchLockStateReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->groupLatch,n);
    return ProcXkbLatchLockState(client);
}

static int
SProcXkbGetControls(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetControlsReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetControlsReq);
    swaps(&stuff->deviceSpec,n);
    return ProcXkbGetControls(client);
}

static int
SProcXkbSetControls(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetControlsReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbSetControlsReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->affectInternalVMods,n);
    swaps(&stuff->internalVMods,n);
    swaps(&stuff->affectIgnoreLockVMods,n);
    swaps(&stuff->ignoreLockVMods,n);
    swaps(&stuff->axOptions,n);
    swapl(&stuff->affectEnabledCtrls,n);
    swapl(&stuff->enabledCtrls,n);
    swapl(&stuff->changeCtrls,n);
    swaps(&stuff->repeatDelay,n);
    swaps(&stuff->repeatInterval,n);
    swaps(&stuff->slowKeysDelay,n);
    swaps(&stuff->debounceDelay,n);
    swaps(&stuff->mkDelay,n);
    swaps(&stuff->mkInterval,n);
    swaps(&stuff->mkTimeToMax,n);
    swaps(&stuff->mkMaxSpeed,n);
    swaps(&stuff->mkCurve,n);
    swaps(&stuff->axTimeout,n);
    swapl(&stuff->axtCtrlsMask,n);
    swapl(&stuff->axtCtrlsValues,n);
    swaps(&stuff->axtOptsMask,n);
    swaps(&stuff->axtOptsValues,n);
    return ProcXkbSetControls(client);
}

static int
SProcXkbGetMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetMapReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetMapReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->full,n);
    swaps(&stuff->partial,n);
    swaps(&stuff->virtualMods,n);
    return ProcXkbGetMap(client);
}

static int
SProcXkbSetMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetMapReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetMapReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->present,n);
    swaps(&stuff->flags,n);
    swaps(&stuff->totalSyms,n);
    swaps(&stuff->totalActs,n);
    swaps(&stuff->virtualMods,n);
    return ProcXkbSetMap(client);
}


static int
SProcXkbGetCompatMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetCompatMapReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetCompatMapReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->firstSI,n);
    swaps(&stuff->nSI,n);
    return ProcXkbGetCompatMap(client);
}

static int
SProcXkbSetCompatMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetCompatMapReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetCompatMapReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->firstSI,n);
    swaps(&stuff->nSI,n);
    return ProcXkbSetCompatMap(client);
}

static int
SProcXkbGetIndicatorState(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetIndicatorStateReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetIndicatorStateReq);
    swaps(&stuff->deviceSpec,n);
    return ProcXkbGetIndicatorState(client);
}

static int
SProcXkbGetIndicatorMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetIndicatorMapReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetIndicatorMapReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->which,n);
    return ProcXkbGetIndicatorMap(client);
}

static int
SProcXkbSetIndicatorMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetIndicatorMapReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetIndicatorMapReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->which,n);
    return ProcXkbSetIndicatorMap(client);
}

static int
SProcXkbGetNamedIndicator(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetNamedIndicatorReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetNamedIndicatorReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->ledClass,n);
    swaps(&stuff->ledID,n);
    swapl(&stuff->indicator,n);
    return ProcXkbGetNamedIndicator(client);
}

static int
SProcXkbSetNamedIndicator(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetNamedIndicatorReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbSetNamedIndicatorReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->ledClass,n);
    swaps(&stuff->ledID,n);
    swapl(&stuff->indicator,n);
    swaps(&stuff->virtualMods,n);
    swapl(&stuff->ctrls,n);
    return ProcXkbSetNamedIndicator(client);
}


static int
SProcXkbGetNames(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetNamesReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetNamesReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->which,n);
    return ProcXkbGetNames(client);
}

static int
SProcXkbSetNames(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetNamesReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetNamesReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->virtualMods,n);
    swapl(&stuff->which,n);
    swapl(&stuff->indicators,n);
    swaps(&stuff->totalKTLevelNames,n);
    return ProcXkbSetNames(client);
}

static int
SProcXkbGetGeometry(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetGeometryReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetGeometryReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->name,n);
    return ProcXkbGetGeometry(client);
}

static int
SProcXkbSetGeometry(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetGeometryReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetGeometryReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->name,n);
    swaps(&stuff->widthMM,n);
    swaps(&stuff->heightMM,n);
    swaps(&stuff->nProperties,n);
    swaps(&stuff->nColors,n);
    swaps(&stuff->nDoodads,n);
    swaps(&stuff->nKeyAliases,n);
    return ProcXkbSetGeometry(client);
}

static int
SProcXkbPerClientFlags(ClientPtr client)
{
register int	n;

    REQUEST(xkbPerClientFlagsReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbPerClientFlagsReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->change,n);
    swapl(&stuff->value,n);
    swapl(&stuff->ctrlsToChange,n);
    swapl(&stuff->autoCtrls,n);
    swapl(&stuff->autoCtrlValues,n);
    return ProcXkbPerClientFlags(client);
}

static int
SProcXkbListComponents(ClientPtr client)
{
register int	n;

    REQUEST(xkbListComponentsReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbListComponentsReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->maxNames,n);
    return ProcXkbListComponents(client);
}

static int
SProcXkbGetKbdByName(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetKbdByNameReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->want,n);
    swaps(&stuff->need,n);
    return ProcXkbGetKbdByName(client);
}

static int
SProcXkbGetDeviceInfo(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetDeviceInfoReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetDeviceInfoReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->wanted,n);
    swaps(&stuff->ledClass,n);
    swaps(&stuff->ledID,n);
    return ProcXkbGetDeviceInfo(client);
}

static int
SProcXkbSetDeviceInfo(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetDeviceInfoReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetDeviceInfoReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->change,n);
    swaps(&stuff->nDeviceLedFBs,n);
    return ProcXkbSetDeviceInfo(client);
}

static int
SProcXkbSetDebuggingFlags(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetDebuggingFlagsReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetDebuggingFlagsReq);
    swapl(&stuff->affectFlags,n);
    swapl(&stuff->flags,n);
    swapl(&stuff->affectCtrls,n);
    swapl(&stuff->ctrls,n);
    swaps(&stuff->msgLength,n);
    return ProcXkbSetDebuggingFlags(client);
}

int
SProcXkbDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_kbUseExtension:
	return SProcXkbUseExtension(client);
    case X_kbSelectEvents:
	return SProcXkbSelectEvents(client);
    case X_kbBell:
	return SProcXkbBell(client);
    case X_kbGetState:
	return SProcXkbGetState(client);
    case X_kbLatchLockState:
	return SProcXkbLatchLockState(client);
    case X_kbGetControls:
	return SProcXkbGetControls(client);
    case X_kbSetControls:
	return SProcXkbSetControls(client);
    case X_kbGetMap:
	return SProcXkbGetMap(client);
    case X_kbSetMap:
	return SProcXkbSetMap(client);
    case X_kbGetCompatMap:
	return SProcXkbGetCompatMap(client);
    case X_kbSetCompatMap:
	return SProcXkbSetCompatMap(client);
    case X_kbGetIndicatorState:
	return SProcXkbGetIndicatorState(client);
    case X_kbGetIndicatorMap:
	return SProcXkbGetIndicatorMap(client);
    case X_kbSetIndicatorMap:
	return SProcXkbSetIndicatorMap(client);
    case X_kbGetNamedIndicator:
	return SProcXkbGetNamedIndicator(client);
    case X_kbSetNamedIndicator:
	return SProcXkbSetNamedIndicator(client);
    case X_kbGetNames:
	return SProcXkbGetNames(client);
    case X_kbSetNames:
	return SProcXkbSetNames(client);
    case X_kbGetGeometry:
	return SProcXkbGetGeometry(client);
    case X_kbSetGeometry:
	return SProcXkbSetGeometry(client);
    case X_kbPerClientFlags:
	return SProcXkbPerClientFlags(client);
    case X_kbListComponents:
	return SProcXkbListComponents(client);
    case X_kbGetKbdByName:
	return SProcXkbGetKbdByName(client);
    case X_kbGetDeviceInfo:
	return SProcXkbGetDeviceInfo(client);
    case X_kbSetDeviceInfo:
	return SProcXkbSetDeviceInfo(client);
    case X_kbSetDebuggingFlags:
	return SProcXkbSetDebuggingFlags(client);
    default:
	return BadRequest;
    }
}
/************************************************************
 Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include <X11/Xos.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XKMformat.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS	1
#include <xkbsrv.h>
#include "xkbgeom.h"

/***====================================================================***/

#define	BUFFER_SIZE	512

static char textBuffer[BUFFER_SIZE];
static int  tbNext= 0;

static char *
tbGetBuffer(unsigned size)
{
char *rtrn;

    if (size>=BUFFER_SIZE)
	return NULL;
    if ((BUFFER_SIZE-tbNext)<=size)
	tbNext= 0;
    rtrn= &textBuffer[tbNext];
    tbNext+= size;
    return rtrn;
}

/***====================================================================***/

char *
XkbAtomText(Atom atm,unsigned format)
{
const char	*atmstr;
char	*rtrn,*tmp;

    atmstr = NameForAtom(atm);
    if (atmstr != NULL) {
	int	len;
	len= strlen(atmstr)+1;
	if (len>BUFFER_SIZE)
	    len= BUFFER_SIZE-2;
	rtrn= tbGetBuffer(len);
	strncpy(rtrn,atmstr,len);
	rtrn[len]= '\0';
    }
    else {
	rtrn= tbGetBuffer(1);
	rtrn[0]= '\0';
    }
    if (format==XkbCFile) {
	for (tmp=rtrn;*tmp!='\0';tmp++) {
	    if ((tmp==rtrn)&&(!isalpha(*tmp)))
		*tmp= '_';
	    else if (!isalnum(*tmp))
		*tmp= '_';
	}
    }
    return XkbStringText(rtrn,format);
}

/***====================================================================***/

char *
XkbVModIndexText(XkbDescPtr xkb,unsigned ndx,unsigned format)
{
register int len;
register Atom *vmodNames;
char *rtrn;
const char *tmp;
char  numBuf[20];

    if (xkb && xkb->names)
	 vmodNames= xkb->names->vmods;
    else vmodNames= NULL;

    tmp= NULL;
    if (ndx>=XkbNumVirtualMods)
	 tmp= "illegal";
    else if (vmodNames&&(vmodNames[ndx]!=None))
	 tmp= NameForAtom(vmodNames[ndx]);
    if (tmp==NULL) {
	sprintf(numBuf,"%d",ndx);
	tmp = numBuf;
    }

    len= strlen(tmp)+1;
    if (format==XkbCFile)
	len+= 4;
    if (len>=BUFFER_SIZE)
	len= BUFFER_SIZE-1;
    rtrn= tbGetBuffer(len);
    if (format==XkbCFile) {
	 strcpy(rtrn,"vmod_");
	 strncpy(&rtrn[5],tmp,len-4);
    }
    else strncpy(rtrn,tmp,len);
    return rtrn;
}

char *
XkbVModMaskText(        XkbDescPtr	xkb,
			unsigned	modMask,
			unsigned	mask,
			unsigned	format)
{
register int i,bit;
int	 len;
char *mm,*rtrn;
char *str,buf[BUFFER_SIZE];

    if ((modMask==0)&&(mask==0)) {
	rtrn= tbGetBuffer(5);
	if (format==XkbCFile)
	     sprintf(rtrn,"0");
	else sprintf(rtrn,"none");
	return rtrn;
    }
    if (modMask!=0)
	 mm= XkbModMaskText(modMask,format);
    else mm= NULL;

    str= buf;
    buf[0]= '\0';
    if (mask) {
	char *tmp;
	for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	    if (mask&bit) {
		tmp= XkbVModIndexText(xkb,i,format);
		len= strlen(tmp)+1+(str==buf?0:1);
		if (format==XkbCFile)
		    len+= 4;
		if ((str-(buf+len))<=BUFFER_SIZE) {
		    if (str!=buf) {
			if (format==XkbCFile)	*str++= '|';
			else			*str++= '+';
			len--;
		    }
		}
		if (format==XkbCFile)
		     sprintf(str,"%sMask",tmp);
		else strcpy(str,tmp);
		str= &str[len-1];
	    }
	}
	str= buf;
    }
    else str= NULL;
    if (mm)	
	len= strlen(mm);
    else	len= 0;
    if (str)
	len+= strlen(str)+(mm==NULL?0:1);
    if (len>=BUFFER_SIZE)
	len= BUFFER_SIZE-1;
    rtrn= tbGetBuffer(len+1);
    rtrn[0]= '\0';

    if (mm!=NULL) {
	i= strlen(mm);
	if (i>len)
	    i= len;
	strcpy(rtrn,mm);
    }
    else {
	i=0;
    }
    if (str!=NULL) {
	if (mm!=NULL) {
	    if (format==XkbCFile)	strcat(rtrn,"|");
	    else			strcat(rtrn,"+");
	}
	strncat(rtrn,str,len-i);
    }
    rtrn[len]= '\0';
    return rtrn;
}

static char *modNames[XkbNumModifiers] = {
    "Shift", "Lock", "Control", "Mod1", "Mod2", "Mod3", "Mod4", "Mod5"
};

char *
XkbModIndexText(unsigned ndx,unsigned format)
{
char *	rtrn;
char	buf[100];

    if (format==XkbCFile) {
	if (ndx<XkbNumModifiers)
	     sprintf(buf,"%sMapIndex",modNames[ndx]);
	else if (ndx==XkbNoModifier)
	     sprintf(buf,"XkbNoModifier");
	else sprintf(buf,"0x%02x",ndx);
    }
    else {
	if (ndx<XkbNumModifiers)
	     strcpy(buf,modNames[ndx]);
	else if (ndx==XkbNoModifier)
	     strcpy(buf,"none");
	else sprintf(buf,"ILLEGAL_%02x",ndx);
    }
    rtrn= tbGetBuffer(strlen(buf)+1);
    strcpy(rtrn,buf);
    return rtrn;
}

char *
XkbModMaskText(unsigned mask,unsigned format)
{
register int i,bit;
char buf[64],*rtrn;

    if ((mask&0xff)==0xff) {
	if (format==XkbCFile) 		strcpy(buf,"0xff");
	else				strcpy(buf,"all");
    }
    else if ((mask&0xff)==0) {
	if (format==XkbCFile)		strcpy(buf,"0");
	else				strcpy(buf,"none");
    }
    else {
	char *str= buf;
	buf[0]= '\0';
	for (i=0,bit=1;i<XkbNumModifiers;i++,bit<<=1) {
	    if (mask&bit) {
		if (str!=buf) {
		    if (format==XkbCFile)	*str++= '|';
		    else			*str++= '+';
		}
		strcpy(str,modNames[i]);
		str= &str[strlen(str)];
		if (format==XkbCFile) {
		    strcpy(str,"Mask");
		    str+= 4;
		}
	    }
	}
    }
    rtrn= tbGetBuffer(strlen(buf)+1);
    strcpy(rtrn,buf);
    return rtrn;
}

/***====================================================================***/

/*ARGSUSED*/
char *
XkbConfigText(unsigned config,unsigned format)
{
static char *buf;

    buf= tbGetBuffer(32);
    switch (config) {
	case XkmSemanticsFile:
	    strcpy(buf,"Semantics");
	    break;
	case XkmLayoutFile:
	    strcpy(buf,"Layout");
	    break;
	case XkmKeymapFile:
	    strcpy(buf,"Keymap");
	    break;
	case XkmGeometryFile:
	case XkmGeometryIndex:
	    strcpy(buf,"Geometry");
	    break;
	case XkmTypesIndex:
	    strcpy(buf,"Types");
	    break;
	case XkmCompatMapIndex:
	    strcpy(buf,"CompatMap");
	    break;
	case XkmSymbolsIndex:
	    strcpy(buf,"Symbols");
	    break;
	case XkmIndicatorsIndex:
	    strcpy(buf,"Indicators");
	    break;
	case XkmKeyNamesIndex:
	    strcpy(buf,"KeyNames");
	    break;
	case XkmVirtualModsIndex:
	    strcpy(buf,"VirtualMods");
	    break;
	default:
	    sprintf(buf,"unknown(%d)",config);
	    break;
    }
    return buf;
}

/***====================================================================***/

char *
XkbKeysymText(KeySym sym,unsigned format)
{
static char buf[32],*rtrn;

    if (sym==NoSymbol)
	 strcpy(rtrn=buf,"NoSymbol");
    else sprintf(rtrn=buf, "0x%lx", (long)sym);
    return rtrn;
}

char *
XkbKeyNameText(char *name,unsigned format)
{
char *buf;

    if (format==XkbCFile) {
	buf= tbGetBuffer(5);
	memcpy(buf,name,4);
	buf[4]= '\0';
    }
    else {
	int len;
	buf= tbGetBuffer(7);
	buf[0]= '<';
	memcpy(&buf[1],name,4);
	buf[5]= '\0';
	len= strlen(buf);
	buf[len++]= '>';
	buf[len]= '\0';
    }
    return buf;
}

/***====================================================================***/

static char *siMatchText[5] = {
	"NoneOf", "AnyOfOrNone", "AnyOf", "AllOf", "Exactly"
};

char *
XkbSIMatchText(unsigned type,unsigned format)
{
static char buf[40];
char *rtrn;

    switch (type&XkbSI_OpMask) {
	case XkbSI_NoneOf:	rtrn= siMatchText[0]; break;
	case XkbSI_AnyOfOrNone:	rtrn= siMatchText[1]; break;
	case XkbSI_AnyOf:	rtrn= siMatchText[2]; break;
	case XkbSI_AllOf:	rtrn= siMatchText[3]; break;
	case XkbSI_Exactly:	rtrn= siMatchText[4]; break;
	default:		sprintf(buf,"0x%x",type&XkbSI_OpMask);
				return buf;
    }
    if (format==XkbCFile) {
	if (type&XkbSI_LevelOneOnly)
	     sprintf(buf,"XkbSI_LevelOneOnly|XkbSI_%s",rtrn);
	else sprintf(buf,"XkbSI_%s",rtrn);
	rtrn= buf;
    }
    return rtrn;
}

/***====================================================================***/

static char *imWhichNames[]= {
	"base",
	"latched",
	"locked",
	"effective",
	"compat"
};

char *
XkbIMWhichStateMaskText(unsigned use_which,unsigned format)
{
int		len;
unsigned	i,bit,tmp;
char *		buf;

    if (use_which==0) {
	buf= tbGetBuffer(2);
	strcpy(buf,"0");
	return buf;
    }
    tmp= use_which&XkbIM_UseAnyMods;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    len+= strlen(imWhichNames[i])+1;
	    if (format==XkbCFile)
		len+= 9;
	}
    }
    buf= tbGetBuffer(len+1);
    tmp= use_which&XkbIM_UseAnyMods;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    if (format==XkbCFile) {
		if (len!=0)
		    buf[len++]= '|';
		sprintf(&buf[len],"XkbIM_Use%s",imWhichNames[i]);
		buf[len+9]= toupper(buf[len+9]);
	    }
	    else {
		if (len!=0)
		    buf[len++]= '+';
		sprintf(&buf[len],"%s",imWhichNames[i]);
	    }
	    len+= strlen(&buf[len]);
	}
    }
    return buf;
}

static char *ctrlNames[] = {
	"repeatKeys",
	"slowKeys",
	"bounceKeys",
	"stickyKeys",
	"mouseKeys",
	"mouseKeysAccel",
	"accessXKeys",
	"accessXTimeout",
	"accessXFeedback",
	"audibleBell",
	"overlay1",
	"overlay2",
	"ignoreGroupLock"
};

char *
XkbControlsMaskText(unsigned ctrls,unsigned format)
{
int		len;
unsigned	i,bit,tmp;
char *		buf;

    if (ctrls==0) {
	buf= tbGetBuffer(5);
	if (format==XkbCFile)
	     strcpy(buf,"0");
	else strcpy(buf,"none");
	return buf;
    }
    tmp= ctrls&XkbAllBooleanCtrlsMask;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    len+= strlen(ctrlNames[i])+1;
	    if (format==XkbCFile)
		len+= 7;
	}
    }
    buf= tbGetBuffer(len+1);
    tmp= ctrls&XkbAllBooleanCtrlsMask;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    if (format==XkbCFile) {
		if (len!=0)
		    buf[len++]= '|';
		sprintf(&buf[len],"Xkb%sMask",ctrlNames[i]);
		buf[len+3]= toupper(buf[len+3]);
	    }
	    else {
		if (len!=0)
		    buf[len++]= '+';
		sprintf(&buf[len],"%s",ctrlNames[i]);
	    }
	    len+= strlen(&buf[len]);
	}
    }
    return buf;
}

/***====================================================================***/

char *
XkbStringText(char *str,unsigned format)
{
char *	buf;
register char *in,*out;
int	len;
Bool	ok;

    if (str==NULL) {
	buf= tbGetBuffer(2);
	buf[0]='\0';
	return buf;
    }
    else if (format==XkbXKMFile)
	return str;
    for (ok= TRUE,len=0,in=str;*in!='\0';in++,len++) {
	if (!isprint(*in)) {
	    ok= FALSE;
	    switch (*in) {
		case '\n': case '\t': case '\v':
		case '\b': case '\r': case '\f':
		    len++;
		    break;
		default:
		    len+= 4;
		    break;
	    }
	}
    }
    if (ok)
	return str;
    buf= tbGetBuffer(len+1);
    for (in=str,out=buf;*in!='\0';in++) {
	if (isprint(*in))
	    *out++= *in;
	else {
	    *out++= '\\';
	    if (*in=='\n')	*out++= 'n';
	    else if (*in=='\t')	*out++= 't';
	    else if (*in=='\v')	*out++= 'v';
	    else if (*in=='\b')	*out++= 'b';
	    else if (*in=='\r')	*out++= 'r';
	    else if (*in=='\f')	*out++= 'f';
	    else if ((*in=='\033')&&(format==XkbXKMFile)) {
		*out++= 'e';
	    }
	    else {
		*out++= '0';
		sprintf(out,"%o",*in);
		while (*out!='\0')
		    out++;
	    }
	}
    }
    *out++= '\0';
    return buf;
}

/***====================================================================***/

char *
XkbGeomFPText(int val,unsigned format)
{
int	whole,frac;
char *	buf;

    buf= tbGetBuffer(12);
    if (format==XkbCFile) {
	sprintf(buf,"%d",val);
    }
    else {
	whole= val/XkbGeomPtsPerMM;
	frac= val%XkbGeomPtsPerMM;
	if (frac!=0)
	     sprintf(buf,"%d.%d",whole,frac);
	else sprintf(buf,"%d",whole);
    }
    return buf;
}

char *
XkbDoodadTypeText(unsigned type,unsigned format)
{
char *	buf;
    if (format==XkbCFile) {
	buf= tbGetBuffer(24);
	if (type==XkbOutlineDoodad)	   strcpy(buf,"XkbOutlineDoodad");
	else if (type==XkbSolidDoodad)	   strcpy(buf,"XkbSolidDoodad");
	else if (type==XkbTextDoodad)	   strcpy(buf,"XkbTextDoodad");
	else if (type==XkbIndicatorDoodad) strcpy(buf,"XkbIndicatorDoodad");
	else if (type==XkbLogoDoodad)	   strcpy(buf,"XkbLogoDoodad");
	else				   sprintf(buf,"UnknownDoodad%d",type);
    }
    else {
	buf= tbGetBuffer(12);
	if (type==XkbOutlineDoodad)	   strcpy(buf,"outline");
	else if (type==XkbSolidDoodad)	   strcpy(buf,"solid");
	else if (type==XkbTextDoodad)	   strcpy(buf,"text");
	else if (type==XkbIndicatorDoodad) strcpy(buf,"indicator");
	else if (type==XkbLogoDoodad)	   strcpy(buf,"logo");
	else				   sprintf(buf,"unknown%d",type);
    }
    return buf;
}

static char *actionTypeNames[XkbSA_NumActions]= {
    "NoAction", 
    "SetMods",      "LatchMods",    "LockMods", 
    "SetGroup",     "LatchGroup",   "LockGroup",
    "MovePtr",
    "PtrBtn",       "LockPtrBtn",
    "SetPtrDflt",
    "ISOLock",
    "Terminate",    "SwitchScreen", 
    "SetControls",  "LockControls",
    "ActionMessage",
    "RedirectKey",
    "DeviceBtn",    "LockDeviceBtn"
};

char *
XkbActionTypeText(unsigned type,unsigned format)
{
static char buf[32];
char *rtrn;

    if (type<=XkbSA_LastAction) {
	rtrn= actionTypeNames[type];
	if (format==XkbCFile) {
	    sprintf(buf,"XkbSA_%s",rtrn);
	    return buf;
	}
	return rtrn;
    }
    sprintf(buf,"Private");
    return buf;
}

/***====================================================================***/

static int
TryCopyStr(char *to,char *from,int *pLeft)
{
register int len;
    if (*pLeft>0) {
	len= strlen(from);
	if (len<((*pLeft)-3)) {
	    strcat(to,from);
	    *pLeft-= len;
	    return TRUE;
	}
    }
    *pLeft= -1;
    return FALSE;
}

/*ARGSUSED*/
static Bool
CopyNoActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int*sz)
{
    return TRUE;
}

static Bool
CopyModActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int* sz)
{
XkbModAction *	act;
unsigned	tmp;

    act= &action->mods;
    tmp= XkbModActionVMods(act);
    TryCopyStr(buf,"modifiers=",sz);
    if (act->flags&XkbSA_UseModMapMods)
	  TryCopyStr(buf,"modMapMods",sz);
    else if (act->real_mods || tmp) {
	 TryCopyStr(buf,
		     XkbVModMaskText(xkb,act->real_mods,tmp,XkbXKBFile),
		     sz);
    }
    else TryCopyStr(buf,"none",sz);
    if (act->type==XkbSA_LockMods)
	return TRUE;
    if (act->flags&XkbSA_ClearLocks)
	TryCopyStr(buf,",clearLocks",sz);
    if (act->flags&XkbSA_LatchToLock)
	TryCopyStr(buf,",latchToLock",sz);
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyGroupActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbGroupAction *	act;
char			tbuf[32];

    act= &action->group;
    TryCopyStr(buf,"group=",sz);
    if (act->flags&XkbSA_GroupAbsolute)
	 sprintf(tbuf,"%d",XkbSAGroup(act)+1);
    else if (XkbSAGroup(act)<0)
	 sprintf(tbuf,"%d",XkbSAGroup(act));
    else sprintf(tbuf,"+%d",XkbSAGroup(act));
    TryCopyStr(buf,tbuf,sz);
    if (act->type==XkbSA_LockGroup)
	return TRUE;
    if (act->flags&XkbSA_ClearLocks)
	TryCopyStr(buf,",clearLocks",sz);
    if (act->flags&XkbSA_LatchToLock)
	TryCopyStr(buf,",latchToLock",sz);
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyMovePtrArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
{
XkbPtrAction *	act;
int		x,y;
char		tbuf[32];

    act= &action->ptr;
    x= XkbPtrActionX(act);
    y= XkbPtrActionY(act);
    if ((act->flags&XkbSA_MoveAbsoluteX)||(x<0))
	 sprintf(tbuf,"x=%d",x);
    else sprintf(tbuf,"x=+%d",x);
    TryCopyStr(buf,tbuf,sz);

    if ((act->flags&XkbSA_MoveAbsoluteY)||(y<0))
	 sprintf(tbuf,",y=%d",y);
    else sprintf(tbuf,",y=+%d",y);
    TryCopyStr(buf,tbuf,sz);
    if (act->flags&XkbSA_NoAcceleration)
	TryCopyStr(buf,",!accel",sz);
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyPtrBtnArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
{
XkbPtrBtnAction *	act;
char			tbuf[32];

    act= &action->btn;
    TryCopyStr(buf,"button=",sz);
    if ((act->button>0)&&(act->button<6)) {
	 sprintf(tbuf,"%d",act->button);
	 TryCopyStr(buf,tbuf,sz);
    }
    else TryCopyStr(buf,"default",sz);
    if (act->count>0) {
	sprintf(tbuf,",count=%d",act->count);
	TryCopyStr(buf,tbuf,sz);
    }
    if (action->type==XkbSA_LockPtrBtn) {
	switch (act->flags&(XkbSA_LockNoUnlock|XkbSA_LockNoLock)) {
	    case XkbSA_LockNoLock:
		sprintf(tbuf,",affect=unlock"); break;
	    case XkbSA_LockNoUnlock:
		sprintf(tbuf,",affect=lock"); break;
	    case XkbSA_LockNoUnlock|XkbSA_LockNoLock:
		sprintf(tbuf,",affect=neither"); break;
	    default:
		sprintf(tbuf,",affect=both"); break;
	}
	TryCopyStr(buf,tbuf,sz);
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopySetPtrDfltArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbPtrDfltAction *	act;
char			tbuf[32];

    act= &action->dflt;
    if (act->affect==XkbSA_AffectDfltBtn) {
	TryCopyStr(buf,"affect=button,button=",sz);
	if ((act->flags&XkbSA_DfltBtnAbsolute)||(XkbSAPtrDfltValue(act)<0))
	     sprintf(tbuf,"%d",XkbSAPtrDfltValue(act));
	else sprintf(tbuf,"+%d",XkbSAPtrDfltValue(act));
	TryCopyStr(buf,tbuf,sz);
    }
    return TRUE;
}

static Bool
CopyISOLockArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
{
XkbISOAction *	act;
char		tbuf[64];

    act= &action->iso;
    if (act->flags&XkbSA_ISODfltIsGroup) {
	TryCopyStr(tbuf,"group=",sz);
	if (act->flags&XkbSA_GroupAbsolute)
	     sprintf(tbuf,"%d",XkbSAGroup(act)+1);
	else if (XkbSAGroup(act)<0)
	     sprintf(tbuf,"%d",XkbSAGroup(act));
	else sprintf(tbuf,"+%d",XkbSAGroup(act));
	TryCopyStr(buf,tbuf,sz);
    }
    else {
	unsigned tmp;
	tmp= XkbModActionVMods(act);
	TryCopyStr(buf,"modifiers=",sz);
	if (act->flags&XkbSA_UseModMapMods)
	     TryCopyStr(buf,"modMapMods",sz);
	else if (act->real_mods || tmp) {
	    if (act->real_mods) {
		TryCopyStr(buf,XkbModMaskText(act->real_mods,XkbXKBFile),sz);
		if (tmp)
		    TryCopyStr(buf,"+",sz);
	    }
	    if (tmp)
		TryCopyStr(buf,XkbVModMaskText(xkb,0,tmp,XkbXKBFile),sz);
	}
	else TryCopyStr(buf,"none",sz);
    }
    TryCopyStr(buf,",affect=",sz);
    if ((act->affect&XkbSA_ISOAffectMask)==0)
	TryCopyStr(buf,"all",sz);
    else {
	int nOut= 0;
	if ((act->affect&XkbSA_ISONoAffectMods)==0) {
	    TryCopyStr(buf,"mods",sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectGroup)==0) {
	    sprintf(tbuf,"%sgroups",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectPtr)==0) {
	    sprintf(tbuf,"%spointer",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectCtrls)==0) {
	    sprintf(tbuf,"%scontrols",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopySwitchScreenArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbSwitchScreenAction *	act;
char			tbuf[32];

    act= &action->screen;
    if ((act->flags&XkbSA_SwitchAbsolute)||(XkbSAScreen(act)<0))
	 sprintf(tbuf,"screen=%d",XkbSAScreen(act));
    else sprintf(tbuf,"screen=+%d",XkbSAScreen(act));
    TryCopyStr(buf,tbuf,sz);
    if (act->flags&XkbSA_SwitchApplication)
	 TryCopyStr(buf,",!same",sz);
    else TryCopyStr(buf,",same",sz);
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopySetLockControlsArgs(XkbDescPtr xkb,XkbAction *action,
							char *buf,int *sz)
{
XkbCtrlsAction *	act;
unsigned		tmp;
char			tbuf[32];

    act= &action->ctrls;
    tmp= XkbActionCtrls(act);
    TryCopyStr(buf,"controls=",sz);
    if (tmp==0)
	TryCopyStr(buf,"none",sz);
    else if ((tmp&XkbAllBooleanCtrlsMask)==XkbAllBooleanCtrlsMask)
	TryCopyStr(buf,"all",sz);
    else {
	int nOut= 0;
	if (tmp&XkbRepeatKeysMask) {
	    sprintf(tbuf,"%sRepeatKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbSlowKeysMask) {
	    sprintf(tbuf,"%sSlowKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbBounceKeysMask) {
	    sprintf(tbuf,"%sBounceKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbStickyKeysMask) {
	    sprintf(tbuf,"%sStickyKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbMouseKeysMask) {
	    sprintf(tbuf,"%sMouseKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbMouseKeysAccelMask) {
	    sprintf(tbuf,"%sMouseKeysAccel",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXKeysMask) {
	    sprintf(tbuf,"%sAccessXKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXTimeoutMask) {
	    sprintf(tbuf,"%sAccessXTimeout",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXFeedbackMask) {
	    sprintf(tbuf,"%sAccessXFeedback",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAudibleBellMask) {
	    sprintf(tbuf,"%sAudibleBell",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbOverlay1Mask) {
	    sprintf(tbuf,"%sOverlay1",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbOverlay2Mask) {
	    sprintf(tbuf,"%sOverlay2",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbIgnoreGroupLockMask) {
	    sprintf(tbuf,"%sIgnoreGroupLock",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyActionMessageArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbMessageAction *	act;
unsigned		all;
char			tbuf[32];

    act= &action->msg;
    all= XkbSA_MessageOnPress|XkbSA_MessageOnRelease;
    TryCopyStr(buf,"report=",sz);
    if ((act->flags&all)==0)
	TryCopyStr(buf,"none",sz);
    else if ((act->flags&all)==all)
	TryCopyStr(buf,"all",sz);
    else if (act->flags&XkbSA_MessageOnPress)
	 TryCopyStr(buf,"KeyPress",sz);
    else TryCopyStr(buf,"KeyRelease",sz);
    sprintf(tbuf,",data[0]=0x%02x",act->message[0]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[1]=0x%02x",act->message[1]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[2]=0x%02x",act->message[2]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[3]=0x%02x",act->message[3]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[4]=0x%02x",act->message[4]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[5]=0x%02x",act->message[5]); TryCopyStr(buf,tbuf,sz);
    return TRUE;
}

static Bool
CopyRedirectKeyArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbRedirectKeyAction *	act;
char			tbuf[32],*tmp;
unsigned		kc;
unsigned		vmods,vmods_mask;

    act= &action->redirect;
    kc= act->new_key;
    vmods= XkbSARedirectVMods(act);
    vmods_mask= XkbSARedirectVModsMask(act);
    if (xkb && xkb->names && xkb->names->keys && (kc<=xkb->max_key_code) &&
				(xkb->names->keys[kc].name[0]!='\0')) {
	char *kn;
	kn= XkbKeyNameText(xkb->names->keys[kc].name,XkbXKBFile);
	sprintf(tbuf,"key=%s",kn);
    }
    else sprintf(tbuf,"key=%d",kc);
    TryCopyStr(buf,tbuf,sz);
    if ((act->mods_mask==0)&&(vmods_mask==0))
	return TRUE;
    if ((act->mods_mask==XkbAllModifiersMask)&&
	(vmods_mask==XkbAllVirtualModsMask)) {
	tmp= XkbVModMaskText(xkb,act->mods,vmods,XkbXKBFile);
	TryCopyStr(buf,",mods=",sz);
	TryCopyStr(buf,tmp,sz);
    }
    else {
	if ((act->mods_mask&act->mods)||(vmods_mask&vmods)) {
	    tmp= XkbVModMaskText(xkb,act->mods_mask&act->mods,
					 vmods_mask&vmods,XkbXKBFile);
	    TryCopyStr(buf,",mods= ",sz);
	    TryCopyStr(buf,tmp,sz);
	}
	if ((act->mods_mask&(~act->mods))||(vmods_mask&(~vmods))) {
	    tmp= XkbVModMaskText(xkb,act->mods_mask&(~act->mods),
					 vmods_mask&(~vmods),XkbXKBFile);
	    TryCopyStr(buf,",clearMods= ",sz);
	    TryCopyStr(buf,tmp,sz);
	}
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyDeviceBtnArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbDeviceBtnAction *	act;
char			tbuf[32];

    act= &action->devbtn;
    sprintf(tbuf,"device= %d",act->device); TryCopyStr(buf,tbuf,sz);
    TryCopyStr(buf,",button=",sz);
    sprintf(tbuf,"%d",act->button);
    TryCopyStr(buf,tbuf,sz);
    if (act->count>0) {
	sprintf(tbuf,",count=%d",act->count);
	TryCopyStr(buf,tbuf,sz);
    }
    if (action->type==XkbSA_LockDeviceBtn) {
	switch (act->flags&(XkbSA_LockNoUnlock|XkbSA_LockNoLock)) {
	    case XkbSA_LockNoLock:
		sprintf(tbuf,",affect=unlock"); break;
	    case XkbSA_LockNoUnlock:
		sprintf(tbuf,",affect=lock"); break;
	    case XkbSA_LockNoUnlock|XkbSA_LockNoLock:
		sprintf(tbuf,",affect=neither"); break;
	    default:
		sprintf(tbuf,",affect=both"); break;
	}
	TryCopyStr(buf,tbuf,sz);
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyOtherArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
{
XkbAnyAction *	act;
char		tbuf[32];

    act= &action->any;
    sprintf(tbuf,"type=0x%02x",act->type); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[0]=0x%02x",act->data[0]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[1]=0x%02x",act->data[1]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[2]=0x%02x",act->data[2]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[3]=0x%02x",act->data[3]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[4]=0x%02x",act->data[4]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[5]=0x%02x",act->data[5]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[6]=0x%02x",act->data[6]); TryCopyStr(buf,tbuf,sz);
    return TRUE;
}

typedef	Bool	(*actionCopy)(
	XkbDescPtr 	/* xkb */,
	XkbAction *	/* action */,
	char *		/* buf */,
	int*		/* sz */
);
static actionCopy	copyActionArgs[XkbSA_NumActions] = {
	CopyNoActionArgs		/* NoAction	*/,
	CopyModActionArgs		/* SetMods	*/,
	CopyModActionArgs		/* LatchMods	*/,
	CopyModActionArgs		/* LockMods	*/,
	CopyGroupActionArgs		/* SetGroup	*/,
	CopyGroupActionArgs		/* LatchGroup	*/,
	CopyGroupActionArgs		/* LockGroup	*/,
	CopyMovePtrArgs			/* MovePtr	*/,
	CopyPtrBtnArgs			/* PtrBtn	*/,
	CopyPtrBtnArgs			/* LockPtrBtn	*/,
	CopySetPtrDfltArgs		/* SetPtrDflt	*/,
	CopyISOLockArgs			/* ISOLock	*/,
	CopyNoActionArgs		/* Terminate	*/,
	CopySwitchScreenArgs		/* SwitchScreen	*/,
	CopySetLockControlsArgs		/* SetControls	*/,
	CopySetLockControlsArgs		/* LockControls	*/,
	CopyActionMessageArgs		/* ActionMessage*/,
	CopyRedirectKeyArgs		/* RedirectKey	*/,
	CopyDeviceBtnArgs		/* DeviceBtn	*/,
	CopyDeviceBtnArgs		/* LockDeviceBtn*/
};

#define	ACTION_SZ	256

char *
XkbActionText(XkbDescPtr xkb,XkbAction *action,unsigned format)
{
char	buf[ACTION_SZ],*tmp;
int	sz;

    if (format==XkbCFile) {
	sprintf(buf,
	    "{ %20s, { 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x } }",
	    XkbActionTypeText(action->type,XkbCFile),
	    action->any.data[0],action->any.data[1],action->any.data[2],
	    action->any.data[3],action->any.data[4],action->any.data[5],
	    action->any.data[6]);
    }
    else {
	sprintf(buf,"%s(",XkbActionTypeText(action->type,XkbXKBFile));
	sz= ACTION_SZ-strlen(buf)+2; /* room for close paren and NULL */
	if (action->type<(unsigned)XkbSA_NumActions)
	     (*copyActionArgs[action->type])(xkb,action,buf,&sz);
	else CopyOtherArgs(xkb,action,buf,&sz);
	TryCopyStr(buf,")",&sz);
    }
    tmp= tbGetBuffer(strlen(buf)+1);
    if (tmp!=NULL)
	strcpy(tmp,buf);
    return tmp;
}

char *
XkbBehaviorText(XkbDescPtr xkb,XkbBehavior *behavior,unsigned format)
{
char	buf[256],*tmp;

    if (format==XkbCFile) {
	if (behavior->type==XkbKB_Default)
	     sprintf(buf,"{   0,    0 }");
	else sprintf(buf,"{ %3d, 0x%02x }",behavior->type,behavior->data);
    }
    else {
	unsigned 	type,permanent;
	type= behavior->type&XkbKB_OpMask;
	permanent=((behavior->type&XkbKB_Permanent)!=0);

	if (type==XkbKB_Lock) {
	    sprintf(buf,"lock= %s",(permanent?"Permanent":"TRUE"));
	}
	else if (type==XkbKB_RadioGroup) {
	    int 	g;
	    char	*tmp;
	    g= ((behavior->data)&(~XkbKB_RGAllowNone))+1;
	    if (XkbKB_RGAllowNone&behavior->data) {
		sprintf(buf,"allowNone,");
		tmp= &buf[strlen(buf)];
	    }
	    else tmp= buf;
	    if (permanent)
		 sprintf(tmp,"permanentRadioGroup= %d",g);
	    else sprintf(tmp,"radioGroup= %d",g);
	}
	else if ((type==XkbKB_Overlay1)||(type==XkbKB_Overlay2)) {
	    int ndx,kc;
	    char *kn;

	    ndx= ((type==XkbKB_Overlay1)?1:2);
	    kc= behavior->data;
	    if ((xkb)&&(xkb->names)&&(xkb->names->keys))
		kn= XkbKeyNameText(xkb->names->keys[kc].name,XkbXKBFile);
	    else {
		static char tbuf[8];
		sprintf(tbuf,"%d",kc);
		kn= tbuf;
	    }
	    if (permanent)
		 sprintf(buf,"permanentOverlay%d= %s",ndx,kn);
	    else sprintf(buf,"overlay%d= %s",ndx,kn);
	}
    }
    tmp= tbGetBuffer(strlen(buf)+1);
    if (tmp!=NULL)
	strcpy(tmp,buf);
    return tmp;
}

/***====================================================================***/

char *
XkbIndentText(unsigned size)
{
static char buf[32];
register int i;

    if (size>31)
	size= 31;

    for (i=0;i<size;i++) {
	buf[i]= ' ';
    }
    buf[size]= '\0';
    return buf;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/
/*

Copyright © 2008 Red Hat Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "os.h"
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#define	XK_CYRILLIC
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "eventstr.h"

#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "xkbgeom.h"
#include "xkb.h"

/***====================================================================***/

int
_XkbLookupAnyDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
		    Mask access_mode, int *xkb_err)
{
    int rc = XkbKeyboardErrorCode;

    if (id == XkbUseCoreKbd)
        id = PickKeyboard(client)->id;
    else if (id == XkbUseCorePtr)
        id = PickPointer(client)->id;

    rc = dixLookupDevice(pDev, id, client, access_mode);
    if (rc != Success)
	*xkb_err = XkbErr_BadDevice;

    return rc;
}

int
_XkbLookupKeyboard(DeviceIntPtr *pDev, int id, ClientPtr client,
		   Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    if (id == XkbDfltXIId)
        id = XkbUseCoreKbd;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
	return rc;

    dev = *pDev;
    if (!dev->key || !dev->key->xkbInfo) {
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupBellDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
		     Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
	return rc;

    dev = *pDev;
    if (!dev->kbdfeed && !dev->bell) {
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupLedDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
		    Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    if (id == XkbDfltXIId)
        id = XkbUseCorePtr;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
	return rc;

    dev = *pDev;
    if (!dev->kbdfeed && !dev->leds) {
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupButtonDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
		       Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
	return rc;

    dev = *pDev;
    if (!dev->button) {
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
    }
    return Success;
}

void
XkbSetActionKeyMods(XkbDescPtr xkb,XkbAction *act,unsigned mods)
{
register unsigned	tmp;

    switch (act->type) {
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (act->mods.flags&XkbSA_UseModMapMods)
		act->mods.real_mods= act->mods.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->mods))!=0)
		act->mods.mask|= XkbMaskForVMask(xkb,tmp);
	    break;
	case XkbSA_ISOLock:
	    if (act->iso.flags&XkbSA_UseModMapMods)
		act->iso.real_mods= act->iso.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->iso))!=0)
		act->iso.mask|= XkbMaskForVMask(xkb,tmp);
	    break;
    }
    return;
}

unsigned
XkbMaskForVMask(XkbDescPtr xkb,unsigned vmask)
{
register int i,bit;
register unsigned mask;
    
    for (mask=i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (vmask&bit)
	    mask|= xkb->server->vmods[i];
    }
    return mask;
}

/***====================================================================***/

void
XkbUpdateKeyTypesFromCore(	DeviceIntPtr	pXDev,
                                KeySymsPtr      pCore,
				KeyCode	 	first,
				CARD8	 	num,
				XkbChangesPtr	changes)
{
XkbDescPtr		xkb;
unsigned		key,nG,explicit;
int			types[XkbNumKbdGroups];
KeySym			tsyms[XkbMaxSymsPerKey],*syms;
XkbMapChangesPtr	mc;

    xkb= pXDev->key->xkbInfo->desc;
    if (first+num-1>xkb->max_key_code) {
	/* 1/12/95 (ef) -- XXX! should allow XKB structures to grow */
	num= xkb->max_key_code-first+1;
    }

    mc= (changes?(&changes->map):NULL);

    syms= &pCore->map[(first - pCore->minKeyCode) * pCore->mapWidth];
    for (key=first; key<(first+num); key++,syms+= pCore->mapWidth) {
        explicit= xkb->server->explicit[key]&XkbExplicitKeyTypesMask;
        types[XkbGroup1Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup1Index);
        types[XkbGroup2Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup2Index);
        types[XkbGroup3Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup3Index);
        types[XkbGroup4Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup4Index);
        nG= XkbKeyTypesForCoreSymbols(xkb,pCore->mapWidth,syms,explicit,types,
									tsyms);
	XkbChangeTypesOfKey(xkb,key,nG,XkbAllGroupsMask,types,mc);
	memcpy((char *)XkbKeySymsPtr(xkb,key),(char *)tsyms,
					XkbKeyNumSyms(xkb,key)*sizeof(KeySym));
    }
    if (changes->map.changed&XkbKeySymsMask) {
	CARD8 oldLast,newLast;
	oldLast = changes->map.first_key_sym+changes->map.num_key_syms-1;
	newLast = first+num-1;

	if (first<changes->map.first_key_sym)
	    changes->map.first_key_sym = first;
	if (oldLast>newLast)
	    newLast= oldLast;
	changes->map.num_key_syms = newLast-changes->map.first_key_sym+1;
    }
    else {
	changes->map.changed|= XkbKeySymsMask;
	changes->map.first_key_sym = first;
	changes->map.num_key_syms = num;
    }
    return;
}

void
XkbUpdateDescActions(	XkbDescPtr		xkb,
			KeyCode		 	first,
			CARD8		 	num,
			XkbChangesPtr	 	changes)
{
register unsigned	key;

    for (key=first;key<(first+num);key++) {
	XkbApplyCompatMapToKey(xkb,key,changes);
    }

    if (changes->map.changed&(XkbVirtualModMapMask|XkbModifierMapMask)) {
        unsigned char           newVMods[XkbNumVirtualMods];
        register  unsigned      bit,i;
        unsigned                present;

        memset(newVMods, 0, XkbNumVirtualMods);
        present= 0;
        for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
            if (xkb->server->vmodmap[key]==0)
                continue;
            for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
                if (bit&xkb->server->vmodmap[key]) {
                    present|= bit;
                    newVMods[i]|= xkb->map->modmap[key];
                }
            }
        }
        for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
            if ((bit&present)&&(newVMods[i]!=xkb->server->vmods[i])) {
                changes->map.changed|= XkbVirtualModsMask;
                changes->map.vmods|= bit;
                xkb->server->vmods[i]= newVMods[i];
            }
        }
    }
    if (changes->map.changed&XkbVirtualModsMask)
        XkbApplyVirtualModChanges(xkb,changes->map.vmods,changes);

    if (changes->map.changed&XkbKeyActionsMask) {
	CARD8 oldLast,newLast;
	oldLast= changes->map.first_key_act+changes->map.num_key_acts-1;
	newLast = first+num-1;

	if (first<changes->map.first_key_act)
	    changes->map.first_key_act = first;
	if (newLast>oldLast)
	    newLast= oldLast;
	changes->map.num_key_acts= newLast-changes->map.first_key_act+1;
    }
    else {
	changes->map.changed|= XkbKeyActionsMask;
	changes->map.first_key_act = first;
	changes->map.num_key_acts = num;
    }
    return;
}

void
XkbUpdateActions(	DeviceIntPtr	 	pXDev,
			KeyCode		 	first,
			CARD8		 	num,
			XkbChangesPtr	 	changes,
			unsigned *	 	needChecksRtrn,
			XkbEventCausePtr	cause)
{
XkbSrvInfoPtr		xkbi;
XkbDescPtr		xkb;
CARD8 *			repeat;

    if (needChecksRtrn)
	*needChecksRtrn= 0;
    xkbi= pXDev->key->xkbInfo;
    xkb= xkbi->desc;
    repeat= xkb->ctrls->per_key_repeat;

    /* before letting XKB do any changes, copy the current core values */
    if (pXDev->kbdfeed)
	memcpy(repeat,pXDev->kbdfeed->ctrl.autoRepeats,XkbPerKeyBitArraySize);

    XkbUpdateDescActions(xkb,first,num,changes);

    if ((pXDev->kbdfeed)&&
	(changes->ctrls.changed_ctrls&XkbPerKeyRepeatMask)) {
	/* now copy the modified changes back to core */
	memcpy(pXDev->kbdfeed->ctrl.autoRepeats,repeat, XkbPerKeyBitArraySize);
	if (pXDev->kbdfeed->CtrlProc)
	    (*pXDev->kbdfeed->CtrlProc)(pXDev, &pXDev->kbdfeed->ctrl);
    }
    return;
}

KeySymsPtr
XkbGetCoreMap(DeviceIntPtr keybd)
{
register int		key,tmp;
int			maxSymsPerKey, maxGroup1Width;
XkbDescPtr		xkb;
KeySymsPtr              syms;
int			maxNumberOfGroups;

    if (!keybd || !keybd->key || !keybd->key->xkbInfo)
	return NULL;

    xkb= keybd->key->xkbInfo->desc;
    maxSymsPerKey= maxGroup1Width= 0;
    maxNumberOfGroups = 0;

    /* determine sizes */
    for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
	if (XkbKeycodeInRange(xkb,key)) {
	    int	nGroups;
	    int	w;
	    nGroups= XkbKeyNumGroups(xkb,key);
	    tmp= 0;
	    if (nGroups>0) {
		if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup1Index))<=2)
		     tmp+= 2;
		else tmp+= w + 2;
                /* remember highest G1 width */
                if (w > maxGroup1Width)
                    maxGroup1Width = w;
	    }
	    if (nGroups>1) {
                if (tmp <= 2) {
		     if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup2Index))<2)
		          tmp+= 2;
		     else tmp+= w;
                } else {
                     if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup2Index))>2)
                          tmp+= w - 2;
                }
	    }
	    if (nGroups>2)
		tmp+= XkbKeyGroupWidth(xkb,key,XkbGroup3Index);
	    if (nGroups>3)
		tmp+= XkbKeyGroupWidth(xkb,key,XkbGroup4Index);
	    if (tmp>maxSymsPerKey)
		maxSymsPerKey= tmp;
            if (nGroups > maxNumberOfGroups)
		maxNumberOfGroups = nGroups;
	}
    }

    if (maxSymsPerKey <= 0)
        return NULL;

    syms = calloc(1, sizeof(*syms));
    if (!syms)
        return NULL;

    /* See Section 12.4 of the XKB Protocol spec. Because of the
     * single-group distribution for multi-group keyboards, we have to
     * have enough symbols for the largest group 1 to replicate across the
     * number of groups on the keyboard. e.g. a single-group key with 4
     * symbols on a keyboard that has 3 groups -> 12 syms per key */
    if (maxSymsPerKey < maxNumberOfGroups * maxGroup1Width)
        maxSymsPerKey = maxNumberOfGroups * maxGroup1Width;

    syms->mapWidth = maxSymsPerKey;
    syms->minKeyCode = xkb->min_key_code;
    syms->maxKeyCode = xkb->max_key_code;

    tmp = syms->mapWidth * (xkb->max_key_code - xkb->min_key_code + 1);
    syms->map = calloc(tmp, sizeof(*syms->map));
    if (!syms->map) {
        free(syms);
        return NULL;
    }

    for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
        KeySym *pCore,*pXKB;
        unsigned nGroups,groupWidth,n,nOut;

        nGroups= XkbKeyNumGroups(xkb,key);
        n= (key-xkb->min_key_code)*syms->mapWidth;
        pCore= &syms->map[n];
        pXKB= XkbKeySymsPtr(xkb,key);
        nOut= 2;
        if (nGroups>0) {
            groupWidth= XkbKeyGroupWidth(xkb,key,XkbGroup1Index);
            if (groupWidth>0)   pCore[0]= pXKB[0];
            if (groupWidth>1)   pCore[1]= pXKB[1];
            for (n=2;n<groupWidth;n++)
                pCore[2+n]= pXKB[n];
            if (groupWidth>2)
                nOut= groupWidth;
        }

	/* See XKB Protocol Sec, Section 12.4.
           A 1-group key with ABCDE on a 2 group keyboard must be
	   duplicated across all groups as ABABCDECDE.
	 */
	if (nGroups == 1)
	{
	    int idx, j;

	    groupWidth = XkbKeyGroupWidth(xkb, key, XkbGroup1Index);

	    /* AB..CDE... -> ABABCDE... */
	    if (groupWidth > 0 && syms->mapWidth >= 3)
	        pCore[2] = pCore[0];
	    if (groupWidth > 1 && syms->mapWidth >= 4)
	        pCore[3] = pCore[1];

	    /* ABABCDE... -> ABABCDECDE */
	    idx = 2 + groupWidth;
	    while (groupWidth > 2 && idx < syms->mapWidth &&
		   idx < groupWidth * 2)
	    {
		pCore[idx] = pCore[idx - groupWidth + 2];
		idx++;
	    }
	    idx = 2 * groupWidth;
	    if (idx < 4)
		idx = 4;
	    /* 3 or more groups: ABABCDECDEABCDEABCDE */
	    for (j = 3; j <= maxNumberOfGroups; j++)
		for (n = 0; n < groupWidth && idx < maxSymsPerKey; n++)
		    pCore[idx++] = pXKB[n];
	}

	pXKB+= XkbKeyGroupsWidth(xkb,key);
	nOut+= 2;
	if (nGroups>1) {
	    groupWidth= XkbKeyGroupWidth(xkb,key,XkbGroup2Index);
	    if (groupWidth>0)	pCore[2]= pXKB[0];
	    if (groupWidth>1)	pCore[3]= pXKB[1];
	    for (n=2;n<groupWidth;n++) {
		pCore[nOut+(n-2)]= pXKB[n];
	    }
	    if (groupWidth>2)
		nOut+= (groupWidth-2);
	}
	pXKB+= XkbKeyGroupsWidth(xkb,key);
	for (n=XkbGroup3Index;n<nGroups;n++) {
	    register int s;
	    groupWidth= XkbKeyGroupWidth(xkb,key,n);
	    for (s=0;s<groupWidth;s++) {
		pCore[nOut++]= pXKB[s];
	    }
	    pXKB+= XkbKeyGroupsWidth(xkb,key);
	}
    }

    return syms;
}

void
XkbSetRepeatKeys(DeviceIntPtr pXDev,int key,int onoff)
{
    if (pXDev && pXDev->key && pXDev->key->xkbInfo) {
	xkbControlsNotify	cn;
	XkbControlsPtr		ctrls = pXDev->key->xkbInfo->desc->ctrls;
	XkbControlsRec 		old;
	old = *ctrls;

	if (key== -1) {	/* global autorepeat setting changed */
	    if (onoff)	ctrls->enabled_ctrls |= XkbRepeatKeysMask;
	    else	ctrls->enabled_ctrls &= ~XkbRepeatKeysMask;
	}
	else if (pXDev->kbdfeed) {
	    ctrls->per_key_repeat[key/8] = 
		pXDev->kbdfeed->ctrl.autoRepeats[key/8];
	}
	
	if (XkbComputeControlsNotify(pXDev,&old,ctrls,&cn,TRUE))
	    XkbSendControlsNotify(pXDev,&cn);
    }
    return;
}

/* Applies a change to a single device, does not traverse the device tree. */
void
XkbApplyMappingChange(DeviceIntPtr kbd, KeySymsPtr map, KeyCode first_key,
                      CARD8 num_keys, CARD8 *modmap, ClientPtr client)
{
    XkbDescPtr xkb = kbd->key->xkbInfo->desc;
    XkbEventCauseRec cause;
    XkbChangesRec changes;
    unsigned int check;

    memset(&changes, 0, sizeof(changes));
    memset(&cause, 0, sizeof(cause));

    if (map && first_key && num_keys) {
        check = 0;
        XkbSetCauseCoreReq(&cause, X_ChangeKeyboardMapping, client);

        XkbUpdateKeyTypesFromCore(kbd, map, first_key, num_keys, &changes);
        XkbUpdateActions(kbd, first_key, num_keys, &changes, &check, &cause);

        if (check)
            XkbCheckSecondaryEffects(kbd->key->xkbInfo, 1, &changes, &cause);
    }

    if (modmap) {
        /* A keymap change can imply a modmap change, se we prefer the
         * former. */
        if (!cause.mjr)
            XkbSetCauseCoreReq(&cause,X_SetModifierMapping,client);

        check = 0;
        num_keys = xkb->max_key_code - xkb->min_key_code + 1;
        changes.map.changed |= XkbModifierMapMask;
        changes.map.first_modmap_key = xkb->min_key_code;
        changes.map.num_modmap_keys = num_keys;
        memcpy(kbd->key->xkbInfo->desc->map->modmap, modmap, MAP_LENGTH);
        XkbUpdateActions(kbd, xkb->min_key_code, num_keys, &changes, &check,
                         &cause);

        if (check)
            XkbCheckSecondaryEffects(kbd->key->xkbInfo, 1, &changes, &cause);
    }

    XkbSendNotification(kbd, &changes, &cause);
}

void
XkbDisableComputedAutoRepeats(DeviceIntPtr dev,unsigned key)
{
XkbSrvInfoPtr	xkbi = dev->key->xkbInfo;
xkbMapNotify	mn;

    xkbi->desc->server->explicit[key]|= XkbExplicitAutoRepeatMask;
    memset(&mn, 0, sizeof(mn));
    mn.changed= XkbExplicitComponentsMask;
    mn.firstKeyExplicit= key;
    mn.nKeyExplicit= 1;
    XkbSendMapNotify(dev,&mn);
    return;
}

unsigned
XkbStateChangedFlags(XkbStatePtr old,XkbStatePtr new)
{
int		changed;

    changed=(old->group!=new->group?XkbGroupStateMask:0);
    changed|=(old->base_group!=new->base_group?XkbGroupBaseMask:0);
    changed|=(old->latched_group!=new->latched_group?XkbGroupLatchMask:0);
    changed|=(old->locked_group!=new->locked_group?XkbGroupLockMask:0);
    changed|=(old->mods!=new->mods?XkbModifierStateMask:0);
    changed|=(old->base_mods!=new->base_mods?XkbModifierBaseMask:0);
    changed|=(old->latched_mods!=new->latched_mods?XkbModifierLatchMask:0);
    changed|=(old->locked_mods!=new->locked_mods?XkbModifierLockMask:0);
    changed|=(old->compat_state!=new->compat_state?XkbCompatStateMask:0);
    changed|=(old->grab_mods!=new->grab_mods?XkbGrabModsMask:0);
    if (old->compat_grab_mods!=new->compat_grab_mods)
	changed|= XkbCompatGrabModsMask;
    changed|=(old->lookup_mods!=new->lookup_mods?XkbLookupModsMask:0);
    if (old->compat_lookup_mods!=new->compat_lookup_mods)
	changed|= XkbCompatLookupModsMask;
    changed|=(old->ptr_buttons!=new->ptr_buttons?XkbPointerButtonMask:0);
    return changed;
}

static void
XkbComputeCompatState(XkbSrvInfoPtr xkbi)
{
CARD16 		grp_mask;
XkbStatePtr	state= &xkbi->state;
XkbCompatMapPtr	map;

    if (!state || !xkbi->desc || !xkbi->desc->ctrls || !xkbi->desc->compat)
        return;

    map= xkbi->desc->compat;
    grp_mask= map->groups[state->group].mask;
    state->compat_state = state->mods|grp_mask;
    state->compat_lookup_mods= state->lookup_mods|grp_mask;

    if (xkbi->desc->ctrls->enabled_ctrls&XkbIgnoreGroupLockMask)
	 grp_mask= map->groups[state->base_group].mask;
    state->compat_grab_mods= state->grab_mods|grp_mask;
    return;
}

unsigned
XkbAdjustGroup(int group,XkbControlsPtr ctrls)
{
unsigned	act;

    act= XkbOutOfRangeGroupAction(ctrls->groups_wrap);
    if (group<0) {
	while ( group < 0 )  {
	    if (act==XkbClampIntoRange) {
		group= XkbGroup1Index;
	    }
	    else if (act==XkbRedirectIntoRange) {
		int newGroup;
		newGroup= XkbOutOfRangeGroupNumber(ctrls->groups_wrap);
		if (newGroup>=ctrls->num_groups)
		     group= XkbGroup1Index;
		else group= newGroup;
	    }
	    else {
		group+= ctrls->num_groups;
	    }
	}
    }
    else if (group>=ctrls->num_groups) {
	if (act==XkbClampIntoRange) {
	    group= ctrls->num_groups-1;
	}
	else if (act==XkbRedirectIntoRange) {
	    int newGroup;
	    newGroup= XkbOutOfRangeGroupNumber(ctrls->groups_wrap);
	    if (newGroup>=ctrls->num_groups)
		 group= XkbGroup1Index;
	    else group= newGroup;
	}
	else {
	    group%= ctrls->num_groups;
	}
    }
    return group;
}

void
XkbComputeDerivedState(XkbSrvInfoPtr xkbi)
{
XkbStatePtr	state= &xkbi->state;
XkbControlsPtr	ctrls= xkbi->desc->ctrls;
unsigned char	grp;

    if (!state || !ctrls)
        return;

    state->mods= (state->base_mods|state->latched_mods|state->locked_mods);
    state->lookup_mods= state->mods&(~ctrls->internal.mask);
    state->grab_mods= state->lookup_mods&(~ctrls->ignore_lock.mask);
    state->grab_mods|= 
	((state->base_mods|state->latched_mods)&ctrls->ignore_lock.mask);


    grp= state->locked_group;
    if (grp>=ctrls->num_groups)
	state->locked_group= XkbAdjustGroup(XkbCharToInt(grp),ctrls);

    grp= state->locked_group+state->base_group+state->latched_group;
    if (grp>=ctrls->num_groups)
	 state->group= XkbAdjustGroup(XkbCharToInt(grp),ctrls);
    else state->group= grp;
    XkbComputeCompatState(xkbi);
    return;
}

/***====================================================================***/

void
XkbCheckSecondaryEffects(	XkbSrvInfoPtr		xkbi,
				unsigned		which,
				XkbChangesPtr 		changes,
				XkbEventCausePtr	cause)
{
    if (which&XkbStateNotifyMask) {
	XkbStateRec old;
	old= xkbi->state;
	changes->state_changes|= XkbStateChangedFlags(&old,&xkbi->state);
	XkbComputeDerivedState(xkbi);
    }
    if (which&XkbIndicatorStateNotifyMask)
	XkbUpdateIndicators(xkbi->device,XkbAllIndicatorsMask,TRUE,changes,
									cause);
    return;
}

/***====================================================================***/

Bool
XkbEnableDisableControls(	XkbSrvInfoPtr		xkbi,
				unsigned long		change,
				unsigned long		newValues,
				XkbChangesPtr		changes,
				XkbEventCausePtr	cause)
{
XkbControlsPtr		ctrls;
unsigned 		old;
XkbSrvLedInfoPtr	sli;

    ctrls= xkbi->desc->ctrls;
    old= ctrls->enabled_ctrls;
    ctrls->enabled_ctrls&= ~change;
    ctrls->enabled_ctrls|= (change&newValues);
    if (old==ctrls->enabled_ctrls)
	return FALSE;
    if (cause!=NULL) {
	xkbControlsNotify cn;
	cn.numGroups= ctrls->num_groups;
	cn.changedControls= XkbControlsEnabledMask;
	cn.enabledControls= ctrls->enabled_ctrls;
	cn.enabledControlChanges= (ctrls->enabled_ctrls^old);
	cn.keycode= cause->kc;
	cn.eventType= cause->event;
	cn.requestMajor= cause->mjr;
	cn.requestMinor= cause->mnr;
	XkbSendControlsNotify(xkbi->device,&cn);
    }
    else {
	/* Yes, this really should be an XOR.  If ctrls->enabled_ctrls_changes*/
	/* is non-zero, the controls in question changed already in "this" */
	/* request and this change merely undoes the previous one.  By the */
	/* same token, we have to figure out whether or not ControlsEnabled */
	/* should be set or not in the changes structure */
	changes->ctrls.enabled_ctrls_changes^= (ctrls->enabled_ctrls^old);
	if (changes->ctrls.enabled_ctrls_changes)
	     changes->ctrls.changed_ctrls|= XkbControlsEnabledMask;
	else changes->ctrls.changed_ctrls&= ~XkbControlsEnabledMask;
    }
    sli= XkbFindSrvLedInfo(xkbi->device,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(xkbi->device,sli->usesControls,TRUE,changes,cause);
    return TRUE;
}

/***====================================================================***/

#define	MAX_TOC	16

XkbGeometryPtr
XkbLookupNamedGeometry(DeviceIntPtr dev,Atom name,Bool *shouldFree)
{
XkbSrvInfoPtr	xkbi=	dev->key->xkbInfo;
XkbDescPtr	xkb=	xkbi->desc;

    *shouldFree= 0;
    if (name==None) {
	if (xkb->geom!=NULL)
	    return xkb->geom;
	name= xkb->names->geometry;
    }
    if ((xkb->geom!=NULL)&&(xkb->geom->name==name))
	return xkb->geom;
    *shouldFree= 1;
    return NULL;
}

void
XkbConvertCase(register KeySym sym, KeySym *lower, KeySym *upper)
{
    *lower = sym;
    *upper = sym;
    switch(sym >> 8) {
    case 0: /* Latin 1 */
	if ((sym >= XK_A) && (sym <= XK_Z))
	    *lower += (XK_a - XK_A);
	else if ((sym >= XK_a) && (sym <= XK_z))
	    *upper -= (XK_a - XK_A);
	else if ((sym >= XK_Agrave) && (sym <= XK_Odiaeresis))
	    *lower += (XK_agrave - XK_Agrave);
	else if ((sym >= XK_agrave) && (sym <= XK_odiaeresis))
	    *upper -= (XK_agrave - XK_Agrave);
	else if ((sym >= XK_Ooblique) && (sym <= XK_Thorn))
	    *lower += (XK_oslash - XK_Ooblique);
	else if ((sym >= XK_oslash) && (sym <= XK_thorn))
	    *upper -= (XK_oslash - XK_Ooblique);
	break;
    case 1: /* Latin 2 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym == XK_Aogonek)
	    *lower = XK_aogonek;
	else if (sym >= XK_Lstroke && sym <= XK_Sacute)
	    *lower += (XK_lstroke - XK_Lstroke);
	else if (sym >= XK_Scaron && sym <= XK_Zacute)
	    *lower += (XK_scaron - XK_Scaron);
	else if (sym >= XK_Zcaron && sym <= XK_Zabovedot)
	    *lower += (XK_zcaron - XK_Zcaron);
	else if (sym == XK_aogonek)
	    *upper = XK_Aogonek;
	else if (sym >= XK_lstroke && sym <= XK_sacute)
	    *upper -= (XK_lstroke - XK_Lstroke);
	else if (sym >= XK_scaron && sym <= XK_zacute)
	    *upper -= (XK_scaron - XK_Scaron);
	else if (sym >= XK_zcaron && sym <= XK_zabovedot)
	    *upper -= (XK_zcaron - XK_Zcaron);
	else if (sym >= XK_Racute && sym <= XK_Tcedilla)
	    *lower += (XK_racute - XK_Racute);
	else if (sym >= XK_racute && sym <= XK_tcedilla)
	    *upper -= (XK_racute - XK_Racute);
	break;
    case 2: /* Latin 3 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Hstroke && sym <= XK_Hcircumflex)
	    *lower += (XK_hstroke - XK_Hstroke);
	else if (sym >= XK_Gbreve && sym <= XK_Jcircumflex)
	    *lower += (XK_gbreve - XK_Gbreve);
	else if (sym >= XK_hstroke && sym <= XK_hcircumflex)
	    *upper -= (XK_hstroke - XK_Hstroke);
	else if (sym >= XK_gbreve && sym <= XK_jcircumflex)
	    *upper -= (XK_gbreve - XK_Gbreve);
	else if (sym >= XK_Cabovedot && sym <= XK_Scircumflex)
	    *lower += (XK_cabovedot - XK_Cabovedot);
	else if (sym >= XK_cabovedot && sym <= XK_scircumflex)
	    *upper -= (XK_cabovedot - XK_Cabovedot);
	break;
    case 3: /* Latin 4 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Rcedilla && sym <= XK_Tslash)
	    *lower += (XK_rcedilla - XK_Rcedilla);
	else if (sym >= XK_rcedilla && sym <= XK_tslash)
	    *upper -= (XK_rcedilla - XK_Rcedilla);
	else if (sym == XK_ENG)
	    *lower = XK_eng;
	else if (sym == XK_eng)
	    *upper = XK_ENG;
	else if (sym >= XK_Amacron && sym <= XK_Umacron)
	    *lower += (XK_amacron - XK_Amacron);
	else if (sym >= XK_amacron && sym <= XK_umacron)
	    *upper -= (XK_amacron - XK_Amacron);
	break;
    case 6: /* Cyrillic */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Serbian_DJE && sym <= XK_Serbian_DZE)
	    *lower -= (XK_Serbian_DJE - XK_Serbian_dje);
	else if (sym >= XK_Serbian_dje && sym <= XK_Serbian_dze)
	    *upper += (XK_Serbian_DJE - XK_Serbian_dje);
	else if (sym >= XK_Cyrillic_YU && sym <= XK_Cyrillic_HARDSIGN)
	    *lower -= (XK_Cyrillic_YU - XK_Cyrillic_yu);
	else if (sym >= XK_Cyrillic_yu && sym <= XK_Cyrillic_hardsign)
	    *upper += (XK_Cyrillic_YU - XK_Cyrillic_yu);
        break;
    case 7: /* Greek */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Greek_ALPHAaccent && sym <= XK_Greek_OMEGAaccent)
	    *lower += (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
	else if (sym >= XK_Greek_alphaaccent && sym <= XK_Greek_omegaaccent &&
		 sym != XK_Greek_iotaaccentdieresis &&
		 sym != XK_Greek_upsilonaccentdieresis)
	    *upper -= (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
	else if (sym >= XK_Greek_ALPHA && sym <= XK_Greek_OMEGA)
	    *lower += (XK_Greek_alpha - XK_Greek_ALPHA);
	else if (sym >= XK_Greek_alpha && sym <= XK_Greek_omega &&
		 sym != XK_Greek_finalsmallsigma)
	    *upper -= (XK_Greek_alpha - XK_Greek_ALPHA);
        break;
    }
}

static Bool
_XkbCopyClientMap(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;
    int i;
    XkbKeyTypePtr stype = NULL, dtype = NULL;

    /* client map */
    if (src->map) {
        if (!dst->map) {
            tmp = calloc(1, sizeof(XkbClientMapRec));
            if (!tmp)
                return FALSE;
            dst->map = tmp;
        }

        if (src->map->syms) {
            if (src->map->size_syms != dst->map->size_syms) {
                tmp = realloc(dst->map->syms,
                              src->map->size_syms * sizeof(KeySym));
                if (!tmp)
                    return FALSE;
                dst->map->syms = tmp;

            }
            memcpy(dst->map->syms, src->map->syms,
                   src->map->size_syms * sizeof(KeySym));
        }
        else {
            free(dst->map->syms);
            dst->map->syms = NULL;
        }
        dst->map->num_syms = src->map->num_syms;
        dst->map->size_syms = src->map->size_syms;

        if (src->map->key_sym_map) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->map->key_sym_map,
                              (src->max_key_code + 1) * sizeof(XkbSymMapRec));
                if (!tmp)
                    return FALSE;
                dst->map->key_sym_map = tmp;
            }
            memcpy(dst->map->key_sym_map, src->map->key_sym_map,
                   (src->max_key_code + 1) * sizeof(XkbSymMapRec));
        }
        else {
            free(dst->map->key_sym_map);
            dst->map->key_sym_map = NULL;
        }

        if (src->map->types && src->map->num_types) {
            if (src->map->num_types > dst->map->size_types ||
                !dst->map->types || !dst->map->size_types) {
                if (dst->map->types && dst->map->size_types) {
                    tmp = realloc(dst->map->types,
                                   src->map->num_types * sizeof(XkbKeyTypeRec));
                    if (!tmp)
                        return FALSE;
                    dst->map->types = tmp;
                    memset(dst->map->types + dst->map->num_types, 0,
                          (src->map->num_types - dst->map->num_types) *
                            sizeof(XkbKeyTypeRec));
                }
                else {
                    tmp = calloc(src->map->num_types, sizeof(XkbKeyTypeRec));
                    if (!tmp)
                        return FALSE;
                    dst->map->types = tmp;
                }
            }
            else if (src->map->num_types < dst->map->num_types &&
                     dst->map->types) {
                for (i = src->map->num_types, dtype = (dst->map->types + i);
                     i < dst->map->num_types; i++, dtype++) {
                    free(dtype->level_names);
                    dtype->level_names = NULL;
                    dtype->num_levels = 0;
                    if (dtype->map_count) {
                        free(dtype->map);
                        free(dtype->preserve);
                    }
                }
            }

            stype = src->map->types;
            dtype = dst->map->types;
            for (i = 0; i < src->map->num_types; i++, dtype++, stype++) {
                if (stype->num_levels && stype->level_names) {
                    if (stype->num_levels != dtype->num_levels &&
                        dtype->num_levels && dtype->level_names &&
                        i < dst->map->num_types) {
                        tmp = realloc(dtype->level_names,
                                       stype->num_levels * sizeof(Atom));
                        if (!tmp)
                            continue;
                        dtype->level_names = tmp;
                    }
                    else if (!dtype->num_levels || !dtype->level_names ||
                             i >= dst->map->num_types) {
                        tmp = malloc(stype->num_levels * sizeof(Atom));
                        if (!tmp)
                            continue;
                        dtype->level_names = tmp;
                    }
                    dtype->num_levels = stype->num_levels;
                    memcpy(dtype->level_names, stype->level_names,
                           stype->num_levels * sizeof(Atom));
                }
                else {
                    if (dtype->num_levels && dtype->level_names &&
                        i < dst->map->num_types)
                        free(dtype->level_names);
                    dtype->num_levels = 0;
                    dtype->level_names = NULL;
                }

                dtype->name = stype->name;
                memcpy(&dtype->mods, &stype->mods, sizeof(XkbModsRec));

                if (stype->map_count) {
                    if (stype->map) {
                        if (stype->map_count != dtype->map_count &&
                            dtype->map_count && dtype->map &&
                            i < dst->map->num_types) {
                            tmp = realloc(dtype->map,
                                           stype->map_count *
                                             sizeof(XkbKTMapEntryRec));
                            if (!tmp)
                                return FALSE;
                            dtype->map = tmp;
                        }
                        else if (!dtype->map_count || !dtype->map ||
                                 i >= dst->map->num_types) {
                            tmp = malloc(stype->map_count *
                                           sizeof(XkbKTMapEntryRec));
                            if (!tmp)
                                return FALSE;
                            dtype->map = tmp;
                        }

                        memcpy(dtype->map, stype->map,
                               stype->map_count * sizeof(XkbKTMapEntryRec));
                    }
                    else {
                        if (dtype->map && i < dst->map->num_types)
                            free(dtype->map);
                        dtype->map = NULL;
                    }

                    if (stype->preserve) {
                        if (stype->map_count != dtype->map_count &&
                            dtype->map_count && dtype->preserve &&
                            i < dst->map->num_types) {
                            tmp = realloc(dtype->preserve,
                                           stype->map_count *
                                             sizeof(XkbModsRec));
                            if (!tmp)
                                return FALSE;
                            dtype->preserve = tmp;
                        }
                        else if (!dtype->preserve || !dtype->map_count ||
                                 i >= dst->map->num_types) {
                            tmp = malloc(stype->map_count *
                                         sizeof(XkbModsRec));
                            if (!tmp)
                                return FALSE;
                            dtype->preserve = tmp;
                        }

                        memcpy(dtype->preserve, stype->preserve,
                               stype->map_count * sizeof(XkbModsRec));
                    }
                    else {
                        if (dtype->preserve && i < dst->map->num_types)
                            free(dtype->preserve);
                        dtype->preserve = NULL;
                    }

                    dtype->map_count = stype->map_count;
                }
                else {
                    if (dtype->map_count && i < dst->map->num_types) {
                        free(dtype->map);
                        free(dtype->preserve);
                    }
                    dtype->map_count = 0;
                    dtype->map = NULL;
                    dtype->preserve = NULL;
                }
            }

            dst->map->size_types = src->map->num_types;
            dst->map->num_types = src->map->num_types;
        }
        else {
            if (dst->map->types) {
                for (i = 0, dtype = dst->map->types; i < dst->map->num_types;
                     i++, dtype++) {
                    free(dtype->level_names);
                    if (dtype->map && dtype->map_count)
                        free(dtype->map);
                    if (dtype->preserve && dtype->map_count)
                        free(dtype->preserve);
                }
            }
            free(dst->map->types);
            dst->map->types = NULL;
            dst->map->num_types = 0;
            dst->map->size_types = 0;
        }

        if (src->map->modmap) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->map->modmap, src->max_key_code + 1);
                if (!tmp)
                    return FALSE;
                dst->map->modmap = tmp;
            }
            memcpy(dst->map->modmap, src->map->modmap, src->max_key_code + 1);
        }
        else {
            free(dst->map->modmap);
            dst->map->modmap = NULL;
        }
    }
    else {
        if (dst->map)
            XkbFreeClientMap(dst, XkbAllClientInfoMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyServerMap(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* server map */
    if (src->server) {
        if (!dst->server) {
            tmp = calloc(1, sizeof(XkbServerMapRec));
            if (!tmp)
                return FALSE;
            dst->server = tmp;
        }

        if (src->server->explicit) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->explicit, src->max_key_code + 1);
                if (!tmp)
                    return FALSE;
                dst->server->explicit = tmp;
            }
            memcpy(dst->server->explicit, src->server->explicit,
                   src->max_key_code + 1);
        }
        else {
            free(dst->server->explicit);
            dst->server->explicit = NULL;
        }

        if (src->server->acts) {
            if (src->server->size_acts != dst->server->size_acts) {
                tmp = realloc(dst->server->acts,
                              src->server->size_acts * sizeof(XkbAction));
                if (!tmp)
                    return FALSE;
                dst->server->acts = tmp;
            }
            memcpy(dst->server->acts, src->server->acts,
                   src->server->size_acts * sizeof(XkbAction));
        }
        else {
            free(dst->server->acts);
            dst->server->acts = NULL;
        }
       dst->server->size_acts = src->server->size_acts;
       dst->server->num_acts = src->server->num_acts;

        if (src->server->key_acts) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->key_acts,
                              (src->max_key_code + 1) * sizeof(unsigned short));
                if (!tmp)
                    return FALSE;
                dst->server->key_acts = tmp;
            }
            memcpy(dst->server->key_acts, src->server->key_acts,
                   (src->max_key_code + 1) * sizeof(unsigned short));
        }
        else {
            free(dst->server->key_acts);
            dst->server->key_acts = NULL;
        }

        if (src->server->behaviors) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->behaviors,
                              (src->max_key_code + 1) * sizeof(XkbBehavior));
                if (!tmp)
                    return FALSE;
                dst->server->behaviors = tmp;
            }
            memcpy(dst->server->behaviors, src->server->behaviors,
                   (src->max_key_code + 1) * sizeof(XkbBehavior));
        }
        else {
            free(dst->server->behaviors);
            dst->server->behaviors = NULL;
        }

        memcpy(dst->server->vmods, src->server->vmods, XkbNumVirtualMods);

        if (src->server->vmodmap) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->vmodmap,
                              (src->max_key_code + 1) * sizeof(unsigned short));
                if (!tmp)
                    return FALSE;
                dst->server->vmodmap = tmp;
            }
            memcpy(dst->server->vmodmap, src->server->vmodmap,
                   (src->max_key_code + 1) * sizeof(unsigned short));
        }
        else {
            free(dst->server->vmodmap);
            dst->server->vmodmap = NULL;
        }
    }
    else {
        if (dst->server)
            XkbFreeServerMap(dst, XkbAllServerInfoMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyNames(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* names */
    if (src->names) {
        if (!dst->names) {
            dst->names = calloc(1, sizeof(XkbNamesRec));
            if (!dst->names)
                return FALSE;
        }

        if (src->names->keys) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->names->keys,
                              (src->max_key_code + 1) * sizeof(XkbKeyNameRec));
                if (!tmp)
                    return FALSE;
                dst->names->keys = tmp;
            }
            memcpy(dst->names->keys, src->names->keys,
                   (src->max_key_code + 1) * sizeof(XkbKeyNameRec));
        }
        else {
            free(dst->names->keys);
            dst->names->keys = NULL;
        }

        if (src->names->num_key_aliases) {
            if (src->names->num_key_aliases != dst->names->num_key_aliases) {
                tmp = realloc(dst->names->key_aliases,
                              src->names->num_key_aliases *
                              sizeof(XkbKeyAliasRec));
                if (!tmp)
                    return FALSE;
                dst->names->key_aliases = tmp;
            }
            memcpy(dst->names->key_aliases, src->names->key_aliases,
                   src->names->num_key_aliases * sizeof(XkbKeyAliasRec));
        }
        else {
            free(dst->names->key_aliases);
            dst->names->key_aliases = NULL;
        }
        dst->names->num_key_aliases = src->names->num_key_aliases;

        if (src->names->num_rg) {
            if (src->names->num_rg != dst->names->num_rg) {
                tmp = realloc(dst->names->radio_groups,
                              src->names->num_rg * sizeof(Atom));
                if (!tmp)
                    return FALSE;
                dst->names->radio_groups = tmp;
            }
            memcpy(dst->names->radio_groups, src->names->radio_groups,
                   src->names->num_rg * sizeof(Atom));
        }
        else {
            free(dst->names->radio_groups);
        }
        dst->names->num_rg = src->names->num_rg;

        dst->names->keycodes = src->names->keycodes;
        dst->names->geometry = src->names->geometry;
        dst->names->symbols = src->names->symbols;
        dst->names->types = src->names->types;
        dst->names->compat = src->names->compat;
        dst->names->phys_symbols = src->names->phys_symbols;

        memcpy(dst->names->vmods, src->names->vmods,
               XkbNumVirtualMods * sizeof(Atom));
        memcpy(dst->names->indicators, src->names->indicators,
               XkbNumIndicators * sizeof(Atom));
        memcpy(dst->names->groups, src->names->groups,
               XkbNumKbdGroups * sizeof(Atom));
    }
    else {
        if (dst->names)
            XkbFreeNames(dst, XkbAllNamesMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyCompat(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* compat */
    if (src->compat) {
        if (!dst->compat) {
            dst->compat = calloc(1, sizeof(XkbCompatMapRec));
            if (!dst->compat)
                return FALSE;
        }

        if (src->compat->sym_interpret && src->compat->num_si) {
            if (src->compat->num_si != dst->compat->size_si) {
                tmp = realloc(dst->compat->sym_interpret,
                              src->compat->num_si * sizeof(XkbSymInterpretRec));
                if (!tmp)
                    return FALSE;
                dst->compat->sym_interpret = tmp;
            }
            memcpy(dst->compat->sym_interpret, src->compat->sym_interpret,
                   src->compat->num_si * sizeof(XkbSymInterpretRec));

            dst->compat->num_si = src->compat->num_si;
            dst->compat->size_si = src->compat->num_si;
        }
        else {
            if (dst->compat->sym_interpret && dst->compat->size_si)
                free(dst->compat->sym_interpret);

            dst->compat->sym_interpret = NULL;
            dst->compat->num_si = 0;
            dst->compat->size_si = 0;
        }

        memcpy(dst->compat->groups, src->compat->groups,
               XkbNumKbdGroups * sizeof(XkbModsRec));
    }
    else {
        if (dst->compat)
            XkbFreeCompatMap(dst, XkbAllCompatMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyGeom(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;
    int i = 0, j = 0, k = 0;
    XkbColorPtr scolor = NULL, dcolor = NULL;
    XkbDoodadPtr sdoodad = NULL, ddoodad = NULL;
    XkbOutlinePtr soutline = NULL, doutline = NULL;
    XkbPropertyPtr sprop = NULL, dprop = NULL;
    XkbRowPtr srow = NULL, drow = NULL;
    XkbSectionPtr ssection = NULL, dsection = NULL;
    XkbShapePtr sshape = NULL, dshape = NULL;

    /* geometry */
    if (src->geom) {
        if (!dst->geom) {
            dst->geom = calloc(sizeof(XkbGeometryRec), 1);
            if (!dst->geom)
                return FALSE;
        }

        /* properties */
        if (src->geom->num_properties) {
            /* If we've got more properties in the destination than
             * the source, run through and free all the excess ones
             * first. */
            if (src->geom->num_properties < dst->geom->sz_properties) {
                for (i = src->geom->num_properties, dprop = dst->geom->properties + i;
                     i < dst->geom->num_properties;
                     i++, dprop++) {
                    free(dprop->name);
                    free(dprop->value);
                }
            }

            /* Reallocate and clear all new items if the buffer grows. */
            if (!XkbGeomRealloc((void **)&dst->geom->properties, dst->geom->sz_properties, src->geom->num_properties,
                                sizeof(XkbPropertyRec), XKB_GEOM_CLEAR_EXCESS))
                return FALSE;
            /* We don't set num_properties as we need it to try and avoid
             * too much reallocing. */
            dst->geom->sz_properties = src->geom->num_properties;

            for (i = 0,
                  sprop = src->geom->properties,
                  dprop = dst->geom->properties;
                 i < src->geom->num_properties;
                 i++, sprop++, dprop++) {
                if (i < dst->geom->num_properties) {
                    if (strlen(sprop->name) != strlen(dprop->name)) {
                        tmp = realloc(dprop->name, strlen(sprop->name) + 1);
                        if (!tmp)
                            return FALSE;
                        dprop->name = tmp;
                    }
                    if (strlen(sprop->value) != strlen(dprop->value)) {
                        tmp = realloc(dprop->value, strlen(sprop->value) + 1);
                        if (!tmp)
                            return FALSE;
                        dprop->value = tmp;
                    }
                    strcpy(dprop->name, sprop->name);
                    strcpy(dprop->value, sprop->value);
                }
                else {
                    dprop->name = xstrdup(sprop->name);
                    dprop->value = xstrdup(sprop->value);
                }
            }

            /* ... which is already src->geom->num_properties. */
            dst->geom->num_properties = dst->geom->sz_properties;
        }
        else {
            if (dst->geom->sz_properties) {
                for (i = 0, dprop = dst->geom->properties;
                     i < dst->geom->num_properties;
                     i++, dprop++) {
                    free(dprop->name);
                    free(dprop->value);
                }
                free(dst->geom->properties);
                dst->geom->properties = NULL;
            }

            dst->geom->num_properties = 0;
            dst->geom->sz_properties = 0;
        }

        /* colors */
        if (src->geom->num_colors) {
            if (src->geom->num_colors < dst->geom->sz_colors) {
                for (i = src->geom->num_colors, dcolor = dst->geom->colors + i;
                     i < dst->geom->num_colors;
                     i++, dcolor++) {
                    free(dcolor->spec);
                }
            }

            /* Reallocate and clear all new items if the buffer grows. */
            if (!XkbGeomRealloc((void **)&dst->geom->colors, dst->geom->sz_colors, src->geom->num_colors,
                                sizeof(XkbColorRec), XKB_GEOM_CLEAR_EXCESS))
                return FALSE;
            dst->geom->sz_colors = src->geom->num_colors;

            for (i = 0,
                  scolor = src->geom->colors,
                  dcolor = dst->geom->colors;
                 i < src->geom->num_colors;
                 i++, scolor++, dcolor++) {
                if (i < dst->geom->num_colors) {
                    if (strlen(scolor->spec) != strlen(dcolor->spec)) {
                        tmp = realloc(dcolor->spec, strlen(scolor->spec) + 1);
                        if (!tmp)
                            return FALSE;
                        dcolor->spec = tmp;
                    }
                    strcpy(dcolor->spec, scolor->spec);
                }
                else {
                    dcolor->spec = xstrdup(scolor->spec);
                }
                dcolor->pixel = scolor->pixel;
            }

            dst->geom->num_colors = dst->geom->sz_colors;
        }
        else {
            if (dst->geom->sz_colors) {
                for (i = 0, dcolor = dst->geom->colors;
                     i < dst->geom->num_colors;
                     i++, dcolor++) {
                    free(dcolor->spec);
                }
                free(dst->geom->colors);
                dst->geom->colors = NULL;
            }

            dst->geom->num_colors = 0;
            dst->geom->sz_colors = 0;
        }

        /* shapes */
        /* shapes break down into outlines, which break down into points. */
        if (dst->geom->num_shapes) {
            for (i = 0, dshape = dst->geom->shapes;
                 i < dst->geom->num_shapes;
                 i++, dshape++) {
                for (j = 0, doutline = dshape->outlines;
                     j < dshape->num_outlines;
                     j++, doutline++) {
                    if (doutline->sz_points)
                        free(doutline->points);
                }

                if (dshape->sz_outlines) {
                    free(dshape->outlines);
                    dshape->outlines = NULL;
                }

                dshape->num_outlines = 0;
                dshape->sz_outlines = 0;
            }
        }

        if (src->geom->num_shapes) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc((void **)&dst->geom->shapes, dst->geom->sz_shapes, src->geom->num_shapes,
                                sizeof(XkbShapeRec), XKB_GEOM_CLEAR_ALL))
                return FALSE;

            for (i = 0, sshape = src->geom->shapes, dshape = dst->geom->shapes;
                 i < src->geom->num_shapes;
                 i++, sshape++, dshape++) {
                if (sshape->num_outlines) {
                    tmp = calloc(sshape->num_outlines, sizeof(XkbOutlineRec));
                    if (!tmp)
                        return FALSE;
                    dshape->outlines = tmp;
                    
                    for (j = 0,
                          soutline = sshape->outlines,
                          doutline = dshape->outlines;
                         j < sshape->num_outlines;
                         j++, soutline++, doutline++) {
                        if (soutline->num_points) {
                            tmp = malloc(soutline->num_points *
                                          sizeof(XkbPointRec));
                            if (!tmp)
                                return FALSE;
                            doutline->points = tmp;

                            memcpy(doutline->points, soutline->points,
                                   soutline->num_points * sizeof(XkbPointRec));

                            doutline->corner_radius = soutline->corner_radius;
                        }

                        doutline->num_points = soutline->num_points;
                        doutline->sz_points = soutline->num_points;
                    }
                }

                dshape->num_outlines = sshape->num_outlines;
                dshape->sz_outlines = sshape->num_outlines;
                dshape->name = sshape->name;
                dshape->bounds = sshape->bounds;

                dshape->approx = NULL;
                if (sshape->approx && sshape->num_outlines > 0) {

                    const ptrdiff_t approx_idx =
                            sshape->approx - sshape->outlines;

                    if (approx_idx < dshape->num_outlines) {
                            dshape->approx = dshape->outlines + approx_idx;
                    } else {
                            LogMessage(X_WARNING, "XKB: approx outline "
                                            "index is out of range\n");
                    }
                }

                dshape->primary = NULL;
                if (sshape->primary && sshape->num_outlines > 0) {

                    const ptrdiff_t primary_idx =
                            sshape->primary - sshape->outlines;

                    if (primary_idx < dshape->num_outlines) {
                            dshape->primary = dshape->outlines + primary_idx;
                    } else {
                            LogMessage(X_WARNING, "XKB: primary outline "
                                            "index is out of range\n");
                    }
                }
            }

            dst->geom->num_shapes = src->geom->num_shapes;
            dst->geom->sz_shapes = src->geom->num_shapes;
        }
        else {
            if (dst->geom->sz_shapes) {
                free(dst->geom->shapes);
            }
            dst->geom->shapes = NULL;
            dst->geom->num_shapes = 0;
            dst->geom->sz_shapes = 0;
        }

        /* sections */
        /* sections break down into doodads, and also into rows, which break
         * down into keys. */
        if (dst->geom->num_sections) {
            for (i = 0, dsection = dst->geom->sections;
                 i < dst->geom->num_sections;
                 i++, dsection++) {
                for (j = 0, drow = dsection->rows;
                     j < dsection->num_rows;
                     j++, drow++) {
                    if (drow->num_keys)
                        free(drow->keys);
                }

                if (dsection->num_rows)
                    free(dsection->rows);

                /* cut and waste from geom/doodad below. */
                for (j = 0, ddoodad = dsection->doodads;
                     j < dsection->num_doodads;
                     j++, ddoodad++) {
                    if (ddoodad->any.type == XkbTextDoodad) {
                        free(ddoodad->text.text);
                        ddoodad->text.text = NULL;
                        free(ddoodad->text.font);
                        ddoodad->text.font = NULL;
                     }
                     else if (ddoodad->any.type == XkbLogoDoodad) {
                         free(ddoodad->logo.logo_name);
                         ddoodad->logo.logo_name = NULL;
                    }
                }

                free(dsection->doodads);
            }

            dst->geom->num_sections = 0;
        }

        if (src->geom->num_sections) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc((void **)&dst->geom->sections, dst->geom->sz_sections, src->geom->num_sections,
                                sizeof(XkbSectionRec), XKB_GEOM_CLEAR_ALL))
                return FALSE;
            dst->geom->num_sections = src->geom->num_sections;
            dst->geom->sz_sections = src->geom->num_sections;

            for (i = 0,
                  ssection = src->geom->sections,
                  dsection = dst->geom->sections;
                 i < src->geom->num_sections;
                 i++, ssection++, dsection++) {
                *dsection = *ssection;
                if (ssection->num_rows) {
                    tmp = calloc(ssection->num_rows, sizeof(XkbRowRec));
                    if (!tmp)
                        return FALSE;
                    dsection->rows = tmp;
                }
                dsection->num_rows = ssection->num_rows;
                dsection->sz_rows = ssection->num_rows;

                for (j = 0, srow = ssection->rows, drow = dsection->rows;
                     j < ssection->num_rows;
                     j++, srow++, drow++) {
                    if (srow->num_keys) {
                        tmp = malloc(srow->num_keys * sizeof(XkbKeyRec));
                        if (!tmp)
                            return FALSE;
                        drow->keys = tmp;
                        memcpy(drow->keys, srow->keys,
                               srow->num_keys * sizeof(XkbKeyRec));
                    }
                    drow->num_keys = srow->num_keys;
                    drow->sz_keys = srow->num_keys;
                    drow->top = srow->top;
                    drow->left = srow->left;
                    drow->vertical = srow->vertical;
                    drow->bounds = srow->bounds;
                }

                if (ssection->num_doodads) {
                    tmp = calloc(ssection->num_doodads, sizeof(XkbDoodadRec));
                    if (!tmp)
                        return FALSE;
                    dsection->doodads = tmp;
                }
                else {
                    dsection->doodads = NULL;
                }

                dsection->sz_doodads = ssection->num_doodads;
                for (k = 0,
                      sdoodad = ssection->doodads,
                      ddoodad = dsection->doodads;
                     k < ssection->num_doodads;
                     k++, sdoodad++, ddoodad++) {
                    memcpy(ddoodad , sdoodad, sizeof(XkbDoodadRec));
                    if (sdoodad->any.type == XkbTextDoodad) {
                        if (sdoodad->text.text)
                            ddoodad->text.text =
                             strdup(sdoodad->text.text);
                        if (sdoodad->text.font)
                            ddoodad->text.font =
                             strdup(sdoodad->text.font);
                    }
                    else if (sdoodad->any.type == XkbLogoDoodad) {
                        if (sdoodad->logo.logo_name)
                            ddoodad->logo.logo_name =
                             strdup(sdoodad->logo.logo_name);
                    }
                }
                dsection->overlays = NULL;
                dsection->sz_overlays = 0;
                dsection->num_overlays = 0;
            }
        }
        else {
            if (dst->geom->sz_sections) {
                free(dst->geom->sections);
            }

            dst->geom->sections = NULL;
            dst->geom->num_sections = 0;
            dst->geom->sz_sections = 0;
        }

        /* doodads */
        if (dst->geom->num_doodads) {
            for (i = src->geom->num_doodads,
                  ddoodad = dst->geom->doodads +
                             src->geom->num_doodads;
                 i < dst->geom->num_doodads;
                 i++, ddoodad++) {
                 if (ddoodad->any.type == XkbTextDoodad) {
                     free(ddoodad->text.text);
                     ddoodad->text.text = NULL;
                     free(ddoodad->text.font);
                     ddoodad->text.font = NULL;
                 }
                 else if (ddoodad->any.type == XkbLogoDoodad) {
                     free(ddoodad->logo.logo_name);
                     ddoodad->logo.logo_name = NULL;
                }
            }
            dst->geom->num_doodads = 0;
        }

        if (src->geom->num_doodads) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc((void **)&dst->geom->doodads, dst->geom->sz_doodads, src->geom->num_doodads,
                                sizeof(XkbDoodadRec), XKB_GEOM_CLEAR_ALL))
                return FALSE;

            dst->geom->sz_doodads = src->geom->num_doodads;

            for (i = 0,
                  sdoodad = src->geom->doodads,
                  ddoodad = dst->geom->doodads;
                 i < src->geom->num_doodads;
                 i++, sdoodad++, ddoodad++) {
                memcpy(ddoodad , sdoodad, sizeof(XkbDoodadRec));
                if (sdoodad->any.type == XkbTextDoodad) {
                    if (sdoodad->text.text)
                        ddoodad->text.text = strdup(sdoodad->text.text);
                    if (sdoodad->text.font)
                        ddoodad->text.font = strdup(sdoodad->text.font);
                }
                else if (sdoodad->any.type == XkbLogoDoodad) {
                    if (sdoodad->logo.logo_name)
                        ddoodad->logo.logo_name =
                          strdup(sdoodad->logo.logo_name);
                }
            }

            dst->geom->num_doodads = dst->geom->sz_doodads;
        }
        else {
            if (dst->geom->sz_doodads) {
                free(dst->geom->doodads);
            }

            dst->geom->doodads = NULL;
            dst->geom->num_doodads = 0;
            dst->geom->sz_doodads = 0;
        }

        /* key aliases */
        if (src->geom->num_key_aliases) {
            /* Reallocate but don't clear any items. There is no need
             * to clear anything because data is immediately copied
             * over the whole memory area with memcpy. */
            if (!XkbGeomRealloc((void **)&dst->geom->key_aliases, dst->geom->sz_key_aliases, src->geom->num_key_aliases,
                                2 * XkbKeyNameLength, XKB_GEOM_CLEAR_NONE))
                return FALSE;

            dst->geom->sz_key_aliases = src->geom->num_key_aliases;

            memcpy(dst->geom->key_aliases, src->geom->key_aliases,
                   src->geom->num_key_aliases * 2 * XkbKeyNameLength);

            dst->geom->num_key_aliases = dst->geom->sz_key_aliases;
        }
        else {
            free(dst->geom->key_aliases);
            dst->geom->key_aliases = NULL;
            dst->geom->num_key_aliases = 0;
            dst->geom->sz_key_aliases = 0;
        }
        
        /* font */
        if (src->geom->label_font) {
            if (!dst->geom->label_font) {
                tmp = malloc(strlen(src->geom->label_font) + 1);
                if (!tmp)
                    return FALSE;
                dst->geom->label_font = tmp;
            }
            else if (strlen(src->geom->label_font) !=
                strlen(dst->geom->label_font)) {
                tmp = realloc(dst->geom->label_font,
                               strlen(src->geom->label_font) + 1);
                if (!tmp)
                    return FALSE;
                dst->geom->label_font = tmp;
            }

            strcpy(dst->geom->label_font, src->geom->label_font);
            i = XkbGeomColorIndex(src->geom, src->geom->label_color);
            dst->geom->label_color = &(dst->geom->colors[i]);
            i = XkbGeomColorIndex(src->geom, src->geom->base_color);
            dst->geom->base_color = &(dst->geom->colors[i]);
        }
        else {
            free(dst->geom->label_font);
            dst->geom->label_font = NULL;
            dst->geom->label_color = NULL;
            dst->geom->base_color = NULL;
        }

        dst->geom->name = src->geom->name;
        dst->geom->width_mm = src->geom->width_mm;
        dst->geom->height_mm = src->geom->height_mm;
    }
    else
    {
        if (dst->geom) {
            /* I LOVE THE DIFFERENT CALL SIGNATURE.  REALLY, I DO. */
            XkbFreeGeometry(dst->geom, XkbGeomAllMask, TRUE);
            dst->geom = NULL;
        }
    }

    return TRUE;
}

static Bool
_XkbCopyIndicators(XkbDescPtr src, XkbDescPtr dst)
{
    /* indicators */
    if (src->indicators) {
        if (!dst->indicators) {
            dst->indicators = malloc(sizeof(XkbIndicatorRec));
            if (!dst->indicators)
                return FALSE;
        }
        memcpy(dst->indicators, src->indicators, sizeof(XkbIndicatorRec));
    }
    else {
        free(dst->indicators);
        dst->indicators = NULL;
    }
    return TRUE;
}

static Bool
_XkbCopyControls(XkbDescPtr src, XkbDescPtr dst)
{
    /* controls */
    if (src->ctrls) {
        if (!dst->ctrls) {
            dst->ctrls = malloc(sizeof(XkbControlsRec));
            if (!dst->ctrls)
                return FALSE;
        }
        memcpy(dst->ctrls, src->ctrls, sizeof(XkbControlsRec));
    }
    else {
        free(dst->ctrls);
        dst->ctrls = NULL;
    }
    return TRUE;
}

/**
 * Copy an XKB map from src to dst, reallocating when necessary: if some
 * map components are present in one, but not in the other, the destination
 * components will be allocated or freed as necessary.
 *
 * Basic map consistency is assumed on both sides, so maps with random
 * uninitialised data (e.g. names->radio_grous == NULL, names->num_rg == 19)
 * _will_ cause failures.  You've been warned.
 *
 * Returns TRUE on success, or FALSE on failure.  If this function fails,
 * dst may be in an inconsistent state: all its pointers are guaranteed
 * to remain valid, but part of the map may be from src and part from dst.
 *
 */

Bool
XkbCopyKeymap(XkbDescPtr dst, XkbDescPtr src)
{

    if (!src || !dst) {
        DebugF("XkbCopyKeymap: src (%p) or dst (%p) is NULL\n", src, dst);
        return FALSE;
    }

    if (src == dst)
        return TRUE;

    if (!_XkbCopyClientMap(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy client map\n");
        return FALSE;
    }
    if (!_XkbCopyServerMap(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy server map\n");
        return FALSE;
    }
    if (!_XkbCopyIndicators(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy indicators\n");
        return FALSE;
    }
    if (!_XkbCopyControls(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy controls\n");
        return FALSE;
    }
    if (!_XkbCopyNames(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy names\n");
        return FALSE;
    }
    if (!_XkbCopyCompat(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy compat map\n");
        return FALSE;
    }
    if (!_XkbCopyGeom(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy geometry\n");
        return FALSE;
    }

    dst->min_key_code = src->min_key_code;
    dst->max_key_code = src->max_key_code;

    return TRUE;
}

Bool
XkbCopyDeviceKeymap(DeviceIntPtr dst, DeviceIntPtr src)
{
    xkbNewKeyboardNotify nkn;
    Bool ret;

    if (!dst->key || !src->key)
        return FALSE;

    memset(&nkn, 0, sizeof(xkbNewKeyboardNotify));
    nkn.oldMinKeyCode = dst->key->xkbInfo->desc->min_key_code;
    nkn.oldMaxKeyCode = dst->key->xkbInfo->desc->max_key_code;
    nkn.deviceID = dst->id;
    nkn.oldDeviceID = dst->id; /* maybe src->id? */
    nkn.minKeyCode = src->key->xkbInfo->desc->min_key_code;
    nkn.maxKeyCode = src->key->xkbInfo->desc->max_key_code;
    nkn.requestMajor = XkbReqCode;
    nkn.requestMinor = X_kbSetMap; /* Near enough's good enough. */
    nkn.changed = XkbNKN_KeycodesMask;
    if (src->key->xkbInfo->desc->geom)
        nkn.changed |= XkbNKN_GeometryMask;

    ret = XkbCopyKeymap(dst->key->xkbInfo->desc, src->key->xkbInfo->desc);
    if (ret)
        XkbSendNewKeyboardNotify(dst, &nkn);

    return ret;
}

int
XkbGetEffectiveGroup(XkbSrvInfoPtr xkbi, XkbStatePtr xkbState, CARD8 keycode)
{
    XkbDescPtr xkb = xkbi->desc;
    int effectiveGroup = xkbState->group;

    if (!XkbKeycodeInRange(xkb, keycode))
        return -1;

    if (effectiveGroup == XkbGroup1Index)
        return effectiveGroup;

    if (XkbKeyNumGroups(xkb,keycode) > 1U) {
        if (effectiveGroup >= XkbKeyNumGroups(xkb,keycode)) {
            unsigned int gi = XkbKeyGroupInfo(xkb,keycode);
            switch (XkbOutOfRangeGroupAction(gi)) {
                default:
                case XkbWrapIntoRange:
                    effectiveGroup %= XkbKeyNumGroups(xkb, keycode);
                    break;
                case XkbClampIntoRange:
                    effectiveGroup = XkbKeyNumGroups(xkb, keycode) - 1;
                    break;
                case XkbRedirectIntoRange:
                    effectiveGroup = XkbOutOfRangeGroupInfo(gi);
                    if (effectiveGroup >= XkbKeyNumGroups(xkb, keycode))
                        effectiveGroup = 0;
                    break;
            }
        }
    }
    else effectiveGroup = XkbGroup1Index;

    return effectiveGroup;
}

/* Merge the lockedPtrButtons from all attached SDs for the given master
 * device into the MD's state.
 */
void
XkbMergeLockedPtrBtns(DeviceIntPtr master)
{
    DeviceIntPtr d = inputInfo.devices;
    XkbSrvInfoPtr xkbi = NULL;

    if (!IsMaster(master))
        return;

    if (!master->key)
        return;

    xkbi = master->key->xkbInfo;
    xkbi->lockedPtrButtons = 0;

    for (; d; d = d->next) {
        if (IsMaster(d) || GetMaster(d, MASTER_KEYBOARD) != master || !d->key)
            continue;

        xkbi->lockedPtrButtons |= d->key->xkbInfo->lockedPtrButtons;
    }
}
/************************************************************
 Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>

#include <X11/Xos.h>
#include <X11/Xfuncs.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XKMformat.h>
#include "misc.h"
#include "inputstr.h"
#include "xkbstr.h"
#include "xkbsrv.h"
#include "xkbgeom.h"

Atom
XkbInternAtom(char *str,Bool only_if_exists)
{
    if (str==NULL)
	return None;
    return MakeAtom(str,strlen(str),!only_if_exists);
}

/***====================================================================***/

static void *
XkmInsureSize(void *oldPtr,int oldCount,int *newCountRtrn,int elemSize)
{
int	newCount= *newCountRtrn;

    if (oldPtr==NULL) {
	if (newCount==0)
	    return NULL;
	oldPtr= calloc(newCount,elemSize);
    }
    else if (oldCount<newCount) {
	oldPtr= realloc(oldPtr,newCount*elemSize);
	if (oldPtr!=NULL) {
	    char *tmp= (char *)oldPtr;
	    memset(&tmp[oldCount*elemSize], 0, (newCount-oldCount)*elemSize);
	}
    }
    else if (newCount<oldCount) {
	*newCountRtrn= oldCount;
    }
    return oldPtr;
}

#define	XkmInsureTypedSize(p,o,n,t) ((p)=((t *)XkmInsureSize((char *)(p),(o),(n),sizeof(t))))

static CARD8
XkmGetCARD8(FILE *file,int *pNRead)
{
int	tmp;
    tmp= getc(file);
    if (pNRead&&(tmp!=EOF))
	(*pNRead)+= 1;
    return tmp;
}

static CARD16
XkmGetCARD16(FILE *file,int *pNRead)
{
CARD16		val;

    if ((fread(&val,2,1,file)==1)&&(pNRead))
	(*pNRead)+= 2;
    return val;
}

static CARD32
XkmGetCARD32(FILE *file,int *pNRead)
{
CARD32	val;

    if ((fread(&val,4,1,file)==1)&&(pNRead))
	(*pNRead)+= 4;
    return val;
}

static int
XkmSkipPadding(FILE *file,unsigned pad)
{
register int	i,nRead=0;

    for (i=0;i<pad;i++) {
	if (getc(file)!=EOF)
	    nRead++;
    }
    return nRead;
}

static int
XkmGetCountedString(FILE *file,char *str,int max_len)
{
int	count,nRead=0;

    count= XkmGetCARD16(file,&nRead);
    if (count>0) {
	int tmp;
	if (count>max_len) {
	    tmp= fread(str,1,max_len,file);
	    while (tmp<count) {
		if ((getc(file))!=EOF)
		     tmp++;
		else break;
	    }
	}
	else {
	    tmp= fread(str,1,count,file);
	}
	nRead+= tmp;
    }
    if (count>=max_len)	str[max_len-1]= '\0';
    else		str[count]= '\0';
    count= XkbPaddedSize(nRead)-nRead;
    if (count>0)
	nRead+= XkmSkipPadding(file,count);
    return nRead;
}

/***====================================================================***/

static int
ReadXkmVirtualMods(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register unsigned int i,bit;
unsigned int	bound,named,tmp;
int		nRead=0;

    if (XkbAllocServerMap(xkb,XkbVirtualModsMask,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmVirtualMods",0);
	return -1;
    }
    bound= XkmGetCARD16(file,&nRead);
    named= XkmGetCARD16(file,&nRead);
    for (i=tmp=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (bound&bit) {
	    xkb->server->vmods[i]= XkmGetCARD8(file,&nRead);
	    if (changes)
		changes->map.vmods|= bit;
	    tmp++;
	}
    }
    if ((i= XkbPaddedSize(tmp)-tmp)>0)
	nRead+= XkmSkipPadding(file,i);
    if (XkbAllocNames(xkb,XkbVirtualModNamesMask,0,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmVirtualMods",0);
	return -1;
    }
    for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	char name[100];
	if (named&bit) {
	    if (nRead+=XkmGetCountedString(file,name,100)) {
		xkb->names->vmods[i]= XkbInternAtom(name,FALSE);
		if (changes)
		    changes->names.changed_vmods|= bit;
	    }
	}
    }
    return nRead;
}

/***====================================================================***/

static int
ReadXkmKeycodes(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register int	i;
unsigned	minKC,maxKC,nAl;
int		nRead=0;
char 		name[100];
XkbKeyNamePtr	pN;

    name[0]= '\0';
    nRead+= XkmGetCountedString(file,name,100);
    minKC= XkmGetCARD8(file,&nRead);
    maxKC= XkmGetCARD8(file,&nRead);
    if (xkb->min_key_code==0) {
	xkb->min_key_code= minKC;
	xkb->max_key_code= maxKC;
    }
    else {
	if (minKC<xkb->min_key_code)
	    xkb->min_key_code= minKC;
	if (maxKC>xkb->max_key_code) {
	    _XkbLibError(_XkbErrBadValue,"ReadXkmKeycodes",maxKC);
	    return -1;
	}
    }
    nAl= XkmGetCARD8(file,&nRead);
    nRead+= XkmSkipPadding(file,1);

#define WANTED (XkbKeycodesNameMask|XkbKeyNamesMask|XkbKeyAliasesMask)
    if (XkbAllocNames(xkb,WANTED,0,nAl)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmKeycodes",0);
	return -1;
    }
    if (name[0]!='\0') {
	xkb->names->keycodes= XkbInternAtom(name,FALSE);
    }

    for (pN=&xkb->names->keys[minKC],i=minKC;i<=(int)maxKC;i++,pN++) {
	if (fread(pN,1,XkbKeyNameLength,file)!=XkbKeyNameLength) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmKeycodes",0);
	    return -1;
	}
	nRead+= XkbKeyNameLength;
    }
    if (nAl>0) {
	XkbKeyAliasPtr	pAl;
	for (pAl= xkb->names->key_aliases,i=0;i<nAl;i++,pAl++) {
	    int tmp;
	    tmp= fread(pAl,1,2*XkbKeyNameLength,file);
	    if (tmp!=2*XkbKeyNameLength) {
		_XkbLibError(_XkbErrBadLength,"ReadXkmKeycodes",0);
		return -1;
	    }
	    nRead+= 2*XkbKeyNameLength;
	}
	if (changes)
	    changes->names.changed|= XkbKeyAliasesMask;
    }
    if (changes)
	changes->names.changed|= XkbKeyNamesMask;
    return nRead;
}

/***====================================================================***/

static int
ReadXkmKeyTypes(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register unsigned	i,n;
unsigned		num_types;
int			nRead=0;
int			tmp;
XkbKeyTypePtr		type;
xkmKeyTypeDesc		wire;
XkbKTMapEntryPtr	entry;
xkmKTMapEntryDesc	wire_entry;
char 			buf[100];

    if ((tmp= XkmGetCountedString(file,buf,100))<1) {
	_XkbLibError(_XkbErrBadLength,"ReadXkmKeyTypes",0);
	return -1;
    }	
    nRead+= tmp;
    if (buf[0]!='\0') {
	if (XkbAllocNames(xkb,XkbTypesNameMask,0,0)!=Success) {
	    _XkbLibError(_XkbErrBadAlloc,"ReadXkmKeyTypes",0);
	    return -1;
        }
	xkb->names->types= XkbInternAtom(buf,FALSE);
    }
    num_types= XkmGetCARD16(file,&nRead);
    nRead+= XkmSkipPadding(file,2);
    if (num_types<1)
	return nRead;
    if (XkbAllocClientMap(xkb,XkbKeyTypesMask,num_types)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmKeyTypes",0);
	return nRead;
    }
    xkb->map->num_types= num_types;
    if (num_types<XkbNumRequiredTypes) {
	_XkbLibError(_XkbErrMissingReqTypes,"ReadXkmKeyTypes",0);
	return -1;
    }
    type= xkb->map->types;
    for (i=0;i<num_types;i++,type++) {
	if ((int)fread(&wire,SIZEOF(xkmKeyTypeDesc),1,file)<1) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmKeyTypes",0);
	    return -1;
	}
	nRead+= SIZEOF(xkmKeyTypeDesc);
	if (((i==XkbOneLevelIndex)&&(wire.numLevels!=1))||
	    (((i==XkbTwoLevelIndex)||(i==XkbAlphabeticIndex)||
	     ((i)==XkbKeypadIndex))&&(wire.numLevels!=2))) {
	    _XkbLibError(_XkbErrBadTypeWidth,"ReadXkmKeyTypes",i);
	    return -1;
	}
	tmp= wire.nMapEntries;
	XkmInsureTypedSize(type->map,type->map_count,&tmp,XkbKTMapEntryRec);
	if ((wire.nMapEntries>0)&&(type->map==NULL)) {
	    _XkbLibError(_XkbErrBadValue,"ReadXkmKeyTypes",wire.nMapEntries);
	    return -1;
	}
	for (n=0,entry= type->map;n<wire.nMapEntries;n++,entry++) {
	    if (fread(&wire_entry,SIZEOF(xkmKTMapEntryDesc),1,file)<(int)1) {
		_XkbLibError(_XkbErrBadLength,"ReadXkmKeyTypes",0);
		return -1;
	    }
	    nRead+= SIZEOF(xkmKTMapEntryDesc);
	    entry->active= (wire_entry.virtualMods==0);
	    entry->level= wire_entry.level;
	    entry->mods.mask= wire_entry.realMods;
	    entry->mods.real_mods= wire_entry.realMods;
	    entry->mods.vmods= wire_entry.virtualMods;
	}
	nRead+= XkmGetCountedString(file,buf,100);
	if (((i==XkbOneLevelIndex)&&(strcmp(buf,"ONE_LEVEL")!=0))||
	    ((i==XkbTwoLevelIndex)&&(strcmp(buf,"TWO_LEVEL")!=0))||
	    ((i==XkbAlphabeticIndex)&&(strcmp(buf,"ALPHABETIC")!=0))||
	    ((i==XkbKeypadIndex)&&(strcmp(buf,"KEYPAD")!=0))) {
	   _XkbLibError(_XkbErrBadTypeName,"ReadXkmKeyTypes",0);
	   return -1;
	}
	if (buf[0]!='\0') {
	     type->name= XkbInternAtom(buf,FALSE);
	}
	else type->name= None;

	if (wire.preserve) {
	    xkmModsDesc	p_entry;
	    XkbModsPtr	pre;
	    XkmInsureTypedSize(type->preserve,type->map_count,&tmp,
						XkbModsRec);
	    if (type->preserve==NULL) {
		_XkbLibError(_XkbErrBadMatch,"ReadXkmKeycodes",0);
		return -1;
	    }
	    for (n=0,pre=type->preserve;n<wire.nMapEntries;n++,pre++) {
		if (fread(&p_entry,SIZEOF(xkmModsDesc),1,file)<1) {
		    _XkbLibError(_XkbErrBadLength,"ReadXkmKeycodes",0);
		    return -1;
		}
		nRead+= SIZEOF(xkmModsDesc);
		pre->mask= p_entry.realMods;
		pre->real_mods= p_entry.realMods;
		pre->vmods= p_entry.virtualMods;
	    }
	}
	if (wire.nLevelNames>0) {
	    int width= wire.numLevels;
	    if (wire.nLevelNames>(unsigned)width) {
		_XkbLibError(_XkbErrBadMatch,"ReadXkmKeycodes",0);
		return -1;
	    }
	    XkmInsureTypedSize(type->level_names,type->num_levels,&width,Atom);
	    if (type->level_names!=NULL) {
		for (n=0;n<wire.nLevelNames;n++) {
		    if ((tmp=XkmGetCountedString(file,buf,100))<1)
			return -1;
		    nRead+= tmp;
		    if (strlen(buf)==0)
			 type->level_names[n]= None;
		    else type->level_names[n]= XkbInternAtom(buf,0);
		}
	    }
	}
	type->mods.mask= wire.realMods;
	type->mods.real_mods= wire.realMods;
	type->mods.vmods= wire.virtualMods;
	type->num_levels= wire.numLevels;
	type->map_count= wire.nMapEntries;
    }
    if (changes) {
	changes->map.changed|= XkbKeyTypesMask;
	changes->map.first_type= 0;
	changes->map.num_types= xkb->map->num_types;
    }
    return nRead;
}

/***====================================================================***/

static int
ReadXkmCompatMap(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register int		i;
unsigned		num_si,groups;
char 			name[100];
XkbSymInterpretPtr	interp;
xkmSymInterpretDesc	wire;
unsigned		tmp;
int			nRead=0;
XkbCompatMapPtr		compat;
XkbAction               *act;

    if ((tmp= XkmGetCountedString(file,name,100))<1) {
	_XkbLibError(_XkbErrBadLength,"ReadXkmCompatMap",0);
	return -1;
    }
    nRead+= tmp;
    if (name[0]!='\0') {
	if (XkbAllocNames(xkb,XkbCompatNameMask,0,0)!=Success) {
	    _XkbLibError(_XkbErrBadAlloc,"ReadXkmCompatMap",0);
	    return -1;
	}
	xkb->names->compat= XkbInternAtom(name,FALSE);
    }
    num_si= XkmGetCARD16(file,&nRead);
    groups= XkmGetCARD8(file,&nRead);
    nRead+= XkmSkipPadding(file,1);
    if (XkbAllocCompatMap(xkb,XkbAllCompatMask,num_si)!=Success)
	return -1;
    compat= xkb->compat;
    compat->num_si= 0;
    interp= compat->sym_interpret;
    for (i=0;i<num_si;i++) {
	tmp= fread(&wire,SIZEOF(xkmSymInterpretDesc),1,file);
	nRead+= tmp*SIZEOF(xkmSymInterpretDesc);
	interp->sym= wire.sym;
	interp->mods= wire.mods;
	interp->match= wire.match;
	interp->virtual_mod= wire.virtualMod;
	interp->flags= wire.flags;
	interp->act.type= wire.actionType;
        act = (XkbAction *) &interp->act;

        switch (interp->act.type) {
        case XkbSA_SetMods:
        case XkbSA_LatchMods:
        case XkbSA_LockMods:
            act->mods.flags = wire.actionData[0];
            act->mods.mask = wire.actionData[1];
            act->mods.real_mods = wire.actionData[2];
            act->mods.vmods1 = wire.actionData[3];
            act->mods.vmods2 = wire.actionData[4];
            break;
        case XkbSA_SetGroup:
        case XkbSA_LatchGroup:
        case XkbSA_LockGroup:
            act->group.flags = wire.actionData[0];
            act->group.group_XXX = wire.actionData[1];
            break;
        case XkbSA_MovePtr:
            act->ptr.flags = wire.actionData[0];
            act->ptr.high_XXX = wire.actionData[1];
            act->ptr.low_XXX = wire.actionData[2];
            act->ptr.high_YYY = wire.actionData[3];
            act->ptr.low_YYY = wire.actionData[4];
            break;
        case XkbSA_PtrBtn:
        case XkbSA_LockPtrBtn:
            act->btn.flags = wire.actionData[0];
            act->btn.count = wire.actionData[1];
            act->btn.button = wire.actionData[2];
            break;
        case XkbSA_DeviceBtn:
        case XkbSA_LockDeviceBtn:
            act->devbtn.flags = wire.actionData[0];
            act->devbtn.count = wire.actionData[1];
            act->devbtn.button = wire.actionData[2];
            act->devbtn.device = wire.actionData[3];
            break;
        case XkbSA_SetPtrDflt:
            act->dflt.flags = wire.actionData[0];
            act->dflt.affect = wire.actionData[1];
            act->dflt.valueXXX = wire.actionData[2];
            break;
        case XkbSA_ISOLock:
            act->iso.flags = wire.actionData[0];
            act->iso.mask = wire.actionData[1];
            act->iso.real_mods = wire.actionData[2];
            act->iso.group_XXX = wire.actionData[3];
            act->iso.affect = wire.actionData[4];
            act->iso.vmods1 = wire.actionData[5];
            act->iso.vmods2 = wire.actionData[6];
            break;
        case XkbSA_SwitchScreen:
            act->screen.flags = wire.actionData[0];
            act->screen.screenXXX = wire.actionData[1];
            break;
        case XkbSA_SetControls:
        case XkbSA_LockControls:
            act->ctrls.flags = wire.actionData[0];
            act->ctrls.ctrls3 = wire.actionData[1];
            act->ctrls.ctrls2 = wire.actionData[2];
            act->ctrls.ctrls1 = wire.actionData[3];
            act->ctrls.ctrls0 = wire.actionData[4];
            break;
        case XkbSA_RedirectKey:
            act->redirect.new_key = wire.actionData[0];
            act->redirect.mods_mask = wire.actionData[1];
            act->redirect.mods = wire.actionData[2];
            act->redirect.vmods_mask0 = wire.actionData[3];
            act->redirect.vmods_mask1 = wire.actionData[4];
            act->redirect.vmods0 = wire.actionData[4];
            act->redirect.vmods1 = wire.actionData[5];
            break;
        case XkbSA_DeviceValuator:
            act->devval.device = wire.actionData[0];
            act->devval.v1_what = wire.actionData[1];
            act->devval.v1_ndx = wire.actionData[2];
            act->devval.v1_value = wire.actionData[3];
            act->devval.v2_what = wire.actionData[4];
            act->devval.v2_ndx = wire.actionData[5];
            act->devval.v2_what = wire.actionData[6];
            break;

        case XkbSA_XFree86Private:
            /*
             * Bugfix for broken xkbcomp: if we encounter an XFree86Private
             * action with Any+AnyOfOrNone(All), then we skip the interp as
             * broken.  Versions of xkbcomp below 1.2.2 had a bug where they
             * would interpret a symbol that couldn't be found in an interpret
             * as Any.  So, an XF86LogWindowTree+AnyOfOrNone(All) interp that
             * triggered the PrWins action would make every key without an
             * action trigger PrWins if libX11 didn't yet know about the
             * XF86LogWindowTree keysym.  None too useful.
             *
             * We only do this for XFree86 actions, as the current XKB
             * dataset relies on Any+AnyOfOrNone(All) -> SetMods for Ctrl in
             * particular.
             *
             * See xkbcomp commits 2a473b906943ffd807ad81960c47530ee7ae9a60 and
             * 3caab5aa37decb7b5dc1642a0452efc3e1f5100e for more details.
             */
            if (interp->sym == NoSymbol && interp->match == XkbSI_AnyOfOrNone &&
                (interp->mods & 0xff) == 0xff) {
                ErrorF("XKB: Skipping broken Any+AnyOfOrNone(All) -> Private "
                       "action from compiled keymap\n");
                continue;
            }
            /* copy the kind of action */
            memcpy(act->any.data, wire.actionData, XkbAnyActionDataSize);
            break ;

        case XkbSA_Terminate:
            /* no args, kinda (note: untrue for xfree86). */
            break;
        case XkbSA_ActionMessage:
            /* unsupported. */
            break;
        }
        interp++;
        compat->num_si++;
    }
    if ((num_si>0)&&(changes)) {
	changes->compat.first_si= 0;
	changes->compat.num_si= compat->num_si;
    }
    if (groups) {
	register unsigned bit;
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    xkmModsDesc	md;
	    if (groups&bit) {
		tmp= fread(&md,SIZEOF(xkmModsDesc),1,file);
		nRead+= tmp*SIZEOF(xkmModsDesc);
		xkb->compat->groups[i].real_mods= md.realMods;
		xkb->compat->groups[i].vmods= md.virtualMods;
		if (md.virtualMods != 0) {
		    unsigned mask;
		    if (XkbVirtualModsToReal(xkb,md.virtualMods,&mask))
			xkb->compat->groups[i].mask= md.realMods|mask;
		}
		else xkb->compat->groups[i].mask= md.realMods;
	    }
	}
	if (changes)
	    changes->compat.changed_groups|= groups;
    }
    return nRead;
}

static int
ReadXkmIndicators(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register unsigned	nLEDs;
xkmIndicatorMapDesc	wire;
char			buf[100];
unsigned		tmp;
int			nRead=0;

    if ((xkb->indicators==NULL)&&(XkbAllocIndicatorMaps(xkb)!=Success)) {
	_XkbLibError(_XkbErrBadAlloc,"indicator rec",0);
	return -1;
    }
    if (XkbAllocNames(xkb,XkbIndicatorNamesMask,0,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"indicator names",0);
	return -1;
    }
    nLEDs= XkmGetCARD8(file,&nRead);
    nRead+= XkmSkipPadding(file,3);
    xkb->indicators->phys_indicators= XkmGetCARD32(file,&nRead);
    while (nLEDs-->0) {
	Atom 			name;
	XkbIndicatorMapPtr	map;

	if ((tmp=XkmGetCountedString(file,buf,100))<1) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmIndicators",0);
	    return -1;
	}
	nRead+= tmp;
	if (buf[0]!='\0')
	     name= XkbInternAtom(buf,FALSE);
	else name= None;
	if ((tmp=fread(&wire,SIZEOF(xkmIndicatorMapDesc),1,file))<1) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmIndicators",0);
	    return -1;
	}
	nRead+= tmp*SIZEOF(xkmIndicatorMapDesc);
	if (xkb->names) {
	    xkb->names->indicators[wire.indicator-1]= name;
	    if (changes)
		changes->names.changed_indicators|= (1<<(wire.indicator-1));
	}
	map= &xkb->indicators->maps[wire.indicator-1];
	map->flags= wire.flags;
	map->which_groups= wire.which_groups;
	map->groups= wire.groups;
	map->which_mods= wire.which_mods;
	map->mods.mask= wire.real_mods;
	map->mods.real_mods= wire.real_mods;
	map->mods.vmods= wire.vmods;
	map->ctrls= wire.ctrls;
    }
    return nRead;
}

static XkbKeyTypePtr
FindTypeForKey(XkbDescPtr xkb,Atom name,unsigned width,KeySym *syms)
{
    if ((!xkb)||(!xkb->map))
	return NULL;
    if (name!=None) {
	register unsigned i;
	for (i=0;i<xkb->map->num_types;i++) {
	    if (xkb->map->types[i].name==name) {
		if (xkb->map->types[i].num_levels!=width)
		    DebugF("Group width mismatch between key and type\n");
		return &xkb->map->types[i];
	    }
	}
    }
    if ((width<2)||((syms!=NULL)&&(syms[1]==NoSymbol)))
	return &xkb->map->types[XkbOneLevelIndex];
    if (syms!=NULL) {
	if (XkbKSIsLower(syms[0])&&XkbKSIsUpper(syms[1]))
	    return &xkb->map->types[XkbAlphabeticIndex];
	else if (XkbKSIsKeypad(syms[0])||XkbKSIsKeypad(syms[1]))
	    return &xkb->map->types[XkbKeypadIndex];
    }
    return &xkb->map->types[XkbTwoLevelIndex];
}

static int
ReadXkmSymbols(FILE *file,XkbDescPtr xkb)
{
register int		i,g,s,totalVModMaps;
xkmKeySymMapDesc 	wireMap;
char 			buf[100];
unsigned		minKC,maxKC,groupNames,tmp;
int			nRead=0;

    if ((tmp=XkmGetCountedString(file,buf,100))<1)
	return -1;
    nRead+= tmp;
    minKC= XkmGetCARD8(file,&nRead);
    maxKC= XkmGetCARD8(file,&nRead);
    groupNames= XkmGetCARD8(file,&nRead);
    totalVModMaps= XkmGetCARD8(file,&nRead);
    if (XkbAllocNames(xkb,
	      XkbSymbolsNameMask|XkbPhysSymbolsNameMask|XkbGroupNamesMask,
	      0,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"physical names",0);
	return -1;
    }
    if ((buf[0]!='\0')&&(xkb->names)) {
	Atom name;
	name= XkbInternAtom(buf,0);
	xkb->names->symbols= name;
	xkb->names->phys_symbols= name;
    }
    for (i=0,g=1;i<XkbNumKbdGroups;i++,g<<=1) {
	if (groupNames&g) {
	    if ((tmp=XkmGetCountedString(file,buf,100))<1)
		return -1;
	    nRead+= tmp;

	    if (!xkb->names)
		    continue;

	    if (buf[0]!='\0') {
		Atom name;
		name= XkbInternAtom(buf,0);
		xkb->names->groups[i]= name;
	    }	
	    else xkb->names->groups[i]= None;
	}
    }
    if (XkbAllocServerMap(xkb,XkbAllServerInfoMask,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"server map",0);
	return -1;
    }
    if (XkbAllocClientMap(xkb,XkbAllClientInfoMask,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"client map",0);
	return -1;
    }
    if (XkbAllocControls(xkb,XkbAllControlsMask)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"controls",0);
	return -1;
    }
    if ((xkb->map==NULL)||(xkb->server==NULL))
	return -1;
    if (xkb->min_key_code<8)	xkb->min_key_code= minKC;
    if (xkb->max_key_code<8)	xkb->max_key_code= maxKC;
    if ((minKC>=8)&&(minKC<xkb->min_key_code))
	xkb->min_key_code= minKC;
    if ((maxKC>=8)&&(maxKC>xkb->max_key_code)) {
	_XkbLibError(_XkbErrBadValue,"keys in symbol map",maxKC);
	return -1;
    }
    for (i=minKC;i<=(int)maxKC;i++)  {
	Atom 		typeName[XkbNumKbdGroups];
	XkbKeyTypePtr	type[XkbNumKbdGroups];
	if ((tmp=fread(&wireMap,SIZEOF(xkmKeySymMapDesc),1,file))<1) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmSymbols",0);
	    return -1;
	}
	nRead+= tmp*SIZEOF(xkmKeySymMapDesc);
	memset((char *)typeName, 0, XkbNumKbdGroups*sizeof(Atom));
	memset((char *)type, 0, XkbNumKbdGroups*sizeof(XkbKeyTypePtr));
	if (wireMap.flags&XkmKeyHasTypes) {
	    register int g;
	    for (g=0;g<XkbNumKbdGroups;g++) {
		if ((wireMap.flags&(1<<g))&&
			((tmp=XkmGetCountedString(file,buf,100))>0)) {
		    typeName[g]= XkbInternAtom(buf,1);
		    nRead+= tmp;
		}
		type[g]=FindTypeForKey(xkb,typeName[g],wireMap.width,NULL);
		if (type[g]==NULL) {
		    _XkbLibError(_XkbErrMissingTypes,"ReadXkmSymbols",0);
		    return -1;
		}
		if (typeName[g]==type[g]->name)
		    xkb->server->explicit[i]|= (1<<g);
	    }
	}
	if (wireMap.flags&XkmRepeatingKey) {
	    xkb->ctrls->per_key_repeat[i/8]|= (1<<(i%8));
	    xkb->server->explicit[i]|= XkbExplicitAutoRepeatMask;
	}
	else if (wireMap.flags&XkmNonRepeatingKey) {
	    xkb->ctrls->per_key_repeat[i/8]&= ~(1<<(i%8));
	    xkb->server->explicit[i]|= XkbExplicitAutoRepeatMask;
	}
	xkb->map->modmap[i]= wireMap.modifier_map;
	if (XkbNumGroups(wireMap.num_groups)>0) {
	    KeySym	*sym;
	    int		 nSyms;
	
	    if (XkbNumGroups(wireMap.num_groups)>xkb->ctrls->num_groups)
		xkb->ctrls->num_groups= wireMap.num_groups;
	    nSyms= XkbNumGroups(wireMap.num_groups)*wireMap.width;
	    sym= XkbResizeKeySyms(xkb,i,nSyms);
	    if (!sym)
		return -1;
	    for (s=0;s<nSyms;s++) {
		*sym++= XkmGetCARD32(file,&nRead);
	    }
	    if (wireMap.flags&XkmKeyHasActions) {
		XkbAction *	act;
		act= XkbResizeKeyActions(xkb,i,nSyms);
		for (s=0;s<nSyms;s++,act++) {
		    tmp=fread(act,SIZEOF(xkmActionDesc),1,file);
		    nRead+= tmp*SIZEOF(xkmActionDesc);
		}
		xkb->server->explicit[i]|= XkbExplicitInterpretMask;
	    }
	}
	for (g=0;g<XkbNumGroups(wireMap.num_groups);g++) {
	    if (((xkb->server->explicit[i]&(1<<g))==0)||(type[g]==NULL)) {
		KeySym *tmpSyms;
		tmpSyms= XkbKeySymsPtr(xkb,i)+(wireMap.width*g);
		type[g]= FindTypeForKey(xkb,None,wireMap.width,tmpSyms);
	    }
	    xkb->map->key_sym_map[i].kt_index[g]= type[g]-(&xkb->map->types[0]);
	}
	xkb->map->key_sym_map[i].group_info= wireMap.num_groups;
	xkb->map->key_sym_map[i].width= wireMap.width;
	if (wireMap.flags&XkmKeyHasBehavior) {
	    xkmBehaviorDesc	b;
	    tmp= fread(&b,SIZEOF(xkmBehaviorDesc),1,file);
	    nRead+= tmp*SIZEOF(xkmBehaviorDesc);
	    xkb->server->behaviors[i].type= b.type;
	    xkb->server->behaviors[i].data= b.data;
	    xkb->server->explicit[i]|= XkbExplicitBehaviorMask;
	}
    }
    if (totalVModMaps>0) {
	xkmVModMapDesc	v;
	for (i=0;i<totalVModMaps;i++) {
	    tmp= fread(&v,SIZEOF(xkmVModMapDesc),1,file);
	    nRead+= tmp*SIZEOF(xkmVModMapDesc);
	    if (tmp>0)
		xkb->server->vmodmap[v.key]= v.vmods;
	}
    }
    return nRead;
}

static int
ReadXkmGeomDoodad(
    FILE *		file,
    XkbGeometryPtr	geom,
    XkbSectionPtr	section)
{
XkbDoodadPtr	doodad;
xkmDoodadDesc	doodadWire;
char		buf[100];
unsigned	tmp;
int		nRead=0;

    nRead+= XkmGetCountedString(file,buf,100);
    tmp= fread(&doodadWire,SIZEOF(xkmDoodadDesc),1,file);
    nRead+= SIZEOF(xkmDoodadDesc)*tmp;
    doodad= XkbAddGeomDoodad(geom,section,XkbInternAtom(buf,FALSE));
    if (!doodad)
	return nRead;
    doodad->any.type= doodadWire.any.type;
    doodad->any.priority= doodadWire.any.priority;
    doodad->any.top= doodadWire.any.top;
    doodad->any.left= doodadWire.any.left;
    switch (doodadWire.any.type) {
	case XkbOutlineDoodad:
	case XkbSolidDoodad:
	    doodad->shape.angle= doodadWire.shape.angle;
	    doodad->shape.color_ndx= doodadWire.shape.color_ndx;
	    doodad->shape.shape_ndx= doodadWire.shape.shape_ndx;
	    break;
	case XkbTextDoodad:
	    doodad->text.angle= doodadWire.text.angle;
	    doodad->text.width= doodadWire.text.width;
	    doodad->text.height= doodadWire.text.height;
	    doodad->text.color_ndx= doodadWire.text.color_ndx;
	    nRead+= XkmGetCountedString(file,buf,100);
	    doodad->text.text= Xstrdup(buf);
	    nRead+= XkmGetCountedString(file,buf,100);
	    doodad->text.font= Xstrdup(buf);
	    break;
	case XkbIndicatorDoodad:
	    doodad->indicator.shape_ndx= doodadWire.indicator.shape_ndx;
	    doodad->indicator.on_color_ndx= doodadWire.indicator.on_color_ndx;
	    doodad->indicator.off_color_ndx= doodadWire.indicator.off_color_ndx;
	    break;
	case XkbLogoDoodad:
	    doodad->logo.angle= doodadWire.logo.angle;
	    doodad->logo.color_ndx= doodadWire.logo.color_ndx;
	    doodad->logo.shape_ndx= doodadWire.logo.shape_ndx;
	    nRead+= XkmGetCountedString(file,buf,100);
	    doodad->logo.logo_name= Xstrdup(buf);
	    break;
	default:
	    /* report error? */
	    return nRead;
    }
    return nRead;
}

static int
ReadXkmGeomOverlay(	FILE *		file,
			XkbGeometryPtr	geom,
			XkbSectionPtr	section)
{
char 			buf[100];
unsigned		tmp;
int			nRead=0;
XkbOverlayPtr		ol;
XkbOverlayRowPtr	row;
xkmOverlayDesc 		olWire;
xkmOverlayRowDesc	rowWire;
register int		r;

    nRead+= XkmGetCountedString(file,buf,100);
    tmp= fread(&olWire,SIZEOF(xkmOverlayDesc),1,file);
    nRead+= tmp*SIZEOF(xkmOverlayDesc);
    ol= XkbAddGeomOverlay(section,XkbInternAtom(buf,FALSE),
    							olWire.num_rows);
    if (!ol)
	return nRead;
    for (r=0;r<olWire.num_rows;r++)  {
    	int			k;
	xkmOverlayKeyDesc	keyWire;
	tmp= fread(&rowWire,SIZEOF(xkmOverlayRowDesc),1,file);
	nRead+= tmp*SIZEOF(xkmOverlayRowDesc);
	row= XkbAddGeomOverlayRow(ol,rowWire.row_under,rowWire.num_keys);
	if (!row) {
	    _XkbLibError(_XkbErrBadAlloc,"ReadXkmGeomOverlay",0);
	   return nRead;
	}
	for (k=0;k<rowWire.num_keys;k++) {
	    tmp= fread(&keyWire,SIZEOF(xkmOverlayKeyDesc),1,file);
	    nRead+= tmp*SIZEOF(xkmOverlayKeyDesc);
	    memcpy(row->keys[k].over.name,keyWire.over,XkbKeyNameLength);
	    memcpy(row->keys[k].under.name,keyWire.under,XkbKeyNameLength);
	}
	row->num_keys= rowWire.num_keys;
    }
    return nRead;
}

static int
ReadXkmGeomSection(	FILE *		file,
			XkbGeometryPtr	geom)
{
register int	i;
XkbSectionPtr	section;
xkmSectionDesc	sectionWire;
unsigned	tmp;
int		nRead= 0;
char		buf[100];
Atom		nameAtom;

    nRead+= XkmGetCountedString(file,buf,100);
    nameAtom= XkbInternAtom(buf,FALSE);
    tmp= fread(&sectionWire,SIZEOF(xkmSectionDesc),1,file);
    nRead+= SIZEOF(xkmSectionDesc)*tmp;
    section= XkbAddGeomSection(geom,nameAtom,sectionWire.num_rows,
			 			sectionWire.num_doodads,
			 			sectionWire.num_overlays);
    if (!section) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeomSection",0);
	return nRead;
    }
    section->top= sectionWire.top;
    section->left= sectionWire.left;
    section->width= sectionWire.width;
    section->height= sectionWire.height;
    section->angle= sectionWire.angle;
    section->priority= sectionWire.priority;
    if (sectionWire.num_rows>0) {
	register int	k;
	XkbRowPtr	row;
	xkmRowDesc	rowWire;
	XkbKeyPtr	key;
	xkmKeyDesc	keyWire;

	for (i=0;i<sectionWire.num_rows;i++) {
	    tmp= fread(&rowWire,SIZEOF(xkmRowDesc),1,file);
	    nRead+= SIZEOF(xkmRowDesc)*tmp;
	    row= XkbAddGeomRow(section,rowWire.num_keys);
	    if (!row) {
		_XkbLibError(_XkbErrBadAlloc,"ReadXkmKeycodes",0);
		return nRead;
	    }
	    row->top= rowWire.top;
	    row->left= rowWire.left;
	    row->vertical= rowWire.vertical;
	    for (k=0;k<rowWire.num_keys;k++) {
		tmp= fread(&keyWire,SIZEOF(xkmKeyDesc),1,file);
		nRead+= SIZEOF(xkmKeyDesc)*tmp;
		key= XkbAddGeomKey(row);
		if (!key) {
		    _XkbLibError(_XkbErrBadAlloc,"ReadXkmGeomSection",0);
		    return nRead;
		}
		memcpy(key->name.name,keyWire.name,XkbKeyNameLength);
		key->gap= keyWire.gap;
		key->shape_ndx= keyWire.shape_ndx;
		key->color_ndx= keyWire.color_ndx;
	    }
	}
    }
    if (sectionWire.num_doodads>0) {
	for (i=0;i<sectionWire.num_doodads;i++) {
	    tmp= ReadXkmGeomDoodad(file,geom,section);
	    nRead+= tmp;
	    if (tmp<1)
		return nRead;
	}
    }
    if (sectionWire.num_overlays>0) {
	for (i=0;i<sectionWire.num_overlays;i++) {
	    tmp= ReadXkmGeomOverlay(file,geom,section);
	    nRead+= tmp;
	    if (tmp<1)
		return nRead;
	}
    }
    return nRead;
}

static int
ReadXkmGeometry(FILE *file,XkbDescPtr xkb)
{
register int		i;
char 			buf[100];
unsigned		tmp;
int			nRead= 0;
xkmGeometryDesc		wireGeom;
XkbGeometryPtr		geom;
XkbGeometrySizesRec	sizes;

    nRead+= XkmGetCountedString(file,buf,100);
    tmp= fread(&wireGeom,SIZEOF(xkmGeometryDesc),1,file);
    nRead+= tmp*SIZEOF(xkmGeometryDesc);
    sizes.which= XkbGeomAllMask;
    sizes.num_properties= wireGeom.num_properties;
    sizes.num_colors= wireGeom.num_colors;
    sizes.num_shapes= wireGeom.num_shapes;
    sizes.num_sections= wireGeom.num_sections;
    sizes.num_doodads= wireGeom.num_doodads;
    sizes.num_key_aliases= wireGeom.num_key_aliases;
    if (XkbAllocGeometry(xkb,&sizes)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
	return nRead;
    }
    geom= xkb->geom;
    geom->name= XkbInternAtom(buf,FALSE);
    geom->width_mm= wireGeom.width_mm;
    geom->height_mm= wireGeom.height_mm;
    nRead+= XkmGetCountedString(file,buf,100);
    geom->label_font= Xstrdup(buf);
    if (wireGeom.num_properties>0) {
	char val[1024];
	for (i=0;i<wireGeom.num_properties;i++) {
	    nRead+= XkmGetCountedString(file,buf,100);
	    nRead+= XkmGetCountedString(file,val,1024);
	    if (XkbAddGeomProperty(geom,buf,val)==NULL) {
		_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
		return nRead;
	    }
	}
    }
    if (wireGeom.num_colors>0) {
	for (i=0;i<wireGeom.num_colors;i++) {
	    nRead+= XkmGetCountedString(file,buf,100);
	    if (XkbAddGeomColor(geom,buf,i)==NULL) {
		_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
		return nRead;
	    }
	}
    }
    geom->base_color= &geom->colors[wireGeom.base_color_ndx];
    geom->label_color= &geom->colors[wireGeom.label_color_ndx];
    if (wireGeom.num_shapes>0) {
	XkbShapePtr	shape;
	xkmShapeDesc	shapeWire;
	Atom		nameAtom;
	for (i=0;i<wireGeom.num_shapes;i++) {
	    register int 	n;
	    XkbOutlinePtr	ol;
	    xkmOutlineDesc	olWire;
	    nRead+= XkmGetCountedString(file,buf,100);
	    nameAtom= XkbInternAtom(buf,FALSE);
	    tmp= fread(&shapeWire,SIZEOF(xkmShapeDesc),1,file);
	    nRead+= tmp*SIZEOF(xkmShapeDesc);
	    shape= XkbAddGeomShape(geom,nameAtom,shapeWire.num_outlines);
	    if (!shape) {
		_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
		return nRead;
	    }
	    for (n=0;n<shapeWire.num_outlines;n++) {
		register int	p;
		xkmPointDesc	ptWire;
		tmp= fread(&olWire,SIZEOF(xkmOutlineDesc),1,file);
		nRead+= tmp*SIZEOF(xkmOutlineDesc);
		ol= XkbAddGeomOutline(shape,olWire.num_points);
		if (!ol) {
		    _XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
		    return nRead;
		}
		ol->num_points= olWire.num_points;
		ol->corner_radius= olWire.corner_radius;
		for (p=0;p<olWire.num_points;p++) {
		    tmp= fread(&ptWire,SIZEOF(xkmPointDesc),1,file);
		    nRead+= tmp*SIZEOF(xkmPointDesc);
		    ol->points[p].x= ptWire.x;
		    ol->points[p].y= ptWire.y;
		    if (ptWire.x<shape->bounds.x1) shape->bounds.x1= ptWire.x;
		    if (ptWire.x>shape->bounds.x2) shape->bounds.x2= ptWire.x;
		    if (ptWire.y<shape->bounds.y1) shape->bounds.y1= ptWire.y;
		    if (ptWire.y>shape->bounds.y2) shape->bounds.y2= ptWire.y;
		}
	    }
	    if (shapeWire.primary_ndx!=XkbNoShape)
		shape->primary= &shape->outlines[shapeWire.primary_ndx];
	    if (shapeWire.approx_ndx!=XkbNoShape)
		shape->approx= &shape->outlines[shapeWire.approx_ndx];
	}
    }
    if (wireGeom.num_sections>0) {
	for (i=0;i<wireGeom.num_sections;i++) {
	    tmp= ReadXkmGeomSection(file,geom);
	    nRead+= tmp;
	    if (tmp==0)
		return nRead;
	}
    }
    if (wireGeom.num_doodads>0) {
	for (i=0;i<wireGeom.num_doodads;i++) {
	    tmp= ReadXkmGeomDoodad(file,geom,NULL);
	    nRead+= tmp;
	    if (tmp==0)
		return nRead;
	}
    }
    if ((wireGeom.num_key_aliases>0)&&(geom->key_aliases)) {
	int sz= XkbKeyNameLength*2;
	int num= wireGeom.num_key_aliases;
	if (fread(geom->key_aliases,sz,num,file)!=num) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmGeometry",0);
	    return -1;
	}
	nRead+= (num*sz);
	geom->num_key_aliases= num;
    }
    return nRead;
}

Bool
XkmProbe(FILE *file)
{
unsigned hdr,tmp;
int	 nRead=0;

    hdr= (('x'<<24)|('k'<<16)|('m'<<8)|XkmFileVersion);
    tmp= XkmGetCARD32(file,&nRead);
    if (tmp!=hdr) {
	if ((tmp&(~0xff))==(hdr&(~0xff))) {
	    _XkbLibError(_XkbErrBadFileVersion,"XkmProbe",tmp&0xff);
	}
	return 0;
    }
    return 1;
}

static Bool
XkmReadTOC(FILE *file,xkmFileInfo* file_info,int max_toc,xkmSectionInfo *toc)
{
unsigned hdr,tmp;
int	nRead=0;
unsigned i,size_toc;

    hdr= (('x'<<24)|('k'<<16)|('m'<<8)|XkmFileVersion);
    tmp= XkmGetCARD32(file,&nRead);
    if (tmp!=hdr) {
	if ((tmp&(~0xff))==(hdr&(~0xff))) {
	    _XkbLibError(_XkbErrBadFileVersion,"XkmReadTOC",tmp&0xff);
	}
	else {
	    _XkbLibError(_XkbErrBadFileType,"XkmReadTOC",tmp);
	}
	return 0;
    }
    fread(file_info,SIZEOF(xkmFileInfo),1,file);
    size_toc= file_info->num_toc;
    if (size_toc>max_toc) {
	DebugF("Warning! Too many TOC entries; last %d ignored\n",
							size_toc-max_toc);
	size_toc= max_toc;
    }
    for (i=0;i<size_toc;i++) {
	fread(&toc[i],SIZEOF(xkmSectionInfo),1,file);
    }
    return 1;
}

/***====================================================================***/

#define	MAX_TOC	16
unsigned
XkmReadFile(FILE *file,unsigned need,unsigned want,XkbDescPtr *xkb)
{
register unsigned	i;
xkmSectionInfo		toc[MAX_TOC],tmpTOC;
xkmFileInfo		fileInfo;
unsigned		tmp,nRead=0;
unsigned		which= need|want;

    if (!XkmReadTOC(file,&fileInfo,MAX_TOC,toc))
	return which;
    if ((fileInfo.present&need)!=need) {
       _XkbLibError(_XkbErrIllegalContents,"XkmReadFile",
       						need&(~fileInfo.present));
       return which;
    }
    if (*xkb==NULL)
	*xkb= XkbAllocKeyboard();
    for (i=0;i<fileInfo.num_toc;i++) {
	fseek(file,toc[i].offset,SEEK_SET);
	tmp= fread(&tmpTOC,SIZEOF(xkmSectionInfo),1,file);
	nRead= tmp*SIZEOF(xkmSectionInfo);
	if ((tmpTOC.type!=toc[i].type)||(tmpTOC.format!=toc[i].format)||
	    (tmpTOC.size!=toc[i].size)||(tmpTOC.offset!=toc[i].offset)) {
	    return which;
	}
	if ((which&(1<<tmpTOC.type))==0) {
	    continue;
	}
	switch (tmpTOC.type) {
	    case XkmVirtualModsIndex:
		tmp= ReadXkmVirtualMods(file,*xkb,NULL);
		break;
	    case XkmTypesIndex:
		tmp= ReadXkmKeyTypes(file,*xkb,NULL);
		break;
	    case XkmCompatMapIndex:
		tmp= ReadXkmCompatMap(file,*xkb,NULL);
		break;
	    case XkmKeyNamesIndex:
		tmp= ReadXkmKeycodes(file,*xkb,NULL);
		break;
	    case XkmIndicatorsIndex:
		tmp= ReadXkmIndicators(file,*xkb,NULL);
		break;
	    case XkmSymbolsIndex:
		tmp= ReadXkmSymbols(file,*xkb);
		break;
	    case XkmGeometryIndex:
		tmp= ReadXkmGeometry(file,*xkb);
		break;
	    default:
		_XkbLibError(_XkbErrBadImplementation,
				XkbConfigText(tmpTOC.type,XkbMessage),0);
		tmp= 0;
		break;
	}
	if (tmp>0) {
	    nRead+= tmp;
	    which&= ~(1<<toc[i].type);
	    (*xkb)->defined|= (1<<toc[i].type);
	}
	if (nRead!=tmpTOC.size) {
	    _XkbLibError(_XkbErrBadLength,XkbConfigText(tmpTOC.type,XkbMessage),
	    						nRead-tmpTOC.size);
	}
    }
    return which;
}
                        XKM File Format Description
                                Version 15

1. Introduction

The XKM file format is the exchange format for XKB keyboard descriptions
between the server and xkbcomp. Usually, the server forks off xkbcomp,
xkbcomp compiles the XKM format from the given parameters.
The resulting XKM file is put into a directory readable by the server and
then parsed.

The XKM format is little more than a binary dump of various XKB-specific
structures and hence tied to the ABI of the server.

                              ❧❧❧❧❧❧❧❧❧❧❧

1.1 About this file format description

This description was produced by analyzing the XKM parsing code. Parts of
the file description present in the original format specification may be
missing. This description thus cannot be a reference document for XKM
implementations.

No description of the meaning of the various fields is given here. Refer to
the XKB protocol specification for more details.
                              ❧❧❧❧❧❧❧❧❧❧❧

2. Notations used in this document

Notation for structures:

┌───
  Name of struct
	name of field:		type or fixed value of field
	name of field:		type or fixed value of field
└───

Data types are identical to those used in the X Protocol specification
except where noted otherwise. Structs specific to XKM are prefixed with XKM,
defines specific to the XKB protocol specification are prefixed with Xkb and
their value is equivalent to that in the protocol specification.

Multiple instances of a given type are denoted in the following form:
	name of field:		LISTofFIELDTYPE

Length specifiers for such fields are usually prefixed with num_. For
example, a struct containing a num_foo of 8 and a 'foo' field contains 8
structures of type 'foo'.

Variable length padding is specified as pad(x), where x is the length of the
data to be padded out to a multiple of 4 bytes. For example, given an x of
10, pad(x) would be the remaining 2 bytes to pad the whole struct to 12
bytes.

A special notation is a variable content struct. In this case, the contents
of the struct depend on the value of one or more specific fields.
┌───
  Name of struct
	field:			type or fixed value of field
	field:			type or fixed value of field
	───
	field ⇒ value 1
	⇒
		specific field:		type
		specific field:		type
	───
        field ⇒ value 2
	⇒
		specific field:		type
		specific field:		type
└───
This notation denotes that if field is of value 1, this struct contains the
specific fields listed underneath value 1.

                              ❧❧❧❧❧❧❧❧❧❧❧

3. XKM Format

The XKM format is a binary format with structs usually being padded to a
multiple of 4 bytes. No provisions for endianess are provided, the parser is
left to guess the endianess of the XKM file.

                              ❧❧❧❧❧❧❧❧❧❧❧
3.1 Common data types

┌───
  XKMCountedString
	count:			CARD16
	string:			count * CHAR
	pad:			pad(count + 2)
└───

XKMCountedString is used for user-readable identifiers. Prime example are
the level names and the section names ("complete", "evdev(inet)", etc.)

┌───
  XKMGroupBits:		CARD8
	group1			0x1
	group2			0x2
	group3			0x4
	group4			0x8
└───

                              ❧❧❧❧❧❧❧❧❧❧❧

3.2 Header and Table of Contents

┌───
  XKMHeader
	version:		CARD8
	identifier1:		'm'
	identifier2:		'k'
	idenfifier3:		'x'
└───

The XKM file format has a 4 byte header identifying the file and the XKM
version. The header is followed by the table of contents indicating the
sections present in this file.

┌───
  XKMFileInfo
	type:			CARD8
	min_keycode:		CARD8
	max_keycode:		CARD8
	num_sectioninfo:	CARD8
	present:		CARD16
	pad:			CARD16
	sectioninfo:		LISTofXKMSectionInfo
└───

min_keycode and max_keycode specify the keycode range for this keyboard
descriptions. The core protocol requires min_keycode always be equal to or
greater than 8.

┌───
  XKMSectionInfo
	type:			CARD16
		XkmTypesIndex		0
		XkmCompatMapIndex	1
		XkmSymbolsIndex		2
		XkmIndicatorsIndex	3
		XkmKeyNamesIndex	4
		XkmGeometryIndex	5
		XkmVirtualModsIndex	6
	format:			CARD16
	size:			CARD16
	offset:			CARD16
└───

Describes the section found in a chunk of a file. This struct is found
_twice_ in the file per section, once as part of the XKMFileInfo, once at
the beginning of the actual section (see offset).
The type specifies the type of the section, the section is to be parsed
according to this type.
Size and offset specify the size in bytes and the offset into the file in
bytes, respectively.

3.3 Sections

Each section resides at the offset specified in the XKMFileInfo sectioninfo.

                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.1 XKMTypes

An XKMTypes section describes the key types defined in a layout. Roughly
speaking, a key type defines how many levels a given key has and which
modifiers change to a particular level.

┌───
  XKMTypesSection
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	num_types:		CARD16
	pad:			CARD16
	types:			LISTofXKMKeyType
└───

┌───
  XKMKeyType
	real_mods:		CARD8
	num_levels:		CARD8
	virt_mods:		CARD16
	num_map_entries: 	CARD8
	num_level_names: 	CARD8
	perserve:	 	CARD8
	pad:			CARD8
	map_entries:		LISTofXKMKTMapEntry
	name:			XKMCountedString
	mods:			LISTofXKMModsDesc
	level_names:		LISXTofXKMCountedString
└───

The num_map_entries specifies the number of structs in both map_entries and mods. mods is only present if preserve is TRUE.

┌───
  XKMKTMapEntry
	level:			CARD8
	real_mods:		CARD8
	virt_mods:		CARD16
└───

┌───
  XKMModsDesc
	real_mods:		CARD8
	pad:			CARD8
	virt_mods:		CARD16
└───

                              ❧❧❧❧❧❧❧❧❧❧❧
3.3.2 XKMCompatMap

An XKMCompatMap section describes the actions a keyboard may trigger. This
ranges from the TerminateServer action to simple modifier bits.

┌───
  XKMCompatMap
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	num_si:			CARD16
	group_mask:		XKMGroupBits
	pad:			CARD8
	si:			LISTofXKMSymInterpreterDesc
	groups:			LISTofXKMModsDesc
└───

One XKMModsDesc is present for each bit set in group_mask.

┌───
  XKMSymInterpretDesc
	sym:			CARD32
	mods:			CARD8
	match:			CARD8
	virtual_mod:		CARD8
	flags:			CARD8
	action_type:		CARD8
	action_data:		XKMActionData
└───

Where the action is 7 bytes of CARD8 whose content is determined by
action_type.

┌───
  XKMActionData:
	pad0:			CARD8
	pad1:			CARD16
	pad2:			CARD32
	───
        action_type ⇒ XkbSA_SetMods ||
        action_type ⇒ XkbSA_LatchMods ||
        action_type ⇒ XkbSA_LockMods
	⇒
		flags:			CARD8
		mask:			CARD8
		real_mods:		CARD8
		vmods1:			CARD8
		vmods2:			CARD8
		pad:			CARD16
	───
        action_type ⇒ XkbSA_SetGroup ||
        action_type ⇒ XkbSA_LatchGroup ||
        action_type ⇒ XkbSA_LockGroup
	⇒
		flags:			CARD8
		group_XXX:		CARD8
		pad0:			CARD8
		pad1:			CARD32
	───
        action_type ⇒ XkbSA_MovePtr
	⇒
		flags:			CARD8
		high_XXX:		CARD8
		low_XXX:		CARD8
		high_YYY:		CARD8
		low_YYY:		CARD8
		pad:			CARD16
	───
        action_type ⇒ XkbSA_PtrBtn ||
        action_type ⇒ XkbSA_LockPtrBtn
	⇒
		flags:			CARD8
		count:			CARD8
		button:			CARD8
		pad:			CARD32
	───
        action_type ⇒ XkbSA_DeviceBtn ||
        action_type ⇒ XkbSA_LockLockPtrBtn
	⇒
		flags:			CARD8
		count:			CARD8
		button:			CARD8
		device:			CARD8
		pad0:			CARD8
		pad1:			CARD16
	───
        action_type ⇒ XkbSA_SetPtrDflt
	⇒
		flags:			CARD8
		affect:			CARD8
		valueXXX:		CARD8
		pad0:			CARD32
	───
        action_type ⇒ XkbSA_ISOLock
	⇒
		flags:			CARD8
		mask:			CARD8
		real_mods:		CARD8
		group_XXX:		CARD8
		affect:			CARD8
		vmods1:			CARD8
		vmods1:			CARD8
	───
        action_type ⇒ XkbSA_SwitchScreen
	⇒
		flags:			CARD8
		screenXXX:		CARD8
		pad0:			CARD8
		pad1:			CARD32
	───
        action_type ⇒ XkbSA_SetControls ||
        action_type ⇒ XkbSA_LockControls
	⇒
		flags:			CARD8
		ctrls3:			CARD8
		ctrls2:			CARD8
		ctrls1:			CARD8
		ctrls0:			CARD8
		pad:			CARD16
	───
        action_type ⇒ XkbSA_RedirectKey
	⇒
		new_key:		CARD8
		mods_mask:		CARD8
		mods:			CARD8
		vmods_mask0:		CARD8
		vmods_mask1:		CARD8
		vmods0:			CARD8
		vmods1:			CARD8
	───
        action_type ⇒ XkbSA_DeviceValuator
	⇒
		device:		CARD8
		v1_what:		CARD8
		v1_idx:			CARD8
		v1_value:		CARD8
		v2_what:		CARD8
		v2_idx:			CARD8
		v2_value:		CARD8
		pad:			CARD8
	───
        action_type ⇒ XkbSA_XFree86Private ||
        action_type ⇒ XkbSA_Terminate
	⇒
		pad0:			CARD8
		pad1:			CARD16
		pad2:			CARD32
	───
        action_type ⇒ XkbSA_ActionMessage
	⇒
		press_msg:		BOOL
		release_msg:		BOOL
		gen_event:		BOOL
		message:		4 * CHAR
└───

Note: XkbSA_ActionMessage is currently unsupported and the contents are
ignored.

                              ❧❧❧❧❧❧❧❧❧❧❧
3.3.3 XkmSymbols

The symbols in a keymap define the actual keysyms each key may produce.

┌───
  XKMSymbols
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	min_keycode:		CARD8
	max_keycode:		CARD8
	group_names_mask:	XKMGroupBits
	num_vmod_maps:		CARD8
	group_names:		LISTofXKMCountedString
	keysyms:		XKMKeysymMapDesc
	vmod_maps:		XKMVModMapDesc
└───
One group_name is present for each bit set in group_names_mask.
The number of keysyms present is max_keycode - min_keycode + 1.

┌───
  XKMKeysymMapDesc
	width:			CARD8
	num_groups:		CARD8
	modifier_map:		CARD8
	flags:			CARD8
	names:			LISTofXKMCountedString
	syms:			LISTofCARD32
	behavior:		XKMBehaviorDesc
└───

Presence of names is conditional on the XkmKeyHasTypes flag. The number of
strings is equal to the number of group bits in group_names_mask in the
preceeding XKMSymbols section.
The number of elements in syms is equal to width * num_groups.
Presence of behavior is conditional on the XkmKeyHasBehavior flag.

┌───
  XKMKeyBehaviorDesc
	type:			CARD8
	data:			CARD8
	pad:			CARD16
└───

┌───
  XKMVModMapDesc
	key:			CARD8
	pad:			CARD8
	vmods:			CARD16
└───

                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.4 XKMIndicators

┌───
  XKMIndicators
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	num_indicators:		CARD8
	pad0:			CARD8
	pad1:			CARD16
	indicators:		LISTofXKMIndicatorMapDesc
└───

┌───
  XKMIndicatorMapDesc
	name:			XKMCountedString
	indicator:		CARD8
	flags:			CARD8
	which_mods:		CARD8
	real_mods:		CARD8
	vmods:			CARD16
	which_groups:		CARD8
	groups:			CARD8
	ctrls:			CARD32
└───
                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.5 XKMKeyNames

┌───
  XKMKeyNames
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	min_keycode:		CARD8
	max_keycode:		CARD8
	num_aliases:		CARD8
	pad:			CARD8
	keynames:		LISTofXKMKeyname
	aliases:		LISTofXKMKeyAlias
└───

keynames contains max_keycode - min_keycode + 1 entries.

┌───
  XkmKeyname
	name:			4 * CHAR8
└───

┌───
  XkmKeyAlias
	real:			XkmKeyname
	alias:			XkmKeyname
└───

                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.5 XKMGeometry

┌───
  XKMGeometry
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	width_mm:		CARD16
	height_mm:		CARD16
	base_color_ndx:		CARD8
	label_color_ndx:	CARD8
	num_properties:		CARD16
	num_colors:		CARD16
	num_shapes:		CARD16
	num_sections:		CARD16
	num_doodads:		CARD16
	num_key_aliases:	CARD16
	pad:			CARD16
	label_font:		XKMCountedString
	properties:		LISTofXKMGeomProperty
	colors:			LISTofXKMCountedString
	shapes:			LISTofXKMGeomShape
	sections:		LISTofXKMGeomSection
	doodads:		LISTofXKMGeomDoodad
	key_aliases:		LISTofXKMKeyAlias
└───

┌───
  XKMGeomProperty
	name:			XKMCountedString
	value:			XKMCountedString

└───

┌───
  XKMGeomShape
	name:			XKMCountedString
	num_outlines:		CARD8
	primary_idx:		CARD8
	approx_idx:		CARD8
	pad:			CARD8
	outlines:		LISTofXKMOutlineDesc
└───

┌───
  XKMOutlineDesc
	num_points:		CARD8
	corner_radius:		CARD8
	pad:			CARD16
	points:			LISTofXKMPointDesc
└───

┌───
  XKMPointDesc
	x:			INT16
	y:			INT16
└───

┌───
  XKMGeomSection
	name:			XKMCountedString
	top:			INT16
	left:			INT16
	width:			CARD16
	height:			CARD16
	angle:			INT16
	priority:		CARD8
	num_rows:		CARD8
	num_doodads:		CARD8
	num_overlays:		CARD8
	pad:			CARD16
	rows:			LISTofXKMRowDesc
	doodads:		LISTofXKMGeomDoodad
	overlays:		LISTofXKMGeomOverlay
└───

┌───
  XKMRowDesc
	top:			INT16
	left:			INT16
	num_keys:		CARD8
	vertical:		BOOL
	pad:			CARD16
	keys:			XKMKeyDesc
└───

┌───
  XKMKeyDesc
	name:			XKMKeyname
	gap:			INT16
	shape_idx:		CARD8
	color_idx:		CARD8
└───

┌───
  XKMGeomDoodad
	name:			XKMCountedString
	type:			CARD8
	priority:		CARD8
	top:			INT16
	left:			INT16
	pad1:			CARD16
	pad2:			CARD32
	pad3:			CARD32
	───
        type ⇒ XkbOutlineDoodad ||
        type ⇒ XkbSolideDoodad
	⇒
		type:			CARD8
		priority:		CARD8
		top:			INT16
		left:			INT16
		angle:			INT16
		color_idx:		CARD8
		shape_idx:		CARD8
		pad0:			CARD16
		pad1:			CARD32
	───
        type ⇒ XkbTextDoodad
	⇒
		type:			CARD8
		priority:		CARD8
		top:			INT16
		left:			INT16
		angle:			INT16
		width:			CARD16
		height:			CARD16
		color_idx:		CARD8
		pad0:			CARD8
		pad1:			CARD16
		text:			XKMCountedString
		font:			XKMCountedString
	───
        type ⇒ XkbIndicatorDoodad
	⇒
		type:			CARD8
		priority:		CARD8
		top:			INT16
		left:			INT16
		shape_idx:		CARD8
		on_color_idx:		CARD8
		off_color_idx:		CARD8
		pad0:			CARD8
		pad1:			CARD16
		pad2:			CARD32
	───
        type ⇒ XkbLogoDoodad
	⇒
		type:			CARD8
		priority:		CARD8
		top:			INT16
		left:			INT16
		angle:			INT16
		color_idx:		CARD8
		shape_idx:		CARD8
		pad0:			CARD16
		pad1:			CARD32
		logo_name:		XKMCountedString
└───

WARNING: XKMGeomDoodad has variable length depending on the type.
NOTE: The current server implementation does not use all fields of all
structures.

┌───
  XKMOverlayDesc
	name:			XKMCountedString
	num_rows:		CARD8
	pad0:			CARD8
	pad1:			CARD16
	rows:			LISTofXKMOverlayRowDesc
└───

┌───
  XKMOverlayRowDesc
	name:			XKMCountedString
	row_under:		CARD8
	num_keys:		CARD8
	pad:			CARD16
	keys:			LISTofXKMOverlayKeyDesc
└───

┌───
  XKMOverlayKeyDesc
	over:			XKMKeyname
	under:			XKMKeyname
└───

                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.6 XKMVirtualMods

┌───
  XKMOverlayRowDesc
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	bound_mask:		SETofVMODBITS
	named_mask:		SETofVMODBITS
	vmods:			LISTofCARD8
	pad:			pad(vmods)
	names:			LISTofXKMCountedString
└───

	VMODBITS:		CARD16

Number of elements in vmods is equal to the number of bits set in
bound_mask. The padding completes vmods to a multiple of 4 byte units.
Number of elements in names is equal to the number of bits set in
named_mask.
dnl Copyright 2005 Red Hat, Inc
dnl 
dnl Permission to use, copy, modify, distribute, and sell this software and its
dnl documentation for any purpose is hereby granted without fee, provided that
dnl the above copyright notice appear in all copies and that both that
dnl copyright notice and this permission notice appear in supporting
dnl documentation.
dnl 
dnl The above copyright notice and this permission notice shall be included
dnl in all copies or substantial portions of the Software.
dnl 
dnl THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
dnl OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
dnl MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
dnl IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
dnl OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
dnl ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
dnl OTHER DEALINGS IN THE SOFTWARE.
dnl 
dnl Except as contained in this notice, the name of the copyright holders shall
dnl not be used in advertising or otherwise to promote the sale, use or
dnl other dealings in this Software without prior written authorization
dnl from the copyright holders.
dnl 

# XORG_DRIVER_CHECK_EXT()
# --------------------------
# Checks for the $1 define in xorg-server.h (from the sdk).  If it
# is defined, then add $1 to $REQUIRED_MODULES.

AC_DEFUN([XORG_DRIVER_CHECK_EXT],[
	AC_REQUIRE([PKG_PROG_PKG_CONFIG])
	SAVE_CFLAGS="$CFLAGS"
	CFLAGS="$CFLAGS -I`$PKG_CONFIG --variable=sdkdir xorg-server`"
	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
#include "xorg-server.h"
#if !defined $1
#error $1 not defined
#endif
		]])],
		[_EXT_CHECK=yes],
		[_EXT_CHECK=no])
	CFLAGS="$SAVE_CFLAGS"
	AC_MSG_CHECKING([if $1 is defined])
	AC_MSG_RESULT([$_EXT_CHECK])
	if test "$_EXT_CHECK" != no; then
		REQUIRED_MODULES="$REQUIRED_MODULES $2"
	fi
])
prefix=@prefix@
exec_prefix=@exec_prefix@
libdir=@libdir@
includedir=@includedir@
datarootdir=@datarootdir@
moduledir=@moduledir@
sdkdir=@sdkdir@
sysconfigdir=@sysconfigdir@

abi_ansic=@abi_ansic@
abi_videodrv=@abi_videodrv@
abi_xinput=@abi_xinput@
abi_extension=@abi_extension@

Name: xorg-server
Description: Modular X.Org X Server
Version: @PACKAGE_VERSION@
Requires: pixman-1 pciaccess
Requires.private: @SDK_REQUIRED_MODULES@
Cflags: -I${sdkdir} @symbol_visibility@
Libs: -L${libdir}
<!-- shared -*-xml-*- entity definitions for the X server documentation -->
<!ENTITY xserver.version "@PACKAGE_VERSION@">
<!ENTITY xserver.reldate "@RELEASE_DATE@">
export TERM=xterm-256color

# user
# /c/msys64/msys2_shell.cmd -defterm -here -no-start -msys2 -shell bash -c "pacman -S --noconfirm --needed cmake ninja gcc ; ./make.sh"

# we must build with gcc as msys2 libs require __data and __bss segments which clang does not provide
#

export c_compiler="clang"
export cxx_compiler="clang++"

export ACLOCAL_PATH="/usr/share/aclocal-1.16:../../ROOTFS/share/aclocal"

cmake -G "Ninja" $1 -DCMAKE_INSTALL_PREFIX="$(pwd)/BUILD_DEBUG/BUILD_ROOT/ROOTFS" -DLLVM_BUILD_ROOT__ROOTFS="$(pwd)/BUILD_DEBUG/BUILD_ROOT/ROOTFS" -DCMAKE_C_COMPILER="$c_compiler" -DCMAKE_CXX_COMPILER="$cxx_compiler" -DCMAKE_BUILD_TYPE=Debug -DCMAKE_COLOR_DIAGNOSTICS=ON -DCMAKE_COLOR_MAKEFILE=ON -S . -B BUILD_DEBUG &&
cmake --build BUILD_DEBUG &&
cmake --install BUILD_DEBUG
rm -rf BUILD_DEBUG ; ./make.sh
https://xorg.freedesktop.org/releases/individual/
