 (pDst->pDrawable, &box, pDst->subWindowMode);
    }
    unwrap (pScrPriv, ps, Glyphs);
    (*ps->Glyphs) (op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
    damageRegionProcessPending (pDst->pDrawable);
    wrap (pScrPriv, ps, Glyphs, damageGlyphs);
}

static void
damageAddTraps (PicturePtr  pPicture,
		INT16	    x_off,
		INT16	    y_off,
		int	    ntrap,
		xTrap	    *traps)
{
    ScreenPtr		pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
    damageScrPriv(pScreen);

    if (checkPictureDamage (pPicture))
    {
	BoxRec	box;
	int	i;
	int	x, y;
	xTrap	*t = traps;

	box.x1 = 32767;
	box.y1 = 32767;
	box.x2 = -32767;
	box.y2 = -32767;
	x = pPicture->pDrawable->x + x_off;
	y = pPicture->pDrawable->y + y_off;
	for (i = 0; i < ntrap; i++)
	{
	    pixman_fixed_t   l = min (t->top.l, t->bot.l);
	    pixman_fixed_t   r = max (t->top.r, t->bot.r);
	    int	    x1 = x + pixman_fixed_to_int (l);
	    int	    x2 = x + pixman_fixed_to_int (pixman_fixed_ceil (r));
	    int	    y1 = y + pixman_fixed_to_int (t->top.y);
	    int	    y2 = y + pixman_fixed_to_int (pixman_fixed_ceil (t->bot.y));
	    
	    if (x1 < box.x1)
		box.x1 = x1;
	    if (x2 > box.x2)
		box.x2 = x2;
	    if (y1 < box.y1)
		box.y1 = y1;
	    if (y2 > box.y2)
		box.y2 = y2;
	}
	TRIM_PICTURE_BOX (box, pPicture);
	if (BOX_NOT_EMPTY(box))
	    damageDamageBox (pPicture->pDrawable, &box, pPicture->subWindowMode);
    }
    unwrap (pScrPriv, ps, AddTraps);
    (*ps->AddTraps) (pPicture, x_off, y_off, ntrap, traps);
    damageRegionProcessPending (pPicture->pDrawable);
    wrap (pScrPriv, ps, AddTraps, damageAddTraps);
}

/**********************************************************/


static void
damageFillSpans(DrawablePtr pDrawable,
		GC	    *pGC,
		int	    npt,
		DDXPointPtr ppt,
		int	    *pwidth,
		int	    fSorted)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt && checkGCDamage (pDrawable, pGC))
    {
	int	    nptTmp = npt;
	DDXPointPtr pptTmp = ppt;
	int	    *pwidthTmp = pwidth;
	BoxRec	    box;

	box.x1 = pptTmp->x;
	box.x2 = box.x1 + *pwidthTmp;
	box.y2 = box.y1 = pptTmp->y;

	while(--nptTmp) 
	{
	   pptTmp++;
	   pwidthTmp++;
	   if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
	   if(box.x2 < (pptTmp->x + *pwidthTmp))
		box.x2 = pptTmp->x + *pwidthTmp;
	   if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
	   else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	}

	box.y2++;

        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDrawable);
        }
        TRIM_BOX(box, pGC); 

	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    
    (*pGC->ops->FillSpans)(pDrawable, pGC, npt, ppt, pwidth, fSorted);

    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageSetSpans(DrawablePtr  pDrawable,
	       GCPtr	    pGC,
	       char	    *pcharsrc,
	       DDXPointPtr  ppt,
	       int	    *pwidth,
	       int	    npt,
	       int	    fSorted)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt && checkGCDamage (pDrawable, pGC))
    {
	DDXPointPtr pptTmp = ppt;
	int	    *pwidthTmp = pwidth;
	int	    nptTmp = npt;
	BoxRec	    box;

	box.x1 = pptTmp->x;
	box.x2 = box.x1 + *pwidthTmp;
	box.y2 = box.y1 = pptTmp->y;

	while(--nptTmp) 
	{
	   pptTmp++;
	   pwidthTmp++;
	   if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
	   if(box.x2 < (pptTmp->x + *pwidthTmp))
		box.x2 = pptTmp->x + *pwidthTmp;
	   if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
	   else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	}

	box.y2++;

        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDrawable);
        }
        TRIM_BOX(box, pGC); 

	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->SetSpans)(pDrawable, pGC, pcharsrc, ppt, pwidth, npt, fSorted);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePutImage(DrawablePtr  pDrawable,
	       GCPtr	    pGC,
	       int	    depth,
	       int	    x,
	       int	    y,
	       int	    w,
	       int	    h,
	       int	    leftPad,
	       int	    format,
	       char	    *pImage)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    if (checkGCDamage (pDrawable, pGC))
    {
	BoxRec box;

	box.x1 = x + pDrawable->x;
	box.x2 = box.x1 + w;
	box.y1 = y + pDrawable->y;
	box.y2 = box.y1 + h;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PutImage)(pDrawable, pGC, depth, x, y, w, h,
		leftPad, format, pImage);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static RegionPtr
damageCopyArea(DrawablePtr   pSrc,
	       DrawablePtr  pDst,
	       GC	    *pGC,
	       int	    srcx,
	       int	    srcy,
	       int	    width,
	       int	    height,
	       int	    dstx,
	       int	    dsty)
{
    RegionPtr ret;
    DAMAGE_GC_OP_PROLOGUE(pGC, pDst);
    
    if (checkGCDamage (pDst, pGC))
    {
	BoxRec box;

	box.x1 = dstx + pDst->x;
	box.x2 = box.x1 + width;
	box.y1 = dsty + pDst->y;
	box.y2 = box.y1 + height;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDst, &box, pGC->subWindowMode);
    }

    ret = (*pGC->ops->CopyArea)(pSrc, pDst,
            pGC, srcx, srcy, width, height, dstx, dsty);
    damageRegionProcessPending (pDst);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDst);
    return ret;
}

static RegionPtr
damageCopyPlane(DrawablePtr	pSrc,
		DrawablePtr	pDst,
		GCPtr		pGC,
		int		srcx,
		int		srcy,
		int		width,
		int		height,
		int		dstx,
		int		dsty,
		unsigned long	bitPlane)
{
    RegionPtr ret;
    DAMAGE_GC_OP_PROLOGUE(pGC, pDst);

    if (checkGCDamage (pDst, pGC))
    {
	BoxRec box;

	box.x1 = dstx + pDst->x;
	box.x2 = box.x1 + width;
	box.y1 = dsty + pDst->y;
	box.y2 = box.y1 + height;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDst, &box, pGC->subWindowMode);
    }

    ret = (*pGC->ops->CopyPlane)(pSrc, pDst,
	       pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
    damageRegionProcessPending (pDst);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDst);
    return ret;
}

static void
damagePolyPoint(DrawablePtr pDrawable,
		GCPtr	    pGC,
		int	    mode,
		int	    npt,
		xPoint	    *ppt)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	box;
	int	nptTmp = npt;
	xPoint	*pptTmp = ppt;

	box.x2 = box.x1 = pptTmp->x;
	box.y2 = box.y1 = pptTmp->y;

	/* this could be slow if the points were spread out */

	while(--nptTmp) 
	{
	   pptTmp++;
	   if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
	   else if(box.x2 < pptTmp->x) box.x2 = pptTmp->x;
	   if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
	   else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	}

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolyPoint)(pDrawable, pGC, mode, npt, ppt);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolylines(DrawablePtr pDrawable,
		GCPtr	    pGC,
		int	    mode,
		int	    npt,
		DDXPointPtr ppt)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt && checkGCDamage (pDrawable, pGC))
    {
	int	    nptTmp = npt;
	DDXPointPtr pptTmp = ppt;
	BoxRec	    box;
	int	    extra = pGC->lineWidth >> 1;

	box.x2 = box.x1 = pptTmp->x;
	box.y2 = box.y1 = pptTmp->y;

	if(nptTmp > 1) 
	{
	   if(pGC->joinStyle == JoinMiter)
		extra = 6 * pGC->lineWidth;
	   else if(pGC->capStyle == CapProjecting)
		extra = pGC->lineWidth;
        }

	if(mode == CoordModePrevious) 
	{
	   int x = box.x1;
	   int y = box.y1;
	   while(--nptTmp) 
	   {
		pptTmp++;
		x += pptTmp->x;
		y += pptTmp->y;
		if(box.x1 > x) box.x1 = x;
		else if(box.x2 < x) box.x2 = x;
		if(box.y1 > y) box.y1 = y;
		else if(box.y2 < y) box.y2 = y;
	    }
	}
	else 
	{
	   while(--nptTmp) 
	   {
		pptTmp++;
		if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
		else if(box.x2 < pptTmp->x) box.x2 = pptTmp->x;
		if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
		else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	    }
	}

	box.x2++;
	box.y2++;

	if(extra) 
	{
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->Polylines)(pDrawable, pGC, mode, npt, ppt);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolySegment(DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		nSeg,
		  xSegment	*pSeg)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (nSeg && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	    box;
	int	    extra = pGC->lineWidth;
	int	    nsegTmp = nSeg;
	xSegment    *pSegTmp = pSeg;

        if(pGC->capStyle != CapProjecting)
	   extra >>= 1;

	if(pSegTmp->x2 > pSegTmp->x1) {
	    box.x1 = pSegTmp->x1;
	    box.x2 = pSegTmp->x2;
	} else {
	    box.x2 = pSegTmp->x1;
	    box.x1 = pSegTmp->x2;
	}

	if(pSegTmp->y2 > pSegTmp->y1) {
	    box.y1 = pSegTmp->y1;
	    box.y2 = pSegTmp->y2;
	} else {
	    box.y2 = pSegTmp->y1;
	    box.y1 = pSegTmp->y2;
	}

	while(--nsegTmp) 
	{
	    pSegTmp++;
	    if(pSegTmp->x2 > pSegTmp->x1) 
	    {
		if(pSegTmp->x1 < box.x1) box.x1 = pSegTmp->x1;
		if(pSegTmp->x2 > box.x2) box.x2 = pSegTmp->x2;
	    }
	    else 
	    {
		if(pSegTmp->x2 < box.x1) box.x1 = pSegTmp->x2;
		if(pSegTmp->x1 > box.x2) box.x2 = pSegTmp->x1;
	    }
	    if(pSegTmp->y2 > pSegTmp->y1) 
	    {
		if(pSegTmp->y1 < box.y1) box.y1 = pSegTmp->y1;
		if(pSegTmp->y2 > box.y2) box.y2 = pSegTmp->y2;
	    }
	    else
	    {
		if(pSegTmp->y2 < box.y1) box.y1 = pSegTmp->y2;
		if(pSegTmp->y1 > box.y2) box.y2 = pSegTmp->y1;
	    }
	}

	box.x2++;
	box.y2++;

	if(extra) 
	{
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolySegment)(pDrawable, pGC, nSeg, pSeg);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolyRectangle(DrawablePtr  pDrawable,
		    GCPtr        pGC,
		    int	         nRects,
		    xRectangle  *pRects)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (nRects && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	    box;
	int	    offset1, offset2, offset3;
	int	    nRectsTmp = nRects;
	xRectangle  *pRectsTmp = pRects;

	offset2 = pGC->lineWidth;
	if(!offset2) offset2 = 1;
	offset1 = offset2 >> 1;
	offset3 = offset2 - offset1;

	while(nRectsTmp--)
	{
	    box.x1 = pRectsTmp->x - offset1;
	    box.y1 = pRectsTmp->y - offset1;
	    box.x2 = box.x1 + pRectsTmp->width + offset2;
	    box.y2 = box.y1 + offset2;
	    TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	    if(BOX_NOT_EMPTY(box))
		damageDamageBox (pDrawable, &box, pGC->subWindowMode);

	    box.x1 = pRectsTmp->x - offset1;
	    box.y1 = pRectsTmp->y + offset3;
	    box.x2 = box.x1 + offset2;
	    box.y2 = box.y1 + pRectsTmp->height - offset2;
	    TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	    if(BOX_NOT_EMPTY(box))
		damageDamageBox (pDrawable, &box, pGC->subWindowMode);

	    box.x1 = pRectsTmp->x + pRectsTmp->width - offset1;
	    box.y1 = pRectsTmp->y + offset3;
	    box.x2 = box.x1 + offset2;
	    box.y2 = box.y1 + pRectsTmp->height - offset2;
	    TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	    if(BOX_NOT_EMPTY(box))
		damageDamageBox (pDrawable, &box, pGC->subWindowMode);

	    box.x1 = pRectsTmp->x - offset1;
	    box.y1 = pRectsTmp->y + pRectsTmp->height - offset1;
	    box.x2 = box.x1 + pRectsTmp->width + offset2;
	    box.y2 = box.y1 + offset2;
	    TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	    if(BOX_NOT_EMPTY(box))
		damageDamageBox (pDrawable, &box, pGC->subWindowMode);

	    pRectsTmp++;
	}
    }
    (*pGC->ops->PolyRectangle)(pDrawable, pGC, nRects, pRects);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolyArc(DrawablePtr   pDrawable,
	      GCPtr	    pGC,
	      int	    nArcs,
	      xArc	    *pArcs)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (nArcs && checkGCDamage (pDrawable, pGC))
    {
	int	extra = pGC->lineWidth >> 1;
	BoxRec	box;
	int	nArcsTmp = nArcs;
	xArc	*pArcsTmp = pArcs;

	box.x1 = pArcsTmp->x;
	box.x2 = box.x1 + pArcsTmp->width;
	box.y1 = pArcsTmp->y;
	box.y2 = box.y1 + pArcsTmp->height;

	while(--nArcsTmp) 
	{
	    pArcsTmp++;
	    if(box.x1 > pArcsTmp->x)
		box.x1 = pArcsTmp->x;
	    if(box.x2 < (pArcsTmp->x + pArcsTmp->width))
		box.x2 = pArcsTmp->x + pArcsTmp->width;
	    if(box.y1 > pArcsTmp->y) 
		box.y1 = pArcsTmp->y;
	    if(box.y2 < (pArcsTmp->y + pArcsTmp->height))
		box.y2 = pArcsTmp->y + pArcsTmp->height;
        }

	if(extra) 
	{
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolyArc)(pDrawable, pGC, nArcs, pArcs);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageFillPolygon(DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		shape,
		  int		mode,
		  int		npt,
		  DDXPointPtr	ppt)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt > 2 && checkGCDamage (pDrawable, pGC))
    {
	DDXPointPtr pptTmp = ppt;
	int	    nptTmp = npt;
	BoxRec	    box;

	box.x2 = box.x1 = pptTmp->x;
	box.y2 = box.y1 = pptTmp->y;

	if(mode != CoordModeOrigin) 
	{
	   int x = box.x1;
	   int y = box.y1;
	   while(--nptTmp) 
	   {
		pptTmp++;
		x += pptTmp->x;
		y += pptTmp->y;
		if(box.x1 > x) box.x1 = x;
		else if(box.x2 < x) box.x2 = x;
		if(box.y1 > y) box.y1 = y;
		else if(box.y2 < y) box.y2 = y;
	    }
	}
	else 
	{
	   while(--nptTmp) 
	   {
		pptTmp++;
		if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
		else if(box.x2 < pptTmp->x) box.x2 = pptTmp->x;
		if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
		else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	    }
	}

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    
    (*pGC->ops->FillPolygon)(pDrawable, pGC, shape, mode, npt, ppt);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}


static void
damagePolyFillRect(DrawablePtr	pDrawable,
		   GCPtr	pGC,
		   int		nRects,
		   xRectangle	*pRects)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    if (nRects && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	    box;
	xRectangle  *pRectsTmp = pRects;
	int	    nRectsTmp = nRects;

	box.x1 = pRectsTmp->x;
	box.x2 = box.x1 + pRectsTmp->width;
	box.y1 = pRectsTmp->y;
	box.y2 = box.y1 + pRectsTmp->height;

	while(--nRectsTmp) 
	{
	    pRectsTmp++;
	    if(box.x1 > pRectsTmp->x) box.x1 = pRectsTmp->x;
	    if(box.x2 < (pRectsTmp->x + pRectsTmp->width))
		box.x2 = pRectsTmp->x + pRectsTmp->width;
	    if(box.y1 > pRectsTmp->y) box.y1 = pRectsTmp->y;
	    if(box.y2 < (pRectsTmp->y + pRectsTmp->height))
		box.y2 = pRectsTmp->y + pRectsTmp->height;
	}

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	    damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolyFillRect)(pDrawable, pGC, nRects, pRects);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}


static void
damagePolyFillArc(DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		nArcs,
		  xArc		*pArcs)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (nArcs && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	box;
	int	nArcsTmp = nArcs;
	xArc	*pArcsTmp = pArcs;

	box.x1 = pArcsTmp->x;
	box.x2 = box.x1 + pArcsTmp->width;
	box.y1 = pArcsTmp->y;
	box.y2 = box.y1 + pArcsTmp->height;

	while(--nArcsTmp) 
	{
	    pArcsTmp++;
	    if(box.x1 > pArcsTmp->x)
		box.x1 = pArcsTmp->x;
	    if(box.x2 < (pArcsTmp->x + pArcsTmp->width))
		box.x2 = pArcsTmp->x + pArcsTmp->width;
	    if(box.y1 > pArcsTmp->y)
		box.y1 = pArcsTmp->y;
	    if(box.y2 < (pArcsTmp->y + pArcsTmp->height))
		box.y2 = pArcsTmp->y + pArcsTmp->height;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolyFillArc)(pDrawable, pGC, nArcs, pArcs);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

/*
 * general Poly/Image text function.  Extract glyph information,
 * compute bounding box and remove cursor if it is overlapped.
 */

static void
damageDamageChars (DrawablePtr	pDrawable,
		   FontPtr	font,
		   int		x,
		   int		y,
		   unsigned int	n,
		   CharInfoPtr	*charinfo,
		   Bool		imageblt,
		   int		subWindowMode)
{
    ExtentInfoRec   extents;
    BoxRec	    box;

    QueryGlyphExtents(font, charinfo, n, &extents);
    if (imageblt)
    {
	if (extents.overallWidth > extents.overallRight)
	    extents.overallRight = extents.overallWidth;
	if (extents.overallWidth < extents.overallLeft)
	    extents.overallLeft = extents.overallWidth;
	if (extents.overallLeft > 0)
	    extents.overallLeft = 0;
	if (extents.fontAscent > extents.overallAscent)
	    extents.overallAscent = extents.fontAscent;
	if (extents.fontDescent > extents.overallDescent)
	    extents.overallDescent = extents.fontDescent;
    }
    box.x1 = x + extents.overallLeft;
    box.y1 = y - extents.overallAscent;
    box.x2 = x + extents.overallRight;
    box.y2 = y + extents.overallDescent;
    damageDamageBox (pDrawable, &box, subWindowMode);
}

/*
 * values for textType:
 */
#define TT_POLY8   0
#define TT_IMAGE8  1
#define TT_POLY16  2
#define TT_IMAGE16 3

static int 
damageText (DrawablePtr	    pDrawable,
	    GCPtr	    pGC,
	    int		    x,
	    int		    y,
	    unsigned long   count,
	    char	    *chars,
	    FontEncoding    fontEncoding,
	    Bool	    textType)
{
    CharInfoPtr	    *charinfo;
    CharInfoPtr	    *info;
    unsigned long   i;
    unsigned int    n;
    int		    w;
    Bool	    imageblt;

    imageblt = (textType == TT_IMAGE8) || (textType == TT_IMAGE16);

    charinfo = malloc(count * sizeof(CharInfoPtr));
    if (!charinfo)
	return x;

    GetGlyphs(pGC->font, count, (unsigned char *)chars,
	      fontEncoding, &i, charinfo);
    n = (unsigned int)i;
    w = 0;
    if (!imageblt)
	for (info = charinfo; i--; info++)
	    w += (*info)->metrics.characterWidth;

    if (n != 0) {
	damageDamageChars (pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y, n,
			   charinfo, imageblt, pGC->subWindowMode);
	if (imageblt)
	    (*pGC->ops->ImageGlyphBlt)(pDrawable, pGC, x, y, n, charinfo,
				       FONTGLYPHS(pGC->font));
	else
	    (*pGC->ops->PolyGlyphBlt)(pDrawable, pGC, x, y, n, charinfo,
				      FONTGLYPHS(pGC->font));
    }
    free(charinfo);
    return x + w;
}

static int
damagePolyText8(DrawablePtr pDrawable,
		GCPtr	    pGC,
		int	    x,
		int	    y,
		int	    count,
		char	    *chars)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (checkGCDamage (pDrawable, pGC))
	x = damageText (pDrawable, pGC, x, y, (unsigned long) count, chars,
		    Linear8Bit, TT_POLY8);
    else
	x = (*pGC->ops->PolyText8)(pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
    return x;
}

static int
damagePolyText16(DrawablePtr	pDrawable,
		 GCPtr		pGC,
		 int		x,
		 int		y,
		 int		count,
		 unsigned short	*chars)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (checkGCDamage (pDrawable, pGC))
	x = damageText (pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
		    FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
		    TT_POLY16);
    else
	x = (*pGC->ops->PolyText16)(pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
    return x;
}

static void
damageImageText8(DrawablePtr	pDrawable,
		 GCPtr		pGC,
		 int		x,
		 int		y,
		 int		count,
		 char		*chars)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (checkGCDamage (pDrawable, pGC))
	damageText (pDrawable, pGC, x, y, (unsigned long) count, chars,
		    Linear8Bit, TT_IMAGE8);
    else
	(*pGC->ops->ImageText8)(pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageImageText16(DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		x,
		  int		y,
		  int		count,
		  unsigned short *chars)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (checkGCDamage (pDrawable, pGC))
	damageText (pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
		    FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
		    TT_IMAGE16);
    else
	(*pGC->ops->ImageText16)(pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}


static void
damageImageGlyphBlt(DrawablePtr	    pDrawable,
		    GCPtr	    pGC,
		    int		    x,
		    int		    y,
		    unsigned int    nglyph,
		    CharInfoPtr	    *ppci,
		    pointer	    pglyphBase)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    damageDamageChars (pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y,
		       nglyph, ppci, TRUE, pGC->subWindowMode);
    (*pGC->ops->ImageGlyphBlt)(pDrawable, pGC, x, y, nglyph,
					ppci, pglyphBase);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolyGlyphBlt(DrawablePtr	pDrawable,
		   GCPtr	pGC,
		   int		x,
		   int		y,
		   unsigned int	nglyph,
		   CharInfoPtr	*ppci,
		   pointer	pglyphBase)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    damageDamageChars (pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y,
		       nglyph, ppci, FALSE, pGC->subWindowMode);
    (*pGC->ops->PolyGlyphBlt)(pDrawable, pGC, x, y, nglyph,
				ppci, pglyphBase);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePushPixels(GCPtr		pGC,
		 PixmapPtr	pBitMap,
		 DrawablePtr	pDrawable,
		 int		dx,
		 int		dy,
		 int		xOrg,
		 int		yOrg)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    if(checkGCDamage (pDrawable, pGC))
    {
	BoxRec box;

        box.x1 = xOrg;
        box.y1 = yOrg;

        if(!pGC->miTranslate) {
           box.x1 += pDrawable->x;          
           box.y1 += pDrawable->y;          
        }

	box.x2 = box.x1 + dx;
	box.y2 = box.y1 + dy;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PushPixels)(pGC, pBitMap, pDrawable, dx, dy, xOrg, yOrg);
    damageRegionProcessPending (pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageRemoveDamage (DamagePtr *pPrev, DamagePtr pDamage)
{
    while (*pPrev)
    {
	if (*pPrev == pDamage)
	{
	    *pPrev = pDamage->pNext;
	    return;
	}
	pPrev = &(*pPrev)->pNext;
    }
#if DAMAGE_VALIDATE_ENABLE
    ErrorF ("Damage not on list\n");
    OsAbort ();
#endif
}

static void
damageInsertDamage (DamagePtr *pPrev, DamagePtr pDamage)
{
#if DAMAGE_VALIDATE_ENABLE
    DamagePtr	pOld;

    for (pOld = *pPrev; pOld; pOld = pOld->pNext)
	if (pOld == pDamage) {
	    ErrorF ("Damage already on list\n");
	    OsAbort ();
	}
#endif
    pDamage->pNext = *pPrev;
    *pPrev = pDamage;
}

static Bool
damageDestroyPixmap (PixmapPtr pPixmap)
{
    ScreenPtr	pScreen = pPixmap->drawable.pScreen;
    damageScrPriv(pScreen);

    if (pPixmap->refcnt == 1)
    {
	DamagePtr	*pPrev = getPixmapDamageRef (pPixmap);
	DamagePtr	pDamage;

	while ((pDamage = *pPrev))
	{
	    damageRemoveDamage (pPrev, pDamage);
	    if (!pDamage->isWindow)
		DamageDestroy (pDamage);
	}
    }
    unwrap (pScrPriv, pScreen, DestroyPixmap);
    (*pScreen->DestroyPixmap) (pPixmap);
    wrap (pScrPriv, pScreen, DestroyPixmap, damageDestroyPixmap);
    return TRUE;
}

static void
damageCopyWindow(WindowPtr	pWindow,
		 DDXPointRec	ptOldOrg,
		 RegionPtr	prgnSrc)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    damageScrPriv(pScreen);

    if (getWindowDamage (pWindow))
    {
	int dx = pWindow->drawable.x - ptOldOrg.x;
	int dy = pWindow->drawable.y - ptOldOrg.y;
	
	/*
	 * The region comes in source relative, but the damage occurs
	 * at the destination location.  Translate back and forth.
	 */
	RegionTranslate(prgnSrc, dx, dy);
	damageRegionAppend (&pWindow->drawable, prgnSrc, FALSE, -1);
	RegionTranslate(prgnSrc, -dx, -dy);
    }
    unwrap (pScrPriv, pScreen, CopyWindow);
    (*pScreen->CopyWindow) (pWindow, ptOldOrg, prgnSrc);
    damageRegionProcessPending (&pWindow->drawable);
    wrap (pScrPriv, pScreen, CopyWindow, damageCopyWindow);
}

static GCOps damageGCOps = {
    damageFillSpans, damageSetSpans,
    damagePutImage, damageCopyArea,
    damageCopyPlane, damagePolyPoint,
    damagePolylines, damagePolySegment,
    damagePolyRectangle, damagePolyArc,
    damageFillPolygon, damagePolyFillRect,
    damagePolyFillArc, damagePolyText8,
    damagePolyText16, damageImageText8,
    damageImageText16, damageImageGlyphBlt,
    damagePolyGlyphBlt, damagePushPixels,
};

static void
damageSetWindowPixmap (WindowPtr pWindow, PixmapPtr pPixmap)
{
    DamagePtr	pDamage;
    ScreenPtr	pScreen = pWindow->drawable.pScreen;
    damageScrPriv(pScreen);

    if ((pDamage = damageGetWinPriv(pWindow)))
    {
	PixmapPtr   pOldPixmap = (*pScreen->GetWindowPixmap) (pWindow);
	DamagePtr   *pPrev = getPixmapDamageRef(pOldPixmap);
	
	while (pDamage)
	{
	    damageRemoveDamage (pPrev, pDamage);
	    pDamage = pDamage->pNextWin;
	}
    }
    unwrap (pScrPriv, pScreen, SetWindowPixmap);
    (*pScreen->SetWindowPixmap) (pWindow, pPixmap);
    wrap (pScrPriv, pScreen, SetWindowPixmap, damageSetWindowPixmap);
    if ((pDamage = damageGetWinPriv(pWindow)))
    {
	DamagePtr   *pPrev = getPixmapDamageRef(pPixmap);
	
	while (pDamage)
	{
	    damageInsertDamage (pPrev, pDamage);
	    pDamage = pDamage->pNextWin;
	}
    }
}

static Bool
damageDestroyWindow (WindowPtr pWindow)
{
    DamagePtr	pDamage;
    ScreenPtr	pScreen = pWindow->drawable.pScreen;
    Bool	ret;
    damageScrPriv(pScreen);

    while ((pDamage = damageGetWinPriv(pWindow)))
    {
	DamageUnregister (&pWindow->drawable, pDamage);
	DamageDestroy (pDamage);
    }
    unwrap (pScrPriv, pScreen, DestroyWindow);
    ret = (*pScreen->DestroyWindow) (pWindow);
    wrap (pScrPriv, pScreen, DestroyWindow, damageDestroyWindow);
    return ret;
}

static Bool
damageCloseScreen (int i, ScreenPtr pScreen)
{
    damageScrPriv(pScreen);

    unwrap (pScrPriv, pScreen, DestroyPixmap);
    unwrap (pScrPriv, pScreen, CreateGC);
    unwrap (pScrPriv, pScreen, CopyWindow);
    unwrap (pScrPriv, pScreen, CloseScreen);
    free(pScrPriv);
    return (*pScreen->CloseScreen) (i, pScreen);
}

/**
 * Default implementations of the damage management functions.
 */
void miDamageCreate (DamagePtr pDamage)
{
}

void miDamageRegister (DrawablePtr pDrawable, DamagePtr pDamage)
{
}

void miDamageUnregister (DrawablePtr pDrawable, DamagePtr pDamage)
{
}

void miDamageDestroy (DamagePtr pDamage)
{
}

/**
 * Public functions for consumption outside this file.
 */

Bool
DamageSetup (ScreenPtr pScreen)
{
    DamageScrPrivPtr	pScrPriv;
    PictureScreenPtr	ps = GetPictureScreenIfSet(pScreen);
    const DamageScreenFuncsRec miFuncs = {
	miDamageCreate, miDamageRegister, miDamageUnregister, miDamageDestroy
    };

    if (!dixRegisterPrivateKey(&damageScrPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;

    if (dixLookupPrivate(&pScreen->devPrivates, damageScrPrivateKey))
	return TRUE;

    if (!dixRegisterPrivateKey(&damageGCPrivateKeyRec, PRIVATE_GC, sizeof(DamageGCPrivRec)))
	return FALSE;

    if (!dixRegisterPrivateKey(&damagePixPrivateKeyRec, PRIVATE_PIXMAP, 0))
	return FALSE;

    if (!dixRegisterPrivateKey(&damageWinPrivateKeyRec, PRIVATE_WINDOW, 0))
	return FALSE;

    pScrPriv = malloc(sizeof (DamageScrPrivRec));
    if (!pScrPriv)
	return FALSE;

    pScrPriv->internalLevel = 0;
    pScrPriv->pScreenDamage = 0;

    wrap (pScrPriv, pScreen, DestroyPixmap, damageDestroyPixmap);
    wrap (pScrPriv, pScreen, CreateGC, damageCreateGC);
    wrap (pScrPriv, pScreen, DestroyWindow, damageDestroyWindow);
    wrap (pScrPriv, pScreen, SetWindowPixmap, damageSetWindowPixmap);
    wrap (pScrPriv, pScreen, CopyWindow, damageCopyWindow);
    wrap (pScrPriv, pScreen, CloseScreen, damageCloseScreen);
    if (ps) {
	wrap (pScrPriv, ps, Glyphs, damageGlyphs);
	wrap (pScrPriv, ps, Composite, damageComposite);
	wrap (pScrPriv, ps, AddTraps, damageAddTraps);
    }

    pScrPriv->funcs = miFuncs;

    dixSetPrivate(&pScreen->devPrivates, damageScrPrivateKey, pScrPriv);
    return TRUE;
}

DamagePtr
DamageCreate (DamageReportFunc  damageReport,
	      DamageDestroyFunc	damageDestroy,
	      DamageReportLevel	damageLevel,
	      Bool		isInternal,
	      ScreenPtr		pScreen,
	      void		*closure)
{
    damageScrPriv(pScreen);
    DamagePtr	pDamage;

    pDamage = dixAllocateObjectWithPrivates(DamageRec, PRIVATE_DAMAGE);
    if (!pDamage)
	return 0;
    pDamage->pNext = 0;
    pDamage->pNextWin = 0;
    RegionNull(&pDamage->damage);
    RegionNull(&pDamage->pendingDamage);
    
    pDamage->damageLevel = damageLevel;
    pDamage->isInternal = isInternal;
    pDamage->closure = closure;
    pDamage->isWindow = FALSE;
    pDamage->pDrawable = 0;
    pDamage->reportAfter = FALSE;

    pDamage->damageReport = damageReport;
    pDamage->damageReportPostRendering = NULL;
    pDamage->damageDestroy = damageDestroy;
    pDamage->damageMarker = NULL;
    pDamage->pScreen = pScreen;

    (*pScrPriv->funcs.Create) (pDamage);

    return pDamage;
}

void
DamageRegister (DrawablePtr pDrawable,
		DamagePtr   pDamage)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    damageScrPriv(pScreen);

#if DAMAGE_VALIDATE_ENABLE
    if (pDrawable->pScreen != pDamage->pScreen)
    {
	ErrorF ("DamageRegister called with mismatched screens\n");
	OsAbort ();
    }
#endif

    if (pDrawable->type == DRAWABLE_WINDOW)
    {
	WindowPtr   pWindow = (WindowPtr) pDrawable;
	winDamageRef(pWindow);

#if DAMAGE_VALIDATE_ENABLE
	DamagePtr   pOld;
	
	for (pOld = *pPrev; pOld; pOld = pOld->pNextWin)
	    if (pOld == pDamage) {
		ErrorF ("Damage already on window list\n");
		OsAbort ();
	    }
#endif
	pDamage->pNextWin = *pPrev;
	*pPrev = pDamage;
	pDamage->isWindow = TRUE;
    }
    else
	pDamage->isWindow = FALSE;
    pDamage->pDrawable = pDrawable;
    damageInsertDamage (getDrawableDamageRef (pDrawable), pDamage);
    (*pScrPriv->funcs.Register) (pDrawable, pDamage);
}

void
DamageDrawInternal (ScreenPtr pScreen, Bool enable)
{
    damageScrPriv (pScreen);

    pScrPriv->internalLevel += enable ? 1 : -1;
}

void
DamageUnregister (DrawablePtr	    pDrawable,
		  DamagePtr	    pDamage)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    damageScrPriv(pScreen);

    (*pScrPriv->funcs.Unregister) (pDrawable, pDamage);

    if (pDrawable->type == DRAWABLE_WINDOW)
    {
	WindowPtr   pWindow = (WindowPtr) pDrawable;
	winDamageRef (pWindow);
#if DAMAGE_VALIDATE_ENABLE
	int	found = 0;
#endif

	while (*pPrev)
	{
	    if (*pPrev == pDamage)
	    {
		*pPrev = pDamage->pNextWin;
#if DAMAGE_VALIDATE_ENABLE
		found = 1;
#endif
		break;
	    }
	    pPrev = &(*pPrev)->pNextWin;
	}
#if DAMAGE_VALIDATE_ENABLE
	if (!found) {
	    ErrorF ("Damage not on window list\n");
	    OsAbort ();
	}
#endif
    }
    pDamage->pDrawable = 0;
    damageRemoveDamage (getDrawableDamageRef (pDrawable), pDamage);
}

void
DamageDestroy (DamagePtr    pDamage)
{
    ScreenPtr pScreen = pDamage->pScreen;
    damageScrPriv(pScreen);

    if (pDamage->damageDestroy)
	(*pDamage->damageDestroy) (pDamage, pDamage->closure);
    (*pScrPriv->funcs.Destroy) (pDamage);
    RegionUninit(&pDamage->damage);
    RegionUninit(&pDamage->pendingDamage);
    dixFreeObjectWithPrivates(pDamage, PRIVATE_DAMAGE);
}

Bool
DamageSubtract (DamagePtr	    pDamage,
		const RegionPtr	    pRegion)
{
    RegionPtr	pClip;
    RegionRec	pixmapClip;
    DrawablePtr	pDrawable = pDamage->pDrawable;
    
    RegionSubtract(&pDamage->damage, &pDamage->damage, pRegion);
    if (pDrawable)
    {
	if (pDrawable->type == DRAWABLE_WINDOW)
	    pClip = &((WindowPtr) pDrawable)->borderClip;
	else
	{
	    BoxRec  box;

	    box.x1 = pDrawable->x;
	    box.y1 = pDrawable->y;
	    box.x2 = pDrawable->x + pDrawable->width;
	    box.y2 = pDrawable->y + pDrawable->height;
	    RegionInit(&pixmapClip, &box, 1);
	    pClip = &pixmapClip;
	}
	RegionTranslate(&pDamage->damage, pDrawable->x, pDrawable->y);
	RegionIntersect(&pDamage->damage, &pDamage->damage, pClip);
	RegionTranslate(&pDamage->damage, -pDrawable->x, -pDrawable->y);
	if (pDrawable->type != DRAWABLE_WINDOW)
	    RegionUninit(&pixmapClip);
    }
    return RegionNotEmpty(&pDamage->damage);
}

void
DamageEmpty (DamagePtr	    pDamage)
{
    RegionEmpty(&pDamage->damage);
}

RegionPtr
DamageRegion (DamagePtr		    pDamage)
{
    return &pDamage->damage;
}

RegionPtr
DamagePendingRegion (DamagePtr	    pDamage)
{
    return &pDamage->pendingDamage;
}

void
DamageRegionAppend (DrawablePtr pDrawable, RegionPtr pRegion)
{
    damageRegionAppend (pDrawable, pRegion, FALSE, -1);
}

void
DamageRegionProcessPending (DrawablePtr pDrawable)
{
    damageRegionProcessPending (pDrawable);
}

/* If a damage marker is provided, then this function must be called after rendering is done. */
/* Please do call back so any future enhancements can assume this function is called. */
/* There are no strict timing requirements for calling this function, just as soon as (is cheaply) possible. */
void
DamageRegionRendered (DrawablePtr pDrawable, DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pRegion)
{
    if (pDamage->damageReportPostRendering)
	damageReportDamagePostRendering (pDamage, pOldDamage, pRegion);
}

/* This call is very odd, i'm leaving it intact for API sake, but please don't use it. */
void
DamageDamageRegion (DrawablePtr	pDrawable,
		    RegionPtr	pRegion)
{
    damageRegionAppend (pDrawable, pRegion, FALSE, -1);

    /* Go back and report this damage for DamagePtrs with reportAfter set, since
     * this call isn't part of an in-progress drawing op in the call chain and
     * the DDX probably just wants to know about it right away.
     */
    damageRegionProcessPending (pDrawable);
}

void
DamageSetReportAfterOp (DamagePtr pDamage, Bool reportAfter)
{
    pDamage->reportAfter = reportAfter;
}

void
DamageSetPostRenderingFunctions(DamagePtr pDamage, DamageReportFunc damageReportPostRendering,
				DamageMarkerFunc damageMarker)
{
    pDamage->damageReportPostRendering = damageReportPostRendering;
    pDamage->damageMarker = damageMarker;
}

DamageScreenFuncsPtr
DamageGetScreenFuncs (ScreenPtr pScreen)
{
    damageScrPriv(pScreen);
    return &pScrPriv->funcs;
}

void
DamageReportDamage (DamagePtr pDamage, RegionPtr pDamageRegion)
{
    BoxRec tmpBox;
    RegionRec tmpRegion;
    Bool was_empty;

    switch (pDamage->damageLevel) {
    case DamageReportRawRegion:
	RegionUnion(&pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	(*pDamage->damageReport) (pDamage, pDamageRegion, pDamage->closure);
	break;
    case DamageReportDeltaRegion:
	RegionNull(&tmpRegion);
	RegionSubtract(&tmpRegion, pDamageRegion, &pDamage->damage);
	if (RegionNotEmpty(&tmpRegion)) {
	    RegionUnion(&pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	    (*pDamage->damageReport) (pDamage, &tmpRegion, pDamage->closure);
	}
	RegionUninit(&tmpRegion);
	break;
    case DamageReportBoundingBox:
	tmpBox = *RegionExtents(&pDamage->damage);
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	if (!BOX_SAME (&tmpBox, RegionExtents(&pDamage->damage))) {
	    (*pDamage->damageReport) (pDamage, &pDamage->damage,
				      pDamage->closure);
	}
	break;
    case DamageReportNonEmpty:
	was_empty = !RegionNotEmpty(&pDamage->damage);
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	if (was_empty && RegionNotEmpty(&pDamage->damage)) {
	    (*pDamage->damageReport) (pDamage, &pDamage->damage,
				      pDamage->closure);
	}
	break;
    case DamageReportNone:
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	break;
    }
}

/*
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _DAMAGE_H_
#define _DAMAGE_H_

typedef struct _damage	*DamagePtr;

typedef enum _damageReportLevel {
    DamageReportRawRegion,
    DamageReportDeltaRegion,
    DamageReportBoundingBox,
    DamageReportNonEmpty,
    DamageReportNone
} DamageReportLevel;

typedef void (*DamageReportFunc) (DamagePtr pDamage, RegionPtr pRegion, void *closure);
typedef void (*DamageDestroyFunc) (DamagePtr pDamage, void *closure);
/* It's the responsibility of the driver to duplicate both regions. */
/* At some point DamageRegionRendered() must be called. */
typedef void (*DamageMarkerFunc) (DrawablePtr pDrawable, DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pRegion, void *closure);

typedef void (*DamageScreenCreateFunc) (DamagePtr);
typedef void (*DamageScreenRegisterFunc) (DrawablePtr, DamagePtr);
typedef void (*DamageScreenUnregisterFunc) (DrawablePtr, DamagePtr);
typedef void (*DamageScreenDestroyFunc) (DamagePtr);

typedef struct _damageScreenFuncs {
    DamageScreenCreateFunc      Create;
    DamageScreenRegisterFunc    Register;
    DamageScreenUnregisterFunc  Unregister;
    DamageScreenDestroyFunc     Destroy;
} DamageScreenFuncsRec, *DamageScreenFuncsPtr;

extern _X_EXPORT void miDamageCreate (DamagePtr);
extern _X_EXPORT void miDamageRegister (DrawablePtr, DamagePtr);
extern _X_EXPORT void miDamageUnregister (DrawablePtr, DamagePtr);
extern _X_EXPORT void miDamageDestroy (DamagePtr);

extern _X_EXPORT Bool
DamageSetup (ScreenPtr pScreen);
    
extern _X_EXPORT DamagePtr
DamageCreate (DamageReportFunc  damageReport,
	      DamageDestroyFunc	damageDestroy,
	      DamageReportLevel damageLevel,
	      Bool		isInternal,
	      ScreenPtr		pScreen,
	      void *		closure);

extern _X_EXPORT void
DamageDrawInternal (ScreenPtr pScreen, Bool enable);

extern _X_EXPORT void
DamageRegister (DrawablePtr	pDrawable,
		DamagePtr	pDamage);

extern _X_EXPORT void
DamageUnregister (DrawablePtr	pDrawable,
		  DamagePtr	pDamage);

extern _X_EXPORT void
DamageDestroy (DamagePtr pDamage);

extern _X_EXPORT Bool
DamageSubtract (DamagePtr	    pDamage,
		const RegionPtr	    pRegion);

extern _X_EXPORT void
DamageEmpty (DamagePtr pDamage);

extern _X_EXPORT RegionPtr
DamageRegion (DamagePtr		    pDamage);

extern _X_EXPORT RegionPtr
DamagePendingRegion (DamagePtr	    pDamage);

/* In case of rendering, call this before the submitting the commands. */
extern _X_EXPORT void
DamageRegionAppend (DrawablePtr pDrawable, RegionPtr pRegion);

/* Call this directly after the rendering operation has been submitted. */
extern _X_EXPORT void
DamageRegionProcessPending (DrawablePtr pDrawable);

/* Call this some time after rendering is done, only relevant when a damageMarker is provided. */
extern _X_EXPORT void
DamageRegionRendered (DrawablePtr pDrawable, DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pRegion);

/* Call this when you create a new Damage and you wish to send an initial damage message (to it). */
extern _X_EXPORT void
DamageReportDamage (DamagePtr pDamage, RegionPtr pDamageRegion);

/* Avoid using this call, it only exists for API compatibility. */
extern _X_EXPORT void
DamageDamageRegion (DrawablePtr	    pDrawable,
		    const RegionPtr pRegion);

extern _X_EXPORT void
DamageSetReportAfterOp (DamagePtr pDamage, Bool reportAfter);

extern _X_EXPORT void
DamageSetPostRenderingFunctions(DamagePtr pDamage, DamageReportFunc damageReportPostRendering,
				DamageMarkerFunc damageMarker);

extern _X_EXPORT DamageScreenFuncsPtr
DamageGetScreenFuncs (ScreenPtr);

#endif /* _DAMAGE_H_ */
/*
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _DAMAGESTR_H_
#define _DAMAGESTR_H_

#include "damage.h"
#include "gcstruct.h"
#include "privates.h"
# include "picturestr.h"

typedef struct _damage {
    DamagePtr		pNext;
    DamagePtr		pNextWin;
    RegionRec		damage;
    
    DamageReportLevel	damageLevel;
    Bool		isInternal;
    void		*closure;
    Bool		isWindow;
    DrawablePtr		pDrawable;
    
    DamageReportFunc	damageReport;
    DamageReportFunc	damageReportPostRendering;
    DamageDestroyFunc	damageDestroy;
    DamageMarkerFunc	damageMarker;

    Bool		reportAfter;
    RegionRec		pendingDamage; /* will be flushed post submission at the latest */
    RegionRec		backupDamage; /* for use with damageMarker */
    ScreenPtr		pScreen;
    PrivateRec		*devPrivates;
} DamageRec;

typedef struct _damageScrPriv {
    int				internalLevel;

    /*
     * For DDXen which don't provide GetScreenPixmap, this provides
     * a place to hook damage for windows on the screen
     */
    DamagePtr			pScreenDamage;

    CopyWindowProcPtr		CopyWindow;
    CloseScreenProcPtr		CloseScreen;
    CreateGCProcPtr		CreateGC;
    DestroyPixmapProcPtr	DestroyPixmap;
    SetWindowPixmapProcPtr	SetWindowPixmap;
    DestroyWindowProcPtr	DestroyWindow;
    CompositeProcPtr		Composite;
    GlyphsProcPtr		Glyphs;
    AddTrapsProcPtr		AddTraps;

    /* Table of wrappable function pointers */
    DamageScreenFuncsRec	funcs;
} DamageScrPrivRec, *DamageScrPrivPtr;

typedef struct _damageGCPriv {
    GCOps   *ops;
    GCFuncs *funcs;
} DamageGCPrivRec, *DamageGCPrivPtr;

/* XXX should move these into damage.c, damageScrPrivateIndex is static */
#define damageGetScrPriv(pScr) ((DamageScrPrivPtr) \
    dixLookupPrivate(&(pScr)->devPrivates, damageScrPrivateKey))

#define damageScrPriv(pScr) \
    DamageScrPrivPtr    pScrPriv = damageGetScrPriv(pScr)

#define damageGetPixPriv(pPix) \
    dixLookupPrivate(&(pPix)->devPrivates, damagePixPrivateKey)

#define damgeSetPixPriv(pPix,v) \
    dixSetPrivate(&(pPix)->devPrivates, damagePixPrivateKey, v)

#define damagePixPriv(pPix) \
    DamagePtr	    pDamage = damageGetPixPriv(pPix)

#define damageGetGCPriv(pGC) \
    dixLookupPrivate(&(pGC)->devPrivates, damageGCPrivateKey)

#define damageGCPriv(pGC) \
    DamageGCPrivPtr  pGCPriv = damageGetGCPriv(pGC)

#define damageGetWinPriv(pWin) \
    ((DamagePtr)dixLookupPrivate(&(pWin)->devPrivates, damageWinPrivateKey))

#define damageSetWinPriv(pWin,d) \
    dixSetPrivate(&(pWin)->devPrivates, damageWinPrivateKey, d)

#endif /* _DAMAGESTR_H_ */
noinst_LTLIBRARIES = libdamage.la

AM_CFLAGS = $(DIX_CFLAGS)

INCLUDES = -I$(srcdir)/../cw

if XORG
sdk_HEADERS = damage.h damagestr.h
endif

libdamage_la_SOURCES =	\
	damage.c	\
	damage.h	\
	damagestr.h
SUBDIRS = sync damage shadow
if COMPOSITE
SUBDIRS += cw
endif
if XQUARTZ
SUBDIRS += rootless
endif
if XWIN_MULTIWINDOWEXTWM
SUBDIRS += rootless
endif
DIST_SUBDIRS = sync damage shadow cw rootless
AM_CFLAGS = $(DIX_CFLAGS) $(XSERVER_CFLAGS)

noinst_LTLIBRARIES = librootless.la
librootless_la_SOURCES = \
	rootlessCommon.c \
	rootlessGC.c \
	rootlessScreen.c \
	rootlessValTree.c \
	rootlessWindow.c

EXTRA_DIST = \
	README.txt \
	rootless.h \
	rootlessCommon.h \
	rootlessConfig.h \
	rootlessWindow.h 
                            Generic Rootless Layer
                                 Version 1.0
                                July 13, 2004

                               Torrey T. Lyons
                              torrey@xfree86.org


Introduction

        The generic rootless layer allows an X server to be implemented 
on top of another window server in a cooperative manner. This allows the 
X11 windows and native windows of the underlying window server to 
coexist on the same screen. The layer is called "rootless" because the root 
window of the X server is generally not drawn. Instead, each top-level 
child of the root window is represented as a separate on-screen window by 
the underlying window server. The layer is referred to as "generic" 
because it abstracts away the details of the underlying window system and 
contains code that is useful for any rootless X server. The code for the 
generic rootless layer is located in xc/programs/Xserver/miext/rootless. To 
build a complete rootless X server requires a specific rootless 
implementation, which provides functions that allow the generic rootless 
layer to interact with the underlying window system.


Concepts

        In the context of a rootless X server the term window is used to 
mean many fundamentally different things. For X11 a window is a DDX 
resource that describes a visible, or potentially visible, rectangle on the 
screen. A top-level window is a direct child of the root window. To avoid 
confusion, an on-screen native window of the underlying window system 
is referred to as a "frame". The generic rootless layer associates each 
mapped top-level X11 window with a frame. An X11 window may be said 
to be "framed" if it or its top-level parent is represented by a frame.

        The generic rootless layer models each frame as being backed at 
all times by a backing buffer, which is periodically flushed to the screen. 
If the underlying window system does not provide a backing buffer for 
frames, this must be done by the rootless implementation. The generic 
rootless layer model does not assume it always has access to the frames' 
backing buffers. Any drawing to the buffer will be proceeded by a call to 
the rootless implementation's StartDrawing() function and StopDrawing() 
will be called when the drawing is concluded. The address of the frame's 
backing buffer is returned by the StartDrawing() function and it can 
change between successive calls.

        Because each frame is assumed to have a backing buffer, the 
generic rootless layer will stop Expose events being generated when the 
regions of visibility of a frame change on screen. This is similar to backing 
store, but backing buffers are different in that they always store a copy of 
the entire window contents, not just the obscured portions. The price paid 
in increased memory consumption is made up by the greatly decreased 
complexity in not having to track and record regions as they are obscured.


Rootless Implementation

        The specifics of the underlying window system are provided to the 
generic rootless layer through rootless implementation functions, compile-
time options, and runtime parameters. The rootless implementation 
functions are a list of functions that allow the generic rootless layer to 
perform operations such as creating, destroying, moving, and resizing 
frames. Some of the implementation functions are optional. A detailed 
description of the rootless implementation functions is provided in 
Appendix A.

        By design, a rootless implementation should only have to include 
the rootless.h header file. The rootlessCommon.h file contains definitions 
internal to the generic rootless layer. (If you find you need to use 
rootlessCommon.h in your implementation, let the generic rootless layer 
maintainers know. This could be an area where the generic rootless layer 
should be generalized.) A rootless implementation should also modify 
rootlessConfig.h to specify compile time options for its platform.

        The following compile-time options are defined in 
rootlessConfig.h:

      o ROOTLESS_PROTECT_ALPHA: By default for a color bit depth of 24 and
        32 bits per pixel, fb will overwrite the "unused" 8 bits to optimize
        drawing speed. If this is true, the alpha channel of frames is
        protected and is not modified when drawing to them. The bits 
        containing the alpha channel are defined by the macro 
        RootlessAlphaMask(bpp), which should return a bit mask for 
        various bits per pixel.

      o ROOTLESS_REDISPLAY_DELAY: Time in milliseconds between updates to
        the underlying window server. Most operations will be buffered until
        this time has expired.

      o ROOTLESS_RESIZE_GRAVITY: If the underlying window system supports it,
        some frame resizes can be optimized by relying on the frame contents
        maintaining a particular gravity during the resize. In this way less
        of the frame contents need to be preserved by the generic rootless
        layer. If true, the generic rootless layer will pass gravity hints
        during resizing and rely on the frame contents being preserved
        accordingly.

        The following runtime options are defined in rootless.h:

      o rootlessGlobalOffsetX, rootlessGlobalOffsetY: These specify the global
        offset that is applied to all screens when converting from
        screen-local to global coordinates.

      o rootless_CopyBytes_threshold, rootless_CopyWindow_threshold:
        The minimum number of bytes or pixels for which to use the rootless
        implementation's respective acceleration function. The rootless
        acceleration functions are all optional so these will only be used
        if the respective acceleration function pointer is not NULL.


Accelerated Drawing

	The rootless implementation typically does not have direct access 
to the hardware. Its access to the graphics hardware is generally through 
the API of the underlying window system. This underlying API may not 
overlap well with the X11 drawing primitives. The generic rootless layer 
falls back to using fb for all its 2-D drawing. Providing optional rootless 
implementation acceleration functions can accelerate some graphics 
primitives and some window functions. Typically calling through to the 
underlying window systems API will not speed up these operations for 
small enough areas. The rootless_*_threshold runtime options allow the 
rootless implementation to provide hints for when the acceleration 
functions should be used instead of fb.


Alpha Channel Protection

	If the bits per pixel is greater then the color bit depth, the contents 
of the extra bits are undefined by the X11 protocol. Some window systems 
will use these extra bits as an alpha channel. The generic rootless layer can 
be configured to protect these bits and make sure they are not modified by 
other parts of the X server. To protect the alpha channel 
ROOTLESS_PROTECT_ALPHA and RootlessAlphaMask(bpp) must be 
set appropriately as described under the compile time options. This 
ensures that the X11 graphics primitives do not overwrite the alpha 
channel in an attempt to optimize drawing. In addition, the window 
functions PaintWindow() and Composite() must be replaced by alpha 
channel safe variants. These are provided in rootless/safeAlpha.


Credits

	The generic rootless layer was originally conceived and developed 
by Greg Parker as part of the XDarwin X server on Mac OS X. John 
Harper made later optimizations to this code but removed its generic 
independence of the underlying window system. Torrey T. Lyons 
reintroduced the generic abstractions and made the rootless code suitable 
for use by other X servers.


Appendix A: Rootless Implementation Functions

	The rootless implementation functions are defined in rootless.h. It 
is intended that rootless.h contains the complete interface that is needed by 
rootless implementations. The definitions contained in rootlessCommon.h 
are intended for internal use by the generic rootless layer and are more 
likely to change.

	Most of these functions take a RootlessFrameID as a parameter. 
The RootlessFrameID is an opaque object that is returned by the 
implementation's CreateFrame() function. The generic rootless layer does 
not use this frame id other than to pass it back to the rootless 
implementation to indicate the frame to operate on.

/*
 * Create a new frame.
 *  The frame is created unmapped.
 *
 *  pFrame      RootlessWindowPtr for this frame should be completely
 *              initialized before calling except for pFrame->wid, which
 *              is set by this function.
 *  pScreen     Screen on which to place the new frame
 *  newX, newY  Position of the frame.
 *  pNewShape   Shape for the frame (in frame-local coordinates). NULL for
 *              unshaped frames.
 */
typedef Bool (*RootlessCreateFrameProc)
    (RootlessWindowPtr pFrame, ScreenPtr pScreen, int newX, int newY,
     RegionPtr pNewShape);

/*
 * Destroy a frame.
 *  Drawing is stopped and all updates are flushed before this is called.
 *
 *  wid         Frame id
 */
typedef void (*RootlessDestroyFrameProc)
    (RootlessFrameID wid);

/*
 * Move a frame on screen.
 *  Drawing is stopped and all updates are flushed before this is called.
 *
 *  wid         Frame id
 *  pScreen     Screen to move the new frame to
 *  newX, newY  New position of the frame
 */
typedef void (*RootlessMoveFrameProc) 
    (RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY);

/*
 * Resize and move a frame.
 *  Drawing is stopped and all updates are flushed before this is called.
 *
 *  wid         Frame id
 *  pScreen     Screen to move the new frame to
 *  newX, newY  New position of the frame
 *  newW, newH  New size of the frame
 *  gravity     Gravity for window contents (rl_gravity_enum). This is always
 *              RL_GRAVITY_NONE unless ROOTLESS_RESIZE_GRAVITY is set.
 */
typedef void (*RootlessResizeFrameProc)
    (RootlessFrameID wid, ScreenPtr pScreen,
     int newX, int newY, unsigned int newW, unsigned int newH,
     unsigned int gravity);

/*
 * Change frame ordering (AKA stacking, layering).
 *  Drawing is stopped before this is called. Unmapped frames are mapped by
 *  setting their ordering.
 *
 *  wid         Frame id
 *  nextWid     Frame id of frame that is now above this one or NULL if this
 *              frame is at the top.
 */
typedef void (*RootlessRestackFrameProc)
    (RootlessFrameID wid, RootlessFrameID nextWid);

/*
 * Change frame's shape.
 *  Drawing is stopped before this is called.
 *
 *  wid         Frame id
 *  pNewShape   New shape for the frame (in frame-local coordinates)
 *              or NULL if now unshaped.
 */
typedef void (*RootlessReshapeFrameProc)
    (RootlessFrameID wid, RegionPtr pNewShape);

/*
 * Unmap a frame.
 *
 *  wid         Frame id
 */
typedef void (*RootlessUnmapFrameProc)
    (RootlessFrameID wid);

/*
 * Start drawing to a frame.
 *  Prepare a frame for direct access to its backing buffer.
 *
 *  wid         Frame id
 *  pixelData   Address of the backing buffer (returned)
 *  bytesPerRow Width in bytes of the backing buffer (returned)
 */
typedef void (*RootlessStartDrawingProc)
    (RootlessFrameID wid, char **pixelData, int *bytesPerRow);

/*
 * Stop drawing to a frame.
 *  No drawing to the frame's backing buffer will occur until drawing
 *  is started again.
 *
 *  wid         Frame id
 *  flush       Flush drawing updates for this frame to the screen.
 */
typedef void (*RootlessStopDrawingProc)
    (RootlessFrameID wid, Bool flush);

/*
 * Flush drawing updates to the screen.
 *  Drawing is stopped before this is called.
 *
 *  wid         Frame id
 *  pDamage     Region containing all the changed pixels in frame-local
 *              coordinates. This is clipped to the window's clip.
 */
typedef void (*RootlessUpdateRegionProc)
    (RootlessFrameID wid, RegionPtr pDamage);

/*
 * Mark damaged rectangles as requiring redisplay to screen.
 *
 *  wid         Frame id
 *  nrects      Number of damaged rectangles
 *  rects       Array of damaged rectangles in frame-local coordinates
 *  shift_x,    Vector to shift rectangles by
 *   shift_y
 */
typedef void (*RootlessDamageRectsProc)
    (RootlessFrameID wid, int nrects, const BoxRec *rects,
     int shift_x, int shift_y);

/*
 * Switch the window associated with a frame. (Optional)
 *  When a framed window is reparented, the frame is resized and set to
 *  use the new top-level parent. If defined this function will be called
 *  afterwards for implementation specific bookkeeping.
 *
 *  pFrame      Frame whose window has switched
 *  oldWin      Previous window wrapped by this frame
 */
typedef void (*RootlessSwitchWindowProc)
    (RootlessWindowPtr pFrame, WindowPtr oldWin);

/*
 * Copy bytes. (Optional)
 *  Source and destinate may overlap and the right thing should happen.
 *
 *  width       Bytes to copy per row
 *  height      Number of rows
 *  src         Source data
 *  srcRowBytes Width of source in bytes
 *  dst         Destination data
 *  dstRowBytes Width of destination in bytes
 */
typedef void (*RootlessCopyBytesProc)
    (unsigned int width, unsigned int height,
     const void *src, unsigned int srcRowBytes,
     void *dst, unsigned int dstRowBytes);

/*
 * Copy area in frame to another part of frame. (Optional)
 *
 *  wid         Frame id
 *  dstNrects   Number of rectangles to copy
 *  dstRects    Array of rectangles to copy
 *  dx, dy      Number of pixels away to copy area
 */
typedef void (*RootlessCopyWindowProc)
    (RootlessFrameID wid, int dstNrects, const BoxRec *dstRects,
     int dx, int dy);

/*
 * External interface to generic rootless mode
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 * Copyright (c) 2002-2003 Torrey T. Lyons. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _ROOTLESS_H
#define _ROOTLESS_H

#include "rootlessConfig.h"
#include "mi.h"
#include "gcstruct.h"

/*
   Each top-level rootless window has a one-to-one correspondence to a physical
   on-screen window. The physical window is refered to as a "frame".
 */

typedef void * RootlessFrameID;

/*
 * RootlessWindowRec
 *  This structure stores the per-frame data used by the rootless code.
 *  Each top-level X window has one RootlessWindowRec associated with it.
 */
typedef struct _RootlessWindowRec {
    // Position and size includes the window border
    // Position is in per-screen coordinates
    int x, y;
    unsigned int width, height;
    unsigned int borderWidth;
    int level;

    RootlessFrameID wid;	// implementation specific frame id
    WindowPtr win;		// underlying X window

    // Valid only when drawing (ie. is_drawing is set)
    char *pixelData;
    int bytesPerRow;

    PixmapPtr pixmap;

    unsigned int is_drawing :1;	// Currently drawing?
    unsigned int is_reorder_pending :1;
    unsigned int is_offscreen :1;
    unsigned int is_obscured :1;
} RootlessWindowRec, *RootlessWindowPtr;


/* Offset for screen-local to global coordinate transforms */
extern int rootlessGlobalOffsetX;
extern int rootlessGlobalOffsetY;

/* The minimum number of bytes or pixels for which to use the
   implementation's accelerated functions. */
extern unsigned int rootless_CopyBytes_threshold;
extern unsigned int rootless_CopyWindow_threshold;

/* Gravity for window contents during resizing */
enum rl_gravity_enum {
    RL_GRAVITY_NONE             = 0,	/* no gravity, fill everything */
    RL_GRAVITY_NORTH_WEST       = 1,	/* anchor to top-left corner */
    RL_GRAVITY_NORTH_EAST       = 2,	/* anchor to top-right corner */
    RL_GRAVITY_SOUTH_EAST       = 3,	/* anchor to bottom-right corner */
    RL_GRAVITY_SOUTH_WEST       = 4,	/* anchor to bottom-left corner */
};


/*------------------------------------------
   Rootless Implementation Functions
  ------------------------------------------*/

/*
 * Create a new frame.
 *  The frame is created unmapped.
 *
 *  pFrame      RootlessWindowPtr for this frame should be completely
 *              initialized before calling except for pFrame->wid, which
 *              is set by this function.
 *  pScreen     Screen on which to place the new frame
 *  newX, newY  Position of the frame.
 *  pNewShape   Shape for the frame (in frame-local coordinates). NULL for
 *              unshaped frames.
 */
typedef Bool (*RootlessCreateFrameProc)
    (RootlessWindowPtr pFrame, ScreenPtr pScreen, int newX, int newY,
     RegionPtr pNewShape);

/*
 * Destroy a frame.
 *  Drawing is stopped and all updates are flushed before this is called.
 *
 *  wid         Frame id
 */
typedef void (*RootlessDestroyFrameProc)
    (RootlessFrameID wid);

/*
 * Move a frame on screen.
 *  Drawing is stopped and all updates are flushed before this is called.
 *
 *  wid         Frame id
 *  pScreen     Screen to move the new frame to
 *  newX, newY  New position of the frame
 */
typedef void (*RootlessMoveFrameProc) 
    (RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY);

/*
 * Resize and move a frame.
 *  Drawing is stopped and all updates are flushed before this is called.
 *
 *  wid         Frame id
 *  pScreen     Screen to move the new frame to
 *  newX, newY  New position of the frame
 *  newW, newH  New size of the frame
 *  gravity     Gravity for window contents (rl_gravity_enum). This is always
 *              RL_GRAVITY_NONE unless ROOTLESS_RESIZE_GRAVITY is set.
 */
typedef void (*RootlessResizeFrameProc)
    (RootlessFrameID wid, ScreenPtr pScreen,
     int newX, int newY, unsigned int newW, unsigned int newH,
     unsigned int gravity);

/*
 * Change frame ordering (AKA stacking, layering).
 *  Drawing is stopped before this is called. Unmapped frames are mapped by
 *  setting their ordering.
 *
 *  wid         Frame id
 *  nextWid     Frame id of frame that is now above this one or NULL if this
 *              frame is at the top.
 */
typedef void (*RootlessRestackFrameProc)
    (RootlessFrameID wid, RootlessFrameID nextWid);

/*
 * Change frame's shape.
 *  Drawing is stopped before this is called.
 *
 *  wid         Frame id
 *  pNewShape   New shape for the frame (in frame-local coordinates)
 *              or NULL if now unshaped.
 */
typedef void (*RootlessReshapeFrameProc)
    (RootlessFrameID wid, RegionPtr pNewShape);

/*
 * Unmap a frame.
 *
 *  wid         Frame id
 */
typedef void (*RootlessUnmapFrameProc)
    (RootlessFrameID wid);

/*
 * Start drawing to a frame.
 *  Prepare a frame for direct access to its backing buffer.
 *
 *  wid         Frame id
 *  pixelData   Address of the backing buffer (returned)
 *  bytesPerRow Width in bytes of the backing buffer (returned)
 */
typedef void (*RootlessStartDrawingProc)
    (RootlessFrameID wid, char **pixelData, int *bytesPerRow);

/*
 * Stop drawing to a frame.
 *  No drawing to the frame's backing buffer will occur until drawing
 *  is started again.
 *
 *  wid         Frame id
 *  flush       Flush drawing updates for this frame to the screen.
 */
typedef void (*RootlessStopDrawingProc)
    (RootlessFrameID wid, Bool flush);

/*
 * Flush drawing updates to the screen.
 *  Drawing is stopped before this is called.
 *
 *  wid         Frame id
 *  pDamage     Region containing all the changed pixels in frame-lcoal
 *              coordinates. This is clipped to the window's clip.
 */
typedef void (*RootlessUpdateRegionProc)
    (RootlessFrameID wid, RegionPtr pDamage);

/*
 * Mark damaged rectangles as requiring redisplay to screen.
 *
 *  wid         Frame id
 *  nrects      Number of damaged rectangles
 *  rects       Array of damaged rectangles in frame-local coordinates
 *  shift_x,    Vector to shift rectangles by
 *   shift_y
 */
typedef void (*RootlessDamageRectsProc)
    (RootlessFrameID wid, int nrects, const BoxRec *rects,
     int shift_x, int shift_y);

/*
 * Switch the window associated with a frame. (Optional)
 *  When a framed window is reparented, the frame is resized and set to
 *  use the new top-level parent. If defined this function will be called
 *  afterwards for implementation specific bookkeeping.
 *
 *  pFrame      Frame whose window has switched
 *  oldWin      Previous window wrapped by this frame
 */
typedef void (*RootlessSwitchWindowProc)
    (RootlessWindowPtr pFrame, WindowPtr oldWin);

/*
 * Check if window should be reordered. (Optional)
 *  The underlying window system may animate windows being ordered in.
 *  We want them to be mapped but remain ordered out until the animation
 *  completes. If defined this function will be called to check if a
 *  framed window should be reordered now. If this function returns
 *  FALSE, the window will still be mapped from the X11 perspective, but
 *  the RestackFrame function will not be called for its frame.
 *
 *  pFrame      Frame to reorder
 */
typedef Bool (*RootlessDoReorderWindowProc)
    (RootlessWindowPtr pFrame);

/*
 * Copy bytes. (Optional)
 *  Source and destinate may overlap and the right thing should happen.
 *
 *  width       Bytes to copy per row
 *  height      Number of rows
 *  src         Source data
 *  srcRowBytes Width of source in bytes
 *  dst         Destination data
 *  dstRowBytes Width of destination in bytes
 */
typedef void (*RootlessCopyBytesProc)
    (unsigned int width, unsigned int height,
     const void *src, unsigned int srcRowBytes,
     void *dst, unsigned int dstRowBytes);

/*
 * Copy area in frame to another part of frame. (Optional)
 *
 *  wid         Frame id
 *  dstNrects   Number of rectangles to copy
 *  dstRects    Array of rectangles to copy
 *  dx, dy      Number of pixels away to copy area
 */
typedef void (*RootlessCopyWindowProc)
    (RootlessFrameID wid, int dstNrects, const BoxRec *dstRects,
     int dx, int dy);


typedef void (*RootlessHideWindowProc)
     (RootlessFrameID wid);

typedef void (*RootlessUpdateColormapProc)
     (RootlessFrameID wid, ScreenPtr pScreen);

/*
 * Rootless implementation function list
 */
typedef struct _RootlessFrameProcs {
    RootlessCreateFrameProc CreateFrame;
    RootlessDestroyFrameProc DestroyFrame;

    RootlessMoveFrameProc MoveFrame;
    RootlessResizeFrameProc ResizeFrame;
    RootlessRestackFrameProc RestackFrame;
    RootlessReshapeFrameProc ReshapeFrame;
    RootlessUnmapFrameProc UnmapFrame;

    RootlessStartDrawingProc StartDrawing;
    RootlessStopDrawingProc StopDrawing;
    RootlessUpdateRegionProc UpdateRegion;
    RootlessDamageRectsProc DamageRects;

    /* Optional frame functions */
    RootlessSwitchWindowProc SwitchWindow;
    RootlessDoReorderWindowProc DoReorderWindow;
    RootlessHideWindowProc HideWindow;
    RootlessUpdateColormapProc UpdateColormap;

    /* Optional acceleration functions */
    RootlessCopyBytesProc CopyBytes;
    RootlessCopyWindowProc CopyWindow;
} RootlessFrameProcsRec, *RootlessFrameProcsPtr;


/*
 * Initialize rootless mode on the given screen.
 */
Bool RootlessInit(ScreenPtr pScreen, RootlessFrameProcsPtr procs);

/*
 * Return the frame ID for the physical window displaying the given window. 
 *
 *  create      If true and the window has no frame, attempt to create one
 */
RootlessFrameID RootlessFrameForWindow(WindowPtr pWin, Bool create);

/*
 * Return the top-level parent of a window.
 *  The root is the top-level parent of itself, even though the root is
 *  not otherwise considered to be a top-level window.
 */
WindowPtr TopLevelParent(WindowPtr pWindow);

/*
 * Prepare a window for direct access to its backing buffer.
 */
void RootlessStartDrawing(WindowPtr pWindow);

/*
 * Finish drawing to a window's backing buffer.
 *
 *  flush       If true, damaged areas are flushed to the screen.
 */
void RootlessStopDrawing(WindowPtr pWindow, Bool flush);

/*
 * Alocate a new screen pixmap.
 *  miCreateScreenResources does not do this properly with a null
 *  framebuffer pointer.
 */
void RootlessUpdateScreenPixmap(ScreenPtr pScreen);

/*
 * Reposition all windows on a screen to their correct positions.
 */
void RootlessRepositionWindows(ScreenPtr pScreen);

/*
 * Bring all windows to the front of the native stack
 */
void RootlessOrderAllWindows (Bool include_unhitable);
#endif /* _ROOTLESS_H */
/*
 * Common rootless definitions and code
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 * Copyright (c) 2002-2003 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stddef.h> /* For NULL */
#include <limits.h> /* For CHAR_BIT */

#include "rootlessCommon.h"
#include "colormapst.h"

unsigned int rootless_CopyBytes_threshold = 0;
unsigned int rootless_CopyWindow_threshold = 0;
int rootlessGlobalOffsetX = 0;
int rootlessGlobalOffsetY = 0;

RegionRec rootlessHugeRoot = {{-32767, -32767, 32767, 32767}, NULL};

/* Following macro from miregion.c */

/*  true iff two Boxes overlap */
#define EXTENTCHECK(r1,r2) \
      (!( ((r1)->x2 <= (r2)->x1)  || \
          ((r1)->x1 >= (r2)->x2)  || \
          ((r1)->y2 <= (r2)->y1)  || \
          ((r1)->y1 >= (r2)->y2) ) )


/*
 * TopLevelParent
 *  Returns the top-level parent of pWindow.
 *  The root is the top-level parent of itself, even though the root is
 *  not otherwise considered to be a top-level window.
 */
WindowPtr
TopLevelParent(WindowPtr pWindow)
{
    WindowPtr top;

    if (IsRoot(pWindow))
        return pWindow;

    top = pWindow;
    while (top && ! IsTopLevel(top))
        top = top->parent;

    return top;
}


/*
 * IsFramedWindow
 *  Returns TRUE if this window is visible inside a frame
 *  (e.g. it is visible and has a top-level or root parent)
 */
Bool
IsFramedWindow(WindowPtr pWin)
{
    WindowPtr top;

    if (!dixPrivateKeyRegistered(&rootlessWindowPrivateKeyRec))
        return FALSE;

    if (!pWin->realized)
        return FALSE;
    top = TopLevelParent(pWin);

    return (top && WINREC(top));
}

Bool
RootlessResolveColormap (ScreenPtr pScreen, int first_color,
                         int n_colors, uint32_t *colors)
{
  int last, i;
  ColormapPtr map;

  map = RootlessGetColormap (pScreen);
  if (map == NULL || map->class != PseudoColor) return FALSE;

  last = min (map->pVisual->ColormapEntries, first_color + n_colors);
  for (i = max (0, first_color); i < last; i++) {
    Entry *ent = map->red + i;
    uint16_t red, green, blue;

      if (!ent->refcnt)	continue;
      if (ent->fShared) {
	red = ent->co.shco.red->color;
	green = ent->co.shco.green->color;
	blue = ent->co.shco.blue->color;
      } else {
	red = ent->co.local.red;
	green = ent->co.local.green;
	blue = ent->co.local.blue;
      }

      colors[i - first_color] = (0xFF000000UL
				 | ((uint32_t) red & 0xff00) << 8
				 | (green & 0xff00)
				 | (blue >> 8));
    }

  return TRUE;
}


/*
 * RootlessStartDrawing
 *  Prepare a window for direct access to its backing buffer.
 *  Each top-level parent has a Pixmap representing its backing buffer,
 *  which all of its children inherit.
 */
void RootlessStartDrawing(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    WindowPtr top = TopLevelParent(pWindow);
    RootlessWindowRec *winRec;
    PixmapPtr curPixmap;

    if (top == NULL)
        return;
    winRec = WINREC(top);
    if (winRec == NULL)
        return;

    // Make sure the window's top-level parent is prepared for drawing.
    if (!winRec->is_drawing) {
        int bw = wBorderWidth(top);

        SCREENREC(pScreen)->imp->StartDrawing(winRec->wid, &winRec->pixelData,
                                              &winRec->bytesPerRow);

        winRec->pixmap =
            GetScratchPixmapHeader(pScreen, winRec->width, winRec->height,
                                   top->drawable.depth,
                                   top->drawable.bitsPerPixel,
                                   winRec->bytesPerRow,
                                   winRec->pixelData);
        SetPixmapBaseToScreen(winRec->pixmap,
                              top->drawable.x - bw, top->drawable.y - bw);

        winRec->is_drawing = TRUE;
    }

    curPixmap = pScreen->GetWindowPixmap(pWindow);
    if (curPixmap == winRec->pixmap)
    {
        RL_DEBUG_MSG("Window %p already has winRec->pixmap %p; not pushing\n", pWindow, winRec->pixmap);
    }
    else
    {
        PixmapPtr oldPixmap = dixLookupPrivate(&pWindow->devPrivates, rootlessWindowOldPixmapPrivateKey);
        if (oldPixmap != NULL)
        {
            if (oldPixmap == curPixmap)
                RL_DEBUG_MSG("Window %p's curPixmap %p is the same as its oldPixmap; strange\n", pWindow, curPixmap);
            else
                RL_DEBUG_MSG("Window %p's existing oldPixmap %p being lost!\n", pWindow, oldPixmap);
        }
	dixSetPrivate(&pWindow->devPrivates, rootlessWindowOldPixmapPrivateKey, curPixmap);
        pScreen->SetWindowPixmap(pWindow, winRec->pixmap);
    }
}


/*
 * RootlessStopDrawing
 *  Stop drawing to a window's backing buffer. If flush is true,
 *  damaged regions are flushed to the screen.
 */
static int RestorePreDrawingPixmapVisitor(WindowPtr pWindow, pointer data)
{
    RootlessWindowRec *winRec = (RootlessWindowRec*)data;
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    PixmapPtr exPixmap = pScreen->GetWindowPixmap(pWindow);
    PixmapPtr oldPixmap = dixLookupPrivate(&pWindow->devPrivates, rootlessWindowOldPixmapPrivateKey);
    if (oldPixmap == NULL)
    {
        if (exPixmap == winRec->pixmap)
            RL_DEBUG_MSG("Window %p appears to be in drawing mode (ex-pixmap %p equals winRec->pixmap, which is being freed) but has no oldPixmap!\n", pWindow, exPixmap);
    }
    else
    {
        if (exPixmap != winRec->pixmap)
            RL_DEBUG_MSG("Window %p appears to be in drawing mode (oldPixmap %p) but ex-pixmap %p not winRec->pixmap %p!\n", pWindow, oldPixmap, exPixmap, winRec->pixmap);
        if (oldPixmap == winRec->pixmap)
            RL_DEBUG_MSG("Window %p's oldPixmap %p is winRec->pixmap, which has just been freed!\n", pWindow, oldPixmap);
        pScreen->SetWindowPixmap(pWindow, oldPixmap);
        dixSetPrivate(&pWindow->devPrivates, rootlessWindowOldPixmapPrivateKey, NULL);
    }
    return WT_WALKCHILDREN;
}

void RootlessStopDrawing(WindowPtr pWindow, Bool flush)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    WindowPtr top = TopLevelParent(pWindow);
    RootlessWindowRec *winRec;

    if (top == NULL)
        return;
    winRec = WINREC(top);
    if (winRec == NULL)
        return;

    if (winRec->is_drawing) {
        SCREENREC(pScreen)->imp->StopDrawing(winRec->wid, flush);

        FreeScratchPixmapHeader(winRec->pixmap);
        TraverseTree(top, RestorePreDrawingPixmapVisitor, (pointer)winRec);
        winRec->pixmap = NULL;

        winRec->is_drawing = FALSE;
    }
    else if (flush) {
        SCREENREC(pScreen)->imp->UpdateRegion(winRec->wid, NULL);
    }

    if (flush && winRec->is_reorder_pending) {
        winRec->is_reorder_pending = FALSE;
        RootlessReorderWindow(pWindow);
    }
}


/*
 * RootlessDamageRegion
 *  Mark a damaged region as requiring redisplay to screen.
 *  pRegion is in GLOBAL coordinates.
 */
void
RootlessDamageRegion(WindowPtr pWindow, RegionPtr pRegion)
{
    RootlessWindowRec *winRec;
    RegionRec clipped;
    WindowPtr pTop;
    BoxPtr b1, b2;

    RL_DEBUG_MSG("Damaged win 0x%x ", pWindow);

    pTop = TopLevelParent(pWindow);
    if (pTop == NULL)
        return;

    winRec = WINREC(pTop);
    if (winRec == NULL)
        return;

    /* We need to intersect the drawn region with the clip of the window
       to avoid marking places we didn't actually draw (which can cause
       problems when the window has an extra client-side backing store)

       But this is a costly operation and since we'll normally just be
       drawing inside the clip, go to some lengths to avoid the general
       case intersection. */

    b1 = RegionExtents(&pWindow->borderClip);
    b2 = RegionExtents(pRegion);

    if (EXTENTCHECK(b1, b2)) {
        /* Regions may overlap. */

        if (RegionNumRects(pRegion) == 1) {
            int in;

            /* Damaged region only has a single rect, so we can
               just compare that against the region */

            in = RegionContainsRect(&pWindow->borderClip,
                                RegionRects (pRegion));
            if (in == rgnIN) {
            /* clip totally contains pRegion */

                SCREENREC(pWindow->drawable.pScreen)->imp->
                    DamageRects(winRec->wid,
                                RegionNumRects(pRegion),
                                RegionRects(pRegion),
                                -winRec->x, -winRec->y);

                RootlessQueueRedisplay(pTop->drawable.pScreen);
                goto out;
            }
            else if (in == rgnOUT) {
                /* clip doesn't contain pRegion */

                goto out;
            }
        }

        /* clip overlaps pRegion, need to intersect */

        RegionNull(&clipped);
        RegionIntersect(&clipped, &pWindow->borderClip, pRegion);

        SCREENREC(pWindow->drawable.pScreen)->imp->
            DamageRects(winRec->wid,
                        RegionNumRects(&clipped),
                        RegionRects(&clipped),
                        -winRec->x, -winRec->y);

        RegionUninit(&clipped);

        RootlessQueueRedisplay(pTop->drawable.pScreen);
    }

out:
#ifdef ROOTLESSDEBUG
    {
        BoxRec *box = RegionRects(pRegion), *end;
        int numBox = RegionNumRects(pRegion);

        for (end = box+numBox; box < end; box++) {
            RL_DEBUG_MSG("Damage rect: %i, %i, %i, %i\n",
                         box->x1, box->x2, box->y1, box->y2);
        }
    }
#endif
    return;
}


/*
 * RootlessDamageBox
 *  Mark a damaged box as requiring redisplay to screen.
 *  pRegion is in GLOBAL coordinates.
 */
void
RootlessDamageBox(WindowPtr pWindow, BoxPtr pBox)
{
    RegionRec region;

    RegionInit(&region, pBox, 1);

    RootlessDamageRegion(pWindow, &region);

    RegionUninit(&region);  /* no-op */
}


/*
 * RootlessDamageRect
 *  Mark a damaged rectangle as requiring redisplay to screen.
 *  (x, y, w, h) is in window-local coordinates.
 */
void
RootlessDamageRect(WindowPtr pWindow, int x, int y, int w, int h)
{
    BoxRec box;
    RegionRec region;

    x += pWindow->drawable.x;
    y += pWindow->drawable.y;

    box.x1 = x;
    box.x2 = x + w;
    box.y1 = y;
    box.y2 = y + h;

    RegionInit(&region, &box, 1);

    RootlessDamageRegion(pWindow, &region);

    RegionUninit(&region);  /* no-op */
}


/*
 * RootlessRedisplay
 *  Stop drawing and redisplay the damaged region of a window.
 */
void
RootlessRedisplay(WindowPtr pWindow)
{
    RootlessStopDrawing(pWindow, TRUE);
}


/*
 * RootlessRepositionWindows
 *  Reposition all windows on a screen to their correct positions.
 */
void
RootlessRepositionWindows(ScreenPtr pScreen)
{
    WindowPtr root = pScreen->root;
    WindowPtr win;

    if (root != NULL) {
        RootlessRepositionWindow(root);

        for (win = root->firstChild; win; win = win->nextSib) {
            if (WINREC(win) != NULL)
                RootlessRepositionWindow(win);
        }
    }
}


/*
 * RootlessRedisplayScreen
 *  Walk every window on a screen and redisplay the damaged regions.
 */
void
RootlessRedisplayScreen(ScreenPtr pScreen)
{
    WindowPtr root = pScreen->root;

    if (root != NULL) {
        WindowPtr win;

        RootlessRedisplay(root);
        for (win = root->firstChild; win; win = win->nextSib) {
            if (WINREC(win) != NULL) {
                RootlessRedisplay(win);
            }
        }
    }
}
/*
 * Common internal rootless definitions and code
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 * Copyright (c) 2002-2004 Torrey T. Lyons. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#ifndef _ROOTLESSCOMMON_H
#define _ROOTLESSCOMMON_H

#include "misc.h"
#include "rootless.h"
#include "fb.h"

#include "scrnintstr.h"

#include "picturestr.h"


// Debug output, or not.
#ifdef ROOTLESSDEBUG
#define RL_DEBUG_MSG ErrorF
#else
#define RL_DEBUG_MSG(a, ...)
#endif


// Global variables
extern DevPrivateKeyRec rootlessGCPrivateKeyRec;
#define rootlessGCPrivateKey (&rootlessGCPrivateKeyRec)

extern DevPrivateKeyRec rootlessScreenPrivateKeyRec;
#define rootlessScreenPrivateKey (&rootlessScreenPrivateKeyRec)

extern DevPrivateKeyRec rootlessWindowPrivateKeyRec;
#define rootlessWindowPrivateKey (&rootlessWindowPrivateKeyRec)

extern DevPrivateKeyRec rootlessWindowOldPixmapPrivateKeyRec;
#define rootlessWindowOldPixmapPrivateKey (&rootlessWindowOldPixmapPrivateKeyRec)


// RootlessGCRec: private per-gc data
typedef struct {
    GCFuncs *originalFuncs;
    GCOps *originalOps;
} RootlessGCRec;


// RootlessScreenRec: per-screen private data
typedef struct _RootlessScreenRec {
    // Rootless implementation functions
    RootlessFrameProcsPtr imp;

    // Wrapped screen functions
    CreateScreenResourcesProcPtr CreateScreenResources;
    CloseScreenProcPtr CloseScreen;

    CreateWindowProcPtr CreateWindow;
    DestroyWindowProcPtr DestroyWindow;
    RealizeWindowProcPtr RealizeWindow;
    UnrealizeWindowProcPtr UnrealizeWindow;
    MoveWindowProcPtr MoveWindow;
    ResizeWindowProcPtr ResizeWindow;
    RestackWindowProcPtr RestackWindow;
    ReparentWindowProcPtr ReparentWindow;
    ChangeBorderWidthProcPtr ChangeBorderWidth;
    PositionWindowProcPtr PositionWindow;
    ChangeWindowAttributesProcPtr ChangeWindowAttributes;

    CreateGCProcPtr CreateGC;
    CopyWindowProcPtr CopyWindow;
    GetImageProcPtr GetImage;
    SourceValidateProcPtr SourceValidate;

    MarkOverlappedWindowsProcPtr MarkOverlappedWindows;
    ValidateTreeProcPtr ValidateTree;

    SetShapeProcPtr SetShape;

    CompositeProcPtr Composite;
    GlyphsProcPtr Glyphs;

    InstallColormapProcPtr InstallColormap;
    UninstallColormapProcPtr UninstallColormap;
    StoreColorsProcPtr StoreColors;

    void *pixmap_data;
    unsigned int pixmap_data_size;

    ColormapPtr colormap;

    void *redisplay_timer;
    unsigned int redisplay_timer_set :1;
    unsigned int redisplay_queued :1;
    unsigned int redisplay_expired :1;
    unsigned int colormap_changed :1;
} RootlessScreenRec, *RootlessScreenPtr;

// "Definition of the Porting Layer for the X11 Sample Server" says
// unwrap and rewrap of screen functions is unnecessary, but
// screen->CreateGC changes after a call to cfbCreateGC.

#define SCREEN_UNWRAP(screen, fn) \
    screen->fn = SCREENREC(screen)->fn;

#define SCREEN_WRAP(screen, fn) \
    SCREENREC(screen)->fn = screen->fn; \
    screen->fn = Rootless##fn


// Accessors for screen and window privates

#define SCREENREC(pScreen) ((RootlessScreenRec *) \
    dixLookupPrivate(&(pScreen)->devPrivates, rootlessScreenPrivateKey))

#define SETSCREENREC(pScreen, v) \
    dixSetPrivate(&(pScreen)->devPrivates, rootlessScreenPrivateKey, v)

#define WINREC(pWin) ((RootlessWindowRec *) \
    dixLookupPrivate(&(pWin)->devPrivates, rootlessWindowPrivateKey))

#define SETWINREC(pWin, v) \
    dixSetPrivate(&(pWin)->devPrivates, rootlessWindowPrivateKey, v)

// Call a rootless implementation function.
// Many rootless implementation functions are allowed to be NULL.
#define CallFrameProc(pScreen, proc, params)            \
    if (SCREENREC(pScreen)->frameProcs.proc) {          \
        RL_DEBUG_MSG("calling frame proc " #proc " ");  \
        SCREENREC(pScreen)->frameProcs.proc params;     \
    }


// BoxRec manipulators
// Copied from shadowfb

#define TRIM_BOX(box, pGC) { \
    BoxPtr extents = &pGC->pCompositeClip->extents;\
    if(box.x1 < extents->x1) box.x1 = extents->x1; \
    if(box.x2 > extents->x2) box.x2 = extents->x2; \
    if(box.y1 < extents->y1) box.y1 = extents->y1; \
    if(box.y2 > extents->y2) box.y2 = extents->y2; \
}

#define TRANSLATE_BOX(box, pDraw) { \
    box.x1 += pDraw->x; \
    box.x2 += pDraw->x; \
    box.y1 += pDraw->y; \
    box.y2 += pDraw->y; \
}

#define TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC) { \
    TRANSLATE_BOX(box, pDraw); \
    TRIM_BOX(box, pGC); \
}

#define BOX_NOT_EMPTY(box) \
    (((box.x2 - box.x1) > 0) && ((box.y2 - box.y1) > 0))


// HUGE_ROOT and NORMAL_ROOT
// We don't want to clip windows to the edge of the screen.
// HUGE_ROOT temporarily makes the root window really big.
// This is needed as a wrapper around any function that calls
// SetWinSize or SetBorderSize which clip a window against its
// parents, including the root.

extern RegionRec rootlessHugeRoot;

#define HUGE_ROOT(pWin)                         \
    do {                                        \
        WindowPtr w = pWin;                     \
        while (w->parent)                       \
            w = w->parent;                      \
        saveRoot = w->winSize;                  \
        w->winSize = rootlessHugeRoot;          \
    } while (0)

#define NORMAL_ROOT(pWin)                       \
    do {                                        \
        WindowPtr w = pWin;                     \
        while (w->parent)                       \
            w = w->parent;                      \
        w->winSize = saveRoot;                  \
    } while (0)


// Returns TRUE if this window is a top-level window (i.e. child of the root)
// The root is not a top-level window.
#define IsTopLevel(pWin) \
    ((pWin)  &&  (pWin)->parent  &&  !(pWin)->parent->parent)

// Returns TRUE if this window is a root window
#define IsRoot(pWin) \
    ((pWin) == (pWin)->drawable.pScreen->root)


/*
 * SetPixmapBaseToScreen
 *  Move the given pixmap's base address to where pixel (0, 0)
 *  would be if the pixmap's actual data started at (x, y).
 *  Can't access the bits before the first word of the drawable's data in
 *  rootless mode, so make sure our base address is always 32-bit aligned.
 */
#define SetPixmapBaseToScreen(pix, _x, _y) {                                \
    PixmapPtr   _pPix = (PixmapPtr) (pix);                                  \
    _pPix->devPrivate.ptr = (char *) (_pPix->devPrivate.ptr) -              \
                            ((int)(_x) * _pPix->drawable.bitsPerPixel/8 +   \
                             (int)(_y) * _pPix->devKind);                   \
    if (_pPix->drawable.bitsPerPixel != FB_UNIT) {                          \
        size_t _diff = ((size_t) _pPix->devPrivate.ptr) &               \
                         (FB_UNIT / CHAR_BIT - 1);                          \
        _pPix->devPrivate.ptr = (char *) (_pPix->devPrivate.ptr) -          \
                                _diff;                                      \
        _pPix->drawable.x = _diff /                                         \
                            (_pPix->drawable.bitsPerPixel / CHAR_BIT);      \
    }                                                                       \
}


// Returns TRUE if this window is visible inside a frame
// (e.g. it is visible and has a top-level or root parent)
Bool IsFramedWindow(WindowPtr pWin);

// Routines that cause regions to get redrawn.
// DamageRegion and DamageRect are in global coordinates.
// DamageBox is in window-local coordinates.
void RootlessDamageRegion(WindowPtr pWindow, RegionPtr pRegion);
void RootlessDamageRect(WindowPtr pWindow, int x, int y, int w, int h);
void RootlessDamageBox(WindowPtr pWindow, BoxPtr pBox);
void RootlessRedisplay(WindowPtr pWindow);
void RootlessRedisplayScreen(ScreenPtr pScreen);

void RootlessQueueRedisplay(ScreenPtr pScreen);

/* Return the colormap currently installed on the given screen. */
ColormapPtr RootlessGetColormap (ScreenPtr pScreen);

/* Convert colormap to ARGB. */
Bool RootlessResolveColormap (ScreenPtr pScreen, int first_color,
			      int n_colors, uint32_t *colors);

void RootlessFlushWindowColormap (WindowPtr pWin);
void RootlessFlushScreenColormaps (ScreenPtr pScreen);

// Move a window to its proper location on the screen.
void RootlessRepositionWindow(WindowPtr pWin);

// Move the window to it's correct place in the physical stacking order.
void RootlessReorderWindow(WindowPtr pWin);

void RootlessScreenExpose (ScreenPtr pScreen);
void RootlessHideAllWindows (void);
void RootlessShowAllWindows (void);
void RootlessUpdateRooted (Bool state);

void RootlessEnableRoot (ScreenPtr pScreen);
void RootlessDisableRoot (ScreenPtr pScreen);

void RootlessSetPixmapOfAncestors(WindowPtr pWin);

#endif /* _ROOTLESSCOMMON_H */
/*
 * Platform specific rootless configuration
 */
/*
 * Copyright (c) 2003 Torrey T. Lyons. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _ROOTLESSCONFIG_H
#define _ROOTLESSCONFIG_H

#ifdef __APPLE__

# define ROOTLESS_PROTECT_ALPHA TRUE
# define ROOTLESS_REDISPLAY_DELAY 10
# define ROOTLESS_RESIZE_GRAVITY TRUE
/*# define ROOTLESSDEBUG*/

/* Bit mask for alpha channel with a particular number of bits per
   pixel. Note that we only care for 32bpp data. Mac OS X uses planar
   alpha for 16bpp. */
# define RootlessAlphaMask(bpp) ((bpp) == 32 ? 0xFF000000 : 0)

#endif /* __APPLE__ */

#if defined(__CYGWIN__) || defined(WIN32)

# define ROOTLESS_PROTECT_ALPHA TRUE
# define ROOTLESS_REDISPLAY_DELAY 10
# undef  ROOTLESS_RESIZE_GRAVITY
/*# define ROOTLESSDEBUG*/

# define RootlessAlphaMask(bpp) ((bpp) == 32 ? 0xFF000000 : 0)

#endif /* __CYGWIN__ */

#endif /* _ROOTLESSCONFIG_H */
/*
 * Graphics Context support for generic rootless X server
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 * Copyright (c) 2002-2003 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stddef.h> /* For NULL */
#include "mi.h"
#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "dixfontstr.h"
#include "mivalidate.h"
#include "fb.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "rootlessCommon.h"


// GC functions
static void RootlessValidateGC(GCPtr pGC, unsigned long changes,
                               DrawablePtr pDrawable);
static void RootlessChangeGC(GCPtr pGC, unsigned long mask);
static void RootlessCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
static void RootlessDestroyGC(GCPtr pGC);
static void RootlessChangeClip(GCPtr pGC, int type, pointer pvalue,
                               int nrects);
static void RootlessDestroyClip(GCPtr pGC);
static void RootlessCopyClip(GCPtr pgcDst, GCPtr pgcSrc);

Bool RootlessCreateGC(GCPtr pGC);

GCFuncs rootlessGCFuncs = {
    RootlessValidateGC,
    RootlessChangeGC,
    RootlessCopyGC,
    RootlessDestroyGC,
    RootlessChangeClip,
    RootlessDestroyClip,
    RootlessCopyClip,
};

// GC operations
static void RootlessFillSpans(DrawablePtr dst, GCPtr pGC, int nInit,
			      DDXPointPtr pptInit, int *pwidthInit, 
			      int sorted);
static void RootlessSetSpans(DrawablePtr dst, GCPtr pGC, char *pSrc,
			     DDXPointPtr pptInit, int *pwidthInit,
			     int nspans, int sorted);
static void RootlessPutImage(DrawablePtr dst, GCPtr pGC,
			     int depth, int x, int y, int w, int h,
			     int leftPad, int format, char *pBits);
static RegionPtr RootlessCopyArea(DrawablePtr pSrc, DrawablePtr dst, GCPtr pGC,
				  int srcx, int srcy, int w, int h,
				  int dstx, int dsty);
static RegionPtr RootlessCopyPlane(DrawablePtr pSrc, DrawablePtr dst,
                                   GCPtr pGC, int srcx, int srcy,
                                   int w, int h, int dstx, int dsty,
                                   unsigned long plane);
static void RootlessPolyPoint(DrawablePtr dst, GCPtr pGC,
                              int mode, int npt, DDXPointPtr pptInit);
static void RootlessPolylines(DrawablePtr dst, GCPtr pGC,
                              int mode, int npt, DDXPointPtr pptInit);
static void RootlessPolySegment(DrawablePtr dst, GCPtr pGC,
                                int nseg, xSegment *pSeg);
static void RootlessPolyRectangle(DrawablePtr dst, GCPtr pGC,
                                  int nRects, xRectangle *pRects);
static void RootlessPolyArc(DrawablePtr dst, GCPtr pGC, int narcs, xArc *parcs);
static void RootlessFillPolygon(DrawablePtr dst, GCPtr pGC,
                                int shape, int mode, int count,
                                DDXPointPtr pptInit);
static void RootlessPolyFillRect(DrawablePtr dst, GCPtr pGC,
                                 int nRectsInit, xRectangle *pRectsInit);
static void RootlessPolyFillArc(DrawablePtr dst, GCPtr pGC,
                                int narcsInit, xArc *parcsInit);
static int RootlessPolyText8(DrawablePtr dst, GCPtr pGC,
			     int x, int y, int count, char *chars);
static int RootlessPolyText16(DrawablePtr dst, GCPtr pGC,
			      int x, int y, int count, unsigned short *chars);
static void RootlessImageText8(DrawablePtr dst, GCPtr pGC,
                               int x, int y, int count, char *chars);
static void RootlessImageText16(DrawablePtr dst, GCPtr pGC,
                                int x, int y, int count, unsigned short *chars);
static void RootlessImageGlyphBlt(DrawablePtr dst, GCPtr pGC,
                                  int x, int y, unsigned int nglyphInit,
                                  CharInfoPtr *ppciInit, pointer unused);
static void RootlessPolyGlyphBlt(DrawablePtr dst, GCPtr pGC,
                                 int x, int y, unsigned int nglyph,
                                 CharInfoPtr *ppci, pointer pglyphBase);
static void RootlessPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr dst,
			       int dx, int dy, int xOrg, int yOrg);


static GCOps rootlessGCOps = {
    RootlessFillSpans,
    RootlessSetSpans,
    RootlessPutImage,
    RootlessCopyArea,
    RootlessCopyPlane,
    RootlessPolyPoint,
    RootlessPolylines,
    RootlessPolySegment,
    RootlessPolyRectangle,
    RootlessPolyArc,
    RootlessFillPolygon,
    RootlessPolyFillRect,
    RootlessPolyFillArc,
    RootlessPolyText8,
    RootlessPolyText16,
    RootlessImageText8,
    RootlessImageText16,
    RootlessImageGlyphBlt,
    RootlessPolyGlyphBlt,
    RootlessPushPixels
};

/*
   If ROOTLESS_PROTECT_ALPHA is set, we have to make sure that the alpha
   channel of the on screen windows is always opaque. fb makes this harder
   than it would otherwise be by noticing that a planemask of 0x00ffffff
   includes all bits when depth==24, and so it "optimizes" the planemask to
   0xffffffff. We work around this by temporarily setting depth=bpp while
   changing the GC.

   So the normal situation (in 32 bit mode) is that the planemask is
   0x00ffffff and thus fb leaves the alpha channel alone. The rootless
   implementation is responsible for setting the alpha channel opaque
   initially.

   Unfortunately drawing with a planemask that doesn't have all bits set
   normally causes fb to fall off its fastest paths when blitting and
   filling.  So we try to recognize when we can relax the planemask back to
   0xffffffff, and do that for the duration of the drawing operation,
   setting the alpha channel in fg/bg pixels to opaque at the same time. We
   can do this when drawing op is GXcopy. We can also do this when copying
   from another window since its alpha channel must also be opaque.

   The three macros below are used to implement this. Drawing ops that can
   potentially have their planemask relaxed look like:

   OP {
       GC_SAVE(gc);
       GCOP_UNWRAP(gc);

       ...

       if (canAccelxxx(..) && otherwise-suitable)
            GC_UNSET_PM(gc, dst);

       gc->funcs->OP(gc, ...);

       GC_RESTORE(gc, dst);
       GCOP_WRAP(gc);
   }

 */

#define GC_SAVE(pGC) 				\
    unsigned long _save_fg = (pGC)->fgPixel;	\
    unsigned long _save_bg = (pGC)->bgPixel;	\
    unsigned long _save_pm = (pGC)->planemask;	\
    Bool _changed = FALSE

#define GC_RESTORE(pGC, pDraw)					\
    do {							\
        if (_changed) {						\
            unsigned int depth = (pDraw)->depth;		\
            (pGC)->fgPixel = _save_fg;				\
            (pGC)->bgPixel = _save_bg;				\
            (pGC)->planemask = _save_pm;			\
            (pDraw)->depth = (pDraw)->bitsPerPixel;		\
            VALIDATE_GC(pGC, GCForeground | GCBackground |	\
                        GCPlaneMask, pDraw);			\
            (pDraw)->depth = depth;				\
        }							\
    } while (0)

#define GC_UNSET_PM(pGC, pDraw)						\
    do {								\
        unsigned int mask = RootlessAlphaMask ((pDraw)->bitsPerPixel);	\
        if (((pGC)->planemask & mask) != mask) {			\
            unsigned int depth = (pDraw)->depth;			\
            (pGC)->fgPixel |= mask;					\
            (pGC)->bgPixel |= mask;					\
            (pGC)->planemask |= mask;					\
            (pDraw)->depth = (pDraw)->bitsPerPixel;			\
            VALIDATE_GC(pGC, GCForeground |				\
                        GCBackground | GCPlaneMask, pDraw);		\
            (pDraw)->depth = depth;					\
            _changed = TRUE;						\
        }								\
    } while (0)

#define VALIDATE_GC(pGC, changes, pDrawable)				\
    do {								\
        pGC->funcs->ValidateGC(pGC, changes, pDrawable);		\
        if (((WindowPtr) pDrawable)->viewable) {			\
            gcrec->originalOps = pGC->ops;				\
        }								\
    } while(0)

static RootlessWindowRec *
canAccelBlit (DrawablePtr pDraw, GCPtr pGC)
{
    WindowPtr pTop;
    RootlessWindowRec *winRec;
    unsigned int pm;

    if (pGC->alu != GXcopy)
        return NULL;

    if (pDraw->type != DRAWABLE_WINDOW)
        return NULL;

    pm = ~RootlessAlphaMask(pDraw->bitsPerPixel);
    if ((pGC->planemask & pm) != pm)
        return NULL;

    pTop = TopLevelParent((WindowPtr) pDraw);
    if (pTop == NULL)
        return NULL;

    winRec = WINREC(pTop);
    if (winRec == NULL)
        return NULL;

    return winRec;
}

static inline RootlessWindowRec *
canAccelFill(DrawablePtr pDraw, GCPtr pGC)
{
    if (pGC->fillStyle != FillSolid)
        return NULL;

    return canAccelBlit(pDraw, pGC);
}


/*
 * Screen function to create a graphics context
 */
Bool
RootlessCreateGC(GCPtr pGC)
{
    RootlessGCRec *gcrec;
    RootlessScreenRec *s;
    Bool result;

    SCREEN_UNWRAP(pGC->pScreen, CreateGC);
    s = SCREENREC(pGC->pScreen);
    result = s->CreateGC(pGC);

    gcrec = (RootlessGCRec *)
	dixLookupPrivate(&pGC->devPrivates, rootlessGCPrivateKey);
    gcrec->originalOps = NULL; // don't wrap ops yet
    gcrec->originalFuncs = pGC->funcs;
    pGC->funcs = &rootlessGCFuncs;

    SCREEN_WRAP(pGC->pScreen, CreateGC);
    return result;
}


/*
 * GC funcs
 *
 * These wrap lower level GC funcs.
 * ValidateGC wraps the GC ops iff dest is viewable.
 * All the others just unwrap and call.
 */

// GCFUNC_UNRAP assumes funcs have been wrapped and 
// does not assume ops have been wrapped
#define GCFUNC_UNWRAP(pGC) \
    RootlessGCRec *gcrec = (RootlessGCRec *) \
	dixLookupPrivate(&(pGC)->devPrivates, rootlessGCPrivateKey); \
    (pGC)->funcs = gcrec->originalFuncs; \
    if (gcrec->originalOps) { \
        (pGC)->ops = gcrec->originalOps; \
}

#define GCFUNC_WRAP(pGC) \
    gcrec->originalFuncs = (pGC)->funcs; \
    (pGC)->funcs = &rootlessGCFuncs; \
    if (gcrec->originalOps) { \
        gcrec->originalOps = (pGC)->ops; \
        (pGC)->ops = &rootlessGCOps; \
}


static void
RootlessValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
{
    GCFUNC_UNWRAP(pGC);

    gcrec->originalOps = NULL;

    if (pDrawable->type == DRAWABLE_WINDOW)
    {
#ifdef ROOTLESS_PROTECT_ALPHA
        unsigned int depth = pDrawable->depth;

        // We force a planemask so fb doesn't overwrite the alpha channel.
        // Left to its own devices, fb will optimize away the planemask.
        pDrawable->depth = pDrawable->bitsPerPixel;
        pGC->planemask &= ~RootlessAlphaMask(pDrawable->bitsPerPixel);
        VALIDATE_GC(pGC, changes | GCPlaneMask, pDrawable);
        pDrawable->depth = depth;
#else
        VALIDATE_GC(pGC, changes, pDrawable);
#endif
    } else {
        pGC->funcs->ValidateGC(pGC, changes, pDrawable);
    }

    GCFUNC_WRAP(pGC);
}

static void RootlessChangeGC(GCPtr pGC, unsigned long mask)
{
    GCFUNC_UNWRAP(pGC);
    pGC->funcs->ChangeGC(pGC, mask);
    GCFUNC_WRAP(pGC);
}

static void RootlessCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    GCFUNC_UNWRAP(pGCDst);
    pGCDst->funcs->CopyGC(pGCSrc, mask, pGCDst);
    GCFUNC_WRAP(pGCDst);
}

static void RootlessDestroyGC(GCPtr pGC)
{
    GCFUNC_UNWRAP(pGC);
    pGC->funcs->DestroyGC(pGC);
    GCFUNC_WRAP(pGC);
}

static void RootlessChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
{
    GCFUNC_UNWRAP(pGC);
    pGC->funcs->ChangeClip(pGC, type, pvalue, nrects);
    GCFUNC_WRAP(pGC);
}

static void RootlessDestroyClip(GCPtr pGC)
{
    GCFUNC_UNWRAP(pGC);
    pGC->funcs->DestroyClip(pGC);
    GCFUNC_WRAP(pGC);
}

static void RootlessCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    GCFUNC_UNWRAP(pgcDst);
    pgcDst->funcs->CopyClip(pgcDst, pgcSrc);
    GCFUNC_WRAP(pgcDst);
}


/*
 * GC ops
 *
 * We can't use shadowfb because shadowfb assumes one pixmap
 * and our root window is a special case.
 * However, much of this code is copied from shadowfb.
 */

// assumes both funcs and ops are wrapped
#define GCOP_UNWRAP(pGC) \
    RootlessGCRec *gcrec = (RootlessGCRec *) \
        dixLookupPrivate(&(pGC)->devPrivates, rootlessGCPrivateKey); \
    GCFuncs *saveFuncs = pGC->funcs; \
    (pGC)->funcs = gcrec->originalFuncs; \
    (pGC)->ops = gcrec->originalOps;

#define GCOP_WRAP(pGC) \
    gcrec->originalOps = (pGC)->ops; \
    (pGC)->funcs = saveFuncs; \
    (pGC)->ops = &rootlessGCOps;

static void
RootlessFillSpans(DrawablePtr dst, GCPtr pGC, int nInit,
                  DDXPointPtr pptInit, int *pwidthInit, int sorted)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("fill spans start ");

    if (nInit <= 0) {
        pGC->ops->FillSpans(dst, pGC, nInit, pptInit, pwidthInit, sorted);
    } else {
        DDXPointPtr ppt = pptInit;
        int *pwidth = pwidthInit;
        int i = nInit;
        BoxRec box;

        box.x1 = ppt->x;
        box.x2 = box.x1 + *pwidth;
        box.y2 = box.y1 = ppt->y;

        while (--i) {
            ppt++;
            pwidth++;
            if (box.x1 > ppt->x)
                box.x1 = ppt->x;
            if (box.x2 < (ppt->x + *pwidth))
                box.x2 = ppt->x + *pwidth;
            if (box.y1 > ppt->y)
                box.y1 = ppt->y;
            else if (box.y2 < ppt->y)
                box.y2 = ppt->y;
        }

        box.y2++;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC))
        {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->FillSpans(dst, pGC, nInit, pptInit, pwidthInit, sorted);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("fill spans end\n");
}

static void
RootlessSetSpans(DrawablePtr dst, GCPtr pGC, char *pSrc,
                 DDXPointPtr pptInit, int *pwidthInit,
                 int nspans, int sorted)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("set spans start ");

    if (nspans <= 0) {
        pGC->ops->SetSpans(dst, pGC, pSrc, pptInit, pwidthInit,
                           nspans, sorted);
    } else {
        DDXPointPtr ppt = pptInit;
        int *pwidth = pwidthInit;
        int i = nspans;
        BoxRec box;

        box.x1 = ppt->x;
        box.x2 = box.x1 + *pwidth;
        box.y2 = box.y1 = ppt->y;

        while (--i) {
            ppt++;
            pwidth++;
            if (box.x1 > ppt->x)
                box.x1 = ppt->x;
            if (box.x2 < (ppt->x + *pwidth))
                box.x2 = ppt->x + *pwidth;
            if (box.y1 > ppt->y)
                box.y1 = ppt->y;
            else if (box.y2 < ppt->y)
                box.y2 = ppt->y;
        }

        box.y2++;

        RootlessStartDrawing((WindowPtr) dst);
        pGC->ops->SetSpans(dst, pGC, pSrc, pptInit, pwidthInit,
                           nspans, sorted);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("set spans end\n");
}

static void
RootlessPutImage(DrawablePtr dst, GCPtr pGC,
                 int depth, int x, int y, int w, int h,
                 int leftPad, int format, char *pBits)
{
    BoxRec box;

    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("put image start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PutImage(dst, pGC, depth, x,y,w,h, leftPad, format, pBits);

    box.x1 = x + dst->x;
    box.x2 = box.x1 + w;
    box.y1 = y + dst->y;
    box.y2 = box.y1 + h;

    TRIM_BOX(box, pGC);
    if (BOX_NOT_EMPTY(box))
        RootlessDamageBox ((WindowPtr) dst, &box);

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("put image end\n");
}

/* changed area is *dest* rect */
static RegionPtr
RootlessCopyArea(DrawablePtr pSrc, DrawablePtr dst, GCPtr pGC,
                 int srcx, int srcy, int w, int h,
                 int dstx, int dsty)
{
    RegionPtr result;
    BoxRec box;

    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);

    RL_DEBUG_MSG("copy area start (src 0x%x, dst 0x%x)", pSrc, dst);

    if (pSrc->type == DRAWABLE_WINDOW && IsFramedWindow((WindowPtr)pSrc)) {
        /* If both source and dest are windows, and we're doing
           a simple copy operation, we can remove the alpha-protecting
           planemask (since source has opaque alpha as well) */

        if (canAccelBlit(pSrc, pGC))
        {
            GC_UNSET_PM(pGC, dst);
        }

        RootlessStartDrawing((WindowPtr) pSrc);
    }
    RootlessStartDrawing((WindowPtr) dst);
    result = pGC->ops->CopyArea(pSrc, dst, pGC, srcx, srcy, w, h, dstx, dsty);

    box.x1 = dstx + dst->x;
    box.x2 = box.x1 + w;
    box.y1 = dsty + dst->y;
    box.y2 = box.y1 + h;

    TRIM_BOX(box, pGC);
    if (BOX_NOT_EMPTY(box))
        RootlessDamageBox ((WindowPtr) dst, &box);

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("copy area end\n");
    return result;
}

/* changed area is *dest* rect */
static RegionPtr RootlessCopyPlane(DrawablePtr pSrc, DrawablePtr dst,
                                   GCPtr pGC, int srcx, int srcy,
                                   int w, int h, int dstx, int dsty,
                                   unsigned long plane)
{
    RegionPtr result;
    BoxRec box;

    GCOP_UNWRAP(pGC);

    RL_DEBUG_MSG("copy plane start ");

    if (pSrc->type == DRAWABLE_WINDOW && IsFramedWindow((WindowPtr)pSrc)) {
        RootlessStartDrawing((WindowPtr) pSrc);
    }
    RootlessStartDrawing((WindowPtr) dst);
    result = pGC->ops->CopyPlane(pSrc, dst, pGC, srcx, srcy, w, h,
                                 dstx, dsty, plane);

    box.x1 = dstx + dst->x;
    box.x2 = box.x1 + w;
    box.y1 = dsty + dst->y;
    box.y2 = box.y1 + h;

    TRIM_BOX(box, pGC);
    if (BOX_NOT_EMPTY(box))
        RootlessDamageBox ((WindowPtr) dst, &box);

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("copy plane end\n");
    return result;
}

// Options for size of changed area:
//  0 = box per point
//  1 = big box around all points
//  2 = accumulate point in 20 pixel radius
#define ROOTLESS_CHANGED_AREA 1
#define abs(a) ((a) > 0 ? (a) : -(a))

/* changed area is box around all points */
static void RootlessPolyPoint(DrawablePtr dst, GCPtr pGC,
                              int mode, int npt, DDXPointPtr pptInit)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("polypoint start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolyPoint(dst, pGC, mode, npt, pptInit);

    if (npt > 0) {
#if ROOTLESS_CHANGED_AREA==0
        // box per point
        BoxRec box;

        while (npt) {
            box.x1 = pptInit->x;
            box.y1 = pptInit->y;
            box.x2 = box.x1 + 1;
            box.y2 = box.y1 + 1;

            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox ((WindowPtr) dst, &box);

            npt--;
            pptInit++;
        }

#elif ROOTLESS_CHANGED_AREA==1
        // one big box
        BoxRec box;

        box.x2 = box.x1 = pptInit->x;
        box.y2 = box.y1 = pptInit->y;
        while (--npt) {
            pptInit++;
            if (box.x1 > pptInit->x)
                box.x1 = pptInit->x;
            else if (box.x2 < pptInit->x)
                box.x2 = pptInit->x;
            if (box.y1 > pptInit->y)
                box.y1 = pptInit->y;
            else if (box.y2 < pptInit->y)
                box.y2 = pptInit->y;
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);

#elif ROOTLESS_CHANGED_AREA==2
        // clever(?) method: accumulate point in 20-pixel radius
        BoxRec box;
        int firstx, firsty;

        box.x2 = box.x1 = firstx = pptInit->x;
        box.y2 = box.y1 = firsty = pptInit->y;
        while (--npt) {
            pptInit++;
            if (abs(pptInit->x - firstx) > 20 ||
                abs(pptInit->y - firsty) > 20) {
                box.x2++;
                box.y2++;
                TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
                if (BOX_NOT_EMPTY(box))
                    RootlessDamageBox ((WindowPtr) dst, &box);
                box.x2 = box.x1 = firstx = pptInit->x;
                box.y2 = box.y1 = firsty = pptInit->y;
            } else {
                if (box.x1 > pptInit->x) box.x1 = pptInit->x;
                else if (box.x2 < pptInit->x) box.x2 = pptInit->x;
                if (box.y1 > pptInit->y) box.y1 = pptInit->y;
                else if (box.y2 < pptInit->y) box.y2 = pptInit->y;
            }
        }
        box.x2++;
        box.y2++;
        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
#endif  /* ROOTLESS_CHANGED_AREA */
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("polypoint end\n");
}

#undef ROOTLESS_CHANGED_AREA

/* changed area is box around each line */
static void RootlessPolylines(DrawablePtr dst, GCPtr pGC,
                              int mode, int npt, DDXPointPtr pptInit)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("poly lines start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->Polylines(dst, pGC, mode, npt, pptInit);

    if (npt > 0) {
        BoxRec box;
        int extra = pGC->lineWidth >> 1;

        box.x2 = box.x1 = pptInit->x;
        box.y2 = box.y1 = pptInit->y;

        if (npt > 1) {
            if (pGC->joinStyle == JoinMiter)
                extra = 6 * pGC->lineWidth;
            else if (pGC->capStyle == CapProjecting)
                extra = pGC->lineWidth;
        }

        if (mode == CoordModePrevious) {
            int x = box.x1;
            int y = box.y1;

            while (--npt) {
                pptInit++;
                x += pptInit->x;
                y += pptInit->y;
                if (box.x1 > x)
                    box.x1 = x;
                else if (box.x2 < x)
                    box.x2 = x;
                if (box.y1 > y)
                    box.y1 = y;
                else if (box.y2 < y)
                    box.y2 = y;
            }
        } else {
            while (--npt) {
                pptInit++;
                if (box.x1 > pptInit->x)
                    box.x1 = pptInit->x;
                else if (box.x2 < pptInit->x)
                    box.x2 = pptInit->x;
                if (box.y1 > pptInit->y)
                    box.y1 = pptInit->y;
                else if (box.y2 < pptInit->y)
                    box.y2 = pptInit->y;
            }
        }

        box.x2++;
        box.y2++;

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("poly lines end\n");
}

/* changed area is box around each line segment */
static void RootlessPolySegment(DrawablePtr dst, GCPtr pGC,
                                int nseg, xSegment *pSeg)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("poly segment start (win 0x%x)", dst);

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolySegment(dst, pGC, nseg, pSeg);

    if (nseg > 0) {
        BoxRec box;
        int extra = pGC->lineWidth;

        if (pGC->capStyle != CapProjecting)
        extra >>= 1;

        if (pSeg->x2 > pSeg->x1) {
            box.x1 = pSeg->x1;
            box.x2 = pSeg->x2;
        } else {
            box.x2 = pSeg->x1;
            box.x1 = pSeg->x2;
        }

        if (pSeg->y2 > pSeg->y1) {
            box.y1 = pSeg->y1;
            box.y2 = pSeg->y2;
        } else {
            box.y2 = pSeg->y1;
            box.y1 = pSeg->y2;
        }

        while (--nseg) {
            pSeg++;
            if (pSeg->x2 > pSeg->x1) {
                if (pSeg->x1 < box.x1) box.x1 = pSeg->x1;
                if (pSeg->x2 > box.x2) box.x2 = pSeg->x2;
            } else {
                if (pSeg->x2 < box.x1) box.x1 = pSeg->x2;
                if (pSeg->x1 > box.x2) box.x2 = pSeg->x1;
            }
            if (pSeg->y2 > pSeg->y1) {
                if (pSeg->y1 < box.y1) box.y1 = pSeg->y1;
                if (pSeg->y2 > box.y2) box.y2 = pSeg->y2;
            } else {
                if (pSeg->y2 < box.y1) box.y1 = pSeg->y2;
                if (pSeg->y1 > box.y2) box.y2 = pSeg->y1;
            }
        }

        box.x2++;
        box.y2++;

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("poly segment end\n");
}

/* changed area is box around each line (not entire rects) */
static void RootlessPolyRectangle(DrawablePtr dst, GCPtr pGC,
                                  int nRects, xRectangle *pRects)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("poly rectangle start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolyRectangle(dst, pGC, nRects, pRects);

    if (nRects > 0) {
        BoxRec box;
        int offset1, offset2, offset3;

        offset2 = pGC->lineWidth;
        if (!offset2) offset2 = 1;
        offset1 = offset2 >> 1;
        offset3 = offset2 - offset1;

        while (nRects--) {
            box.x1 = pRects->x - offset1;
            box.y1 = pRects->y - offset1;
            box.x2 = box.x1 + pRects->width + offset2;
            box.y2 = box.y1 + offset2;
            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox ((WindowPtr) dst, &box);

            box.x1 = pRects->x - offset1;
            box.y1 = pRects->y + offset3;
            box.x2 = box.x1 + offset2;
            box.y2 = box.y1 + pRects->height - offset2;
            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox ((WindowPtr) dst, &box);

            box.x1 = pRects->x + pRects->width - offset1;
            box.y1 = pRects->y + offset3;
            box.x2 = box.x1 + offset2;
            box.y2 = box.y1 + pRects->height - offset2;
            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox ((WindowPtr) dst, &box);

            box.x1 = pRects->x - offset1;
            box.y1 = pRects->y + pRects->height - offset1;
            box.x2 = box.x1 + pRects->width + offset2;
            box.y2 = box.y1 + offset2;
            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox ((WindowPtr) dst, &box);

            pRects++;
        }
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("poly rectangle end\n");
}


/* changed area is box around each arc (assumes all arcs are 360 degrees) */
static void RootlessPolyArc(DrawablePtr dst, GCPtr pGC, int narcs, xArc *parcs)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("poly arc start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolyArc(dst, pGC, narcs, parcs);

    if (narcs > 0) {
        int extra = pGC->lineWidth >> 1;
        BoxRec box;

        box.x1 = parcs->x;
        box.x2 = box.x1 + parcs->width;
        box.y1 = parcs->y;
        box.y2 = box.y1 + parcs->height;

        /* should I break these up instead ? */

        while (--narcs) {
            parcs++;
            if (box.x1 > parcs->x)
                box.x1 = parcs->x;
            if (box.x2 < (parcs->x + parcs->width))
                box.x2 = parcs->x + parcs->width;
            if (box.y1 > parcs->y)
                box.y1 = parcs->y;
            if (box.y2 < (parcs->y + parcs->height))
                box.y2 = parcs->y + parcs->height;
        }

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("poly arc end\n");
}


/* changed area is box around each poly */
static void RootlessFillPolygon(DrawablePtr dst, GCPtr pGC,
                                int shape, int mode, int count,
                                DDXPointPtr pptInit)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("fill poly start (win 0x%x, fillStyle 0x%x)", dst,
                 pGC->fillStyle);

    if (count <= 2) {
        pGC->ops->FillPolygon(dst, pGC, shape, mode, count, pptInit);
    } else {
        DDXPointPtr ppt = pptInit;
        int i = count;
        BoxRec box;

        box.x2 = box.x1 = ppt->x;
        box.y2 = box.y1 = ppt->y;

        if (mode != CoordModeOrigin) {
            int x = box.x1;
            int y = box.y1;

            while (--i) {
                ppt++;
                x += ppt->x;
                y += ppt->y;
                if (box.x1 > x)
                    box.x1 = x;
                else if (box.x2 < x)
                    box.x2 = x;
                if (box.y1 > y)
                    box.y1 = y;
                else if (box.y2 < y)
                    box.y2 = y;
            }
        } else {
            while (--i) {
                ppt++;
                if (box.x1 > ppt->x)
                    box.x1 = ppt->x;
                else if (box.x2 < ppt->x)
                    box.x2 = ppt->x;
                if (box.y1 > ppt->y)
                    box.y1 = ppt->y;
                else if (box.y2 < ppt->y)
                    box.y2 = ppt->y;
            }
        }

        box.x2++;
        box.y2++;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC))
        {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->FillPolygon(dst, pGC, shape, mode, count, pptInit);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("fill poly end\n");
}

/* changed area is the rects */
static void RootlessPolyFillRect(DrawablePtr dst, GCPtr pGC,
                                 int nRectsInit, xRectangle *pRectsInit)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("fill rect start (win 0x%x, fillStyle 0x%x)", dst,
                 pGC->fillStyle);

    if (nRectsInit <= 0) {
        pGC->ops->PolyFillRect(dst, pGC, nRectsInit, pRectsInit);
    } else {
        BoxRec box;
        xRectangle *pRects = pRectsInit;
        int nRects = nRectsInit;

        box.x1 = pRects->x;
        box.x2 = box.x1 + pRects->width;
        box.y1 = pRects->y;
        box.y2 = box.y1 + pRects->height;

        while (--nRects) {
            pRects++;
            if (box.x1 > pRects->x)
                box.x1 = pRects->x;
            if (box.x2 < (pRects->x + pRects->width))
                box.x2 = pRects->x + pRects->width;
            if (box.y1 > pRects->y)
                box.y1 = pRects->y;
            if (box.y2 < (pRects->y + pRects->height))
                box.y2 = pRects->y + pRects->height;
        }

        RootlessStartDrawing((WindowPtr) dst);
 
        if (canAccelFill(dst, pGC))
        {
            GC_UNSET_PM(pGC, dst);
        }

       pGC->ops->PolyFillRect(dst, pGC, nRectsInit, pRectsInit);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("fill rect end\n");
}


/* changed area is box around each arc (assuming arcs are all 360 degrees) */
static void RootlessPolyFillArc(DrawablePtr dst, GCPtr pGC,
                                int narcsInit, xArc *parcsInit)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("fill arc start ");

    if (narcsInit > 0) {
        BoxRec box;
        int narcs = narcsInit;
        xArc *parcs = parcsInit;

        box.x1 = parcs->x;
        box.x2 = box.x1 + parcs->width;
        box.y1 = parcs->y;
        box.y2 = box.y1 + parcs->height;

        /* should I break these up instead ? */

        while (--narcs) {
            parcs++;
            if (box.x1 > parcs->x)
                box.x1 = parcs->x;
            if (box.x2 < (parcs->x + parcs->width))
                box.x2 = parcs->x + parcs->width;
            if (box.y1 > parcs->y)
                box.y1 = parcs->y;
            if (box.y2 < (parcs->y + parcs->height))
                box.y2 = parcs->y + parcs->height;
        }

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC))
        {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->PolyFillArc(dst, pGC, narcsInit, parcsInit);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    } else {
        pGC->ops->PolyFillArc(dst, pGC, narcsInit, parcsInit);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("fill arc end\n");
}


static void RootlessImageText8(DrawablePtr dst, GCPtr pGC,
                               int x, int y, int count, char *chars)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("imagetext8 start ");

    if (count > 0) {
        int top, bot, Min, Max;
        BoxRec box;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
        if (Min > 0) Min = 0;
        Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);
        if (Max < 0) Max = 0;

        /* ugh */
        box.x1 = dst->x + x + Min +
        FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + Max +
        FONTMAXBOUNDS(pGC->font, rightSideBearing);

        box.y1 = dst->y + y - top;
        box.y2 = dst->y + y + bot;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC))
        {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->ImageText8(dst, pGC, x, y, count, chars);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    } else {
        pGC->ops->ImageText8(dst, pGC, x, y, count, chars);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("imagetext8 end\n");
}

static int RootlessPolyText8(DrawablePtr dst, GCPtr pGC,
                             int x, int y, int count, char *chars)
{
    int width; // the result, sorta

    GCOP_UNWRAP(pGC);

    RL_DEBUG_MSG("polytext8 start ");

    RootlessStartDrawing((WindowPtr) dst);
    width = pGC->ops->PolyText8(dst, pGC, x, y, count, chars);
    width -= x;

    if (width > 0) {
        BoxRec box;

        /* ugh */
        box.x1 = dst->x + x + FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + FONTMAXBOUNDS(pGC->font, rightSideBearing);

        if (count > 1) {
            if (width > 0) box.x2 += width;
            else box.x1 += width;
        }

        box.y1 = dst->y + y - FONTMAXBOUNDS(pGC->font, ascent);
        box.y2 = dst->y + y + FONTMAXBOUNDS(pGC->font, descent);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("polytext8 end\n");
    return width + x;
}

static void RootlessImageText16(DrawablePtr dst, GCPtr pGC,
                                int x, int y, int count, unsigned short *chars)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("imagetext16 start ");

    if (count > 0) {
        int top, bot, Min, Max;
        BoxRec box;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
        if (Min > 0) Min = 0;
        Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);
        if (Max < 0) Max = 0;

        /* ugh */
        box.x1 = dst->x + x + Min +
            FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + Max +
            FONTMAXBOUNDS(pGC->font, rightSideBearing);

        box.y1 = dst->y + y - top;
        box.y2 = dst->y + y + bot;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC))
        {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->ImageText16(dst, pGC, x, y, count, chars);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    } else {
        pGC->ops->ImageText16(dst, pGC, x, y, count, chars);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("imagetext16 end\n");
}

static int RootlessPolyText16(DrawablePtr dst, GCPtr pGC,
                            int x, int y, int count, unsigned short *chars)
{
    int width; // the result, sorta

    GCOP_UNWRAP(pGC);

    RL_DEBUG_MSG("polytext16 start ");

    RootlessStartDrawing((WindowPtr) dst);
    width = pGC->ops->PolyText16(dst, pGC, x, y, count, chars);
    width -= x;

    if (width > 0) {
        BoxRec box;

        /* ugh */
        box.x1 = dst->x + x + FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + FONTMAXBOUNDS(pGC->font, rightSideBearing);

        if (count > 1) {
            if (width > 0) box.x2 += width;
            else box.x1 += width;
        }

        box.y1 = dst->y + y - FONTMAXBOUNDS(pGC->font, ascent);
        box.y2 = dst->y + y + FONTMAXBOUNDS(pGC->font, descent);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("polytext16 end\n");
    return width + x;
}

static void RootlessImageGlyphBlt(DrawablePtr dst, GCPtr pGC,
                                  int x, int y, unsigned int nglyphInit,
                                  CharInfoPtr *ppciInit, pointer unused)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("imageglyph start ");

    if (nglyphInit > 0) {
        int top, bot, width = 0;
        BoxRec box;
        unsigned int nglyph = nglyphInit;
        CharInfoPtr *ppci = ppciInit;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        box.x1 = ppci[0]->metrics.leftSideBearing;
        if (box.x1 > 0) box.x1 = 0;
        box.x2 = ppci[nglyph - 1]->metrics.rightSideBearing -
            ppci[nglyph - 1]->metrics.characterWidth;
        if (box.x2 < 0) box.x2 = 0;

        box.x2 += dst->x + x;
        box.x1 += dst->x + x;

        while (nglyph--) {
            width += (*ppci)->metrics.characterWidth;
            ppci++;
        }

        if (width > 0)
            box.x2 += width;
        else
            box.x1 += width;

        box.y1 = dst->y + y - top;
        box.y2 = dst->y + y + bot;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC))
        {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->ImageGlyphBlt(dst, pGC, x, y, nglyphInit, ppciInit, unused);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    } else {
        pGC->ops->ImageGlyphBlt(dst, pGC, x, y, nglyphInit, ppciInit, unused);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("imageglyph end\n");
}

static void RootlessPolyGlyphBlt(DrawablePtr dst, GCPtr pGC,
                                 int x, int y, unsigned int nglyph,
                                 CharInfoPtr *ppci, pointer pglyphBase)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("polyglyph start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolyGlyphBlt(dst, pGC, x, y, nglyph, ppci, pglyphBase);

    if (nglyph > 0) {
        BoxRec box;

        /* ugh */
        box.x1 = dst->x + x + ppci[0]->metrics.leftSideBearing;
        box.x2 = dst->x + x + ppci[nglyph - 1]->metrics.rightSideBearing;

        if (nglyph > 1) {
            int width = 0;

            while (--nglyph) {
                width += (*ppci)->metrics.characterWidth;
                ppci++;
            }

            if (width > 0) box.x2 += width;
            else box.x1 += width;
        }

        box.y1 = dst->y + y - FONTMAXBOUNDS(pGC->font, ascent);
        box.y2 = dst->y + y + FONTMAXBOUNDS(pGC->font, descent);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox ((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("polyglyph end\n");
}


/* changed area is in dest */
static void
RootlessPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr dst,
                   int dx, int dy, int xOrg, int yOrg)
{
    BoxRec box;

    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("push pixels start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PushPixels(pGC, pBitMap, dst, dx, dy, xOrg, yOrg);

    box.x1 = xOrg + dst->x;
    box.x2 = box.x1 + dx;
    box.y1 = yOrg + dst->y;
    box.y2 = box.y1 + dy;

    TRIM_BOX(box, pGC);
    if (BOX_NOT_EMPTY(box))
        RootlessDamageBox ((WindowPtr) dst, &box);

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("push pixels end\n");
}
/*
 * Screen routines for generic rootless X server
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 * Copyright (c) 2002-2003 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "mi.h"
#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "mivalidate.h"
#include "picturestr.h"
#include "colormapst.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#include "rootlessCommon.h"
#include "rootlessWindow.h"

/* In milliseconds */
#ifndef ROOTLESS_REDISPLAY_DELAY
#define ROOTLESS_REDISPLAY_DELAY 10
#endif

extern int RootlessMiValidateTree(WindowPtr pRoot, WindowPtr pChild,
                                  VTKind kind);
extern Bool RootlessCreateGC(GCPtr pGC);

// Initialize globals
DevPrivateKeyRec rootlessGCPrivateKeyRec;
DevPrivateKeyRec rootlessScreenPrivateKeyRec;
DevPrivateKeyRec rootlessWindowPrivateKeyRec;
DevPrivateKeyRec rootlessWindowOldPixmapPrivateKeyRec;

/*
 * RootlessUpdateScreenPixmap
 *  miCreateScreenResources does not like a null framebuffer pointer,
 *  it leaves the screen pixmap with an uninitialized data pointer.
 *  Thus, rootless implementations typically set the framebuffer width
 *  to zero so that miCreateScreenResources does not allocate a screen
 *  pixmap for us. We allocate our own screen pixmap here since we need
 *  the screen pixmap to be valid (e.g. CopyArea from the root window).
 */
void
RootlessUpdateScreenPixmap(ScreenPtr pScreen)
{
    RootlessScreenRec *s = SCREENREC(pScreen);
    PixmapPtr pPix;
    unsigned int rowbytes;

    pPix = (*pScreen->GetScreenPixmap)(pScreen);
    if (pPix == NULL) {
        pPix = (*pScreen->CreatePixmap)(pScreen, 0, 0, pScreen->rootDepth, 0);
        (*pScreen->SetScreenPixmap)(pPix);
    }

    rowbytes = PixmapBytePad(pScreen->width, pScreen->rootDepth);

    if (s->pixmap_data_size < rowbytes) {
        free(s->pixmap_data);

        s->pixmap_data_size = rowbytes;
        s->pixmap_data = malloc(s->pixmap_data_size);
        if (s->pixmap_data == NULL)
            return;

        memset(s->pixmap_data, 0xFF, s->pixmap_data_size);

        pScreen->ModifyPixmapHeader(pPix, pScreen->width, pScreen->height,
                                    pScreen->rootDepth,
                                    BitsPerPixel(pScreen->rootDepth),
                                    0, s->pixmap_data);
        /* ModifyPixmapHeader ignores zero arguments, so install rowbytes
           by hand. */
        pPix->devKind = 0;
    }
}


/*
 * RootlessCreateScreenResources
 *  Rootless implementations typically set a null framebuffer pointer, which
 *  causes problems with miCreateScreenResources. We fix things up here.
 */
static Bool
RootlessCreateScreenResources(ScreenPtr pScreen)
{
    Bool ret = TRUE;

    SCREEN_UNWRAP(pScreen, CreateScreenResources);

    if (pScreen->CreateScreenResources != NULL)
        ret = (*pScreen->CreateScreenResources)(pScreen);

    SCREEN_WRAP(pScreen, CreateScreenResources);

    if (!ret)
        return ret;

    /* Make sure we have a valid screen pixmap. */

    RootlessUpdateScreenPixmap(pScreen);

    return ret;
}


static Bool
RootlessCloseScreen(int i, ScreenPtr pScreen)
{
    RootlessScreenRec *s;

    s = SCREENREC(pScreen);

    // fixme unwrap everything that was wrapped?
    pScreen->CloseScreen = s->CloseScreen;

    if (s->pixmap_data != NULL) {
        free(s->pixmap_data);
        s->pixmap_data = NULL;
        s->pixmap_data_size = 0;
    }

    free(s);
    return pScreen->CloseScreen(i, pScreen);
}


static void
RootlessGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
                 unsigned int format, unsigned long planeMask, char *pdstLine)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    SCREEN_UNWRAP(pScreen, GetImage);

    if (pDrawable->type == DRAWABLE_WINDOW) {
        int x0, y0, x1, y1;
        RootlessWindowRec *winRec;

        // Many apps use GetImage to sync with the visible frame buffer
        // FIXME: entire screen or just window or all screens?
        RootlessRedisplayScreen(pScreen);

        // RedisplayScreen stops drawing, so we need to start it again
        RootlessStartDrawing((WindowPtr)pDrawable);

        /* Check that we have some place to read from. */
        winRec = WINREC(TopLevelParent((WindowPtr) pDrawable));
        if (winRec == NULL)
            goto out;

        /* Clip to top-level window bounds. */
        /* FIXME: fbGetImage uses the width parameter to calculate the
           stride of the destination pixmap. If w is clipped, the data
           returned will be garbage, although we will not crash. */

        x0 = pDrawable->x + sx;
        y0 = pDrawable->y + sy;
        x1 = x0 + w;
        y1 = y0 + h;

        x0 = max (x0, winRec->x);
        y0 = max (y0, winRec->y);
        x1 = min (x1, winRec->x + winRec->width);
        y1 = min (y1, winRec->y + winRec->height);

        sx = x0 - pDrawable->x;
        sy = y0 - pDrawable->y;
        w = x1 - x0;
        h = y1 - y0;

        if (w <= 0 || h <= 0)
            goto out;
    }

    pScreen->GetImage(pDrawable, sx, sy, w, h, format, planeMask, pdstLine);

out:
    SCREEN_WRAP(pScreen, GetImage);
}


/*
 * RootlessSourceValidate
 *  CopyArea and CopyPlane use a GC tied to the destination drawable.
 *  StartDrawing/StopDrawing wrappers won't be called if source is
 *  a visible window but the destination isn't. So, we call StartDrawing
 *  here and leave StopDrawing for the block handler.
 */
static void
RootlessSourceValidate(DrawablePtr pDrawable, int x, int y, int w, int h,
                       unsigned int subWindowMode)
{
    SCREEN_UNWRAP(pDrawable->pScreen, SourceValidate);
    if (pDrawable->type == DRAWABLE_WINDOW) {
        WindowPtr pWin = (WindowPtr)pDrawable;
        RootlessStartDrawing(pWin);
    }
    if (pDrawable->pScreen->SourceValidate) {
        pDrawable->pScreen->SourceValidate(pDrawable, x, y, w, h, subWindowMode);
    }
    SCREEN_WRAP(pDrawable->pScreen, SourceValidate);
}

static void
RootlessComposite(CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
                  INT16 xSrc, INT16 ySrc, INT16  xMask, INT16  yMask,
                  INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    WindowPtr srcWin, dstWin, maskWin = NULL;

    if (pMask) {                        // pMask can be NULL
        maskWin = (pMask->pDrawable->type == DRAWABLE_WINDOW) ?
                  (WindowPtr)pMask->pDrawable :  NULL;
    }
    srcWin  = (pSrc->pDrawable && pSrc->pDrawable->type  == DRAWABLE_WINDOW) ?
              (WindowPtr)pSrc->pDrawable  :  NULL;
    dstWin  = (pDst->pDrawable->type == DRAWABLE_WINDOW) ?
              (WindowPtr)pDst->pDrawable  :  NULL;

    // SCREEN_UNWRAP(ps, Composite);
    ps->Composite = SCREENREC(pScreen)->Composite;

    if (srcWin  && IsFramedWindow(srcWin))
        RootlessStartDrawing(srcWin);
    if (maskWin && IsFramedWindow(maskWin))
        RootlessStartDrawing(maskWin);
    if (dstWin  && IsFramedWindow(dstWin))
        RootlessStartDrawing(dstWin);

    ps->Composite(op, pSrc, pMask, pDst,
                  xSrc, ySrc, xMask, yMask,
                  xDst, yDst, width, height);

    if (dstWin  && IsFramedWindow(dstWin)) {
        RootlessDamageRect(dstWin, xDst, yDst, width, height);
    }

    ps->Composite = RootlessComposite;
    // SCREEN_WRAP(ps, Composite);
}


static void
RootlessGlyphs(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
               PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
               int nlist, GlyphListPtr list, GlyphPtr *glyphs)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    int x, y;
    int n;
    GlyphPtr glyph;
    WindowPtr srcWin, dstWin;

    srcWin = (pSrc->pDrawable && pSrc->pDrawable->type == DRAWABLE_WINDOW) ?
             (WindowPtr)pSrc->pDrawable  :  NULL;
    dstWin = (pDst->pDrawable->type == DRAWABLE_WINDOW) ?
             (WindowPtr)pDst->pDrawable  :  NULL;

    if (srcWin && IsFramedWindow(srcWin)) RootlessStartDrawing(srcWin);
    if (dstWin && IsFramedWindow(dstWin)) RootlessStartDrawing(dstWin);

    //SCREEN_UNWRAP(ps, Glyphs);
    ps->Glyphs = SCREENREC(pScreen)->Glyphs;
    ps->Glyphs(op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
    ps->Glyphs = RootlessGlyphs;
    //SCREEN_WRAP(ps, Glyphs);

    if (dstWin && IsFramedWindow(dstWin)) {
        x = xSrc;
        y = ySrc;

        while (nlist--) {
            x += list->xOff;
            y += list->yOff;
            n = list->len;

            /* Calling DamageRect for the bounding box of each glyph is
               inefficient. So compute the union of all glyphs in a list
               and damage that. */

            if (n > 0) {
                BoxRec box;

                glyph = *glyphs++;

                box.x1 = x - glyph->info.x;
                box.y1 = y - glyph->info.y;
                box.x2 = box.x1 + glyph->info.width;
                box.y2 = box.y1 + glyph->info.height;

                x += glyph->info.xOff;
                y += glyph->info.yOff;

                while (--n > 0) {
                    short x1, y1, x2, y2;

                    glyph = *glyphs++;

                    x1 = x - glyph->info.x;
                    y1 = y - glyph->info.y;
                    x2 = x1 + glyph->info.width;
                    y2 = y1 + glyph->info.height;

                    box.x1 = max (box.x1, x1);
                    box.y1 = max (box.y1, y1);
                    box.x2 = max (box.x2, x2);
                    box.y2 = max (box.y2, y2);

                    x += glyph->info.xOff;
                    y += glyph->info.yOff;
                }

                RootlessDamageBox(dstWin, &box);
            }
            list++;
        }
    }
}


/*
 * RootlessValidateTree
 *  ValidateTree is modified in two ways:
 *   - top-level windows don't clip each other
 *   - windows aren't clipped against root.
 *  These only matter when validating from the root.
 */
static int
RootlessValidateTree(WindowPtr pParent, WindowPtr pChild, VTKind kind)
{
    int result;
    RegionRec saveRoot;
    ScreenPtr pScreen = pParent->drawable.pScreen;

    SCREEN_UNWRAP(pScreen, ValidateTree);
    RL_DEBUG_MSG("VALIDATETREE start ");

    // Use our custom version to validate from root
    if (IsRoot(pParent)) {
        RL_DEBUG_MSG("custom ");
        result = RootlessMiValidateTree(pParent, pChild, kind);
    } else {
        HUGE_ROOT(pParent);
        result = pScreen->ValidateTree(pParent, pChild, kind);
        NORMAL_ROOT(pParent);
    }

    SCREEN_WRAP(pScreen, ValidateTree);
    RL_DEBUG_MSG("VALIDATETREE end\n");

    return result;
}


/*
 * RootlessMarkOverlappedWindows
 *  MarkOverlappedWindows is modified to ignore overlapping
 *  top-level windows.
 */
static Bool
RootlessMarkOverlappedWindows(WindowPtr pWin, WindowPtr pFirst,
                              WindowPtr *ppLayerWin)
{
    RegionRec saveRoot;
    Bool result;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    SCREEN_UNWRAP(pScreen, MarkOverlappedWindows);
    RL_DEBUG_MSG("MARKOVERLAPPEDWINDOWS start ");

    HUGE_ROOT(pWin);
    if (IsRoot(pWin)) {
        // root - mark nothing
        RL_DEBUG_MSG("is root not marking ");
        result = FALSE;
    }
    else if (! IsTopLevel(pWin)) {
        // not top-level window - mark normally
        result = pScreen->MarkOverlappedWindows(pWin, pFirst, ppLayerWin);
    }
    else {
        //top-level window - mark children ONLY - NO overlaps with sibs (?)
        // This code copied from miMarkOverlappedWindows()

        register WindowPtr pChild;
        Bool anyMarked = FALSE;
        MarkWindowProcPtr MarkWindow = pScreen->MarkWindow;

        RL_DEBUG_MSG("is top level! ");
        /* single layered systems are easy */
        if (ppLayerWin) *ppLayerWin = pWin;

        if (pWin == pFirst) {
            /* Blindly mark pWin and all of its inferiors.   This is a slight
             * overkill if there are mapped windows that outside pWin's border,
             * but it's better than wasting time on RectIn checks.
             */
            pChild = pWin;
            while (1) {
                if (pChild->viewable) {
                    if (RegionBroken(&pChild->winSize))
                        SetWinSize (pChild);
                    if (RegionBroken(&pChild->borderSize))
                        SetBorderSize (pChild);
                    (* MarkWindow)(pChild);
                    if (pChild->firstChild) {
                        pChild = pChild->firstChild;
                        continue;
                    }
                }
                while (!pChild->nextSib && (pChild != pWin))
                    pChild = pChild->parent;
                if (pChild == pWin)
                    break;
                pChild = pChild->nextSib;
            }
            anyMarked = TRUE;
        }
        if (anyMarked)
            (* MarkWindow)(pWin->parent);
        result = anyMarked;
    }
    NORMAL_ROOT(pWin);
    SCREEN_WRAP(pScreen, MarkOverlappedWindows);
    RL_DEBUG_MSG("MARKOVERLAPPEDWINDOWS end\n");

    return result;
}

static void expose_1 (WindowPtr pWin) {
    WindowPtr pChild;
    
    if (!pWin->realized)
        return;
    
    miPaintWindow(pWin, &pWin->borderClip, PW_BACKGROUND);
    
    /* FIXME: comments in windowstr.h indicate that borderClip doesn't
     include subwindow visibility. But I'm not so sure.. so we may
     be exposing too much.. */
    
    miSendExposures (pWin, &pWin->borderClip,
                     pWin->drawable.x, pWin->drawable.y);
    
    for (pChild = pWin->firstChild; pChild != NULL; pChild = pChild->nextSib)
        expose_1 (pChild);
}

void
RootlessScreenExpose (ScreenPtr pScreen)
{
    expose_1 (pScreen->root);
}


ColormapPtr
RootlessGetColormap (ScreenPtr pScreen)
{
  RootlessScreenRec *s = SCREENREC (pScreen);

  return s->colormap;
}

static void
RootlessInstallColormap (ColormapPtr pMap)
{
  ScreenPtr pScreen = pMap->pScreen;
  RootlessScreenRec *s = SCREENREC (pScreen);

  SCREEN_UNWRAP(pScreen, InstallColormap);

  if (s->colormap != pMap) {
    s->colormap = pMap;
    s->colormap_changed = TRUE;
    RootlessQueueRedisplay (pScreen);
  }

  pScreen->InstallColormap (pMap);

  SCREEN_WRAP (pScreen, InstallColormap);
}

static void
RootlessUninstallColormap (ColormapPtr pMap)
{
  ScreenPtr pScreen = pMap->pScreen;
  RootlessScreenRec *s = SCREENREC (pScreen);

  SCREEN_UNWRAP(pScreen, UninstallColormap);

  if (s->colormap == pMap)
    s->colormap = NULL;

  pScreen->UninstallColormap (pMap);

  SCREEN_WRAP(pScreen, UninstallColormap);
}

static void
RootlessStoreColors (ColormapPtr pMap, int ndef, xColorItem *pdef)
{
  ScreenPtr pScreen = pMap->pScreen;
  RootlessScreenRec *s = SCREENREC (pScreen);

  SCREEN_UNWRAP(pScreen, StoreColors);

  if (s->colormap == pMap && ndef > 0) {
    s->colormap_changed = TRUE;
    RootlessQueueRedisplay (pScreen);
  }

  pScreen->StoreColors (pMap, ndef, pdef);

  SCREEN_WRAP(pScreen, StoreColors);
}


static CARD32
RootlessRedisplayCallback(OsTimerPtr timer, CARD32 time, void *arg)
{
    RootlessScreenRec *screenRec = arg;

    if (!screenRec->redisplay_queued) {
        /* No update needed. Stop the timer. */

        screenRec->redisplay_timer_set = FALSE;
        return 0;
    }

    screenRec->redisplay_queued = FALSE;

    /* Mark that we should redisplay before waiting for I/O next time */
    screenRec->redisplay_expired = TRUE;

    /* Reinstall the timer immediately, so we get as close to our
       redisplay interval as possible. */

    return ROOTLESS_REDISPLAY_DELAY;
}


/*
 * RootlessQueueRedisplay
 *  Queue a redisplay after a timer delay to ensure we do not redisplay
 *  too frequently.
 */
void
RootlessQueueRedisplay(ScreenPtr pScreen)
{
    RootlessScreenRec *screenRec = SCREENREC(pScreen);

    screenRec->redisplay_queued = TRUE;

    if (screenRec->redisplay_timer_set)
        return;

    screenRec->redisplay_timer = TimerSet(screenRec->redisplay_timer,
                                          0, ROOTLESS_REDISPLAY_DELAY,
                                          RootlessRedisplayCallback,
                                          screenRec);
    screenRec->redisplay_timer_set = TRUE;
}


/*
 * RootlessBlockHandler
 *  If the redisplay timer has expired, flush drawing before blocking
 *  on select().
 */
static void
RootlessBlockHandler(pointer pbdata, OSTimePtr pTimeout, pointer pReadmask)
{
    ScreenPtr pScreen = pbdata;
    RootlessScreenRec *screenRec = SCREENREC(pScreen);

    if (screenRec->redisplay_expired) {
        screenRec->redisplay_expired = FALSE;

        RootlessRedisplayScreen(pScreen);
    }
}


static void
RootlessWakeupHandler(pointer data, int i, pointer LastSelectMask)
{
    // nothing here
}


static Bool
RootlessAllocatePrivates(ScreenPtr pScreen)
{
    RootlessScreenRec *s;

    if (!dixRegisterPrivateKey(&rootlessGCPrivateKeyRec, PRIVATE_GC, sizeof(RootlessGCRec)))
        return FALSE;
    if (!dixRegisterPrivateKey(&rootlessScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&rootlessWindowPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&rootlessWindowOldPixmapPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;

    s = malloc(sizeof(RootlessScreenRec));
    if (! s) return FALSE;
    SETSCREENREC(pScreen, s);

    s->pixmap_data = NULL;
    s->pixmap_data_size = 0;

    s->redisplay_timer = NULL;
    s->redisplay_timer_set = FALSE;

    return TRUE;
}


static void
RootlessWrap(ScreenPtr pScreen)
{
    RootlessScreenRec *s = SCREENREC(pScreen);

#define WRAP(a) \
    if (pScreen->a) { \
        s->a = pScreen->a; \
    } else { \
        RL_DEBUG_MSG("null screen fn " #a "\n"); \
        s->a = NULL; \
    } \
    pScreen->a = Rootless##a

    WRAP(CreateScreenResources);
    WRAP(CloseScreen);
    WRAP(CreateGC);
    WRAP(CopyWindow);
    WRAP(GetImage);
    WRAP(SourceValidate);
    WRAP(CreateWindow);
    WRAP(DestroyWindow);
    WRAP(RealizeWindow);
    WRAP(UnrealizeWindow);
    WRAP(MoveWindow);
    WRAP(PositionWindow);
    WRAP(ResizeWindow);
    WRAP(RestackWindow);
    WRAP(ReparentWindow);
    WRAP(ChangeBorderWidth);
    WRAP(MarkOverlappedWindows);
    WRAP(ValidateTree);
    WRAP(ChangeWindowAttributes);
    WRAP(InstallColormap);
    WRAP(UninstallColormap);
    WRAP(StoreColors);

    WRAP(SetShape);

    {
        // Composite and Glyphs don't use normal screen wrapping
        PictureScreenPtr ps = GetPictureScreen(pScreen);
        s->Composite = ps->Composite;
        ps->Composite = RootlessComposite;
        s->Glyphs = ps->Glyphs;
        ps->Glyphs = RootlessGlyphs;
    }

    // WRAP(ClearToBackground); fixme put this back? useful for shaped wins?

#undef WRAP
}


/*
 * RootlessInit
 *  Called by the rootless implementation to initialize the rootless layer.
 *  Rootless wraps lots of stuff and needs a bunch of devPrivates.
 */
Bool RootlessInit(ScreenPtr pScreen, RootlessFrameProcsPtr procs)
{
    RootlessScreenRec *s;

    if (!RootlessAllocatePrivates(pScreen))
        return FALSE;

    s = SCREENREC(pScreen);

    s->imp = procs;
    s->colormap = NULL;
    s->redisplay_expired = FALSE;

    RootlessWrap(pScreen);

    if (!RegisterBlockAndWakeupHandlers(RootlessBlockHandler,
                                        RootlessWakeupHandler,
                                        (pointer) pScreen))
    {
        return FALSE;
    }

    return TRUE;
}

void RootlessUpdateRooted (Bool state) {
    int i;
    
    if (!state)
    {
        for (i = 0; i < screenInfo.numScreens; i++)
            RootlessDisableRoot (screenInfo.screens[i]);
    }
    else
    {
        for (i = 0; i < screenInfo.numScreens; i++)
            RootlessEnableRoot (screenInfo.screens[i]);
    }
}
/*
 * Calculate window clip lists for rootless mode
 *
 * This file is very closely based on mivaltree.c.
 */

/*
 * mivaltree.c --
 *	Functions for recalculating window clip lists. Main function
 *	is miValidateTree.
 *

Copyright 1987, 1988, 1989, 1998  The Open Group

All Rights Reserved.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

 *
 * Copyright 1987, 1988, 1989 by 
 * Digital Equipment Corporation, Maynard, Massachusetts,
 * 
 *                         All Rights Reserved
 * 
 * Permission to use, copy, modify, and distribute this software and its 
 * documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in 
 * supporting documentation, and that the name of Digital not be
 * used in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.  
 * 
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * 
 ******************************************************************/

/* The panoramix components contained the following notice */
/*****************************************************************

Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/
 /* 
  * Aug '86: Susan Angebranndt -- original code
  * July '87: Adam de Boor -- substantially modified and commented
  * Summer '89: Joel McCormack -- so fast you wouldn't believe it possible.
  *             In particular, much improved code for window mapping and
  *             circulating.
  *		Bob Scheifler -- avoid miComputeClips for unmapped windows,
  *				 valdata changes
  */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stddef.h> /* For NULL */
#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "validate.h"
#include    "windowstr.h"
#include    "mi.h"
#include    "regionstr.h"
#include    "mivalidate.h"

#include    "globals.h"

int RootlessMiValidateTree (WindowPtr pRoot, WindowPtr pChild, VTKind kind);

/*
 * Compute the visibility of a shaped window
 */
static int
RootlessShapedWindowIn (RegionPtr universe,
			RegionPtr bounding, BoxPtr rect, int x, int y)
{
    BoxRec  box;
    register BoxPtr  boundBox;
    int	    nbox;
    Bool    someIn, someOut;
    register int t, x1, y1, x2, y2;

    nbox = RegionNumRects (bounding);
    boundBox = RegionRects (bounding);
    someIn = someOut = FALSE;
    x1 = rect->x1;
    y1 = rect->y1;
    x2 = rect->x2;
    y2 = rect->y2;
    while (nbox--)
    {
	if ((t = boundBox->x1 + x) < x1)
	    t = x1;
	box.x1 = t;
	if ((t = boundBox->y1 + y) < y1)
	    t = y1;
	box.y1 = t;
	if ((t = boundBox->x2 + x) > x2)
	    t = x2;
	box.x2 = t;
	if ((t = boundBox->y2 + y) > y2)
	    t = y2;
	box.y2 = t;
	if (box.x1 > box.x2)
	    box.x2 = box.x1;
	if (box.y1 > box.y2)
	    box.y2 = box.y1;
	switch (RegionContainsRect(universe, &box))
	{
	case rgnIN:
	    if (someOut)
		return rgnPART;
	    someIn = TRUE;
	    break;
	case rgnOUT:
	    if (someIn)
		return rgnPART;
	    someOut = TRUE;
	    break;
	default:
	    return rgnPART;
	}
	boundBox++;
    }
    if (someIn)
	return rgnIN;
    return rgnOUT;
}

#define HasParentRelativeBorder(w) (!(w)->borderIsPixel && \
				    HasBorder(w) && \
				    (w)->backgroundState == ParentRelative)


/*
 *-----------------------------------------------------------------------
 * RootlessComputeClips --
 *	Recompute the clipList, borderClip, exposed and borderExposed
 *	regions for pParent and its children. Only viewable windows are
 *	taken into account.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	clipList, borderClip, exposed and borderExposed are altered.
 *	A VisibilityNotify event may be generated on the parent window.
 *
 *-----------------------------------------------------------------------
 */
static void
RootlessComputeClips (WindowPtr pParent, ScreenPtr pScreen, 
		      RegionPtr universe, VTKind kind, RegionPtr exposed)
{
    int			dx,
			dy;
    RegionRec		childUniverse;
    register WindowPtr	pChild;
    int     	  	oldVis, newVis;
    BoxRec		borderSize;
    RegionRec		childUnion;
    Bool		overlap;
    RegionPtr		borderVisible;
    /*
     * Figure out the new visibility of this window.
     * The extent of the universe should be the same as the extent of
     * the borderSize region. If the window is unobscured, this rectangle
     * will be completely inside the universe (the universe will cover it
     * completely). If the window is completely obscured, none of the
     * universe will cover the rectangle.
     */
    borderSize.x1 = pParent->drawable.x - wBorderWidth(pParent);
    borderSize.y1 = pParent->drawable.y - wBorderWidth(pParent);
    dx = (int) pParent->drawable.x + (int) pParent->drawable.width + wBorderWidth(pParent);
    if (dx > 32767)
	dx = 32767;
    borderSize.x2 = dx;
    dy = (int) pParent->drawable.y + (int) pParent->drawable.height + wBorderWidth(pParent);
    if (dy > 32767)
	dy = 32767;
    borderSize.y2 = dy;

    oldVis = pParent->visibility;
    switch (RegionContainsRect(universe, &borderSize))
    {
    case rgnIN:
	    newVis = VisibilityUnobscured;
	    break;
	case rgnPART:
	    newVis = VisibilityPartiallyObscured;
	    {
		RegionPtr   pBounding;

		if ((pBounding = wBoundingShape (pParent)))
		{
		    switch (RootlessShapedWindowIn (universe,
						    pBounding, &borderSize,
						    pParent->drawable.x,
						    pParent->drawable.y))
		    {
		    case rgnIN:
			newVis = VisibilityUnobscured;
			break;
		    case rgnOUT:
			newVis = VisibilityFullyObscured;
			break;
		    }
		}
	    }
	    break;
	default:
	    newVis = VisibilityFullyObscured;
	    break;
    }

    pParent->visibility = newVis;
    if (oldVis != newVis &&
	((pParent->eventMask | wOtherEventMasks(pParent)) & VisibilityChangeMask))
	SendVisibilityNotify(pParent);

    dx = pParent->drawable.x - pParent->valdata->before.oldAbsCorner.x;
    dy = pParent->drawable.y - pParent->valdata->before.oldAbsCorner.y;

    /*
     * avoid computations when dealing with simple operations
     */

    switch (kind) {
    case VTMap:
    case VTStack:
    case VTUnmap:
	break;
    case VTMove:
	if ((oldVis == newVis) &&
	    ((oldVis == VisibilityFullyObscured) ||
	     (oldVis == VisibilityUnobscured)))
	{
	    pChild = pParent;
	    while (1)
	    {
		if (pChild->viewable)
		{
		    if (pChild->visibility != VisibilityFullyObscured)
		    {
			RegionTranslate(&pChild->borderClip,
						      dx, dy);
			RegionTranslate(&pChild->clipList,
						      dx, dy);
			pChild->drawable.serialNumber = NEXT_SERIAL_NUMBER;
			if (pScreen->ClipNotify)
			    (* pScreen->ClipNotify) (pChild, dx, dy);

		    }
		    if (pChild->valdata)
		    {
			RegionNull(&pChild->valdata->after.borderExposed);
			if (HasParentRelativeBorder(pChild))
			  {
			    RegionSubtract(&pChild->valdata->after.borderExposed,
					   &pChild->borderClip,
					   &pChild->winSize);
			}
			RegionNull(&pChild->valdata->after.exposed);
		    }
		    if (pChild->firstChild)
		    {
			pChild = pChild->firstChild;
			continue;
		    }
		}
		while (!pChild->nextSib && (pChild != pParent))
		    pChild = pChild->parent;
		if (pChild == pParent)
		    break;
		pChild = pChild->nextSib;
	    }
	    return;
	}
	/* fall through */
    default:
    	/*
     	 * To calculate exposures correctly, we have to translate the old
     	 * borderClip and clipList regions to the window's new location so there
     	 * is a correspondence between pieces of the new and old clipping regions.
     	 */
    	if (dx || dy) 
    	{
	    /*
	     * We translate the old clipList because that will be exposed or copied
	     * if gravity is right.
	     */
	    RegionTranslate(&pParent->borderClip, dx, dy);
	    RegionTranslate(&pParent->clipList, dx, dy);
    	} 
	break;
    case VTBroken:
	RegionEmpty(&pParent->borderClip);
	RegionEmpty(&pParent->clipList);
	break;
    }

    borderVisible = pParent->valdata->before.borderVisible;
    RegionNull(&pParent->valdata->after.borderExposed);
    RegionNull(&pParent->valdata->after.exposed);

    /*
     * Since the borderClip must not be clipped by the children, we do
     * the border exposure first...
     *
     * 'universe' is the window's borderClip. To figure the exposures, remove
     * the area that used to be exposed from the new.
     * This leaves a region of pieces that weren't exposed before.
     */

    if (HasBorder (pParent))
    {
    	if (borderVisible)
    	{
	    /*
	     * when the border changes shape, the old visible portions
	     * of the border will be saved by DIX in borderVisible --
	     * use that region and destroy it
	     */
	    RegionSubtract(exposed, universe, borderVisible);
	    RegionDestroy(borderVisible);
    	}
    	else
    	{
	    RegionSubtract(exposed, universe, &pParent->borderClip);
    	}
	if (HasParentRelativeBorder(pParent) && (dx || dy)) {
	    RegionSubtract(&pParent->valdata->after.borderExposed,
				  universe,
				  &pParent->winSize);
	} else {
	    RegionSubtract(&pParent->valdata->after.borderExposed,
			       exposed, &pParent->winSize);
	}

	RegionCopy(&pParent->borderClip, universe);
    
    	/*
     	 * To get the right clipList for the parent, and to make doubly sure
     	 * that no child overlaps the parent's border, we remove the parent's
     	 * border from the universe before proceeding.
     	 */
    
	RegionIntersect(universe, universe, &pParent->winSize);
    }
    else
	RegionCopy(&pParent->borderClip, universe);
    
    if ((pChild = pParent->firstChild) && pParent->mapped)
    {
	RegionNull(&childUniverse);
	RegionNull(&childUnion);
	if ((pChild->drawable.y < pParent->lastChild->drawable.y) ||
	    ((pChild->drawable.y == pParent->lastChild->drawable.y) &&
	     (pChild->drawable.x < pParent->lastChild->drawable.x)))
	{
	    for (; pChild; pChild = pChild->nextSib)
	    {
		if (pChild->viewable)
		    RegionAppend(&childUnion, &pChild->borderSize);
	    }
	}
	else
	{
	    for (pChild = pParent->lastChild; pChild; pChild = pChild->prevSib)
	    {
		if (pChild->viewable)
		    RegionAppend(&childUnion, &pChild->borderSize);
	    }
	}
	RegionValidate(&childUnion, &overlap);

	for (pChild = pParent->firstChild;
	     pChild;
	     pChild = pChild->nextSib)
 	{
	    if (pChild->viewable) {
		/*
		 * If the child is viewable, we want to remove its extents
		 * from the current universe, but we only re-clip it if
		 * it's been marked.
		 */
		if (pChild->valdata) {
		    /*
		     * Figure out the new universe from the child's
		     * perspective and recurse.
		     */
		    RegionIntersect(&childUniverse,
					    universe,
					    &pChild->borderSize);
		    RootlessComputeClips (pChild, pScreen, &childUniverse, 
					  kind, exposed);
		}
		/*
		 * Once the child has been processed, we remove its extents
		 * from the current universe, thus denying its space to any
		 * other sibling.
		 */
		if (overlap)
		    RegionSubtract(universe, universe,
					  &pChild->borderSize);
	    }
	}
	if (!overlap)
	    RegionSubtract(universe, universe, &childUnion);
	RegionUninit(&childUnion);
	RegionUninit(&childUniverse);
    } /* if any children */

    /*
     * 'universe' now contains the new clipList for the parent window.
     *
     * To figure the exposure of the window we subtract the old clip from the
     * new, just as for the border.
     */

    if (oldVis == VisibilityFullyObscured ||
	oldVis == VisibilityNotViewable)
    {
	RegionCopy(&pParent->valdata->after.exposed, universe);
    }
    else if (newVis != VisibilityFullyObscured &&
	     newVis != VisibilityNotViewable)
    {
	RegionSubtract(&pParent->valdata->after.exposed,
			       universe, &pParent->clipList);
    }

    /* HACK ALERT - copying contents of regions, instead of regions */
    {
	RegionRec   tmp;

	tmp = pParent->clipList;
	pParent->clipList = *universe;
	*universe = tmp;
    }

#ifdef NOTDEF
    RegionCopy(&pParent->clipList, universe);
#endif

    pParent->drawable.serialNumber = NEXT_SERIAL_NUMBER;

    if (pScreen->ClipNotify)
	(* pScreen->ClipNotify) (pParent, dx, dy);
}

static void
RootlessTreeObscured(WindowPtr pParent)
{
    register WindowPtr pChild;
    register int    oldVis;

    pChild = pParent;
    while (1)
    {
	if (pChild->viewable)
	{
	    oldVis = pChild->visibility;
	    if (oldVis != (pChild->visibility = VisibilityFullyObscured) &&
		((pChild->eventMask | wOtherEventMasks(pChild)) & VisibilityChangeMask))
		SendVisibilityNotify(pChild);
	    if (pChild->firstChild)
	    {
		pChild = pChild->firstChild;
		continue;
	    }
	}
	while (!pChild->nextSib && (pChild != pParent))
	    pChild = pChild->parent;
	if (pChild == pParent)
	    break;
	pChild = pChild->nextSib;
    }
}

/*
 *-----------------------------------------------------------------------
 * RootlessMiValidateTree --
 *	Recomputes the clip list for pParent and all its inferiors.
 *
 * Results:
 *	Always returns 1.
 *
 * Side Effects:
 *	The clipList, borderClip, exposed, and borderExposed regions for
 *	each marked window are altered.
 *
 * Notes:
 *	This routine assumes that all affected windows have been marked
 *	(valdata created) and their winSize and borderSize regions
 *	adjusted to correspond to their new positions. The borderClip and
 *	clipList regions should not have been touched.
 *
 *	The top-most level is treated differently from all lower levels
 *	because pParent is unchanged. For the top level, we merge the
 *	regions taken up by the marked children back into the clipList
 *	for pParent, thus forming a region from which the marked children
 *	can claim their areas. For lower levels, where the old clipList
 *	and borderClip are invalid, we can't do this and have to do the
 *	extra operations done in miComputeClips, but this is much faster
 *	e.g. when only one child has moved...
 *
 *-----------------------------------------------------------------------
 */
/* 
   Quartz version: used for validate from root in rootless mode.
   We need to make sure top-level windows don't clip each other, 
   and that top-level windows aren't clipped to the root window.
*/
/*ARGSUSED*/
// fixme this is ugly
// Xprint/ValTree.c doesn't work, but maybe that method can?
int
RootlessMiValidateTree (WindowPtr pRoot, /* Parent to validate */
			WindowPtr pChild, /* First child of pRoot that was
					   * affected */
			VTKind kind /* What kind of configuration caused call */)
{
    RegionRec	  	childClip;  /* The new borderClip for the current
				     * child */
    RegionRec		exposed;    /* For intermediate calculations */
    register ScreenPtr	pScreen;
    register WindowPtr	pWin;

    pScreen = pRoot->drawable.pScreen;
    if (pChild == NullWindow)
	pChild = pRoot->firstChild;

    RegionNull(&childClip);
    RegionNull(&exposed);

    if (RegionBroken(&pRoot->clipList) &&
	!RegionBroken(&pRoot->borderClip))
    {
        // fixme this might not work, but hopefully doesn't happen anyway.
        kind = VTBroken;
        RegionEmpty(&pRoot->clipList);
        ErrorF("ValidateTree: BUSTED!\n");
    }

    /* 
     * Recursively compute the clips for all children of the root. 
     * They don't clip against each other or the root itself, so 
     * childClip is always reset to that child's size.
     */

    for (pWin = pChild;
	 pWin != NullWindow;
	 pWin = pWin->nextSib)
    {
        if (pWin->viewable) {
            if (pWin->valdata) {
                RegionCopy(&childClip, &pWin->borderSize);
                RootlessComputeClips (pWin, pScreen, &childClip, kind, &exposed);
            } else if (pWin->visibility == VisibilityNotViewable) {
                RootlessTreeObscured(pWin);
            }
        } else {
            if (pWin->valdata) {
                RegionEmpty(&pWin->clipList);
                if (pScreen->ClipNotify)
                    (* pScreen->ClipNotify) (pWin, 0, 0);
                RegionEmpty(&pWin->borderClip);
                pWin->valdata = NULL;
            }
        }
    }

    RegionUninit(&childClip);

    /* The root is never clipped by its children, so nothing on the root 
       is ever exposed by moving or mapping its children. */
    RegionNull(&pRoot->valdata->after.exposed);
    RegionNull(&pRoot->valdata->after.borderExposed);

    return 1;
}
/*
 * Rootless window management
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 * Copyright (c) 2002-2004 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stddef.h> /* For NULL */
#include <limits.h> /* For CHAR_BIT */
#include <assert.h>
#include <X11/Xatom.h>
#ifdef __APPLE__
#include <Xplugin.h>
#include "mi.h"
#include "pixmapstr.h"
#include "windowstr.h"
//#include <X11/extensions/applewm.h>
extern int darwinMainScreenX, darwinMainScreenY;
extern Bool no_configure_window;
#endif
#include "fb.h"

#include "rootlessCommon.h"
#include "rootlessWindow.h"

#define SCREEN_TO_GLOBAL_X \
    (pScreen->x + rootlessGlobalOffsetX)
#define SCREEN_TO_GLOBAL_Y \
    (pScreen->y + rootlessGlobalOffsetY)

#define DEFINE_ATOM_HELPER(func,atom_name)                      \
  static Atom func (void) {                                       \
    static unsigned int generation = 0;                             \
    static Atom atom;                                           \
    if (generation != serverGeneration) {                       \
      generation = serverGeneration;                          \
      atom = MakeAtom (atom_name, strlen (atom_name), TRUE);  \
    }                                                           \
    return atom;                                                \
  }

DEFINE_ATOM_HELPER (xa_native_window_id, "_NATIVE_WINDOW_ID")

static Bool windows_hidden;
// TODO - abstract xp functions

#ifdef __APPLE__

// XXX: identical to x_cvt_vptr_to_uint ?
#define MAKE_WINDOW_ID(x)		((xp_window_id)((size_t)(x)))

void
RootlessNativeWindowStateChanged (WindowPtr pWin, unsigned int state)
{
  RootlessWindowRec *winRec;

  if (pWin == NULL) return;

  winRec = WINREC (pWin);
  if (winRec == NULL) return;

  winRec->is_offscreen = ((state & XP_WINDOW_STATE_OFFSCREEN) != 0);
  winRec->is_obscured = ((state & XP_WINDOW_STATE_OBSCURED) != 0);
  pWin->rootlessUnhittable = winRec->is_offscreen;
}

void RootlessNativeWindowMoved (WindowPtr pWin) {
    xp_box bounds;
    int sx, sy, err;
    XID vlist[2];
    Mask mask;
    ClientPtr pClient;
    RootlessWindowRec *winRec;
    
    winRec = WINREC(pWin);
    
    if (xp_get_window_bounds (MAKE_WINDOW_ID(winRec->wid), &bounds) != Success) return;
    
    sx = pWin->drawable.pScreen->x + darwinMainScreenX;
    sy = pWin->drawable.pScreen->y + darwinMainScreenY;
    
    /* Fake up a ConfigureWindow packet to resize the window to the current bounds. */
    vlist[0] = (INT16) bounds.x1 - sx;
    vlist[1] = (INT16) bounds.y1 - sy;
    mask = CWX | CWY;
    
    /* pretend we're the owner of the window! */
    err = dixLookupClient(&pClient, pWin->drawable.id, serverClient, DixUnknownAccess);
    if(err != Success) {
        ErrorF("RootlessNativeWindowMoved(): Failed to lookup window: 0x%x\n", (unsigned int)pWin->drawable.id);
        return;
    }
    
    /* Don't want to do anything to the physical window (avoids 
     notification-response feedback loops) */
    
    no_configure_window = TRUE;
    ConfigureWindow (pWin, mask, vlist, pClient);
    no_configure_window = FALSE;
}

#endif /* __APPLE__ */

/*
 * RootlessCreateWindow
 *  For now, don't create a physical window until either the window is
 *  realized, or we really need it (e.g. to attach VRAM surfaces to).
 *  Do reset the window size so it's not clipped by the root window.
 */
Bool
RootlessCreateWindow(WindowPtr pWin)
{
    Bool result;
    RegionRec saveRoot;

    SETWINREC(pWin, NULL);
    dixSetPrivate(&pWin->devPrivates, rootlessWindowOldPixmapPrivateKey, NULL);

    SCREEN_UNWRAP(pWin->drawable.pScreen, CreateWindow);

    if (!IsRoot(pWin)) {
        /* win/border size set by DIX, not by wrapped CreateWindow, so
           correct it here. Don't HUGE_ROOT when pWin is the root! */

        HUGE_ROOT(pWin);
        SetWinSize(pWin);
        SetBorderSize(pWin);
    }

    result = pWin->drawable.pScreen->CreateWindow(pWin);

    if (pWin->parent) {
        NORMAL_ROOT(pWin);
    }

    SCREEN_WRAP(pWin->drawable.pScreen, CreateWindow);

    return result;
}


/*
 * RootlessDestroyFrame
 *  Destroy the physical window associated with the given window.
 */
static void
RootlessDestroyFrame(WindowPtr pWin, RootlessWindowPtr winRec)
{
    SCREENREC(pWin->drawable.pScreen)->imp->DestroyFrame(winRec->wid);
    free(winRec);
    SETWINREC(pWin, NULL);
}


/*
 * RootlessDestroyWindow
 *  Destroy the physical window associated with the given window.
 */
Bool
RootlessDestroyWindow(WindowPtr pWin)
{
    RootlessWindowRec *winRec = WINREC(pWin);
    Bool result;

    if (winRec != NULL) {
        RootlessDestroyFrame(pWin, winRec);
    }

    SCREEN_UNWRAP(pWin->drawable.pScreen, DestroyWindow);
    result = pWin->drawable.pScreen->DestroyWindow(pWin);
    SCREEN_WRAP(pWin->drawable.pScreen, DestroyWindow);

    return result;
}



static Bool
RootlessGetShape(WindowPtr pWin, RegionPtr pShape)
{
    if (wBoundingShape(pWin) == NULL)
        return FALSE;

    /* wBoundingShape is relative to *inner* origin of window.
       Translate by borderWidth to get the outside-relative position. */

    RegionNull(pShape);
    RegionCopy(pShape, wBoundingShape(pWin));
    RegionTranslate(pShape, pWin->borderWidth, pWin->borderWidth);

    return TRUE;
}


/*
 * RootlessReshapeFrame
 *  Set the frame shape.
 */
static void RootlessReshapeFrame(WindowPtr pWin)
{
    RootlessWindowRec *winRec = WINREC(pWin);
    RegionRec newShape;
    RegionPtr pShape;

    // If the window is not yet framed, do nothing
    if (winRec == NULL)
        return;

    if (IsRoot(pWin))
        return;

    RootlessStopDrawing(pWin, FALSE);

    pShape = RootlessGetShape(pWin, &newShape) ? &newShape : NULL;

#ifdef ROOTLESSDEBUG
    RL_DEBUG_MSG("reshaping...");
    if (pShape != NULL) {
        RL_DEBUG_MSG("numrects %d, extents %d %d %d %d ",
                     RegionNumRects(&newShape),
                     newShape.extents.x1, newShape.extents.y1,
                     newShape.extents.x2, newShape.extents.y2);
    } else {
        RL_DEBUG_MSG("no shape ");
    }
#endif

    SCREENREC(pWin->drawable.pScreen)->imp->ReshapeFrame(winRec->wid, pShape);

    if (pShape != NULL)
        RegionUninit(&newShape);
}


/*
 * RootlessSetShape
 *  Shape is usually set before a window is mapped and the window will
 *  not have a frame associated with it. In this case, the frame will be
 *  shaped when the window is framed.
 */
void
RootlessSetShape(WindowPtr pWin, int kind)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    SCREEN_UNWRAP(pScreen, SetShape);
    pScreen->SetShape(pWin, kind);
    SCREEN_WRAP(pScreen, SetShape);

    RootlessReshapeFrame(pWin);
}



/* Disallow ParentRelative background on top-level windows
   because the root window doesn't really have the right background.
 */
Bool
RootlessChangeWindowAttributes(WindowPtr pWin, unsigned long vmask)
{
    Bool result;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    RL_DEBUG_MSG("change window attributes start ");

    SCREEN_UNWRAP(pScreen, ChangeWindowAttributes);
    result = pScreen->ChangeWindowAttributes(pWin, vmask);
    SCREEN_WRAP(pScreen, ChangeWindowAttributes);

    if (WINREC(pWin)) {
        // disallow ParentRelative background state
        if (pWin->backgroundState == ParentRelative) {
            XID pixel = 0;
            ChangeWindowAttributes(pWin, CWBackPixel, &pixel, serverClient);
        }
    }

    RL_DEBUG_MSG("change window attributes end\n");
    return result;
}


/*
 * RootlessPositionWindow
 *  This is a hook for when DIX moves or resizes a window.
 *  Update the frame position now although the physical window is moved
 *  in RootlessMoveWindow. (x, y) are *inside* position. After this,
 *  mi and fb are expecting the pixmap to be at the new location.
 */
Bool
RootlessPositionWindow(WindowPtr pWin, int x, int y)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RootlessWindowRec *winRec = WINREC(pWin);
    Bool result;

    RL_DEBUG_MSG("positionwindow start (win 0x%x @ %i, %i)\n", pWin, x, y);

    if (winRec) {
        if (winRec->is_drawing) {
            // Reset frame's pixmap and move it to the new position.
            int bw = wBorderWidth(pWin);

            winRec->pixmap->devPrivate.ptr = winRec->pixelData;
            SetPixmapBaseToScreen(winRec->pixmap, x - bw, y - bw);
        }
    }

    SCREEN_UNWRAP(pScreen, PositionWindow);
    result = pScreen->PositionWindow(pWin, x, y);
    SCREEN_WRAP(pScreen, PositionWindow);

    RL_DEBUG_MSG("positionwindow end\n");
    return result;
}


/*
 * RootlessInitializeFrame
 *  Initialize some basic attributes of the frame. Note that winRec
 *  may already have valid data in it, so don't overwrite anything
 *  valuable.
 */
static void
RootlessInitializeFrame(WindowPtr pWin, RootlessWindowRec *winRec)
{
    DrawablePtr d = &pWin->drawable;
    int bw = wBorderWidth(pWin);

    winRec->win = pWin;

    winRec->x = d->x - bw;
    winRec->y = d->y - bw;
    winRec->width = d->width + 2*bw;
    winRec->height = d->height + 2*bw;
    winRec->borderWidth = bw;
}

/*
 * RootlessEnsureFrame
 *  Make sure the given window is framed. If the window doesn't have a
 *  physical window associated with it, attempt to create one. If that
 *  is unsuccessful, return NULL.
 */
static RootlessWindowRec *
RootlessEnsureFrame(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RootlessWindowRec *winRec;
    RegionRec shape;
    RegionPtr pShape = NULL;

    if (WINREC(pWin) != NULL)
        return WINREC(pWin);

    if (!IsTopLevel(pWin) && !IsRoot(pWin))
        return NULL;

    if (pWin->drawable.class != InputOutput)
        return NULL;

    winRec = malloc(sizeof(RootlessWindowRec));

    if (!winRec)
        return NULL;

    RootlessInitializeFrame(pWin, winRec);

    winRec->is_drawing = FALSE;
    winRec->is_reorder_pending = FALSE;
    winRec->pixmap = NULL;
    winRec->wid = NULL;
    winRec->level = 0;

    SETWINREC(pWin, winRec);

    // Set the frame's shape if the window is shaped
    if (RootlessGetShape(pWin, &shape))
        pShape = &shape;

    RL_DEBUG_MSG("creating frame ");

    if (!SCREENREC(pScreen)->imp->CreateFrame(winRec, pScreen,
                                              winRec->x + SCREEN_TO_GLOBAL_X,
                                              winRec->y + SCREEN_TO_GLOBAL_Y,
                                              pShape))
    {
        RL_DEBUG_MSG("implementation failed to create frame!\n");
        free(winRec);
        SETWINREC(pWin, NULL);
        return NULL;
    }

    if (pWin->drawable.depth == 8)
      RootlessFlushWindowColormap(pWin);

    if (pShape != NULL)
        RegionUninit(&shape);

    return winRec;
}


/*
 * RootlessRealizeWindow
 *  The frame is usually created here and not in CreateWindow so that
 *  windows do not eat memory until they are realized.
 */
Bool
RootlessRealizeWindow(WindowPtr pWin)
{
    Bool result;
    RegionRec saveRoot;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    RL_DEBUG_MSG("realizewindow start (win 0x%x) ", pWin);

    if ((IsTopLevel(pWin) && pWin->drawable.class == InputOutput)) {
        RootlessWindowRec *winRec;

        winRec = RootlessEnsureFrame(pWin);
        if (winRec == NULL)
            return FALSE;

        winRec->is_reorder_pending = TRUE;

        RL_DEBUG_MSG("Top level window ");

        // Disallow ParentRelative background state on top-level windows.
        // This might have been set before the window was mapped.
        if (pWin->backgroundState == ParentRelative) {
            XID pixel = 0;
            ChangeWindowAttributes(pWin, CWBackPixel, &pixel, serverClient);
        }
    }

    if (!IsRoot(pWin)) HUGE_ROOT(pWin);
    SCREEN_UNWRAP(pScreen, RealizeWindow);
    result = pScreen->RealizeWindow(pWin);
    SCREEN_WRAP(pScreen, RealizeWindow);
    if (!IsRoot(pWin)) NORMAL_ROOT(pWin);

    RL_DEBUG_MSG("realizewindow end\n");
    return result;
}


/*
 * RootlessFrameForWindow
 *  Returns the frame ID for the physical window displaying the given window. 
 *  If CREATE is true and the window has no frame, attempt to create one.
 */
RootlessFrameID
RootlessFrameForWindow(WindowPtr pWin, Bool create)
{
    WindowPtr pTopWin;
    RootlessWindowRec *winRec;

    pTopWin = TopLevelParent(pWin);
    if (pTopWin == NULL)
        return NULL;

    winRec = WINREC(pTopWin);

    if (winRec == NULL && create && pWin->drawable.class == InputOutput) {
        winRec = RootlessEnsureFrame(pTopWin);
    }

    if (winRec == NULL)
        return NULL;

    return winRec->wid;
}


/*
 * RootlessUnrealizeWindow
 *  Unmap the physical window.
 */
Bool
RootlessUnrealizeWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RootlessWindowRec *winRec = WINREC(pWin);
    Bool result;

    RL_DEBUG_MSG("unrealizewindow start ");

    if (winRec) {
        RootlessStopDrawing(pWin, FALSE);

        SCREENREC(pScreen)->imp->UnmapFrame(winRec->wid);

        winRec->is_reorder_pending = FALSE;
    }

    SCREEN_UNWRAP(pScreen, UnrealizeWindow);
    result = pScreen->UnrealizeWindow(pWin);
    SCREEN_WRAP(pScreen, UnrealizeWindow);

    RL_DEBUG_MSG("unrealizewindow end\n");
    return result;
}


/*
 * RootlessReorderWindow
 *  Reorder the frame associated with the given window so that it's
 *  physically above the window below it in the X stacking order.
 */
void
RootlessReorderWindow(WindowPtr pWin)
{
    RootlessWindowRec *winRec = WINREC(pWin);

    if (pWin->realized && winRec != NULL && !winRec->is_reorder_pending && !windows_hidden) {
        WindowPtr newPrevW;
        RootlessWindowRec *newPrev;
        RootlessFrameID newPrevID;
        ScreenPtr pScreen = pWin->drawable.pScreen;

        /* Check if the implementation wants the frame to not be reordered
           even though the X11 window is restacked. This can be useful if
           frames are ordered-in with animation so that the reordering is not
           done until the animation is complete. */
        if (SCREENREC(pScreen)->imp->DoReorderWindow) {
            if (!SCREENREC(pScreen)->imp->DoReorderWindow(winRec))
                return;
        }

        RootlessStopDrawing(pWin, FALSE);

        /* Find the next window above this one that has a mapped frame. 
         * Only include cases where the windows are in the same category of
         * hittability to ensure offscreen windows dont get restacked
         * relative to onscreen ones (but that the offscreen ones maintain
         * their stacking order if they are explicitly asked to Reorder
         */

        newPrevW = pWin->prevSib;
        while (newPrevW && (WINREC(newPrevW) == NULL || !newPrevW->realized || newPrevW->rootlessUnhittable != pWin->rootlessUnhittable))
            newPrevW = newPrevW->prevSib;

        newPrev = newPrevW != NULL ? WINREC(newPrevW) : NULL;
        newPrevID = newPrev != NULL ? newPrev->wid : 0;

        /* If it exists, reorder the frame above us first. */

        if (newPrev && newPrev->is_reorder_pending) {
            newPrev->is_reorder_pending = FALSE;
            RootlessReorderWindow(newPrevW);
        }

        SCREENREC(pScreen)->imp->RestackFrame(winRec->wid, newPrevID);
    }
}


/*
 * RootlessRestackWindow
 *  This is a hook for when DIX changes the window stacking order.
 *  The window has already been inserted into its new position in the
 *  DIX window stack. We need to change the order of the physical
 *  window to match.
 */
void
RootlessRestackWindow(WindowPtr pWin, WindowPtr pOldNextSib)
{
    RegionRec saveRoot;
    RootlessWindowRec *winRec = WINREC(pWin);
    ScreenPtr pScreen = pWin->drawable.pScreen;

    RL_DEBUG_MSG("restackwindow start ");
    if (winRec)
        RL_DEBUG_MSG("restack top level \n");

    HUGE_ROOT(pWin);
    SCREEN_UNWRAP(pScreen, RestackWindow);

    if (pScreen->RestackWindow)
        pScreen->RestackWindow(pWin, pOldNextSib);

    SCREEN_WRAP(pScreen, RestackWindow);
    NORMAL_ROOT(pWin);

    if (winRec && pWin->viewable) {
        RootlessReorderWindow(pWin);
    }

    RL_DEBUG_MSG("restackwindow end\n");
}

/*
 * Specialized window copy procedures
 */

// Globals needed during window resize and move.
static pointer gResizeDeathBits = NULL;
static int gResizeDeathCount = 0;
static PixmapPtr gResizeDeathPix[2] = {NULL, NULL};
static BoxRec gResizeDeathBounds[2];
static CopyWindowProcPtr gResizeOldCopyWindowProc = NULL;

/*
 * RootlessNoCopyWindow
 *  CopyWindow() that doesn't do anything. For MoveWindow() of
 *  top-level windows.
 */
static void
RootlessNoCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg,
                     RegionPtr prgnSrc)
{
    // some code expects the region to be translated
    int dx = ptOldOrg.x - pWin->drawable.x;
    int dy = ptOldOrg.y - pWin->drawable.y;

    RL_DEBUG_MSG("ROOTLESSNOCOPYWINDOW ");

    RegionTranslate(prgnSrc, -dx, -dy);
}


/*
 * RootlessResizeCopyWindow
 *  CopyWindow used during ResizeWindow for gravity moves. Based on
 *  fbCopyWindow. The original always draws on the root pixmap, which
 *  we don't have. Instead, draw on the parent window's pixmap.
 *  Resize version: the old location's pixels are in gResizeCopyWindowSource.
 */
static void
RootlessResizeCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg,
                         RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RegionRec   rgnDst;
    int         dx, dy;

    RL_DEBUG_MSG("resizecopywindowFB start (win 0x%x) ", pWin);

    /* Don't unwrap pScreen->CopyWindow.
       The bogus rewrap with RootlessCopyWindow causes a crash if
       CopyWindow is called again during the same resize. */

    if (gResizeDeathCount == 0)
        return;

    RootlessStartDrawing(pWin);

    dx = ptOldOrg.x - pWin->drawable.x;
    dy = ptOldOrg.y - pWin->drawable.y;
    RegionTranslate(prgnSrc, -dx, -dy);
    RegionNull(&rgnDst);
    RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);

    if (gResizeDeathCount == 1) {
        /* Simple case, we only have a single source pixmap. */

        miCopyRegion(&gResizeDeathPix[0]->drawable,
                     &pScreen->GetWindowPixmap(pWin)->drawable, 0,
                     &rgnDst, dx, dy, fbCopyWindowProc, 0, 0);
    }
    else {
        int i;
        RegionRec clip, clipped;

        /* More complex case, N source pixmaps (usually two). So we
           intersect the destination with each source and copy those bits. */

        for (i = 0; i < gResizeDeathCount; i++) {
            RegionInit(&clip, gResizeDeathBounds + 0, 1);
            RegionNull(&clipped);
            RegionIntersect(&rgnDst, &clip, &clipped);

            miCopyRegion(&gResizeDeathPix[i]->drawable,
                         &pScreen->GetWindowPixmap(pWin)->drawable, 0,
                         &clipped, dx, dy, fbCopyWindowProc, 0, 0);

            RegionUninit(&clipped);
            RegionUninit(&clip);
        }
    }

    /* Don't update - resize will update everything */
    RegionUninit(&rgnDst);

    fbValidateDrawable(&pWin->drawable);

    RL_DEBUG_MSG("resizecopywindowFB end\n");
}


/*
 * RootlessCopyWindow
 *  Update *new* location of window. Old location is redrawn with
 *  miPaintWindow. Cloned from fbCopyWindow.
 *  The original always draws on the root pixmap, which we don't have.
 *  Instead, draw on the parent window's pixmap.
 */
void
RootlessCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RegionRec   rgnDst;
    int         dx, dy;
    BoxPtr extents;
    int area;

    RL_DEBUG_MSG("copywindowFB start (win 0x%x) ", pWin);

    SCREEN_UNWRAP(pScreen, CopyWindow);

    dx = ptOldOrg.x - pWin->drawable.x;
    dy = ptOldOrg.y - pWin->drawable.y;
    RegionTranslate(prgnSrc, -dx, -dy);

    RegionNull(&rgnDst);
    RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);

    extents = RegionExtents(&rgnDst);
    area = (extents->x2 - extents->x1) * (extents->y2 - extents->y1);

    /* If the area exceeds threshold, use the implementation's
       accelerated version. */
    if (area > rootless_CopyWindow_threshold &&
        SCREENREC(pScreen)->imp->CopyWindow)
    {
        RootlessWindowRec *winRec;
        WindowPtr top;

        top = TopLevelParent(pWin);
        if (top == NULL) {
            RL_DEBUG_MSG("no parent\n");
            goto out;
        }

        winRec = WINREC(top);
        if (winRec == NULL) {
            RL_DEBUG_MSG("not framed\n");
            goto out;
        }

        /* Move region to window local coords */
        RegionTranslate(&rgnDst, -winRec->x, -winRec->y);

        RootlessStopDrawing(pWin, FALSE);

        SCREENREC(pScreen)->imp->CopyWindow(winRec->wid,
                                            RegionNumRects(&rgnDst),
                                            RegionRects(&rgnDst),
                                            dx, dy);
    }
    else {
        RootlessStartDrawing(pWin);

        miCopyRegion((DrawablePtr) pWin, (DrawablePtr) pWin,
                     0, &rgnDst, dx, dy, fbCopyWindowProc, 0, 0);

        /* prgnSrc has been translated to dst position */
        RootlessDamageRegion(pWin, prgnSrc);
    }

out:
    RegionUninit(&rgnDst);
    fbValidateDrawable(&pWin->drawable);

    SCREEN_WRAP(pScreen, CopyWindow);

    RL_DEBUG_MSG("copywindowFB end\n");
}


/*
 * Window resize procedures
 */

enum {
    WIDTH_SMALLER = 1,
    HEIGHT_SMALLER = 2,
};


/*
 * ResizeWeighting
 *  Choose gravity to avoid local copies. Do that by looking for
 *  a corner that doesn't move _relative to the screen_.
 */
static inline unsigned int
ResizeWeighting(int oldX1, int oldY1, int oldX2, int oldY2, int oldBW,
                int newX1, int newY1, int newX2, int newY2, int newBW)
{
#ifdef ROOTLESS_RESIZE_GRAVITY
    if (newBW != oldBW)
        return RL_GRAVITY_NONE;

    if (newX1 == oldX1 && newY1 == oldY1)
        return RL_GRAVITY_NORTH_WEST;
    else if (newX1 == oldX1 && newY2 == oldY2)
        return RL_GRAVITY_SOUTH_WEST;
    else if (newX2 == oldX2 && newY2 == oldY2)
        return RL_GRAVITY_SOUTH_EAST;
    else if (newX2 == oldX2 && newY1 == oldY1)
        return RL_GRAVITY_NORTH_EAST;
    else
        return RL_GRAVITY_NONE;
#else
    return RL_GRAVITY_NONE;
#endif
}


/*
 * StartFrameResize
 *  Prepare to resize a top-level window. The old window's pixels are
 *  saved and the implementation is told to change the window size.
 *  (x,y,w,h) is outer frame of window (outside border)
 */
static Bool
StartFrameResize(WindowPtr pWin, Bool gravity,
                 int oldX, int oldY, int oldW, int oldH, int oldBW,
                 int newX, int newY, int newW, int newH, int newBW)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RootlessWindowRec *winRec = WINREC(pWin);
    Bool need_window_source = FALSE, resize_after = FALSE;

    BoxRec rect;
    int oldX2, newX2;
    int oldY2, newY2;
    unsigned int weight;

    oldX2 = oldX + oldW, newX2 = newX + newW;
    oldY2 = oldY + oldH, newY2 = newY + newH;

    /* Decide which resize weighting to use */
    weight = ResizeWeighting(oldX, oldY, oldW, oldH, oldBW,
                             newX, newY, newW, newH, newBW);

    /* Compute intersection between old and new rects */
    rect.x1 = max(oldX, newX);
    rect.y1 = max(oldY, newY);
    rect.x2 = min(oldX2, newX2);
    rect.y2 = min(oldY2, newY2);

    RL_DEBUG_MSG("RESIZE TOPLEVEL WINDOW with gravity %i ", gravity);
    RL_DEBUG_MSG("%d %d %d %d %d   %d %d %d %d %d\n",
                 oldX, oldY, oldW, oldH, oldBW,
                 newX, newY, newW, newH, newBW);

    RootlessRedisplay(pWin);

    /* If gravity is true, then we need to have a way of recovering all
       the original bits in the window for when X rearranges the contents
       based on the various gravity settings. The obvious way is to just
       snapshot the entire backing store before resizing it, but that
       it slow on large windows.

       So the optimization here is to use the implementation's resize
       weighting options (if available) to allow us to reason about what
       is left in the backing store after the resize. We can then only
       copy what won't be there after the resize, and do a two-stage copy
       operation.

       Most of these optimizations are only applied when the top-left
       corner of the window is fixed, since that's the common case. They
       could probably be extended with some thought. */

    gResizeDeathCount = 0;

    if (gravity && weight == RL_GRAVITY_NORTH_WEST) {
        unsigned int code = 0;

        /* Top left corner is anchored. We never need to copy the
           entire window. */

        need_window_source = TRUE;

        /* These comparisons were chosen to avoid setting bits when the sizes
        are the same. (So the fastest case automatically gets taken when
        dimensions are unchanging.) */

        if (newW < oldW)
            code |= WIDTH_SMALLER;
        if (newH < oldH)
            code |= HEIGHT_SMALLER;

        if (((code ^ (code >> 1)) & 1) == 0) {
            /* Both dimensions are either getting larger, or both
               are getting smaller. No need to copy anything. */

            if (code == (WIDTH_SMALLER | HEIGHT_SMALLER)) {
                /* Since the window is getting smaller, we can do gravity
                   repair on it with it's current size, then resize it
                   afterwards. */

                resize_after = TRUE;
            }

            gResizeDeathCount = 1;
        }
        else {
            unsigned int copy_rowbytes, Bpp;
            unsigned int copy_rect_width, copy_rect_height;
            BoxRec copy_rect;

            /* We can get away with a partial copy. 'rect' is the
               intersection between old and new bounds, so copy
               everything to the right of or below the intersection. */

            RootlessStartDrawing(pWin);

            if (code == WIDTH_SMALLER) {
                copy_rect.x1 = rect.x2;
                copy_rect.y1 = rect.y1;
                copy_rect.x2 = oldX2;
                copy_rect.y2 = oldY2;
            }
            else if (code == HEIGHT_SMALLER) {
                copy_rect.x1 = rect.x1;
                copy_rect.y1 = rect.y2;
                copy_rect.x2 = oldX2;
                copy_rect.y2 = oldY2;
            }
            else
                OsAbort();

            Bpp = winRec->win->drawable.bitsPerPixel / 8;
            copy_rect_width = copy_rect.x2 - copy_rect.x1;
            copy_rect_height = copy_rect.y2 - copy_rect.y1;
            copy_rowbytes = ((copy_rect_width * Bpp) + 31) & ~31;
            gResizeDeathBits = malloc(copy_rowbytes
                                      * copy_rect_height);

            if (copy_rect_width * copy_rect_height >
                        rootless_CopyBytes_threshold &&
                SCREENREC(pScreen)->imp->CopyBytes)
            {
                SCREENREC(pScreen)->imp->CopyBytes(
                    copy_rect_width * Bpp, copy_rect_height,
                    ((char *) winRec->pixelData)
                    + ((copy_rect.y1 - oldY) * winRec->bytesPerRow)
                    + (copy_rect.x1 - oldX) * Bpp, winRec->bytesPerRow,
                    gResizeDeathBits, copy_rowbytes);
            } else {
                fbBlt((FbBits *) (winRec->pixelData
                      + ((copy_rect.y1 - oldY) * winRec->bytesPerRow)
                      + (copy_rect.x1 - oldX) * Bpp),
                      winRec->bytesPerRow / sizeof(FbBits), 0,
                      (FbBits *) gResizeDeathBits,
                      copy_rowbytes / sizeof(FbBits), 0,
                      copy_rect_width * Bpp, copy_rect_height,
                      GXcopy, FB_ALLONES, Bpp, 0, 0);
            }

            gResizeDeathBounds[1] = copy_rect;
            gResizeDeathPix[1]
                = GetScratchPixmapHeader(pScreen, copy_rect_width,
                                         copy_rect_height,
                                         winRec->win->drawable.depth,
                                         winRec->win->drawable.bitsPerPixel,
                                         winRec->bytesPerRow,
                                         (void *) gResizeDeathBits);

            SetPixmapBaseToScreen(gResizeDeathPix[1],
                                  copy_rect.x1, copy_rect.y1);

            gResizeDeathCount = 2;
        }
    }
    else if (gravity) {
        /* The general case. Just copy everything. */

        RootlessStartDrawing(pWin);

        gResizeDeathBits = malloc(winRec->bytesPerRow * winRec->height);

        memcpy(gResizeDeathBits, winRec->pixelData,
               winRec->bytesPerRow * winRec->height);

        gResizeDeathBounds[0] = (BoxRec) {oldX, oldY, oldX2, oldY2};
        gResizeDeathPix[0]
            = GetScratchPixmapHeader(pScreen, winRec->width,
                                     winRec->height,
                                     winRec->win->drawable.depth,
                                     winRec->win->drawable.bitsPerPixel,
                                     winRec->bytesPerRow,
                                     (void *) gResizeDeathBits);

        SetPixmapBaseToScreen(gResizeDeathPix[0], oldX, oldY);
        gResizeDeathCount = 1;
    }

    RootlessStopDrawing(pWin, FALSE);

    winRec->x = newX;
    winRec->y = newY;
    winRec->width = newW;
    winRec->height = newH;
    winRec->borderWidth = newBW;

    /* Unless both dimensions are getting smaller, Resize the frame
       before doing gravity repair */

    if (!resize_after) {
        SCREENREC(pScreen)->imp->ResizeFrame(winRec->wid, pScreen,
                                             newX + SCREEN_TO_GLOBAL_X,
                                             newY + SCREEN_TO_GLOBAL_Y,
                                             newW, newH, weight);
    }

    RootlessStartDrawing(pWin);

    /* If necessary, create a source pixmap pointing at the current
       window bits. */

    if (need_window_source) {
        gResizeDeathBounds[0] = (BoxRec) {oldX, oldY, oldX2, oldY2};
        gResizeDeathPix[0]
            = GetScratchPixmapHeader(pScreen, oldW, oldH,
                                     winRec->win->drawable.depth,
                                     winRec->win->drawable.bitsPerPixel,
                                     winRec->bytesPerRow, winRec->pixelData);

        SetPixmapBaseToScreen(gResizeDeathPix[0], oldX, oldY);
    }

    /* Use custom CopyWindow when moving gravity bits around
       ResizeWindow assumes the old window contents are in the same
       pixmap, but here they're in deathPix instead. */

    if (gravity) {
        gResizeOldCopyWindowProc = pScreen->CopyWindow;
        pScreen->CopyWindow = RootlessResizeCopyWindow;
    }

    /* If we can't rely on the window server preserving the bits we
       need in the position we need, copy the pixels in the
       intersection from src to dst. ResizeWindow assumes these pixels
       are already present when making gravity adjustments. pWin
       currently has new-sized pixmap but is in old position.

       FIXME: border width change! (?) */

    if (gravity && weight == RL_GRAVITY_NONE) {
        PixmapPtr src, dst;

        assert(gResizeDeathCount == 1);

        src = gResizeDeathPix[0];
        dst = pScreen->GetWindowPixmap(pWin);

        RL_DEBUG_MSG("Resize copy rect %d %d %d %d\n",
                     rect.x1, rect.y1, rect.x2, rect.y2);

        /* rect is the intersection of the old location and new location */
        if (BOX_NOT_EMPTY(rect) && src != NULL && dst != NULL) {
            /* The window drawable still has the old frame position, which
               means that DST doesn't actually point at the origin of our
               physical backing store when adjusted by the drawable.x,y
               position. So sneakily adjust it temporarily while copying.. */

            ((PixmapPtr) dst)->devPrivate.ptr = winRec->pixelData;
            SetPixmapBaseToScreen(dst, newX, newY);

            fbCopyWindowProc(&src->drawable, &dst->drawable, NULL,
                             &rect, 1, 0, 0, FALSE, FALSE, 0, 0);

            ((PixmapPtr) dst)->devPrivate.ptr = winRec->pixelData;
            SetPixmapBaseToScreen(dst, oldX, oldY);
        }
    }

    return resize_after;
}


static void
FinishFrameResize(WindowPtr pWin, Bool gravity, int oldX, int oldY,
                  unsigned int oldW, unsigned int oldH, unsigned int oldBW,
                  int newX, int newY, unsigned int newW, unsigned int newH,
                  unsigned int newBW, Bool resize_now)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RootlessWindowRec *winRec = WINREC(pWin);
    int i;

    RootlessStopDrawing(pWin, FALSE);

    if (resize_now) {
        unsigned int weight;

        /* We didn't resize anything earlier, so do it now, now that
           we've finished gravitating the bits. */

        weight = ResizeWeighting(oldX, oldY, oldW, oldH, oldBW,
                                 newX, newY, newW, newH, newBW);

        SCREENREC(pScreen)->imp->ResizeFrame(winRec->wid, pScreen,
                                             newX + SCREEN_TO_GLOBAL_X,
                                             newY + SCREEN_TO_GLOBAL_Y,
                                             newW, newH, weight);
    }

    /* Redraw everything. FIXME: there must be times when we don't need
       to do this. Perhaps when top-left weighting and no gravity? */

    RootlessDamageRect(pWin, -newBW, -newBW, newW, newH);

    for (i = 0; i < 2; i++) {
        if (gResizeDeathPix[i] != NULL) {
            FreeScratchPixmapHeader(gResizeDeathPix[i]);
            gResizeDeathPix[i] = NULL;
        }
    }

    free(gResizeDeathBits);
    gResizeDeathBits = NULL;

    if (gravity) {
        pScreen->CopyWindow = gResizeOldCopyWindowProc;
    }
}


/*
 * RootlessMoveWindow
 *  If kind==VTOther, window border is resizing (and borderWidth is
 *  already changed!!@#$)  This case works like window resize, not move.
 */
void
RootlessMoveWindow(WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind)
{
    RootlessWindowRec *winRec = WINREC(pWin);
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CopyWindowProcPtr oldCopyWindowProc = NULL;
    int oldX = 0, oldY = 0, newX = 0, newY = 0;
    unsigned int oldW = 0, oldH = 0, oldBW = 0;
    unsigned int newW = 0, newH = 0, newBW = 0;
    Bool resize_after = FALSE;
    RegionRec saveRoot;

    RL_DEBUG_MSG("movewindow start \n");

    if (winRec) {
        if (kind == VTMove) {
            oldX = winRec->x;
            oldY = winRec->y;
            RootlessRedisplay(pWin);
            RootlessStartDrawing(pWin);
        } else {
            RL_DEBUG_MSG("movewindow border resizing ");

            oldBW = winRec->borderWidth;
            oldX = winRec->x;
            oldY = winRec->y;
            oldW = winRec->width;
            oldH = winRec->height;

            newBW = wBorderWidth(pWin);
            newX = x;
            newY = y;
            newW = pWin->drawable.width  + 2*newBW;
            newH = pWin->drawable.height + 2*newBW;

            resize_after = StartFrameResize(pWin, FALSE,
                                            oldX, oldY, oldW, oldH, oldBW,
                                            newX, newY, newW, newH, newBW);
        }
    }

    HUGE_ROOT(pWin);
    SCREEN_UNWRAP(pScreen, MoveWindow);

    if (winRec) {
        oldCopyWindowProc = pScreen->CopyWindow;
        pScreen->CopyWindow = RootlessNoCopyWindow;
    }
    pScreen->MoveWindow(pWin, x, y, pSib, kind);
    if (winRec) {
        pScreen->CopyWindow = oldCopyWindowProc;
    }

    NORMAL_ROOT(pWin);
    SCREEN_WRAP(pScreen, MoveWindow);

    if (winRec) {
        if (kind == VTMove) {
            winRec->x = x;
            winRec->y = y;
            RootlessStopDrawing(pWin, FALSE);
            SCREENREC(pScreen)->imp->MoveFrame(winRec->wid, pScreen,
                                               x + SCREEN_TO_GLOBAL_X,
                                               y + SCREEN_TO_GLOBAL_Y);
        } else {
            FinishFrameResize(pWin, FALSE, oldX, oldY, oldW, oldH, oldBW,
                              newX, newY, newW, newH, newBW, resize_after);
        }
    }

    RL_DEBUG_MSG("movewindow end\n");
}


/*
 * RootlessResizeWindow
 *  Note: (x, y, w, h) as passed to this procedure don't match the frame
 *  definition. (x,y) is corner of very outer edge, *outside* border.
 *  w,h is width and height *inside* border, *ignoring* border width.
 *  The rect (x, y, w, h) doesn't mean anything. (x, y, w+2*bw, h+2*bw)
 *  is total rect and (x+bw, y+bw, w, h) is inner rect.
 */
void
RootlessResizeWindow(WindowPtr pWin, int x, int y,
                     unsigned int w, unsigned int h, WindowPtr pSib)
{
    RootlessWindowRec *winRec = WINREC(pWin);
    ScreenPtr pScreen = pWin->drawable.pScreen;
    int oldX = 0, oldY = 0, newX = 0, newY = 0;
    unsigned int oldW = 0, oldH = 0, oldBW = 0, newW = 0, newH = 0, newBW = 0;
    Bool resize_after = FALSE;
    RegionRec saveRoot;

    RL_DEBUG_MSG("resizewindow start (win 0x%x) ", pWin);
    
    if(pWin->parent) {
        if (winRec) {
            oldBW = winRec->borderWidth;
            oldX = winRec->x;
            oldY = winRec->y;
            oldW = winRec->width;
            oldH = winRec->height;

            newBW = oldBW;
            newX = x;
            newY = y;
            newW = w + 2*newBW;
            newH = h + 2*newBW;

            resize_after = StartFrameResize(pWin, TRUE,
                                            oldX, oldY, oldW, oldH, oldBW,
                                            newX, newY, newW, newH, newBW);
        }

        HUGE_ROOT(pWin);
        SCREEN_UNWRAP(pScreen, ResizeWindow);
        pScreen->ResizeWindow(pWin, x, y, w, h, pSib);
        SCREEN_WRAP(pScreen, ResizeWindow);
        NORMAL_ROOT(pWin);

        if (winRec) {
            FinishFrameResize(pWin, TRUE, oldX, oldY, oldW, oldH, oldBW,
                              newX, newY, newW, newH, newBW, resize_after);
        }
    } else {
        /* Special case for resizing the root window */
        BoxRec box;

        pWin->drawable.x = x;
        pWin->drawable.y = y;
        pWin->drawable.width = w;
        pWin->drawable.height = h;

        box.x1 = x; box.y1 = y;
        box.x2 = x + w; box.y2 = y + h;
        RegionUninit(&pWin->winSize);
        RegionInit(&pWin->winSize, &box, 1);
        RegionCopy(&pWin->borderSize, &pWin->winSize);
        RegionCopy(&pWin->clipList, &pWin->winSize);
        RegionCopy(&pWin->borderClip, &pWin->winSize);

        if (winRec) {
            SCREENREC(pScreen)->imp->ResizeFrame(winRec->wid, pScreen,
                                                 x + SCREEN_TO_GLOBAL_X,
                                                 y + SCREEN_TO_GLOBAL_Y,
                                                 w, h, RL_GRAVITY_NONE);
        }

        miSendExposures(pWin, &pWin->borderClip,
                        pWin->drawable.x, pWin->drawable.y);        
    }

    RL_DEBUG_MSG("resizewindow end\n");
}


/*
 * RootlessRepositionWindow
 *  Called by the implementation when a window needs to be repositioned to
 *  its correct location on the screen. This routine is typically needed
 *  due to changes in the underlying window system, such as a screen layout
 *  change.
 */
void
RootlessRepositionWindow(WindowPtr pWin)
{
    RootlessWindowRec *winRec = WINREC(pWin);
    ScreenPtr pScreen = pWin->drawable.pScreen;

    if (winRec == NULL)
        return;

    RootlessStopDrawing(pWin, FALSE);
    SCREENREC(pScreen)->imp->MoveFrame(winRec->wid, pScreen,
                                       winRec->x + SCREEN_TO_GLOBAL_X,
                                       winRec->y + SCREEN_TO_GLOBAL_Y);

    RootlessReorderWindow(pWin);
}


/*
 * RootlessReparentWindow
 *  Called after a window has been reparented. Generally windows are not
 *  framed until they are mapped. However, a window may be framed early by the
 *  implementation calling RootlessFrameForWindow. (e.g. this could be needed
 *  to attach a VRAM surface to it.) If the window is subsequently reparented
 *  by the window manager before being mapped, we need to give the frame to
 *  the new top-level window.
 */
void
RootlessReparentWindow(WindowPtr pWin, WindowPtr pPriorParent)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RootlessWindowRec *winRec = WINREC(pWin);
    WindowPtr pTopWin;

    /* Check that window is not top-level now, but used to be. */
    if (IsRoot(pWin) || IsRoot(pWin->parent)
        || IsTopLevel(pWin) || winRec == NULL)
    {
        goto out;
    }

    /* If the formerly top-level window has a frame, we want to give the
       frame to its new top-level parent. If we can't do that, we'll just
       have to jettison it... */

    pTopWin = TopLevelParent(pWin);
    assert(pTopWin != pWin);
    
    pWin->rootlessUnhittable = FALSE;
    
    DeleteProperty (serverClient, pWin, xa_native_window_id ());

    if (WINREC(pTopWin) != NULL) {
        /* We're screwed. */
        RootlessDestroyFrame(pWin, winRec);
    } else {
        if (!pTopWin->realized && pWin->realized) {
            SCREENREC(pScreen)->imp->UnmapFrame(winRec->wid);
        }

        /* Switch the frame record from one to the other. */

        SETWINREC(pWin, NULL);
        SETWINREC(pTopWin, winRec);

        RootlessInitializeFrame(pTopWin, winRec);
        RootlessReshapeFrame(pTopWin);

        SCREENREC(pScreen)->imp->ResizeFrame(winRec->wid, pScreen,
                                             winRec->x + SCREEN_TO_GLOBAL_X,
                                             winRec->y + SCREEN_TO_GLOBAL_Y,
                                             winRec->width, winRec->height,
                                             RL_GRAVITY_NONE);

        if (SCREENREC(pScreen)->imp->SwitchWindow) {
            SCREENREC(pScreen)->imp->SwitchWindow(winRec, pWin);
        }

        if (pTopWin->realized && !pWin->realized)
            winRec->is_reorder_pending = TRUE;
    }

out:
    if (SCREENREC(pScreen)->ReparentWindow) {
        SCREEN_UNWRAP(pScreen, ReparentWindow);
        pScreen->ReparentWindow(pWin, pPriorParent);
        SCREEN_WRAP(pScreen, ReparentWindow);
    }
}


void
RootlessFlushWindowColormap (WindowPtr pWin)
{
  RootlessWindowRec *winRec = WINREC (pWin);
  ScreenPtr pScreen = pWin->drawable.pScreen;

  if (winRec == NULL)
    return;

  RootlessStopDrawing (pWin, FALSE);

  if (SCREENREC(pScreen)->imp->UpdateColormap)
    SCREENREC(pScreen)->imp->UpdateColormap(winRec->wid, pScreen);
}

/*
 * RootlessChangeBorderWidth
 *  FIXME: untested!
 *  pWin inside corner stays the same; pWin->drawable.[xy] stays the same
 *  Frame moves and resizes.
 */
void
RootlessChangeBorderWidth(WindowPtr pWin, unsigned int width)
{
    RegionRec saveRoot;
    Bool resize_after = FALSE;

    RL_DEBUG_MSG("change border width ");

    if (width != wBorderWidth(pWin)) {
        RootlessWindowRec *winRec = WINREC(pWin);
        int oldX = 0, oldY = 0, newX = 0, newY = 0;
        unsigned int oldW = 0, oldH = 0, oldBW = 0;
        unsigned int newW = 0, newH = 0, newBW = 0;

        if (winRec) {
            oldBW = winRec->borderWidth;
            oldX = winRec->x;
            oldY = winRec->y;
            oldW = winRec->width;
            oldH = winRec->height;

            newBW = width;
            newX = pWin->drawable.x - newBW;
            newY = pWin->drawable.y - newBW;
            newW = pWin->drawable.width  + 2*newBW;
            newH = pWin->drawable.height + 2*newBW;

            resize_after = StartFrameResize(pWin, FALSE,
                                            oldX, oldY, oldW, oldH, oldBW,
                                            newX, newY, newW, newH, newBW);
        }

        HUGE_ROOT(pWin);
        SCREEN_UNWRAP(pWin->drawable.pScreen, ChangeBorderWidth);
        pWin->drawable.pScreen->ChangeBorderWidth(pWin, width);
        SCREEN_WRAP(pWin->drawable.pScreen, ChangeBorderWidth);
        NORMAL_ROOT(pWin);

        if (winRec) {
            FinishFrameResize(pWin, FALSE, oldX, oldY, oldW, oldH, oldBW,
                              newX, newY, newW, newH, newBW, resize_after);
        }
    }

    RL_DEBUG_MSG("change border width end\n");
}

/*
 * RootlessOrderAllWindows
 * Brings all X11 windows to the top of the window stack
 * (i.e in front of Aqua windows) -- called when X11.app is given focus
 */
void
RootlessOrderAllWindows (Bool include_unhitable)
{
    int i;
    WindowPtr pWin;

    if (windows_hidden)
        return;    

    RL_DEBUG_MSG("RootlessOrderAllWindows() ");
    for (i = 0; i < screenInfo.numScreens; i++) {
      if (screenInfo.screens[i] == NULL) continue;
      pWin = screenInfo.screens[i]->root;
      if (pWin == NULL) continue;
      
      for (pWin = pWin->firstChild; pWin != NULL; pWin = pWin->nextSib) {
	if (!pWin->realized) continue;
	if (RootlessEnsureFrame(pWin) == NULL) continue;
        if (!include_unhitable && pWin->rootlessUnhittable) continue;
	RootlessReorderWindow (pWin);
      }
    }
    RL_DEBUG_MSG("RootlessOrderAllWindows() done");
}

void
RootlessEnableRoot (ScreenPtr pScreen)
{
    WindowPtr pRoot;
    pRoot = pScreen->root;
    
    RootlessEnsureFrame (pRoot);
    (*pScreen->ClearToBackground) (pRoot, 0, 0, 0, 0, TRUE);
    RootlessReorderWindow (pRoot);
}

void
RootlessDisableRoot (ScreenPtr pScreen)
{
    WindowPtr pRoot;
    RootlessWindowRec *winRec;

    pRoot = pScreen->root;
    winRec = WINREC (pRoot);

    if (NULL == winRec)
	return;
           
    RootlessDestroyFrame (pRoot, winRec);
    DeleteProperty (serverClient, pRoot, xa_native_window_id ());
}

void
RootlessHideAllWindows (void)
{
    int i;
    ScreenPtr pScreen;
    WindowPtr pWin;
    RootlessWindowRec *winRec;
    
    if (windows_hidden)
        return;
    
    windows_hidden = TRUE;
    
    for (i = 0; i < screenInfo.numScreens; i++)
    {
        pScreen = screenInfo.screens[i];
	if (pScreen == NULL)
	    continue;
	pWin = pScreen->root;
	if (pWin == NULL)
            continue;
        
        for (pWin = pWin->firstChild; pWin != NULL; pWin = pWin->nextSib)
        {
            if (!pWin->realized)
                continue;
            
            RootlessStopDrawing (pWin, FALSE);
            
            winRec = WINREC (pWin);
            if (winRec != NULL)
            {
              if (SCREENREC(pScreen)->imp->HideWindow)
                SCREENREC(pScreen)->imp->HideWindow(winRec->wid);
            }
        }
    }
}

void
RootlessShowAllWindows (void)
{
    int i;
    ScreenPtr pScreen;
    WindowPtr pWin;
    RootlessWindowRec *winRec;
    
    if (!windows_hidden)
        return;
    
    windows_hidden = FALSE;
    
    for (i = 0; i < screenInfo.numScreens; i++)
    {
        pScreen = screenInfo.screens[i];
	if (pScreen == NULL)
	    continue;
	pWin = pScreen->root;
	if (pWin == NULL)
            continue;
        
        for (pWin = pWin->firstChild; pWin != NULL; pWin = pWin->nextSib)
        {
            if (!pWin->realized)
                continue;
            
            winRec = RootlessEnsureFrame (pWin);
            if (winRec == NULL)
                continue;
            
            RootlessReorderWindow (pWin);
        }
        
        RootlessScreenExpose (pScreen);
    }
}

/*
 * SetPixmapOfAncestors
 *  Set the Pixmaps on all ParentRelative windows up the ancestor chain.
 */
void
RootlessSetPixmapOfAncestors(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    WindowPtr topWin = TopLevelParent(pWin);
    RootlessWindowRec *topWinRec = WINREC(topWin);
    
    while (pWin->backgroundState == ParentRelative) {
        if (pWin == topWin) {
            // disallow ParentRelative background state on top level
            XID pixel = 0;
            ChangeWindowAttributes(pWin, CWBackPixel, &pixel, serverClient);
            RL_DEBUG_MSG("Cleared ParentRelative on 0x%x.\n", pWin);
            break;
        }
        
        pWin = pWin->parent;
        pScreen->SetWindowPixmap(pWin, topWinRec->pixmap);
    }
}

/*
 * Rootless window management
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _ROOTLESSWINDOW_H
#define _ROOTLESSWINDOW_H

#include "rootlessCommon.h"

Bool RootlessCreateWindow(WindowPtr pWin);
Bool RootlessDestroyWindow(WindowPtr pWin);

void RootlessSetShape(WindowPtr pWin, int kind);

Bool RootlessChangeWindowAttributes(WindowPtr pWin, unsigned long vmask);
Bool RootlessPositionWindow(WindowPtr pWin, int x, int y);
Bool RootlessRealizeWindow(WindowPtr pWin);
Bool RootlessUnrealizeWindow(WindowPtr pWin);
void RootlessRestackWindow(WindowPtr pWin, WindowPtr pOldNextSib);
void RootlessCopyWindow(WindowPtr pWin,DDXPointRec ptOldOrg,RegionPtr prgnSrc);
void RootlessMoveWindow(WindowPtr pWin,int x,int y,WindowPtr pSib,VTKind kind);
void RootlessResizeWindow(WindowPtr pWin, int x, int y,
			  unsigned int w, unsigned int h, WindowPtr pSib);
void RootlessReparentWindow(WindowPtr pWin, WindowPtr pPriorParent);
void RootlessChangeBorderWidth(WindowPtr pWin, unsigned int width);
#ifdef __APPLE__
void RootlessNativeWindowMoved (WindowPtr pWin);
void RootlessNativeWindowStateChanged (WindowPtr pWin, unsigned int state); 
#endif

#endif
noinst_LTLIBRARIES = libshadow.la

AM_CFLAGS = $(DIX_CFLAGS)

if XORG
sdk_HEADERS = shadow.h
endif

libshadow_la_SOURCES =		\
	shadow.c		\
	shadow.h		\
	shalloc.c		\
	shpacked.c		\
	shplanar8.c		\
	shplanar.c		\
	shrot16pack_180.c	\
	shrot16pack_270.c	\
	shrot16pack_270YX.c	\
	shrot16pack_90.c	\
	shrot16pack_90YX.c	\
	shrot16pack.c		\
	shrot32pack_180.c	\
	shrot32pack_270.c	\
	shrot32pack_90.c	\
	shrot32pack.c		\
	shrot8pack_180.c	\
	shrot8pack_270.c	\
	shrot8pack_90.c		\
	shrot8pack.c		\
	shrotate.c		\
	shrotpack.h		\
	shrotpackYX.h
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    "dixfontstr.h"
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"

static DevPrivateKeyRec shadowScrPrivateKeyRec;
#define shadowScrPrivateKey (&shadowScrPrivateKeyRec)

#define wrap(priv, real, mem) {\
    priv->mem = real->mem; \
    real->mem = shadow##mem; \
}

#define unwrap(priv, real, mem) {\
    real->mem = priv->mem; \
}

static void
shadowRedisplay(ScreenPtr pScreen)
{
    shadowBuf(pScreen);
    RegionPtr pRegion;

    if (!pBuf || !pBuf->pDamage || !pBuf->update)
	return;
    pRegion = DamageRegion(pBuf->pDamage);
    if (RegionNotEmpty(pRegion)) {
	(*pBuf->update)(pScreen, pBuf);
	DamageEmpty(pBuf->pDamage);
    }
}

static void
shadowBlockHandler(pointer data, OSTimePtr pTimeout, pointer pRead)
{
    ScreenPtr pScreen = (ScreenPtr) data;

    shadowRedisplay(pScreen);
}

static void
shadowWakeupHandler(pointer data, int i, pointer LastSelectMask)
{
}

static void
shadowGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
	       unsigned int format, unsigned long planeMask, char *pdstLine)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    shadowBuf(pScreen);

    /* Many apps use GetImage to sync with the visable frame buffer */
    if (pDrawable->type == DRAWABLE_WINDOW)
	shadowRedisplay(pScreen);
    unwrap(pBuf, pScreen, GetImage);
    pScreen->GetImage(pDrawable, sx, sy, w, h, format, planeMask, pdstLine);
    wrap(pBuf, pScreen, GetImage);
}

#define BACKWARDS_COMPATIBILITY

static Bool
shadowCloseScreen(int i, ScreenPtr pScreen)
{
    shadowBuf(pScreen);

    unwrap(pBuf, pScreen, GetImage);
    unwrap(pBuf, pScreen, CloseScreen);
    shadowRemove(pScreen, pBuf->pPixmap);
    DamageDestroy(pBuf->pDamage);
#ifdef BACKWARDS_COMPATIBILITY
    RegionUninit(&pBuf->damage); /* bc */
#endif
    if (pBuf->pPixmap)
	pScreen->DestroyPixmap(pBuf->pPixmap);
    free(pBuf);
    return pScreen->CloseScreen(i, pScreen);
}

#ifdef BACKWARDS_COMPATIBILITY
static void
shadowReportFunc(DamagePtr pDamage, RegionPtr pRegion, void *closure)
{
    ScreenPtr pScreen = closure;
    shadowBufPtr pBuf = (shadowBufPtr)
	dixLookupPrivate(&pScreen->devPrivates, shadowScrPrivateKey);

    /* Register the damaged region, use DamageReportNone below when we
     * want to break BC below... */
    RegionUnion(&pDamage->damage, &pDamage->damage, pRegion);

    /*
     * BC hack.  In 7.0 and earlier several drivers would inspect the
     * 'damage' member directly, so we have to keep it existing.
     */
    RegionCopy(&pBuf->damage, pRegion);
}
#endif

Bool
shadowSetup(ScreenPtr pScreen)
{
    shadowBufPtr pBuf;

    if (!dixRegisterPrivateKey(&shadowScrPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;

    if (!DamageSetup(pScreen))
	return FALSE;

    pBuf = malloc(sizeof(shadowBufRec));
    if (!pBuf)
	return FALSE;
#ifdef BACKWARDS_COMPATIBILITY
    pBuf->pDamage = DamageCreate((DamageReportFunc)shadowReportFunc, 
		    		 (DamageDestroyFunc)NULL,
				 DamageReportRawRegion,
				 TRUE, pScreen, pScreen);
#else
    pBuf->pDamage = DamageCreate((DamageReportFunc)NULL, 
		    		 (DamageDestroyFunc)NULL,
				 DamageReportNone,
				 TRUE, pScreen, pScreen);
#endif
    if (!pBuf->pDamage) {
	free(pBuf);
	return FALSE;
    }

    wrap(pBuf, pScreen, CloseScreen);
    wrap(pBuf, pScreen, GetImage);
    pBuf->update = 0;
    pBuf->window = 0;
    pBuf->pPixmap = 0;
    pBuf->closure = 0;
    pBuf->randr = 0;
#ifdef BACKWARDS_COMPATIBILITY
    RegionNull(&pBuf->damage); /* bc */
#endif

    dixSetPrivate(&pScreen->devPrivates, shadowScrPrivateKey, pBuf);
    return TRUE;
}

Bool
shadowAdd(ScreenPtr pScreen, PixmapPtr pPixmap, ShadowUpdateProc update,
	  ShadowWindowProc window, int randr, void *closure)
{
    shadowBuf(pScreen);

    if (!RegisterBlockAndWakeupHandlers(shadowBlockHandler, shadowWakeupHandler,
					(pointer)pScreen))
	return FALSE;

    /*
     * Map simple rotation values to bitmasks; fortunately,
     * these are all unique
     */
    switch (randr) {
    case 0:
	randr = SHADOW_ROTATE_0;
	break;
    case 90:
	randr = SHADOW_ROTATE_90;
	break;
    case 180:
	randr = SHADOW_ROTATE_180;
	break;
    case 270:
	randr = SHADOW_ROTATE_270;
	break;
    }
    pBuf->update = update;
    pBuf->window = window;
    pBuf->randr = randr;
    pBuf->closure = closure;
    pBuf->pPixmap = pPixmap;
    DamageRegister(&pPixmap->drawable, pBuf->pDamage);
    return TRUE;
}

void
shadowRemove(ScreenPtr pScreen, PixmapPtr pPixmap)
{
    shadowBuf(pScreen);

    if (pBuf->pPixmap) {
	DamageUnregister(&pBuf->pPixmap->drawable, pBuf->pDamage);
	pBuf->update = 0;
	pBuf->window = 0;
	pBuf->randr = 0;
	pBuf->closure = 0;
	pBuf->pPixmap = 0;
    }

    RemoveBlockAndWakeupHandlers(shadowBlockHandler, shadowWakeupHandler,
				 (pointer) pScreen);
}

Bool
shadowInit(ScreenPtr pScreen, ShadowUpdateProc update, ShadowWindowProc window)
{
    PixmapPtr pPixmap;
    
    pPixmap = pScreen->CreatePixmap(pScreen, pScreen->width, pScreen->height,
				    pScreen->rootDepth, 0);
    if (!pPixmap)
	return FALSE;
    
    if (!shadowSetup(pScreen)) {
	pScreen->DestroyPixmap(pPixmap);
	return FALSE;
    }

    shadowAdd(pScreen, pPixmap, update, window, SHADOW_ROTATE_0, 0);

    return TRUE;
}
/*
 *
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _SHADOW_H_
#define _SHADOW_H_

#include "scrnintstr.h"

#include "picturestr.h"

#include "damage.h"
#include "damagestr.h"
typedef struct _shadowBuf   *shadowBufPtr;

typedef void (*ShadowUpdateProc) (ScreenPtr pScreen,
				  shadowBufPtr pBuf);

#define SHADOW_WINDOW_RELOCATE 1
#define SHADOW_WINDOW_READ 2
#define SHADOW_WINDOW_WRITE 4

typedef void *(*ShadowWindowProc) (ScreenPtr	pScreen,
				   CARD32	row,
				   CARD32	offset,
				   int		mode,
				   CARD32	*size,
				   void		*closure);

/* BC hack: do not move the damage member.  see shadow.c for explanation. */
typedef struct _shadowBuf {
    DamagePtr           pDamage;
    ShadowUpdateProc	update;
    ShadowWindowProc	window;
    RegionRec		damage;
    PixmapPtr		pPixmap;
    void		*closure;
    int			randr;

    /* screen wrappers */
    GetImageProcPtr     GetImage;
    CloseScreenProcPtr  CloseScreen;
} shadowBufRec;

/* Match defines from randr extension */
#define SHADOW_ROTATE_0	    1
#define SHADOW_ROTATE_90    2
#define SHADOW_ROTATE_180   4
#define SHADOW_ROTATE_270   8
#define SHADOW_ROTATE_ALL   (SHADOW_ROTATE_0|SHADOW_ROTATE_90|\
			     SHADOW_ROTATE_180|SHADOW_ROTATE_270)
#define SHADOW_REFLECT_X    16
#define SHADOW_REFLECT_Y    32
#define SHADOW_REFLECT_ALL  (SHADOW_REFLECT_X|SHADOW_REFLECT_Y)

extern _X_EXPORT DevPrivateKey shadowScrPrivateKey;

#define shadowGetBuf(pScr) ((shadowBufPtr) \
    dixLookupPrivate(&(pScr)->devPrivates, shadowScrPrivateKey))
#define shadowBuf(pScr)            shadowBufPtr pBuf = shadowGetBuf(pScr)
#define shadowDamage(pBuf)  DamageRegion(pBuf->pDamage)    

extern _X_EXPORT Bool
shadowSetup (ScreenPtr pScreen);

extern _X_EXPORT Bool
shadowAdd (ScreenPtr	    pScreen,
	   PixmapPtr	    pPixmap,
	   ShadowUpdateProc update,
	   ShadowWindowProc window,
	   int		    randr,
	   void		    *closure);

extern _X_EXPORT void
shadowRemove (ScreenPtr pScreen, PixmapPtr pPixmap);

extern _X_EXPORT Bool
shadowInit (ScreenPtr pScreen, ShadowUpdateProc update, ShadowWindowProc window);

extern _X_EXPORT void *
shadowAlloc (int width, int height, int bpp);

extern _X_EXPORT void
shadowUpdatePacked (ScreenPtr	    pScreen,
		    shadowBufPtr    pBuf);

extern _X_EXPORT void
shadowUpdatePlanar4 (ScreenPtr	    pScreen,
		     shadowBufPtr   pBuf);

extern _X_EXPORT void
shadowUpdatePlanar4x8 (ScreenPtr    pScreen,
		       shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotatePacked (ScreenPtr    pScreen,
			  shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate8_90 (ScreenPtr    pScreen,
			shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate16_90 (ScreenPtr    pScreen,
			 shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate16_90YX (ScreenPtr    pScreen,
			   shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate32_90 (ScreenPtr    pScreen,
			 shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate8_180 (ScreenPtr    pScreen,
			 shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate16_180 (ScreenPtr    pScreen,
			  shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate32_180 (ScreenPtr    pScreen,
			  shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate8_270 (ScreenPtr    pScreen,
			 shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate16_270 (ScreenPtr    pScreen,
			  shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate16_270YX (ScreenPtr    pScreen,
			    shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate32_270 (ScreenPtr    pScreen,
			  shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate8 (ScreenPtr    pScreen,
		     shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate16 (ScreenPtr    pScreen,
		      shadowBufPtr pBuf);

extern _X_EXPORT void
shadowUpdateRotate32 (ScreenPtr    pScreen,
		      shadowBufPtr pBuf);

typedef void (* shadowUpdateProc)(ScreenPtr, shadowBufPtr);

extern _X_EXPORT shadowUpdateProc shadowUpdatePackedWeak(void);
extern _X_EXPORT shadowUpdateProc shadowUpdatePlanar4Weak(void);
extern _X_EXPORT shadowUpdateProc shadowUpdatePlanar4x8Weak(void);
extern _X_EXPORT shadowUpdateProc shadowUpdateRotatePackedWeak(void);

#endif /* _SHADOW_H_ */
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    <X11/fonts/font.h>
#include    "dixfontstr.h"
#include    <X11/fonts/fontstruct.h>
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"

void *
shadowAlloc (int width, int height, int bpp)
{
    int	    stride;
    void    *fb;

    /* Cant use PixmapBytePad -- the structure is probably not initialized yet */
    stride = BitmapBytePad (width * bpp);
    fb = malloc(stride * height);
    return fb;
}
/*
 *
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    <X11/fonts/font.h>
#include    "dixfontstr.h"
#include    <X11/fonts/fontstruct.h>
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"
#include    "fb.h"

void
shadowUpdatePacked (ScreenPtr	    pScreen,
		    shadowBufPtr    pBuf)
{
    RegionPtr	damage = shadowDamage (pBuf);
    PixmapPtr	pShadow = pBuf->pPixmap;
    int		nbox = RegionNumRects (damage);
    BoxPtr	pbox = RegionRects (damage);
    FbBits	*shaBase, *shaLine, *sha;
    FbStride	shaStride;
    int		scrBase, scrLine, scr;
    int		shaBpp;
    _X_UNUSED int	shaXoff, shaYoff;
    int		x, y, w, h, width;
    int         i;
    FbBits	*winBase = NULL, *win;
    CARD32      winSize;

    fbGetDrawable (&pShadow->drawable, shaBase, shaStride, shaBpp, shaXoff, shaYoff);
    while (nbox--)
    {
	x = pbox->x1 * shaBpp;
	y = pbox->y1;
	w = (pbox->x2 - pbox->x1) * shaBpp;
	h = pbox->y2 - pbox->y1;

	scrLine = (x >> FB_SHIFT);
	shaLine = shaBase + y * shaStride + (x >> FB_SHIFT);
				   
	x &= FB_MASK;
	w = (w + x + FB_MASK) >> FB_SHIFT;
	
	while (h--)
	{
	    winSize = 0;
	    scrBase = 0;
	    width = w;
	    scr = scrLine;
	    sha = shaLine;
	    while (width) {
		/* how much remains in this window */
		i = scrBase + winSize - scr;
		if (i <= 0 || scr < scrBase)
		{
		    winBase = (FbBits *) (*pBuf->window) (pScreen,
							  y,
							  scr * sizeof (FbBits),
							  SHADOW_WINDOW_WRITE,
							  &winSize,
							  pBuf->closure);
		    if(!winBase)
			return;
		    scrBase = scr;
		    winSize /= sizeof (FbBits);
		    i = winSize;
		}
		win = winBase + (scr - scrBase);
		if (i > width)
		    i = width;
		width -= i;
		scr += i;
#define PickBit(a,i)	(((a) >> (i)) & 1)
		memcpy(win, sha, i * sizeof(FbBits));
		sha += i;
	    }
	    shaLine += shaStride;
	    y++;
	}
	pbox++;
    }
}

shadowUpdateProc
shadowUpdatePackedWeak(void) {
    return shadowUpdatePacked;
}
/*
 *
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    <X11/fonts/font.h>
#include    "dixfontstr.h"
#include    <X11/fonts/fontstruct.h>
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"
#include    "fb.h"

/*
 * 32 4-bit pixels per write
 */

#define PL_SHIFT    7	    
#define PL_UNIT	    (1 << PL_SHIFT)
#define PL_MASK	    (PL_UNIT - 1)

/*
 *  32->8 conversion:
 *
 *      7 6 5 4 3 2 1 0
 *      A B C D E F G H
 *
 *      3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *      1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * m    . . . H . . . G . . . F . . . E . . . D . . . C . . . B . . . A
 * m1   G . . . F . . . E . . . D . . . C . . . B . . . A . . . . . . .	    m << (7 - (p))
 * m2   . H . . . G . . . F . . . E . . . D . . . C . . . B . . . A . .	    (m >> (p)) << 2
 * m3   G               E               C               A                   m1 & 0x80808080
 * m4     H               F               D               B                 m2 & 0x40404040
 * m5   G H             E F             C D             A B                 m3 | m4
 * m6   G H             E F             C D     G H     A B     E F         m5 | (m5 >> 20)
 * m7   G H             E F             C D     G H     A B C D E F G H     m6 | (m6 >> 10)
 */

#if 0
#define GetBits(p,o,d) {\
    m = sha[o]; \
    m1 = m << (7 - (p)); \
    m2 = (m >> (p)) << 2; \
    m3 = m1 & 0x80808080; \
    m4 = m2 & 0x40404040; \
    m5 = m3 | m4; \
    m6 = m5 | (m5 >> 20); \
    d = m6 | (m6 >> 10); \
}
#else
#define GetBits(p,o,d) {\
    m = sha[o]; \
    m5 = ((m << (7 - (p))) & 0x80808080) | (((m >> (p)) << 2) & 0x40404040); \
    m6 = m5 | (m5 >> 20); \
    d = m6 | (m6 >> 10); \
}
#endif

void
shadowUpdatePlanar4 (ScreenPtr	    pScreen,
		     shadowBufPtr   pBuf)
{
    RegionPtr	damage = shadowDamage (pBuf);
    PixmapPtr	pShadow = pBuf->pPixmap;
    int		nbox = RegionNumRects (damage);
    BoxPtr	pbox = RegionRects (damage);
    CARD32	*shaBase, *shaLine, *sha;
    FbStride	shaStride;
    int		scrBase, scrLine, scr;
    int		shaBpp;
    _X_UNUSED int	shaXoff, shaYoff;
    int		x, y, w, h, width;
    int         i;
    CARD32	*winBase = NULL, *win;
    CARD32	winSize;
    int		plane;
    CARD32	m,m5,m6;
    CARD8	s1, s2, s3, s4;

    fbGetStipDrawable (&pShadow->drawable, shaBase, shaStride, shaBpp, shaXoff, shaYoff);
    while (nbox--)
    {
	x = (pbox->x1) * shaBpp;
	y = (pbox->y1);
	w = (pbox->x2 - pbox->x1) * shaBpp;
	h = pbox->y2 - pbox->y1;

	w = (w + (x & PL_MASK) + PL_MASK) >> PL_SHIFT;
	x &= ~PL_MASK;
	
	scrLine = (x >> PL_SHIFT);
	shaLine = shaBase + y * shaStride + (x >> FB_SHIFT);
	
	while (h--)
	{
	    for (plane = 0; plane < 4; plane++)
	    {
		width = w;
		scr = scrLine;
		sha = shaLine;
		winSize = 0;
		scrBase = 0;
		while (width) {
		    /* how much remains in this window */
		    i = scrBase + winSize - scr;
		    if (i <= 0 || scr < scrBase)
		    {
			winBase = (CARD32 *) (*pBuf->window) (pScreen,
							      y,
							      (scr << 4) | (plane),
							      SHADOW_WINDOW_WRITE,
							      &winSize,
							      pBuf->closure);
			if(!winBase)
			return;
			winSize >>= 2;
			scrBase = scr;
			i = winSize;
		    }
		    win = winBase + (scr - scrBase);
		    if (i > width)
		    i = width;
		    width -= i;
		    scr += i;
		   
		    while (i--)
		    {
			GetBits(plane,0,s1);
			GetBits(plane,1,s2);
			GetBits(plane,2,s3);
			GetBits(plane,3,s4);
			*win++ = s1 | (s2 << 8) | (s3 << 16) | (s4 << 24);
			sha += 4;
		    }
		}
	    }
	    shaLine += shaStride;
	    y++;
	}
	pbox++;
    }
}

shadowUpdateProc shadowUpdatePlanar4Weak(void) {
    return shadowUpdatePlanar4;
}

shadowUpdateProc shadowUpdatePlanar4x8Weak(void) {
    return shadowUpdatePlanar4x8;
}
/*
 *
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    <X11/fonts/font.h>
#include    "dixfontstr.h"
#include    <X11/fonts/fontstruct.h>
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"
#include    "fb.h"

/*
 * Expose 8bpp depth 4
 */

/*
 *  32->8 conversion:
 *
 *      7 6 5 4 3 2 1 0
 *      A B C D E F G H
 *
 *      3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *      1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * m1   D x x x x x x x C x x x x x x x B x x x x x x x A x x x x x x x     sha[0] << (7-(p))
 * m2   x x x x H x x x x x x x G x x x x x x x F x x x x x x x E x x x     sha[1] << (3-(p))
 * m3   D               C               B               A                   m1 & 0x80808080
 * m4           H               G               F               E           m2 & 0x08080808
 * m5   D       H       C       G       B       F       A       E	    m3 | m4
 * m6                     D       H       C       G       B       F         m5 >> 9
 * m7   D       H       C D     G H     B C     F G     A B     E F         m5 | m6
 * m8                                       D       H       C D     G H     m7 >> 18
 * m9   D       H       C D     G H     B C D   F G H   A B C D E F G H     m7 | m8
 */

#define PL_SHIFT    8
#define PL_UNIT	    (1 << PL_SHIFT)
#define PL_MASK	    (PL_UNIT - 1)

#if 0
#define GetBits(p,o,d) { \
    CARD32	m1,m2,m3,m4,m5,m6,m7,m8; \
    m1 = sha[o] << (7 - (p)); \
    m2 = sha[(o)+1] << (3 - (p)); \
    m3 = m1 & 0x80808080; \
    m4 = m2 & 0x08080808; \
    m5 = m3 | m4; \
    m6 = m5 >> 9; \
    m7 = m5 | m6; \
    m8 = m7 >> 18; \
    d = m7 | m8; \
}
#else
#define GetBits(p,o,d) { \
    CARD32	m5,m7; \
    m5 = ((sha[o] << (7 - (p))) & 0x80808080) | ((sha[(o)+1] << (3 - (p))) & 0x08080808); \
    m7 = m5 | (m5 >> 9); \
    d = m7 | (m7 >> 18); \
}
#endif

void
shadowUpdatePlanar4x8 (ScreenPtr	pScreen,
		       shadowBufPtr	pBuf)
{
    RegionPtr	damage = shadowDamage (pBuf);
    PixmapPtr	pShadow = pBuf->pPixmap;
    int		nbox = RegionNumRects (damage);
    BoxPtr	pbox = RegionRects (damage);
    CARD32	*shaBase, *shaLine, *sha;
    CARD8	s1, s2, s3, s4;
    FbStride	shaStride;
    int		scrBase, scrLine, scr;
    int		shaBpp;
    _X_UNUSED int	shaXoff, shaYoff;
    int		x, y, w, h, width;
    int         i;
    CARD32	*winBase = NULL, *win;
    CARD32	winSize;
    int		plane;

    fbGetStipDrawable (&pShadow->drawable, shaBase, shaStride, shaBpp, shaXoff, shaYoff);
    while (nbox--)
    {
	x = pbox->x1 * shaBpp;
	y = pbox->y1;
	w = (pbox->x2 - pbox->x1) * shaBpp;
	h = pbox->y2 - pbox->y1;

	w = (w + (x & PL_MASK) + PL_MASK) >> PL_SHIFT;
	x &= ~PL_MASK;
	
	scrLine = (x >> PL_SHIFT);
	shaLine = shaBase + y * shaStride + (x >> FB_SHIFT);
	
	while (h--)
	{
	    for (plane = 0; plane < 4; plane++)
	    {
		width = w;
		scr = scrLine;
		sha = shaLine;
		winSize = 0;
		scrBase = 0;
		while (width) {
		    /* how much remains in this window */
		    i = scrBase + winSize - scr;
		    if (i <= 0 || scr < scrBase)
		    {
			winBase = (CARD32 *) (*pBuf->window) (pScreen,
							      y,
							      (scr << 4) | (plane),
							      SHADOW_WINDOW_WRITE,
							      &winSize,
							      pBuf->closure);
			if(!winBase)
			    return;
			winSize >>= 2;
			scrBase = scr;
			i = winSize;
		    }
		    win = winBase + (scr - scrBase);
		    if (i > width)
		    i = width;
		    width -= i;
		    scr += i;
		   
		    while (i--)
		    {
			GetBits(plane,0,s1);
			GetBits(plane,2,s2);
			GetBits(plane,4,s3);
			GetBits(plane,6,s4);
			*win++ = s1 | (s2 << 8) | (s3 << 16) | (s4 << 24);
			sha += 8;
		    }
		}
	    }
	    shaLine += shaStride;
	    y++;
	}
	pbox++;
    }
}
		    
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate16
#define Data	CARD16

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate16_180
#define Data	CARD16
#define ROTATE	180

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate16_270
#define Data	CARD16
#define ROTATE	270

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright  2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate16_270YX
#define Data	CARD16
#define ROTATE	270

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpackYX.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate16_90
#define Data	CARD16
#define ROTATE	90

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright  2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate16_90YX
#define Data	CARD16
#define ROTATE	90

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpackYX.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate32
#define Data	CARD32

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate32_180
#define Data	CARD32
#define ROTATE	180

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate32_270
#define Data	CARD32
#define ROTATE	270

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate32_90
#define Data	CARD32
#define ROTATE	90

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate8
#define Data	CARD8

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate8_180
#define Data	CARD8
#define ROTATE	180

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate8_270
#define Data	CARD8
#define ROTATE	270

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FUNC	shadowUpdateRotate8_90
#define Data	CARD8
#define ROTATE	90

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "shrotpack.h"
/*
 *
 * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    <X11/fonts/font.h>
#include    "dixfontstr.h"
#include    <X11/fonts/fontstruct.h>
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"
#include    "fb.h"

/*
 * These indicate which way the source (shadow) is scanned when
 * walking the screen in a particular direction
 */

#define LEFT_TO_RIGHT	1
#define RIGHT_TO_LEFT	-1
#define TOP_TO_BOTTOM	2
#define BOTTOM_TO_TOP	-2

void
shadowUpdateRotatePacked (ScreenPtr	pScreen,
			  shadowBufPtr	pBuf)
{
    RegionPtr	damage = shadowDamage (pBuf);
    PixmapPtr	pShadow = pBuf->pPixmap;
    int		nbox = RegionNumRects (damage);
    BoxPtr	pbox = RegionRects (damage);
    FbBits	*shaBits;
    FbStride	shaStride;
    int		shaBpp;
    _X_UNUSED int	shaXoff, shaYoff;
    int		box_x1, box_x2, box_y1, box_y2;
    int		sha_x1 = 0, sha_y1 = 0;
    int		scr_x1 = 0, scr_x2 = 0, scr_y1 = 0, scr_y2 = 0, scr_w, scr_h;
    int		scr_x, scr_y;
    int		w;
    int		pixelsPerBits;
    int		pixelsMask;
    FbStride	shaStepOverY = 0, shaStepDownY = 0;
    FbStride	shaStepOverX = 0, shaStepDownX = 0;
    FbBits	*shaLine, *sha;
    int		shaHeight = pShadow->drawable.height;
    int		shaWidth = pShadow->drawable.width;
    FbBits	shaMask;
    int		shaFirstShift, shaShift;
    int		o_x_dir;
    int		o_y_dir;
    int		x_dir;
    int		y_dir;

    fbGetDrawable (&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff, shaYoff);
    pixelsPerBits = (sizeof (FbBits) * 8) / shaBpp;
    pixelsMask = ~(pixelsPerBits - 1);
    shaMask = FbBitsMask (FB_UNIT-shaBpp, shaBpp);
    /*
     * Compute rotation related constants to walk the shadow
     */
    o_x_dir = LEFT_TO_RIGHT;
    o_y_dir = TOP_TO_BOTTOM;
    if (pBuf->randr & SHADOW_REFLECT_X)
	o_x_dir = -o_x_dir;
    if (pBuf->randr & SHADOW_REFLECT_Y)
	o_y_dir = -o_y_dir;
    switch (pBuf->randr & (SHADOW_ROTATE_ALL)) {
    case SHADOW_ROTATE_0:	/* upper left shadow -> upper left screen */
    default:
	x_dir = o_x_dir;
	y_dir = o_y_dir;
	break;
    case SHADOW_ROTATE_90:    	/* upper right shadow -> upper left screen */
	x_dir = o_y_dir;
	y_dir = -o_x_dir;
	break;
    case SHADOW_ROTATE_180:	/* lower right shadow -> upper left screen */
	x_dir = -o_x_dir;
	y_dir = -o_y_dir;
	break;
    case SHADOW_ROTATE_270:	/* lower left shadow -> upper left screen */
	x_dir = -o_y_dir;
	y_dir = o_x_dir;
	break;
    }
    switch (x_dir) {
    case LEFT_TO_RIGHT:
	shaStepOverX = shaBpp;
	shaStepOverY = 0;
	break;
    case TOP_TO_BOTTOM:
	shaStepOverX = 0;
	shaStepOverY = shaStride;
	break;
    case RIGHT_TO_LEFT:
	shaStepOverX = -shaBpp;
	shaStepOverY = 0;
	break;
    case BOTTOM_TO_TOP:
	shaStepOverX = 0;
	shaStepOverY = -shaStride;
	break;
    }
    switch (y_dir) {
    case TOP_TO_BOTTOM:
	shaStepDownX = 0;
	shaStepDownY = shaStride;
	break;
    case RIGHT_TO_LEFT:
	shaStepDownX = -shaBpp;
	shaStepDownY = 0;
	break;
    case BOTTOM_TO_TOP:
	shaStepDownX = 0;
	shaStepDownY = -shaStride;
	break;
    case LEFT_TO_RIGHT:
	shaStepDownX = shaBpp;
	shaStepDownY = 0;
	break;
    }
    
    while (nbox--)
    {
        box_x1 = pbox->x1;
        box_y1 = pbox->y1;
        box_x2 = pbox->x2;
        box_y2 = pbox->y2;
        pbox++;

	/*
	 * Compute screen and shadow locations for this box
	 */
	switch (x_dir) {
	case LEFT_TO_RIGHT:
	    scr_x1 = box_x1 & pixelsMask;
	    scr_x2 = (box_x2 + pixelsPerBits - 1) & pixelsMask;
	    
	    sha_x1 = scr_x1;
	    break;
	case TOP_TO_BOTTOM:
	    scr_x1 = box_y1 & pixelsMask;
	    scr_x2 = (box_y2 + pixelsPerBits - 1) & pixelsMask;

	    sha_y1 = scr_x1;
	    break;
	case RIGHT_TO_LEFT:
	    scr_x1 = (shaWidth - box_x2) & pixelsMask;
	    scr_x2 = (shaWidth - box_x1 + pixelsPerBits - 1) & pixelsMask;

	    sha_x1 = (shaWidth - scr_x1 - 1);
	    break;
	case BOTTOM_TO_TOP:
	    scr_x1 = (shaHeight - box_y2) & pixelsMask;
	    scr_x2 = (shaHeight - box_y1 + pixelsPerBits - 1) & pixelsMask;
	    
	    sha_y1 = (shaHeight - scr_x1 - 1);
	    break;
	}
	switch (y_dir) {
	case TOP_TO_BOTTOM:
	    scr_y1 = box_y1;
	    scr_y2 = box_y2;

	    sha_y1 = scr_y1;
	    break;
	case RIGHT_TO_LEFT:
	    scr_y1 = (shaWidth - box_x2);
	    scr_y2 = (shaWidth - box_x1);

	    sha_x1 = box_x2 - 1;
	    break;
	case BOTTOM_TO_TOP:
	    scr_y1 = shaHeight - box_y2;
	    scr_y2 = shaHeight - box_y1;
	    
	    sha_y1 = box_y2 - 1;
	    break;
	case LEFT_TO_RIGHT:
	    scr_y1 = box_x1;
	    scr_y2 = box_x2;

	    sha_x1 = box_x1;
	    break;
	}
	scr_w = ((scr_x2 - scr_x1) * shaBpp) >> FB_SHIFT;
	scr_h = scr_y2 - scr_y1;
	scr_y = scr_y1;

	/* shift amount for first pixel on screen */ 
	shaFirstShift = FB_UNIT - ((sha_x1 * shaBpp) & FB_MASK) - shaBpp;
	
	/* pointer to shadow data first placed on screen */
	shaLine = (shaBits + 
		   sha_y1 * shaStride + 
		   ((sha_x1 * shaBpp) >> FB_SHIFT));

	/*
	 * Copy the bits, always write across the physical frame buffer
	 * to take advantage of write combining.
	 */
	while (scr_h--)
	{
	    int	    p;
	    FbBits  bits;
	    FbBits  *win;
	    int	    i;
	    CARD32  winSize;
	    
	    sha = shaLine;
	    shaShift = shaFirstShift;
	    w = scr_w;
	    scr_x = scr_x1 * shaBpp >> FB_SHIFT;

	    while (w)
	    {
		/*
		 * Map some of this line
		 */
		win = (FbBits *) (*pBuf->window) (pScreen,
						  scr_y,
						  scr_x << 2,
						  SHADOW_WINDOW_WRITE,
						  &winSize,
						  pBuf->closure);
		i = (winSize >> 2);
		if (i > w)
		    i = w;
		w -= i;
		scr_x += i;
		/*
		 * Copy the portion of the line mapped
		 */
		while (i--)
		{
		    bits = 0;
		    p = pixelsPerBits;
		    /*
		     * Build one word of output from multiple inputs
		     * 
		     * Note that for 90/270 rotations, this will walk
		     * down the shadow hitting each scanline once.
		     * This is probably not very efficient.
		     */
		    while (p--)
		    {
			bits = FbScrLeft(bits, shaBpp);
			bits |= FbScrRight (*sha, shaShift) & shaMask;

			shaShift -= shaStepOverX;
			if (shaShift >= FB_UNIT)
			{
			    shaShift -= FB_UNIT;
			    sha--;
			}
			else if (shaShift < 0)
			{
			    shaShift += FB_UNIT;
			    sha++;
			}
			sha += shaStepOverY;
		    }
		    *win++ = bits;
		}
	    }
	    scr_y++;
	    shaFirstShift -= shaStepDownX;
	    if (shaFirstShift >= FB_UNIT)
	    {
		shaFirstShift -= FB_UNIT;
		shaLine--;
	    }
	    else if (shaFirstShift < 0)
	    {
		shaFirstShift += FB_UNIT;
		shaLine++;
	    }
	    shaLine += shaStepDownY;
	}
    }
}

shadowUpdateProc shadowUpdateRotatePackedWeak(void) {
    return shadowUpdateRotatePacked;
}
/*
 *
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Thanks to Daniel Chemko <dchemko@intrinsyc.com> for making the 90 and 180
 * orientations work.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    <X11/fonts/font.h>
#include    "dixfontstr.h"
#include    <X11/fonts/fontstruct.h>
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"
#include    "fb.h"

#define DANDEBUG         0

#if ROTATE == 270

#define SCRLEFT(x,y,w,h)    (pScreen->height - ((y) + (h)))
#define SCRY(x,y,w,h)	    (x)
#define SCRWIDTH(x,y,w,h)   (h)
#define FIRSTSHA(x,y,w,h)   (((y) + (h) - 1) * shaStride + (x))
#define STEPDOWN(x,y,w,h)   ((w)--)
#define NEXTY(x,y,w,h)	    ((x)++)
#define SHASTEPX(stride)    -(stride)
#define SHASTEPY(stride)    (1)

#elif ROTATE == 90

#define SCRLEFT(x,y,w,h)    (y)
#define SCRY(x,y,w,h)	    (pScreen->width - ((x) + (w)) - 1)
#define SCRWIDTH(x,y,w,h)   (h)
#define FIRSTSHA(x,y,w,h)   ((y) * shaStride + (x + w - 1))
#define STEPDOWN(x,y,w,h)   ((w)--)
#define NEXTY(x,y,w,h)	    ((void)(x))
#define SHASTEPX(stride)    (stride)
#define SHASTEPY(stride)    (-1)

#elif ROTATE == 180

#define SCRLEFT(x,y,w,h)    (pScreen->width - ((x) + (w)))
#define SCRY(x,y,w,h)	    (pScreen->height - ((y) + (h)) - 1)
#define SCRWIDTH(x,y,w,h)   (w)
#define FIRSTSHA(x,y,w,h)   ((y + h - 1) * shaStride + (x + w - 1))
#define STEPDOWN(x,y,w,h)   ((h)--)
#define NEXTY(x,y,w,h)	    ((void)(y))
#define SHASTEPX(stride)    (-1)
#define SHASTEPY(stride)    -(stride)

#else

#define SCRLEFT(x,y,w,h)    (x)
#define SCRY(x,y,w,h)	    (y)
#define SCRWIDTH(x,y,w,h)   (w)
#define FIRSTSHA(x,y,w,h)   ((y) * shaStride + (x))
#define STEPDOWN(x,y,w,h)   ((h)--)
#define NEXTY(x,y,w,h)	    ((y)++)
#define SHASTEPX(stride)    (1)
#define SHASTEPY(stride)    (stride)

#endif

void
FUNC (ScreenPtr	    pScreen,
      shadowBufPtr  pBuf)
{
    RegionPtr	damage = shadowDamage (pBuf);
    PixmapPtr	pShadow = pBuf->pPixmap;
    int		nbox = RegionNumRects (damage);
    BoxPtr	pbox = RegionRects (damage);
    FbBits	*shaBits;
    Data	*shaBase, *shaLine, *sha;
    FbStride	shaStride;
    int		scrBase, scrLine, scr;
    int		shaBpp;
    _X_UNUSED int	shaXoff, shaYoff;
    int		x, y, w, h, width;
    int         i;
    Data	*winBase = NULL, *win;
    CARD32	winSize;

    fbGetDrawable (&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff, shaYoff);
    shaBase = (Data *) shaBits;
    shaStride = shaStride * sizeof (FbBits) / sizeof (Data);
#if (DANDEBUG > 1)
    ErrorF ("-> Entering Shadow Update:\r\n   |- Origins: pShadow=%x, pScreen=%x, damage=%x\r\n   |- Metrics: shaStride=%d, shaBase=%x, shaBpp=%d\r\n   |                                                     \n", pShadow, pScreen, damage, shaStride, shaBase, shaBpp);
#endif
    while (nbox--)
    {
        x = pbox->x1;
        y = pbox->y1;
        w = (pbox->x2 - pbox->x1);
        h = pbox->y2 - pbox->y1;
        
#if (DANDEBUG > 2)
        ErrorF ("   |-> Redrawing box - Metrics: X=%d, Y=%d, Width=%d, Height=%d\n", x, y, w, h);
#endif
        scrLine = SCRLEFT(x,y,w,h);
        shaLine = shaBase + FIRSTSHA(x,y,w,h);
        
        while (STEPDOWN(x,y,w,h))
        {
            winSize = 0;
            scrBase = 0;
            width = SCRWIDTH(x,y,w,h);
            scr = scrLine;
            sha = shaLine;
#if (DANDEBUG > 3)
            ErrorF ("   |   |-> StepDown - Metrics: width=%d, scr=%x, sha=%x\n", width, scr, sha);
#endif
            while (width)
            {
                /*  how much remains in this window */
                i = scrBase + winSize - scr;
                if (i <= 0 || scr < scrBase)
                {
                    winBase = (Data *) (*pBuf->window) (pScreen,
							SCRY(x,y,w,h),
							scr * sizeof (Data),
							SHADOW_WINDOW_WRITE,
							&winSize,
							pBuf->closure);
                    if(!winBase)
                        return;
                    scrBase = scr;
                    winSize /= sizeof (Data);
                    i = winSize;
#if(DANDEBUG > 4)
                    ErrorF ("   |   |   |-> Starting New Line - Metrics: winBase=%x, scrBase=%x, winSize=%d\r\n   |   |   |   Xstride=%d, Ystride=%d, w=%d h=%d\n", winBase, scrBase, winSize, SHASTEPX(shaStride), SHASTEPY(shaStride), w, h);
#endif
                }
                win = winBase + (scr - scrBase);
                if (i > width)
                    i = width;
                width -= i;
                scr += i;
#if(DANDEBUG > 5)
		ErrorF ("   |   |   |-> Writing Line - Metrics: win=%x, sha=%x\n", win, sha);
#endif
                while (i--)
                {
#if(DANDEBUG > 6)
		    ErrorF ("   |   |   |-> Writing Pixel - Metrics: win=%x, sha=%d, remaining=%d\n", win, sha, i);
#endif
                    *win++ = *sha;
                    sha += SHASTEPX(shaStride);
                } /*  i */
            } /*  width */
            shaLine += SHASTEPY(shaStride);
            NEXTY(x,y,w,h);
        } /*  STEPDOWN */
        pbox++;
    } /*  nbox */
}
/*
 * Copyright © 2004 Philip Blundell
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Philip Blundell not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Philip Blundell makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * PHILIP BLUNDELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL PHILIP BLUNDELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    "dixfontstr.h"
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"
#include    "fb.h"

#if ROTATE == 270

#define WINSTEPX(stride)    (stride)
#define WINSTART(x,y)       (((pScreen->height - 1) - y) + (x * winStride))
#define WINSTEPY()	    -1

#elif ROTATE == 90

#define WINSTEPX(stride)    (-stride)
#define WINSTEPY()	    1
#define WINSTART(x,y)       (((pScreen->width - 1 - x) * winStride) + y)

#else

#error This rotation is not supported here

#endif

#ifdef __arm__
#define PREFETCH
#endif

void
FUNC (ScreenPtr	    pScreen,
      shadowBufPtr  pBuf);

void
FUNC (ScreenPtr	    pScreen,
      shadowBufPtr  pBuf)
{
    RegionPtr	damage = shadowDamage(pBuf);
    PixmapPtr	pShadow = pBuf->pPixmap;
    int		nbox = RegionNumRects (damage);
    BoxPtr	pbox = RegionRects (damage);
    FbBits	*shaBits;
    Data	*shaBase, *shaLine, *sha;
    FbStride	shaStride, winStride;
    int		shaBpp;
    _X_UNUSED int	shaXoff, shaYoff;
    int		x, y, w, h;
    Data	*winBase, *win, *winLine;
    CARD32	winSize;

    fbGetDrawable (&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff, shaYoff);
    shaBase = (Data *) shaBits;
    shaStride = shaStride * sizeof (FbBits) / sizeof (Data);

    winBase = (Data *) (*pBuf->window) (pScreen, 0, 0,
					SHADOW_WINDOW_WRITE,
					&winSize, pBuf->closure);
    winStride = (Data *) (*pBuf->window) (pScreen, 1, 0,
					  SHADOW_WINDOW_WRITE,
					  &winSize, pBuf->closure) - winBase;

    while (nbox--)
    {
        x = pbox->x1;
        y = pbox->y1;
        w = (pbox->x2 - pbox->x1);
        h = pbox->y2 - pbox->y1;

	shaLine = shaBase + (y * shaStride) + x;
#ifdef PREFETCH
	__builtin_prefetch (shaLine);
#endif
	winLine = winBase + WINSTART(x, y);

        while (h--)
        {
	    sha = shaLine;
	    win = winLine;

            while (sha < (shaLine + w - 16))
            {
#ifdef PREFETCH
		__builtin_prefetch (sha + shaStride);
#endif
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);

		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);

		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);

		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
            }

            while (sha < (shaLine + w))
            {
		*win = *sha++;
		win += WINSTEPX(winStride);
            }

	    y++;
	    shaLine += shaStride;
	    winLine += WINSTEPY();
        }
        pbox++;
    } /*  nbox */
}
noinst_LTLIBRARIES = libsync.la

AM_CFLAGS = $(DIX_CFLAGS)

INCLUDES = 

if XORG
sdk_HEADERS = misync.h misyncstr.h
endif

libsync_la_SOURCES =	\
	misync.c	\
	misync.h	\
	misyncstr.h
/*
 * Copyright © 2010 NVIDIA Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "misync.h"
#include "misyncstr.h"

static DevPrivateKeyRec syncScreenPrivateKeyRec;
static DevPrivateKey syncScreenPrivateKey = &syncScreenPrivateKeyRec;

#define SYNC_SCREEN_PRIV(pScreen) 				\
    (SyncScreenPrivPtr) dixLookupPrivate(&pScreen->devPrivates,	\
					 syncScreenPrivateKey)

typedef struct _syncScreenPriv {
    /* Wrappable sync-specific screen functions */
    SyncScreenFuncsRec		funcs;

    /* Wrapped screen functions */
    CloseScreenProcPtr		CloseScreen;
} SyncScreenPrivRec, *SyncScreenPrivPtr;

/* Default implementations of the sync screen functions */
void
miSyncScreenCreateFence(ScreenPtr pScreen, SyncFence* pFence,
                        Bool initially_triggered)
{
    (void)pScreen;

    pFence->triggered = initially_triggered;
}

void miSyncScreenDestroyFence(ScreenPtr pScreen, SyncFence* pFence)
{
    (void)pScreen;
    (void)pFence;
}

/* Default implementations of the per-object functions */
static void
miSyncFenceSetTriggered(SyncFence* pFence)
{
    pFence->triggered = TRUE;
}

static void
miSyncFenceReset(SyncFence* pFence)
{
    pFence->triggered = FALSE;
}

static Bool
miSyncFenceCheckTriggered(SyncFence* pFence)
{
    return pFence->triggered;
}

static void
miSyncFenceAddTrigger(SyncTrigger* pTrigger)
{
    (void)pTrigger;

    return;
}

static void
miSyncFenceDeleteTrigger(SyncTrigger* pTrigger)
{
    (void)pTrigger;

    return;
}

/* Machine independent portion of the fence sync object implementation */
void
miSyncInitFence(ScreenPtr pScreen, SyncFence* pFence, Bool initially_triggered)
{
    SyncScreenPrivPtr pScreenPriv = SYNC_SCREEN_PRIV(pScreen);
    static const SyncFenceFuncsRec miSyncFenceFuncs = {
	&miSyncFenceSetTriggered,
	&miSyncFenceReset,
	&miSyncFenceCheckTriggered,
	&miSyncFenceAddTrigger,
	&miSyncFenceDeleteTrigger
    };

    pFence->pScreen = pScreen;
    pFence->funcs = miSyncFenceFuncs;

    pScreenPriv->funcs.CreateFence(pScreen, pFence, initially_triggered);
}

void
miSyncDestroyFence(SyncFence* pFence)
{
    ScreenPtr pScreen = pFence->pScreen;
    SyncScreenPrivPtr pScreenPriv = SYNC_SCREEN_PRIV(pScreen);
    SyncTriggerList *ptl, *pNext;

    pFence->sync.beingDestroyed = TRUE;
    /* tell all the fence's triggers that the counter has been destroyed */
    for (ptl = pFence->sync.pTriglist; ptl; ptl = pNext)
    {
	(*ptl->pTrigger->CounterDestroyed)(ptl->pTrigger);
	pNext = ptl->next;
	free(ptl); /* destroy the trigger list as we go */
    }

    pScreenPriv->funcs.DestroyFence(pScreen, pFence);

    dixFreeObjectWithPrivates(pFence, PRIVATE_SYNC_FENCE);
}

void
miSyncTriggerFence(SyncFence* pFence)
{
    SyncTriggerList *ptl, *pNext;
    CARD64 unused;

    pFence->funcs.SetTriggered(pFence);

    XSyncIntToValue(&unused, 0L);

    /* run through triggers to see if any fired */
    for (ptl = pFence->sync.pTriglist; ptl; ptl = pNext)
    {
	pNext = ptl->next;
	if ((*ptl->pTrigger->CheckTrigger)(ptl->pTrigger, unused))
	    (*ptl->pTrigger->TriggerFired)(ptl->pTrigger);
    }
}

SyncScreenFuncsPtr miSyncGetScreenFuncs(ScreenPtr pScreen)
{
    SyncScreenPrivPtr pScreenPriv = SYNC_SCREEN_PRIV(pScreen);

    return &pScreenPriv->funcs;
}

static Bool
SyncCloseScreen (int i, ScreenPtr pScreen)
{
    SyncScreenPrivPtr pScreenPriv = SYNC_SCREEN_PRIV(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;

    return (*pScreen->CloseScreen) (i, pScreen);
}

Bool
miSyncSetup(ScreenPtr pScreen)
{
    SyncScreenPrivPtr	pScreenPriv;

    static const SyncScreenFuncsRec miSyncScreenFuncs = {
	&miSyncScreenCreateFence,
	&miSyncScreenDestroyFence
    };

    if (dixPrivateKeyRegistered(syncScreenPrivateKey))
	return TRUE;

    if (!dixRegisterPrivateKey(syncScreenPrivateKey, PRIVATE_SCREEN,
			       sizeof(SyncScreenPrivRec)))
	return FALSE;

    pScreenPriv = SYNC_SCREEN_PRIV(pScreen);

    pScreenPriv->funcs = miSyncScreenFuncs;

    /* Wrap CloseScreen to clean up */
    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = SyncCloseScreen;

    return TRUE;
}
/*
 * Copyright © 2010 NVIDIA Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _MISYNC_H_
#define _MISYNC_H_

typedef struct _SyncFence SyncFence;
typedef struct _SyncTrigger SyncTrigger;

typedef void (*SyncScreenCreateFenceFunc) (ScreenPtr pScreen,
					   SyncFence* pFence,
					   Bool initially_triggered);
typedef void (*SyncScreenDestroyFenceFunc) (ScreenPtr pScreen,
					    SyncFence* pFence);

typedef struct _syncScreenFuncs {
    SyncScreenCreateFenceFunc	CreateFence;
    SyncScreenDestroyFenceFunc	DestroyFence;
} SyncScreenFuncsRec, *SyncScreenFuncsPtr;

extern _X_EXPORT void
miSyncScreenCreateFence(ScreenPtr pScreen, SyncFence* pFence,
			Bool initially_triggered);
extern _X_EXPORT void
miSyncScreenDestroyFence(ScreenPtr pScreen, SyncFence* pFence);

typedef void (*SyncFenceSetTriggeredFunc) (SyncFence* pFence);
typedef void (*SyncFenceResetFunc) (SyncFence* pFence);
typedef Bool (*SyncFenceCheckTriggeredFunc) (SyncFence* pFence);
typedef void (*SyncFenceAddTriggerFunc) (SyncTrigger* pTrigger);
typedef void (*SyncFenceDeleteTriggerFunc) (SyncTrigger* pTrigger);

typedef struct _syncFenceFuncs {
    SyncFenceSetTriggeredFunc	SetTriggered;
    SyncFenceResetFunc		Reset;
    SyncFenceCheckTriggeredFunc	CheckTriggered;
    SyncFenceAddTriggerFunc	AddTrigger;
    SyncFenceDeleteTriggerFunc	DeleteTrigger;
} SyncFenceFuncsRec, *SyncFenceFuncsPtr;

extern _X_EXPORT void
miSyncInitFence(ScreenPtr pScreen, SyncFence* pFence, Bool initially_triggered);
extern _X_EXPORT void
miSyncDestroyFence(SyncFence* pFence);
extern _X_EXPORT void
miSyncTriggerFence(SyncFence* pFence);

extern _X_EXPORT SyncScreenFuncsPtr
miSyncGetScreenFuncs(ScreenPtr pScreen);
extern _X_EXPORT Bool
miSyncSetup(ScreenPtr pScreen);

#endif /* _MISYNC_H_ */
/*
 * Copyright © 2010 NVIDIA Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _MISYNCSTR_H_
#define _MISYNCSTR_H_

#include "dix.h"
#include <X11/extensions/syncconst.h>

#define CARD64 XSyncValue /* XXX temporary! need real 64 bit values for Alpha */

/* Sync object types */
#define SYNC_COUNTER		0
#define SYNC_FENCE		1

typedef struct _SyncObject {
    ClientPtr		client;	/* Owning client. 0 for system counters */
    struct _SyncTriggerList *pTriglist;	/* list of triggers */
    XID			id;		/* resource ID */
    unsigned char	type;		/* SYNC_* */
    Bool		beingDestroyed;	/* in process of going away */
} SyncObject;

typedef struct _SyncCounter {
    SyncObject		sync;		/* Common sync object data */
    CARD64		value;		/* counter value */
    struct _SysCounterInfo *pSysCounterInfo; /* NULL if not a system counter */
} SyncCounter;

struct _SyncFence {
    SyncObject		sync;		/* Common sync object data */
    ScreenPtr		pScreen;	/* Screen of this fence object */
    SyncFenceFuncsRec	funcs;		/* Funcs for performing ops on fence */
    Bool		triggered;	/* fence state */
    PrivateRec		*devPrivates;	/* driver-specific per-fence data */
};

struct _SyncTrigger {
    SyncObject *pSync;
    CARD64	wait_value;	/* wait value */
    unsigned int value_type;	/* Absolute or Relative */
    unsigned int test_type;	/* transition or Comparision type */
    CARD64	test_value;	/* trigger event threshold value */
    Bool	(*CheckTrigger)(
				struct _SyncTrigger * /*pTrigger*/,
				CARD64 /*newval*/
				);
    void	(*TriggerFired)(
				struct _SyncTrigger * /*pTrigger*/
				);
    void	(*CounterDestroyed)(
				struct _SyncTrigger * /*pTrigger*/
				    );
};

typedef struct _SyncTriggerList {
    SyncTrigger *pTrigger;
    struct _SyncTriggerList *next;
} SyncTriggerList;

#endif /* _MISYNCSTR_H_ */

/***********************************************************

Copyright 1987, 1998  The Open Group

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, and/or sell copies of the Software, and to permit persons
to whom the Software is furnished to do so, provided that the above
copyright notice(s) and this permission notice appear in all copies of
the Software and that both the above copyright notice(s) and this
permission notice appear in supporting documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.

X Window System is a trademark of The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef WIN32
#include <X11/Xwinsock.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include <X11/Xauth.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "site.h"
#include <errno.h>
#include <sys/types.h>
#ifndef WIN32
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <ctype.h>

#if defined(TCPCONN) || defined(STREAMSCONN) 
#include <netinet/in.h>
#endif /* TCPCONN || STREAMSCONN */

#ifdef HAS_GETPEERUCRED
# include <ucred.h>
# ifdef sun
#  include <zone.h>
# endif
#endif

#if defined(SVR4) ||  (defined(SYSV) && defined(__i386__)) || defined(__GNU__)
# include <sys/utsname.h>
#endif
#if defined(SYSV) &&  defined(__i386__)
# include <sys/stream.h>
#endif
#ifdef __GNU__
#undef SIOCGIFCONF
#include <netdb.h>
#else /*!__GNU__*/
# include <net/if.h>
#endif /*__GNU__ */

#ifdef SVR4
#include <sys/sockio.h>
#include <sys/stropts.h>
#endif

#include <netdb.h>

#ifdef CSRG_BASED
#include <sys/param.h>
#if (BSD >= 199103)
#define VARIABLE_IFREQ
#endif
#endif

#ifdef BSD44SOCKETS
#ifndef VARIABLE_IFREQ
#define VARIABLE_IFREQ
#endif
#endif

#ifdef HAS_GETIFADDRS
#include <ifaddrs.h>
#endif

/* Solaris provides an extended interface SIOCGLIFCONF.  Other systems
 * may have this as well, but the code has only been tested on Solaris
 * so far, so we only enable it there.  Other platforms may be added as
 * needed.
 *
 * Test for Solaris commented out  --  TSI @ UQV  2003.06.13
 */
#ifdef SIOCGLIFCONF
/* #if defined(sun) */
#define USE_SIOCGLIFCONF
/* #endif */
#endif

#endif /* WIN32 */


#define X_INCLUDE_NETDB_H
#include <X11/Xos_r.h>

#include "dixstruct.h"
#include "osdep.h"

#include "xace.h"

Bool defeatAccessControl = FALSE;

#define acmp(a1, a2, len) memcmp((char *)(a1), (char *)(a2), len)
#define acopy(a1, a2, len) memmove((char *)(a2), (char *)(a1), len)
#define addrEqual(fam, address, length, host) \
			 ((fam) == (host)->family &&\
			  (length) == (host)->len &&\
			  !acmp (address, (host)->addr, length))

static int ConvertAddr(struct sockaddr * /*saddr*/,
		       int * /*len*/,
		       pointer * /*addr*/);

static int CheckAddr(int /*family*/,
		     const void * /*pAddr*/,
		     unsigned /*length*/);

static Bool NewHost(int /*family*/,
		    const void  * /*addr*/,
		    int /*len*/,
		    int /* addingLocalHosts */);

/* XFree86 bug #156: To keep track of which hosts were explicitly requested in
   /etc/X<display>.hosts, we've added a requested field to the HOST struct,
   and a LocalHostRequested variable.  These default to FALSE, but are set
   to TRUE in ResetHosts when reading in /etc/X<display>.hosts.  They are
   checked in DisableLocalHost(), which is called to disable the default 
   local host entries when stronger authentication is turned on. */

typedef struct _host {
	short		family;
	short		len;
	unsigned char	*addr;
	struct _host *next;
	int		requested;
} HOST;

#define MakeHost(h,l)	(h)=malloc(sizeof *(h)+(l));\
			if (h) { \
			   (h)->addr=(unsigned char *) ((h) + 1);\
			   (h)->requested = FALSE; \
			}
#define FreeHost(h)	free(h)
static HOST *selfhosts = NULL;
static HOST *validhosts = NULL;
static int AccessEnabled = DEFAULT_ACCESS_CONTROL;
static int LocalHostEnabled = FALSE;
static int LocalHostRequested = FALSE;
static int UsingXdmcp = FALSE;

/* FamilyServerInterpreted implementation */
static Bool siAddrMatch(int family, pointer addr, int len, HOST *host, 
	ClientPtr client);
static int  siCheckAddr(const char *addrString, int length);
static void siTypesInitialize(void);

/*
 * called when authorization is not enabled to add the
 * local host to the access list
 */

void
EnableLocalHost (void)
{
    if (!UsingXdmcp)
    {
	LocalHostEnabled = TRUE;
	AddLocalHosts ();
    }
}

/*
 * called when authorization is enabled to keep us secure
 */
void
DisableLocalHost (void)
{
    HOST *self;

    if (!LocalHostRequested)		/* Fix for XFree86 bug #156 */
	LocalHostEnabled = FALSE;
    for (self = selfhosts; self; self = self->next) {
      if (!self->requested)		/* Fix for XFree86 bug #156 */
	(void) RemoveHost ((ClientPtr)NULL, self->family, self->len, (pointer)self->addr);
    }
}

/*
 * called at init time when XDMCP will be used; xdmcp always
 * adds local hosts manually when needed
 */

void
AccessUsingXdmcp (void)
{
    UsingXdmcp = TRUE;
    LocalHostEnabled = FALSE;
}


#if  defined(SVR4) && !defined(sun)  && defined(SIOCGIFCONF) && !defined(USE_SIOCGLIFCONF)

/* Deal with different SIOCGIFCONF ioctl semantics on these OSs */

static int
ifioctl (int fd, int cmd, char *arg)
{
    struct strioctl ioc;
    int ret;

    memset((char *) &ioc, 0, sizeof(ioc));
    ioc.ic_cmd = cmd;
    ioc.ic_timout = 0;
    if (cmd == SIOCGIFCONF)
    {
	ioc.ic_len = ((struct ifconf *) arg)->ifc_len;
	ioc.ic_dp = ((struct ifconf *) arg)->ifc_buf;
    }
    else
    {
	ioc.ic_len = sizeof(struct ifreq);
	ioc.ic_dp = arg;
    }
    ret = ioctl(fd, I_STR, (char *) &ioc);
    if (ret >= 0 && cmd == SIOCGIFCONF)
#ifdef SVR4
	((struct ifconf *) arg)->ifc_len = ioc.ic_len;
#endif
    return ret;
}
#else
#define ifioctl ioctl
#endif

/*
 * DefineSelf (fd):
 *
 * Define this host for access control.  Find all the hosts the OS knows about 
 * for this fd and add them to the selfhosts list.
 */

#if !defined(SIOCGIFCONF) 
void
DefineSelf (int fd)
{
#if !defined(TCPCONN) && !defined(STREAMSCONN) && !defined(UNIXCONN)
    return;
#else
    register int n;
    int	len;
    caddr_t	addr;
    int		family;
    register HOST	*host;

#ifndef WIN32
    struct utsname name;
#else
    struct {
        char  nodename[512];	    
    } name;
#endif

    register struct hostent  *hp;

    union {
	struct  sockaddr   sa;
	struct  sockaddr_in  in;
#if defined(IPv6) && defined(AF_INET6)
	struct  sockaddr_in6  in6;
#endif
    } saddr;
	
    struct	sockaddr_in	*inetaddr;
    struct	sockaddr_in6	*inet6addr;
    struct sockaddr_in broad_addr;
#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
    _Xgethostbynameparams hparams;
#endif

    /* Why not use gethostname()?  Well, at least on my system, I've had to
     * make an ugly kernel patch to get a name longer than 8 characters, and
     * uname() lets me access to the whole string (it smashes release, you
     * see), whereas gethostname() kindly truncates it for me.
     */
#ifndef WIN32
    uname(&name);
#else
    gethostname(name.nodename, sizeof(name.nodename));
#endif

    hp = _XGethostbyname(name.nodename, hparams);
    if (hp != NULL)
    {
	saddr.sa.sa_family = hp->h_addrtype;
	switch (hp->h_addrtype) {
	case AF_INET:
	    inetaddr = (struct sockaddr_in *) (&(saddr.sa));
	    acopy ( hp->h_addr, &(inetaddr->sin_addr), hp->h_length);
	    len = sizeof(saddr.sa);
	    break;
#if defined(IPv6) && defined(AF_INET6)
	case AF_INET6:
	    inet6addr = (struct sockaddr_in6 *) (&(saddr.sa));
	    acopy ( hp->h_addr, &(inet6addr->sin6_addr), hp->h_length);
	    len = sizeof(saddr.in6);
	    break;
#endif
	default:
	    goto DefineLocalHost;
	}
	family = ConvertAddr ( &(saddr.sa), &len, (pointer *)&addr);
	if ( family != -1 && family != FamilyLocal )
	{
	    for (host = selfhosts;
		 host && !addrEqual (family, addr, len, host);
		 host = host->next) ;
	    if (!host)
	    {
		/* add this host to the host list.	*/
		MakeHost(host,len)
		if (host)
		{
		    host->family = family;
		    host->len = len;
		    acopy ( addr, host->addr, len);
		    host->next = selfhosts;
		    selfhosts = host;
		}
#ifdef XDMCP
		/*
		 *  If this is an Internet Address, but not the localhost
		 *  address (127.0.0.1), nor the bogus address (0.0.0.0),
		 *  register it.
		 */
		if (family == FamilyInternet &&
		    !(len == 4 &&
		      ((addr[0] == 127) ||
		       (addr[0] == 0 && addr[1] == 0 &&
			addr[2] == 0 && addr[3] == 0)))
		      )
		{
		    XdmcpRegisterConnection (family, (char *)addr, len);
		    broad_addr = *inetaddr;
		    ((struct sockaddr_in *) &broad_addr)->sin_addr.s_addr =
			htonl (INADDR_BROADCAST);
		    XdmcpRegisterBroadcastAddress ((struct sockaddr_in *)
						   &broad_addr);
		}
#if defined(IPv6) && defined(AF_INET6)
		else if (family == FamilyInternet6 &&
		  !(IN6_IS_ADDR_LOOPBACK((struct in6_addr *)addr)))
		{
		    XdmcpRegisterConnection (family, (char *)addr, len);
		}
#endif

#endif /* XDMCP */
	    }
	}
    }
    /*
     * now add a host of family FamilyLocalHost...
     */
DefineLocalHost:
    for (host = selfhosts;
	 host && !addrEqual(FamilyLocalHost, "", 0, host);
	 host = host->next);
    if (!host)
    {
	MakeHost(host, 0);
	if (host)
	{
	    host->family = FamilyLocalHost;
	    host->len = 0;
	    acopy("", host->addr, 0);
	    host->next = selfhosts;
	    selfhosts = host;
	}
    }
#endif /* !TCPCONN && !STREAMSCONN && !UNIXCONN */
}

#else

#ifdef USE_SIOCGLIFCONF
#define ifr_type    struct lifreq
#else
#define ifr_type    struct ifreq
#endif

#ifdef VARIABLE_IFREQ
#define ifr_size(p) (sizeof (struct ifreq) + \
		     (p->ifr_addr.sa_len > sizeof (p->ifr_addr) ? \
		      p->ifr_addr.sa_len - sizeof (p->ifr_addr) : 0))
#define ifraddr_size(a) (a.sa_len)
#else
#define ifr_size(p) (sizeof (ifr_type))
#define ifraddr_size(a) (sizeof (a))
#endif

#if defined(IPv6) && defined(AF_INET6)
#include <arpa/inet.h>
#endif

#if defined(IPv6) && defined(AF_INET6)
static void
in6_fillscopeid(struct sockaddr_in6 *sin6)
{
#if defined(__KAME__)
	if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
		sin6->sin6_scope_id =
			ntohs(*(u_int16_t *)&sin6->sin6_addr.s6_addr[2]);
		sin6->sin6_addr.s6_addr[2] = sin6->sin6_addr.s6_addr[3] = 0;
	}
#endif
}
#endif

void
DefineSelf (int fd)
{
#ifndef HAS_GETIFADDRS
    char 		*cp, *cplim;
# ifdef USE_SIOCGLIFCONF
    struct sockaddr_storage buf[16];
    struct lifconf	ifc;
    register struct lifreq *ifr;
#  ifdef SIOCGLIFNUM
    struct lifnum	ifn;
#  endif
# else /* !USE_SIOCGLIFCONF */
    char		buf[2048];
    struct ifconf	ifc;
    register struct ifreq *ifr;
# endif
    void *		bufptr = buf;   
#else /* HAS_GETIFADDRS */
    struct ifaddrs *	ifap, *ifr;
#endif
    int 		len;
    unsigned char *	addr;
    int 		family;
    register HOST 	*host;
    
#ifndef HAS_GETIFADDRS

    len = sizeof(buf);

#ifdef USE_SIOCGLIFCONF
    
#ifdef SIOCGLIFNUM
    ifn.lifn_family = AF_UNSPEC;
    ifn.lifn_flags = 0;
    if (ioctl (fd, SIOCGLIFNUM, (char *) &ifn) < 0)
        Error ("Getting interface count");    
    if (len < (ifn.lifn_count * sizeof(struct lifreq))) {
	len = ifn.lifn_count * sizeof(struct lifreq);
	bufptr = malloc(len);
    }
#endif
    
    ifc.lifc_family = AF_UNSPEC;
    ifc.lifc_flags = 0;
    ifc.lifc_len = len;
    ifc.lifc_buf = bufptr;

#define IFC_IOCTL_REQ SIOCGLIFCONF
#define IFC_IFC_REQ ifc.lifc_req
#define IFC_IFC_LEN ifc.lifc_len
#define IFR_IFR_ADDR ifr->lifr_addr
#define IFR_IFR_NAME ifr->lifr_name

#else /* Use SIOCGIFCONF */
    ifc.ifc_len = len;
    ifc.ifc_buf = bufptr;

#define IFC_IOCTL_REQ SIOCGIFCONF
#define IFC_IFC_REQ ifc.ifc_req
#define IFC_IFC_LEN ifc.ifc_len
#define IFR_IFR_ADDR ifr->ifr_addr
#define IFR_IFR_NAME ifr->ifr_name
#endif

    if (ifioctl (fd, IFC_IOCTL_REQ, (pointer) &ifc) < 0)
        Error ("Getting interface configuration (4)");

    cplim = (char *) IFC_IFC_REQ + IFC_IFC_LEN;
    
    for (cp = (char *) IFC_IFC_REQ; cp < cplim; cp += ifr_size (ifr))
    {
	ifr = (ifr_type *) cp;
	len = ifraddr_size (IFR_IFR_ADDR);
	family = ConvertAddr ((struct sockaddr *) &IFR_IFR_ADDR, 
	  			&len, (pointer *)&addr);
        if (family == -1 || family == FamilyLocal)
	    continue;
#if defined(IPv6) && defined(AF_INET6)
	if (family == FamilyInternet6) 
	    in6_fillscopeid((struct sockaddr_in6 *)&IFR_IFR_ADDR);
#endif
        for (host = selfhosts;
 	     host && !addrEqual (family, addr, len, host);
	     host = host->next)
	    ;
        if (host)
	    continue;
	MakeHost(host,len)
	if (host)
	{
	    host->family = family;
	    host->len = len;
	    acopy(addr, host->addr, len);
	    host->next = selfhosts;
	    selfhosts = host;
	}
#ifdef XDMCP
	{
#ifdef USE_SIOCGLIFCONF
	    struct sockaddr_storage broad_addr;
#else
	    struct sockaddr broad_addr;
#endif

	    /*
	     * If this isn't an Internet Address, don't register it.
	     */
	    if (family != FamilyInternet
#if defined(IPv6) && defined(AF_INET6)
	      && family != FamilyInternet6
#endif
		)
		continue;

	    /*
 	     * ignore 'localhost' entries as they're not useful
	     * on the other end of the wire
	     */
	    if (family == FamilyInternet &&
		addr[0] == 127 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 1)
		continue;
#if defined(IPv6) && defined(AF_INET6)
	    else if (family == FamilyInternet6 && 
	      IN6_IS_ADDR_LOOPBACK((struct in6_addr *)addr))
		continue;
#endif

	    /*
	     * Ignore '0.0.0.0' entries as they are
	     * returned by some OSes for unconfigured NICs but they are
	     * not useful on the other end of the wire.
	     */
	    if (len == 4 &&
		addr[0] == 0 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 0)
		continue;

	    XdmcpRegisterConnection (family, (char *)addr, len);

#if defined(IPv6) && defined(AF_INET6)
	    /* IPv6 doesn't support broadcasting, so we drop out here */
	    if (family == FamilyInternet6)
		continue;
#endif

	    broad_addr = IFR_IFR_ADDR;

	    ((struct sockaddr_in *) &broad_addr)->sin_addr.s_addr =
		htonl (INADDR_BROADCAST);
#if defined(USE_SIOCGLIFCONF) && defined(SIOCGLIFBRDADDR)
	    {
	    	struct lifreq    broad_req;
    
	    	broad_req = *ifr;
		if (ioctl (fd, SIOCGLIFFLAGS, (char *) &broad_req) != -1 &&
		    (broad_req.lifr_flags & IFF_BROADCAST) &&
		    (broad_req.lifr_flags & IFF_UP)
		    )
		{
		    broad_req = *ifr;
		    if (ioctl (fd, SIOCGLIFBRDADDR, &broad_req) != -1)
			broad_addr = broad_req.lifr_broadaddr;
		    else
			continue;
		}
		else
		    continue;
	    }

#elif defined(SIOCGIFBRDADDR)
	    {
	    	struct ifreq    broad_req;
    
	    	broad_req = *ifr;
		if (ifioctl (fd, SIOCGIFFLAGS, (pointer) &broad_req) != -1 &&
		    (broad_req.ifr_flags & IFF_BROADCAST) &&
		    (broad_req.ifr_flags & IFF_UP)
		    )
		{
		    broad_req = *ifr;
		    if (ifioctl (fd, SIOCGIFBRDADDR, (pointer) &broad_req) != -1)
			broad_addr = broad_req.ifr_addr;
		    else
			continue;
		}
		else
		    continue;
	    }
#endif /* SIOCGIFBRDADDR */
	    XdmcpRegisterBroadcastAddress ((struct sockaddr_in *) &broad_addr);
	}
#endif /* XDMCP */
    }
    if (bufptr != buf)
        free(bufptr);    
#else /* HAS_GETIFADDRS */
    if (getifaddrs(&ifap) < 0) {
	ErrorF("Warning: getifaddrs returns %s\n", strerror(errno));
	return;
    }
    for (ifr = ifap; ifr != NULL; ifr = ifr->ifa_next) {
        if (!ifr->ifa_addr)
            continue;
	len = sizeof(*(ifr->ifa_addr));
	family = ConvertAddr((struct sockaddr *) ifr->ifa_addr, &len,
			     (pointer *)&addr);
	if (family == -1 || family == FamilyLocal) 
	    continue;
#if defined(IPv6) && defined(AF_INET6)
	if (family == FamilyInternet6) 
	    in6_fillscopeid((struct sockaddr_in6 *)ifr->ifa_addr);
#endif

	for (host = selfhosts; 
	     host != NULL && !addrEqual(family, addr, len, host);
	     host = host->next) 
	    ;
	if (host != NULL) 
	    continue;
	MakeHost(host, len);
	if (host != NULL) {
	    host->family = family;
	    host->len = len;
	    acopy(addr, host->addr, len);
	    host->next = selfhosts;
	    selfhosts = host;
	}
#ifdef XDMCP
	{
	    /*
	     * If this isn't an Internet Address, don't register it.
	     */
	    if (family != FamilyInternet
#if defined(IPv6) && defined(AF_INET6)
		&& family != FamilyInternet6
#endif
	    )
		continue;

	    /* 
	     * ignore 'localhost' entries as they're not useful
	     * on the other end of the wire
	     */
	    if (ifr->ifa_flags & IFF_LOOPBACK) 
		    continue;

	    if (family == FamilyInternet && 
		addr[0] == 127 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 1) 
		continue;

	    /*
	     * Ignore '0.0.0.0' entries as they are
	     * returned by some OSes for unconfigured NICs but they are
	     * not useful on the other end of the wire.
	     */
	    if (len == 4 &&
		addr[0] == 0 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 0)
		continue;
#if defined(IPv6) && defined(AF_INET6)
	    else if (family == FamilyInternet6 && 
	      IN6_IS_ADDR_LOOPBACK((struct in6_addr *)addr))
		continue;
#endif
	    XdmcpRegisterConnection(family, (char *)addr, len);
#if defined(IPv6) && defined(AF_INET6)
	    if (family == FamilyInternet6) 
		/* IPv6 doesn't support broadcasting, so we drop out here */
		continue;
#endif
	    if ((ifr->ifa_flags & IFF_BROADCAST) &&
		(ifr->ifa_flags & IFF_UP) &&
                ifr->ifa_broadaddr)
		XdmcpRegisterBroadcastAddress(
		    (struct sockaddr_in *) ifr->ifa_broadaddr);
	    else
		continue;
	}
#endif /* XDMCP */
		
    } /* for */
    freeifaddrs(ifap);
#endif /* HAS_GETIFADDRS */

    /*
     * add something of FamilyLocalHost
     */
    for (host = selfhosts;
	 host && !addrEqual(FamilyLocalHost, "", 0, host);
	 host = host->next);
    if (!host)
    {
	MakeHost(host, 0);
	if (host)
	{
	    host->family = FamilyLocalHost;
	    host->len = 0;
	    acopy("", host->addr, 0);
	    host->next = selfhosts;
	    selfhosts = host;
	}
    }
}
#endif /* hpux && !HAS_IFREQ */

#ifdef XDMCP
void
AugmentSelf(pointer from, int len)
{
    int family;
    pointer addr;
    register HOST *host;

    family = ConvertAddr(from, &len, (pointer *)&addr);
    if (family == -1 || family == FamilyLocal)
	return;
    for (host = selfhosts; host; host = host->next)
    {
	if (addrEqual(family, addr, len, host))
	    return;
    }
    MakeHost(host,len)
    if (!host)
	return;
    host->family = family;
    host->len = len;
    acopy(addr, host->addr, len);
    host->next = selfhosts;
    selfhosts = host;
}
#endif

void
AddLocalHosts (void)
{
    HOST    *self;

    for (self = selfhosts; self; self = self->next)
	    /* Fix for XFree86 bug #156: pass addingLocal = TRUE to
	     * NewHost to tell that we are adding the default local
	     * host entries and not to flag the entries as being
	     * explicitely requested */
	(void) NewHost (self->family, self->addr, self->len, TRUE);
}

/* Reset access control list to initial hosts */
void
ResetHosts (char *display)
{
    register HOST	*host;
    char                lhostname[120], ohostname[120];
    char 		*hostname = ohostname;
    char		fname[PATH_MAX + 1];
    int			fnamelen;
    FILE		*fd;
    char		*ptr;
    int                 i, hostlen;
#if (defined(TCPCONN) || defined(STREAMSCONN) ) && \
     (!defined(IPv6) || !defined(AF_INET6))
    union {
        struct sockaddr	sa;
#if defined(TCPCONN) || defined(STREAMSCONN)
	struct sockaddr_in in;
#endif /* TCPCONN || STREAMSCONN */
    }			saddr;
#endif
    int			family = 0;
    pointer		addr;
    int 		len;

    siTypesInitialize();
    AccessEnabled = defeatAccessControl ? FALSE : DEFAULT_ACCESS_CONTROL;
    LocalHostEnabled = FALSE;
    while ((host = validhosts) != 0)
    {
        validhosts = host->next;
        FreeHost (host);
    }

#if defined WIN32 && defined __MINGW32__
#define ETC_HOST_PREFIX "X"
#else
#define ETC_HOST_PREFIX "/etc/X"
#endif
#define ETC_HOST_SUFFIX ".hosts"
    fnamelen = strlen(ETC_HOST_PREFIX) + strlen(ETC_HOST_SUFFIX) +
		strlen(display) + 1;
    if (fnamelen > sizeof(fname))
	FatalError("Display name `%s' is too long\n", display);
    snprintf(fname, sizeof(fname), ETC_HOST_PREFIX "%s" ETC_HOST_SUFFIX, 
	     display);

    if ((fd = fopen (fname, "r")) != 0)
    {
        while (fgets (ohostname, sizeof (ohostname), fd))
	{
	family = FamilyWild;
	if (*ohostname == '#')
	    continue;
    	if ((ptr = strchr(ohostname, '\n')) != 0)
    	    *ptr = 0;
        hostlen = strlen(ohostname) + 1;
        for (i = 0; i < hostlen; i++)
	    lhostname[i] = tolower(ohostname[i]);
	hostname = ohostname;
	if (!strncmp("local:", lhostname, 6))
	{
	    family = FamilyLocalHost;
	    NewHost(family, "", 0, FALSE);
	    LocalHostRequested = TRUE;	/* Fix for XFree86 bug #156 */
	}
#if defined(TCPCONN) || defined(STREAMSCONN)
	else if (!strncmp("inet:", lhostname, 5))
	{
	    family = FamilyInternet;
	    hostname = ohostname + 5;
	}
#if defined(IPv6) && defined(AF_INET6)
	else if (!strncmp("inet6:", lhostname, 6))
	{
	    family = FamilyInternet6;
	    hostname = ohostname + 6;
	}
#endif
#endif
#ifdef SECURE_RPC
	else if (!strncmp("nis:", lhostname, 4))
	{
	    family = FamilyNetname;
	    hostname = ohostname + 4;
	}
#endif
	else if (!strncmp("si:", lhostname, 3))
	{
	    family = FamilyServerInterpreted;
	    hostname = ohostname + 3;
	    hostlen -= 3;
	}


	if (family == FamilyServerInterpreted) 
	{
	    len = siCheckAddr(hostname, hostlen);
	    if (len >= 0) {
		NewHost(family, hostname, len, FALSE);
	    }
	}
	else
#ifdef SECURE_RPC
	if ((family == FamilyNetname) || (strchr(hostname, '@')))
	{
	    SecureRPCInit ();
	    (void) NewHost (FamilyNetname, hostname, strlen (hostname), FALSE);
	}
	else
#endif /* SECURE_RPC */
#if defined(TCPCONN) || defined(STREAMSCONN)
	{
#if defined(IPv6) && defined(AF_INET6)
	    if ( (family == FamilyInternet) || (family == FamilyInternet6) ||
		 (family == FamilyWild) ) 
            {
		struct addrinfo *addresses;
		struct addrinfo *a;
		int f;
	    
		if (getaddrinfo(hostname, NULL, NULL, &addresses) == 0) {
		    for (a = addresses ; a != NULL ; a = a->ai_next) {
			len = a->ai_addrlen;
			f = ConvertAddr(a->ai_addr,&len,(pointer *)&addr);
			if ( (family == f) || 
			     ((family == FamilyWild) && (f != -1)) ) {
			    NewHost(f, addr, len, FALSE);
			}			
		    }
		    freeaddrinfo(addresses);
		}
	    }
#else
#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
	    _Xgethostbynameparams hparams;
#endif
	    register struct hostent *hp;

    	    /* host name */
    	    if ((family == FamilyInternet &&
		 ((hp = _XGethostbyname(hostname, hparams)) != 0)) ||
		((hp = _XGethostbyname(hostname, hparams)) != 0))
	    {
    		saddr.sa.sa_family = hp->h_addrtype;
		len = sizeof(saddr.sa);
    		if ((family = ConvertAddr (&saddr.sa, &len, (pointer *)&addr)) != -1)
		{
#ifdef h_addr				/* new 4.3bsd version of gethostent */
		    char **list;

		    /* iterate over the addresses */
		    for (list = hp->h_addr_list; *list; list++)
			(void) NewHost (family, (pointer)*list, len, FALSE);
#else
    		    (void) NewHost (family, (pointer)hp->h_addr, len, FALSE);
#endif
		}
    	    }
#endif /* IPv6 */
        }
#endif /* TCPCONN || STREAMSCONN */
	family = FamilyWild;
        }
        fclose (fd);
    }
}

/* Is client on the local host */
Bool
ComputeLocalClient(ClientPtr client)
{
    int    		alen, family, notused;
    Xtransaddr		*from = NULL;
    pointer		addr;
    register HOST	*host;
    OsCommPtr           oc = (OsCommPtr) client->osPrivate;

    if (!oc->trans_conn)
        return FALSE;

    if (!_XSERVTransGetPeerAddr (oc->trans_conn, &notused, &alen, &from))
    {
	family = ConvertAddr ((struct sockaddr *) from,
	    &alen, (pointer *)&addr);
	if (family == -1)
	{
	    free(from);
	    return FALSE;
	}
	if (family == FamilyLocal)
	{
	    free(from);
	    return TRUE;
	}
	for (host = selfhosts; host; host = host->next)
	{
	    if (addrEqual (family, addr, alen, host)) {
		free(from);
		return TRUE;
	    }
	}
	free(from);
    }
    return FALSE;
}

Bool LocalClient(ClientPtr client)
{
    if (!client->osPrivate)
        return FALSE;
    return ((OsCommPtr)client->osPrivate)->local_client;
}

/*
 * Return the uid and gid of a connected local client
 * 
 * Used by XShm to test access rights to shared memory segments
 */
int
LocalClientCred(ClientPtr client, int *pUid, int *pGid)
{
    LocalClientCredRec *lcc;
    int ret = GetLocalClientCreds(client, &lcc);

    if (ret == 0) {
#ifdef HAVE_GETZONEID /* only local if in the same zone */
	if ((lcc->fieldsSet & LCC_ZID_SET) && (lcc->zoneid != getzoneid())) {
	    FreeLocalClientCreds(lcc);
	    return -1;
	}	    
#endif
	if ((lcc->fieldsSet & LCC_UID_SET) && (pUid != NULL))
	    *pUid = lcc->euid;
	if ((lcc->fieldsSet & LCC_GID_SET) && (pGid != NULL))
	    *pGid = lcc->egid;
	FreeLocalClientCreds(lcc);
    }
    return ret;
}

/*
 * Return the uid and all gids of a connected local client
 * Allocates a LocalClientCredRec - caller must call FreeLocalClientCreds
 * 
 * Used by localuser & localgroup ServerInterpreted access control forms below
 * Used by AuthAudit to log who local connections came from
 */
int
GetLocalClientCreds(ClientPtr client, LocalClientCredRec **lccp)
{
#if defined(HAS_GETPEEREID) || defined(HAS_GETPEERUCRED) || defined(SO_PEERCRED)
    int fd;
    XtransConnInfo ci;
    LocalClientCredRec *lcc;
#ifdef HAS_GETPEEREID
    uid_t uid;
    gid_t gid;
#elif defined(HAS_GETPEERUCRED)
    ucred_t *peercred = NULL;
    const gid_t *gids;
#elif defined(SO_PEERCRED)
    struct ucred peercred;
    socklen_t so_len = sizeof(peercred);
#endif

    if (client == NULL)
	return -1;
    ci = ((OsCommPtr)client->osPrivate)->trans_conn;
#if !(defined(sun) && defined(HAS_GETPEERUCRED))
    /* Most implementations can only determine peer credentials for Unix 
     * domain sockets - Solaris getpeerucred can work with a bit more, so 
     * we just let it tell us if the connection type is supported or not
     */
    if (!_XSERVTransIsLocal(ci)) {
	return -1;
    }
#endif

    *lccp = calloc(1, sizeof(LocalClientCredRec));
    if (*lccp == NULL)
	return -1;
    lcc = *lccp;
        
    fd = _XSERVTransGetConnectionNumber(ci);
#ifdef HAS_GETPEEREID
    if (getpeereid(fd, &uid, &gid) == -1) {
	FreeLocalClientCreds(lcc);
	return -1;
    }
    lcc->euid = uid;
    lcc->egid = gid;
    lcc->fieldsSet = LCC_UID_SET | LCC_GID_SET;
    return 0;
#elif defined(HAS_GETPEERUCRED)
    if (getpeerucred(fd, &peercred) < 0) {
	FreeLocalClientCreds(lcc);
    	return -1;
    }
    lcc->euid = ucred_geteuid(peercred);
    if (lcc->euid != -1)
	lcc->fieldsSet |= LCC_UID_SET;
    lcc->egid = ucred_getegid(peercred);
    if (lcc->egid != -1)
	lcc->fieldsSet |= LCC_GID_SET;
    lcc->pid = ucred_getpid(peercred);
    if (lcc->pid != -1)
	lcc->fieldsSet |= LCC_PID_SET;
#ifdef HAVE_GETZONEID
    lcc->zoneid = ucred_getzoneid(peercred);
    if (lcc->zoneid != -1)
	lcc->fieldsSet |= LCC_ZID_SET;
#endif
    lcc->nSuppGids = ucred_getgroups(peercred, &gids);
    if (lcc->nSuppGids > 0) {
	lcc->pSuppGids = calloc(lcc->nSuppGids, sizeof(int));
	if (lcc->pSuppGids == NULL) {
	    lcc->nSuppGids = 0;
	} else {
	    int i;
	    for (i = 0 ; i < lcc->nSuppGids; i++) {
		(lcc->pSuppGids)[i] = (int) gids[i];
	    }
	}
    } else {
	lcc->nSuppGids = 0;
    }
    ucred_free(peercred);
    return 0;
#elif defined(SO_PEERCRED)
    if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &peercred, &so_len) == -1) {
	FreeLocalClientCreds(lcc);
	return -1;
    }
    lcc->euid = peercred.uid;
    lcc->egid = peercred.gid;
    lcc->pid = peercred.pid;
    lcc->fieldsSet = LCC_UID_SET | LCC_GID_SET | LCC_PID_SET;
    return 0;
#endif
#else
    /* No system call available to get the credentials of the peer */
#define NO_LOCAL_CLIENT_CRED
    return -1;
#endif
}

void
FreeLocalClientCreds(LocalClientCredRec *lcc)
{
    if (lcc != NULL) {
	if (lcc->nSuppGids > 0) {
	    free(lcc->pSuppGids);
	}
	free(lcc);
    }
}

static int
AuthorizedClient(ClientPtr client)
{
    int rc;

    if (!client || defeatAccessControl)
	return Success;

    /* untrusted clients can't change host access */
    rc = XaceHook(XACE_SERVER_ACCESS, client, DixManageAccess);
    if (rc != Success)
	return rc;

    return LocalClient(client) ? Success : BadAccess;
}

/* Add a host to the access control list.  This is the external interface
 * called from the dispatcher */

int
AddHost (ClientPtr	client,
	 int            family,
	 unsigned       length,        /* of bytes in pAddr */
	 const void *   pAddr)
{
    int rc, len;

    rc = AuthorizedClient(client);
    if (rc != Success)
	return rc;
    switch (family) {
    case FamilyLocalHost:
	len = length;
	LocalHostEnabled = TRUE;
	break;
#ifdef SECURE_RPC
    case FamilyNetname:
	len = length;
	SecureRPCInit ();
	break;
#endif
    case FamilyInternet:
#if defined(IPv6) && defined(AF_INET6)
    case FamilyInternet6:
#endif
    case FamilyDECnet:
    case FamilyChaos:
    case FamilyServerInterpreted:
	if ((len = CheckAddr (family, pAddr, length)) < 0)
	{
	    client->errorValue = length;
	    return BadValue;
	}
	break;
    case FamilyLocal:
    default:
	client->errorValue = family;
	return BadValue;
    }
    if (NewHost (family, pAddr, len, FALSE))
	return Success;
    return BadAlloc;
}

Bool
ForEachHostInFamily (int	    family,
		     Bool    (*func)(
			 unsigned char * /* addr */,
			 short           /* len */,
			 pointer         /* closure */),
		     pointer closure)
{
    HOST    *host;

    for (host = validhosts; host; host = host->next)
	if (family == host->family && func (host->addr, host->len, closure))
	    return TRUE;
    return FALSE;
}

/* Add a host to the access control list. This is the internal interface 
 * called when starting or resetting the server */
static Bool
NewHost (int		family,
	 const void *	addr,
	 int		len,
	 int		addingLocalHosts)
{
    register HOST *host;

    for (host = validhosts; host; host = host->next)
    {
        if (addrEqual (family, addr, len, host))
	    return TRUE;
    }
    if (!addingLocalHosts) {			/* Fix for XFree86 bug #156 */
	for (host = selfhosts; host; host = host->next) {
	    if (addrEqual (family, addr, len, host)) {
		host->requested = TRUE;
		break;
	    }	    
	}
    }
    MakeHost(host,len)
    if (!host)
	return FALSE;
    host->family = family;
    host->len = len;
    acopy(addr, host->addr, len);
    host->next = validhosts;
    validhosts = host;
    return TRUE;
}

/* Remove a host from the access control list */

int
RemoveHost (
    ClientPtr		client,
    int                 family,
    unsigned            length,        /* of bytes in pAddr */
    pointer             pAddr)
{
    int rc, len;
    register HOST	*host, **prev;

    rc = AuthorizedClient(client);
    if (rc != Success)
	return rc;
    switch (family) {
    case FamilyLocalHost:
	len = length;
	LocalHostEnabled = FALSE;
	break;
#ifdef SECURE_RPC
    case FamilyNetname:
	len = length;
	break;
#endif
    case FamilyInternet:
#if defined(IPv6) && defined(AF_INET6)
    case FamilyInternet6:
#endif
    case FamilyDECnet:
    case FamilyChaos:
    case FamilyServerInterpreted:
    	if ((len = CheckAddr (family, pAddr, length)) < 0)
    	{
	    client->errorValue = length;
            return BadValue;
    	}
	break;
    case FamilyLocal:
    default:
	client->errorValue = family;
        return BadValue;
    }
    for (prev = &validhosts;
         (host = *prev) && (!addrEqual (family, pAddr, len, host));
         prev = &host->next)
        ;
    if (host)
    {
        *prev = host->next;
        FreeHost (host);
    }
    return Success;
}

/* Get all hosts in the access control list */
int
GetHosts (
    pointer		*data,
    int			*pnHosts,
    int			*pLen,
    BOOL		*pEnabled)
{
    int			len;
    register int 	n = 0;
    register unsigned char *ptr;
    register HOST	*host;
    int			nHosts = 0;

    *pEnabled = AccessEnabled ? EnableAccess : DisableAccess;
    for (host = validhosts; host; host = host->next)
    {
	nHosts++;
	n += pad_to_int32(host->len) + sizeof(xHostEntry);
    }
    if (n)
    {
        *data = ptr = malloc(n);
	if (!ptr)
	{
	    return BadAlloc;
	}
        for (host = validhosts; host; host = host->next)
	{
	    len = host->len;
	    ((xHostEntry *)ptr)->family = host->family;
	    ((xHostEntry *)ptr)->length = len;
	    ptr += sizeof(xHostEntry);
	    acopy (host->addr, ptr, len);
	    ptr += pad_to_int32(len);
        }
    } else {
	*data = NULL;
    }
    *pnHosts = nHosts;
    *pLen = n;
    return Success;
}

/* Check for valid address family and length, and return address length. */

/*ARGSUSED*/
static int
CheckAddr (
    int			family,
    const void *	pAddr,
    unsigned		length)
{
    int	len;

    switch (family)
    {
#if defined(TCPCONN) || defined(STREAMSCONN)
      case FamilyInternet:
	if (length == sizeof (struct in_addr))
	    len = length;
	else
	    len = -1;
        break;
#if defined(IPv6) && defined(AF_INET6)
      case FamilyInternet6:
	if (length == sizeof (struct in6_addr))
	    len = length;
	else
	    len = -1;
        break;
#endif
#endif 
      case FamilyServerInterpreted:
	len = siCheckAddr(pAddr, length);
	break;
      default:
        len = -1;
    }
    return len;
}

/* Check if a host is not in the access control list. 
 * Returns 1 if host is invalid, 0 if we've found it. */

int
InvalidHost (
    register struct sockaddr	*saddr,
    int				len,
    ClientPtr			client)
{
    int 			family;
    pointer			addr;
    register HOST 		*selfhost, *host;

    if (!AccessEnabled)   /* just let them in */
        return 0;
    family = ConvertAddr (saddr, &len, (pointer *)&addr);
    if (family == -1)
        return 1;
    if (family == FamilyLocal)
    {
	if (!LocalHostEnabled)
 	{
	    /*
	     * check to see if any local address is enabled.  This 
	     * implicitly enables local connections.
	     */
	    for (selfhost = selfhosts; selfhost; selfhost=selfhost->next)
 	    {
		for (host = validhosts; host; host=host->next)
		{
		    if (addrEqual (selfhost->family, selfhost->addr,
				   selfhost->len, host))
			return 0;
		}
	    }
	} else
	    return 0;
    }
    for (host = validhosts; host; host = host->next)
    {
	if (host->family == FamilyServerInterpreted) {
	    if (siAddrMatch (family, addr, len, host, client)) {
		return 0;
	    }
	} else {
	    if (addrEqual (family, addr, len, host))
		return 0;
	}

    }
    return 1;
}

static int
ConvertAddr (
    register struct sockaddr	*saddr,
    int				*len,
    pointer			*addr)
{
    if (*len == 0)
        return FamilyLocal;
    switch (saddr->sa_family)
    {
    case AF_UNSPEC:
#if defined(UNIXCONN) || defined(LOCALCONN)
    case AF_UNIX:
#endif
        return FamilyLocal;
#if defined(TCPCONN) || defined(STREAMSCONN)
    case AF_INET:
#ifdef WIN32
        if (16777343 == *(long*)&((struct sockaddr_in *) saddr)->sin_addr)
            return FamilyLocal;
#endif
        *len = sizeof (struct in_addr);
        *addr = (pointer) &(((struct sockaddr_in *) saddr)->sin_addr);
        return FamilyInternet;
#if defined(IPv6) && defined(AF_INET6)
    case AF_INET6: 
    {
	struct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *) saddr;
	if (IN6_IS_ADDR_V4MAPPED(&(saddr6->sin6_addr))) {
	    *len = sizeof (struct in_addr);
	    *addr = (pointer) &(saddr6->sin6_addr.s6_addr[12]);
	    return FamilyInternet;
	} else {
	    *len = sizeof (struct in6_addr);
	    *addr = (pointer) &(saddr6->sin6_addr);
	    return FamilyInternet6;
	}
    }
#endif
#endif
    default:
        return -1;
    }
}

int
ChangeAccessControl(
    ClientPtr client,
    int fEnabled)
{
    int rc = AuthorizedClient(client);
    if (rc != Success)
	return rc;
    AccessEnabled = fEnabled;
    return Success;
}

/* returns FALSE if xhost + in effect, else TRUE */
int
GetAccessControl(void)
{
    return AccessEnabled;
}

/*****************************************************************************
 * FamilyServerInterpreted host entry implementation
 *
 * Supports an extensible system of host types which the server can interpret
 * See the IPv6 extensions to the X11 protocol spec for the definition.
 *
 * Currently supported schemes:
 *
 * hostname	- hostname as defined in IETF RFC 2396
 * ipv6		- IPv6 literal address as defined in IETF RFC's 3513 and <TBD>
 *
 * See xc/doc/specs/SIAddresses for formal definitions of each type.
 */

/* These definitions and the siTypeAdd function could be exported in the 
 * future to enable loading additional host types, but that was not done for
 * the initial implementation.
 */
typedef Bool (*siAddrMatchFunc)(int family, pointer addr, int len, 
  const char *siAddr, int siAddrlen, ClientPtr client, void *siTypePriv);
typedef int  (*siCheckAddrFunc)(const char *addrString, int length, 
  void *siTypePriv);

struct siType {
    struct siType *	next;
    const char *	typeName;
    siAddrMatchFunc	addrMatch;
    siCheckAddrFunc	checkAddr;
    void *		typePriv;	/* Private data for type routines */
};

static struct siType *siTypeList;

static int
siTypeAdd(const char *typeName, siAddrMatchFunc addrMatch,
  siCheckAddrFunc checkAddr, void *typePriv)
{
    struct siType *s, *p;

    if ((typeName == NULL) || (addrMatch == NULL) || (checkAddr == NULL))
	return BadValue;

    for (s = siTypeList, p = NULL; s != NULL ; p = s, s = s->next) {
	if (strcmp(typeName, s->typeName) == 0) {
	    s->addrMatch = addrMatch;
	    s->checkAddr = checkAddr;
	    s->typePriv = typePriv;
	    return Success;
	}
    }

    s = malloc(sizeof(struct siType));
    if (s == NULL)
	return BadAlloc;

    if (p == NULL)
	siTypeList = s;
    else
	p->next = s;

    s->next = NULL;
    s->typeName = typeName;
    s->addrMatch = addrMatch;
    s->checkAddr = checkAddr;
    s->typePriv = typePriv;
    return Success;
}

/* Checks to see if a host matches a server-interpreted host entry */
static Bool 
siAddrMatch(int family, pointer addr, int len, HOST *host, ClientPtr client)
{
    Bool matches = FALSE;
    struct siType *s;
    const char *valueString;
    int addrlen;

    valueString = (const char *) memchr(host->addr, '\0', host->len);
    if (valueString != NULL) {
	for (s = siTypeList; s != NULL ; s = s->next) {
	    if (strcmp((char *) host->addr, s->typeName) == 0) {
		addrlen = host->len - (strlen((char *)host->addr) + 1);
		matches = s->addrMatch(family, addr, len, 
		  valueString + 1, addrlen, client, s->typePriv);
		break;
	    }
	}
#ifdef FAMILY_SI_DEBUG
	ErrorF(
	    "Xserver: siAddrMatch(): type = %s, value = %*.*s -- %s\n",
	      host->addr, addrlen, addrlen, valueString + 1,
	      (matches) ? "accepted" : "rejected");
#endif
    }
    return matches;
}

static int
siCheckAddr(const char *addrString, int length)
{
    const char *valueString;
    int addrlen, typelen;
    int len = -1;
    struct siType *s;

    /* Make sure there is a \0 byte inside the specified length
       to separate the address type from the address value. */
    valueString = (const char *) memchr(addrString, '\0', length);
    if (valueString != NULL) {
	/* Make sure the first string is a recognized address type,
	 * and the second string is a valid address of that type. 
	 */
	typelen = strlen(addrString) + 1;
	addrlen = length - typelen;

	for (s = siTypeList; s != NULL ; s = s->next) {
	    if (strcmp(addrString, s->typeName) == 0) {
		len = s->checkAddr(valueString + 1, addrlen, s->typePriv);
		if (len >= 0) {
		    len += typelen;
		}
		break;
	    }
	}
#ifdef FAMILY_SI_DEBUG
	{
	    const char *resultMsg;

	    if (s == NULL) {
		resultMsg = "type not registered";
	    } else {
		if (len == -1) 
		    resultMsg = "rejected";
		else
		    resultMsg = "accepted";
	    }

	    ErrorF("Xserver: siCheckAddr(): type = %s, value = %*.*s, len = %d -- %s\n",
	      addrString, addrlen, addrlen, valueString + 1, len, resultMsg);
	}
#endif
    }
    return len;
}


/***
 * Hostname server-interpreted host type
 *
 * Stored as hostname string, explicitly defined to be resolved ONLY
 * at access check time, to allow for hosts with dynamic addresses
 * but static hostnames, such as found in some DHCP & mobile setups.
 *
 * Hostname must conform to IETF RFC 2396 sec. 3.2.2, which defines it as:
 * 	hostname     = *( domainlabel "." ) toplabel [ "." ]
 *	domainlabel  = alphanum | alphanum *( alphanum | "-" ) alphanum
 *	toplabel     = alpha | alpha *( alphanum | "-" ) alphanum
 */

#ifdef NI_MAXHOST
# define SI_HOSTNAME_MAXLEN NI_MAXHOST
#else
# ifdef MAXHOSTNAMELEN
#  define SI_HOSTNAME_MAXLEN MAXHOSTNAMELEN
# else
#  define SI_HOSTNAME_MAXLEN 256
# endif
#endif

static Bool 
siHostnameAddrMatch(int family, pointer addr, int len,
  const char *siAddr, int siAddrLen, ClientPtr client, void *typePriv)
{
    Bool res = FALSE;

/* Currently only supports checking against IPv4 & IPv6 connections, but 
 * support for other address families, such as DECnet, could be added if 
 * desired.
 */
#if defined(IPv6) && defined(AF_INET6)
    if ((family == FamilyInternet) || (family == FamilyInternet6)) {
	char hostname[SI_HOSTNAME_MAXLEN];
	struct addrinfo *addresses;
	struct addrinfo *a;
	int f, hostaddrlen;
	pointer hostaddr;

	if (siAddrLen >= sizeof(hostname)) 
	    return FALSE;

	strncpy(hostname, siAddr, siAddrLen);
	hostname[siAddrLen] = '\0';

	if (getaddrinfo(hostname, NULL, NULL, &addresses) == 0) {
	    for (a = addresses ; a != NULL ; a = a->ai_next) {
		hostaddrlen = a->ai_addrlen;
		f = ConvertAddr(a->ai_addr,&hostaddrlen,&hostaddr);
		if ((f == family) && (len == hostaddrlen) &&
		  (acmp (addr, hostaddr, len) == 0) ) {
		    res = TRUE;
		    break;
		}
	    }
	    freeaddrinfo(addresses);
	}
    }
#else /* IPv6 not supported, use gethostbyname instead for IPv4 */
    if (family == FamilyInternet) {
	register struct hostent *hp;
#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
	_Xgethostbynameparams hparams;
#endif
	char hostname[SI_HOSTNAME_MAXLEN];
	int f, hostaddrlen;
	pointer hostaddr;
	const char **addrlist;

	if (siAddrLen >= sizeof(hostname)) 
	    return FALSE;

	strncpy(hostname, siAddr, siAddrLen);
	hostname[siAddrLen] = '\0';

	if ((hp = _XGethostbyname(hostname, hparams)) != NULL) {
#ifdef h_addr				/* new 4.3bsd version of gethostent */
	    /* iterate over the addresses */
	    for (addrlist = hp->h_addr_list; *addrlist; addrlist++)
#else
	    addrlist = &hp->h_addr;
#endif
	    {
		struct  sockaddr_in  sin;

    		sin.sin_family = hp->h_addrtype;
		acopy ( *addrlist, &(sin.sin_addr), hp->h_length);
		hostaddrlen = sizeof(sin);
    		f = ConvertAddr ((struct sockaddr *)&sin, 
		  &hostaddrlen, &hostaddr);
		if ((f == family) && (len == hostaddrlen) &&
		  (acmp (addr, hostaddr, len) == 0) ) {
		    res = TRUE;
		    break;
		}
    	    }
        }
    }
#endif
    return res;
}


static int
siHostnameCheckAddr(const char *valueString, int length, void *typePriv)
{
    /* Check conformance of hostname to RFC 2396 sec. 3.2.2 definition.
     * We do not use ctype functions here to avoid locale-specific
     * character sets.  Hostnames must be pure ASCII.  
     */
    int len = length;
    int i;
    Bool dotAllowed = FALSE;
    Bool dashAllowed = FALSE;
		    
    if ((length <= 0) || (length >= SI_HOSTNAME_MAXLEN)) {
	len = -1;
    } else {
	for (i = 0; i < length; i++) {
	    char c = valueString[i];

	    if (c == 0x2E) { /* '.' */
		if (dotAllowed == FALSE) {
		    len = -1;
		    break;
		} else {
		    dotAllowed = FALSE;
		    dashAllowed = FALSE;
		}
	    } else if (c == 0x2D) { /* '-' */
		if (dashAllowed == FALSE) {
		    len = -1;
		    break;
		} else {
		    dotAllowed = FALSE;
		}
	    } else if (((c >= 0x30) && (c <= 0x3A)) /* 0-9 */ ||
		       ((c >= 0x61) && (c <= 0x7A)) /* a-z */ ||
		       ((c >= 0x41) && (c <= 0x5A)) /* A-Z */) {
		dotAllowed = TRUE;
		dashAllowed = TRUE;
	    } else { /* Invalid character */
		len = -1;
		break;
	    }
	}
    }
    return len;
}

#if defined(IPv6) && defined(AF_INET6)
/***
 * "ipv6" server interpreted type
 *
 * Currently supports only IPv6 literal address as specified in IETF RFC 3513
 *
 * Once draft-ietf-ipv6-scoping-arch-00.txt becomes an RFC, support will be 
 * added for the scoped address format it specifies.
 */

/* Maximum length of an IPv6 address string - increase when adding support 
 * for scoped address qualifiers.  Includes room for trailing NUL byte. 
 */
#define SI_IPv6_MAXLEN INET6_ADDRSTRLEN

static Bool 
siIPv6AddrMatch(int family, pointer addr, int len,
  const char *siAddr, int siAddrlen, ClientPtr client, void *typePriv)
{
    struct in6_addr addr6;
    char addrbuf[SI_IPv6_MAXLEN];

    if ((family != FamilyInternet6) || (len != sizeof(addr6)))
	return FALSE;

    memcpy(addrbuf, siAddr, siAddrlen);
    addrbuf[siAddrlen] = '\0';

    if (inet_pton(AF_INET6, addrbuf, &addr6) != 1) {
	perror("inet_pton");
	return FALSE;
    }

    if (memcmp(addr, &addr6, len) == 0) {
	return TRUE;
    } else {
	return FALSE;
    }
}

static int
siIPv6CheckAddr(const char *addrString, int length, void *typePriv)
{
    int len;

    /* Minimum length is 3 (smallest legal address is "::1") */
    if (length < 3) {
	/* Address is too short! */
	len = -1;
    } else if (length >= SI_IPv6_MAXLEN) {
	/* Address is too long! */
	len = -1;
    } else {
	/* Assume inet_pton is sufficient validation */
	struct in6_addr addr6;
	char addrbuf[SI_IPv6_MAXLEN];

	memcpy(addrbuf, addrString, length);
	addrbuf[length] = '\0';

	if (inet_pton(AF_INET6, addrbuf, &addr6) != 1) {
	    perror("inet_pton");
	    len = -1;
	} else {
	    len = length;
	}
    }
    return len;
}
#endif /* IPv6 */

#if !defined(NO_LOCAL_CLIENT_CRED)
/***
 * "localuser" & "localgroup" server interpreted types
 *
 * Allows local connections from a given local user or group
 */

#include <pwd.h>
#include <grp.h>

#define LOCAL_USER 1
#define LOCAL_GROUP 2

typedef struct {
    int credType;
} siLocalCredPrivRec, *siLocalCredPrivPtr;

static siLocalCredPrivRec siLocalUserPriv = { LOCAL_USER };
static siLocalCredPrivRec siLocalGroupPriv = { LOCAL_GROUP };

static Bool
siLocalCredGetId(const char *addr, int len, siLocalCredPrivPtr lcPriv, int *id)
{
    Bool parsedOK = FALSE;
    char *addrbuf = malloc(len + 1);

    if (addrbuf == NULL) {
	return FALSE;
    }

    memcpy(addrbuf, addr, len);
    addrbuf[len] = '\0';

    if (addr[0] == '#') { /* numeric id */
	char *cp;
	errno = 0;
	*id = strtol(addrbuf + 1, &cp, 0);
	if ((errno == 0) && (cp != (addrbuf+1))) {
	    parsedOK = TRUE;
	}
    } else { /* non-numeric name */
	if (lcPriv->credType == LOCAL_USER) {
	    struct passwd *pw = getpwnam(addrbuf);

	    if (pw != NULL) {
		*id = (int) pw->pw_uid;
		parsedOK = TRUE;
	    }
	} else { /* group */
	    struct group *gr = getgrnam(addrbuf);

	    if (gr != NULL) {
		*id = (int) gr->gr_gid;
		parsedOK = TRUE;
	    }
	}
    }

    free(addrbuf);
    return parsedOK;
}

static Bool 
siLocalCredAddrMatch(int family, pointer addr, int len,
  const char *siAddr, int siAddrlen, ClientPtr client, void *typePriv)
{
    int siAddrId;
    LocalClientCredRec *lcc;
    siLocalCredPrivPtr lcPriv = (siLocalCredPrivPtr) typePriv;

    if (GetLocalClientCreds(client, &lcc) == -1) {
	return FALSE;
    }

#ifdef HAVE_GETZONEID /* Ensure process is in the same zone */
    if ((lcc->fieldsSet & LCC_ZID_SET) && (lcc->zoneid != getzoneid())) {
	FreeLocalClientCreds(lcc);
	return FALSE;
    }
#endif

    if (siLocalCredGetId(siAddr, siAddrlen, lcPriv, &siAddrId) == FALSE) {
	FreeLocalClientCreds(lcc);
	return FALSE;
    }

    if (lcPriv->credType == LOCAL_USER) {
	if ((lcc->fieldsSet & LCC_UID_SET) && (lcc->euid == siAddrId)) {
	    FreeLocalClientCreds(lcc);
	    return TRUE;
	}
    } else {
	if ((lcc->fieldsSet & LCC_GID_SET) && (lcc->egid == siAddrId)) {
	    FreeLocalClientCreds(lcc);
	    return TRUE;
	}
	if (lcc->pSuppGids != NULL) {
	    int i;

	    for (i = 0 ; i < lcc->nSuppGids; i++) {
		if (lcc->pSuppGids[i] == siAddrId) {
		    FreeLocalClientCreds(lcc);
		    return TRUE;
		}
	    }
	}
    }
    FreeLocalClientCreds(lcc);
    return FALSE;
}

static int
siLocalCredCheckAddr(const char *addrString, int length, void *typePriv)
{
    int len = length;
    int id;

    if (siLocalCredGetId(addrString, length, 
	(siLocalCredPrivPtr)typePriv, &id) == FALSE) {
	len = -1;
    }
    return len;
}
#endif /* localuser */

static void
siTypesInitialize(void)
{
    siTypeAdd("hostname", siHostnameAddrMatch, siHostnameCheckAddr, NULL);
#if defined(IPv6) && defined(AF_INET6)
    siTypeAdd("ipv6", siIPv6AddrMatch, siIPv6CheckAddr, NULL);
#endif
#if !defined(NO_LOCAL_CLIENT_CRED)
    siTypeAdd("localuser", siLocalCredAddrMatch, siLocalCredCheckAddr, 
      &siLocalUserPriv);
    siTypeAdd("localgroup", siLocalCredAddrMatch, siLocalCredCheckAddr, 
      &siLocalGroupPriv);
#endif
}
/*

Copyright 1988, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*
 * authorization hooks for the server
 * Author:  Keith Packard, MIT X Consortium
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

# include   <X11/X.h>
# include   <X11/Xauth.h>
# include   "misc.h"
# include   "osdep.h"
# include   "dixstruct.h"
# include   <sys/types.h>
# include   <sys/stat.h>
#ifdef WIN32
#include    <X11/Xw32defs.h>
#endif

struct protocol {
    unsigned short   name_length;
    char    *name;
    AuthAddCFunc	Add;	/* new authorization data */
    AuthCheckFunc	Check;	/* verify client authorization data */
    AuthRstCFunc	Reset;	/* delete all authorization data entries */
    AuthToIDFunc	ToID;	/* convert cookie to ID */
    AuthFromIDFunc	FromID;	/* convert ID to cookie */
    AuthRemCFunc	Remove;	/* remove a specific cookie */
#ifdef XCSECURITY
    AuthGenCFunc	Generate;
#endif
};

static struct protocol   protocols[] = {
{   (unsigned short) 18,    "MIT-MAGIC-COOKIE-1",
		MitAddCookie,	MitCheckCookie,	MitResetCookie,
		MitToID,	MitFromID,	MitRemoveCookie,
#ifdef XCSECURITY
		MitGenerateCookie
#endif
},
#ifdef HASXDMAUTH
{   (unsigned short) 19,    "XDM-AUTHORIZATION-1",
		XdmAddCookie,	XdmCheckCookie,	XdmResetCookie,
		XdmToID,	XdmFromID,	XdmRemoveCookie,
#ifdef XCSECURITY
		NULL
#endif
},
#endif
#ifdef SECURE_RPC
{   (unsigned short) 9,    "SUN-DES-1",
		SecureRPCAdd,	SecureRPCCheck,	SecureRPCReset,
		SecureRPCToID,	SecureRPCFromID,SecureRPCRemove,
#ifdef XCSECURITY
		NULL
#endif
},
#endif
};

# define NUM_AUTHORIZATION  (sizeof (protocols) /\
			     sizeof (struct protocol))

/*
 * Initialize all classes of authorization by reading the
 * specified authorization file
 */

static char *authorization_file = (char *)NULL;

static Bool ShouldLoadAuth = TRUE;

void
InitAuthorization (char *file_name)
{
    authorization_file = file_name;
}

static int
LoadAuthorization (void)
{
    FILE    *f;
    Xauth   *auth;
    int	    i;
    int	    count = 0;

    ShouldLoadAuth = FALSE;
    if (!authorization_file)
	return 0;

    f = Fopen (authorization_file, "r");
    if (!f)
	return -1;

    while ((auth = XauReadAuth (f)) != 0) {
	for (i = 0; i < NUM_AUTHORIZATION; i++) {
	    if (protocols[i].name_length == auth->name_length &&
		memcmp (protocols[i].name, auth->name, (int) auth->name_length) == 0 &&
		protocols[i].Add)
	    {
		++count;
		(*protocols[i].Add) (auth->data_length, auth->data,
					 FakeClientID(0));
	    }
	}
	XauDisposeAuth (auth);
    }

    Fclose (f);
    return count;
}

#ifdef XDMCP
/*
 * XdmcpInit calls this function to discover all authorization
 * schemes supported by the display
 */
void
RegisterAuthorizations (void)
{
    int	    i;

    for (i = 0; i < NUM_AUTHORIZATION; i++)
	XdmcpRegisterAuthorization (protocols[i].name,
				    (int)protocols[i].name_length);
}
#endif

XID
CheckAuthorization (
    unsigned int name_length,
    const char	*name,
    unsigned int data_length,
    const char	*data,
    ClientPtr client,
    char	**reason)	/* failure message.  NULL for default msg */
{
    int	i;
    struct stat buf;
    static time_t lastmod = 0;
    static Bool loaded = FALSE;

    if (!authorization_file || stat(authorization_file, &buf))
    {
	if (lastmod != 0) {
	    lastmod = 0;
	    ShouldLoadAuth = TRUE;	/* stat lost, so force reload */
	}
    }
    else if (buf.st_mtime > lastmod)
    {
	lastmod = buf.st_mtime;
	ShouldLoadAuth = TRUE;
    }
    if (ShouldLoadAuth)
    {
	int loadauth = LoadAuthorization();

	/*
	 * If the authorization file has at least one entry for this server,
	 * disable local host access. (loadauth > 0)
	 *
	 * If there are zero entries (either initially or when the
	 * authorization file is later reloaded), or if a valid
	 * authorization file was never loaded, enable local host access.
	 * (loadauth == 0 || !loaded)
	 *
	 * If the authorization file was loaded initially (with valid
	 * entries for this server), and reloading it later fails, don't
	 * change anything. (loadauth == -1 && loaded)
	 */
	
	if (loadauth > 0)
	{
	    DisableLocalHost(); /* got at least one */
	    loaded = TRUE;
	}
	else if (loadauth == 0 || !loaded)
	    EnableLocalHost ();
    }
    if (name_length) {
	for (i = 0; i < NUM_AUTHORIZATION; i++) {
	    if (protocols[i].name_length == name_length &&
		memcmp (protocols[i].name, name, (int) name_length) == 0)
	    {
		return (*protocols[i].Check) (data_length, data, client, reason);
	    }
	    *reason = "Protocol not supported by server\n";
	}
    } else *reason = "No protocol specified\n";
    return (XID) ~0L;
}

void
ResetAuthorization (void)
{
    int	i;

    for (i = 0; i < NUM_AUTHORIZATION; i++)
	if (protocols[i].Reset)
	    (*protocols[i].Reset)();
    ShouldLoadAuth = TRUE;
}

int
AuthorizationFromID (
	XID 		id,
	unsigned short	*name_lenp,
	char		**namep,
	unsigned short	*data_lenp,
	char		**datap)
{
    int	i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
	if (protocols[i].FromID &&
	    (*protocols[i].FromID) (id, data_lenp, datap)) {
	    *name_lenp = protocols[i].name_length;
	    *namep = protocols[i].name;
	    return 1;
	}
    }
    return 0;
}

int
RemoveAuthorization (
	unsigned short	name_length,
	const char	*name,
	unsigned short	data_length,
	const char	*data)
{
    int	i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
    	if (protocols[i].name_length == name_length &&
	    memcmp (protocols[i].name, name, (int) name_length) == 0 &&
	    protocols[i].Remove)
    	{
	    return (*protocols[i].Remove) (data_length, data);
    	}
    }
    return 0;
}

int
AddAuthorization (unsigned name_length, const char *name,
		  unsigned data_length, char *data)
{
    int	i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
    	if (protocols[i].name_length == name_length &&
	    memcmp (protocols[i].name, name, (int) name_length) == 0 &&
	    protocols[i].Add)
    	{
	    return (*protocols[i].Add) (data_length, data, FakeClientID(0));
    	}
    }
    return 0;
}

#ifdef XCSECURITY

XID
GenerateAuthorization(
	unsigned name_length,
	const char	*name,
	unsigned data_length,
	const char	*data,
	unsigned *data_length_return,
	char	**data_return)
{
    int	i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
    	if (protocols[i].name_length == name_length &&
	    memcmp (protocols[i].name, name, (int) name_length) == 0 &&
	    protocols[i].Generate)
    	{
	    return (*protocols[i].Generate) (data_length, data,
			FakeClientID(0), data_length_return, data_return);
    	}
    }
    return -1;
}

void
GenerateRandomData (int len, char *buf)
{
    int fd;

    fd = open("/dev/urandom", O_RDONLY);
    read(fd, buf, len);
    close(fd);
}

#endif /* XCSECURITY */
/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "os.h"
#include "misc.h"

#ifdef HAVE_BACKTRACE
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <dlfcn.h>
#include <execinfo.h>

void xorg_backtrace(void)
{
    void *array[64];
    const char *mod;
    int size, i;
    Dl_info info;
    ErrorF("\nBacktrace:\n");
    size = backtrace(array, 64);
    for (i = 0; i < size; i++) {
	dladdr(array[i], &info);
	mod = (info.dli_fname && *info.dli_fname) ? info.dli_fname : "(vdso)";
	if (info.dli_saddr)
	    ErrorF("%d: %s (%s+0x%lx) [%p]\n", i, mod,
		   info.dli_sname, (long unsigned int)((char *) array[i] - (char *) info.dli_saddr), array[i]);
	else
	    ErrorF("%d: %s (%p+0x%lx) [%p]\n", i, mod,
		   info.dli_fbase, (long unsigned int)((char *) array[i] - (char *) info.dli_fbase), array[i]);
    }
}

#else /* not glibc or glibc < 2.1 */

# if defined(sun) && defined(__SVR4)
#  define HAVE_PSTACK
# endif

# if defined(HAVE_WALKCONTEXT) /* Solaris 9 & later */

# include <ucontext.h>
# include <signal.h>
# include <dlfcn.h>
# include <sys/elf.h>

#ifdef _LP64
# define ElfSym Elf64_Sym
#else
# define ElfSym Elf32_Sym
#endif

/* Called for each frame on the stack to print it's contents */
static int xorg_backtrace_frame(uintptr_t pc, int signo, void *arg)
{
    Dl_info dlinfo;
    ElfSym *dlsym;
    char header[32];
    int depth = *((int *) arg);

    if (signo) {
	char signame[SIG2STR_MAX];

	if (sig2str(signo, signame) != 0) {
	    strcpy(signame, "unknown");
	}

	ErrorF("** Signal %d (%s)\n", signo, signame);
    }

    snprintf(header, sizeof(header), "%d: 0x%lx", depth, pc);
    *((int *) arg) = depth + 1;

    /* Ask system dynamic loader for info on the address */
    if (dladdr1((void *) pc, &dlinfo, (void **) &dlsym, RTLD_DL_SYMENT)) {
	unsigned long offset = pc - (uintptr_t) dlinfo.dli_saddr;
	const char *symname;
	
	if (offset < dlsym->st_size) { /* inside a function */
	    symname = dlinfo.dli_sname;
	} else { /* found which file it was in, but not which function */
	    symname = "<section start>";
	    offset = pc - (uintptr_t)dlinfo.dli_fbase;
	}
	ErrorF("%s: %s:%s+0x%lx\n", header, dlinfo.dli_fname,
	       symname, offset);

    } else {
	/* Couldn't find symbol info from system dynamic loader, should
	 * probably poke elfloader here, but haven't written that code yet,
	 * so we just print the pc.
	 */
	ErrorF("%s\n", header);
    }

    return 0;
}
# endif /* HAVE_WALKCONTEXT */

# ifdef HAVE_PSTACK
static int xorg_backtrace_pstack(void) {
    pid_t kidpid;
    int pipefd[2];

    if (pipe(pipefd) != 0) {
	return -1;
    }

    kidpid = fork1();

    if (kidpid == -1) {
	/* ERROR */
	return -1;
    } else if (kidpid == 0) {
	/* CHILD */
	char parent[16];
	
	seteuid(0);
	close(STDIN_FILENO);
	close(STDOUT_FILENO);
	dup2(pipefd[1],STDOUT_FILENO);
	closefrom(STDERR_FILENO);

	snprintf(parent, sizeof(parent), "%d", getppid());
	execle("/usr/bin/pstack", "pstack", parent, NULL);
	exit(1);
    } else {
	/* PARENT */
	char btline[256];
	int kidstat;
	int bytesread;
	int done = 0;
	
	close(pipefd[1]);

	while (!done) {
	    bytesread = read(pipefd[0], btline, sizeof(btline) - 1);

	    if (bytesread > 0) {
		btline[bytesread] = 0;
		ErrorF("%s", btline);
	    }
	    else if ((bytesread < 0) ||
		     ((errno != EINTR) && (errno != EAGAIN)))
		done = 1;
	}
	close(pipefd[0]);
	waitpid(kidpid, &kidstat, 0);
	if (kidstat != 0)
	    return -1;
    }
    return 0;
}
# endif /* HAVE_PSTACK */


# if defined(HAVE_PSTACK) || defined(HAVE_WALKCONTEXT)

void xorg_backtrace(void) {

    ErrorF("\nBacktrace:\n");

#  ifdef HAVE_PSTACK
/* First try fork/exec of pstack - otherwise fall back to walkcontext
   pstack is preferred since it can print names of non-exported functions */

    if (xorg_backtrace_pstack() < 0)
#  endif	
    {
#  ifdef HAVE_WALKCONTEXT
	ucontext_t u;
	int depth = 1;
	
	if (getcontext(&u) == 0)
	    walkcontext(&u, xorg_backtrace_frame, &depth);
	else
#  endif
	    Error("Failed to get backtrace info");
    }
    ErrorF("\n");	
}

# else

/* Default fallback if we can't find any way to get a backtrace */
void xorg_backtrace(void) { return; }

# endif
#endif
/*
 * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies). All
 * rights reserved.
 * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @file
 *
 * This file contains functionality for identifying clients by various
 * means. The primary purpose of identification is to simply aid in
 * finding out which clients are using X server and how they are using
 * it. For example, it's often necessary to monitor what requests
 * clients are executing (to spot bad behaviour) and how they are
 * allocating resources in X server (to spot excessive resource
 * usage).
 *
 * This framework automatically allocates information, that can be
 * used for client identification, when a client connects to the
 * server. The information is freed when the client disconnects. The
 * allocated information is just a collection of various IDs, such as
 * PID and process name for local clients, that are likely to be
 * useful in analyzing X server usage.
 *
 * Users of the framework can query ID information about clients at
 * any time. To avoid repeated polling of IDs the users can also
 * subscribe for notifications about the availability of ID
 * information. IDs have been allocated before ClientStateCallback is
 * called with ClientStateInitial state. Similarly the IDs will be
 * released after ClientStateCallback is called with ClientStateGone
 * state.
 *
 * Author: Rami Ylimäki <rami.ylimaki@vincit.fi>
 */

#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "client.h"
#include "os.h"
#include "dixstruct.h"

/**
 * Try to determine a PID for a client from its connection
 * information. This should be called only once when new client has
 * connected, use GetClientPid to determine the PID at other times.
 *
 * @param[in] client Connection linked to some process.
 *
 * @return PID of the client. Error (-1) if PID can't be determined
 *         for the client.
 *
 * @see GetClientPid
 */
pid_t DetermineClientPid(struct _Client *client)
{
    LocalClientCredRec *lcc = NULL;
    pid_t pid = -1;

    if (client == NullClient)
        return pid;

    if (client == serverClient)
        return getpid();

    if (GetLocalClientCreds(client, &lcc) != -1)
    {
        if (lcc->fieldsSet & LCC_PID_SET)
            pid = lcc->pid;
        FreeLocalClientCreds(lcc);
    }

    return pid;
}

/**
 * Try to determine a command line string for a client based on its
 * PID. Note that mapping PID to a command hasn't been implemented for
 * some operating systems. This should be called only once when a new
 * client has connected, use GetClientCmdName/Args to determine the
 * string at other times.
 *
 * @param[in]  pid     Process ID of a client.

 * @param[out] cmdname Client process name without arguments. You must
 *                     release this by calling free. On error NULL is
 *                     returned. Pass NULL if you aren't interested in
 *                     this value.
 * @param[out] cmdargs Arguments to client process. Useful for
 *                     identifying a client that is executed from a
 *                     launcher program. You must release this by
 *                     calling free. On error NULL is returned. Pass
 *                     NULL if you aren't interested in this value.
 *
 * @see GetClientCmdName/Args
 */
void DetermineClientCmd(pid_t pid, const char **cmdname, const char **cmdargs)
{
    char path[PATH_MAX + 1];
    int totsize = 0;
    int cmdsize = 0;
    int argsize = 0;
    int fd = 0;

    if (cmdname)
        *cmdname = NULL;
    if (cmdargs)
        *cmdargs = NULL;

    if (pid == -1)
        return;

    /* Check if /proc/pid/cmdline exists. It's not supported on all
     * operating systems. */
    if (snprintf(path, sizeof(path), "/proc/%d/cmdline", pid) < 0)
        return;
    fd = open(path, O_RDONLY);
    if (fd < 0)
        return;

    /* Read the contents of /proc/pid/cmdline. It should contain the
     * process name and arguments. */
    totsize = read(fd, path, sizeof(path));
    close(fd);
    if (totsize <= 0)
        return;
    path[totsize - 1] = '\0';

    /* Contruct the process name without arguments. */
    cmdsize = strlen(path) + 1;
    if (cmdname)
    {
        char *name = malloc(cmdsize);
        if (name)
        {
            strncpy(name, path, cmdsize);
            name[cmdsize - 1] = '\0';
            *cmdname = name;
        }
    }

    /* Construct the arguments for client process. */
    argsize = totsize - cmdsize;
    if (cmdargs && (argsize > 0))
    {
        char *args = malloc(argsize);
        if (args)
        {
            int i = 0;
            for (i = 0; i < (argsize - 1); ++i)
            {
                const char c = path[cmdsize + i];
                args[i] = (c == '\0') ? ' ' : c;
            }
            args[argsize - 1] = '\0';
            *cmdargs = args;
        }
    }
}

/**
 * Called when a new client connects. Allocates client ID information.
 *
 * @param[in] client Recently connected client.
 */
void ReserveClientIds(struct _Client *client)
{
#ifdef CLIENTIDS
    if (client == NullClient)
        return;

    assert(!client->clientIds);
    client->clientIds = calloc(1, sizeof(ClientIdRec));
    if (!client->clientIds)
        return;

    client->clientIds->pid = DetermineClientPid(client);
    if (client->clientIds->pid != -1)
        DetermineClientCmd(client->clientIds->pid, &client->clientIds->cmdname, &client->clientIds->cmdargs);

    DebugF("client(%lx): Reserved pid(%d).\n",
           client->clientAsMask, client->clientIds->pid);
    DebugF("client(%lx): Reserved cmdname(%s) and cmdargs(%s).\n",
           client->clientAsMask,
           client->clientIds->cmdname ? client->clientIds->cmdname : "NULL",
           client->clientIds->cmdargs ? client->clientIds->cmdargs : "NULL");
#endif /* CLIENTIDS */
}

/**
 * Called when an existing client disconnects. Frees client ID
 * information.
 *
 * @param[in] client Recently disconnected client.
 */
void ReleaseClientIds(struct _Client *client)
{
#ifdef CLIENTIDS
    if (client == NullClient)
        return;

    if (!client->clientIds)
        return;

    DebugF("client(%lx): Released pid(%d).\n",
           client->clientAsMask, client->clientIds->pid);
    DebugF("client(%lx): Released cmdline(%s) and cmdargs(%s).\n",
           client->clientAsMask,
           client->clientIds->cmdname ? client->clientIds->cmdname : "NULL",
           client->clientIds->cmdargs ? client->clientIds->cmdargs : "NULL");

    free((void *) client->clientIds->cmdname); /* const char * */
    free((void *) client->clientIds->cmdargs); /* const char * */
    free(client->clientIds);
    client->clientIds = NULL;
#endif /* CLIENTIDS */
}

/**
 * Get cached PID of a client.
 *
 * param[in] client Client whose PID has been already cached.
 *
 * @return Cached client PID. Error (-1) if called:
 *         - before ClientStateInitial client state notification
 *         - after ClientStateGone client state notification
 *         - for remote clients
 *
 * @see DetermineClientPid
 */
pid_t GetClientPid(struct _Client *client)
{
    if (client == NullClient)
        return -1;

    if (!client->clientIds)
        return -1;

    return client->clientIds->pid;
}

/**
 * Get cached command name string of a client.
 *
 * param[in] client Client whose command line string has been already
 *                  cached.
 *
 * @return Cached client command name. Error (NULL) if called:
 *         - before ClientStateInitial client state notification
 *         - after ClientStateGone client state notification
 *         - for remote clients
 *         - on OS that doesn't support mapping of PID to command line
 *
 * @see DetermineClientCmd
 */
const char *GetClientCmdName(struct _Client *client)
{
    if (client == NullClient)
        return NULL;

    if (!client->clientIds)
        return NULL;

    return client->clientIds->cmdname;
}

/**
 * Get cached command arguments string of a client.
 *
 * param[in] client Client whose command line string has been already
 *                  cached.
 *
 * @return Cached client command arguments. Error (NULL) if called:
 *         - before ClientStateInitial client state notification
 *         - after ClientStateGone client state notification
 *         - for remote clients
 *         - on OS that doesn't support mapping of PID to command line
 *
 * @see DetermineClientCmd
 */
const char *GetClientCmdArgs(struct _Client *client)
{
    if (client == NullClient)
        return NULL;

    if (!client->clientIds)
        return NULL;

    return client->clientIds->cmdargs;
}
/***********************************************************

Copyright 1987, 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
/*****************************************************************
 *  Stuff to create connections --- OS dependent
 *
 *      EstablishNewConnections, CreateWellKnownSockets, ResetWellKnownSockets,
 *      CloseDownConnection, CheckConnections, AddEnabledDevice,
 *	RemoveEnabledDevice, OnlyListToOneClient,
 *      ListenToAllClients,
 *
 *      (WaitForSomething is in its own file)
 *
 *      In this implementation, a client socket table is not kept.
 *      Instead, what would be the index into the table is just the
 *      file descriptor of the socket.  This won't work for if the
 *      socket ids aren't small nums (0 - 2^8)
 *
 *****************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef WIN32
#include <X11/Xwinsock.h>
#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#endif
#include <X11/X.h>
#include <X11/Xproto.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include <X11/Xtrans/Xtransint.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef WIN32
#include <sys/socket.h>



#if defined(TCPCONN) || defined(STREAMSCONN)
# include <netinet/in.h>
# include <arpa/inet.h>
#  ifdef apollo
#   ifndef NO_TCP_H
#    include <netinet/tcp.h>
#   endif
#  else
#   ifdef CSRG_BASED
#    include <sys/param.h>
#   endif
#   include <netinet/tcp.h>
#  endif
# include <arpa/inet.h>
#endif

#include <sys/uio.h>

#endif /* WIN32 */
#include "misc.h"		/* for typedef of pointer */
#include "osdep.h"
#include <X11/Xpoll.h>
#include "opaque.h"
#include "dixstruct.h"
#include "xace.h"

#define Pid_t pid_t


#ifdef HAS_GETPEERUCRED
# include <ucred.h>
# include <zone.h>
#endif

#ifdef XSERVER_DTRACE
# include <sys/types.h>
typedef const char *string;
# ifndef HAS_GETPEERUCRED
#  define zoneid_t int
# endif
# include "../dix/Xserver-dtrace.h"
#endif

static int lastfdesc;		/* maximum file descriptor */

fd_set WellKnownConnections;	/* Listener mask */
fd_set EnabledDevices;		/* mask for input devices that are on */
fd_set AllSockets;		/* select on this */
fd_set AllClients;		/* available clients */
fd_set LastSelectMask;		/* mask returned from last select call */
fd_set ClientsWithInput;	/* clients with FULL requests in buffer */
fd_set ClientsWriteBlocked;	/* clients who cannot receive output */
fd_set OutputPending;		/* clients with reply/event data ready to go */
int MaxClients = 0;
Bool NewOutputPending;		/* not yet attempted to write some new output */
Bool AnyClientsWriteBlocked;	/* true if some client blocked on write */

static Bool RunFromSmartParent;	/* send SIGUSR1 to parent process */
Bool RunFromSigStopParent;	/* send SIGSTOP to our own process; Upstart (or
				   equivalent) will send SIGCONT back. */
Bool PartialNetwork;	/* continue even if unable to bind all addrs */
static Pid_t ParentProcess;

static Bool debug_conns = FALSE;

fd_set IgnoredClientsWithInput;
static fd_set GrabImperviousClients;
static fd_set SavedAllClients;
static fd_set SavedAllSockets;
static fd_set SavedClientsWithInput;
int GrabInProgress = 0;

#if !defined(WIN32)
int *ConnectionTranslation = NULL;
#else
/*
 * On NT fds are not between 0 and MAXSOCKS, they are unrelated, and there is
 * not even a known maximum value, so use something quite arbitrary for now.
 * Do storage is a hash table of size 256. Collisions are handled in a linked
 * list.
 */

#undef MAXSOCKS
#define MAXSOCKS 500
#undef MAXSELECT
#define MAXSELECT 500

struct _ct_node {
    struct _ct_node *next;
    int key;
    int value;
};

struct _ct_node *ct_head[256];

void InitConnectionTranslation(void)
{
    memset(ct_head, 0, sizeof(ct_head));
}

int GetConnectionTranslation(int conn)
{
    struct _ct_node *node = ct_head[conn & 0xff];
    while (node != NULL)
    {
        if (node->key == conn)
            return node->value;
        node = node->next;
    }
    return 0;
}

void SetConnectionTranslation(int conn, int client)
{
    struct _ct_node **node = ct_head + (conn & 0xff);
    if (client == 0) /* remove entry */
    {
        while (*node != NULL)
        {
            if ((*node)->key == conn)
            {
                struct _ct_node *temp = *node;
                *node = (*node)->next;
                free(temp);
                return;
            }
            node = &((*node)->next);
        }
        return;
    } else 
    {
        while (*node != NULL)
        {
            if ((*node)->key == conn)
            {
                (*node)->value = client;
                return;
            }
            node = &((*node)->next);
        }
        *node = malloc(sizeof(struct _ct_node));
        (*node)->next = NULL;
        (*node)->key = conn;
        (*node)->value = client;
        return;
    }
}

void ClearConnectionTranslation(void)
{
    unsigned i;
    for (i = 0; i < 256; i++)
    {
        struct _ct_node *node = ct_head[i];
        while (node != NULL)
        {
            struct _ct_node *temp = node;
            node = node->next;
            free(temp);
        }
    }
}
#endif

static XtransConnInfo 	*ListenTransConns = NULL;
static int	       	*ListenTransFds = NULL;
static int		ListenTransCount;

static void ErrorConnMax(XtransConnInfo /* trans_conn */);

static XtransConnInfo
lookup_trans_conn (int fd)
{
    if (ListenTransFds)
    {
	int i;
	for (i = 0; i < ListenTransCount; i++)
	    if (ListenTransFds[i] == fd)
		return ListenTransConns[i];
    }

    return NULL;
}

/* Set MaxClients and lastfdesc, and allocate ConnectionTranslation */

void
InitConnectionLimits(void)
{
    lastfdesc = -1;

#ifndef __CYGWIN__

#if !defined(XNO_SYSCONF) && defined(_SC_OPEN_MAX)
    lastfdesc = sysconf(_SC_OPEN_MAX) - 1;
#endif

#ifdef HAS_GETDTABLESIZE
    if (lastfdesc < 0)
	lastfdesc = getdtablesize() - 1;
#endif

#ifdef _NFILE
    if (lastfdesc < 0)
	lastfdesc = _NFILE - 1;
#endif

#endif /* __CYGWIN__ */

    /* This is the fallback */
    if (lastfdesc < 0)
	lastfdesc = MAXSOCKS;

    if (lastfdesc > MAXSELECT)
	lastfdesc = MAXSELECT;

    if (lastfdesc > MAXCLIENTS)
    {
	lastfdesc = MAXCLIENTS;
	if (debug_conns)
	    ErrorF( "REACHED MAXIMUM CLIENTS LIMIT %d\n", MAXCLIENTS);
    }
    MaxClients = lastfdesc;

#ifdef DEBUG
    ErrorF("InitConnectionLimits: MaxClients = %d\n", MaxClients);
#endif

#if !defined(WIN32)
    if (!ConnectionTranslation)
        ConnectionTranslation = (int *)xnfalloc(sizeof(int)*(lastfdesc + 1));
#else
    InitConnectionTranslation();
#endif
}

/*
 * If SIGUSR1 was set to SIG_IGN when the server started, assume that either
 *
 *  a- The parent process is ignoring SIGUSR1
 *
 * or
 *
 *  b- The parent process is expecting a SIGUSR1
 *     when the server is ready to accept connections
 *
 * In the first case, the signal will be harmless, in the second case,
 * the signal will be quite useful.
 */
static void
InitParentProcess(void)
{
#if !defined(WIN32)
    OsSigHandlerPtr handler;
    handler = OsSignal (SIGUSR1, SIG_IGN);
    if ( handler == SIG_IGN)
	RunFromSmartParent = TRUE;
    OsSignal(SIGUSR1, handler);
    ParentProcess = getppid ();
#endif
}

void
NotifyParentProcess(void)
{
#if !defined(WIN32)
    if (RunFromSmartParent) {
	if (ParentProcess > 1) {
	    kill (ParentProcess, SIGUSR1);
	}
    }
    if (RunFromSigStopParent)
	raise (SIGSTOP);
#endif
}

/*****************
 * CreateWellKnownSockets
 *    At initialization, create the sockets to listen on for new clients.
 *****************/

void
CreateWellKnownSockets(void)
{
    int		i;
    int		partial;
    char 	port[20];

    FD_ZERO(&AllSockets);
    FD_ZERO(&AllClients);
    FD_ZERO(&LastSelectMask);
    FD_ZERO(&ClientsWithInput);

#if !defined(WIN32)
    for (i=0; i<MaxClients; i++) ConnectionTranslation[i] = 0;
#else
    ClearConnectionTranslation();
#endif

    FD_ZERO (&WellKnownConnections);

    sprintf (port, "%d", atoi (display));

    if ((_XSERVTransMakeAllCOTSServerListeners (port, &partial,
	&ListenTransCount, &ListenTransConns) >= 0) &&
	(ListenTransCount >= 1))
    {
	if (!PartialNetwork && partial)
	{
	    FatalError ("Failed to establish all listening sockets");
	}
	else
	{
	    ListenTransFds = malloc(ListenTransCount * sizeof (int));

	    for (i = 0; i < ListenTransCount; i++)
	    {
		int fd = _XSERVTransGetConnectionNumber (ListenTransConns[i]);
		
		ListenTransFds[i] = fd;
		FD_SET (fd, &WellKnownConnections);

		if (!_XSERVTransIsLocal (ListenTransConns[i]))
		{
		    DefineSelf (fd);
		}
	    }
	}
    }

    if (!XFD_ANYSET (&WellKnownConnections))
        FatalError ("Cannot establish any listening sockets - Make sure an X server isn't already running");
#if !defined(WIN32)
    OsSignal (SIGPIPE, SIG_IGN);
    OsSignal (SIGHUP, AutoResetServer);
#endif
    OsSignal (SIGINT, GiveUp);
    OsSignal (SIGTERM, GiveUp);
    XFD_COPYSET (&WellKnownConnections, &AllSockets);
    ResetHosts(display);

    InitParentProcess();

#ifdef XDMCP
    XdmcpInit ();
#endif
}

void
ResetWellKnownSockets (void)
{
    int i;

    ResetOsBuffers();

    for (i = 0; i < ListenTransCount; i++)
    {
	int status = _XSERVTransResetListener (ListenTransConns[i]);

	if (status != TRANS_RESET_NOOP)
	{
	    if (status == TRANS_RESET_FAILURE)
	    {
		/*
		 * ListenTransConns[i] freed by xtrans.
		 * Remove it from out list.
		 */

		FD_CLR (ListenTransFds[i], &WellKnownConnections);
		ListenTransFds[i] = ListenTransFds[ListenTransCount - 1];
		ListenTransConns[i] = ListenTransConns[ListenTransCount - 1];
		ListenTransCount -= 1;
		i -= 1;
	    }
	    else if (status == TRANS_RESET_NEW_FD)
	    {
		/*
		 * A new file descriptor was allocated (the old one was closed)
		 */

		int newfd = _XSERVTransGetConnectionNumber (ListenTransConns[i]);

		FD_CLR (ListenTransFds[i], &WellKnownConnections);
		ListenTransFds[i] = newfd;
		FD_SET(newfd, &WellKnownConnections);
	    }
	}
    }

    ResetAuthorization ();
    ResetHosts(display);
    /*
     * restart XDMCP
     */
#ifdef XDMCP
    XdmcpReset ();
#endif
}

void
CloseWellKnownConnections(void)
{
    int i;

    for (i = 0; i < ListenTransCount; i++)
	_XSERVTransClose (ListenTransConns[i]);
}

static void
AuthAudit (ClientPtr client, Bool letin, 
    struct sockaddr *saddr, int len, 
    unsigned int proto_n, char *auth_proto, int auth_id)
{
    char addr[128];
    char *out = addr;
    char client_uid_string[64];
    LocalClientCredRec *lcc;
#ifdef XSERVER_DTRACE
    pid_t client_pid = -1;
    zoneid_t client_zid = -1;
#endif

    if (!len)
        strcpy(out, "local host");
    else
	switch (saddr->sa_family)
	{
	case AF_UNSPEC:
#if defined(UNIXCONN) || defined(LOCALCONN)
	case AF_UNIX:
#endif
	    strcpy(out, "local host");
	    break;
#if defined(TCPCONN) || defined(STREAMSCONN)
	case AF_INET:
	    sprintf(out, "IP %s",
		inet_ntoa(((struct sockaddr_in *) saddr)->sin_addr));
	    break;
#if defined(IPv6) && defined(AF_INET6)
	case AF_INET6: {
	    char ipaddr[INET6_ADDRSTRLEN];
	    inet_ntop(AF_INET6, &((struct sockaddr_in6 *) saddr)->sin6_addr,
	      ipaddr, sizeof(ipaddr));
	    sprintf(out, "IP %s", ipaddr);
	}
	    break;
#endif
#endif
	default:
	    strcpy(out, "unknown address");
	}

    if (GetLocalClientCreds(client, &lcc) != -1) {
	int slen; /* length written to client_uid_string */

	strcpy(client_uid_string, " ( ");
	slen = 3;

	if (lcc->fieldsSet & LCC_UID_SET) {
	    snprintf(client_uid_string + slen,
		     sizeof(client_uid_string) - slen,
		     "uid=%ld ", (long) lcc->euid);
	    slen = strlen(client_uid_string);
	}

	if (lcc->fieldsSet & LCC_GID_SET) {
	    snprintf(client_uid_string + slen,
		     sizeof(client_uid_string) - slen,
		     "gid=%ld ", (long) lcc->egid);
	    slen = strlen(client_uid_string);
	}

	if (lcc->fieldsSet & LCC_PID_SET) {
#ifdef XSERVER_DTRACE	    
	    client_pid = lcc->pid;
#endif
	    snprintf(client_uid_string + slen,
		     sizeof(client_uid_string) - slen,
		     "pid=%ld ", (long) lcc->pid);
	    slen = strlen(client_uid_string);
	}
	
	if (lcc->fieldsSet & LCC_ZID_SET) {
#ifdef XSERVER_DTRACE
	    client_zid = lcc->zoneid;
#endif	    
	    snprintf(client_uid_string + slen,
		     sizeof(client_uid_string) - slen,
		     "zoneid=%ld ", (long) lcc->zoneid);
	    slen = strlen(client_uid_string);
	}

	snprintf(client_uid_string + slen, sizeof(client_uid_string) - slen,
		 ")");
	FreeLocalClientCreds(lcc);
    }
    else {
	client_uid_string[0] = '\0';
    }
    
#ifdef XSERVER_DTRACE
    XSERVER_CLIENT_AUTH(client->index, addr, client_pid, client_zid);
#endif
    if (auditTrailLevel > 1) {
      if (proto_n)
	AuditF("client %d %s from %s%s\n  Auth name: %.*s ID: %d\n", 
	       client->index, letin ? "connected" : "rejected", addr,
	       client_uid_string, (int)proto_n, auth_proto, auth_id);
      else 
	AuditF("client %d %s from %s%s\n", 
	       client->index, letin ? "connected" : "rejected", addr,
	       client_uid_string);

    }
}

XID
AuthorizationIDOfClient(ClientPtr client)
{
    if (client->osPrivate)
	return ((OsCommPtr)client->osPrivate)->auth_id;
    else
	return None;
}


/*****************************************************************
 * ClientAuthorized
 *
 *    Sent by the client at connection setup:
 *                typedef struct _xConnClientPrefix {
 *                   CARD8	byteOrder;
 *                   BYTE	pad;
 *                   CARD16	majorVersion, minorVersion;
 *                   CARD16	nbytesAuthProto;    
 *                   CARD16	nbytesAuthString;   
 *                 } xConnClientPrefix;
 *
 *     	It is hoped that eventually one protocol will be agreed upon.  In the
 *        mean time, a server that implements a different protocol than the
 *        client expects, or a server that only implements the host-based
 *        mechanism, will simply ignore this information.
 *
 *****************************************************************/

char *
ClientAuthorized(ClientPtr client, 
    unsigned int proto_n, char *auth_proto, 
    unsigned int string_n, char *auth_string)
{
    OsCommPtr 		priv;
    Xtransaddr		*from = NULL;
    int 		family;
    int			fromlen;
    XID	 		auth_id;
    char	 	*reason = NULL;
    XtransConnInfo	trans_conn;

    priv = (OsCommPtr)client->osPrivate;
    trans_conn = priv->trans_conn;

    /* Allow any client to connect without authorization on a launchd socket,
       because it is securely created -- this prevents a race condition on launch */
    if(trans_conn->flags & TRANS_NOXAUTH) {
        auth_id = (XID) 0L;
    } else {
        auth_id = CheckAuthorization (proto_n, auth_proto, string_n, auth_string, client, &reason);
    }

    if (auth_id == (XID) ~0L)
    {
	if (_XSERVTransGetPeerAddr(trans_conn, &family, &fromlen, &from) != -1)
	{
	    if (InvalidHost ((struct sockaddr *) from, fromlen, client))
		AuthAudit(client, FALSE, (struct sockaddr *) from,
			  fromlen, proto_n, auth_proto, auth_id);
	    else
	    {
		auth_id = (XID) 0;
#ifdef XSERVER_DTRACE
		if ((auditTrailLevel > 1) || XSERVER_CLIENT_AUTH_ENABLED())
#else
		if (auditTrailLevel > 1)
#endif
		    AuthAudit(client, TRUE,
			(struct sockaddr *) from, fromlen,
			proto_n, auth_proto, auth_id);
	    }

	    free(from);
	}

	if (auth_id == (XID) ~0L) {
	    if (reason)
		return reason;
	    else
		return "Client is not authorized to connect to Server";
	}
    }
#ifdef XSERVER_DTRACE
    else if ((auditTrailLevel > 1) || XSERVER_CLIENT_AUTH_ENABLED())
#else
    else if (auditTrailLevel > 1)
#endif
    {
	if (_XSERVTransGetPeerAddr (trans_conn,
	    &family, &fromlen, &from) != -1)
	{
	    AuthAudit(client, TRUE, (struct sockaddr *) from, fromlen,
		      proto_n, auth_proto, auth_id);

	    free(from);
	}
    }
    priv->auth_id = auth_id;
    priv->conn_time = 0;

#ifdef XDMCP
    /* indicate to Xdmcp protocol that we've opened new client */
    XdmcpOpenDisplay(priv->fd);
#endif /* XDMCP */

    XaceHook(XACE_AUTH_AVAIL, client, auth_id);

    /* At this point, if the client is authorized to change the access control
     * list, we should getpeername() information, and add the client to
     * the selfhosts list.  It's not really the host machine, but the
     * true purpose of the selfhosts list is to see who may change the
     * access control list.
     */
    return((char *)NULL);
}

static ClientPtr
AllocNewConnection (XtransConnInfo trans_conn, int fd, CARD32 conn_time)
{
    OsCommPtr	oc;
    ClientPtr	client;
    
    if (
#ifndef WIN32
	fd >= lastfdesc
#else
	XFD_SETCOUNT(&AllClients) >= MaxClients
#endif
	)
	return NullClient;
    oc = malloc(sizeof(OsCommRec));
    if (!oc)
	return NullClient;
    oc->trans_conn = trans_conn;
    oc->fd = fd;
    oc->input = (ConnectionInputPtr)NULL;
    oc->output = (ConnectionOutputPtr)NULL;
    oc->auth_id = None;
    oc->conn_time = conn_time;
    if (!(client = NextAvailableClient((pointer)oc)))
    {
	free(oc);
	return NullClient;
    }
    oc->local_client = ComputeLocalClient(client);
#if !defined(WIN32)
    ConnectionTranslation[fd] = client->index;
#else
    SetConnectionTranslation(fd, client->index);
#endif
    if (GrabInProgress)
    {
        FD_SET(fd, &SavedAllClients);
        FD_SET(fd, &SavedAllSockets);
    }
    else
    {
        FD_SET(fd, &AllClients);
        FD_SET(fd, &AllSockets);
    }

#ifdef DEBUG
    ErrorF("AllocNewConnection: client index = %d, socket fd = %d\n",
	   client->index, fd);
#endif
#ifdef XSERVER_DTRACE
    XSERVER_CLIENT_CONNECT(client->index, fd);
#endif	

    return client;
}

/*****************
 * EstablishNewConnections
 *    If anyone is waiting on listened sockets, accept them.
 *    Returns a mask with indices of new clients.  Updates AllClients
 *    and AllSockets.
 *****************/

/*ARGSUSED*/
Bool
EstablishNewConnections(ClientPtr clientUnused, pointer closure)
{
    fd_set  readyconnections;     /* set of listeners that are ready */
    int curconn;                  /* fd of listener that's ready */
    register int newconn;         /* fd of new client */
    CARD32 connect_time;
    register int i;
    register ClientPtr client;
    register OsCommPtr oc;
    fd_set tmask;

    XFD_ANDSET (&tmask, (fd_set*)closure, &WellKnownConnections);
    XFD_COPYSET(&tmask, &readyconnections);
    if (!XFD_ANYSET(&readyconnections))
	return TRUE;
    connect_time = GetTimeInMillis();
    /* kill off stragglers */
    for (i=1; i<currentMaxClients; i++)
    {
	if ((client = clients[i]))
	{
	    oc = (OsCommPtr)(client->osPrivate);
	    if ((oc && (oc->conn_time != 0) &&
		(connect_time - oc->conn_time) >= TimeOutValue) || 
		(client->noClientException != Success && !client->clientGone))
		CloseDownClient(client);     
	}
    }
#ifndef WIN32
    for (i = 0; i < howmany(XFD_SETSIZE, NFDBITS); i++)
    {
      while (readyconnections.fds_bits[i])
#else
      for (i = 0; i < XFD_SETCOUNT(&readyconnections); i++) 
#endif
      {
	XtransConnInfo trans_conn, new_trans_conn;
	int status;

#ifndef WIN32
	curconn = mffs (readyconnections.fds_bits[i]) - 1;
	readyconnections.fds_bits[i] &= ~((fd_mask)1 << curconn);
	curconn += (i * (sizeof(fd_mask)*8));
#else
	curconn = XFD_FD(&readyconnections, i);
#endif

	if ((trans_conn = lookup_trans_conn (curconn)) == NULL)
	    continue;

	if ((new_trans_conn = _XSERVTransAccept (trans_conn, &status)) == NULL)
	    continue;

	newconn = _XSERVTransGetConnectionNumber (new_trans_conn);

	if (newconn < lastfdesc)
	{
		int clientid;
#if !defined(WIN32)
  		clientid = ConnectionTranslation[newconn];
#else
  		clientid = GetConnectionTranslation(newconn);
#endif
		if(clientid && (client = clients[clientid]))
 			CloseDownClient(client);
	}

	_XSERVTransSetOption(new_trans_conn, TRANS_NONBLOCKING, 1);

	if(trans_conn->flags & TRANS_NOXAUTH)
	    new_trans_conn->flags = new_trans_conn->flags | TRANS_NOXAUTH;

	if (!AllocNewConnection (new_trans_conn, newconn, connect_time))
	{
	    ErrorConnMax(new_trans_conn);
	    _XSERVTransClose(new_trans_conn);
	}
      }
#ifndef WIN32
    }
#endif
    return TRUE;
}

#define NOROOM "Maximum number of clients reached"

/************
 *   ErrorConnMax
 *     Fail a connection due to lack of client or file descriptor space
 ************/

static void
ErrorConnMax(XtransConnInfo trans_conn)
{
    int fd = _XSERVTransGetConnectionNumber (trans_conn);
    xConnSetupPrefix csp;
    char pad[3];
    struct iovec iov[3];
    char byteOrder = 0;
    int whichbyte = 1;
    struct timeval waittime;
    fd_set mask;

    /* if these seems like a lot of trouble to go to, it probably is */
    waittime.tv_sec = BOTIMEOUT / MILLI_PER_SECOND;
    waittime.tv_usec = (BOTIMEOUT % MILLI_PER_SECOND) *
		       (1000000 / MILLI_PER_SECOND);
    FD_ZERO(&mask);
    FD_SET(fd, &mask);
    (void)Select(fd + 1, &mask, NULL, NULL, &waittime);
    /* try to read the byte-order of the connection */
    (void)_XSERVTransRead(trans_conn, &byteOrder, 1);
    if ((byteOrder == 'l') || (byteOrder == 'B'))
    {
	csp.success = xFalse;
	csp.lengthReason = sizeof(NOROOM) - 1;
	csp.length = (sizeof(NOROOM) + 2) >> 2;
	csp.majorVersion = X_PROTOCOL;
	csp.minorVersion = X_PROTOCOL_REVISION;
	if (((*(char *) &whichbyte) && (byteOrder == 'B')) ||
	    (!(*(char *) &whichbyte) && (byteOrder == 'l')))
	{
	    swaps(&csp.majorVersion, whichbyte);
	    swaps(&csp.minorVersion, whichbyte);
	    swaps(&csp.length, whichbyte);
	}
	iov[0].iov_len = sz_xConnSetupPrefix;
	iov[0].iov_base = (char *) &csp;
	iov[1].iov_len = csp.lengthReason;
	iov[1].iov_base = NOROOM;
	iov[2].iov_len = (4 - (csp.lengthReason & 3)) & 3;
	iov[2].iov_base = pad;
	(void)_XSERVTransWritev(trans_conn, iov, 3);
    }
}

/************
 *   CloseDownFileDescriptor:
 *     Remove this file descriptor and it's I/O buffers, etc.
 ************/

static void
CloseDownFileDescriptor(OsCommPtr oc)
{
    int connection = oc->fd;

    if (oc->trans_conn) {
	_XSERVTransDisconnect(oc->trans_conn);
	_XSERVTransClose(oc->trans_conn);
    }
#ifndef WIN32
    ConnectionTranslation[connection] = 0;
#else
    SetConnectionTranslation(connection, 0);
#endif    
    FD_CLR(connection, &AllSockets);
    FD_CLR(connection, &AllClients);
    FD_CLR(connection, &ClientsWithInput);
    FD_CLR(connection, &GrabImperviousClients);
    if (GrabInProgress)
    {
	FD_CLR(connection, &SavedAllSockets);
	FD_CLR(connection, &SavedAllClients);
	FD_CLR(connection, &SavedClientsWithInput);
    }
    FD_CLR(connection, &ClientsWriteBlocked);
    if (!XFD_ANYSET(&ClientsWriteBlocked))
    	AnyClientsWriteBlocked = FALSE;
    FD_CLR(connection, &OutputPending);
}

/*****************
 * CheckConnections
 *    Some connection has died, go find which one and shut it down 
 *    The file descriptor has been closed, but is still in AllClients.
 *    If would truly be wonderful if select() would put the bogus
 *    file descriptors in the exception mask, but nooooo.  So we have
 *    to check each and every socket individually.
 *****************/

void
CheckConnections(void)
{
#ifndef WIN32
    fd_mask		mask;
#endif
    fd_set		tmask; 
    int			curclient, curoff;
    int			i;
    struct timeval	notime;
    int r;
#ifdef WIN32
    int j;
    fd_set savedAllClients;
#endif

    notime.tv_sec = 0;
    notime.tv_usec = 0;

#ifndef WIN32
    for (i=0; i<howmany(XFD_SETSIZE, NFDBITS); i++)
    {
	mask = AllClients.fds_bits[i];
        while (mask)
    	{
	    curoff = mffs (mask) - 1;
	    curclient = curoff + (i * (sizeof(fd_mask)*8));
            FD_ZERO(&tmask);
            FD_SET(curclient, &tmask);
            do {
                r = Select (curclient + 1, &tmask, NULL, NULL, &notime);
            } while (r < 0 && (errno == EINTR || errno == EAGAIN));
            if (r < 0)
                if (ConnectionTranslation[curclient] > 0)
                    CloseDownClient(clients[ConnectionTranslation[curclient]]);
	    mask &= ~((fd_mask)1 << curoff);
	}
    }	
#else
  /* First test AllSockets and then AllClients are valid sockets */
  XFD_COPYSET(&AllSockets, &savedAllClients);
  for (j = 0; j < 2; j++)
  {
    for (i = 0; i < XFD_SETCOUNT(&savedAllClients); i++)
    {
      curclient = XFD_FD(&savedAllClients, i);
      FD_ZERO(&tmask);
      FD_SET(curclient, &tmask);
      do
      {
        r = Select(curclient + 1, &tmask, NULL, NULL, &notime);
      }
      while (r == SOCKET_ERROR
#ifdef HAS_WINSOCK
      && (WSAGetLastError() == WSAEINTR || WSAGetLastError() == WSAEWOULDBLOCK)
#endif
      );
      if (r < 0)
        if (GetConnectionTranslation(curclient) > 0)
        {
          CloseDownClient(clients[GetConnectionTranslation(curclient)]);
        }
    }
    XFD_COPYSET(&AllClients, &savedAllClients);
  }
#endif
}


/*****************
 * CloseDownConnection
 *    Delete client from AllClients and free resources 
 *****************/

void
CloseDownConnection(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;

    if (FlushCallback)
	CallCallbacks(&FlushCallback, NULL);

    if (oc->output && oc->output->count)
	FlushClient(client, oc, (char *)NULL, 0);
#ifdef XDMCP
    XdmcpCloseDisplay(oc->fd);
#endif
    CloseDownFileDescriptor(oc);
    FreeOsBuffers(oc);
    free(client->osPrivate);
    client->osPrivate = (pointer)NULL;
    if (auditTrailLevel > 1)
	AuditF("client %d disconnected\n", client->index);
}

void
AddGeneralSocket(int fd)
{
    FD_SET(fd, &AllSockets);
    if (GrabInProgress)
	FD_SET(fd, &SavedAllSockets);
}

void
AddEnabledDevice(int fd)
{
    FD_SET(fd, &EnabledDevices);
    AddGeneralSocket(fd);
}

void
RemoveGeneralSocket(int fd)
{
    FD_CLR(fd, &AllSockets);
    if (GrabInProgress)
	FD_CLR(fd, &SavedAllSockets);
}

void
RemoveEnabledDevice(int fd)
{
    FD_CLR(fd, &EnabledDevices);
    RemoveGeneralSocket(fd);
}

/*****************
 * OnlyListenToOneClient:
 *    Only accept requests from  one client.  Continue to handle new
 *    connections, but don't take any protocol requests from the new
 *    ones.  Note that if GrabInProgress is set, EstablishNewConnections
 *    needs to put new clients into SavedAllSockets and SavedAllClients.
 *    Note also that there is no timeout for this in the protocol.
 *    This routine is "undone" by ListenToAllClients()
 *****************/

int
OnlyListenToOneClient(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    int rc, connection = oc->fd;

    rc = XaceHook(XACE_SERVER_ACCESS, client, DixGrabAccess);
    if (rc != Success)
	return rc;

    if (! GrabInProgress)
    {
	XFD_COPYSET(&ClientsWithInput, &SavedClientsWithInput);
	XFD_ANDSET(&ClientsWithInput,
		       &ClientsWithInput, &GrabImperviousClients);
	if (FD_ISSET(connection, &SavedClientsWithInput))
	{
	    FD_CLR(connection, &SavedClientsWithInput);
	    FD_SET(connection, &ClientsWithInput);
	}
	XFD_UNSET(&SavedClientsWithInput, &GrabImperviousClients);
	XFD_COPYSET(&AllSockets, &SavedAllSockets);
	XFD_COPYSET(&AllClients, &SavedAllClients);
	XFD_UNSET(&AllSockets, &AllClients);
	XFD_ANDSET(&AllClients, &AllClients, &GrabImperviousClients);
	FD_SET(connection, &AllClients);
	XFD_ORSET(&AllSockets, &AllSockets, &AllClients);
	GrabInProgress = client->index;
    }
    return rc;
}

/****************
 * ListenToAllClients:
 *    Undoes OnlyListentToOneClient()
 ****************/

void
ListenToAllClients(void)
{
    if (GrabInProgress)
    {
	XFD_ORSET(&AllSockets, &AllSockets, &SavedAllSockets);
	XFD_ORSET(&AllClients, &AllClients, &SavedAllClients);
	XFD_ORSET(&ClientsWithInput, &ClientsWithInput, &SavedClientsWithInput);
	GrabInProgress = 0;
    }	
}

/****************
 * IgnoreClient
 *    Removes one client from input masks.
 *    Must have cooresponding call to AttendClient.
 ****************/

void
IgnoreClient (ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    int connection = oc->fd;

    client->ignoreCount++;
    if (client->ignoreCount > 1)
	return;

    isItTimeToYield = TRUE;
    if (!GrabInProgress || FD_ISSET(connection, &AllClients))
    {
    	if (FD_ISSET (connection, &ClientsWithInput))
	    FD_SET(connection, &IgnoredClientsWithInput);
    	else
	    FD_CLR(connection, &IgnoredClientsWithInput);
    	FD_CLR(connection, &ClientsWithInput);
    	FD_CLR(connection, &AllSockets);
    	FD_CLR(connection, &AllClients);
	FD_CLR(connection, &LastSelectMask);
    }
    else
    {
    	if (FD_ISSET (connection, &SavedClientsWithInput))
	    FD_SET(connection, &IgnoredClientsWithInput);
    	else
	    FD_CLR(connection, &IgnoredClientsWithInput);
	FD_CLR(connection, &SavedClientsWithInput);
	FD_CLR(connection, &SavedAllSockets);
	FD_CLR(connection, &SavedAllClients);
    }
}

/****************
 * AttendClient
 *    Adds one client back into the input masks.
 ****************/

void
AttendClient (ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    int connection = oc->fd;

    client->ignoreCount--;
    if (client->ignoreCount)
	return;

    if (!GrabInProgress || GrabInProgress == client->index ||
	FD_ISSET(connection, &GrabImperviousClients))
    {
    	FD_SET(connection, &AllClients);
    	FD_SET(connection, &AllSockets);
	FD_SET(connection, &LastSelectMask);
    	if (FD_ISSET (connection, &IgnoredClientsWithInput))
	    FD_SET(connection, &ClientsWithInput);
    }
    else
    {
	FD_SET(connection, &SavedAllClients);
	FD_SET(connection, &SavedAllSockets);
	if (FD_ISSET(connection, &IgnoredClientsWithInput))
	    FD_SET(connection, &SavedClientsWithInput);
    }
}

/* make client impervious to grabs; assume only executing client calls this */

void
MakeClientGrabImpervious(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    int connection = oc->fd;

    FD_SET(connection, &GrabImperviousClients);

    if (ServerGrabCallback)
    {
	ServerGrabInfoRec grabinfo;
	grabinfo.client = client;
	grabinfo.grabstate  = CLIENT_IMPERVIOUS;
	CallCallbacks(&ServerGrabCallback, &grabinfo);
    }
}

/* make client pervious to grabs; assume only executing client calls this */

void
MakeClientGrabPervious(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    int connection = oc->fd;

    FD_CLR(connection, &GrabImperviousClients);
    if (GrabInProgress && (GrabInProgress != client->index))
    {
	if (FD_ISSET(connection, &ClientsWithInput))
	{
	    FD_SET(connection, &SavedClientsWithInput);
	    FD_CLR(connection, &ClientsWithInput);
	}
	FD_CLR(connection, &AllSockets);
	FD_CLR(connection, &AllClients);
	isItTimeToYield = TRUE;
    }

    if (ServerGrabCallback)
    {
	ServerGrabInfoRec grabinfo;
	grabinfo.client = client;
	grabinfo.grabstate  = CLIENT_PERVIOUS;
	CallCallbacks(&ServerGrabCallback, &grabinfo);
    }
}

#ifdef XQUARTZ
/* Add a fd (from launchd) to our listeners */
void ListenOnOpenFD(int fd, int noxauth) {
    char port[256];
    XtransConnInfo ciptr;
    const char *display_env = getenv("DISPLAY");

    if(display_env && (strncmp(display_env, "/tmp/launch", 11) == 0)) {
        /* Make the path the launchd socket if our DISPLAY is set right */
        strcpy(port, display_env);
    } else {
        /* Just some default so things don't break and die. */
        sprintf(port, ":%d", atoi(display));
    }

    /* Make our XtransConnInfo
     * TRANS_SOCKET_LOCAL_INDEX = 5 from Xtrans.c
     */
    ciptr = _XSERVTransReopenCOTSServer(5, fd, port);
    if(ciptr == NULL) {
        ErrorF("Got NULL while trying to Reopen launchd port.\n");
        return;
    }
    
    if(noxauth)
        ciptr->flags = ciptr->flags | TRANS_NOXAUTH;

    /* Allocate space to store it */
    ListenTransFds = (int *) realloc(ListenTransFds, (ListenTransCount + 1) * sizeof (int));
    ListenTransConns = (XtransConnInfo *) realloc(ListenTransConns, (ListenTransCount + 1) * sizeof (XtransConnInfo));
    
    /* Store it */
    ListenTransConns[ListenTransCount] = ciptr;
    ListenTransFds[ListenTransCount] = fd;

    FD_SET(fd, &WellKnownConnections);
    FD_SET(fd, &AllSockets);
    
    /* Increment the count */
    ListenTransCount++;

    /* This *might* not be needed... /shrug */
    ResetAuthorization();
    ResetHosts(display);
#ifdef XDMCP
    XdmcpReset();
#endif
}

#endif
/***********************************************************

Copyright 1987, 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.


******************************************************************/
/*****************************************************************
 * i/o functions
 *
 *   WriteToClient, ReadRequestFromClient
 *   InsertFakeRequest, ResetCurrentRequest
 *
 *****************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#undef DEBUG_COMMUNICATION

#ifdef WIN32
#include <X11/Xwinsock.h>
#endif
#include <stdio.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include <X11/Xmd.h>
#include <errno.h>
#if !defined(WIN32)
#include <sys/uio.h>
#endif
#include <X11/X.h>
#include <X11/Xproto.h>
#include "os.h"
#include "osdep.h"
#include <X11/Xpoll.h>
#include "opaque.h"
#include "dixstruct.h"
#include "misc.h"

CallbackListPtr       ReplyCallback;
CallbackListPtr       FlushCallback;

static ConnectionInputPtr AllocateInputBuffer(void);
static ConnectionOutputPtr AllocateOutputBuffer(void);

/* check for both EAGAIN and EWOULDBLOCK, because some supposedly POSIX
 * systems are broken and return EWOULDBLOCK when they should return EAGAIN
 */
#ifndef WIN32
#define ETEST(err) (err == EAGAIN || err == EWOULDBLOCK)
#else /* WIN32 The socket errorcodes differ from the normal errors*/
#define ETEST(err) (err == EAGAIN || err == WSAEWOULDBLOCK)
#endif

static Bool CriticalOutputPending;
static int timesThisConnection = 0;
static ConnectionInputPtr FreeInputs = (ConnectionInputPtr)NULL;
static ConnectionOutputPtr FreeOutputs = (ConnectionOutputPtr)NULL;
static OsCommPtr AvailableInput = (OsCommPtr)NULL;

#define get_req_len(req,cli) ((cli)->swapped ? \
			      lswaps((req)->length) : (req)->length)

#include <X11/extensions/bigreqsproto.h>

#define get_big_req_len(req,cli) ((cli)->swapped ? \
				  lswapl(((xBigReq *)(req))->length) : \
				  ((xBigReq *)(req))->length)

#define MAX_TIMES_PER         10

/*
 *   A lot of the code in this file manipulates a ConnectionInputPtr:
 *
 *    -----------------------------------------------
 *   |------- bufcnt ------->|           |           |
 *   |           |- gotnow ->|           |           |
 *   |           |-------- needed ------>|           |
 *   |-----------+--------- size --------+---------->|
 *    -----------------------------------------------
 *   ^           ^
 *   |           |
 *   buffer   bufptr
 *
 *  buffer is a pointer to the start of the buffer.
 *  bufptr points to the start of the current request.
 *  bufcnt counts how many bytes are in the buffer.
 *  size is the size of the buffer in bytes.
 *
 *  In several of the functions, gotnow and needed are local variables
 *  that do the following:
 *
 *  gotnow is the number of bytes of the request that we're
 *  trying to read that are currently in the buffer.
 *  Typically, gotnow = (buffer + bufcnt) - bufptr
 *
 *  needed = the length of the request that we're trying to
 *  read.  Watch out: needed sometimes counts bytes and sometimes
 *  counts CARD32's.
 */


/*****************************************************************
 * ReadRequestFromClient
 *    Returns one request in client->requestBuffer.  The request
 *    length will be in client->req_len.  Return status is:
 *
 *    > 0  if  successful, specifies length in bytes of the request
 *    = 0  if  entire request is not yet available
 *    < 0  if  client should be terminated
 *
 *    The request returned must be contiguous so that it can be
 *    cast in the dispatcher to the correct request type.  Because requests
 *    are variable length, ReadRequestFromClient() must look at the first 4
 *    or 8 bytes of a request to determine the length (the request length is
 *    in the 3rd and 4th bytes of the request unless it is a Big Request
 *    (see the Big Request Extension), in which case the 3rd and 4th bytes
 *    are zero and the following 4 bytes are the request length.
 *
 *    Note: in order to make the server scheduler (WaitForSomething())
 *    "fair", the ClientsWithInput mask is used.  This mask tells which
 *    clients have FULL requests left in their buffers.  Clients with
 *    partial requests require a read.  Basically, client buffers
 *    are drained before select() is called again.  But, we can't keep
 *    reading from a client that is sending buckets of data (or has
 *    a partial request) because others clients need to be scheduled.
 *****************************************************************/

static void
YieldControl(void)
{
    isItTimeToYield = TRUE;
    timesThisConnection = 0;
}

static void
YieldControlNoInput(int fd)
{
    YieldControl();
    FD_CLR(fd, &ClientsWithInput);
}

static void
YieldControlDeath(void)
{
    timesThisConnection = 0;
}

int
ReadRequestFromClient(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    ConnectionInputPtr oci = oc->input;
    int fd = oc->fd;
    unsigned int gotnow, needed;
    int result;
    register xReq *request;
    Bool need_header;
    Bool move_header;

    /* If an input buffer was empty, either free it if it is too big
     * or link it into our list of free input buffers.  This means that
     * different clients can share the same input buffer (at different
     * times).  This was done to save memory.
     */

    if (AvailableInput)
    {
	if (AvailableInput != oc)
	{
	    register ConnectionInputPtr aci = AvailableInput->input;
	    if (aci->size > BUFWATERMARK)
	    {
		free(aci->buffer);
		free(aci);
	    }
	    else
	    {
		aci->next = FreeInputs;
		FreeInputs = aci;
	    }
	    AvailableInput->input = (ConnectionInputPtr)NULL;
	}
	AvailableInput = (OsCommPtr)NULL;
    }

    /* make sure we have an input buffer */

    if (!oci)
    {
	if ((oci = FreeInputs))
	{
	    FreeInputs = oci->next;
	}
	else if (!(oci = AllocateInputBuffer()))
	{
	    YieldControlDeath();
	    return -1;
	}
	oc->input = oci;
    }

    /* advance to start of next request */

    oci->bufptr += oci->lenLastReq;

    need_header = FALSE;
    move_header = FALSE;
    gotnow = oci->bufcnt + oci->buffer - oci->bufptr;

    if (oci->ignoreBytes > 0) {
	if (oci->ignoreBytes > oci->size)
	    needed = oci->size;
	else
	    needed = oci->ignoreBytes;
    }
    else if (gotnow < sizeof(xReq))
    {
	/* We don't have an entire xReq yet.  Can't tell how big
	 * the request will be until we get the whole xReq.
	 */
	needed = sizeof(xReq);
	need_header = TRUE;
    }
    else
    {
	/* We have a whole xReq.  We can tell how big the whole
	 * request will be unless it is a Big Request.
	 */
	request = (xReq *)oci->bufptr;
	needed = get_req_len(request, client);
	if (!needed && client->big_requests)
	{
	    /* It's a Big Request. */
	    move_header = TRUE;
	    if (gotnow < sizeof(xBigReq))
	    {
		/* Still need more data to tell just how big. */
		needed = bytes_to_int32(sizeof(xBigReq)); /* needed is in CARD32s now */
		need_header = TRUE;
	    }
	    else
		needed = get_big_req_len(request, client);
	}
	client->req_len = needed;
	needed <<= 2; /* needed is in bytes now */
    }
    if (gotnow < needed)
    {
	/* Need to read more data, either so that we can get a
	 * complete xReq (if need_header is TRUE), a complete
	 * xBigReq (if move_header is TRUE), or the rest of the
	 * request (if need_header and move_header are both FALSE).
	 */

	oci->lenLastReq = 0;
	if (needed > maxBigRequestSize << 2)
	{
	    /* request is too big for us to handle */
	    /*
	     * Mark the rest of it as needing to be ignored, and then return
	     * the full size.  Dispatch() will turn it into a BadLength error.
	     */
	    oci->ignoreBytes = needed - gotnow;
	    oci->lenLastReq = gotnow;
	    return needed;
	}
	if ((gotnow == 0) ||
	    ((oci->bufptr - oci->buffer + needed) > oci->size))
	{
	    /* no data, or the request is too big to fit in the buffer */

	    if ((gotnow > 0) && (oci->bufptr != oci->buffer))
		/* save the data we've already read */
		memmove(oci->buffer, oci->bufptr, gotnow);
	    if (needed > oci->size)
	    {
		/* make buffer bigger to accomodate request */
		char *ibuf;

		ibuf = (char *)realloc(oci->buffer, needed);
		if (!ibuf)
		{
		    YieldControlDeath();
		    return -1;
		}
		oci->size = needed;
		oci->buffer = ibuf;
	    }
	    oci->bufptr = oci->buffer;
	    oci->bufcnt = gotnow;
	}
	/*  XXX this is a workaround.  This function is sometimes called
	 *  after the trans_conn has been freed.  In this case trans_conn
	 *  will be null.  Really ought to restructure things so that we
	 *  never get here in those circumstances.
	 */
	if (!oc->trans_conn)
	{
	    /*  treat as if an error occured on the read, which is what
	     *  used to happen
	     */
	    YieldControlDeath();
	    return -1;
	}
	    result = _XSERVTransRead(oc->trans_conn, oci->buffer + oci->bufcnt,
				     oci->size - oci->bufcnt); 
	if (result <= 0)
	{
	    if ((result < 0) && ETEST(errno))
	    {
#if defined(SVR4) && defined(__i386__) && !defined(sun)
		if (0)
#endif
		{
		    YieldControlNoInput(fd);
		    return 0;
		}
	    }
	    YieldControlDeath();
	    return -1;
	}
	oci->bufcnt += result;
	gotnow += result;
	/* free up some space after huge requests */
	if ((oci->size > BUFWATERMARK) &&
	    (oci->bufcnt < BUFSIZE) && (needed < BUFSIZE))
	{
	    char *ibuf;

	    ibuf = (char *)realloc(oci->buffer, BUFSIZE);
	    if (ibuf)
	    {
		oci->size = BUFSIZE;
		oci->buffer = ibuf;
		oci->bufptr = ibuf + oci->bufcnt - gotnow;
	    }
	}
	if (need_header && gotnow >= needed)
	{
	    /* We wanted an xReq, now we've gotten it. */
	    request = (xReq *)oci->bufptr;
	    needed = get_req_len(request, client);
	    if (!needed && client->big_requests)
	    {
		move_header = TRUE;
		if (gotnow < sizeof(xBigReq))
		    needed = bytes_to_int32(sizeof(xBigReq));
		else
		    needed = get_big_req_len(request, client);
	    }
	    client->req_len = needed;
	    needed <<= 2;
	}
	if (gotnow < needed)
	{
	    /* Still don't have enough; punt. */
	    YieldControlNoInput(fd);
	    return 0;
	}
    }
    if (needed == 0)
    {
	if (client->big_requests)
	    needed = sizeof(xBigReq);
	else
	    needed = sizeof(xReq);
    }

    /* If there are bytes to ignore, ignore them now. */

    if (oci->ignoreBytes > 0) {
	assert(needed == oci->ignoreBytes || needed == oci->size);
	/*
	 * The _XSERVTransRead call above may return more or fewer bytes than we
	 * want to ignore.  Ignore the smaller of the two sizes.
	 */
	if (gotnow < needed) {
	    oci->ignoreBytes -= gotnow;
	    oci->bufptr += gotnow;
	    gotnow = 0;
	} else {
	    oci->ignoreBytes -= needed;
	    oci->bufptr += needed;
	    gotnow -= needed;
	}
	needed = 0;
    }

    oci->lenLastReq = needed;

    /*
     *  Check to see if client has at least one whole request in the
     *  buffer beyond the request we're returning to the caller.
     *  If there is only a partial request, treat like buffer
     *  is empty so that select() will be called again and other clients
     *  can get into the queue.   
     */

    gotnow -= needed;
    if (gotnow >= sizeof(xReq)) 
    {
	request = (xReq *)(oci->bufptr + needed);
	if (gotnow >= (result = (get_req_len(request, client) << 2))
	    && (result ||
		(client->big_requests &&
		 (gotnow >= sizeof(xBigReq) &&
		  gotnow >= (get_big_req_len(request, client) << 2))))
	    )
	    FD_SET(fd, &ClientsWithInput);
	else
	{
	    if (!SmartScheduleDisable)
		FD_CLR(fd, &ClientsWithInput);
	    else
		YieldControlNoInput(fd);
	}
    }
    else
    {
	if (!gotnow)
	    AvailableInput = oc;
	if (!SmartScheduleDisable)
	    FD_CLR(fd, &ClientsWithInput);
	else
	    YieldControlNoInput(fd);
    }
    if (SmartScheduleDisable)
    if (++timesThisConnection >= MAX_TIMES_PER)
	YieldControl();
    if (move_header)
    {
	request = (xReq *)oci->bufptr;
	oci->bufptr += (sizeof(xBigReq) - sizeof(xReq));
	*(xReq *)oci->bufptr = *request;
	oci->lenLastReq -= (sizeof(xBigReq) - sizeof(xReq));
	client->req_len -= bytes_to_int32(sizeof(xBigReq) - sizeof(xReq));
    }
    client->requestBuffer = (pointer)oci->bufptr;
#ifdef DEBUG_COMMUNICATION
    {
	xReq *req = client->requestBuffer;
	ErrorF("REQUEST: ClientIDX: %i, type: 0x%x data: 0x%x len: %i\n",
	       client->index,req->reqType,req->data,req->length);
    }
#endif
    return needed;
}

/*****************************************************************
 * InsertFakeRequest
 *    Splice a consed up (possibly partial) request in as the next request.
 *
 **********************/

Bool
InsertFakeRequest(ClientPtr client, char *data, int count)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    ConnectionInputPtr oci = oc->input;
    int fd = oc->fd;
    int gotnow, moveup;

    if (AvailableInput)
    {
	if (AvailableInput != oc)
	{
	    ConnectionInputPtr aci = AvailableInput->input;
	    if (aci->size > BUFWATERMARK)
	    {
		free(aci->buffer);
		free(aci);
	    }
	    else
	    {
		aci->next = FreeInputs;
		FreeInputs = aci;
	    }
	    AvailableInput->input = (ConnectionInputPtr)NULL;
	}
	AvailableInput = (OsCommPtr)NULL;
    }
    if (!oci)
    {
	if ((oci = FreeInputs))
	    FreeInputs = oci->next;
	else if (!(oci = AllocateInputBuffer()))
	    return FALSE;
	oc->input = oci;
    }
    oci->bufptr += oci->lenLastReq;
    oci->lenLastReq = 0;
    gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
    if ((gotnow + count) > oci->size)
    {
	char *ibuf;

	ibuf = (char *)realloc(oci->buffer, gotnow + count);
	if (!ibuf)
	    return FALSE;
	oci->size = gotnow + count;
	oci->buffer = ibuf;
	oci->bufptr = ibuf + oci->bufcnt - gotnow;
    }
    moveup = count - (oci->bufptr - oci->buffer);
    if (moveup > 0)
    {
	if (gotnow > 0)
	    memmove(oci->bufptr + moveup, oci->bufptr, gotnow);
	oci->bufptr += moveup;
	oci->bufcnt += moveup;
    }
    memmove(oci->bufptr - count, data, count);
    oci->bufptr -= count;
    gotnow += count;
    if ((gotnow >= sizeof(xReq)) &&
	(gotnow >= (int)(get_req_len((xReq *)oci->bufptr, client) << 2)))
	FD_SET(fd, &ClientsWithInput);
    else
	YieldControlNoInput(fd);
    return TRUE;
}

/*****************************************************************
 * ResetRequestFromClient
 *    Reset to reexecute the current request, and yield.
 *
 **********************/

void
ResetCurrentRequest(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    register ConnectionInputPtr oci = oc->input;
    int fd = oc->fd;
    register xReq *request;
    int gotnow, needed;
    if (AvailableInput == oc)
	AvailableInput = (OsCommPtr)NULL;
    oci->lenLastReq = 0;
    gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
    if (gotnow < sizeof(xReq))
    {
	YieldControlNoInput(fd);
    }
    else
    {
	request = (xReq *)oci->bufptr;
	needed = get_req_len(request, client);
	if (!needed && client->big_requests)
	{
	    oci->bufptr -= sizeof(xBigReq) - sizeof(xReq);
	    *(xReq *)oci->bufptr = *request;
	    ((xBigReq *)oci->bufptr)->length = client->req_len;
	    if (client->swapped)
	    {
		char n;
		swapl(&((xBigReq *)oci->bufptr)->length, n);
	    }
	}
	if (gotnow >= (needed << 2))
	{
	    if (FD_ISSET(fd, &AllClients))
	    {
		FD_SET(fd, &ClientsWithInput);
	    }
	    else
	    {
		FD_SET(fd, &IgnoredClientsWithInput);
	    }
	    YieldControl();
	}
	else
	    YieldControlNoInput(fd);
    }
}

static const int padlength[4] = {0, 3, 2, 1};

 /********************
 * FlushAllOutput()
 *    Flush all clients with output.  However, if some client still
 *    has input in the queue (more requests), then don't flush.  This
 *    will prevent the output queue from being flushed every time around
 *    the round robin queue.  Now, some say that it SHOULD be flushed
 *    every time around, but...
 *
 **********************/

void
FlushAllOutput(void)
{
    register int index, base;
    register fd_mask mask; /* raphael */
    OsCommPtr oc;
    register ClientPtr client;
    Bool newoutput = NewOutputPending;
#if defined(WIN32)
    fd_set newOutputPending;
#endif

    if (FlushCallback)
	CallCallbacks(&FlushCallback, NULL);

    if (!newoutput)
	return;

    /*
     * It may be that some client still has critical output pending,
     * but he is not yet ready to receive it anyway, so we will
     * simply wait for the select to tell us when he's ready to receive.
     */
    CriticalOutputPending = FALSE;
    NewOutputPending = FALSE;

#ifndef WIN32
    for (base = 0; base < howmany(XFD_SETSIZE, NFDBITS); base++)
    {
	mask = OutputPending.fds_bits[ base ];
	OutputPending.fds_bits[ base ] = 0;
	while (mask)
	{
	    index = ffs(mask) - 1;
	    mask &= ~lowbit(mask);
	    if ((index = ConnectionTranslation[(base * (sizeof(fd_mask)*8)) + index]) == 0)
		continue;
	    client = clients[index];
	    if (client->clientGone)
		continue;
	    oc = (OsCommPtr)client->osPrivate;
	    if (FD_ISSET(oc->fd, &ClientsWithInput))
	    {
		FD_SET(oc->fd, &OutputPending); /* set the bit again */
		NewOutputPending = TRUE;
	    }
	    else
		(void)FlushClient(client, oc, (char *)NULL, 0);
	}
    }
#else  /* WIN32 */
    FD_ZERO(&newOutputPending);
    for (base = 0; base < XFD_SETCOUNT(&OutputPending); base++)
    {
	    index = XFD_FD(&OutputPending, base);
	    if ((index = GetConnectionTranslation(index)) == 0)
		continue;
	    client = clients[index];
	    if (client->clientGone)
		continue;
	    oc = (OsCommPtr)client->osPrivate;
	    if (FD_ISSET(oc->fd, &ClientsWithInput))
	    {
		FD_SET(oc->fd, &newOutputPending); /* set the bit again */
		NewOutputPending = TRUE;
	    }
	    else
		(void)FlushClient(client, oc, (char *)NULL, 0);
    }
    XFD_COPYSET(&newOutputPending, &OutputPending);
#endif /* WIN32 */
}

void
FlushIfCriticalOutputPending(void)
{
    if (CriticalOutputPending)
	FlushAllOutput();
}

void
SetCriticalOutputPending(void)
{
    CriticalOutputPending = TRUE;
}

/*****************
 * WriteToClient
 *    Copies buf into ClientPtr.buf if it fits (with padding), else
 *    flushes ClientPtr.buf and buf to client.  As of this writing,
 *    every use of WriteToClient is cast to void, and the result
 *    is ignored.  Potentially, this could be used by requests
 *    that are sending several chunks of data and want to break
 *    out of a loop on error.  Thus, we will leave the type of
 *    this routine as int.
 *****************/

int
WriteToClient (ClientPtr who, int count, const void *__buf)
{
    OsCommPtr oc;
    ConnectionOutputPtr oco;
    int padBytes;
    const char *buf = __buf;
#ifdef DEBUG_COMMUNICATION
    Bool multicount = FALSE;
#endif
    if (!count || !who || who == serverClient || who->clientGone)
	return 0;
    oc = who->osPrivate;
    oco = oc->output;
#ifdef DEBUG_COMMUNICATION
    {
	char info[128];
	xError *err;
	xGenericReply *rep;
	xEvent *ev;
	
	if (!who->replyBytesRemaining) {
	    switch(buf[0]) {
	    case X_Reply:
		rep = (xGenericReply*)buf;
		if (rep->sequenceNumber == who->sequence) {
		    snprintf(info,127,"Xreply: type: 0x%x data: 0x%x "
			     "len: %i seq#: 0x%x", rep->type, rep->data1,
			     rep->length, rep->sequenceNumber);
		    multicount = TRUE;
		}
		break;
	    case X_Error:
		err = (xError*)buf;
		snprintf(info,127,"Xerror: Code: 0x%x resID: 0x%x maj: 0x%x "
			 "min: %x", err->errorCode,err->resourceID,
			 err->minorCode,err->majorCode);
		break;
	    default:
		if ((buf[0] & 0x7f) == KeymapNotify) 
		    snprintf(info,127,"KeymapNotifyEvent: %i",buf[0]);
		else {
		    ev = (xEvent*)buf;
		    snprintf(info,127,"XEvent: type: 0x%x detail: 0x%x "
			     "seq#: 0x%x",  ev->u.u.type, ev->u.u.detail,
			     ev->u.u.sequenceNumber);
		}
	    }
	    ErrorF("REPLY: ClientIDX: %i %s\n",who->index, info);
	} else
	    multicount = TRUE;
    }
#endif

    if (!oco)
    {
	if ((oco = FreeOutputs))
	{
	    FreeOutputs = oco->next;
	}
	else if (!(oco = AllocateOutputBuffer()))
	{
	    if (oc->trans_conn) {
		_XSERVTransDisconnect(oc->trans_conn);
		_XSERVTransClose(oc->trans_conn);
		oc->trans_conn = NULL;
	    }
	    MarkClientException(who);
	    return -1;
	}
	oc->output = oco;
    }

    padBytes = padlength[count & 3];

    if(ReplyCallback)
    {
        ReplyInfoRec replyinfo;

	replyinfo.client = who;
	replyinfo.replyData = buf;
	replyinfo.dataLenBytes = count + padBytes;
	if (who->replyBytesRemaining)
	{ /* still sending data of an earlier reply */
	    who->replyBytesRemaining -= count + padBytes;
	    replyinfo.startOfReply = FALSE;
	    replyinfo.bytesRemaining = who->replyBytesRemaining;
	    CallCallbacks((&ReplyCallback), (pointer)&replyinfo);
	}
	else if (who->clientState == ClientStateRunning
		 && buf[0] == X_Reply)
        { /* start of new reply */
	    CARD32 replylen;
	    unsigned long bytesleft;
	    char n;

	    replylen = ((xGenericReply *)buf)->length;
	    if (who->swapped)
		swapl(&replylen, n);
	    bytesleft = (replylen * 4) + SIZEOF(xReply) - count - padBytes;
	    replyinfo.startOfReply = TRUE;
	    replyinfo.bytesRemaining = who->replyBytesRemaining = bytesleft;
	    CallCallbacks((&ReplyCallback), (pointer)&replyinfo);
	} 	                      
    }
#ifdef DEBUG_COMMUNICATION
    else if (multicount) {
	if (who->replyBytesRemaining) {
	    who->replyBytesRemaining -= (count + padBytes);
	} else {
	    CARD32 replylen;
	    replylen = ((xGenericReply *)buf)->length;
	    who->replyBytesRemaining =
		(replylen * 4) + SIZEOF(xReply) - count - padBytes;
	}
    }
#endif
    if (oco->count + count + padBytes > oco->size)
    {
	FD_CLR(oc->fd, &OutputPending);
	if(!XFD_ANYSET(&OutputPending)) {
	  CriticalOutputPending = FALSE;
	  NewOutputPending = FALSE;
	}

	if (FlushCallback)
	    CallCallbacks(&FlushCallback, NULL);

	return FlushClient(who, oc, buf, count);
    }

    NewOutputPending = TRUE;
    FD_SET(oc->fd, &OutputPending);
    memmove((char *)oco->buf + oco->count, buf, count);
    oco->count += count + padBytes;
    return count;
}

 /********************
 * FlushClient()
 *    If the client isn't keeping up with us, then we try to continue
 *    buffering the data and set the apropriate bit in ClientsWritable
 *    (which is used by WaitFor in the select).  If the connection yields
 *    a permanent error, or we can't allocate any more space, we then
 *    close the connection.
 *
 **********************/

int
FlushClient(ClientPtr who, OsCommPtr oc, const void *__extraBuf, int extraCount)
{
    ConnectionOutputPtr oco = oc->output;
    int connection = oc->fd;
    XtransConnInfo trans_conn = oc->trans_conn;
    struct iovec iov[3];
    static char padBuffer[3];
    const char *extraBuf = __extraBuf;
    long written;
    long padsize;
    long notWritten;
    long todo;

    if (!oco)
	return 0;
    written = 0;
    padsize = padlength[extraCount & 3];
    notWritten = oco->count + extraCount + padsize;
    todo = notWritten;
    while (notWritten) {
	long before = written;	/* amount of whole thing written */
	long remain = todo;	/* amount to try this time, <= notWritten */
	int i = 0;
	long len;
	
	/* You could be very general here and have "in" and "out" iovecs
	 * and write a loop without using a macro, but what the heck.  This
	 * translates to:
	 *
	 *     how much of this piece is new?
	 *     if more new then we are trying this time, clamp
	 *     if nothing new
	 *         then bump down amount already written, for next piece
	 *         else put new stuff in iovec, will need all of next piece
	 *
	 * Note that todo had better be at least 1 or else we'll end up
	 * writing 0 iovecs.
	 */
#define InsertIOV(pointer, length) \
	len = (length) - before; \
	if (len > remain) \
	    len = remain; \
	if (len <= 0) { \
	    before = (-len); \
	} else { \
	    iov[i].iov_len = len; \
	    iov[i].iov_base = (pointer) + before;	\
	    i++; \
	    remain -= len; \
	    before = 0; \
	}

	InsertIOV ((char *)oco->buf, oco->count)
	InsertIOV ((char *)extraBuf, extraCount)
	InsertIOV (padBuffer, padsize)

	errno = 0;
	if (trans_conn && (len = _XSERVTransWritev(trans_conn, iov, i)) >= 0)
	{
	    written += len;
	    notWritten -= len;
	    todo = notWritten;
	}
	else if (ETEST(errno)
#ifdef SUNSYSV /* check for another brain-damaged OS bug */
		 || (errno == 0)
#endif
#ifdef EMSGSIZE /* check for another brain-damaged OS bug */
		 || ((errno == EMSGSIZE) && (todo == 1))
#endif
		)
	{
	    /* If we've arrived here, then the client is stuffed to the gills
	       and not ready to accept more.  Make a note of it and buffer
	       the rest. */
	    FD_SET(connection, &ClientsWriteBlocked);
	    AnyClientsWriteBlocked = TRUE;

	    if (written < oco->count)
	    {
		if (written > 0)
		{
		    oco->count -= written;
		    memmove((char *)oco->buf,
			    (char *)oco->buf + written,
			  oco->count);
		    written = 0;
		}
	    }
	    else
	    {
		written -= oco->count;
		oco->count = 0;
	    }

	    if (notWritten > oco->size)
	    {
		unsigned char *obuf;

		obuf = (unsigned char *)realloc(oco->buf,
						 notWritten + BUFSIZE);
		if (!obuf)
		{
		    _XSERVTransDisconnect(oc->trans_conn);
		    _XSERVTransClose(oc->trans_conn);
		    oc->trans_conn = NULL;
		    MarkClientException(who);
		    oco->count = 0;
		    return -1;
		}
		oco->size = notWritten + BUFSIZE;
		oco->buf = obuf;
	    }

	    /* If the amount written extended into the padBuffer, then the
	       difference "extraCount - written" may be less than 0 */
	    if ((len = extraCount - written) > 0)
		memmove ((char *)oco->buf + oco->count,
			 extraBuf + written,
		       len);

	    oco->count = notWritten; /* this will include the pad */
	    /* return only the amount explicitly requested */
	    return extraCount;
	}
#ifdef EMSGSIZE /* check for another brain-damaged OS bug */
	else if (errno == EMSGSIZE)
	{
	    todo >>= 1;
	}
#endif
	else
	{
	    if (oc->trans_conn)
	    {
		_XSERVTransDisconnect(oc->trans_conn);
		_XSERVTransClose(oc->trans_conn);
		oc->trans_conn = NULL;
	    }
	    MarkClientException(who);
	    oco->count = 0;
	    return -1;
	}
    }

    /* everything was flushed out */
    oco->count = 0;
    /* check to see if this client was write blocked */
    if (AnyClientsWriteBlocked)
    {
	FD_CLR(oc->fd, &ClientsWriteBlocked);
 	if (! XFD_ANYSET(&ClientsWriteBlocked))
	    AnyClientsWriteBlocked = FALSE;
    }
    if (oco->size > BUFWATERMARK)
    {
	free(oco->buf);
	free(oco);
    }
    else
    {
	oco->next = FreeOutputs;
	FreeOutputs = oco;
    }
    oc->output = (ConnectionOutputPtr)NULL;
    return extraCount; /* return only the amount explicitly requested */
}

static ConnectionInputPtr
AllocateInputBuffer(void)
{
    ConnectionInputPtr oci;

    oci = malloc(sizeof(ConnectionInput));
    if (!oci)
	return NULL;
    oci->buffer = malloc(BUFSIZE);
    if (!oci->buffer)
    {
	free(oci);
	return NULL;
    }
    oci->size = BUFSIZE;
    oci->bufptr = oci->buffer;
    oci->bufcnt = 0;
    oci->lenLastReq = 0;
    oci->ignoreBytes = 0;
    return oci;
}

static ConnectionOutputPtr
AllocateOutputBuffer(void)
{
    ConnectionOutputPtr oco;

    oco = malloc(sizeof(ConnectionOutput));
    if (!oco)
	return NULL;
    oco->buf = calloc(1, BUFSIZE);
    if (!oco->buf)
    {
	free(oco);
	return NULL;
    }
    oco->size = BUFSIZE;
    oco->count = 0;
    return oco;
}

void
FreeOsBuffers(OsCommPtr oc)
{
    ConnectionInputPtr oci;
    ConnectionOutputPtr oco;

    if (AvailableInput == oc)
	AvailableInput = (OsCommPtr)NULL;
    if ((oci = oc->input))
    {
	if (FreeInputs)
	{
	    free(oci->buffer);
	    free(oci);
	}
	else
	{
	    FreeInputs = oci;
	    oci->next = (ConnectionInputPtr)NULL;
	    oci->bufptr = oci->buffer;
	    oci->bufcnt = 0;
	    oci->lenLastReq = 0;
	}
    }
    if ((oco = oc->output))
    {
	if (FreeOutputs)
	{
	    free(oco->buf);
	    free(oco);
	}
	else
	{
	    FreeOutputs = oco;
	    oco->next = (ConnectionOutputPtr)NULL;
	    oco->count = 0;
	}
    }
}

void
ResetOsBuffers(void)
{
    ConnectionInputPtr oci;
    ConnectionOutputPtr oco;

    while ((oci = FreeInputs))
    {
	FreeInputs = oci->next;
	free(oci->buffer);
	free(oci);
    }
    while ((oco = FreeOutputs))
    {
	FreeOutputs = oco->next;
	free(oco->buf);
	free(oco);
    }
}
/*

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
Copyright 1994 Quarterdeck Office Systems.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital and
Quarterdeck not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

DIGITAL AND QUARTERDECK DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT
OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
OR PERFORMANCE OF THIS SOFTWARE.

*/

/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/Xos.h>
#include <stdio.h>
#include <time.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <stdlib.h>	/* for malloc() */
#include <errno.h>

#include "input.h"
#include "site.h"
#include "opaque.h"

#ifdef WIN32
#include <process.h>
#define getpid(x) _getpid(x)
#endif

#ifdef XF86BIGFONT
#include "xf86bigfontsrv.h"
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wformat-nonliteral"
#endif

#ifdef DDXOSVERRORF
void (*OsVendorVErrorFProc)(const char *, va_list args) = NULL;
#endif

static FILE *logFile = NULL;
static Bool logFlush = FALSE;
static Bool logSync = FALSE;
static int logVerbosity = DEFAULT_LOG_VERBOSITY;
static int logFileVerbosity = DEFAULT_LOG_FILE_VERBOSITY;

/* Buffer to information logged before the log file is opened. */
static char *saveBuffer = NULL;
static int bufferSize = 0, bufferUnused = 0, bufferPos = 0;
static Bool needBuffer = TRUE;

#ifdef __APPLE__
#include <AvailabilityMacros.h>

static char __crashreporter_info_buff__[4096] = {0};
static const char *__crashreporter_info__ __attribute__((__used__)) = &__crashreporter_info_buff__[0];
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
// This is actually a toolchain requirement, but I'm not sure the correct check,        
// but it should be fine to just only include it for Leopard and later.  This line
// just tells the linker to never strip this symbol (such as for space optimization)
asm (".desc ___crashreporter_info__, 0x10");
#endif
#endif

/* Prefix strings for log messages. */
#ifndef X_UNKNOWN_STRING
#define X_UNKNOWN_STRING		"(\?\?)"
#endif
#ifndef X_PROBE_STRING
#define X_PROBE_STRING			"(--)"
#endif
#ifndef X_CONFIG_STRING
#define X_CONFIG_STRING			"(**)"
#endif
#ifndef X_DEFAULT_STRING
#define X_DEFAULT_STRING		"(==)"
#endif
#ifndef X_CMDLINE_STRING
#define X_CMDLINE_STRING		"(++)"
#endif
#ifndef X_NOTICE_STRING
#define X_NOTICE_STRING			"(!!)"
#endif
#ifndef X_ERROR_STRING
#define X_ERROR_STRING			"(EE)"
#endif
#ifndef X_WARNING_STRING
#define X_WARNING_STRING		"(WW)"
#endif
#ifndef X_INFO_STRING
#define X_INFO_STRING			"(II)"
#endif
#ifndef X_NOT_IMPLEMENTED_STRING
#define X_NOT_IMPLEMENTED_STRING	"(NI)"
#endif

/*
 * LogInit is called to start logging to a file.  It is also called (with
 * NULL arguments) when logging to a file is not wanted.  It must always be
 * called, otherwise log messages will continue to accumulate in a buffer.
 *
 * %s, if present in the fname or backup strings, is expanded to the display
 * string.
 */

const char *
LogInit(const char *fname, const char *backup)
{
    char *logFileName = NULL;

    if (fname && *fname) {
	if (asprintf(&logFileName, fname, display) == -1)
	    FatalError("Cannot allocate space for the log file name\n");

	if (backup && *backup) {
	    struct stat buf;

	    if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {
		char *suffix;
		char *oldLog;

		if ((asprintf(&suffix, backup, display) == -1) ||
		    (asprintf(&oldLog, "%s%s", logFileName, suffix) == -1))
		    FatalError("Cannot allocate space for the log file name\n");
		free(suffix);
		if (rename(logFileName, oldLog) == -1) {
		    FatalError("Cannot move old log file \"%s\" to \"%s\"\n",
			       logFileName, oldLog);
		}
		free(oldLog);
	    }
	}
	if ((logFile = fopen(logFileName, "w")) == NULL)
	    FatalError("Cannot open log file \"%s\"\n", logFileName);
	setvbuf(logFile, NULL, _IONBF, 0);

	/* Flush saved log information. */
	if (saveBuffer && bufferSize > 0) {
	    fwrite(saveBuffer, bufferPos, 1, logFile);
	    fflush(logFile);
#ifndef WIN32
	    fsync(fileno(logFile));
#endif
	}
    }

    /*
     * Unconditionally free the buffer, and flag that the buffer is no longer
     * needed.
     */
    if (saveBuffer && bufferSize > 0) {
	free(saveBuffer);	/* Must be free(), not free() */
	saveBuffer = NULL;
	bufferSize = 0;
    }
    needBuffer = FALSE;

    return logFileName;
}

void
LogClose(enum ExitCode error)
{
    if (logFile) {
	ErrorF("Server terminated %s (%d). Closing log file.\n",
		(error == EXIT_NO_ERROR) ? "successfully" : "with error", error);
	fclose(logFile);
	logFile = NULL;
    }
}

Bool
LogSetParameter(LogParameter param, int value)
{
    switch (param) {
    case XLOG_FLUSH:
	logFlush = value ? TRUE : FALSE;
	return TRUE;
    case XLOG_SYNC:
	logSync = value ? TRUE : FALSE;
	return TRUE;
    case XLOG_VERBOSITY:
	logVerbosity = value;
	return TRUE;
    case XLOG_FILE_VERBOSITY:
	logFileVerbosity = value;
	return TRUE;
    default:
	return FALSE;
    }
}

/* This function does the actual log message writes. */

void
LogVWrite(int verb, const char *f, va_list args)
{
    static char tmpBuffer[1024];
    int len = 0;
    static Bool newline = TRUE;

    if (newline) {
	sprintf(tmpBuffer, "[%10.3f] ", GetTimeInMillis() / 1000.0);
	len = strlen(tmpBuffer);
	if (logFile)
	    fwrite(tmpBuffer, len, 1, logFile);
    }

    /*
     * Since a va_list can only be processed once, write the string to a
     * buffer, and then write the buffer out to the appropriate output
     * stream(s).
     */
    if (verb < 0 || logFileVerbosity >= verb || logVerbosity >= verb) {
	vsnprintf(tmpBuffer, sizeof(tmpBuffer), f, args);
	len = strlen(tmpBuffer);
    }
    newline = (tmpBuffer[len-1] == '\n');
    if ((verb < 0 || logVerbosity >= verb) && len > 0)
	fwrite(tmpBuffer, len, 1, stderr);
    if ((verb < 0 || logFileVerbosity >= verb) && len > 0) {
	if (logFile) {
	    fwrite(tmpBuffer, len, 1, logFile);
	    if (logFlush) {
		fflush(logFile);
#ifndef WIN32
		if (logSync)
		    fsync(fileno(logFile));
#endif
	    }
	} else if (needBuffer) {
	    if (len > bufferUnused) {
		bufferSize += 1024;
		bufferUnused += 1024;
		saveBuffer = realloc(saveBuffer, bufferSize);
		if (!saveBuffer)
		    FatalError("realloc() failed while saving log messages\n");
	    }
	    bufferUnused -= len;
	    memcpy(saveBuffer + bufferPos, tmpBuffer, len);
	    bufferPos += len;
	}
    }
}

void
LogWrite(int verb, const char *f, ...)
{
    va_list args;

    va_start(args, f);
    LogVWrite(verb, f, args);
    va_end(args);
}

void
LogVMessageVerb(MessageType type, int verb, const char *format, va_list args)
{
    const char *s  = X_UNKNOWN_STRING;
    char tmpBuf[1024];

    /* Ignore verbosity for X_ERROR */
    if (logVerbosity >= verb || logFileVerbosity >= verb || type == X_ERROR) {
	switch (type) {
	case X_PROBED:
	    s = X_PROBE_STRING;
	    break;
	case X_CONFIG:
	    s = X_CONFIG_STRING;
	    break;
	case X_DEFAULT:
	    s = X_DEFAULT_STRING;
	    break;
	case X_CMDLINE:
	    s = X_CMDLINE_STRING;
	    break;
	case X_NOTICE:
	    s = X_NOTICE_STRING;
	    break;
	case X_ERROR:
	    s = X_ERROR_STRING;
	    if (verb > 0)
		verb = 0;
	    break;
	case X_WARNING:
	    s = X_WARNING_STRING;
	    break;
	case X_INFO:
	    s = X_INFO_STRING;
	    break;
	case X_NOT_IMPLEMENTED:
	    s = X_NOT_IMPLEMENTED_STRING;
	    break;
	case X_UNKNOWN:
	    s = X_UNKNOWN_STRING;
	    break;
	case X_NONE:
	    s = NULL;
	    break;
	}

        /* if s is not NULL we need a space before format */
        snprintf(tmpBuf, sizeof(tmpBuf), "%s%s%s", s ? s : "",
                                                   s ? " " : "",
                                                   format);
        LogVWrite(verb, tmpBuf, args);
    }
}

/* Log message with verbosity level specified. */
void
LogMessageVerb(MessageType type, int verb, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    LogVMessageVerb(type, verb, format, ap);
    va_end(ap);
}

/* Log a message with the standard verbosity level of 1. */
void
LogMessage(MessageType type, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    LogVMessageVerb(type, 1, format, ap);
    va_end(ap);
}

void
AbortServer(void) _X_NORETURN;

void
AbortServer(void)
{
#ifdef XF86BIGFONT
    XF86BigfontCleanup();
#endif
    CloseWellKnownConnections();
    OsCleanup(TRUE);
    CloseDownDevices();
    AbortDDX(EXIT_ERR_ABORT);
    fflush(stderr);
    if (CoreDump)
	OsAbort();
    exit (1);
}

#define AUDIT_PREFIX "AUDIT: %s: %ld: "
#ifndef AUDIT_TIMEOUT
#define AUDIT_TIMEOUT ((CARD32)(120 * 1000)) /* 2 mn */
#endif

static int nrepeat = 0;
static int oldlen = -1;
static OsTimerPtr auditTimer = NULL;

void
FreeAuditTimer(void)
{
    if (auditTimer != NULL) {
	/* Force output of pending messages */
	TimerForce(auditTimer);
	TimerFree(auditTimer);
	auditTimer = NULL;
    }
}

static char *
AuditPrefix(void)
{
    time_t tm;
    char *autime, *s;
    char *tmpBuf;
    int len;

    time(&tm);
    autime = ctime(&tm);
    if ((s = strchr(autime, '\n')))
	*s = '\0';
    len = strlen(AUDIT_PREFIX) + strlen(autime) + 10 + 1;
    tmpBuf = malloc(len);
    if (!tmpBuf)
	return NULL;
    snprintf(tmpBuf, len, AUDIT_PREFIX, autime, (unsigned long)getpid());
    return tmpBuf;
}

void
AuditF(const char * f, ...)
{
    va_list args;

    va_start(args, f);

    VAuditF(f, args);
    va_end(args);
}

static CARD32
AuditFlush(OsTimerPtr timer, CARD32 now, pointer arg)
{
    char *prefix;

    if (nrepeat > 0) {
	prefix = AuditPrefix();
	ErrorF("%slast message repeated %d times\n",
	       prefix != NULL ? prefix : "", nrepeat);
	nrepeat = 0;
	free(prefix);
	return AUDIT_TIMEOUT;
    } else {
	/* if the timer expires without anything to print, flush the message */
	oldlen = -1;
	return 0;
    }
}

void
VAuditF(const char *f, va_list args)
{
    char *prefix;
    char buf[1024];
    int len;
    static char oldbuf[1024];

    prefix = AuditPrefix();
    len = vsnprintf(buf, sizeof(buf), f, args);

    if (len == oldlen && strcmp(buf, oldbuf) == 0) {
	/* Message already seen */
	nrepeat++;
    } else {
	/* new message */
	if (auditTimer != NULL)
	    TimerForce(auditTimer);
	ErrorF("%s%s", prefix != NULL ? prefix : "", buf);
	strlcpy(oldbuf, buf, sizeof(oldbuf));
	oldlen = len;
	nrepeat = 0;
	auditTimer = TimerSet(auditTimer, 0, AUDIT_TIMEOUT, AuditFlush, NULL);
    }
    free(prefix);
}

void
FatalError(const char *f, ...)
{
    va_list args;
    static Bool beenhere = FALSE;

    if (beenhere)
	ErrorF("\nFatalError re-entered, aborting\n");
    else
	ErrorF("\nFatal server error:\n");

    va_start(args, f);
#ifdef __APPLE__
    {
        va_list args2;
        va_copy(args2, args);
        (void)vsnprintf(__crashreporter_info_buff__, sizeof(__crashreporter_info_buff__), f, args2);
        va_end(args2);
    }
#endif
    VErrorF(f, args);
    va_end(args);
    ErrorF("\n");
    if (!beenhere)
	OsVendorFatalError();
    if (!beenhere) {
	beenhere = TRUE;
	AbortServer();
    } else
	OsAbort();
    /*NOTREACHED*/
}

void
VErrorF(const char *f, va_list args)
{
#ifdef DDXOSVERRORF
    if (OsVendorVErrorFProc)
	OsVendorVErrorFProc(f, args);
    else
	LogVWrite(-1, f, args);
#else
    LogVWrite(-1, f, args);
#endif
}

void
ErrorF(const char * f, ...)
{
    va_list args;

    va_start(args, f);
    VErrorF(f, args);
    va_end(args);
}

/* A perror() workalike. */

void
Error(const char *str)
{
    const char *err = strerror(errno);

    if (str)
	LogWrite(-1, "%s: %s", str, err);
    else
	LogWrite(-1, "%s", err);
}

void
LogPrintMarkers(void)
{
    /* Show what the message marker symbols mean. */
    LogWrite(0, "Markers: ");
    LogMessageVerb(X_PROBED, 0, "probed, ");
    LogMessageVerb(X_CONFIG, 0, "from config file, ");
    LogMessageVerb(X_DEFAULT, 0, "default setting,\n\t");
    LogMessageVerb(X_CMDLINE, 0, "from command line, ");
    LogMessageVerb(X_NOTICE, 0, "notice, ");
    LogMessageVerb(X_INFO, 0, "informational,\n\t");
    LogMessageVerb(X_WARNING, 0, "warning, ");
    LogMessageVerb(X_ERROR, 0, "error, ");
    LogMessageVerb(X_NOT_IMPLEMENTED, 0, "not implemented, ");
    LogMessageVerb(X_UNKNOWN, 0, "unknown.\n");
}

noinst_LTLIBRARIES = libos.la

AM_CFLAGS = $(DIX_CFLAGS) $(SHA1_CFLAGS)

SECURERPC_SRCS = rpcauth.c
XDMCP_SRCS = xdmcp.c
STRLCAT_SRCS = strlcat.c strlcpy.c
XORG_SRCS = log.c

libos_la_SOURCES = 	\
	WaitFor.c	\
	access.c	\
	auth.c		\
	backtrace.c	\
	client.c	\
	connection.c	\
	io.c		\
	mitauth.c	\
	oscolor.c	\
	osdep.h		\
	osinit.c	\
	utils.c		\
	strcasecmp.c	\
	strcasestr.c	\
	xdmauth.c	\
	xsha1.c		\
	xstrans.c	\
	xprintf.c	\
	$(XORG_SRCS)
libos_la_LIBADD = @SHA1_LIBS@ $(DLOPEN_LIBS)

if SECURE_RPC
libos_la_SOURCES += $(SECURERPC_SRCS)
endif

if XDMCP
libos_la_SOURCES += $(XDMCP_SRCS)
endif

if NEED_STRLCAT
libos_la_SOURCES += $(STRLCAT_SRCS)
endif

EXTRA_DIST = $(SECURERPC_SRCS) $(INTERNALMALLOC_SRCS) \
     $(XDMCP_SRCS) $(STRLCAT_SRCS)

if SPECIAL_DTRACE_OBJECTS
# Generate dtrace object code for probes in libos & libdix
dtrace.o: $(top_srcdir)/dix/Xserver.d $(am_libos_la_OBJECTS)
	$(AM_V_GEN)$(DTRACE) -G -C -o $@ -s $(top_srcdir)/dix/Xserver.d .libs/*.o ../dix/.libs/*.o

noinst_PROGRAMS = os.O

os_O_SOURCES =
os.O: dtrace.o $(am_libos_la_OBJECTS)
	$(AM_V_GEN)ld -r -o $@ dtrace.o .libs/*.o
endif
/*

Copyright 1988, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*
 * MIT-MAGIC-COOKIE-1 authorization scheme
 * Author:  Keith Packard, MIT X Consortium
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include "os.h"
#include "osdep.h"
#include "dixstruct.h"

static struct auth {
    struct auth	*next;
    unsigned short	len;
    char	*data;
    XID		id;
} *mit_auth;

int
MitAddCookie (
    unsigned short	data_length,
    const char		*data,
    XID			id)
{
    struct auth	*new;

    new = malloc(sizeof (struct auth));
    if (!new)
	return 0;
    new->data = malloc((unsigned) data_length);
    if (!new->data) {
	free(new);
	return 0;
    }
    new->next = mit_auth;
    mit_auth = new;
    memmove(new->data, data, (int) data_length);
    new->len = data_length;
    new->id = id;
    return 1;
}

XID
MitCheckCookie (
    unsigned short	data_length,
    const char		*data,
    ClientPtr		client,
    char		**reason)
{
    struct auth	*auth;

    for (auth = mit_auth; auth; auth=auth->next) {
        if (data_length == auth->len &&
	   memcmp (data, auth->data, (int) data_length) == 0)
	    return auth->id;
    }
    *reason = "Invalid MIT-MAGIC-COOKIE-1 key";
    return (XID) -1;
}

int
MitResetCookie (void)
{
    struct auth	*auth, *next;

    for (auth = mit_auth; auth; auth=next) {
	next = auth->next;
	free(auth->data);
	free(auth);
    }
    mit_auth = 0;
    return 0;
}

XID
MitToID (
	unsigned short	data_length,
	char		*data)
{
    struct auth	*auth;

    for (auth = mit_auth; auth; auth=auth->next) {
	if (data_length == auth->len &&
	    memcmp (data, auth->data, data_length) == 0)
	    return auth->id;
    }
    return (XID) -1;
}

int
MitFromID (
	XID		id,
	unsigned short	*data_lenp,
	char		**datap)
{
    struct auth	*auth;

    for (auth = mit_auth; auth; auth=auth->next) {
	if (id == auth->id) {
	    *data_lenp = auth->len;
	    *datap = auth->data;
	    return 1;
	}
    }
    return 0;
}

int
MitRemoveCookie (
	unsigned short	data_length,
	const char	*data)
{
    struct auth	*auth, *prev;

    prev = 0;
    for (auth = mit_auth; auth; prev = auth, auth=auth->next) {
	if (data_length == auth->len &&
	    memcmp (data, auth->data, data_length) == 0)
 	{
	    if (prev)
		prev->next = auth->next;
	    else
		mit_auth = auth->next;
	    free(auth->data);
	    free(auth);
	    return 1;
	}
    }
    return 0;
}

#ifdef XCSECURITY

static char cookie[16]; /* 128 bits */

XID
MitGenerateCookie (
    unsigned	data_length,
    const char	*data,
    XID		id,
    unsigned	*data_length_return,
    char	**data_return)
{
    int i = 0;
    int status;

    while (data_length--)
    {
	cookie[i++] += *data++;
	if (i >= sizeof (cookie)) i = 0;
    }
    GenerateRandomData(sizeof (cookie), cookie);
    status = MitAddCookie(sizeof (cookie), cookie, id);
    if (!status)
    {
	id = -1;
    }
    else
    {
	*data_return = cookie;
	*data_length_return = sizeof (cookie);
    }
    return id;
}

#endif /* XCSECURITY */
/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/keysym.h>
#include "os.h"

typedef struct _builtinColor {
    unsigned char	red;
    unsigned char	green;
    unsigned char	blue;
    unsigned short	name;
} BuiltinColor;

static const char BuiltinColorNames[] = {
    "alice blue\0"
    "AliceBlue\0"
    "antique white\0"
    "AntiqueWhite\0"
    "AntiqueWhite1\0"
    "AntiqueWhite2\0"
    "AntiqueWhite3\0"
    "AntiqueWhite4\0"
    "aquamarine\0"
    "aquamarine1\0"
    "aquamarine2\0"
    "aquamarine3\0"
    "aquamarine4\0"
    "azure\0"
    "azure1\0"
    "azure2\0"
    "azure3\0"
    "azure4\0"
    "beige\0"
    "bisque\0"
    "bisque1\0"
    "bisque2\0"
    "bisque3\0"
    "bisque4\0"
    "black\0"
    "blanched almond\0"
    "BlanchedAlmond\0"
    "blue\0"
    "blue violet\0"
    "blue1\0"
    "blue2\0"
    "blue3\0"
    "blue4\0"
    "BlueViolet\0"
    "brown\0"
    "brown1\0"
    "brown2\0"
    "brown3\0"
    "brown4\0"
    "burlywood\0"
    "burlywood1\0"
    "burlywood2\0"
    "burlywood3\0"
    "burlywood4\0"
    "cadet blue\0"
    "CadetBlue\0"
    "CadetBlue1\0"
    "CadetBlue2\0"
    "CadetBlue3\0"
    "CadetBlue4\0"
    "chartreuse\0"
    "chartreuse1\0"
    "chartreuse2\0"
    "chartreuse3\0"
    "chartreuse4\0"
    "chocolate\0"
    "chocolate1\0"
    "chocolate2\0"
    "chocolate3\0"
    "chocolate4\0"
    "coral\0"
    "coral1\0"
    "coral2\0"
    "coral3\0"
    "coral4\0"
    "cornflower blue\0"
    "CornflowerBlue\0"
    "cornsilk\0"
    "cornsilk1\0"
    "cornsilk2\0"
    "cornsilk3\0"
    "cornsilk4\0"
    "cyan\0"
    "cyan1\0"
    "cyan2\0"
    "cyan3\0"
    "cyan4\0"
    "dark blue\0"
    "dark cyan\0"
    "dark goldenrod\0"
    "dark gray\0"
    "dark green\0"
    "dark grey\0"
    "dark khaki\0"
    "dark magenta\0"
    "dark olive green\0"
    "dark orange\0"
    "dark orchid\0"
    "dark red\0"
    "dark salmon\0"
    "dark sea green\0"
    "dark slate blue\0"
    "dark slate gray\0"
    "dark slate grey\0"
    "dark turquoise\0"
    "dark violet\0"
    "DarkBlue\0"
    "DarkCyan\0"
    "DarkGoldenrod\0"
    "DarkGoldenrod1\0"
    "DarkGoldenrod2\0"
    "DarkGoldenrod3\0"
    "DarkGoldenrod4\0"
    "DarkGray\0"
    "DarkGreen\0"
    "DarkGrey\0"
    "DarkKhaki\0"
    "DarkMagenta\0"
    "DarkOliveGreen\0"
    "DarkOliveGreen1\0"
    "DarkOliveGreen2\0"
    "DarkOliveGreen3\0"
    "DarkOliveGreen4\0"
    "DarkOrange\0"
    "DarkOrange1\0"
    "DarkOrange2\0"
    "DarkOrange3\0"
    "DarkOrange4\0"
    "DarkOrchid\0"
    "DarkOrchid1\0"
    "DarkOrchid2\0"
    "DarkOrchid3\0"
    "DarkOrchid4\0"
    "DarkRed\0"
    "DarkSalmon\0"
    "DarkSeaGreen\0"
    "DarkSeaGreen1\0"
    "DarkSeaGreen2\0"
    "DarkSeaGreen3\0"
    "DarkSeaGreen4\0"
    "DarkSlateBlue\0"
    "DarkSlateGray\0"
    "DarkSlateGray1\0"
    "DarkSlateGray2\0"
    "DarkSlateGray3\0"
    "DarkSlateGray4\0"
    "DarkSlateGrey\0"
    "DarkTurquoise\0"
    "DarkViolet\0"
    "deep pink\0"
    "deep sky blue\0"
    "DeepPink\0"
    "DeepPink1\0"
    "DeepPink2\0"
    "DeepPink3\0"
    "DeepPink4\0"
    "DeepSkyBlue\0"
    "DeepSkyBlue1\0"
    "DeepSkyBlue2\0"
    "DeepSkyBlue3\0"
    "DeepSkyBlue4\0"
    "dim gray\0"
    "dim grey\0"
    "DimGray\0"
    "DimGrey\0"
    "dodger blue\0"
    "DodgerBlue\0"
    "DodgerBlue1\0"
    "DodgerBlue2\0"
    "DodgerBlue3\0"
    "DodgerBlue4\0"
    "firebrick\0"
    "firebrick1\0"
    "firebrick2\0"
    "firebrick3\0"
    "firebrick4\0"
    "floral white\0"
    "FloralWhite\0"
    "forest green\0"
    "ForestGreen\0"
    "gainsboro\0"
    "ghost white\0"
    "GhostWhite\0"
    "gold\0"
    "gold1\0"
    "gold2\0"
    "gold3\0"
    "gold4\0"
    "goldenrod\0"
    "goldenrod1\0"
    "goldenrod2\0"
    "goldenrod3\0"
    "goldenrod4\0"
    "gray\0"
    "gray0\0"
    "gray1\0"
    "gray10\0"
    "gray100\0"
    "gray11\0"
    "gray12\0"
    "gray13\0"
    "gray14\0"
    "gray15\0"
    "gray16\0"
    "gray17\0"
    "gray18\0"
    "gray19\0"
    "gray2\0"
    "gray20\0"
    "gray21\0"
    "gray22\0"
    "gray23\0"
    "gray24\0"
    "gray25\0"
    "gray26\0"
    "gray27\0"
    "gray28\0"
    "gray29\0"
    "gray3\0"
    "gray30\0"
    "gray31\0"
    "gray32\0"
    "gray33\0"
    "gray34\0"
    "gray35\0"
    "gray36\0"
    "gray37\0"
    "gray38\0"
    "gray39\0"
    "gray4\0"
    "gray40\0"
    "gray41\0"
    "gray42\0"
    "gray43\0"
    "gray44\0"
    "gray45\0"
    "gray46\0"
    "gray47\0"
    "gray48\0"
    "gray49\0"
    "gray5\0"
    "gray50\0"
    "gray51\0"
    "gray52\0"
    "gray53\0"
    "gray54\0"
    "gray55\0"
    "gray56\0"
    "gray57\0"
    "gray58\0"
    "gray59\0"
    "gray6\0"
    "gray60\0"
    "gray61\0"
    "gray62\0"
    "gray63\0"
    "gray64\0"
    "gray65\0"
    "gray66\0"
    "gray67\0"
    "gray68\0"
    "gray69\0"
    "gray7\0"
    "gray70\0"
    "gray71\0"
    "gray72\0"
    "gray73\0"
    "gray74\0"
    "gray75\0"
    "gray76\0"
    "gray77\0"
    "gray78\0"
    "gray79\0"
    "gray8\0"
    "gray80\0"
    "gray81\0"
    "gray82\0"
    "gray83\0"
    "gray84\0"
    "gray85\0"
    "gray86\0"
    "gray87\0"
    "gray88\0"
    "gray89\0"
    "gray9\0"
    "gray90\0"
    "gray91\0"
    "gray92\0"
    "gray93\0"
    "gray94\0"
    "gray95\0"
    "gray96\0"
    "gray97\0"
    "gray98\0"
    "gray99\0"
    "green\0"
    "green yellow\0"
    "green1\0"
    "green2\0"
    "green3\0"
    "green4\0"
    "GreenYellow\0"
    "grey\0"
    "grey0\0"
    "grey1\0"
    "grey10\0"
    "grey100\0"
    "grey11\0"
    "grey12\0"
    "grey13\0"
    "grey14\0"
    "grey15\0"
    "grey16\0"
    "grey17\0"
    "grey18\0"
    "grey19\0"
    "grey2\0"
    "grey20\0"
    "grey21\0"
    "grey22\0"
    "grey23\0"
    "grey24\0"
    "grey25\0"
    "grey26\0"
    "grey27\0"
    "grey28\0"
    "grey29\0"
    "grey3\0"
    "grey30\0"
    "grey31\0"
    "grey32\0"
    "grey33\0"
    "grey34\0"
    "grey35\0"
    "grey36\0"
    "grey37\0"
    "grey38\0"
    "grey39\0"
    "grey4\0"
    "grey40\0"
    "grey41\0"
    "grey42\0"
    "grey43\0"
    "grey44\0"
    "grey45\0"
    "grey46\0"
    "grey47\0"
    "grey48\0"
    "grey49\0"
    "grey5\0"
    "grey50\0"
    "grey51\0"
    "grey52\0"
    "grey53\0"
    "grey54\0"
    "grey55\0"
    "grey56\0"
    "grey57\0"
    "grey58\0"
    "grey59\0"
    "grey6\0"
    "grey60\0"
    "grey61\0"
    "grey62\0"
    "grey63\0"
    "grey64\0"
    "grey65\0"
    "grey66\0"
    "grey67\0"
    "grey68\0"
    "grey69\0"
    "grey7\0"
    "grey70\0"
    "grey71\0"
    "grey72\0"
    "grey73\0"
    "grey74\0"
    "grey75\0"
    "grey76\0"
    "grey77\0"
    "grey78\0"
    "grey79\0"
    "grey8\0"
    "grey80\0"
    "grey81\0"
    "grey82\0"
    "grey83\0"
    "grey84\0"
    "grey85\0"
    "grey86\0"
    "grey87\0"
    "grey88\0"
    "grey89\0"
    "grey9\0"
    "grey90\0"
    "grey91\0"
    "grey92\0"
    "grey93\0"
    "grey94\0"
    "grey95\0"
    "grey96\0"
    "grey97\0"
    "grey98\0"
    "grey99\0"
    "honeydew\0"
    "honeydew1\0"
    "honeydew2\0"
    "honeydew3\0"
    "honeydew4\0"
    "hot pink\0"
    "HotPink\0"
    "HotPink1\0"
    "HotPink2\0"
    "HotPink3\0"
    "HotPink4\0"
    "indian red\0"
    "IndianRed\0"
    "IndianRed1\0"
    "IndianRed2\0"
    "IndianRed3\0"
    "IndianRed4\0"
    "ivory\0"
    "ivory1\0"
    "ivory2\0"
    "ivory3\0"
    "ivory4\0"
    "khaki\0"
    "khaki1\0"
    "khaki2\0"
    "khaki3\0"
    "khaki4\0"
    "lavender\0"
    "lavender blush\0"
    "LavenderBlush\0"
    "LavenderBlush1\0"
    "LavenderBlush2\0"
    "LavenderBlush3\0"
    "LavenderBlush4\0"
    "lawn green\0"
    "LawnGreen\0"
    "lemon chiffon\0"
    "LemonChiffon\0"
    "LemonChiffon1\0"
    "LemonChiffon2\0"
    "LemonChiffon3\0"
    "LemonChiffon4\0"
    "light blue\0"
    "light coral\0"
    "light cyan\0"
    "light goldenrod\0"
    "light goldenrod yellow\0"
    "light gray\0"
    "light green\0"
    "light grey\0"
    "light pink\0"
    "light salmon\0"
    "light sea green\0"
    "light sky blue\0"
    "light slate blue\0"
    "light slate gray\0"
    "light slate grey\0"
    "light steel blue\0"
    "light yellow\0"
    "LightBlue\0"
    "LightBlue1\0"
    "LightBlue2\0"
    "LightBlue3\0"
    "LightBlue4\0"
    "LightCoral\0"
    "LightCyan\0"
    "LightCyan1\0"
    "LightCyan2\0"
    "LightCyan3\0"
    "LightCyan4\0"
    "LightGoldenrod\0"
    "LightGoldenrod1\0"
    "LightGoldenrod2\0"
    "LightGoldenrod3\0"
    "LightGoldenrod4\0"
    "LightGoldenrodYellow\0"
    "LightGray\0"
    "LightGreen\0"
    "LightGrey\0"
    "LightPink\0"
    "LightPink1\0"
    "LightPink2\0"
    "LightPink3\0"
    "LightPink4\0"
    "LightSalmon\0"
    "LightSalmon1\0"
    "LightSalmon2\0"
    "LightSalmon3\0"
    "LightSalmon4\0"
    "LightSeaGreen\0"
    "LightSkyBlue\0"
    "LightSkyBlue1\0"
    "LightSkyBlue2\0"
    "LightSkyBlue3\0"
    "LightSkyBlue4\0"
    "LightSlateBlue\0"
    "LightSlateGray\0"
    "LightSlateGrey\0"
    "LightSteelBlue\0"
    "LightSteelBlue1\0"
    "LightSteelBlue2\0"
    "LightSteelBlue3\0"
    "LightSteelBlue4\0"
    "LightYellow\0"
    "LightYellow1\0"
    "LightYellow2\0"
    "LightYellow3\0"
    "LightYellow4\0"
    "lime green\0"
    "LimeGreen\0"
    "linen\0"
    "magenta\0"
    "magenta1\0"
    "magenta2\0"
    "magenta3\0"
    "magenta4\0"
    "maroon\0"
    "maroon1\0"
    "maroon2\0"
    "maroon3\0"
    "maroon4\0"
    "medium aquamarine\0"
    "medium blue\0"
    "medium orchid\0"
    "medium purple\0"
    "medium sea green\0"
    "medium slate blue\0"
    "medium spring green\0"
    "medium turquoise\0"
    "medium violet red\0"
    "MediumAquamarine\0"
    "MediumBlue\0"
    "MediumOrchid\0"
    "MediumOrchid1\0"
    "MediumOrchid2\0"
    "MediumOrchid3\0"
    "MediumOrchid4\0"
    "MediumPurple\0"
    "MediumPurple1\0"
    "MediumPurple2\0"
    "MediumPurple3\0"
    "MediumPurple4\0"
    "MediumSeaGreen\0"
    "MediumSlateBlue\0"
    "MediumSpringGreen\0"
    "MediumTurquoise\0"
    "MediumVioletRed\0"
    "midnight blue\0"
    "MidnightBlue\0"
    "mint cream\0"
    "MintCream\0"
    "misty rose\0"
    "MistyRose\0"
    "MistyRose1\0"
    "MistyRose2\0"
    "MistyRose3\0"
    "MistyRose4\0"
    "moccasin\0"
    "navajo white\0"
    "NavajoWhite\0"
    "NavajoWhite1\0"
    "NavajoWhite2\0"
    "NavajoWhite3\0"
    "NavajoWhite4\0"
    "navy\0"
    "navy blue\0"
    "NavyBlue\0"
    "old lace\0"
    "OldLace\0"
    "olive drab\0"
    "OliveDrab\0"
    "OliveDrab1\0"
    "OliveDrab2\0"
    "OliveDrab3\0"
    "OliveDrab4\0"
    "orange\0"
    "orange red\0"
    "orange1\0"
    "orange2\0"
    "orange3\0"
    "orange4\0"
    "OrangeRed\0"
    "OrangeRed1\0"
    "OrangeRed2\0"
    "OrangeRed3\0"
    "OrangeRed4\0"
    "orchid\0"
    "orchid1\0"
    "orchid2\0"
    "orchid3\0"
    "orchid4\0"
    "pale goldenrod\0"
    "pale green\0"
    "pale turquoise\0"
    "pale violet red\0"
    "PaleGoldenrod\0"
    "PaleGreen\0"
    "PaleGreen1\0"
    "PaleGreen2\0"
    "PaleGreen3\0"
    "PaleGreen4\0"
    "PaleTurquoise\0"
    "PaleTurquoise1\0"
    "PaleTurquoise2\0"
    "PaleTurquoise3\0"
    "PaleTurquoise4\0"
    "PaleVioletRed\0"
    "PaleVioletRed1\0"
    "PaleVioletRed2\0"
    "PaleVioletRed3\0"
    "PaleVioletRed4\0"
    "papaya whip\0"
    "PapayaWhip\0"
    "peach puff\0"
    "PeachPuff\0"
    "PeachPuff1\0"
    "PeachPuff2\0"
    "PeachPuff3\0"
    "PeachPuff4\0"
    "peru\0"
    "pink\0"
    "pink1\0"
    "pink2\0"
    "pink3\0"
    "pink4\0"
    "plum\0"
    "plum1\0"
    "plum2\0"
    "plum3\0"
    "plum4\0"
    "powder blue\0"
    "PowderBlue\0"
    "purple\0"
    "purple1\0"
    "purple2\0"
    "purple3\0"
    "purple4\0"
    "red\0"
    "red1\0"
    "red2\0"
    "red3\0"
    "red4\0"
    "rosy brown\0"
    "RosyBrown\0"
    "RosyBrown1\0"
    "RosyBrown2\0"
    "RosyBrown3\0"
    "RosyBrown4\0"
    "royal blue\0"
    "RoyalBlue\0"
    "RoyalBlue1\0"
    "RoyalBlue2\0"
    "RoyalBlue3\0"
    "RoyalBlue4\0"
    "saddle brown\0"
    "SaddleBrown\0"
    "salmon\0"
    "salmon1\0"
    "salmon2\0"
    "salmon3\0"
    "salmon4\0"
    "sandy brown\0"
    "SandyBrown\0"
    "sea green\0"
    "SeaGreen\0"
    "SeaGreen1\0"
    "SeaGreen2\0"
    "SeaGreen3\0"
    "SeaGreen4\0"
    "seashell\0"
    "seashell1\0"
    "seashell2\0"
    "seashell3\0"
    "seashell4\0"
    "sienna\0"
    "sienna1\0"
    "sienna2\0"
    "sienna3\0"
    "sienna4\0"
    "sky blue\0"
    "SkyBlue\0"
    "SkyBlue1\0"
    "SkyBlue2\0"
    "SkyBlue3\0"
    "SkyBlue4\0"
    "slate blue\0"
    "slate gray\0"
    "slate grey\0"
    "SlateBlue\0"
    "SlateBlue1\0"
    "SlateBlue2\0"
    "SlateBlue3\0"
    "SlateBlue4\0"
    "SlateGray\0"
    "SlateGray1\0"
    "SlateGray2\0"
    "SlateGray3\0"
    "SlateGray4\0"
    "SlateGrey\0"
    "snow\0"
    "snow1\0"
    "snow2\0"
    "snow3\0"
    "snow4\0"
    "spring green\0"
    "SpringGreen\0"
    "SpringGreen1\0"
    "SpringGreen2\0"
    "SpringGreen3\0"
    "SpringGreen4\0"
    "steel blue\0"
    "SteelBlue\0"
    "SteelBlue1\0"
    "SteelBlue2\0"
    "SteelBlue3\0"
    "SteelBlue4\0"
    "tan\0"
    "tan1\0"
    "tan2\0"
    "tan3\0"
    "tan4\0"
    "thistle\0"
    "thistle1\0"
    "thistle2\0"
    "thistle3\0"
    "thistle4\0"
    "tomato\0"
    "tomato1\0"
    "tomato2\0"
    "tomato3\0"
    "tomato4\0"
    "turquoise\0"
    "turquoise1\0"
    "turquoise2\0"
    "turquoise3\0"
    "turquoise4\0"
    "violet\0"
    "violet red\0"
    "VioletRed\0"
    "VioletRed1\0"
    "VioletRed2\0"
    "VioletRed3\0"
    "VioletRed4\0"
    "wheat\0"
    "wheat1\0"
    "wheat2\0"
    "wheat3\0"
    "wheat4\0"
    "white\0"
    "white smoke\0"
    "WhiteSmoke\0"
    "yellow\0"
    "yellow green\0"
    "yellow1\0"
    "yellow2\0"
    "yellow3\0"
    "yellow4\0"
    "YellowGreen\0"
};

static const BuiltinColor BuiltinColors[] = {
    { 240, 248, 255,      0 }, /* alice blue */
    { 240, 248, 255,     11 }, /* AliceBlue */
    { 250, 235, 215,     21 }, /* antique white */
    { 250, 235, 215,     35 }, /* AntiqueWhite */
    { 255, 239, 219,     48 }, /* AntiqueWhite1 */
    { 238, 223, 204,     62 }, /* AntiqueWhite2 */
    { 205, 192, 176,     76 }, /* AntiqueWhite3 */
    { 139, 131, 120,     90 }, /* AntiqueWhite4 */
    { 127, 255, 212,    104 }, /* aquamarine */
    { 127, 255, 212,    115 }, /* aquamarine1 */
    { 118, 238, 198,    127 }, /* aquamarine2 */
    { 102, 205, 170,    139 }, /* aquamarine3 */
    {  69, 139, 116,    151 }, /* aquamarine4 */
    { 240, 255, 255,    163 }, /* azure */
    { 240, 255, 255,    169 }, /* azure1 */
    { 224, 238, 238,    176 }, /* azure2 */
    { 193, 205, 205,    183 }, /* azure3 */
    { 131, 139, 139,    190 }, /* azure4 */
    { 245, 245, 220,    197 }, /* beige */
    { 255, 228, 196,    203 }, /* bisque */
    { 255, 228, 196,    210 }, /* bisque1 */
    { 238, 213, 183,    218 }, /* bisque2 */
    { 205, 183, 158,    226 }, /* bisque3 */
    { 139, 125, 107,    234 }, /* bisque4 */
    {   0,   0,   0,    242 }, /* black */
    { 255, 235, 205,    248 }, /* blanched almond */
    { 255, 235, 205,    264 }, /* BlanchedAlmond */
    {   0,   0, 255,    279 }, /* blue */
    { 138,  43, 226,    284 }, /* blue violet */
    {   0,   0, 255,    296 }, /* blue1 */
    {   0,   0, 238,    302 }, /* blue2 */
    {   0,   0, 205,    308 }, /* blue3 */
    {   0,   0, 139,    314 }, /* blue4 */
    { 138,  43, 226,    320 }, /* BlueViolet */
    { 165,  42,  42,    331 }, /* brown */
    { 255,  64,  64,    337 }, /* brown1 */
    { 238,  59,  59,    344 }, /* brown2 */
    { 205,  51,  51,    351 }, /* brown3 */
    { 139,  35,  35,    358 }, /* brown4 */
    { 222, 184, 135,    365 }, /* burlywood */
    { 255, 211, 155,    375 }, /* burlywood1 */
    { 238, 197, 145,    386 }, /* burlywood2 */
    { 205, 170, 125,    397 }, /* burlywood3 */
    { 139, 115,  85,    408 }, /* burlywood4 */
    {  95, 158, 160,    419 }, /* cadet blue */
    {  95, 158, 160,    430 }, /* CadetBlue */
    { 152, 245, 255,    440 }, /* CadetBlue1 */
    { 142, 229, 238,    451 }, /* CadetBlue2 */
    { 122, 197, 205,    462 }, /* CadetBlue3 */
    {  83, 134, 139,    473 }, /* CadetBlue4 */
    { 127, 255,   0,    484 }, /* chartreuse */
    { 127, 255,   0,    495 }, /* chartreuse1 */
    { 118, 238,   0,    507 }, /* chartreuse2 */
    { 102, 205,   0,    519 }, /* chartreuse3 */
    {  69, 139,   0,    531 }, /* chartreuse4 */
    { 210, 105,  30,    543 }, /* chocolate */
    { 255, 127,  36,    553 }, /* chocolate1 */
    { 238, 118,  33,    564 }, /* chocolate2 */
    { 205, 102,  29,    575 }, /* chocolate3 */
    { 139,  69,  19,    586 }, /* chocolate4 */
    { 255, 127,  80,    597 }, /* coral */
    { 255, 114,  86,    603 }, /* coral1 */
    { 238, 106,  80,    610 }, /* coral2 */
    { 205,  91,  69,    617 }, /* coral3 */
    { 139,  62,  47,    624 }, /* coral4 */
    { 100, 149, 237,    631 }, /* cornflower blue */
    { 100, 149, 237,    647 }, /* CornflowerBlue */
    { 255, 248, 220,    662 }, /* cornsilk */
    { 255, 248, 220,    671 }, /* cornsilk1 */
    { 238, 232, 205,    681 }, /* cornsilk2 */
    { 205, 200, 177,    691 }, /* cornsilk3 */
    { 139, 136, 120,    701 }, /* cornsilk4 */
    {   0, 255, 255,    711 }, /* cyan */
    {   0, 255, 255,    716 }, /* cyan1 */
    {   0, 238, 238,    722 }, /* cyan2 */
    {   0, 205, 205,    728 }, /* cyan3 */
    {   0, 139, 139,    734 }, /* cyan4 */
    {   0,   0, 139,    740 }, /* dark blue */
    {   0, 139, 139,    750 }, /* dark cyan */
    { 184, 134,  11,    760 }, /* dark goldenrod */
    { 169, 169, 169,    775 }, /* dark gray */
    {   0, 100,   0,    785 }, /* dark green */
    { 169, 169, 169,    796 }, /* dark grey */
    { 189, 183, 107,    806 }, /* dark khaki */
    { 139,   0, 139,    817 }, /* dark magenta */
    {  85, 107,  47,    830 }, /* dark olive green */
    { 255, 140,   0,    847 }, /* dark orange */
    { 153,  50, 204,    859 }, /* dark orchid */
    { 139,   0,   0,    871 }, /* dark red */
    { 233, 150, 122,    880 }, /* dark salmon */
    { 143, 188, 143,    892 }, /* dark sea green */
    {  72,  61, 139,    907 }, /* dark slate blue */
    {  47,  79,  79,    923 }, /* dark slate gray */
    {  47,  79,  79,    939 }, /* dark slate grey */
    {   0, 206, 209,    955 }, /* dark turquoise */
    { 148,   0, 211,    970 }, /* dark violet */
    {   0,   0, 139,    982 }, /* DarkBlue */
    {   0, 139, 139,    991 }, /* DarkCyan */
    { 184, 134,  11,   1000 }, /* DarkGoldenrod */
    { 255, 185,  15,   1014 }, /* DarkGoldenrod1 */
    { 238, 173,  14,   1029 }, /* DarkGoldenrod2 */
    { 205, 149,  12,   1044 }, /* DarkGoldenrod3 */
    { 139, 101,   8,   1059 }, /* DarkGoldenrod4 */
    { 169, 169, 169,   1074 }, /* DarkGray */
    {   0, 100,   0,   1083 }, /* DarkGreen */
    { 169, 169, 169,   1093 }, /* DarkGrey */
    { 189, 183, 107,   1102 }, /* DarkKhaki */
    { 139,   0, 139,   1112 }, /* DarkMagenta */
    {  85, 107,  47,   1124 }, /* DarkOliveGreen */
    { 202, 255, 112,   1139 }, /* DarkOliveGreen1 */
    { 188, 238, 104,   1155 }, /* DarkOliveGreen2 */
    { 162, 205,  90,   1171 }, /* DarkOliveGreen3 */
    { 110, 139,  61,   1187 }, /* DarkOliveGreen4 */
    { 255, 140,   0,   1203 }, /* DarkOrange */
    { 255, 127,   0,   1214 }, /* DarkOrange1 */
    { 238, 118,   0,   1226 }, /* DarkOrange2 */
    { 205, 102,   0,   1238 }, /* DarkOrange3 */
    { 139,  69,   0,   1250 }, /* DarkOrange4 */
    { 153,  50, 204,   1262 }, /* DarkOrchid */
    { 191,  62, 255,   1273 }, /* DarkOrchid1 */
    { 178,  58, 238,   1285 }, /* DarkOrchid2 */
    { 154,  50, 205,   1297 }, /* DarkOrchid3 */
    { 104,  34, 139,   1309 }, /* DarkOrchid4 */
    { 139,   0,   0,   1321 }, /* DarkRed */
    { 233, 150, 122,   1329 }, /* DarkSalmon */
    { 143, 188, 143,   1340 }, /* DarkSeaGreen */
    { 193, 255, 193,   1353 }, /* DarkSeaGreen1 */
    { 180, 238, 180,   1367 }, /* DarkSeaGreen2 */
    { 155, 205, 155,   1381 }, /* DarkSeaGreen3 */
    { 105, 139, 105,   1395 }, /* DarkSeaGreen4 */
    {  72,  61, 139,   1409 }, /* DarkSlateBlue */
    {  47,  79,  79,   1423 }, /* DarkSlateGray */
    { 151, 255, 255,   1437 }, /* DarkSlateGray1 */
    { 141, 238, 238,   1452 }, /* DarkSlateGray2 */
    { 121, 205, 205,   1467 }, /* DarkSlateGray3 */
    {  82, 139, 139,   1482 }, /* DarkSlateGray4 */
    {  47,  79,  79,   1497 }, /* DarkSlateGrey */
    {   0, 206, 209,   1511 }, /* DarkTurquoise */
    { 148,   0, 211,   1525 }, /* DarkViolet */
    { 255,  20, 147,   1536 }, /* deep pink */
    {   0, 191, 255,   1546 }, /* deep sky blue */
    { 255,  20, 147,   1560 }, /* DeepPink */
    { 255,  20, 147,   1569 }, /* DeepPink1 */
    { 238,  18, 137,   1579 }, /* DeepPink2 */
    { 205,  16, 118,   1589 }, /* DeepPink3 */
    { 139,  10,  80,   1599 }, /* DeepPink4 */
    {   0, 191, 255,   1609 }, /* DeepSkyBlue */
    {   0, 191, 255,   1621 }, /* DeepSkyBlue1 */
    {   0, 178, 238,   1634 }, /* DeepSkyBlue2 */
    {   0, 154, 205,   1647 }, /* DeepSkyBlue3 */
    {   0, 104, 139,   1660 }, /* DeepSkyBlue4 */
    { 105, 105, 105,   1673 }, /* dim gray */
    { 105, 105, 105,   1682 }, /* dim grey */
    { 105, 105, 105,   1691 }, /* DimGray */
    { 105, 105, 105,   1699 }, /* DimGrey */
    {  30, 144, 255,   1707 }, /* dodger blue */
    {  30, 144, 255,   1719 }, /* DodgerBlue */
    {  30, 144, 255,   1730 }, /* DodgerBlue1 */
    {  28, 134, 238,   1742 }, /* DodgerBlue2 */
    {  24, 116, 205,   1754 }, /* DodgerBlue3 */
    {  16,  78, 139,   1766 }, /* DodgerBlue4 */
    { 178,  34,  34,   1778 }, /* firebrick */
    { 255,  48,  48,   1788 }, /* firebrick1 */
    { 238,  44,  44,   1799 }, /* firebrick2 */
    { 205,  38,  38,   1810 }, /* firebrick3 */
    { 139,  26,  26,   1821 }, /* firebrick4 */
    { 255, 250, 240,   1832 }, /* floral white */
    { 255, 250, 240,   1845 }, /* FloralWhite */
    {  34, 139,  34,   1857 }, /* forest green */
    {  34, 139,  34,   1870 }, /* ForestGreen */
    { 220, 220, 220,   1882 }, /* gainsboro */
    { 248, 248, 255,   1892 }, /* ghost white */
    { 248, 248, 255,   1904 }, /* GhostWhite */
    { 255, 215,   0,   1915 }, /* gold */
    { 255, 215,   0,   1920 }, /* gold1 */
    { 238, 201,   0,   1926 }, /* gold2 */
    { 205, 173,   0,   1932 }, /* gold3 */
    { 139, 117,   0,   1938 }, /* gold4 */
    { 218, 165,  32,   1944 }, /* goldenrod */
    { 255, 193,  37,   1954 }, /* goldenrod1 */
    { 238, 180,  34,   1965 }, /* goldenrod2 */
    { 205, 155,  29,   1976 }, /* goldenrod3 */
    { 139, 105,  20,   1987 }, /* goldenrod4 */
    { 190, 190, 190,   1998 }, /* gray */
    {   0,   0,   0,   2003 }, /* gray0 */
    {   3,   3,   3,   2009 }, /* gray1 */
    {  26,  26,  26,   2015 }, /* gray10 */
    { 255, 255, 255,   2022 }, /* gray100 */
    {  28,  28,  28,   2030 }, /* gray11 */
    {  31,  31,  31,   2037 }, /* gray12 */
    {  33,  33,  33,   2044 }, /* gray13 */
    {  36,  36,  36,   2051 }, /* gray14 */
    {  38,  38,  38,   2058 }, /* gray15 */
    {  41,  41,  41,   2065 }, /* gray16 */
    {  43,  43,  43,   2072 }, /* gray17 */
    {  46,  46,  46,   2079 }, /* gray18 */
    {  48,  48,  48,   2086 }, /* gray19 */
    {   5,   5,   5,   2093 }, /* gray2 */
    {  51,  51,  51,   2099 }, /* gray20 */
    {  54,  54,  54,   2106 }, /* gray21 */
    {  56,  56,  56,   2113 }, /* gray22 */
    {  59,  59,  59,   2120 }, /* gray23 */
    {  61,  61,  61,   2127 }, /* gray24 */
    {  64,  64,  64,   2134 }, /* gray25 */
    {  66,  66,  66,   2141 }, /* gray26 */
    {  69,  69,  69,   2148 }, /* gray27 */
    {  71,  71,  71,   2155 }, /* gray28 */
    {  74,  74,  74,   2162 }, /* gray29 */
    {   8,   8,   8,   2169 }, /* gray3 */
    {  77,  77,  77,   2175 }, /* gray30 */
    {  79,  79,  79,   2182 }, /* gray31 */
    {  82,  82,  82,   2189 }, /* gray32 */
    {  84,  84,  84,   2196 }, /* gray33 */
    {  87,  87,  87,   2203 }, /* gray34 */
    {  89,  89,  89,   2210 }, /* gray35 */
    {  92,  92,  92,   2217 }, /* gray36 */
    {  94,  94,  94,   2224 }, /* gray37 */
    {  97,  97,  97,   2231 }, /* gray38 */
    {  99,  99,  99,   2238 }, /* gray39 */
    {  10,  10,  10,   2245 }, /* gray4 */
    { 102, 102, 102,   2251 }, /* gray40 */
    { 105, 105, 105,   2258 }, /* gray41 */
    { 107, 107, 107,   2265 }, /* gray42 */
    { 110, 110, 110,   2272 }, /* gray43 */
    { 112, 112, 112,   2279 }, /* gray44 */
    { 115, 115, 115,   2286 }, /* gray45 */
    { 117, 117, 117,   2293 }, /* gray46 */
    { 120, 120, 120,   2300 }, /* gray47 */
    { 122, 122, 122,   2307 }, /* gray48 */
    { 125, 125, 125,   2314 }, /* gray49 */
    {  13,  13,  13,   2321 }, /* gray5 */
    { 127, 127, 127,   2327 }, /* gray50 */
    { 130, 130, 130,   2334 }, /* gray51 */
    { 133, 133, 133,   2341 }, /* gray52 */
    { 135, 135, 135,   2348 }, /* gray53 */
    { 138, 138, 138,   2355 }, /* gray54 */
    { 140, 140, 140,   2362 }, /* gray55 */
    { 143, 143, 143,   2369 }, /* gray56 */
    { 145, 145, 145,   2376 }, /* gray57 */
    { 148, 148, 148,   2383 }, /* gray58 */
    { 150, 150, 150,   2390 }, /* gray59 */
    {  15,  15,  15,   2397 }, /* gray6 */
    { 153, 153, 153,   2403 }, /* gray60 */
    { 156, 156, 156,   2410 }, /* gray61 */
    { 158, 158, 158,   2417 }, /* gray62 */
    { 161, 161, 161,   2424 }, /* gray63 */
    { 163, 163, 163,   2431 }, /* gray64 */
    { 166, 166, 166,   2438 }, /* gray65 */
    { 168, 168, 168,   2445 }, /* gray66 */
    { 171, 171, 171,   2452 }, /* gray67 */
    { 173, 173, 173,   2459 }, /* gray68 */
    { 176, 176, 176,   2466 }, /* gray69 */
    {  18,  18,  18,   2473 }, /* gray7 */
    { 179, 179, 179,   2479 }, /* gray70 */
    { 181, 181, 181,   2486 }, /* gray71 */
    { 184, 184, 184,   2493 }, /* gray72 */
    { 186, 186, 186,   2500 }, /* gray73 */
    { 189, 189, 189,   2507 }, /* gray74 */
    { 191, 191, 191,   2514 }, /* gray75 */
    { 194, 194, 194,   2521 }, /* gray76 */
    { 196, 196, 196,   2528 }, /* gray77 */
    { 199, 199, 199,   2535 }, /* gray78 */
    { 201, 201, 201,   2542 }, /* gray79 */
    {  20,  20,  20,   2549 }, /* gray8 */
    { 204, 204, 204,   2555 }, /* gray80 */
    { 207, 207, 207,   2562 }, /* gray81 */
    { 209, 209, 209,   2569 }, /* gray82 */
    { 212, 212, 212,   2576 }, /* gray83 */
    { 214, 214, 214,   2583 }, /* gray84 */
    { 217, 217, 217,   2590 }, /* gray85 */
    { 219, 219, 219,   2597 }, /* gray86 */
    { 222, 222, 222,   2604 }, /* gray87 */
    { 224, 224, 224,   2611 }, /* gray88 */
    { 227, 227, 227,   2618 }, /* gray89 */
    {  23,  23,  23,   2625 }, /* gray9 */
    { 229, 229, 229,   2631 }, /* gray90 */
    { 232, 232, 232,   2638 }, /* gray91 */
    { 235, 235, 235,   2645 }, /* gray92 */
    { 237, 237, 237,   2652 }, /* gray93 */
    { 240, 240, 240,   2659 }, /* gray94 */
    { 242, 242, 242,   2666 }, /* gray95 */
    { 245, 245, 245,   2673 }, /* gray96 */
    { 247, 247, 247,   2680 }, /* gray97 */
    { 250, 250, 250,   2687 }, /* gray98 */
    { 252, 252, 252,   2694 }, /* gray99 */
    {   0, 255,   0,   2701 }, /* green */
    { 173, 255,  47,   2707 }, /* green yellow */
    {   0, 255,   0,   2720 }, /* green1 */
    {   0, 238,   0,   2727 }, /* green2 */
    {   0, 205,   0,   2734 }, /* green3 */
    {   0, 139,   0,   2741 }, /* green4 */
    { 173, 255,  47,   2748 }, /* GreenYellow */
    { 190, 190, 190,   2760 }, /* grey */
    {   0,   0,   0,   2765 }, /* grey0 */
    {   3,   3,   3,   2771 }, /* grey1 */
    {  26,  26,  26,   2777 }, /* grey10 */
    { 255, 255, 255,   2784 }, /* grey100 */
    {  28,  28,  28,   2792 }, /* grey11 */
    {  31,  31,  31,   2799 }, /* grey12 */
    {  33,  33,  33,   2806 }, /* grey13 */
    {  36,  36,  36,   2813 }, /* grey14 */
    {  38,  38,  38,   2820 }, /* grey15 */
    {  41,  41,  41,   2827 }, /* grey16 */
    {  43,  43,  43,   2834 }, /* grey17 */
    {  46,  46,  46,   2841 }, /* grey18 */
    {  48,  48,  48,   2848 }, /* grey19 */
    {   5,   5,   5,   2855 }, /* grey2 */
    {  51,  51,  51,   2861 }, /* grey20 */
    {  54,  54,  54,   2868 }, /* grey21 */
    {  56,  56,  56,   2875 }, /* grey22 */
    {  59,  59,  59,   2882 }, /* grey23 */
    {  61,  61,  61,   2889 }, /* grey24 */
    {  64,  64,  64,   2896 }, /* grey25 */
    {  66,  66,  66,   2903 }, /* grey26 */
    {  69,  69,  69,   2910 }, /* grey27 */
    {  71,  71,  71,   2917 }, /* grey28 */
    {  74,  74,  74,   2924 }, /* grey29 */
    {   8,   8,   8,   2931 }, /* grey3 */
    {  77,  77,  77,   2937 }, /* grey30 */
    {  79,  79,  79,   2944 }, /* grey31 */
    {  82,  82,  82,   2951 }, /* grey32 */
    {  84,  84,  84,   2958 }, /* grey33 */
    {  87,  87,  87,   2965 }, /* grey34 */
    {  89,  89,  89,   2972 }, /* grey35 */
    {  92,  92,  92,   2979 }, /* grey36 */
    {  94,  94,  94,   2986 }, /* grey37 */
    {  97,  97,  97,   2993 }, /* grey38 */
    {  99,  99,  99,   3000 }, /* grey39 */
    {  10,  10,  10,   3007 }, /* grey4 */
    { 102, 102, 102,   3013 }, /* grey40 */
    { 105, 105, 105,   3020 }, /* grey41 */
    { 107, 107, 107,   3027 }, /* grey42 */
    { 110, 110, 110,   3034 }, /* grey43 */
    { 112, 112, 112,   3041 }, /* grey44 */
    { 115, 115, 115,   3048 }, /* grey45 */
    { 117, 117, 117,   3055 }, /* grey46 */
    { 120, 120, 120,   3062 }, /* grey47 */
    { 122, 122, 122,   3069 }, /* grey48 */
    { 125, 125, 125,   3076 }, /* grey49 */
    {  13,  13,  13,   3083 }, /* grey5 */
    { 127, 127, 127,   3089 }, /* grey50 */
    { 130, 130, 130,   3096 }, /* grey51 */
    { 133, 133, 133,   3103 }, /* grey52 */
    { 135, 135, 135,   3110 }, /* grey53 */
    { 138, 138, 138,   3117 }, /* grey54 */
    { 140, 140, 140,   3124 }, /* grey55 */
    { 143, 143, 143,   3131 }, /* grey56 */
    { 145, 145, 145,   3138 }, /* grey57 */
    { 148, 148, 148,   3145 }, /* grey58 */
    { 150, 150, 150,   3152 }, /* grey59 */
    {  15,  15,  15,   3159 }, /* grey6 */
    { 153, 153, 153,   3165 }, /* grey60 */
    { 156, 156, 156,   3172 }, /* grey61 */
    { 158, 158, 158,   3179 }, /* grey62 */
    { 161, 161, 161,   3186 }, /* grey63 */
    { 163, 163, 163,   3193 }, /* grey64 */
    { 166, 166, 166,   3200 }, /* grey65 */
    { 168, 168, 168,   3207 }, /* grey66 */
    { 171, 171, 171,   3214 }, /* grey67 */
    { 173, 173, 173,   3221 }, /* grey68 */
    { 176, 176, 176,   3228 }, /* grey69 */
    {  18,  18,  18,   3235 }, /* grey7 */
    { 179, 179, 179,   3241 }, /* grey70 */
    { 181, 181, 181,   3248 }, /* grey71 */
    { 184, 184, 184,   3255 }, /* grey72 */
    { 186, 186, 186,   3262 }, /* grey73 */
    { 189, 189, 189,   3269 }, /* grey74 */
    { 191, 191, 191,   3276 }, /* grey75 */
    { 194, 194, 194,   3283 }, /* grey76 */
    { 196, 196, 196,   3290 }, /* grey77 */
    { 199, 199, 199,   3297 }, /* grey78 */
    { 201, 201, 201,   3304 }, /* grey79 */
    {  20,  20,  20,   3311 }, /* grey8 */
    { 204, 204, 204,   3317 }, /* grey80 */
    { 207, 207, 207,   3324 }, /* grey81 */
    { 209, 209, 209,   3331 }, /* grey82 */
    { 212, 212, 212,   3338 }, /* grey83 */
    { 214, 214, 214,   3345 }, /* grey84 */
    { 217, 217, 217,   3352 }, /* grey85 */
    { 219, 219, 219,   3359 }, /* grey86 */
    { 222, 222, 222,   3366 }, /* grey87 */
    { 224, 224, 224,   3373 }, /* grey88 */
    { 227, 227, 227,   3380 }, /* grey89 */
    {  23,  23,  23,   3387 }, /* grey9 */
    { 229, 229, 229,   3393 }, /* grey90 */
    { 232, 232, 232,   3400 }, /* grey91 */
    { 235, 235, 235,   3407 }, /* grey92 */
    { 237, 237, 237,   3414 }, /* grey93 */
    { 240, 240, 240,   3421 }, /* grey94 */
    { 242, 242, 242,   3428 }, /* grey95 */
    { 245, 245, 245,   3435 }, /* grey96 */
    { 247, 247, 247,   3442 }, /* grey97 */
    { 250, 250, 250,   3449 }, /* grey98 */
    { 252, 252, 252,   3456 }, /* grey99 */
    { 240, 255, 240,   3463 }, /* honeydew */
    { 240, 255, 240,   3472 }, /* honeydew1 */
    { 224, 238, 224,   3482 }, /* honeydew2 */
    { 193, 205, 193,   3492 }, /* honeydew3 */
    { 131, 139, 131,   3502 }, /* honeydew4 */
    { 255, 105, 180,   3512 }, /* hot pink */
    { 255, 105, 180,   3521 }, /* HotPink */
    { 255, 110, 180,   3529 }, /* HotPink1 */
    { 238, 106, 167,   3538 }, /* HotPink2 */
    { 205,  96, 144,   3547 }, /* HotPink3 */
    { 139,  58,  98,   3556 }, /* HotPink4 */
    { 205,  92,  92,   3565 }, /* indian red */
    { 205,  92,  92,   3576 }, /* IndianRed */
    { 255, 106, 106,   3586 }, /* IndianRed1 */
    { 238,  99,  99,   3597 }, /* IndianRed2 */
    { 205,  85,  85,   3608 }, /* IndianRed3 */
    { 139,  58,  58,   3619 }, /* IndianRed4 */
    { 255, 255, 240,   3630 }, /* ivory */
    { 255, 255, 240,   3636 }, /* ivory1 */
    { 238, 238, 224,   3643 }, /* ivory2 */
    { 205, 205, 193,   3650 }, /* ivory3 */
    { 139, 139, 131,   3657 }, /* ivory4 */
    { 240, 230, 140,   3664 }, /* khaki */
    { 255, 246, 143,   3670 }, /* khaki1 */
    { 238, 230, 133,   3677 }, /* khaki2 */
    { 205, 198, 115,   3684 }, /* khaki3 */
    { 139, 134,  78,   3691 }, /* khaki4 */
    { 230, 230, 250,   3698 }, /* lavender */
    { 255, 240, 245,   3707 }, /* lavender blush */
    { 255, 240, 245,   3722 }, /* LavenderBlush */
    { 255, 240, 245,   3736 }, /* LavenderBlush1 */
    { 238, 224, 229,   3751 }, /* LavenderBlush2 */
    { 205, 193, 197,   3766 }, /* LavenderBlush3 */
    { 139, 131, 134,   3781 }, /* LavenderBlush4 */
    { 124, 252,   0,   3796 }, /* lawn green */
    { 124, 252,   0,   3807 }, /* LawnGreen */
    { 255, 250, 205,   3817 }, /* lemon chiffon */
    { 255, 250, 205,   3831 }, /* LemonChiffon */
    { 255, 250, 205,   3844 }, /* LemonChiffon1 */
    { 238, 233, 191,   3858 }, /* LemonChiffon2 */
    { 205, 201, 165,   3872 }, /* LemonChiffon3 */
    { 139, 137, 112,   3886 }, /* LemonChiffon4 */
    { 173, 216, 230,   3900 }, /* light blue */
    { 240, 128, 128,   3911 }, /* light coral */
    { 224, 255, 255,   3923 }, /* light cyan */
    { 238, 221, 130,   3934 }, /* light goldenrod */
    { 250, 250, 210,   3950 }, /* light goldenrod yellow */
    { 211, 211, 211,   3973 }, /* light gray */
    { 144, 238, 144,   3984 }, /* light green */
    { 211, 211, 211,   3996 }, /* light grey */
    { 255, 182, 193,   4007 }, /* light pink */
    { 255, 160, 122,   4018 }, /* light salmon */
    {  32, 178, 170,   4031 }, /* light sea green */
    { 135, 206, 250,   4047 }, /* light sky blue */
    { 132, 112, 255,   4062 }, /* light slate blue */
    { 119, 136, 153,   4079 }, /* light slate gray */
    { 119, 136, 153,   4096 }, /* light slate grey */
    { 176, 196, 222,   4113 }, /* light steel blue */
    { 255, 255, 224,   4130 }, /* light yellow */
    { 173, 216, 230,   4143 }, /* LightBlue */
    { 191, 239, 255,   4153 }, /* LightBlue1 */
    { 178, 223, 238,   4164 }, /* LightBlue2 */
    { 154, 192, 205,   4175 }, /* LightBlue3 */
    { 104, 131, 139,   4186 }, /* LightBlue4 */
    { 240, 128, 128,   4197 }, /* LightCoral */
    { 224, 255, 255,   4208 }, /* LightCyan */
    { 224, 255, 255,   4218 }, /* LightCyan1 */
    { 209, 238, 238,   4229 }, /* LightCyan2 */
    { 180, 205, 205,   4240 }, /* LightCyan3 */
    { 122, 139, 139,   4251 }, /* LightCyan4 */
    { 238, 221, 130,   4262 }, /* LightGoldenrod */
    { 255, 236, 139,   4277 }, /* LightGoldenrod1 */
    { 238, 220, 130,   4293 }, /* LightGoldenrod2 */
    { 205, 190, 112,   4309 }, /* LightGoldenrod3 */
    { 139, 129,  76,   4325 }, /* LightGoldenrod4 */
    { 250, 250, 210,   4341 }, /* LightGoldenrodYellow */
    { 211, 211, 211,   4362 }, /* LightGray */
    { 144, 238, 144,   4372 }, /* LightGreen */
    { 211, 211, 211,   4383 }, /* LightGrey */
    { 255, 182, 193,   4393 }, /* LightPink */
    { 255, 174, 185,   4403 }, /* LightPink1 */
    { 238, 162, 173,   4414 }, /* LightPink2 */
    { 205, 140, 149,   4425 }, /* LightPink3 */
    { 139,  95, 101,   4436 }, /* LightPink4 */
    { 255, 160, 122,   4447 }, /* LightSalmon */
    { 255, 160, 122,   4459 }, /* LightSalmon1 */
    { 238, 149, 114,   4472 }, /* LightSalmon2 */
    { 205, 129,  98,   4485 }, /* LightSalmon3 */
    { 139,  87,  66,   4498 }, /* LightSalmon4 */
    {  32, 178, 170,   4511 }, /* LightSeaGreen */
    { 135, 206, 250,   4525 }, /* LightSkyBlue */
    { 176, 226, 255,   4538 }, /* LightSkyBlue1 */
    { 164, 211, 238,   4552 }, /* LightSkyBlue2 */
    { 141, 182, 205,   4566 }, /* LightSkyBlue3 */
    {  96, 123, 139,   4580 }, /* LightSkyBlue4 */
    { 132, 112, 255,   4594 }, /* LightSlateBlue */
    { 119, 136, 153,   4609 }, /* LightSlateGray */
    { 119, 136, 153,   4624 }, /* LightSlateGrey */
    { 176, 196, 222,   4639 }, /* LightSteelBlue */
    { 202, 225, 255,   4654 }, /* LightSteelBlue1 */
    { 188, 210, 238,   4670 }, /* LightSteelBlue2 */
    { 162, 181, 205,   4686 }, /* LightSteelBlue3 */
    { 110, 123, 139,   4702 }, /* LightSteelBlue4 */
    { 255, 255, 224,   4718 }, /* LightYellow */
    { 255, 255, 224,   4730 }, /* LightYellow1 */
    { 238, 238, 209,   4743 }, /* LightYellow2 */
    { 205, 205, 180,   4756 }, /* LightYellow3 */
    { 139, 139, 122,   4769 }, /* LightYellow4 */
    {  50, 205,  50,   4782 }, /* lime green */
    {  50, 205,  50,   4793 }, /* LimeGreen */
    { 250, 240, 230,   4803 }, /* linen */
    { 255,   0, 255,   4809 }, /* magenta */
    { 255,   0, 255,   4817 }, /* magenta1 */
    { 238,   0, 238,   4826 }, /* magenta2 */
    { 205,   0, 205,   4835 }, /* magenta3 */
    { 139,   0, 139,   4844 }, /* magenta4 */
    { 176,  48,  96,   4853 }, /* maroon */
    { 255,  52, 179,   4860 }, /* maroon1 */
    { 238,  48, 167,   4868 }, /* maroon2 */
    { 205,  41, 144,   4876 }, /* maroon3 */
    { 139,  28,  98,   4884 }, /* maroon4 */
    { 102, 205, 170,   4892 }, /* medium aquamarine */
    {   0,   0, 205,   4910 }, /* medium blue */
    { 186,  85, 211,   4922 }, /* medium orchid */
    { 147, 112, 219,   4936 }, /* medium purple */
    {  60, 179, 113,   4950 }, /* medium sea green */
    { 123, 104, 238,   4967 }, /* medium slate blue */
    {   0, 250, 154,   4985 }, /* medium spring green */
    {  72, 209, 204,   5005 }, /* medium turquoise */
    { 199,  21, 133,   5022 }, /* medium violet red */
    { 102, 205, 170,   5040 }, /* MediumAquamarine */
    {   0,   0, 205,   5057 }, /* MediumBlue */
    { 186,  85, 211,   5068 }, /* MediumOrchid */
    { 224, 102, 255,   5081 }, /* MediumOrchid1 */
    { 209,  95, 238,   5095 }, /* MediumOrchid2 */
    { 180,  82, 205,   5109 }, /* MediumOrchid3 */
    { 122,  55, 139,   5123 }, /* MediumOrchid4 */
    { 147, 112, 219,   5137 }, /* MediumPurple */
    { 171, 130, 255,   5150 }, /* MediumPurple1 */
    { 159, 121, 238,   5164 }, /* MediumPurple2 */
    { 137, 104, 205,   5178 }, /* MediumPurple3 */
    {  93,  71, 139,   5192 }, /* MediumPurple4 */
    {  60, 179, 113,   5206 }, /* MediumSeaGreen */
    { 123, 104, 238,   5221 }, /* MediumSlateBlue */
    {   0, 250, 154,   5237 }, /* MediumSpringGreen */
    {  72, 209, 204,   5255 }, /* MediumTurquoise */
    { 199,  21, 133,   5271 }, /* MediumVioletRed */
    {  25,  25, 112,   5287 }, /* midnight blue */
    {  25,  25, 112,   5301 }, /* MidnightBlue */
    { 245, 255, 250,   5314 }, /* mint cream */
    { 245, 255, 250,   5325 }, /* MintCream */
    { 255, 228, 225,   5335 }, /* misty rose */
    { 255, 228, 225,   5346 }, /* MistyRose */
    { 255, 228, 225,   5356 }, /* MistyRose1 */
    { 238, 213, 210,   5367 }, /* MistyRose2 */
    { 205, 183, 181,   5378 }, /* MistyRose3 */
    { 139, 125, 123,   5389 }, /* MistyRose4 */
    { 255, 228, 181,   5400 }, /* moccasin */
    { 255, 222, 173,   5409 }, /* navajo white */
    { 255, 222, 173,   5422 }, /* NavajoWhite */
    { 255, 222, 173,   5434 }, /* NavajoWhite1 */
    { 238, 207, 161,   5447 }, /* NavajoWhite2 */
    { 205, 179, 139,   5460 }, /* NavajoWhite3 */
    { 139, 121,  94,   5473 }, /* NavajoWhite4 */
    {   0,   0, 128,   5486 }, /* navy */
    {   0,   0, 128,   5491 }, /* navy blue */
    {   0,   0, 128,   5501 }, /* NavyBlue */
    { 253, 245, 230,   5510 }, /* old lace */
    { 253, 245, 230,   5519 }, /* OldLace */
    { 107, 142,  35,   5527 }, /* olive drab */
    { 107, 142,  35,   5538 }, /* OliveDrab */
    { 192, 255,  62,   5548 }, /* OliveDrab1 */
    { 179, 238,  58,   5559 }, /* OliveDrab2 */
    { 154, 205,  50,   5570 }, /* OliveDrab3 */
    { 105, 139,  34,   5581 }, /* OliveDrab4 */
    { 255, 165,   0,   5592 }, /* orange */
    { 255,  69,   0,   5599 }, /* orange red */
    { 255, 165,   0,   5610 }, /* orange1 */
    { 238, 154,   0,   5618 }, /* orange2 */
    { 205, 133,   0,   5626 }, /* orange3 */
    { 139,  90,   0,   5634 }, /* orange4 */
    { 255,  69,   0,   5642 }, /* OrangeRed */
    { 255,  69,   0,   5652 }, /* OrangeRed1 */
    { 238,  64,   0,   5663 }, /* OrangeRed2 */
    { 205,  55,   0,   5674 }, /* OrangeRed3 */
    { 139,  37,   0,   5685 }, /* OrangeRed4 */
    { 218, 112, 214,   5696 }, /* orchid */
    { 255, 131, 250,   5703 }, /* orchid1 */
    { 238, 122, 233,   5711 }, /* orchid2 */
    { 205, 105, 201,   5719 }, /* orchid3 */
    { 139,  71, 137,   5727 }, /* orchid4 */
    { 238, 232, 170,   5735 }, /* pale goldenrod */
    { 152, 251, 152,   5750 }, /* pale green */
    { 175, 238, 238,   5761 }, /* pale turquoise */
    { 219, 112, 147,   5776 }, /* pale violet red */
    { 238, 232, 170,   5792 }, /* PaleGoldenrod */
    { 152, 251, 152,   5806 }, /* PaleGreen */
    { 154, 255, 154,   5816 }, /* PaleGreen1 */
    { 144, 238, 144,   5827 }, /* PaleGreen2 */
    { 124, 205, 124,   5838 }, /* PaleGreen3 */
    {  84, 139,  84,   5849 }, /* PaleGreen4 */
    { 175, 238, 238,   5860 }, /* PaleTurquoise */
    { 187, 255, 255,   5874 }, /* PaleTurquoise1 */
    { 174, 238, 238,   5889 }, /* PaleTurquoise2 */
    { 150, 205, 205,   5904 }, /* PaleTurquoise3 */
    { 102, 139, 139,   5919 }, /* PaleTurquoise4 */
    { 219, 112, 147,   5934 }, /* PaleVioletRed */
    { 255, 130, 171,   5948 }, /* PaleVioletRed1 */
    { 238, 121, 159,   5963 }, /* PaleVioletRed2 */
    { 205, 104, 137,   5978 }, /* PaleVioletRed3 */
    { 139,  71,  93,   5993 }, /* PaleVioletRed4 */
    { 255, 239, 213,   6008 }, /* papaya whip */
    { 255, 239, 213,   6020 }, /* PapayaWhip */
    { 255, 218, 185,   6031 }, /* peach puff */
    { 255, 218, 185,   6042 }, /* PeachPuff */
    { 255, 218, 185,   6052 }, /* PeachPuff1 */
    { 238, 203, 173,   6063 }, /* PeachPuff2 */
    { 205, 175, 149,   6074 }, /* PeachPuff3 */
    { 139, 119, 101,   6085 }, /* PeachPuff4 */
    { 205, 133,  63,   6096 }, /* peru */
    { 255, 192, 203,   6101 }, /* pink */
    { 255, 181, 197,   6106 }, /* pink1 */
    { 238, 169, 184,   6112 }, /* pink2 */
    { 205, 145, 158,   6118 }, /* pink3 */
    { 139,  99, 108,   6124 }, /* pink4 */
    { 221, 160, 221,   6130 }, /* plum */
    { 255, 187, 255,   6135 }, /* plum1 */
    { 238, 174, 238,   6141 }, /* plum2 */
    { 205, 150, 205,   6147 }, /* plum3 */
    { 139, 102, 139,   6153 }, /* plum4 */
    { 176, 224, 230,   6159 }, /* powder blue */
    { 176, 224, 230,   6171 }, /* PowderBlue */
    { 160,  32, 240,   6182 }, /* purple */
    { 155,  48, 255,   6189 }, /* purple1 */
    { 145,  44, 238,   6197 }, /* purple2 */
    { 125,  38, 205,   6205 }, /* purple3 */
    {  85,  26, 139,   6213 }, /* purple4 */
    { 255,   0,   0,   6221 }, /* red */
    { 255,   0,   0,   6225 }, /* red1 */
    { 238,   0,   0,   6230 }, /* red2 */
    { 205,   0,   0,   6235 }, /* red3 */
    { 139,   0,   0,   6240 }, /* red4 */
    { 188, 143, 143,   6245 }, /* rosy brown */
    { 188, 143, 143,   6256 }, /* RosyBrown */
    { 255, 193, 193,   6266 }, /* RosyBrown1 */
    { 238, 180, 180,   6277 }, /* RosyBrown2 */
    { 205, 155, 155,   6288 }, /* RosyBrown3 */
    { 139, 105, 105,   6299 }, /* RosyBrown4 */
    {  65, 105, 225,   6310 }, /* royal blue */
    {  65, 105, 225,   6321 }, /* RoyalBlue */
    {  72, 118, 255,   6331 }, /* RoyalBlue1 */
    {  67, 110, 238,   6342 }, /* RoyalBlue2 */
    {  58,  95, 205,   6353 }, /* RoyalBlue3 */
    {  39,  64, 139,   6364 }, /* RoyalBlue4 */
    { 139,  69,  19,   6375 }, /* saddle brown */
    { 139,  69,  19,   6388 }, /* SaddleBrown */
    { 250, 128, 114,   6400 }, /* salmon */
    { 255, 140, 105,   6407 }, /* salmon1 */
    { 238, 130,  98,   6415 }, /* salmon2 */
    { 205, 112,  84,   6423 }, /* salmon3 */
    { 139,  76,  57,   6431 }, /* salmon4 */
    { 244, 164,  96,   6439 }, /* sandy brown */
    { 244, 164,  96,   6451 }, /* SandyBrown */
    {  46, 139,  87,   6462 }, /* sea green */
    {  46, 139,  87,   6472 }, /* SeaGreen */
    {  84, 255, 159,   6481 }, /* SeaGreen1 */
    {  78, 238, 148,   6491 }, /* SeaGreen2 */
    {  67, 205, 128,   6501 }, /* SeaGreen3 */
    {  46, 139,  87,   6511 }, /* SeaGreen4 */
    { 255, 245, 238,   6521 }, /* seashell */
    { 255, 245, 238,   6530 }, /* seashell1 */
    { 238, 229, 222,   6540 }, /* seashell2 */
    { 205, 197, 191,   6550 }, /* seashell3 */
    { 139, 134, 130,   6560 }, /* seashell4 */
    { 160,  82,  45,   6570 }, /* sienna */
    { 255, 130,  71,   6577 }, /* sienna1 */
    { 238, 121,  66,   6585 }, /* sienna2 */
    { 205, 104,  57,   6593 }, /* sienna3 */
    { 139,  71,  38,   6601 }, /* sienna4 */
    { 135, 206, 235,   6609 }, /* sky blue */
    { 135, 206, 235,   6618 }, /* SkyBlue */
    { 135, 206, 255,   6626 }, /* SkyBlue1 */
    { 126, 192, 238,   6635 }, /* SkyBlue2 */
    { 108, 166, 205,   6644 }, /* SkyBlue3 */
    {  74, 112, 139,   6653 }, /* SkyBlue4 */
    { 106,  90, 205,   6662 }, /* slate blue */
    { 112, 128, 144,   6673 }, /* slate gray */
    { 112, 128, 144,   6684 }, /* slate grey */
    { 106,  90, 205,   6695 }, /* SlateBlue */
    { 131, 111, 255,   6705 }, /* SlateBlue1 */
    { 122, 103, 238,   6716 }, /* SlateBlue2 */
    { 105,  89, 205,   6727 }, /* SlateBlue3 */
    {  71,  60, 139,   6738 }, /* SlateBlue4 */
    { 112, 128, 144,   6749 }, /* SlateGray */
    { 198, 226, 255,   6759 }, /* SlateGray1 */
    { 185, 211, 238,   6770 }, /* SlateGray2 */
    { 159, 182, 205,   6781 }, /* SlateGray3 */
    { 108, 123, 139,   6792 }, /* SlateGray4 */
    { 112, 128, 144,   6803 }, /* SlateGrey */
    { 255, 250, 250,   6813 }, /* snow */
    { 255, 250, 250,   6818 }, /* snow1 */
    { 238, 233, 233,   6824 }, /* snow2 */
    { 205, 201, 201,   6830 }, /* snow3 */
    { 139, 137, 137,   6836 }, /* snow4 */
    {   0, 255, 127,   6842 }, /* spring green */
    {   0, 255, 127,   6855 }, /* SpringGreen */
    {   0, 255, 127,   6867 }, /* SpringGreen1 */
    {   0, 238, 118,   6880 }, /* SpringGreen2 */
    {   0, 205, 102,   6893 }, /* SpringGreen3 */
    {   0, 139,  69,   6906 }, /* SpringGreen4 */
    {  70, 130, 180,   6919 }, /* steel blue */
    {  70, 130, 180,   6930 }, /* SteelBlue */
    {  99, 184, 255,   6940 }, /* SteelBlue1 */
    {  92, 172, 238,   6951 }, /* SteelBlue2 */
    {  79, 148, 205,   6962 }, /* SteelBlue3 */
    {  54, 100, 139,   6973 }, /* SteelBlue4 */
    { 210, 180, 140,   6984 }, /* tan */
    { 255, 165,  79,   6988 }, /* tan1 */
    { 238, 154,  73,   6993 }, /* tan2 */
    { 205, 133,  63,   6998 }, /* tan3 */
    { 139,  90,  43,   7003 }, /* tan4 */
    { 216, 191, 216,   7008 }, /* thistle */
    { 255, 225, 255,   7016 }, /* thistle1 */
    { 238, 210, 238,   7025 }, /* thistle2 */
    { 205, 181, 205,   7034 }, /* thistle3 */
    { 139, 123, 139,   7043 }, /* thistle4 */
    { 255,  99,  71,   7052 }, /* tomato */
    { 255,  99,  71,   7059 }, /* tomato1 */
    { 238,  92,  66,   7067 }, /* tomato2 */
    { 205,  79,  57,   7075 }, /* tomato3 */
    { 139,  54,  38,   7083 }, /* tomato4 */
    {  64, 224, 208,   7091 }, /* turquoise */
    {   0, 245, 255,   7101 }, /* turquoise1 */
    {   0, 229, 238,   7112 }, /* turquoise2 */
    {   0, 197, 205,   7123 }, /* turquoise3 */
    {   0, 134, 139,   7134 }, /* turquoise4 */
    { 238, 130, 238,   7145 }, /* violet */
    { 208,  32, 144,   7152 }, /* violet red */
    { 208,  32, 144,   7163 }, /* VioletRed */
    { 255,  62, 150,   7173 }, /* VioletRed1 */
    { 238,  58, 140,   7184 }, /* VioletRed2 */
    { 205,  50, 120,   7195 }, /* VioletRed3 */
    { 139,  34,  82,   7206 }, /* VioletRed4 */
    { 245, 222, 179,   7217 }, /* wheat */
    { 255, 231, 186,   7223 }, /* wheat1 */
    { 238, 216, 174,   7230 }, /* wheat2 */
    { 205, 186, 150,   7237 }, /* wheat3 */
    { 139, 126, 102,   7244 }, /* wheat4 */
    { 255, 255, 255,   7251 }, /* white */
    { 245, 245, 245,   7257 }, /* white smoke */
    { 245, 245, 245,   7269 }, /* WhiteSmoke */
    { 255, 255,   0,   7280 }, /* yellow */
    { 154, 205,  50,   7287 }, /* yellow green */
    { 255, 255,   0,   7300 }, /* yellow1 */
    { 238, 238,   0,   7308 }, /* yellow2 */
    { 205, 205,   0,   7316 }, /* yellow3 */
    { 139, 139,   0,   7324 }, /* yellow4 */
    { 154, 205,  50,   7332 }, /* YellowGreen */
};

#define NUM_BUILTIN_COLORS  (sizeof (BuiltinColors) / sizeof (BuiltinColors[0]))

Bool
OsLookupColor(int		screen,
	      char		*name,
	      unsigned int	len,
	      unsigned short	*pred,
	      unsigned short	*pgreen,
	      unsigned short	*pblue)
{
    const BuiltinColor	*c;
    int			low, mid, high;
    int			r;

    low = 0;
    high = NUM_BUILTIN_COLORS - 1;
    while (high >= low)
    {
	mid = (low + high) / 2;
	c = &BuiltinColors[mid];
	r = strncasecmp (&BuiltinColorNames[c->name], name, len);
	if (r == 0 && len == strlen (&BuiltinColorNames[c->name]))
	{
	    *pred = c->red * 0x101;
	    *pgreen = c->green * 0x101;
	    *pblue = c->blue * 0x101;
	    return TRUE;
	}
	if (r < 0)
	    low = mid + 1;
	else
	    high = mid - 1;
    }
    return FALSE;
}
/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _OSDEP_H_
#define _OSDEP_H_ 1

#define BOTIMEOUT 200 /* in milliseconds */
#define BUFSIZE 4096
#define BUFWATERMARK 8192

#if defined(XDMCP) || defined(HASXDMAUTH)
#include <X11/Xdmcp.h>
#endif

#ifdef _POSIX_SOURCE
#include <limits.h>
#else
#define _POSIX_SOURCE
#include <limits.h>
#undef _POSIX_SOURCE
#endif

#ifndef OPEN_MAX
#ifdef SVR4
#define OPEN_MAX 256
#else
#include <sys/param.h>
#ifndef OPEN_MAX
#if defined(NOFILE) && !defined(NOFILES_MAX)
#define OPEN_MAX NOFILE
#else
#if !defined(WIN32)
#define OPEN_MAX NOFILES_MAX
#else
#define OPEN_MAX 256
#endif
#endif
#endif
#endif
#endif

#include <X11/Xpoll.h>

/*
 * MAXSOCKS is used only for initialising MaxClients when no other method
 * like sysconf(_SC_OPEN_MAX) is not supported.
 */

#if OPEN_MAX <= 256
#define MAXSOCKS (OPEN_MAX - 1)
#else
#define MAXSOCKS 256
#endif

/* MAXSELECT is the number of fds that select() can handle */
#define MAXSELECT (sizeof(fd_set) * NBBY)

#ifndef HAS_GETDTABLESIZE
#if !defined(SVR4) && !defined(SYSV)
#define HAS_GETDTABLESIZE
#endif
#endif

#include <stddef.h>

#if defined(XDMCP) || defined(HASXDMAUTH)
typedef Bool (*ValidatorFunc)(ARRAY8Ptr Auth, ARRAY8Ptr Data, int packet_type);
typedef Bool (*GeneratorFunc)(ARRAY8Ptr Auth, ARRAY8Ptr Data, int packet_type);
typedef Bool (*AddAuthorFunc)(unsigned name_length, const char *name,
			      unsigned data_length, char *data);
#endif

typedef struct _connectionInput {
    struct _connectionInput *next;
    char *buffer;               /* contains current client input */
    char *bufptr;               /* pointer to current start of data */
    int  bufcnt;                /* count of bytes in buffer */
    int lenLastReq;
    int size;
    unsigned int ignoreBytes;   /* bytes to ignore before the next request */
} ConnectionInput, *ConnectionInputPtr;

typedef struct _connectionOutput {
    struct _connectionOutput *next;
    int size;
    unsigned char *buf;
    int count;
} ConnectionOutput, *ConnectionOutputPtr;

struct _osComm;

#define AuthInitArgs void
typedef void (*AuthInitFunc) (AuthInitArgs);

#define AuthAddCArgs unsigned short data_length, const char *data, XID id
typedef int (*AuthAddCFunc) (AuthAddCArgs);

#define AuthCheckArgs unsigned short data_length, const char *data, ClientPtr client, char **reason
typedef XID (*AuthCheckFunc) (AuthCheckArgs);

#define AuthFromIDArgs XID id, unsigned short *data_lenp, char **datap
typedef int (*AuthFromIDFunc) (AuthFromIDArgs);

#define AuthGenCArgs unsigned data_length, const char *data, XID id, unsigned *data_length_return, char **data_return
typedef XID (*AuthGenCFunc) (AuthGenCArgs);

#define AuthRemCArgs unsigned short data_length, const char *data
typedef int (*AuthRemCFunc) (AuthRemCArgs);

#define AuthRstCArgs void
typedef int (*AuthRstCFunc) (AuthRstCArgs);

#define AuthToIDArgs unsigned short data_length, char *data
typedef XID (*AuthToIDFunc) (AuthToIDArgs);

typedef void (*OsCloseFunc)(ClientPtr);

typedef int (*OsFlushFunc)(ClientPtr who, struct _osComm * oc, char* extraBuf, int extraCount);

typedef struct _osComm {
    int fd;
    ConnectionInputPtr input;
    ConnectionOutputPtr output;
    XID	auth_id;		/* authorization id */
    CARD32 conn_time;		/* timestamp if not established, else 0  */
    struct _XtransConnInfo *trans_conn; /* transport connection object */
    Bool local_client;
} OsCommRec, *OsCommPtr;

extern int FlushClient(
    ClientPtr /*who*/,
    OsCommPtr /*oc*/,
    const void * /*extraBuf*/,
    int /*extraCount*/
);

extern void FreeOsBuffers(
    OsCommPtr /*oc*/
);

#include "dix.h"

extern fd_set AllSockets;
extern fd_set AllClients;
extern fd_set LastSelectMask;
extern fd_set WellKnownConnections;
extern fd_set EnabledDevices;
extern fd_set ClientsWithInput;
extern fd_set ClientsWriteBlocked;
extern fd_set OutputPending;
extern fd_set IgnoredClientsWithInput;

#ifndef WIN32
extern int *ConnectionTranslation;
#else
extern int GetConnectionTranslation(int conn);
extern void SetConnectionTranslation(int conn, int client);
extern void ClearConnectionTranslation(void);
#endif
 
extern Bool NewOutputPending;
extern Bool AnyClientsWriteBlocked;

extern WorkQueuePtr workQueue;

/* in WaitFor.c */
#ifdef WIN32
typedef long int fd_mask;
#endif
#define ffs mffs
extern int mffs(fd_mask);

/* in access.c */
extern Bool ComputeLocalClient(ClientPtr client);

/* in auth.c */
extern void GenerateRandomData (int len, char *buf);

/* in mitauth.c */
extern XID  MitCheckCookie    (AuthCheckArgs);
extern XID  MitGenerateCookie (AuthGenCArgs);
extern XID  MitToID           (AuthToIDArgs);
extern int  MitAddCookie      (AuthAddCArgs);
extern int  MitFromID         (AuthFromIDArgs);
extern int  MitRemoveCookie   (AuthRemCArgs);
extern int  MitResetCookie    (AuthRstCArgs);

/* in xdmauth.c */
#ifdef HASXDMAUTH
extern XID  XdmCheckCookie    (AuthCheckArgs);
extern XID  XdmToID           (AuthToIDArgs);
extern int  XdmAddCookie      (AuthAddCArgs);
extern int  XdmFromID         (AuthFromIDArgs);
extern int  XdmRemoveCookie   (AuthRemCArgs);
extern int  XdmResetCookie    (AuthRstCArgs);
#endif

/* in rpcauth.c */
#ifdef SECURE_RPC
extern void SecureRPCInit     (AuthInitArgs);
extern XID  SecureRPCCheck    (AuthCheckArgs);
extern XID  SecureRPCToID     (AuthToIDArgs);
extern int  SecureRPCAdd      (AuthAddCArgs);
extern int  SecureRPCFromID   (AuthFromIDArgs);
extern int  SecureRPCRemove   (AuthRemCArgs);
extern int  SecureRPCReset    (AuthRstCArgs);
#endif

#ifdef XDMCP
/* in xdmcp.c */
extern void XdmcpUseMsg (void);
extern int XdmcpOptions(int argc, char **argv, int i);
extern void XdmcpRegisterConnection (
    int	    type,
    const char    *address,
    int	    addrlen);
extern void XdmcpRegisterAuthorizations (void);
extern void XdmcpRegisterAuthorization (const char *name, int namelen);
extern void XdmcpInit (void);
extern void XdmcpReset (void);
extern void XdmcpOpenDisplay(int sock);
extern void XdmcpCloseDisplay(int sock);
extern void XdmcpRegisterAuthentication (
    const char    *name,
    int	    namelen,
    const char    *data,
    int	    datalen,
    ValidatorFunc Validator,
    GeneratorFunc Generator,
    AddAuthorFunc AddAuth);

struct sockaddr_in;
extern void XdmcpRegisterBroadcastAddress (const struct sockaddr_in *addr);
#endif

#ifdef HASXDMAUTH
extern void XdmAuthenticationInit (const char *cookie, int cookie_length);
#endif

#endif /* _OSDEP_H_ */
/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include "os.h"
#include "osdep.h"
#include <X11/Xos.h>
#include <signal.h>
#include <errno.h>
#ifdef HAVE_DLFCN_H
# include <dlfcn.h>
#endif
#ifdef HAVE_BACKTRACE
#include <execinfo.h>
#endif

#include "misc.h"

#include "dixstruct.h"


#if !defined(SYSV) && !defined(WIN32) 
#include <sys/resource.h>
#endif

#ifndef ADMPATH
#define ADMPATH "/usr/adm/X%smsgs"
#endif

extern char *display;
#ifdef RLIMIT_DATA
int limitDataSpace = -1;
#endif
#ifdef RLIMIT_STACK
int limitStackSpace = -1;
#endif
#ifdef RLIMIT_NOFILE
int limitNoFile = -1;
#endif

static OsSigWrapperPtr OsSigWrapper = NULL;

OsSigWrapperPtr
OsRegisterSigWrapper(OsSigWrapperPtr newSigWrapper)
{
    OsSigWrapperPtr oldSigWrapper = OsSigWrapper;

    OsSigWrapper = newSigWrapper;

    return oldSigWrapper;
}

/*
 * OsSigHandler --
 *    Catch unexpected signals and exit or continue cleanly.
 */
static void
#ifdef SA_SIGINFO
OsSigHandler(int signo, siginfo_t *sip, void *unused)
#else
OsSigHandler(int signo)
#endif
{
#ifdef RTLD_DI_SETSIGNAL
  const char *dlerr = dlerror();

  if (dlerr) {
      LogMessage(X_ERROR, "Dynamic loader error: %s\n", dlerr);
  }
#endif /* RTLD_DI_SETSIGNAL */

  if (OsSigWrapper != NULL) {
      if (OsSigWrapper(signo) == 0) {
	  /* ddx handled signal and wants us to continue */
	  return;
      }
  }

  /* log, cleanup, and abort */
  xorg_backtrace();

#ifdef SA_SIGINFO
  if (sip->si_code == SI_USER) {
      ErrorF("Recieved signal %d sent by process %ld, uid %ld\n",
	     signo, (long) sip->si_pid, (long) sip->si_uid);
  } else {
      switch (signo) {
          case SIGSEGV:
          case SIGBUS:
          case SIGILL:
          case SIGFPE:
	      ErrorF("%s at address %p\n", strsignal(signo), sip->si_addr);
      }
  }
#endif

  FatalError("Caught signal %d (%s). Server aborting\n",
	     signo, strsignal(signo));
}

void
OsInit(void)
{
    static Bool been_here = FALSE;
    static char* devnull = "/dev/null";
    char fname[PATH_MAX];

    if (!been_here) {
#if !(defined(_WIN32) && !defined(__CYGWIN__))
	struct sigaction act, oact;
	int i;
	int siglist[] = { SIGSEGV, SIGQUIT, SIGILL, SIGFPE, SIGBUS,
			  SIGSYS,
			  SIGXCPU,
			  SIGXFSZ,
#ifdef SIGEMT
			  SIGEMT,
#endif
			  0 /* must be last */ };
	sigemptyset(&act.sa_mask);
#ifdef SA_SIGINFO
	act.sa_sigaction = OsSigHandler;
	act.sa_flags = SA_SIGINFO;
#else
        act.sa_handler = OsSigHandler;
        act.sa_flags = 0;
#endif
	for (i = 0; siglist[i] != 0; i++) {
	    if (sigaction(siglist[i], &act, &oact)) {
		ErrorF("failed to install signal handler for signal %d: %s\n",
		       siglist[i], strerror(errno));
	    }
	}
#ifdef HAVE_BACKTRACE
	/*
	 * initialize the backtracer, since the ctor calls dlopen(), which
	 * calls malloc(), which isn't signal-safe.
	 */
	do {
	    void *array;
	    backtrace(&array, 1);
	} while (0);
#endif

#ifdef RTLD_DI_SETSIGNAL
	/* Tell runtime linker to send a signal we can catch instead of SIGKILL
	 * for failures to load libraries/modules at runtime so we can clean up
	 * after ourselves.
	 */
	int failure_signal = SIGQUIT;
	dlinfo(RTLD_SELF, RTLD_DI_SETSIGNAL, &failure_signal);
#endif

#endif /* exclude from native windows builds. */

#if !defined(__CYGWIN__) 
	fclose(stdin);
	fclose(stdout);
#endif
	/* 
	 * If a write of zero bytes to stderr returns non-zero, i.e. -1, 
	 * then writing to stderr failed, and we'll write somewhere else 
	 * instead. (Apparently this never happens in the Real World.)
	 */
	if (write (2, fname, 0) == -1) 
	{
	    FILE *err;

	    if (strlen (display) + strlen (ADMPATH) + 1 < sizeof fname)
		sprintf (fname, ADMPATH, display);
	    else
		strcpy (fname, devnull);
	    /*
	     * uses stdio to avoid os dependencies here,
	     * a real os would use
 	     *  open (fname, O_WRONLY|O_APPEND|O_CREAT, 0666)
	     */
	    if (!(err = fopen (fname, "a+")))
		err = fopen (devnull, "w");
	    if (err && (fileno(err) != 2)) {
		dup2 (fileno (err), 2);
		fclose (err);
	    }
#if defined(SYSV) || defined(SVR4) || defined(WIN32) || defined(__CYGWIN__)
	    {
	    static char buf[BUFSIZ];
	    setvbuf (stderr, buf, _IOLBF, BUFSIZ);
	    }
#else
	    setlinebuf(stderr);
#endif
	}

#ifndef __MINGW32__
	if (getpgrp () == 0)
	    setpgid (0, 0);
#endif

#ifdef RLIMIT_DATA
	if (limitDataSpace >= 0)
	{
	    struct rlimit	rlim;

	    if (!getrlimit(RLIMIT_DATA, &rlim))
	    {
		if ((limitDataSpace > 0) && (limitDataSpace < rlim.rlim_max))
		    rlim.rlim_cur = limitDataSpace;
		else
		    rlim.rlim_cur = rlim.rlim_max;
		(void)setrlimit(RLIMIT_DATA, &rlim);
	    }
	}
#endif
#ifdef RLIMIT_STACK
	if (limitStackSpace >= 0)
	{
	    struct rlimit	rlim;

	    if (!getrlimit(RLIMIT_STACK, &rlim))
	    {
		if ((limitStackSpace > 0) && (limitStackSpace < rlim.rlim_max))
		    rlim.rlim_cur = limitStackSpace;
		else
		    rlim.rlim_cur = rlim.rlim_max;
		(void)setrlimit(RLIMIT_STACK, &rlim);
	    }
	}
#endif
#ifdef RLIMIT_NOFILE
	if (limitNoFile >= 0)
	{
	    struct rlimit	rlim;

	    if (!getrlimit(RLIMIT_NOFILE, &rlim))
	    {
		if ((limitNoFile > 0) && (limitNoFile < rlim.rlim_max))
		    rlim.rlim_cur = limitNoFile;
		else
		    rlim.rlim_cur = rlim.rlim_max;
		(void)setrlimit(RLIMIT_NOFILE, &rlim);
	    }
	}
#endif
#ifdef LOCK_SERVER
	LockServer();
#endif
	been_here = TRUE;
    }
    TimerInit();
    OsVendorInit();
    /*
     * No log file by default.  OsVendorInit() should call LogInit() with the
     * log file name if logging to a file is desired.
     */
    LogInit(NULL, NULL);
    SmartScheduleInit ();
}

void
OsCleanup(Bool terminating)
{
    if (terminating)
    {
#ifdef LOCK_SERVER
	UnlockServer();
#endif
    }
}
/*

Copyright 1991, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*
 * SUN-DES-1 authentication mechanism
 * Author:  Mayank Choudhary, Sun Microsystems
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef SECURE_RPC

#include <X11/X.h>
#include <X11/Xauth.h>
#include "misc.h"
#include "os.h"
#include "osdep.h"
#include "dixstruct.h"

#include <rpc/rpc.h>

#ifdef sun
/* <rpc/auth.h> only includes this if _KERNEL is #defined... */
extern bool_t xdr_opaque_auth(XDR *, struct opaque_auth *);
#endif

static enum auth_stat why;

static char * 
authdes_ezdecode(const char *inmsg, int len)
{
    struct rpc_msg  msg;
    char            cred_area[MAX_AUTH_BYTES];
    char            verf_area[MAX_AUTH_BYTES];
    char            *temp_inmsg;
    struct svc_req  r;
    bool_t          res0, res1;
    XDR             xdr;
    SVCXPRT         xprt;

    temp_inmsg = malloc(len);
    memmove(temp_inmsg, inmsg, len);

    memset((char *)&msg, 0, sizeof(msg));
    memset((char *)&r, 0, sizeof(r));
    memset(cred_area, 0, sizeof(cred_area));
    memset(verf_area, 0, sizeof(verf_area));

    msg.rm_call.cb_cred.oa_base = cred_area;
    msg.rm_call.cb_verf.oa_base = verf_area;
    why = AUTH_FAILED; 
    xdrmem_create(&xdr, temp_inmsg, len, XDR_DECODE);

    if ((r.rq_clntcred = malloc(MAX_AUTH_BYTES)) == NULL)
        goto bad1;
    r.rq_xprt = &xprt;

    /* decode into msg */
    res0 = xdr_opaque_auth(&xdr, &(msg.rm_call.cb_cred)); 
    res1 = xdr_opaque_auth(&xdr, &(msg.rm_call.cb_verf));
    if ( ! (res0 && res1) )
         goto bad2;

    /* do the authentication */

    r.rq_cred = msg.rm_call.cb_cred;        /* read by opaque stuff */
    if (r.rq_cred.oa_flavor != AUTH_DES) {
        why = AUTH_TOOWEAK;
        goto bad2;
    }
#ifdef SVR4
    if ((why = __authenticate(&r, &msg)) != AUTH_OK) {
#else
    if ((why = _authenticate(&r, &msg)) != AUTH_OK) {
#endif
            goto bad2;
    }
    return (((struct authdes_cred *) r.rq_clntcred)->adc_fullname.name); 

bad2:
    free(r.rq_clntcred);
bad1:
    return ((char *)0); /* ((struct authdes_cred *) NULL); */
}

static XID  rpc_id = (XID) ~0L;

static Bool
CheckNetName (
    unsigned char    *addr,
    short	    len,
    pointer	    closure
)
{
    return (len == strlen ((char *) closure) &&
	    strncmp ((char *) addr, (char *) closure, len) == 0);
}

static char rpc_error[MAXNETNAMELEN+50];

_X_HIDDEN XID
SecureRPCCheck (unsigned short data_length, const char *data,
    ClientPtr client, char **reason)
{
    char *fullname;
    
    if (rpc_id == (XID) ~0L) {
	*reason = "Secure RPC authorization not initialized";
    } else {
	fullname = authdes_ezdecode(data, data_length);
	if (fullname == (char *)0) {
	    sprintf(rpc_error, "Unable to authenticate secure RPC client (why=%d)", why);
	    *reason = rpc_error;
	} else {
	    if (ForEachHostInFamily (FamilyNetname, CheckNetName, fullname))
		return rpc_id;
	    sprintf(rpc_error, "Principal \"%s\" is not authorized to connect",
			fullname);
	    *reason = rpc_error;
	}
    }
    return (XID) ~0L;
}
    
_X_HIDDEN void
SecureRPCInit (void)
{
    if (rpc_id == ~0L)
	AddAuthorization (9, "SUN-DES-1", 0, (char *) 0);
}

_X_HIDDEN int
SecureRPCAdd (unsigned short data_length, const char *data, XID id)
{
    if (data_length)
	AddHost ((pointer) 0, FamilyNetname, data_length, data);
    rpc_id = id;
    return 1;
}

_X_HIDDEN int
SecureRPCReset (void)
{
    rpc_id = (XID) ~0L;
    return 1;
}

_X_HIDDEN XID
SecureRPCToID (unsigned short data_length, char *data)
{
    return rpc_id;
}

_X_HIDDEN int
SecureRPCFromID (XID id, unsigned short *data_lenp, char **datap)
{
    return 0;
}

_X_HIDDEN int
SecureRPCRemove (unsigned short data_length, const char *data)
{
    return 0;
}
#endif /* SECURE_RPC */
/*
 * Copyright (c) 1987, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <ctype.h>
#include "dix.h"

#ifdef NEED_STRCASECMP
int
xstrcasecmp(const char *str1, const char *str2)
{
    const u_char *us1 = (const u_char *)str1, *us2 = (const u_char *)str2;

    while (tolower(*us1) == tolower(*us2)) {
        if (*us1++ == '\0')
            return 0;
        us2++;
    }

    return (tolower(*us1) - tolower(*us2));
}
#endif

#ifdef NEED_STRNCASECMP
int
xstrncasecmp(const char *s1, const char *s2, size_t n)
{
    if (n != 0) {
        const u_char *us1 = (const u_char *)s1, *us2 = (const u_char *)s2;

        do {
            if (tolower(*us1) != tolower(*us2++))
                return (tolower(*us1) - tolower(*--us2));
            if (*us1++ == '\0')
                break;
        } while (--n != 0);
    }

    return 0;
}
#endif
/*-
 * Copyright (c) 1990, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <ctype.h>
#include <string.h>
#include "dix.h"

/*
 * Find the first occurrence of find in s, ignore case.
 */
#ifdef NEED_STRCASESTR
char *
xstrcasestr(const char *s, const char *find)
{
        char c, sc;
        size_t len;

        if ((c = *find++) != 0) {
                c = tolower((unsigned char)c);
                len = strlen(find);
                do {
                        do {
                                if ((sc = *s++) == 0)
                                        return NULL;
                        } while ((char)tolower((unsigned char)sc) != c);
                } while (strncasecmp(s, find, len) != 0);
                s--;
        }
        return ((char *)s);
}
#endif
/*
 * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/types.h>
#include <string.h>
#include "os.h"

/*
 * Appends src to string dst of size siz (unlike strncat, siz is the
 * full size of dst, not space left).  At most siz-1 characters
 * will be copied.  Always NUL terminates (unless siz <= strlen(dst)).
 * Returns strlen(src) + MIN(siz, strlen(initial dst)).
 * If retval >= siz, truncation occurred.
 */
size_t
strlcat(char *dst, const char *src, size_t siz)
{
	register char *d = dst;
	register const char *s = src;
	register size_t n = siz;
	size_t dlen;

	/* Find the end of dst and adjust bytes left but don't go past end */
	while (n-- != 0 && *d != '\0')
		d++;
	dlen = d - dst;
	n = siz - dlen;

	if (n == 0)
		return(dlen + strlen(s));
	while (*s != '\0') {
		if (n != 1) {
			*d++ = *s;
			n--;
		}
		s++;
	}
	*d = '\0';

	return(dlen + (s - src));	/* count does not include NUL */
}
/*
 * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/types.h>
#include <string.h>
#include "os.h"

/*
 * Copy src to string dst of size siz.  At most siz-1 characters
 * will be copied.  Always NUL terminates (unless siz == 0).
 * Returns strlen(src); if retval >= siz, truncation occurred.
 */
size_t
strlcpy(char *dst, const char *src, size_t siz)
{
	register char *d = dst;
	register const char *s = src;
	register size_t n = siz;

	/* Copy as many bytes as will fit */
	if (n != 0 && --n != 0) {
		do {
			if ((*d++ = *s++) == 0)
				break;
		} while (--n != 0);
	}

	/* Not enough room in dst, add NUL and traverse rest of src */
	if (n == 0) {
		if (siz != 0)
			*d = '\0';		/* NUL-terminate dst */
		while (*s++)
			;
	}

	return s - src - 1;	/* count does not include NUL */
}
/*

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
Copyright 1994 Quarterdeck Office Systems.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital and
Quarterdeck not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

DIGITAL AND QUARTERDECK DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT
OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
OR PERFORMANCE OF THIS SOFTWARE.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef __CYGWIN__
#include <stdlib.h>
#include <signal.h>
/*
   Sigh... We really need a prototype for this to know it is stdcall,
   but #include-ing <windows.h> here is not a good idea...
*/
__stdcall unsigned long GetTickCount(void);
#endif


#include <X11/Xos.h>
#include <stdio.h>
#include <time.h>
#ifdef __MINGW32__
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501
#endif
#include <X11/Xwinsock.h>
#include <ws2tcpip.h>
#else
#include <sys/time.h>
#include <sys/resource.h>
#endif
#include "misc.h"
#include <X11/X.h>
#ifndef XSERV_t
#define XSERV_t
#endif
#ifndef TRANS_SERVER
#define TRANS_SERVER
#endif
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include "input.h"
#include "dixfont.h"
#include "osdep.h"
#include "extension.h"
#ifdef X_POSIX_C_SOURCE
#define _POSIX_C_SOURCE X_POSIX_C_SOURCE
#include <signal.h>
#undef _POSIX_C_SOURCE
#else
#if defined(_POSIX_SOURCE)
#include <signal.h>
#else
#define _POSIX_SOURCE
#include <signal.h>
#undef _POSIX_SOURCE
#endif
#endif
#ifndef WIN32
#include <sys/wait.h>
#endif
#if !defined(SYSV) && !defined(WIN32) 
#include <sys/resource.h>
#endif
#include <sys/stat.h>
#include <ctype.h>    /* for isspace */
#include <stdarg.h>

#include <stdlib.h>	/* for malloc() */

#if defined(TCPCONN) || defined(STREAMSCONN)
# ifndef WIN32
#  include <netdb.h>
# endif
#endif

#include "opaque.h"

#include "dixstruct.h"

#include "xkbsrv.h"

#include "picture.h"

Bool noTestExtensions;
#ifdef COMPOSITE
#ifdef __MINGW32__
Bool noCompositeExtension = TRUE;
#else
Bool noCompositeExtension = FALSE;
#endif
#endif

#ifdef DAMAGE
Bool noDamageExtension = FALSE;
#endif
#ifdef DBE
Bool noDbeExtension = FALSE;
#endif
#ifdef DPMSExtension
Bool noDPMSExtension = FALSE;
#endif
#ifdef GLXEXT
Bool noGlxExtension = FALSE;
Bool noGlxVisualInit = FALSE;
#endif
#ifdef SCREENSAVER
Bool noScreenSaverExtension = FALSE;
#endif
#ifdef MITSHM
Bool noMITShmExtension = FALSE;
#endif
#ifdef RANDR
Bool noRRExtension = FALSE;
#endif
Bool noRenderExtension = FALSE;
#ifdef XCSECURITY
Bool noSecurityExtension = FALSE;
#endif
#ifdef RES
Bool noResExtension = FALSE;
#endif
#ifdef XF86BIGFONT
Bool noXFree86BigfontExtension = FALSE;
#endif
#ifdef XFreeXDGA
Bool noXFree86DGAExtension = FALSE;
#endif
#ifdef XF86DRI
Bool noXFree86DRIExtension = FALSE;
#endif
#ifdef XF86VIDMODE
Bool noXFree86VidModeExtension = FALSE;
#endif
#ifdef XFIXES
Bool noXFixesExtension = FALSE;
#endif
#ifdef PANORAMIX
/* Xinerama is disabled by default unless enabled via +xinerama */
Bool noPanoramiXExtension = TRUE;
#endif
#ifdef XSELINUX
Bool noSELinuxExtension = FALSE;
int selinuxEnforcingState = SELINUX_MODE_DEFAULT;
#endif
#ifdef XV
Bool noXvExtension = FALSE;
#endif
#ifdef DRI2
Bool noDRI2Extension = FALSE;
#endif

Bool noGEExtension = FALSE;

#define X_INCLUDE_NETDB_H
#include <X11/Xos_r.h>

#include <errno.h>

Bool CoreDump;

#ifdef PANORAMIX
Bool PanoramiXExtensionDisabledHack = FALSE;
#endif

int auditTrailLevel = 1;

#ifdef __MINGW32__
static HANDLE s_hSmartScheduleTimer = NULL;
static HANDLE s_hSmartScheduleTimerQueue = NULL;
static VOID CALLBACK SmartScheduleTimer(PVOID lpParameter, BOOLEAN TimerOrWaitFired);
#endif

#if defined(SVR4) || defined(__linux__) || defined(CSRG_BASED)
#define HAS_SAVED_IDS_AND_SETEUID
#endif

OsSigHandlerPtr
OsSignal(int sig, OsSigHandlerPtr handler)
{
#if defined(WIN32) && defined(__MINGW32__)
    return signal(sig, handler);
#else
    struct sigaction act, oact;

    sigemptyset(&act.sa_mask);
    if (handler != SIG_IGN)
	sigaddset(&act.sa_mask, sig);
    act.sa_flags = 0;
    act.sa_handler = handler;
    if (sigaction(sig, &act, &oact))
      perror("sigaction");
    return oact.sa_handler;
#endif
}

/*
 * Explicit support for a server lock file like the ones used for UUCP.
 * For architectures with virtual terminals that can run more than one
 * server at a time.  This keeps the servers from stomping on each other
 * if the user forgets to give them different display numbers.
 */
#define LOCK_DIR "/tmp"
#define LOCK_TMP_PREFIX "/.tX"
#define LOCK_PREFIX "/.X"
#define LOCK_SUFFIX "-lock"

static Bool nolock = FALSE;

#ifdef SERVER_LOCK
#ifdef __MINGW32__
/* work around function in winbase.h */
#define LockFile XLockFile
#endif
static Bool StillLocking = FALSE;
static char LockFile[PATH_MAX];


/*
 * LockServer --
 *      Check if the server lock file exists.  If so, check if the PID
 *      contained inside is valid.  If so, then die.  Otherwise, create
 *      the lock file containing the PID.
 */
void
LockServer(void)
{
  char tmp[PATH_MAX], pid_str[12];
  int lfd, i, haslock, l_pid, t;
  char *tmppath = NULL;
  int len;
  char port[20];

  if (nolock) return;
  /*
   * Path names
   */
  tmppath = LOCK_DIR;

  sprintf(port, "%d", atoi(display));
  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :
						strlen(LOCK_TMP_PREFIX);
  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;
  if (len > sizeof(LockFile))
    FatalError("Display name `%s' is too long\n", port);
  (void)sprintf(tmp, "%s" LOCK_TMP_PREFIX "%s" LOCK_SUFFIX, tmppath, port);
  (void)sprintf(LockFile, "%s" LOCK_PREFIX "%s" LOCK_SUFFIX, tmppath, port);

  /*
   * Create a temporary file containing our PID.  Attempt three times
   * to create the file.
   */
  StillLocking = TRUE;
  i = 0;
  do {
    i++;
    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
    if (lfd < 0)
       sleep(2);
    else
       break;
  } while (i < 3);
  if (lfd < 0) {
    unlink(tmp);
    i = 0;
    do {
      i++;
      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
      if (lfd < 0)
         sleep(2);
      else
         break;
    } while (i < 3);
  }
  if (lfd < 0)
    FatalError("Could not create lock file in %s\n", tmp);
  (void) sprintf(pid_str, "%10ld\n", (long)getpid());
  (void) write(lfd, pid_str, 11);
  (void) fchmod(lfd, 0444);
  (void) close(lfd);

  /*
   * OK.  Now the tmp file exists.  Try three times to move it in place
   * for the lock.
   */
  i = 0;
  haslock = 0;
  while ((!haslock) && (i++ < 3)) {
    haslock = (link(tmp,LockFile) == 0);
    if (haslock) {
      /*
       * We're done.
       */
      break;
    }
    else {
      /*
       * Read the pid from the existing file
       */
      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);
      if (lfd < 0) {
        unlink(tmp);
        FatalError("Can't read lock file %s\n", LockFile);
      }
      pid_str[0] = '\0';
      if (read(lfd, pid_str, 11) != 11) {
        /*
         * Bogus lock file.
         */
        unlink(LockFile);
        close(lfd);
        continue;
      }
      pid_str[11] = '\0';
      sscanf(pid_str, "%d", &l_pid);
      close(lfd);

      /*
       * Now try to kill the PID to see if it exists.
       */
      errno = 0;
      t = kill(l_pid, 0);
      if ((t< 0) && (errno == ESRCH)) {
        /*
         * Stale lock file.
         */
        unlink(LockFile);
        continue;
      }
      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {
        /*
         * Process is still active.
         */
        unlink(tmp);
	FatalError("Server is already active for display %s\n%s %s\n%s\n",
		   port, "\tIf this server is no longer running, remove",
		   LockFile, "\tand start again.");
      }
    }
  }
  unlink(tmp);
  if (!haslock)
    FatalError("Could not create server lock file: %s\n", LockFile);
  StillLocking = FALSE;
}

/*
 * UnlockServer --
 *      Remove the server lock file.
 */
void
UnlockServer(void)
{
  if (nolock) return;

  if (!StillLocking){

  (void) unlink(LockFile);
  }
}
#endif /* SERVER_LOCK */

/* Force connections to close on SIGHUP from init */

void
AutoResetServer (int sig)
{
    int olderrno = errno;

    dispatchException |= DE_RESET;
    isItTimeToYield = TRUE;
    errno = olderrno;
}

/* Force connections to close and then exit on SIGTERM, SIGINT */

void
GiveUp(int sig)
{
    int olderrno = errno;

    dispatchException |= DE_TERMINATE;
    isItTimeToYield = TRUE;
    errno = olderrno;
}

#if (defined WIN32 && defined __MINGW32__) || defined(__CYGWIN__)
CARD32
GetTimeInMillis (void)
{
  return GetTickCount ();
}
#else
CARD32
GetTimeInMillis(void)
{
    struct timeval tv;

#ifdef MONOTONIC_CLOCK
    struct timespec tp;
    static clockid_t clockid;
    if (!clockid) {
#ifdef CLOCK_MONOTONIC_COARSE
        if (clock_getres(CLOCK_MONOTONIC_COARSE, &tp) == 0 &&
            (tp.tv_nsec / 1000) <= 1000 &&
            clock_gettime(CLOCK_MONOTONIC_COARSE, &tp) == 0)
            clockid = CLOCK_MONOTONIC_COARSE;
        else
#endif
        if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
            clockid = CLOCK_MONOTONIC;
        else
            clockid = ~0L;
    }
    if (clockid != ~0L && clock_gettime(clockid, &tp) == 0)
        return (tp.tv_sec * 1000) + (tp.tv_nsec / 1000000L);
#endif

    X_GETTIMEOFDAY(&tv);
    return(tv.tv_sec * 1000) + (tv.tv_usec / 1000);
}
#endif

void
AdjustWaitForDelay (pointer waitTime, unsigned long newdelay)
{
    static struct timeval   delay_val;
    struct timeval	    **wt = (struct timeval **) waitTime;
    unsigned long	    olddelay;

    if (*wt == NULL)
    {
	delay_val.tv_sec = newdelay / 1000;
	delay_val.tv_usec = 1000 * (newdelay % 1000);
	*wt = &delay_val;
    }
    else
    {
	olddelay = (*wt)->tv_sec * 1000 + (*wt)->tv_usec / 1000;
	if (newdelay < olddelay)
	{
	    (*wt)->tv_sec = newdelay / 1000;
	    (*wt)->tv_usec = 1000 * (newdelay % 1000);
	}
    }
}

void UseMsg(void)
{
    ErrorF("use: Xwin [:<display>] [option]\n");
    ErrorF("-a #                   default pointer acceleration (factor)\n");
    ErrorF("-ac                    disable access control restrictions\n");
    ErrorF("-audit int             set audit trail level\n");	
    ErrorF("-auth file             select authorization file\n");	
    ErrorF("-br                    create root window with black background\n");
    ErrorF("+bs                    enable any backing store support\n");
    ErrorF("-bs                    disable any backing store support\n");
    ErrorF("-c                     turns off key-click\n");
    ErrorF("c #                    key-click volume (0-100)\n");
    ErrorF("-cc int                default color visual class\n");
    ErrorF("-nocursor              disable the cursor\n");
    ErrorF("-core                  generate core dump on fatal error\n");
    ErrorF("-dpi int               screen resolution in dots per inch\n");
#ifdef DPMSExtension
    ErrorF("-dpms                  disables VESA DPMS monitor control\n");
#endif
    ErrorF("-deferglyphs [none|all|16] defer loading of [no|all|16-bit] glyphs\n");
    ErrorF("-f #                   bell base (0-100)\n");
    ErrorF("-fc string             cursor font\n");
    ErrorF("-fn string             default font name\n");
    ErrorF("-fp string             default font path\n");
    ErrorF("-help                  prints message with these options\n");
    ErrorF("-I                     ignore all remaining arguments\n");
#ifdef RLIMIT_DATA
    ErrorF("-ld int                limit data space to N Kb\n");
#endif
#ifdef RLIMIT_NOFILE
    ErrorF("-lf int                limit number of open files to N\n");
#endif
#ifdef RLIMIT_STACK
    ErrorF("-ls int                limit stack space to N Kb\n");
#endif
    ErrorF("-nolock                disable the locking mechanism\n");
    ErrorF("-nolisten string       don't listen on protocol\n");
    ErrorF("-noreset               don't reset after last client exists\n");
    ErrorF("-background [none]     create root window with no background\n");
    ErrorF("-reset                 reset after last client exists\n");
    ErrorF("-p #                   screen-saver pattern duration (minutes)\n");
    ErrorF("-pn                    accept failure to listen on all ports\n");
    ErrorF("-nopn                  reject failure to listen on all ports\n");
    ErrorF("-r                     turns off auto-repeat\n");
    ErrorF("r                      turns on auto-repeat \n");
    ErrorF("-render [default|mono|gray|color] set render color alloc policy\n");
    ErrorF("-retro                 start with classic stipple and cursor\n");
    ErrorF("-s #                   screen-saver timeout (minutes)\n");
    ErrorF("-t #                   default pointer threshold (pixels/t)\n");
    ErrorF("-terminate             terminate at server reset\n");
    ErrorF("-to #                  connection time out\n");
    ErrorF("-tst                   disable testing extensions\n");
    ErrorF("ttyxx                  server started from init on /dev/ttyxx\n");
    ErrorF("v                      video blanking for screen-saver\n");
    ErrorF("-v                     screen-saver without video blanking\n");
    ErrorF("-wm                    WhenMapped default backing-store\n");
    ErrorF("-wr                    create root window with white background\n");
    ErrorF("-maxbigreqsize         set maximal bigrequest size \n");
#ifdef PANORAMIX
    ErrorF("+xinerama              Enable XINERAMA extension\n");
    ErrorF("-xinerama              Disable XINERAMA extension\n");
#endif
#ifdef __MINGW32__
    ErrorF("-smartSched            Enable EXPERIMENTAL smart scheduling\n");
#else
    ErrorF("-dumbSched             Disable smart scheduling, enable old behavior\n");
#endif
    ErrorF("-schedInterval int     Set scheduler interval in msec\n");
    ErrorF("-sigstop               Enable SIGSTOP based startup\n");
    ErrorF("+extension name        Enable extension\n");
    ErrorF("-extension name        Disable extension\n");
#ifdef XDMCP
    XdmcpUseMsg();
#endif
    XkbUseMsg();
    ddxUseMsg();
}

/*  This function performs a rudimentary sanity check
 *  on the display name passed in on the command-line,
 *  since this string is used to generate filenames.
 *  It is especially important that the display name
 *  not contain a "/" and not start with a "-".
 *                                            --kvajk
 */
static int 
VerifyDisplayName(const char *d)
{
    if ( d == (char *)0 ) return 0;  /*  null  */
    if ( *d == '\0' ) return 0;  /*  empty  */
    if ( *d == '-' ) return 0;  /*  could be confused for an option  */
    if ( *d == '.' ) return 0;  /*  must not equal "." or ".."  */
    if ( strchr(d, '/') != (char *)0 ) return 0;  /*  very important!!!  */
    return 1;
}

/*
 * This function parses the command line. Handles device-independent fields
 * and allows ddx to handle additional fields.  It is not allowed to modify
 * argc or any of the strings pointed to by argv.
 */
void
ProcessCommandLine(int argc, char *argv[])
{
    int i, skip;

    defaultKeyboardControl.autoRepeat = TRUE;

#ifdef NO_PART_NET
    PartialNetwork = FALSE;
#else
    PartialNetwork = TRUE;
#endif

    for ( i = 1; i < argc; i++ )
    {
	/* call ddx first, so it can peek/override if it wants */
        if((skip = ddxProcessArgument(argc, argv, i)))
	{
	    i += (skip - 1);
	}
	else if(argv[i][0] ==  ':')  
	{
	    /* initialize display */
	    display = argv[i];
	    display++;
            if( ! VerifyDisplayName( display ) ) {
                ErrorF("Bad display name: %s\n", display);
                UseMsg();
		FatalError("Bad display name, exiting: %s\n", display);
            }
	}
	else if ( strcmp( argv[i], "-a") == 0)
	{
	    if(++i < argc)
	        defaultPointerControl.num = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-ac") == 0)
	{
	    defeatAccessControl = TRUE;
	}
	else if ( strcmp( argv[i], "-audit") == 0)
	{
	    if(++i < argc)
	        auditTrailLevel = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-auth") == 0)
	{
	    if(++i < argc)
	        InitAuthorization (argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-br") == 0) ; /* default */
	else if ( strcmp( argv[i], "+bs") == 0)
	    enableBackingStore = TRUE;
	else if ( strcmp( argv[i], "-bs") == 0)
	    disableBackingStore = TRUE;
	else if ( strcmp( argv[i], "c") == 0)
	{
	    if(++i < argc)
	        defaultKeyboardControl.click = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-c") == 0)
	{
	    defaultKeyboardControl.click = 0;
	}
	else if ( strcmp( argv[i], "-cc") == 0)
	{
	    if(++i < argc)
	        defaultColorVisualClass = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-core") == 0)
	{
#if !defined(WIN32) || !defined(__MINGW32__)
	    struct rlimit   core_limit;
	    getrlimit (RLIMIT_CORE, &core_limit);
	    core_limit.rlim_cur = core_limit.rlim_max;
	    setrlimit (RLIMIT_CORE, &core_limit);
#endif
	    CoreDump = TRUE;
	}
        else if ( strcmp( argv[i], "-nocursor") == 0)
        {
            EnableCursor = FALSE;
        }
        else if ( strcmp( argv[i], "-dpi") == 0)
	{
	    if(++i < argc)
	        monitorResolution = atoi(argv[i]);
	    else
		UseMsg();
	}
#ifdef DPMSExtension
	else if ( strcmp( argv[i], "dpms") == 0)
	    /* ignored for compatibility */ ;
	else if ( strcmp( argv[i], "-dpms") == 0)
	    DPMSDisabledSwitch = TRUE;
#endif
	else if ( strcmp( argv[i], "-deferglyphs") == 0)
	{
	    if(++i >= argc || !ParseGlyphCachingMode(argv[i]))
		UseMsg();
	}
	else if ( strcmp( argv[i], "-f") == 0)
	{
	    if(++i < argc)
	        defaultKeyboardControl.bell = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-fc") == 0)
	{
	    if(++i < argc)
	        defaultCursorFont = argv[i];
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-fn") == 0)
	{
	    if(++i < argc)
	        defaultTextFont = argv[i];
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-fp") == 0)
	{
	    if(++i < argc)
	    {
	        defaultFontPath = argv[i];
	    }
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-help") == 0)
	{
	    UseMsg();
	    exit(0);
	}
        else if ( (skip=XkbProcessArguments(argc,argv,i))!=0 ) {
	    if (skip>0)
		 i+= skip-1;
	    else UseMsg();
	}
#ifdef RLIMIT_DATA
	else if ( strcmp( argv[i], "-ld") == 0)
	{
	    if(++i < argc)
	    {
	        limitDataSpace = atoi(argv[i]);
		if (limitDataSpace > 0)
		    limitDataSpace *= 1024;
	    }
	    else
		UseMsg();
	}
#endif
#ifdef RLIMIT_NOFILE
	else if ( strcmp( argv[i], "-lf") == 0)
	{
	    if(++i < argc)
	        limitNoFile = atoi(argv[i]);
	    else
		UseMsg();
	}
#endif
#ifdef RLIMIT_STACK
	else if ( strcmp( argv[i], "-ls") == 0)
	{
	    if(++i < argc)
	    {
	        limitStackSpace = atoi(argv[i]);
		if (limitStackSpace > 0)
		    limitStackSpace *= 1024;
	    }
	    else
		UseMsg();
	}
#endif
	else if ( strcmp ( argv[i], "-nolock") == 0)
	{
#if !defined(WIN32) && !defined(__CYGWIN__)
	  if (getuid() != 0)
	    ErrorF("Warning: the -nolock option can only be used by root\n");
	  else
#endif
	    nolock = TRUE;
	}
	else if ( strcmp( argv[i], "-nolisten") == 0)
	{
            if(++i < argc) {
		if (_XSERVTransNoListen(argv[i])) 
		    FatalError ("Failed to disable listen for %s transport",
				argv[i]);
	   } else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-noreset") == 0)
	{
	    dispatchExceptionAtReset = 0;
	}
	else if ( strcmp( argv[i], "-reset") == 0)
	{
	    dispatchExceptionAtReset = DE_RESET;
	}
	else if ( strcmp( argv[i], "-p") == 0)
	{
	    if(++i < argc)
	        defaultScreenSaverInterval = ((CARD32)atoi(argv[i])) *
					     MILLI_PER_MIN;
	    else
		UseMsg();
	}
	else if (strcmp(argv[i], "-pogo") == 0)
	{
	    dispatchException = DE_TERMINATE;
	}
	else if ( strcmp( argv[i], "-pn") == 0)
	    PartialNetwork = TRUE;
	else if ( strcmp( argv[i], "-nopn") == 0)
	    PartialNetwork = FALSE;
	else if ( strcmp( argv[i], "r") == 0)
	    defaultKeyboardControl.autoRepeat = TRUE;
	else if ( strcmp( argv[i], "-r") == 0)
	    defaultKeyboardControl.autoRepeat = FALSE;
	else if ( strcmp( argv[i], "-retro") == 0)
	    party_like_its_1989 = TRUE;
	else if ( strcmp( argv[i], "-s") == 0)
	{
	    if(++i < argc)
	        defaultScreenSaverTime = ((CARD32)atoi(argv[i])) *
					 MILLI_PER_MIN;
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-t") == 0)
	{
	    if(++i < argc)
	        defaultPointerControl.threshold = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-terminate") == 0)
	{
	    dispatchExceptionAtReset = DE_TERMINATE;
	}
	else if ( strcmp( argv[i], "-to") == 0)
	{
	    if(++i < argc)
		TimeOutValue = ((CARD32)atoi(argv[i])) * MILLI_PER_SECOND;
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-tst") == 0)
	{
	    noTestExtensions = TRUE;
	}
	else if ( strcmp( argv[i], "v") == 0)
	    defaultScreenSaverBlanking = PreferBlanking;
	else if ( strcmp( argv[i], "-v") == 0)
	    defaultScreenSaverBlanking = DontPreferBlanking;
	else if ( strcmp( argv[i], "-wm") == 0)
	    defaultBackingStore = WhenMapped;
        else if ( strcmp( argv[i], "-wr") == 0)
            whiteRoot = TRUE;
        else if ( strcmp( argv[i], "-background") == 0) {
            if(++i < argc) {
                if (!strcmp ( argv[i], "none"))
                    bgNoneRoot = TRUE;
                else
                    UseMsg();
            }
        }
        else if ( strcmp( argv[i], "-maxbigreqsize") == 0) {
             if(++i < argc) {
                 long reqSizeArg = atol(argv[i]);

                 /* Request size > 128MB does not make much sense... */
                 if( reqSizeArg > 0L && reqSizeArg < 128L ) {
                     maxBigRequestSize = (reqSizeArg * 1048576L) - 1L;
                 }
                 else
                 {
                     UseMsg();
                 }
             }
             else
             {
                 UseMsg();
             }
         }
#ifdef PANORAMIX
	else if ( strcmp( argv[i], "+xinerama") == 0){
	    noPanoramiXExtension = FALSE;
	}
	else if ( strcmp( argv[i], "-xinerama") == 0){
	    noPanoramiXExtension = TRUE;
	}
	else if ( strcmp( argv[i], "-disablexineramaextension") == 0){
	    PanoramiXExtensionDisabledHack = TRUE;
	}
#endif
	else if ( strcmp( argv[i], "-I") == 0)
	{
	    /* ignore all remaining arguments */
	    break;
	}
	else if (strncmp (argv[i], "tty", 3) == 0)
	{
            /* init supplies us with this useless information */
	}
#ifdef XDMCP
	else if ((skip = XdmcpOptions(argc, argv, i)) != i)
	{
	    i = skip - 1;
	}
#endif
#ifdef __MINGW32__
	else if ( strcmp( argv[i], "-smartSched") == 0)
	{
	    SmartScheduleDisable = FALSE;
	}
#else
	else if ( strcmp( argv[i], "-dumbSched") == 0)
	{
	    SmartScheduleDisable = TRUE;
	}
#endif
	else if ( strcmp( argv[i], "-schedInterval") == 0)
	{
	    if (++i < argc)
	    {
		SmartScheduleInterval = atoi(argv[i]);
		SmartScheduleSlice = SmartScheduleInterval;
	    }
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-schedMax") == 0)
	{
	    if (++i < argc)
	    {
		SmartScheduleMaxSlice = atoi(argv[i]);
	    }
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-render" ) == 0)
	{
	    if (++i < argc)
	    {
		int policy = PictureParseCmapPolicy (argv[i]);

		if (policy != PictureCmapPolicyInvalid)
		    PictureCmapPolicy = policy;
		else
		    UseMsg ();
	    }
	    else
		UseMsg ();
	}
	else if ( strcmp( argv[i], "-sigstop") == 0)
	{
	    RunFromSigStopParent = TRUE;
	}
	else if ( strcmp( argv[i], "+extension") == 0)
	{
	    if (++i < argc)
	    {
		if (!EnableDisableExtension(argv[i], TRUE))
		    EnableDisableExtensionError(argv[i], TRUE);
	    }
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-extension") == 0)
	{
	    if (++i < argc)
	    {
		if (!EnableDisableExtension(argv[i], FALSE))
		    EnableDisableExtensionError(argv[i], FALSE);
	    }
	    else
		UseMsg();
	}
 	else
 	{
	    ErrorF("Unrecognized option: %s\n", argv[i]);
	    UseMsg();
	    FatalError("Unrecognized option: %s\n", argv[i]);
        }
    }
}

/* Implement a simple-minded font authorization scheme.  The authorization
   name is "hp-hostname-1", the contents are simply the host name. */
int
set_font_authorizations(char **authorizations, int *authlen, pointer client)
{
#define AUTHORIZATION_NAME "hp-hostname-1"
#if defined(TCPCONN) || defined(STREAMSCONN)
    static char *result = NULL;
    static char *p = NULL;

    if (p == NULL)
    {
	char hname[1024], *hnameptr;
	unsigned int len;
#if defined(IPv6) && defined(AF_INET6)
	struct addrinfo hints, *ai = NULL;
#else
	struct hostent *host;
#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
	_Xgethostbynameparams hparams;
#endif
#endif

	gethostname(hname, 1024);
#if defined(IPv6) && defined(AF_INET6)
	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = AI_CANONNAME;
	if (getaddrinfo(hname, NULL, &hints, &ai) == 0) {
	    hnameptr = ai->ai_canonname;
	} else {
	    hnameptr = hname;
	}
#else
	host = _XGethostbyname(hname, hparams);
	if (host == NULL)
	    hnameptr = hname;
	else
	    hnameptr = host->h_name;
#endif

	len = strlen(hnameptr) + 1;
	result = malloc(len + sizeof(AUTHORIZATION_NAME) + 4);

	p = result;
        *p++ = sizeof(AUTHORIZATION_NAME) >> 8;
        *p++ = sizeof(AUTHORIZATION_NAME) & 0xff;
        *p++ = (len) >> 8;
        *p++ = (len & 0xff);

	memmove(p, AUTHORIZATION_NAME, sizeof(AUTHORIZATION_NAME));
	p += sizeof(AUTHORIZATION_NAME);
	memmove(p, hnameptr, len);
	p += len;
#if defined(IPv6) && defined(AF_INET6)
	if (ai) {
	    freeaddrinfo(ai);
	}
#endif
    }
    *authlen = p - result;
    *authorizations = result;
    return 1;
#else /* TCPCONN */
    return 0;
#endif /* TCPCONN */
}

void *
Xalloc(unsigned long amount)
{
    /*
     * Xalloc used to return NULL when large amount of memory is requested. In
     * order to catch the buggy callers this warning has been added, slated to
     * removal by anyone who touches this code (or just looks at it) in 2011.
     *
     * -- Mikhail Gusarov
     */
    if ((long)amount <= 0)
	ErrorF("Warning: Xalloc: "
	       "requesting unpleasantly large amount of memory: %lu bytes.\n",
               amount);

    return malloc(amount);
}

void *
XNFalloc(unsigned long amount)
{
    void *ptr = malloc(amount);
    if (!ptr)
        FatalError("Out of memory");
    return ptr;
}

void *
Xcalloc(unsigned long amount)
{
    return calloc(1, amount);
}

void *
XNFcalloc(unsigned long amount)
{
    void *ret = calloc(1, amount);
    if (!ret)
        FatalError("XNFcalloc: Out of memory");
    return ret;
}

void *
Xrealloc(void *ptr, unsigned long amount)
{
    /*
     * Xrealloc used to return NULL when large amount of memory is requested. In
     * order to catch the buggy callers this warning has been added, slated to
     * removal by anyone who touches this code (or just looks at it) in 2011.
     *
     * -- Mikhail Gusarov
     */
    if ((long)amount <= 0)
	ErrorF("Warning: Xrealloc: "
	       "requesting unpleasantly large amount of memory: %lu bytes.\n",
               amount);

    return realloc(ptr, amount);
}

void *
XNFrealloc(void *ptr, unsigned long amount)
{
    void *ret = realloc(ptr, amount);
    if (!ret)
	FatalError("XNFrealloc: Out of memory");
    return ret;
}

void
Xfree(void *ptr)
{
    free(ptr);
}


char *
Xstrdup(const char *s)
{
    if (s == NULL)
	return NULL;
    return strdup(s);
}

char *
XNFstrdup(const char *s)
{
    char *ret;

    if (s == NULL)
	return NULL;

    ret = strdup(s);
    if (!ret)
	FatalError("XNFstrdup: Out of memory");
    return ret;
}

void
SmartScheduleStopTimer (void)
{
#ifdef __MINGW32__
    if (SmartScheduleDisable)
        return;
    DeleteTimerQueueTimer(s_hSmartScheduleTimerQueue, s_hSmartScheduleTimer, NULL);
    s_hSmartScheduleTimer = NULL;
#else
    struct itimerval	timer;
    
    if (SmartScheduleDisable)
	return;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_usec = 0;
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_usec = 0;
    (void) setitimer (ITIMER_REAL, &timer, 0);
#endif
}

void
SmartScheduleStartTimer (void)
{
#ifdef __MINGW32__
    if (SmartScheduleDisable)
        return;
    if (!CreateTimerQueueTimer(&s_hSmartScheduleTimer, s_hSmartScheduleTimerQueue, SmartScheduleTimer, NULL,
                               SmartScheduleInterval, SmartScheduleInterval, WT_EXECUTEINPERSISTENTTHREAD))
    {
        ErrorF("SmartScheduleStartTimer - CreateTimerQueueTimer() failed, smart scheduling disabled: %08x\n", (unsigned int)GetLastError());
        CloseHandle(s_hSmartScheduleTimer);
        SmartScheduleDisable = TRUE;
        return;
    }
#else
    struct itimerval	timer;
    
    if (SmartScheduleDisable)
	return;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_usec = SmartScheduleInterval * 1000;
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_usec = SmartScheduleInterval * 1000;
    setitimer (ITIMER_REAL, &timer, 0);
#endif
}

#ifdef __MINGW32__
static VOID CALLBACK SmartScheduleTimer(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
#else
static void
SmartScheduleTimer (int sig)
#endif
{
    SmartScheduleTime += SmartScheduleInterval;
}

void
SmartScheduleInit (void)
{
#ifdef __MINGW32__
    if (SmartScheduleDisable)
        return;
    s_hSmartScheduleTimerQueue = CreateTimerQueue();
    if (!s_hSmartScheduleTimerQueue)
    {
        ErrorF("SmartScheduleInit - CreateTimerQueue() failed, smart scheduling disabled: %08x\n", (unsigned int)GetLastError());
        SmartScheduleDisable = TRUE;
    }
#else
    struct sigaction	act;

    if (SmartScheduleDisable)
	return;

    memset((char *) &act, 0, sizeof(struct sigaction));

    /* Set up the timer signal function */
    act.sa_handler = SmartScheduleTimer;
    sigemptyset (&act.sa_mask);
    sigaddset (&act.sa_mask, SIGALRM);
    if (sigaction (SIGALRM, &act, 0) < 0)
    {
	perror ("sigaction for smart scheduler");
	SmartScheduleDisable = TRUE;
    }
#endif
}

#ifdef SIG_BLOCK
static sigset_t	PreviousSignalMask;
static int	BlockedSignalCount;
#endif

void
OsBlockSignals (void)
{
#ifdef SIG_BLOCK
    if (BlockedSignalCount++ == 0)
    {
	sigset_t    set;
	
	sigemptyset (&set);
	sigaddset (&set, SIGALRM);
	sigaddset (&set, SIGVTALRM);
#ifdef SIGWINCH
	sigaddset (&set, SIGWINCH);
#endif
#ifdef SIGIO
	sigaddset (&set, SIGIO);
#endif
	sigaddset (&set, SIGTSTP);
	sigaddset (&set, SIGTTIN);
	sigaddset (&set, SIGTTOU);
	sigaddset (&set, SIGCHLD);
	sigprocmask (SIG_BLOCK, &set, &PreviousSignalMask);
    }
#endif
}

void
OsReleaseSignals (void)
{
#ifdef SIG_BLOCK
    if (--BlockedSignalCount == 0)
    {
	sigprocmask (SIG_SETMASK, &PreviousSignalMask, 0);
    }
#endif
}

/*
 * Pending signals may interfere with core dumping. Provide a
 * mechanism to block signals when aborting.
 */

void
OsAbort (void)
{
#ifndef __APPLE__
    OsBlockSignals();
#endif
    abort();
}

#if !defined(WIN32)
/*
 * "safer" versions of system(3), popen(3) and pclose(3) which give up
 * all privs before running a command.
 *
 * This is based on the code in FreeBSD 2.2 libc.
 *
 * XXX It'd be good to redirect stderr so that it ends up in the log file
 * as well.  As it is now, xkbcomp messages don't end up in the log file.
 */

int
System(char *command)
{
    int pid, p;
    void (*csig)(int);
    int status;

    if (!command)
	return 1;

    csig = signal(SIGCHLD, SIG_DFL);
    if (csig == SIG_ERR) {
      perror("signal");
      return -1;
    }
    DebugF("System: `%s'\n", command);

    switch (pid = fork()) {
    case -1:	/* error */
	p = -1;
    case 0:	/* child */
	if (setgid(getgid()) == -1)
	    _exit(127);
	if (setuid(getuid()) == -1)
	    _exit(127);
	execl("/bin/sh", "sh", "-c", command, (char *)NULL);
	_exit(127);
    default:	/* parent */
	do {
	    p = waitpid(pid, &status, 0);
	} while (p == -1 && errno == EINTR);
	
    }

    if (signal(SIGCHLD, csig) == SIG_ERR) {
      perror("signal");
      return -1;
    }

    return p == -1 ? -1 : status;
}

static struct pid {
    struct pid *next;
    FILE *fp;
    int pid;
} *pidlist;

OsSigHandlerPtr old_alarm = NULL; /* XXX horrible awful hack */

pointer
Popen(char *command, char *type)
{
    struct pid *cur;
    FILE *iop;
    int pdes[2], pid;

    if (command == NULL || type == NULL)
	return NULL;

    if ((*type != 'r' && *type != 'w') || type[1])
	return NULL;

    if ((cur = malloc(sizeof(struct pid))) == NULL)
	return NULL;

    if (pipe(pdes) < 0) {
	free(cur);
	return NULL;
    }

    /* Ignore the smart scheduler while this is going on */
    old_alarm = OsSignal(SIGALRM, SIG_IGN);
    if (old_alarm == SIG_ERR) {
      close(pdes[0]);
      close(pdes[1]);
      free(cur);
      perror("signal");
      return NULL;
    }

    switch (pid = fork()) {
    case -1: 	/* error */
	close(pdes[0]);
	close(pdes[1]);
	free(cur);
	if (OsSignal(SIGALRM, old_alarm) == SIG_ERR)
	  perror("signal");
	return NULL;
    case 0:	/* child */
	if (setgid(getgid()) == -1)
	    _exit(127);
	if (setuid(getuid()) == -1)
	    _exit(127);
	if (*type == 'r') {
	    if (pdes[1] != 1) {
		/* stdout */
		dup2(pdes[1], 1);
		close(pdes[1]);
	    }
	    close(pdes[0]);
	} else {
	    if (pdes[0] != 0) {
		/* stdin */
		dup2(pdes[0], 0);
		close(pdes[0]);
	    }
	    close(pdes[1]);
	}
	execl("/bin/sh", "sh", "-c", command, (char *)NULL);
	_exit(127);
    }

    /* Avoid EINTR during stdio calls */
    OsBlockSignals ();
    
    /* parent */
    if (*type == 'r') {
	iop = fdopen(pdes[0], type);
	close(pdes[1]);
    } else {
	iop = fdopen(pdes[1], type);
	close(pdes[0]);
    }

    cur->fp = iop;
    cur->pid = pid;
    cur->next = pidlist;
    pidlist = cur;

    DebugF("Popen: `%s', fp = %p\n", command, iop);

    return iop;
}

/* fopen that drops privileges */
pointer
Fopen(char *file, char *type)
{
    FILE *iop;
#ifndef HAS_SAVED_IDS_AND_SETEUID
    struct pid *cur;
    int pdes[2], pid;

    if (file == NULL || type == NULL)
	return NULL;

    if ((*type != 'r' && *type != 'w') || type[1])
	return NULL;

    if ((cur = malloc(sizeof(struct pid))) == NULL)
	return NULL;

    if (pipe(pdes) < 0) {
	free(cur);
	return NULL;
    }

    switch (pid = fork()) {
    case -1: 	/* error */
	close(pdes[0]);
	close(pdes[1]);
	free(cur);
	return NULL;
    case 0:	/* child */
	if (setgid(getgid()) == -1)
	    _exit(127);
	if (setuid(getuid()) == -1)
	    _exit(127);
	if (*type == 'r') {
	    if (pdes[1] != 1) {
		/* stdout */
		dup2(pdes[1], 1);
		close(pdes[1]);
	    }
	    close(pdes[0]);
	} else {
	    if (pdes[0] != 0) {
		/* stdin */
		dup2(pdes[0], 0);
		close(pdes[0]);
	    }
	    close(pdes[1]);
	}
	execl("/bin/cat", "cat", file, (char *)NULL);
	_exit(127);
    }

    /* Avoid EINTR during stdio calls */
    OsBlockSignals ();
    
    /* parent */
    if (*type == 'r') {
	iop = fdopen(pdes[0], type);
	close(pdes[1]);
    } else {
	iop = fdopen(pdes[1], type);
	close(pdes[0]);
    }

    cur->fp = iop;
    cur->pid = pid;
    cur->next = pidlist;
    pidlist = cur;

    DebugF("Fopen(%s), fp = %p\n", file, iop);

    return iop;
#else
    int ruid, euid;

    ruid = getuid();
    euid = geteuid();
    
    if (seteuid(ruid) == -1) {
	    return NULL;
    }
    iop = fopen(file, type);

    if (seteuid(euid) == -1) {
	    fclose(iop);
	    return NULL;
    }
    return iop;
#endif /* HAS_SAVED_IDS_AND_SETEUID */
}

int
Pclose(pointer iop)
{
    struct pid *cur, *last;
    int pstat;
    int pid;

    DebugF("Pclose: fp = %p\n", iop);
    fclose(iop);

    for (last = NULL, cur = pidlist; cur; last = cur, cur = cur->next)
	if (cur->fp == iop)
	    break;
    if (cur == NULL)
	return -1;

    do {
	pid = waitpid(cur->pid, &pstat, 0);
    } while (pid == -1 && errno == EINTR);

    if (last == NULL)
	pidlist = cur->next;
    else
	last->next = cur->next;
    free(cur);

    /* allow EINTR again */
    OsReleaseSignals ();
    
    if (old_alarm && OsSignal(SIGALRM, old_alarm) == SIG_ERR) {
      perror("signal");
      return -1;
    }

    return pid == -1 ? -1 : pstat;
}

int
Fclose(pointer iop)
{
#ifdef HAS_SAVED_IDS_AND_SETEUID
    return fclose(iop);
#else
    return Pclose(iop);
#endif
}

#endif /* !WIN32 */


/*
 * CheckUserParameters: check for long command line arguments and long
 * environment variables.  By default, these checks are only done when
 * the server's euid != ruid.  In 3.3.x, these checks were done in an
 * external wrapper utility.
 */

/* Consider LD* variables insecure? */
#ifndef REMOVE_ENV_LD
#define REMOVE_ENV_LD 1
#endif

/* Remove long environment variables? */
#ifndef REMOVE_LONG_ENV
#define REMOVE_LONG_ENV 1
#endif

/*
 * Disallow stdout or stderr as pipes?  It's possible to block the X server
 * when piping stdout+stderr to a pipe.
 *
 * Don't enable this because it looks like it's going to cause problems.
 */
#ifndef NO_OUTPUT_PIPES
#define NO_OUTPUT_PIPES 0
#endif


/* Check args and env only if running setuid (euid == 0 && euid != uid) ? */
#ifndef CHECK_EUID
#ifndef WIN32
#define CHECK_EUID 1
#else
#define CHECK_EUID 0
#endif
#endif

/*
 * Maybe the locale can be faked to make isprint(3) report that everything
 * is printable?  Avoid it by default.
 */
#ifndef USE_ISPRINT
#define USE_ISPRINT 0
#endif

#define MAX_ARG_LENGTH          128
#define MAX_ENV_LENGTH          256
#define MAX_ENV_PATH_LENGTH     2048	/* Limit for *PATH and TERMCAP */

#if USE_ISPRINT
#include <ctype.h>
#define checkPrintable(c) isprint(c)
#else
#define checkPrintable(c) (((c) & 0x7f) >= 0x20 && ((c) & 0x7f) != 0x7f)
#endif

enum BadCode {
    NotBad = 0,
    UnsafeArg,
    ArgTooLong,
    UnprintableArg,
    EnvTooLong,
    OutputIsPipe,
    InternalError
};

#if defined(VENDORSUPPORT)
#define BUGADDRESS VENDORSUPPORT
#elif defined(BUILDERADDR)
#define BUGADDRESS BUILDERADDR
#else
#define BUGADDRESS "xorg@freedesktop.org"
#endif

void
CheckUserParameters(int argc, char **argv, char **envp)
{
    enum BadCode bad = NotBad;
    int i = 0, j;
    char *a, *e = NULL;

#if CHECK_EUID
    if (geteuid() == 0 && getuid() != geteuid())
#endif
    {
	/* Check each argv[] */
	for (i = 1; i < argc; i++) {
	    if (strcmp(argv[i], "-fp") == 0)
	    {
		i++; /* continue with next argument. skip the length check */
		if (i >= argc)
		    break;
	    } else
	    {
		if (strlen(argv[i]) > MAX_ARG_LENGTH) {
		    bad = ArgTooLong;
		    break;
		}
	    }
	    a = argv[i];
	    while (*a) {
		if (checkPrintable(*a) == 0) {
		    bad = UnprintableArg;
		    break;
		}
		a++;
	    }
	    if (bad)
		break;
	}
	if (!bad) {
	    /* Check each envp[] */
	    for (i = 0; envp[i]; i++) {

		/* Check for bad environment variables and values */
#if REMOVE_ENV_LD
		while (envp[i] && (strncmp(envp[i], "LD", 2) == 0)) {
		    for (j = i; envp[j]; j++) {
			envp[j] = envp[j+1];
		    }
		}
#endif   
		if (envp[i] && (strlen(envp[i]) > MAX_ENV_LENGTH)) {
#if REMOVE_LONG_ENV
		    for (j = i; envp[j]; j++) {
			envp[j] = envp[j+1];
		    }
		    i--;
#else
		    char *eq;
		    int len;

		    eq = strchr(envp[i], '=');
		    if (!eq)
			continue;
		    len = eq - envp[i];
		    e = malloc(len + 1);
		    if (!e) {
			bad = InternalError;
			break;
		    }
		    strncpy(e, envp[i], len);
		    e[len] = 0;
		    if (len >= 4 &&
			(strcmp(e + len - 4, "PATH") == 0 ||
			 strcmp(e, "TERMCAP") == 0)) {
			if (strlen(envp[i]) > MAX_ENV_PATH_LENGTH) {
			    bad = EnvTooLong;
			    break;
			} else {
			    free(e);
			}
		    } else {
			bad = EnvTooLong;
			break;
		    }
#endif
		}
	    }
	}
#if NO_OUTPUT_PIPES
	if (!bad) {
	    struct stat buf;

	    if (fstat(fileno(stdout), &buf) == 0 && S_ISFIFO(buf.st_mode))
		bad = OutputIsPipe;
	    if (fstat(fileno(stderr), &buf) == 0 && S_ISFIFO(buf.st_mode))
		bad = OutputIsPipe;
	}
#endif
    }
    switch (bad) {
    case NotBad:
	return;
    case UnsafeArg:
	ErrorF("Command line argument number %d is unsafe\n", i);
	break;
    case ArgTooLong:
	ErrorF("Command line argument number %d is too long\n", i);
	break;
    case UnprintableArg:
	ErrorF("Command line argument number %d contains unprintable"
		" characters\n", i);
	break;
    case EnvTooLong:
	ErrorF("Environment variable `%s' is too long\n", e);
	break;
    case OutputIsPipe:
	ErrorF("Stdout and/or stderr is a pipe\n");
	break;
    case InternalError:
	ErrorF("Internal Error\n");
	break;
    default:
	ErrorF("Unknown error\n");
	break;
    }
    FatalError("X server aborted because of unsafe environment\n");
}

/*
 * CheckUserAuthorization: check if the user is allowed to start the
 * X server.  This usually means some sort of PAM checking, and it is
 * usually only done for setuid servers (uid != euid).
 */

#ifdef USE_PAM
#include <security/pam_appl.h>
#include <security/pam_misc.h>
#include <pwd.h>
#endif /* USE_PAM */

void
CheckUserAuthorization(void)
{
#ifdef USE_PAM
    static struct pam_conv conv = {
	misc_conv,
	NULL
    };

    pam_handle_t *pamh = NULL;
    struct passwd *pw;
    int retval;

    if (getuid() != geteuid()) {
	pw = getpwuid(getuid());
	if (pw == NULL)
	    FatalError("getpwuid() failed for uid %d\n", getuid());

	retval = pam_start("xserver", pw->pw_name, &conv, &pamh);
	if (retval != PAM_SUCCESS)
	    FatalError("pam_start() failed.\n"
			"\tMissing or mangled PAM config file or module?\n");

	retval = pam_authenticate(pamh, 0);
	if (retval != PAM_SUCCESS) {
	    pam_end(pamh, retval);
	    FatalError("PAM authentication failed, cannot start X server.\n"
			"\tPerhaps you do not have console ownership?\n");
	}

	retval = pam_acct_mgmt(pamh, 0);
	if (retval != PAM_SUCCESS) {
	    pam_end(pamh, retval);
	    FatalError("PAM authentication failed, cannot start X server.\n"
			"\tPerhaps you do not have console ownership?\n");
	}

	/* this is not a session, so do not do session management */
	pam_end(pamh, PAM_SUCCESS);
    }
#endif
}

/*
 * Tokenize a string into a NULL terminated array of strings. Always returns
 * an allocated array unless an error occurs.
 */
char**
xstrtokenize(const char *str, const char *separators)
{
    char **list, **nlist;
    char *tok, *tmp;
    unsigned num = 0, n;

    if (!str)
        return NULL;
    list = calloc(1, sizeof(*list));
    if (!list)
        return NULL;
    tmp = strdup(str);
    if (!tmp)
        goto error;
    for (tok = strtok(tmp, separators); tok; tok = strtok(NULL, separators)) {
        nlist = realloc(list, (num + 2) * sizeof(*list));
        if (!nlist)
            goto error;
        list = nlist;
        list[num] = strdup(tok);
        if (!list[num])
            goto error;
        list[++num] = NULL;
    }
    free(tmp);
    return list;

error:
    free(tmp);
    for (n = 0; n < num; n++)
        free(list[n]);
    free(list);
    return NULL;
}
/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/


/*****************************************************************
 * OS Dependent input routines:
 *
 *  WaitForSomething
 *  TimerForce, TimerSet, TimerCheck, TimerFree
 *
 *****************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef WIN32
#include <X11/Xwinsock.h>
#endif
#include <X11/Xos.h>			/* for strings, fcntl, time */
#include <errno.h>
#include <stdio.h>
#include <X11/X.h>
#include "misc.h"

#include "osdep.h"
#include <X11/Xpoll.h>
#include "dixstruct.h"
#include "opaque.h"
#ifdef DPMSExtension
#include "dpmsproc.h"
#endif

#ifdef WIN32
/* Error codes from windows sockets differ from fileio error codes  */
#undef EINTR
#define EINTR WSAEINTR
#undef EINVAL
#define EINVAL WSAEINVAL
#undef EBADF
#define EBADF WSAENOTSOCK
/* Windows select does not set errno. Use GetErrno as wrapper for 
   WSAGetLastError */
#define GetErrno WSAGetLastError
#else
/* This is just a fallback to errno to hide the differences between unix and
   Windows in the code */
#define GetErrno() errno
#endif

/* like ffs, but uses fd_mask instead of int as argument, so it works
   when fd_mask is longer than an int, such as common 64-bit platforms */
/* modifications by raphael */
int
mffs(fd_mask mask)
{
    int i;

    if (!mask) return 0;
    i = 1;
    while (!(mask & 1))
    {
	i++;
	mask >>= 1;
    }
    return i;
}

#ifdef DPMSExtension
#include <X11/extensions/dpmsconst.h>
#endif

struct _OsTimerRec {
    OsTimerPtr		next;
    CARD32		expires;
    CARD32              delta;
    OsTimerCallback	callback;
    pointer		arg;
};

static void DoTimer(OsTimerPtr timer, CARD32 now, OsTimerPtr *prev);
static void CheckAllTimers(void);
static OsTimerPtr timers = NULL;

/*****************
 * WaitForSomething:
 *     Make the server suspend until there is
 *	1. data from clients or
 *	2. input events available or
 *	3. ddx notices something of interest (graphics
 *	   queue ready, etc.) or
 *	4. clients that have buffered replies/events are ready
 *
 *     If the time between INPUT events is
 *     greater than ScreenSaverTime, the display is turned off (or
 *     saved, depending on the hardware).  So, WaitForSomething()
 *     has to handle this also (that's why the select() has a timeout.
 *     For more info on ClientsWithInput, see ReadRequestFromClient().
 *     pClientsReady is an array to store ready client->index values into.
 *****************/

int
WaitForSomething(int *pClientsReady)
{
    int i;
    struct timeval waittime, *wt;
    INT32 timeout = 0;
    fd_set clientsReadable;
    fd_set clientsWritable;
    int curclient;
    int selecterr;
    static int nready;
    fd_set devicesReadable;
    CARD32 now = 0;
    Bool    someReady = FALSE;

    FD_ZERO(&clientsReadable);

    if (nready)
        SmartScheduleStopTimer();
    nready = 0;

    /* We need a while loop here to handle 
       crashed connections and the screen saver timeout */
    while (1)
    {
	/* deal with any blocked jobs */
	if (workQueue)
	    ProcessWorkQueue();
	if (XFD_ANYSET (&ClientsWithInput))
	{
	    if (!SmartScheduleDisable)
	    {
		someReady = TRUE;
		waittime.tv_sec = 0;
		waittime.tv_usec = 0;
		wt = &waittime;
	    }
	    else
	    {
		XFD_COPYSET (&ClientsWithInput, &clientsReadable);
		break;
	    }
	}
	if (someReady)
	{
	    XFD_COPYSET(&AllSockets, &LastSelectMask);
	    XFD_UNSET(&LastSelectMask, &ClientsWithInput);
	}
	else
	{
        wt = NULL;
	if (timers)
        {
            now = GetTimeInMillis();
	    timeout = timers->expires - now;
            if (timeout > 0 && timeout > timers->delta + 250) {
                /* time has rewound.  reset the timers. */
                CheckAllTimers();
            }

	    if (timers) {
		timeout = timers->expires - now;
		if (timeout < 0)
		    timeout = 0;
		waittime.tv_sec = timeout / MILLI_PER_SECOND;
		waittime.tv_usec = (timeout % MILLI_PER_SECOND) *
				   (1000000 / MILLI_PER_SECOND);
		wt = &waittime;
	    }
	}
	XFD_COPYSET(&AllSockets, &LastSelectMask);
	}

	BlockHandler((pointer)&wt, (pointer)&LastSelectMask);
	if (NewOutputPending)
	    FlushAllOutput();
	/* keep this check close to select() call to minimize race */
	if (dispatchException)
	    i = -1;
	else if (AnyClientsWriteBlocked)
	{
	    XFD_COPYSET(&ClientsWriteBlocked, &clientsWritable);
	    i = Select (MaxClients, &LastSelectMask, &clientsWritable, NULL, wt);
	}
	else 
	{
	    i = Select (MaxClients, &LastSelectMask, NULL, NULL, wt);
	}
	selecterr = GetErrno();
	WakeupHandler(i, (pointer)&LastSelectMask);
	if (i <= 0) /* An error or timeout occurred */
	{
	    if (dispatchException)
		return 0;
	    if (i < 0) 
	    {
		if (selecterr == EBADF)    /* Some client disconnected */
		{
		    CheckConnections ();
		    if (! XFD_ANYSET (&AllClients))
			return 0;
		}
		else if (selecterr == EINVAL)
		{
		    FatalError("WaitForSomething(): select: %s\n",
			strerror(selecterr));
            }
		else if (selecterr != EINTR && selecterr != EAGAIN)
		{
		    ErrorF("WaitForSomething(): select: %s\n",
			strerror(selecterr));
		}
	    }
	    else if (someReady)
	    {
		/*
		 * If no-one else is home, bail quickly
		 */
		XFD_COPYSET(&ClientsWithInput, &LastSelectMask);
		XFD_COPYSET(&ClientsWithInput, &clientsReadable);
		break;
	    }
	    if (*checkForInput[0] != *checkForInput[1])
		return 0;

	    if (timers)
	    {
                int expired = 0;
		now = GetTimeInMillis();
		if ((int) (timers->expires - now) <= 0)
		    expired = 1;

		while (timers && (int) (timers->expires - now) <= 0)
		    DoTimer(timers, now, &timers);

                if (expired)
                    return 0;
	    }
	}
	else
	{
	    fd_set tmp_set;

	    if (*checkForInput[0] == *checkForInput[1]) {
	        if (timers)
	        {
                    int expired = 0;
		    now = GetTimeInMillis();
		    if ((int) (timers->expires - now) <= 0)
		        expired = 1;

		    while (timers && (int) (timers->expires - now) <= 0)
		        DoTimer(timers, now, &timers);

                    if (expired)
                        return 0;
	        }
	    }
	    if (someReady)
		XFD_ORSET(&LastSelectMask, &ClientsWithInput, &LastSelectMask);
	    if (AnyClientsWriteBlocked && XFD_ANYSET (&clientsWritable))
	    {
		NewOutputPending = TRUE;
		XFD_ORSET(&OutputPending, &clientsWritable, &OutputPending);
		XFD_UNSET(&ClientsWriteBlocked, &clientsWritable);
		if (! XFD_ANYSET(&ClientsWriteBlocked))
		    AnyClientsWriteBlocked = FALSE;
	    }

	    XFD_ANDSET(&devicesReadable, &LastSelectMask, &EnabledDevices);
	    XFD_ANDSET(&clientsReadable, &LastSelectMask, &AllClients); 
	    XFD_ANDSET(&tmp_set, &LastSelectMask, &WellKnownConnections);
	    if (XFD_ANYSET(&tmp_set))
		QueueWorkProc(EstablishNewConnections, NULL,
			      (pointer)&LastSelectMask);

	    if (XFD_ANYSET (&devicesReadable) || XFD_ANYSET (&clientsReadable))
		break;
	    /* check here for DDXes that queue events during Block/Wakeup */
	    if (*checkForInput[0] != *checkForInput[1])
		return 0;
	}
    }

    nready = 0;
    if (XFD_ANYSET (&clientsReadable))
    {
#ifndef WIN32
	for (i=0; i<howmany(XFD_SETSIZE, NFDBITS); i++)
	{
	    int highest_priority = 0;

	    while (clientsReadable.fds_bits[i])
	    {
	        int client_priority, client_index;

		curclient = mffs (clientsReadable.fds_bits[i]) - 1;
		client_index = /* raphael: modified */
			ConnectionTranslation[curclient + (i * (sizeof(fd_mask) * 8))];
#else
	int highest_priority = 0;
	fd_set savedClientsReadable;
	XFD_COPYSET(&clientsReadable, &savedClientsReadable);
	for (i = 0; i < XFD_SETCOUNT(&savedClientsReadable); i++)
	{
	    int client_priority, client_index;

	    curclient = XFD_FD(&savedClientsReadable, i);
	    client_index = GetConnectionTranslation(curclient);
#endif
		/*  We implement "strict" priorities.
		 *  Only the highest priority client is returned to
		 *  dix.  If multiple clients at the same priority are
		 *  ready, they are all returned.  This means that an
		 *  aggressive client could take over the server.
		 *  This was not considered a big problem because
		 *  aggressive clients can hose the server in so many 
		 *  other ways :)
		 */
		client_priority = clients[client_index]->priority;
		if (nready == 0 || client_priority > highest_priority)
		{
		    /*  Either we found the first client, or we found
		     *  a client whose priority is greater than all others
		     *  that have been found so far.  Either way, we want 
		     *  to initialize the list of clients to contain just
		     *  this client.
		     */
		    pClientsReady[0] = client_index;
		    highest_priority = client_priority;
		    nready = 1;
		}
		/*  the following if makes sure that multiple same-priority 
		 *  clients get batched together
		 */
		else if (client_priority == highest_priority)
		{
		    pClientsReady[nready++] = client_index;
		}
#ifndef WIN32
		clientsReadable.fds_bits[i] &= ~(((fd_mask)1L) << curclient);
	    }
#else
	    FD_CLR(curclient, &clientsReadable);
#endif
	}
    }

    if (nready)
        SmartScheduleStartTimer();

    return nready;
}

/* If time has rewound, re-run every affected timer.
 * Timers might drop out of the list, so we have to restart every time. */
static void
CheckAllTimers(void)
{
    OsTimerPtr timer;
    CARD32 now;

start:
    now = GetTimeInMillis();

    for (timer = timers; timer; timer = timer->next) {
        if (timer->expires - now > timer->delta + 250) {
            TimerForce(timer);
            goto start;
        }
    }
}

static void
DoTimer(OsTimerPtr timer, CARD32 now, OsTimerPtr *prev)
{
    CARD32 newTime;

    *prev = timer->next;
    timer->next = NULL;
    newTime = (*timer->callback)(timer, now, timer->arg);
    if (newTime)
	TimerSet(timer, 0, newTime, timer->callback, timer->arg);
}

OsTimerPtr
TimerSet(OsTimerPtr timer, int flags, CARD32 millis, 
    OsTimerCallback func, pointer arg)
{
    register OsTimerPtr *prev;
    CARD32 now = GetTimeInMillis();

    if (!timer)
    {
	timer = malloc(sizeof(struct _OsTimerRec));
	if (!timer)
	    return NULL;
    }
    else
    {
	for (prev = &timers; *prev; prev = &(*prev)->next)
	{
	    if (*prev == timer)
	    {
		*prev = timer->next;
		if (flags & TimerForceOld)
		    (void)(*timer->callback)(timer, now, timer->arg);
		break;
	    }
	}
    }
    if (!millis)
	return timer;
    if (flags & TimerAbsolute) {
        timer->delta = millis - now;
    }
    else {
        timer->delta = millis;
	millis += now;
    }
    timer->expires = millis;
    timer->callback = func;
    timer->arg = arg;
    if ((int) (millis - now) <= 0)
    {
	timer->next = NULL;
	millis = (*timer->callback)(timer, now, timer->arg);
	if (!millis)
	    return timer;
    }
    for (prev = &timers;
	 *prev && (int) ((*prev)->expires - millis) <= 0;
	 prev = &(*prev)->next)
        ;
    timer->next = *prev;
    *prev = timer;
    return timer;
}

Bool
TimerForce(OsTimerPtr timer)
{
    OsTimerPtr *prev;

    for (prev = &timers; *prev; prev = &(*prev)->next)
    {
	if (*prev == timer)
	{
	    DoTimer(timer, GetTimeInMillis(), prev);
	    return TRUE;
	}
    }
    return FALSE;
}


void
TimerCancel(OsTimerPtr timer)
{
    OsTimerPtr *prev;

    if (!timer)
	return;
    for (prev = &timers; *prev; prev = &(*prev)->next)
    {
	if (*prev == timer)
	{
	    *prev = timer->next;
	    break;
	}
    }
}

void
TimerFree(OsTimerPtr timer)
{
    if (!timer)
	return;
    TimerCancel(timer);
    free(timer);
}

void
TimerCheck(void)
{
    CARD32 now = GetTimeInMillis();

    while (timers && (int) (timers->expires - now) <= 0)
	DoTimer(timers, now, &timers);
}

void
TimerInit(void)
{
    OsTimerPtr timer;

    while ((timer = timers))
    {
	timers = timer->next;
	free(timer);
    }
}

#ifdef DPMSExtension

#define DPMS_CHECK_MODE(mode,time)\
    if (time > 0 && DPMSPowerLevel < mode && timeout >= time)\
	DPMSSet(serverClient, mode);

#define DPMS_CHECK_TIMEOUT(time)\
    if (time > 0 && (time - timeout) > 0)\
	return time - timeout;

static CARD32
NextDPMSTimeout(INT32 timeout)
{
    /*
     * Return the amount of time remaining until we should set
     * the next power level. Fallthroughs are intentional.
     */
    switch (DPMSPowerLevel)
    {
	case DPMSModeOn:
	    DPMS_CHECK_TIMEOUT(DPMSStandbyTime)

	case DPMSModeStandby:
	    DPMS_CHECK_TIMEOUT(DPMSSuspendTime)

	case DPMSModeSuspend:
	    DPMS_CHECK_TIMEOUT(DPMSOffTime)

	default: /* DPMSModeOff */
	    return 0;
    }
}
#endif /* DPMSExtension */

static CARD32
ScreenSaverTimeoutExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
    INT32 timeout      = now - lastDeviceEventTime.milliseconds;
    CARD32 nextTimeout = 0;

#ifdef DPMSExtension
    /*
     * Check each mode lowest to highest, since a lower mode can
     * have the same timeout as a higher one.
     */
    if (DPMSEnabled)
    {
	DPMS_CHECK_MODE(DPMSModeOff,     DPMSOffTime)
	DPMS_CHECK_MODE(DPMSModeSuspend, DPMSSuspendTime)
	DPMS_CHECK_MODE(DPMSModeStandby, DPMSStandbyTime)

	nextTimeout = NextDPMSTimeout(timeout);
    }

    /*
     * Only do the screensaver checks if we're not in a DPMS
     * power saving mode
     */
    if (DPMSPowerLevel != DPMSModeOn)
	return nextTimeout;
#endif /* DPMSExtension */

    if (!ScreenSaverTime)
	return nextTimeout;

    if (timeout < ScreenSaverTime)
    {
	return nextTimeout > 0 ? 
		min(ScreenSaverTime - timeout, nextTimeout) :
		ScreenSaverTime - timeout;
    }

    ResetOsBuffers(); /* not ideal, but better than nothing */
    dixSaveScreens(serverClient, SCREEN_SAVER_ON, ScreenSaverActive);

    if (ScreenSaverInterval > 0)
    {
	nextTimeout = nextTimeout > 0 ? 
		min(ScreenSaverInterval, nextTimeout) :
		ScreenSaverInterval;
    }

    return nextTimeout;
}

static OsTimerPtr ScreenSaverTimer = NULL;

void
FreeScreenSaverTimer(void)
{
    if (ScreenSaverTimer) {
	TimerFree(ScreenSaverTimer);
	ScreenSaverTimer = NULL;
    }
}

void
SetScreenSaverTimer(void)
{
    CARD32 timeout = 0;

#ifdef DPMSExtension
    if (DPMSEnabled)
    {
	/*
	 * A higher DPMS level has a timeout that's either less
	 * than or equal to that of a lower DPMS level.
	 */
	if (DPMSStandbyTime > 0)
	    timeout = DPMSStandbyTime;

	else if (DPMSSuspendTime > 0)
	    timeout = DPMSSuspendTime;

	else if (DPMSOffTime > 0)
	    timeout = DPMSOffTime;
    }
#endif

    if (ScreenSaverTime > 0)
    {
	timeout = timeout > 0 ?
		min(ScreenSaverTime, timeout) :
		ScreenSaverTime;
    }

#ifdef SCREENSAVER
    if (timeout && !screenSaverSuspended) {
#else
    if (timeout) {
#endif
	ScreenSaverTimer = TimerSet(ScreenSaverTimer, 0, timeout,
	                            ScreenSaverTimeoutExpire, NULL);
    }
    else if (ScreenSaverTimer) {
	FreeScreenSaverTimer();
    }
}

/*

Copyright 1988, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*
 * XDM-AUTHENTICATION-1 (XDMCP authentication) and
 * XDM-AUTHORIZATION-1 (client authorization) protocols
 *
 * Author:  Keith Packard, MIT X Consortium
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include "os.h"
#include "osdep.h"
#include "dixstruct.h"

#ifdef HASXDMAUTH

static Bool authFromXDMCP;

#ifdef XDMCP
#include <X11/Xmd.h>
#undef REQUEST
#include <X11/Xdmcp.h>

/* XDM-AUTHENTICATION-1 */

static XdmAuthKeyRec	privateKey;
static char XdmAuthenticationName[] = "XDM-AUTHENTICATION-1";
#define XdmAuthenticationNameLen (sizeof XdmAuthenticationName - 1)
static XdmAuthKeyRec	rho;

static Bool 
XdmAuthenticationValidator (ARRAY8Ptr privateData, ARRAY8Ptr incomingData, 
    xdmOpCode packet_type)
{
    XdmAuthKeyPtr	incoming;

    XdmcpUnwrap (incomingData->data, (unsigned char *)&privateKey,
			      incomingData->data,incomingData->length);
    if (packet_type == ACCEPT) {
    	if (incomingData->length != 8)
	    return FALSE;
    	incoming = (XdmAuthKeyPtr) incomingData->data;
    	XdmcpDecrementKey (incoming);
    	return XdmcpCompareKeys (incoming, &rho);
    }
    return FALSE;
}

static Bool
XdmAuthenticationGenerator (ARRAY8Ptr privateData, ARRAY8Ptr outgoingData, 
    xdmOpCode packet_type)
{
    outgoingData->length = 0;
    outgoingData->data = 0;
    if (packet_type == REQUEST) {
	if (XdmcpAllocARRAY8 (outgoingData, 8))
	    XdmcpWrap ((unsigned char *)&rho, (unsigned char *)&privateKey,
		       outgoingData->data, 8);
    }
    return TRUE;
}

static Bool
XdmAuthenticationAddAuth (int name_len, const char *name,
    int data_len, char *data)
{
    Bool    ret;
    XdmcpUnwrap ((unsigned char *)data, (unsigned char *)&privateKey,
		 (unsigned char *)data, data_len);
    authFromXDMCP = TRUE;
    ret = AddAuthorization (name_len, name, data_len, data);
    authFromXDMCP = FALSE;
    return ret;
}


#define atox(c)	('0' <= c && c <= '9' ? c - '0' : \
		 'a' <= c && c <= 'f' ? c - 'a' + 10 : \
		 'A' <= c && c <= 'F' ? c - 'A' + 10 : -1)

static int
HexToBinary (const char *in, char *out, int len)
{
    int	    top, bottom;

    while (len > 0)
    {
	top = atox(in[0]);
	if (top == -1)
	    return 0;
	bottom = atox(in[1]);
	if (bottom == -1)
	    return 0;
	*out++ = (top << 4) | bottom;
	in += 2;
	len -= 2;
    }
    if (len)
	return 0;
    *out++ = '\0';
    return 1;
}

void
XdmAuthenticationInit (const char *cookie, int cookie_len)
{
    memset(privateKey.data, 0, 8);
    if (!strncmp (cookie, "0x", 2) || !strncmp (cookie, "0X", 2))
    {
	if (cookie_len > 2 + 2 * 8)
	    cookie_len = 2 + 2 * 8;
	HexToBinary (cookie + 2, (char *)privateKey.data, cookie_len - 2);
    }
    else
    {
    	if (cookie_len > 7)
	    cookie_len = 7;
    	memmove (privateKey.data + 1, cookie, cookie_len);
    }
    XdmcpGenerateKey (&rho);
    XdmcpRegisterAuthentication (XdmAuthenticationName, XdmAuthenticationNameLen,
				 (char *)&rho,
				 sizeof (rho),
				 (ValidatorFunc)XdmAuthenticationValidator,
				 (GeneratorFunc)XdmAuthenticationGenerator,
				 (AddAuthorFunc)XdmAuthenticationAddAuth);
}

#endif /* XDMCP */

/* XDM-AUTHORIZATION-1 */
typedef struct _XdmAuthorization {
    struct _XdmAuthorization	*next;
    XdmAuthKeyRec		rho;
    XdmAuthKeyRec		key;
    XID				id;
} XdmAuthorizationRec, *XdmAuthorizationPtr;

static XdmAuthorizationPtr xdmAuth;

typedef struct _XdmClientAuth {
    struct _XdmClientAuth   *next;
    XdmAuthKeyRec	    rho;
    char		    client[6];
    long		    time;
} XdmClientAuthRec, *XdmClientAuthPtr;

static XdmClientAuthPtr    xdmClients;
static long	    clockOffset;
static Bool	    gotClock;

#define TwentyMinutes	(20 * 60)
#define TwentyFiveMinutes (25 * 60)

static Bool
XdmClientAuthCompare (const XdmClientAuthPtr a, const XdmClientAuthPtr b)
{
    int	i;

    if (!XdmcpCompareKeys (&a->rho, &b->rho))
	return FALSE;
    for (i = 0; i < 6; i++)
	if (a->client[i] != b->client[i])
	    return FALSE;
    return a->time == b->time;
}

static void
XdmClientAuthDecode (const unsigned char *plain, XdmClientAuthPtr auth)
{
    int	    i, j;

    j = 0;
    for (i = 0; i < 8; i++)
    {
	auth->rho.data[i] = plain[j];
	++j;
    }
    for (i = 0; i < 6; i++)
    {
	auth->client[i] = plain[j];
	++j;
    }
    auth->time = 0;
    for (i = 0; i < 4; i++)
    {
	auth->time |= plain[j] << ((3 - i) << 3);
	j++;
    }
}

static void
XdmClientAuthTimeout (long now)
{
    XdmClientAuthPtr	client, next, prev;

    prev = 0;
    for (client = xdmClients; client; client=next)
    {
	next = client->next;
	if (abs (now - client->time) > TwentyFiveMinutes)
	{
	    if (prev)
		prev->next = next;
	    else
		xdmClients = next;
	    free(client);
	}
	else
	    prev = client;
    }
}

static XdmClientAuthPtr
XdmAuthorizationValidate (unsigned char *plain, int length, 
    XdmAuthKeyPtr rho, ClientPtr xclient, char **reason)
{
    XdmClientAuthPtr	client, existing;
    long		now;
    int			i;

    if (length != (192 / 8)) {
	if (reason)
	    *reason = "Bad XDM authorization key length";
	return NULL;
    }
    client = malloc(sizeof (XdmClientAuthRec));
    if (!client)
	return NULL;
    XdmClientAuthDecode (plain, client);
    if (!XdmcpCompareKeys (&client->rho, rho))
    {
	free(client);
	if (reason)
	    *reason = "Invalid XDM-AUTHORIZATION-1 key (failed key comparison)";
	return NULL;
    }
    for (i = 18; i < 24; i++)
	if (plain[i] != 0) {
	    free(client);
	    if (reason)
		*reason = "Invalid XDM-AUTHORIZATION-1 key (failed NULL check)";
	    return NULL;
	}
    if (xclient) {
	int family, addr_len;
	Xtransaddr *addr;

	if (_XSERVTransGetPeerAddr(((OsCommPtr)xclient->osPrivate)->trans_conn,
				   &family, &addr_len, &addr) == 0
	    && _XSERVTransConvertAddress(&family, &addr_len, &addr) == 0) {
#if defined(TCPCONN) || defined(STREAMSCONN)
	    if (family == FamilyInternet &&
		memcmp((char *)addr, client->client, 4) != 0) {
		free(client);
		free(addr);
		if (reason)
		    *reason = "Invalid XDM-AUTHORIZATION-1 key (failed address comparison)";
		return NULL;

	    }
#endif
	    free(addr);
	}
    }
    now = time(0);
    if (!gotClock)
    {
	clockOffset = client->time - now;
	gotClock = TRUE;
    }
    now += clockOffset;
    XdmClientAuthTimeout (now);
    if (abs (client->time - now) > TwentyMinutes)
    {
	free(client);
	if (reason)
	    *reason = "Excessive XDM-AUTHORIZATION-1 time offset";
	return NULL;
    }
    for (existing = xdmClients; existing; existing=existing->next)
    {
	if (XdmClientAuthCompare (existing, client))
	{
	    free(client);
	    if (reason)
		*reason = "XDM authorization key matches an existing client!";
	    return NULL;
	}
    }
    return client;
}

int
XdmAddCookie (unsigned short data_length, const char *data, XID id)
{
    XdmAuthorizationPtr	new;
    unsigned char	*rho_bits, *key_bits;

    switch (data_length)
    {
    case 16:		    /* auth from files is 16 bytes long */
#ifdef XDMCP
	if (authFromXDMCP)
	{
	    /* R5 xdm sent bogus authorization data in the accept packet,
	     * but we can recover */
	    rho_bits = rho.data;
	    key_bits = (unsigned char *) data;
	    key_bits[0] = '\0';
	}
	else
#endif
	{
	    rho_bits = (unsigned char *) data;
	    key_bits = (unsigned char *) (data + 8);
	}
	break;
#ifdef XDMCP
    case 8:		    /* auth from XDMCP is 8 bytes long */
	rho_bits = rho.data;
	key_bits = (unsigned char *) data;
	break;
#endif
    default:
	return 0;
    }
    /* the first octet of the key must be zero */
    if (key_bits[0] != '\0')
	return 0;
    new = malloc(sizeof (XdmAuthorizationRec));
    if (!new)
	return 0;
    new->next = xdmAuth;
    xdmAuth = new;
    memmove (new->key.data, key_bits, (int) 8);
    memmove (new->rho.data, rho_bits, (int) 8);
    new->id = id;
    return 1;
}

XID
XdmCheckCookie (unsigned short cookie_length, const char *cookie,
    ClientPtr xclient, char **reason)
{
    XdmAuthorizationPtr	auth;
    XdmClientAuthPtr	client;
    unsigned char	*plain;

    /* Auth packets must be a multiple of 8 bytes long */
    if (cookie_length & 7)
	return (XID) -1;
    plain = malloc(cookie_length);
    if (!plain)
	return (XID) -1;
    for (auth = xdmAuth; auth; auth=auth->next) {
	XdmcpUnwrap ((unsigned char *)cookie, (unsigned char *)&auth->key, plain, cookie_length);
	if ((client = XdmAuthorizationValidate (plain, cookie_length, &auth->rho, xclient, reason)) != NULL)
	{
	    client->next = xdmClients;
	    xdmClients = client;
	    free(plain);
	    return auth->id;
	}
    }
    free(plain);
    return (XID) -1;
}

int
XdmResetCookie (void)
{
    XdmAuthorizationPtr	auth, next_auth;
    XdmClientAuthPtr	client, next_client;

    for (auth = xdmAuth; auth; auth=next_auth)
    {
	next_auth = auth->next;
	free(auth);
    }
    xdmAuth = 0;
    for (client = xdmClients; client; client=next_client)
    {
	next_client = client->next;
	free(client);
    }
    xdmClients = (XdmClientAuthPtr) 0;
    return 1;
}

XID
XdmToID (unsigned short cookie_length, char *cookie)
{
    XdmAuthorizationPtr	auth;
    XdmClientAuthPtr	client;
    unsigned char	*plain;

    plain = malloc(cookie_length);
    if (!plain)
	return (XID) -1;
    for (auth = xdmAuth; auth; auth=auth->next) {
	XdmcpUnwrap ((unsigned char *)cookie, (unsigned char *)&auth->key, plain, cookie_length);
	if ((client = XdmAuthorizationValidate (plain, cookie_length, &auth->rho, NULL, NULL)) != NULL)
	{
	    free(client);
	    free(cookie);
	    free(plain);
	    return auth->id;
	}
    }
    free(cookie);
    free(plain);
    return (XID) -1;
}

int
XdmFromID (XID id, unsigned short *data_lenp, char **datap)
{
    XdmAuthorizationPtr	auth;

    for (auth = xdmAuth; auth; auth=auth->next) {
	if (id == auth->id) {
	    *data_lenp = 16;
	    *datap = (char *) &auth->rho;
	    return 1;
	}
    }
    return 0;
}

int
XdmRemoveCookie (unsigned short data_length, const char *data)
{
    XdmAuthorizationPtr	auth;
    XdmAuthKeyPtr	key_bits, rho_bits;

    switch (data_length)
    {
    case 16:
	rho_bits = (XdmAuthKeyPtr) data;
	key_bits = (XdmAuthKeyPtr) (data + 8);
	break;
#ifdef XDMCP
    case 8:
	rho_bits = &rho;
	key_bits = (XdmAuthKeyPtr) data;
	break;
#endif
    default:
	return 0;
    }
    for (auth = xdmAuth; auth; auth=auth->next) {
	if (XdmcpCompareKeys (rho_bits, &auth->rho) &&
	    XdmcpCompareKeys (key_bits, &auth->key))
 	{
	    xdmAuth = auth->next;
	    free(auth);
	    return 1;
	}
    }
    return 0;
}

#endif
/*
 * Copyright 1989 Network Computing Devices, Inc., Mountain View, California.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of N.C.D. not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  N.C.D. makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef WIN32
#include <X11/Xwinsock.h>
#endif

#include <X11/Xos.h>

#if !defined(WIN32)
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <X11/X.h>
#include <X11/Xmd.h>
#include "misc.h"
#include <X11/Xpoll.h>
#include "osdep.h"
#include "input.h"
#include "dixstruct.h"
#include "opaque.h"
#include "site.h"

#ifdef STREAMSCONN
#include <tiuser.h>
#include <netconfig.h>
#include <netdir.h>
#endif

#ifdef XDMCP
#undef REQUEST

#ifdef XDMCP_NO_IPV6
#undef IPv6
#endif

#include <X11/Xdmcp.h>

#define X_INCLUDE_NETDB_H
#include <X11/Xos_r.h>

static char *defaultDisplayClass = COMPILEDDISPLAYCLASS;

static int		    xdmcpSocket, sessionSocket;
static xdmcp_states	    state;
#if defined(IPv6) && defined(AF_INET6)
static int		    xdmcpSocket6;
static struct sockaddr_storage req_sockaddr;
#else
static struct sockaddr_in   req_sockaddr;
#endif
static int		    req_socklen;
static CARD32		    SessionID;
static CARD32		    timeOutTime;
static int		    timeOutRtx;
static CARD32		    defaultKeepaliveDormancy = XDM_DEF_DORMANCY;
static CARD32		    keepaliveDormancy = XDM_DEF_DORMANCY;
static CARD16		    DisplayNumber;
static xdmcp_states	    XDM_INIT_STATE = XDM_OFF;
#ifdef HASXDMAUTH
static char		    *xdmAuthCookie;
#endif

static XdmcpBuffer	    buffer;

#if defined(IPv6) && defined(AF_INET6)

static struct addrinfo *mgrAddr;
static struct addrinfo *mgrAddrFirst;

#define SOCKADDR_TYPE		struct sockaddr_storage
#define SOCKADDR_FAMILY(s)	((struct sockaddr *)&(s))->sa_family

#ifdef BSD44SOCKETS
#define SOCKLEN_FIELD(s)	((struct sockaddr *)&(s))->sa_len
#define SOCKLEN_TYPE 		unsigned char
#else
#define SOCKLEN_TYPE 		unsigned int
#endif

#else

#define SOCKADDR_TYPE		struct sockaddr_in
#define SOCKADDR_FAMILY(s)	(s).sin_family

#ifdef BSD44SOCKETS
#define SOCKLEN_FIELD(s)	(s).sin_len
#define SOCKLEN_TYPE		unsigned char
#else
#define SOCKLEN_TYPE		size_t
#endif

#endif

static SOCKADDR_TYPE		ManagerAddress;
static SOCKADDR_TYPE		FromAddress;

#ifdef SOCKLEN_FIELD
#define ManagerAddressLen	SOCKLEN_FIELD(ManagerAddress)
#define FromAddressLen		SOCKLEN_FIELD(FromAddress)
#else
static SOCKLEN_TYPE ManagerAddressLen, FromAddressLen;
#endif

#if defined(IPv6) && defined(AF_INET6)
static struct multicastinfo {
    struct multicastinfo	*next;
    struct addrinfo		*ai;
    int				 hops;
} *mcastlist;
#endif

static void XdmcpAddHost(
    const struct sockaddr    *from,
    int			fromlen,
    ARRAY8Ptr		AuthenticationName,
    ARRAY8Ptr		hostname,
    ARRAY8Ptr		status);

static void XdmcpSelectHost(
    const struct sockaddr *host_sockaddr,
    int			host_len,
    ARRAY8Ptr		AuthenticationName);

static void get_xdmcp_sock(void);

static void send_query_msg(void);

static void recv_willing_msg(
    struct sockaddr * /*from*/,
    int /*fromlen*/,
    unsigned /*length*/);

static void send_request_msg(void);

static void recv_accept_msg(unsigned /*length*/);

static void recv_decline_msg(unsigned /*length*/);

static void send_manage_msg(void);

static void recv_refuse_msg(unsigned /*length*/);

static void recv_failed_msg(unsigned /*length*/);

static void send_keepalive_msg(void);

static void recv_alive_msg(unsigned /*length*/);

static void XdmcpFatal(
    const char * /*type*/,
    ARRAY8Ptr /*status*/);
 
static void XdmcpWarning(const char * /*str*/);

static void get_manager_by_name(
    int /*argc*/,
    char ** /*argv*/,
    int /*i*/);

static void get_fromaddr_by_name(int /*argc*/, char ** /*argv*/, int /*i*/);

#if defined(IPv6) && defined(AF_INET6)
static int get_mcast_options(int /*argc*/, char ** /*argv*/, int /*i*/);
#endif

static void receive_packet(int /*socketfd*/);

static void send_packet(void);

static void timeout(void);

static void restart(void);

static void XdmcpBlockHandler(
    pointer /*data*/,
    struct timeval ** /*wt*/,
    pointer /*LastSelectMask*/);

static void XdmcpWakeupHandler(
    pointer /*data*/,
    int /*i*/,
    pointer /*LastSelectMask*/);

/*
 * Register the Manufacturer display ID
 */

static ARRAY8 ManufacturerDisplayID;

static void
XdmcpRegisterManufacturerDisplayID (const char *name, int length)
{
    int	    i;

    XdmcpDisposeARRAY8 (&ManufacturerDisplayID);
    if (!XdmcpAllocARRAY8 (&ManufacturerDisplayID, length))
	return;
    for (i = 0; i < length; i++)
	ManufacturerDisplayID.data[i] = (CARD8) name[i];
}

static unsigned short	xdm_udp_port = XDM_UDP_PORT;
static Bool	OneSession = FALSE;
static const char 	*xdm_from = NULL;

void
XdmcpUseMsg (void)
{
    ErrorF("-query host-name       contact named host for XDMCP\n");
    ErrorF("-broadcast             broadcast for XDMCP\n");
#if defined(IPv6) && defined(AF_INET6)
    ErrorF("-multicast [addr [hops]] IPv6 multicast for XDMCP\n");
#endif
    ErrorF("-indirect host-name    contact named host for indirect XDMCP\n");
    ErrorF("-port port-num         UDP port number to send messages to\n");
    ErrorF("-from local-address    specify the local address to connect from\n");
    ErrorF("-once                  Terminate server after one session\n");
    ErrorF("-class display-class   specify display class to send in manage\n");
#ifdef HASXDMAUTH
    ErrorF("-cookie xdm-auth-bits  specify the magic cookie for XDMCP\n");
#endif
    ErrorF("-displayID display-id  manufacturer display ID for request\n");
}

int 
XdmcpOptions(int argc, char **argv, int i)
{
    if (strcmp(argv[i], "-query") == 0) {
	get_manager_by_name(argc, argv, i++);
	XDM_INIT_STATE = XDM_QUERY;
	AccessUsingXdmcp ();
	return i + 1;
    }
    if (strcmp(argv[i], "-broadcast") == 0) {
	XDM_INIT_STATE = XDM_BROADCAST;
	AccessUsingXdmcp ();
	return i + 1;
    }
#if defined(IPv6) && defined(AF_INET6)
    if (strcmp(argv[i], "-multicast") == 0) {
	i = get_mcast_options(argc, argv, ++i);
	XDM_INIT_STATE = XDM_MULTICAST;
	AccessUsingXdmcp ();
	return i + 1;
    }
#endif
    if (strcmp(argv[i], "-indirect") == 0) {
	get_manager_by_name(argc, argv, i++);
	XDM_INIT_STATE = XDM_INDIRECT;
	AccessUsingXdmcp ();
	return i + 1;
    }
    if (strcmp(argv[i], "-port") == 0) {
        if (++i == argc)  {
	    FatalError("Xserver: missing port number in command line\n");
	}
	xdm_udp_port = (unsigned short) atoi(argv[i]);
	return i + 1;
    }
    if (strcmp(argv[i], "-from") == 0) {
	get_fromaddr_by_name(argc, argv, ++i);
	return i + 1;
    }
    if (strcmp(argv[i], "-once") == 0) {
	OneSession = TRUE;
	return i + 1;
    }
    if (strcmp(argv[i], "-class") == 0) {
        if (++i == argc)  {
	    FatalError("Xserver: missing class name in command line\n");
	}
	defaultDisplayClass = argv[i];
	return i + 1;
    }
#ifdef HASXDMAUTH
    if (strcmp(argv[i], "-cookie") == 0) {
        if (++i == argc)  {
	    FatalError("Xserver: missing cookie data in command line\n");
	}
	xdmAuthCookie = argv[i];
	return i + 1;
    }
#endif
    if (strcmp(argv[i], "-displayID") == 0) {
        if (++i == argc)  {
	    FatalError("Xserver: missing displayID in command line\n");
	}
	XdmcpRegisterManufacturerDisplayID (argv[i], strlen (argv[i]));
	return i + 1;
    }
    return i;
}

/*
 * This section is a collection of routines for
 * registering server-specific data with the XDMCP
 * state machine.
 */


/*
 * Save all broadcast addresses away so BroadcastQuery
 * packets get sent everywhere
 */

#define MAX_BROADCAST	10

/* This stays sockaddr_in since IPv6 doesn't support broadcast */
static struct sockaddr_in   BroadcastAddresses[MAX_BROADCAST];
static int		    NumBroadcastAddresses;

void
XdmcpRegisterBroadcastAddress (const struct sockaddr_in *addr)
{
    struct sockaddr_in	*bcast;
    if (NumBroadcastAddresses >= MAX_BROADCAST)
	return;
    bcast = &BroadcastAddresses[NumBroadcastAddresses++];
    memset(bcast, 0, sizeof (struct sockaddr_in));
#ifdef BSD44SOCKETS
    bcast->sin_len = addr->sin_len;
#endif
    bcast->sin_family = addr->sin_family;
    bcast->sin_port = htons (xdm_udp_port);
    bcast->sin_addr = addr->sin_addr;
}

/*
 * Each authentication type is registered here; Validator
 * will be called to check all access attempts using
 * the specified authentication type
 */

static ARRAYofARRAY8	AuthenticationNames, AuthenticationDatas;
typedef struct _AuthenticationFuncs {
    ValidatorFunc    Validator;
    GeneratorFunc    Generator;
    AddAuthorFunc    AddAuth;
} AuthenticationFuncsRec, *AuthenticationFuncsPtr;

static AuthenticationFuncsPtr	AuthenticationFuncsList;

void
XdmcpRegisterAuthentication (
    const char    *name,
    int	    namelen,
    const char    *data,
    int	    datalen,
    ValidatorFunc Validator,
    GeneratorFunc Generator,
    AddAuthorFunc AddAuth)
{
    int	    i;
    ARRAY8  AuthenticationName, AuthenticationData;
    static AuthenticationFuncsPtr	newFuncs;

    if (!XdmcpAllocARRAY8 (&AuthenticationName, namelen))
	return;
    if (!XdmcpAllocARRAY8 (&AuthenticationData, datalen))
    {
	XdmcpDisposeARRAY8 (&AuthenticationName);
	return;
    }
    for (i = 0; i < namelen; i++)
	AuthenticationName.data[i] = name[i];
    for (i = 0; i < datalen; i++)
	AuthenticationData.data[i] = data[i];
    if (!(XdmcpReallocARRAYofARRAY8 (&AuthenticationNames,
				     AuthenticationNames.length + 1) &&
	  XdmcpReallocARRAYofARRAY8 (&AuthenticationDatas,
				     AuthenticationDatas.length + 1) &&
	  (newFuncs = malloc((AuthenticationNames.length + 1) * sizeof (AuthenticationFuncsRec)))))
    {
	XdmcpDisposeARRAY8 (&AuthenticationName);
	XdmcpDisposeARRAY8 (&AuthenticationData);
	return;
    }
    for (i = 0; i < AuthenticationNames.length - 1; i++)
	newFuncs[i] = AuthenticationFuncsList[i];
    newFuncs[AuthenticationNames.length-1].Validator = Validator;
    newFuncs[AuthenticationNames.length-1].Generator = Generator;
    newFuncs[AuthenticationNames.length-1].AddAuth = AddAuth;
    free(AuthenticationFuncsList);
    AuthenticationFuncsList = newFuncs;
    AuthenticationNames.data[AuthenticationNames.length-1] = AuthenticationName;
    AuthenticationDatas.data[AuthenticationDatas.length-1] = AuthenticationData;
}

/*
 * Select the authentication type to be used; this is
 * set by the manager of the host to be connected to.
 */

static ARRAY8		noAuthenticationName = {(CARD16) 0, (CARD8Ptr) 0};
static ARRAY8		noAuthenticationData = {(CARD16) 0, (CARD8Ptr) 0};
static ARRAY8Ptr	AuthenticationName = &noAuthenticationName;
static ARRAY8Ptr	AuthenticationData = &noAuthenticationData;
static AuthenticationFuncsPtr	AuthenticationFuncs;

static void
XdmcpSetAuthentication (const ARRAY8Ptr name)
{
    int	i;

    for (i = 0; i < AuthenticationNames.length; i++)
	if (XdmcpARRAY8Equal (&AuthenticationNames.data[i], name))
	{
	    AuthenticationName = &AuthenticationNames.data[i];
	    AuthenticationData = &AuthenticationDatas.data[i];
	    AuthenticationFuncs = &AuthenticationFuncsList[i];
	    break;
	}
}

/*
 * Register the host address for the display
 */

static ARRAY16		ConnectionTypes;
static ARRAYofARRAY8	ConnectionAddresses;
static long		xdmcpGeneration;

void
XdmcpRegisterConnection (
    int	    type,
    const char    *address,
    int	    addrlen)
{
    int	    i;
    CARD8   *newAddress;

    if (xdmcpGeneration != serverGeneration)
    {
	XdmcpDisposeARRAY16 (&ConnectionTypes);
	XdmcpDisposeARRAYofARRAY8 (&ConnectionAddresses);
	xdmcpGeneration = serverGeneration;
    }
    if (xdm_from != NULL) {	/* Only register the requested address */
	const void *regAddr = address;
	const void *fromAddr = NULL;
	int regAddrlen = addrlen;

	if (addrlen == sizeof(struct in_addr)) {
	    if (SOCKADDR_FAMILY(FromAddress) == AF_INET) {
		fromAddr = &((struct sockaddr_in *)&FromAddress)->sin_addr;
	    } 
#if defined(IPv6) && defined(AF_INET6)
	    else if ((SOCKADDR_FAMILY(FromAddress) == AF_INET6) &&
	      IN6_IS_ADDR_V4MAPPED(
		  &((struct sockaddr_in6 *)&FromAddress)->sin6_addr)) {
		fromAddr = &((struct sockaddr_in6 *)&FromAddress)->sin6_addr.s6_addr[12];
	    } 
#endif
	}
#if defined(IPv6) && defined(AF_INET6)
	else if (addrlen == sizeof(struct in6_addr)) {
	    if (SOCKADDR_FAMILY(FromAddress) == AF_INET6) {
		fromAddr = &((struct sockaddr_in6 *)&FromAddress)->sin6_addr;
	    } else if ((SOCKADDR_FAMILY(FromAddress) == AF_INET) &&
	      IN6_IS_ADDR_V4MAPPED((struct in6_addr *) address)) {
		fromAddr = &((struct sockaddr_in *)&FromAddress)->sin_addr;
		regAddr = &((struct sockaddr_in6 *)&address)->sin6_addr.s6_addr[12];
		regAddrlen = sizeof(struct in_addr);
	    }
	}
#endif
	if (!fromAddr || memcmp(regAddr, fromAddr, regAddrlen) != 0) {
	    return;
	}
    }
    if (ConnectionAddresses.length + 1 == 256)
	return;
    newAddress = malloc(addrlen * sizeof (CARD8));
    if (!newAddress)
	return;
    if (!XdmcpReallocARRAY16 (&ConnectionTypes, ConnectionTypes.length + 1))
    {
	free(newAddress);
	return;
    }
    if (!XdmcpReallocARRAYofARRAY8 (&ConnectionAddresses,
				    ConnectionAddresses.length +  1))
    {
	free(newAddress);
	return;
    }
    ConnectionTypes.data[ConnectionTypes.length - 1] = (CARD16) type;
    for (i = 0; i < addrlen; i++)
	newAddress[i] = address[i];
    ConnectionAddresses.data[ConnectionAddresses.length-1].data = newAddress;
    ConnectionAddresses.data[ConnectionAddresses.length-1].length = addrlen;
}

/*
 * Register an Authorization Name.  XDMCP advertises this list
 * to the manager.
 */

static ARRAYofARRAY8	AuthorizationNames;

void
XdmcpRegisterAuthorizations (void)
{
    XdmcpDisposeARRAYofARRAY8 (&AuthorizationNames);
    RegisterAuthorizations ();
}

void
XdmcpRegisterAuthorization (const char *name, int namelen)
{
    ARRAY8  authName;
    int	    i;

    authName.data = malloc(namelen * sizeof (CARD8));
    if (!authName.data)
	return;
    if (!XdmcpReallocARRAYofARRAY8 (&AuthorizationNames, AuthorizationNames.length +1))
    {
	free(authName.data);
	return;
    }
    for (i = 0; i < namelen; i++)
	authName.data[i] = (CARD8) name[i];
    authName.length = namelen;
    AuthorizationNames.data[AuthorizationNames.length-1] = authName;
}

/*
 * Register the DisplayClass string
 */

static ARRAY8	DisplayClass;

static void
XdmcpRegisterDisplayClass (const char *name, int length)
{
    int	    i;

    XdmcpDisposeARRAY8 (&DisplayClass);
    if (!XdmcpAllocARRAY8 (&DisplayClass, length))
	return;
    for (i = 0; i < length; i++)
	DisplayClass.data[i] = (CARD8) name[i];
}

/* 
 * initialize XDMCP; create the socket, compute the display
 * number, set up the state machine
 */

void 
XdmcpInit(void)
{
    state = XDM_INIT_STATE;
#ifdef HASXDMAUTH
    if (xdmAuthCookie)
	XdmAuthenticationInit (xdmAuthCookie, strlen (xdmAuthCookie));
#endif
    if (state != XDM_OFF)
    {
	XdmcpRegisterAuthorizations();
	XdmcpRegisterDisplayClass (defaultDisplayClass, strlen (defaultDisplayClass));
	AccessUsingXdmcp();
	RegisterBlockAndWakeupHandlers (XdmcpBlockHandler, XdmcpWakeupHandler,
				        (pointer) 0);
    	timeOutRtx = 0;
    	DisplayNumber = (CARD16) atoi(display);
    	get_xdmcp_sock();
    	send_packet();
    }
}

void
XdmcpReset (void)
{
    state = XDM_INIT_STATE;
    if (state != XDM_OFF)
    {
	RegisterBlockAndWakeupHandlers (XdmcpBlockHandler, XdmcpWakeupHandler,
				        (pointer) 0);
    	timeOutRtx = 0;
    	send_packet();
    }
}

/*
 * Called whenever a new connection is created; notices the
 * first connection and saves it to terminate the session
 * when it is closed
 */

void
XdmcpOpenDisplay(int sock)
{
    if (state != XDM_AWAIT_MANAGE_RESPONSE)
	return;
    state = XDM_RUN_SESSION;
    sessionSocket = sock;
}

void 
XdmcpCloseDisplay(int sock)
{
    if ((state != XDM_RUN_SESSION && state != XDM_AWAIT_ALIVE_RESPONSE)
	|| sessionSocket != sock)
	    return;
    state = XDM_INIT_STATE;
    if (OneSession)
	dispatchException |= DE_TERMINATE;
    else
	dispatchException |= DE_RESET;
    isItTimeToYield = TRUE;
}

/*
 * called before going to sleep, this routine
 * may modify the timeout value about to be sent
 * to select; in this way XDMCP can do appropriate things
 * dynamically while starting up
 */

/*ARGSUSED*/
static void
XdmcpBlockHandler(
    pointer	    data,   /* unused */
    struct timeval  **wt,
    pointer	    pReadmask)
{
    fd_set *LastSelectMask = (fd_set*)pReadmask;
    CARD32 millisToGo;

    if (state == XDM_OFF)
	return;
    FD_SET(xdmcpSocket, LastSelectMask);
#if defined(IPv6) && defined(AF_INET6)
    if (xdmcpSocket6 >= 0)
	FD_SET(xdmcpSocket6, LastSelectMask);
#endif
    if (timeOutTime == 0)
	return;
    millisToGo = timeOutTime - GetTimeInMillis();
    if ((int) millisToGo < 0)
	millisToGo = 0;
    AdjustWaitForDelay (wt, millisToGo);
}

/*
 * called after select returns; this routine will
 * recognise when XDMCP packets await and
 * process them appropriately
 */

/*ARGSUSED*/
static void
XdmcpWakeupHandler(
    pointer data,   /* unused */
    int	    i,
    pointer pReadmask)
{
    fd_set* LastSelectMask = (fd_set*)pReadmask;
    fd_set   devicesReadable;

    if (state == XDM_OFF)
	return;
    if (i > 0)
    {
	if (FD_ISSET(xdmcpSocket, LastSelectMask))
	{
	    receive_packet(xdmcpSocket);
	    FD_CLR(xdmcpSocket, LastSelectMask);
	} 
#if defined(IPv6) && defined(AF_INET6)
	if (xdmcpSocket6 >= 0 && FD_ISSET(xdmcpSocket6, LastSelectMask))
	{
	    receive_packet(xdmcpSocket6);
	    FD_CLR(xdmcpSocket6, LastSelectMask);
	} 
#endif
	XFD_ANDSET(&devicesReadable, LastSelectMask, &EnabledDevices);
	if (XFD_ANYSET(&devicesReadable))
	{
	    if (state == XDM_AWAIT_USER_INPUT)
		restart();
	    else if (state == XDM_RUN_SESSION)
		keepaliveDormancy = defaultKeepaliveDormancy;
	}
	if (XFD_ANYSET(&AllClients) && state == XDM_RUN_SESSION)
	    timeOutTime = GetTimeInMillis() +  keepaliveDormancy * 1000;
    }
    else if (timeOutTime && (int) (GetTimeInMillis() - timeOutTime) >= 0)
    {
    	if (state == XDM_RUN_SESSION)
    	{
	    state = XDM_KEEPALIVE;
	    send_packet();
    	}
    	else
	    timeout();
    }
}

/*
 * This routine should be called from the routine that drives the
 * user's host menu when the user selects a host
 */

static void
XdmcpSelectHost(
    const struct sockaddr	*host_sockaddr,
    int			host_len,
    ARRAY8Ptr		AuthenticationName)
{
    state = XDM_START_CONNECTION;
    memmove(&req_sockaddr, host_sockaddr, host_len);
    req_socklen = host_len;
    XdmcpSetAuthentication (AuthenticationName);
    send_packet();
}

/*
 * !!! this routine should be replaced by a routine that adds
 * the host to the user's host menu. the current version just
 * selects the first host to respond with willing message.
 */

/*ARGSUSED*/
static void
XdmcpAddHost(
    const struct sockaddr    *from,
    int			fromlen,
    ARRAY8Ptr		AuthenticationName,
    ARRAY8Ptr		hostname,
    ARRAY8Ptr		status)
{
    XdmcpSelectHost(from, fromlen, AuthenticationName);
}

/*
 * A message is queued on the socket; read it and
 * do the appropriate thing
 */

static ARRAY8	UnwillingMessage = { (CARD8) 14, (CARD8 *) "Host unwilling" };

static void
receive_packet(int socketfd)
{
#if defined(IPv6) && defined(AF_INET6)
    struct sockaddr_storage from;
#else
    struct sockaddr_in from;
#endif
    int fromlen = sizeof(from);
    XdmcpHeader	header;

    /* read message off socket */
    if (!XdmcpFill (socketfd, &buffer, (XdmcpNetaddr) &from, &fromlen))
	return;

    /* reset retransmission backoff */
    timeOutRtx = 0;

    if (!XdmcpReadHeader (&buffer, &header))
	return;

    if (header.version != XDM_PROTOCOL_VERSION)
	return;

    switch (header.opcode) {
    case WILLING:
	recv_willing_msg((struct sockaddr *) &from, fromlen, header.length);
	break;
    case UNWILLING:
	XdmcpFatal("Manager unwilling", &UnwillingMessage);
	break;
    case ACCEPT:
	recv_accept_msg(header.length);
	break;
    case DECLINE:
	recv_decline_msg(header.length);
	break;
    case REFUSE:
	recv_refuse_msg(header.length);
	break;
    case FAILED:
	recv_failed_msg(header.length);
	break;
    case ALIVE:
	recv_alive_msg(header.length);
	break;
    }
}

/*
 * send the appropriate message given the current state
 */

static void
send_packet(void)
{
    int rtx;
    switch (state) {
    case XDM_QUERY:
    case XDM_BROADCAST:
    case XDM_INDIRECT:
#if defined(IPv6)  && defined(AF_INET6)
    case XDM_MULTICAST:
#endif
	send_query_msg();
	break;
    case XDM_START_CONNECTION:
	send_request_msg();
	break;
    case XDM_MANAGE:
	send_manage_msg();
	break;
    case XDM_KEEPALIVE:
	send_keepalive_msg();
	break;
    default:
	break;
    }
    rtx = (XDM_MIN_RTX << timeOutRtx);
    if (rtx > XDM_MAX_RTX)
	rtx = XDM_MAX_RTX;
    timeOutTime = GetTimeInMillis() + rtx * 1000;
}

/*
 * The session is declared dead for some reason; too many
 * timeouts, or Keepalive failure.
 */

static void
XdmcpDeadSession (const char *reason)
{
    ErrorF ("XDM: %s, declaring session dead\n", reason);
    state = XDM_INIT_STATE;
    isItTimeToYield = TRUE;
    dispatchException |= DE_RESET;
    timeOutTime = 0;
    timeOutRtx = 0;
    send_packet();
}

/*
 * Timeout waiting for an XDMCP response.
 */

static void
timeout(void)
{
    timeOutRtx++;
    if (state == XDM_AWAIT_ALIVE_RESPONSE && timeOutRtx >= XDM_KA_RTX_LIMIT )
    {
	XdmcpDeadSession ("too many keepalive retransmissions");
	return;
    }
    else if (timeOutRtx >= XDM_RTX_LIMIT)
    {
	/* Quit if "-once" specified, otherwise reset and try again. */
        if (OneSession) {
	    dispatchException |= DE_TERMINATE;
	    ErrorF("XDM: too many retransmissions\n");
	} else { 
	    XdmcpDeadSession("too many retransmissions");
	}
	return;
    }

#if defined(IPv6) && defined(AF_INET6)
    if (state == XDM_COLLECT_QUERY || state == XDM_COLLECT_INDIRECT_QUERY) {
	/* Try next address */
	for (mgrAddr = mgrAddr->ai_next; ; mgrAddr = mgrAddr->ai_next) {
	    if (mgrAddr == NULL) {
		mgrAddr = mgrAddrFirst;
	    }
	    if (mgrAddr->ai_family == AF_INET 
	      || mgrAddr->ai_family == AF_INET6)
		break;
	}
#ifndef SIN6_LEN
	ManagerAddressLen = mgrAddr->ai_addrlen;
#endif
	memcpy(&ManagerAddress, mgrAddr->ai_addr, mgrAddr->ai_addrlen);
    }
#endif

    switch (state) {
    case XDM_COLLECT_QUERY:
	state = XDM_QUERY;
	break;
    case XDM_COLLECT_BROADCAST_QUERY:
	state = XDM_BROADCAST;
	break;
#if defined(IPv6) && defined(AF_INET6)
    case XDM_COLLECT_MULTICAST_QUERY:
	state = XDM_MULTICAST;
	break;
#endif
    case XDM_COLLECT_INDIRECT_QUERY:
	state = XDM_INDIRECT;
	break;
    case XDM_AWAIT_REQUEST_RESPONSE:
	state = XDM_START_CONNECTION;
	break;
    case XDM_AWAIT_MANAGE_RESPONSE:
	state = XDM_MANAGE;
	break;
    case XDM_AWAIT_ALIVE_RESPONSE:
	state = XDM_KEEPALIVE;
	break;
    default:
	break;
    }
    send_packet();
}

static void
restart(void)
{
    state = XDM_INIT_STATE;
    timeOutRtx = 0;
    send_packet();
}

static int
XdmcpCheckAuthentication (ARRAY8Ptr Name, ARRAY8Ptr Data, int packet_type)
{
    return (XdmcpARRAY8Equal (Name, AuthenticationName) &&
	    (AuthenticationName->length == 0 ||
	     (*AuthenticationFuncs->Validator) (AuthenticationData, Data, packet_type)));
}

static int
XdmcpAddAuthorization (ARRAY8Ptr name, ARRAY8Ptr data)
{
    AddAuthorFunc AddAuth;

    if (AuthenticationFuncs && AuthenticationFuncs->AddAuth)
	AddAuth = AuthenticationFuncs->AddAuth;
    else
	AddAuth = AddAuthorization;
    return (*AddAuth) ((unsigned short)name->length,
		       (char *)name->data,
		       (unsigned short)data->length,
		       (char *)data->data);
}

/*
 * from here to the end of this file are routines private
 * to the state machine.
 */

static void
get_xdmcp_sock(void)
{
#ifdef STREAMSCONN
    struct netconfig *nconf;

    if ((xdmcpSocket = t_open("/dev/udp", O_RDWR, 0)) < 0) {
	XdmcpWarning("t_open() of /dev/udp failed");
	return;
    }

    if( t_bind(xdmcpSocket,NULL,NULL) < 0 ) {
	XdmcpWarning("UDP socket creation failed");
	t_error("t_bind(xdmcpSocket) failed" );
	t_close(xdmcpSocket);
	return;
    }

    /*
     * This part of the code looks contrived. It will actually fit in nicely
     * when the CLTS part of Xtrans is implemented.
     */
 
    if( (nconf=getnetconfigent("udp")) == NULL ) {
	XdmcpWarning("UDP socket creation failed: getnetconfigent()");
	t_unbind(xdmcpSocket);
	t_close(xdmcpSocket);
	return;
    }
 
    if( netdir_options(nconf, ND_SET_BROADCAST, xdmcpSocket, NULL) ) {
	XdmcpWarning("UDP set broadcast option failed: netdir_options()");
	freenetconfigent(nconf);
	t_unbind(xdmcpSocket);
	t_close(xdmcpSocket);
	return;
    }
 
    freenetconfigent(nconf);
#else
    int soopts = 1;

#if defined(IPv6) && defined(AF_INET6)
    if ((xdmcpSocket6 = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
	XdmcpWarning("INET6 UDP socket creation failed");
#endif
    if ((xdmcpSocket = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
	XdmcpWarning("UDP socket creation failed");
#ifdef SO_BROADCAST
    else if (setsockopt(xdmcpSocket, SOL_SOCKET, SO_BROADCAST, (char *)&soopts,
	sizeof(soopts)) < 0)
	    XdmcpWarning("UDP set broadcast socket-option failed");
#endif /* SO_BROADCAST */
    if (xdmcpSocket >= 0 && xdm_from != NULL) {
	if (bind(xdmcpSocket, (struct sockaddr *)&FromAddress, 
		 FromAddressLen) < 0) {
	    FatalError("Xserver: failed to bind to -from address: %s\n", xdm_from);
	}
    }
#endif /* STREAMSCONN */
}

static void
send_query_msg(void)
{
    XdmcpHeader	header;
    Bool	broadcast = FALSE;
#if defined(IPv6) && defined(AF_INET6)
    Bool	multicast = FALSE;
#endif
    int		i;
    int 	socketfd = xdmcpSocket;

    header.version = XDM_PROTOCOL_VERSION;
    switch(state){
    case XDM_QUERY:
	header.opcode = (CARD16) QUERY; 
	state = XDM_COLLECT_QUERY;
	break;
    case XDM_BROADCAST:
	header.opcode = (CARD16) BROADCAST_QUERY;
	state = XDM_COLLECT_BROADCAST_QUERY;
	broadcast = TRUE;
	break;
#if defined(IPv6) && defined(AF_INET6)
    case XDM_MULTICAST:
	header.opcode = (CARD16) BROADCAST_QUERY;
	state = XDM_COLLECT_MULTICAST_QUERY;
	multicast = TRUE;
	break;
#endif
    case XDM_INDIRECT:
	header.opcode = (CARD16) INDIRECT_QUERY;
	state = XDM_COLLECT_INDIRECT_QUERY;
	break;
    default:
	break;
    }
    header.length = 1;
    for (i = 0; i < AuthenticationNames.length; i++)
	header.length += 2 + AuthenticationNames.data[i].length;

    XdmcpWriteHeader (&buffer, &header);
    XdmcpWriteARRAYofARRAY8 (&buffer, &AuthenticationNames);
    if (broadcast)
    {
	int i;

	for (i = 0; i < NumBroadcastAddresses; i++)
	    XdmcpFlush (xdmcpSocket, &buffer, (XdmcpNetaddr) &BroadcastAddresses[i],
			sizeof (struct sockaddr_in));
    }
#if defined(IPv6) && defined(AF_INET6)
    else if (multicast)
    {
	struct multicastinfo *mcl;
	struct addrinfo *ai;

	for (mcl = mcastlist; mcl != NULL; mcl = mcl->next) {
	    for (ai = mcl->ai ; ai != NULL; ai = ai->ai_next) {
		if (ai->ai_family == AF_INET) {
		    unsigned char hopflag = (unsigned char) mcl->hops;
		    socketfd = xdmcpSocket;
		    setsockopt(socketfd, IPPROTO_IP, IP_MULTICAST_TTL,
		      &hopflag, sizeof(hopflag));
		} else if (ai->ai_family == AF_INET6) {
		    int hopflag6 = mcl->hops;
		    socketfd = xdmcpSocket6;
		    setsockopt(socketfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
		      &hopflag6, sizeof(hopflag6));
		} else {
		    continue;
		}
		XdmcpFlush (socketfd, &buffer, 
		  	    (XdmcpNetaddr) ai->ai_addr, ai->ai_addrlen);
		break;
	    }
	}
    }
#endif
    else
    {
#if defined(IPv6) && defined(AF_INET6)
	if (SOCKADDR_FAMILY(ManagerAddress) == AF_INET6)
	    socketfd = xdmcpSocket6;
#endif	
	XdmcpFlush (socketfd, &buffer, (XdmcpNetaddr) &ManagerAddress,
		    ManagerAddressLen);
    }
}

static void
recv_willing_msg(
    struct sockaddr	*from,
    int			fromlen,
    unsigned		length)
{
    ARRAY8	authenticationName;
    ARRAY8	hostname;
    ARRAY8	status;

    authenticationName.data = 0;
    hostname.data = 0;
    status.data = 0;
    if (XdmcpReadARRAY8 (&buffer, &authenticationName) &&
	XdmcpReadARRAY8 (&buffer, &hostname) &&
	XdmcpReadARRAY8 (&buffer, &status))
    {
    	if (length == 6 + authenticationName.length +
		      hostname.length + status.length)
    	{
	    switch (state)
	    {
	    case XDM_COLLECT_QUERY:
	    	XdmcpSelectHost(from, fromlen, &authenticationName);
	    	break;
	    case XDM_COLLECT_BROADCAST_QUERY:
#if defined(IPv6) && defined(AF_INET6)
	    case XDM_COLLECT_MULTICAST_QUERY:
#endif
	    case XDM_COLLECT_INDIRECT_QUERY:
	    	XdmcpAddHost(from, fromlen, &authenticationName, &hostname, &status);
	    	break;
	    default:
		break;
    	    }
    	}
    }
    XdmcpDisposeARRAY8 (&authenticationName);
    XdmcpDisposeARRAY8 (&hostname);
    XdmcpDisposeARRAY8 (&status);
}

static void
send_request_msg(void)
{
    XdmcpHeader	    header;
    int		    length;
    int		    i;
    CARD16	    XdmcpConnectionType;
    ARRAY8	    authenticationData;
    int		    socketfd = xdmcpSocket;

    switch (SOCKADDR_FAMILY(ManagerAddress))
    {
    case AF_INET:	XdmcpConnectionType=FamilyInternet; break;
#if defined(IPv6) && defined(AF_INET6)
    case AF_INET6:	XdmcpConnectionType=FamilyInternet6; break;
#endif
    default:		XdmcpConnectionType=0xffff; break;
    }

    header.version = XDM_PROTOCOL_VERSION;
    header.opcode = (CARD16) REQUEST;

    length = 2;					    /* display number */
    length += 1 + 2 * ConnectionTypes.length;	    /* connection types */
    length += 1;				    /* connection addresses */
    for (i = 0; i < ConnectionAddresses.length; i++)
	length += 2 + ConnectionAddresses.data[i].length;
    authenticationData.length = 0;
    authenticationData.data = 0;
    if (AuthenticationFuncs)
    {
	(*AuthenticationFuncs->Generator) (AuthenticationData,
					   &authenticationData,
 					   REQUEST);
    }
    length += 2 + AuthenticationName->length;	    /* authentication name */
    length += 2 + authenticationData.length;	    /* authentication data */
    length += 1;				    /* authorization names */
    for (i = 0; i < AuthorizationNames.length; i++)
	length += 2 + AuthorizationNames.data[i].length;
    length += 2 + ManufacturerDisplayID.length;	    /* display ID */
    header.length = length;

    if (!XdmcpWriteHeader (&buffer, &header))
    {
	XdmcpDisposeARRAY8 (&authenticationData);
	return;
    }
    XdmcpWriteCARD16 (&buffer, DisplayNumber);
    XdmcpWriteCARD8 (&buffer, ConnectionTypes.length);

    /* The connection array is send reordered, so that connections of	*/
    /* the same address type as the XDMCP manager connection are send	*/
    /* first. This works around a bug in xdm. mario@klebsch.de 		*/
    for (i = 0; i < (int)ConnectionTypes.length; i++)
	if (ConnectionTypes.data[i]==XdmcpConnectionType)
	    XdmcpWriteCARD16 (&buffer, ConnectionTypes.data[i]);
    for (i = 0; i < (int)ConnectionTypes.length; i++)
	if (ConnectionTypes.data[i]!=XdmcpConnectionType)
	    XdmcpWriteCARD16 (&buffer, ConnectionTypes.data[i]);

    XdmcpWriteCARD8 (&buffer, ConnectionAddresses.length);
    for (i = 0; i < (int)ConnectionAddresses.length; i++)
	if ( (i<ConnectionTypes.length) && 
	     (ConnectionTypes.data[i]==XdmcpConnectionType) )
	    XdmcpWriteARRAY8 (&buffer, &ConnectionAddresses.data[i]);
    for (i = 0; i < (int)ConnectionAddresses.length; i++)
	if ( (i>=ConnectionTypes.length) ||
	     (ConnectionTypes.data[i]!=XdmcpConnectionType) )
	    XdmcpWriteARRAY8 (&buffer, &ConnectionAddresses.data[i]);

    XdmcpWriteARRAY8 (&buffer, AuthenticationName);
    XdmcpWriteARRAY8 (&buffer, &authenticationData);
    XdmcpDisposeARRAY8 (&authenticationData);
    XdmcpWriteARRAYofARRAY8 (&buffer, &AuthorizationNames);
    XdmcpWriteARRAY8 (&buffer, &ManufacturerDisplayID);
#if defined(IPv6) && defined(AF_INET6)
    if (SOCKADDR_FAMILY(req_sockaddr) == AF_INET6)
	socketfd = xdmcpSocket6;
#endif
    if (XdmcpFlush (socketfd, &buffer, 
			(XdmcpNetaddr) &req_sockaddr, req_socklen))
	state = XDM_AWAIT_REQUEST_RESPONSE;
}

static void
recv_accept_msg(unsigned length)
{
    CARD32  AcceptSessionID;
    ARRAY8  AcceptAuthenticationName, AcceptAuthenticationData;
    ARRAY8  AcceptAuthorizationName, AcceptAuthorizationData;

    if (state != XDM_AWAIT_REQUEST_RESPONSE)
	return;
    AcceptAuthenticationName.data = 0;
    AcceptAuthenticationData.data = 0;
    AcceptAuthorizationName.data = 0;
    AcceptAuthorizationData.data = 0;
    if (XdmcpReadCARD32 (&buffer, &AcceptSessionID) &&
	XdmcpReadARRAY8 (&buffer, &AcceptAuthenticationName) &&
	XdmcpReadARRAY8 (&buffer, &AcceptAuthenticationData) &&
	XdmcpReadARRAY8 (&buffer, &AcceptAuthorizationName) &&
	XdmcpReadARRAY8 (&buffer, &AcceptAuthorizationData))
    {
    	if (length == 12 + AcceptAuthenticationName.length +
		      	   AcceptAuthenticationData.length +
		      	   AcceptAuthorizationName.length +
 		      	   AcceptAuthorizationData.length)
    	{
	    if (!XdmcpCheckAuthentication (&AcceptAuthenticationName,
				      &AcceptAuthenticationData, ACCEPT))
	    {
		XdmcpFatal ("Authentication Failure", &AcceptAuthenticationName);
	    }
	    /* permit access control manipulations from this host */
	    AugmentSelf (&req_sockaddr, req_socklen);
	    /* if the authorization specified in the packet fails
	     * to be acceptable, enable the local addresses
	     */
	    if (!XdmcpAddAuthorization (&AcceptAuthorizationName,
					&AcceptAuthorizationData))
	    {
		AddLocalHosts ();
	    }
	    SessionID = AcceptSessionID;
    	    state = XDM_MANAGE;
    	    send_packet();
    	}
    }
    XdmcpDisposeARRAY8 (&AcceptAuthenticationName);
    XdmcpDisposeARRAY8 (&AcceptAuthenticationData);
    XdmcpDisposeARRAY8 (&AcceptAuthorizationName);
    XdmcpDisposeARRAY8 (&AcceptAuthorizationData);
}

static void
recv_decline_msg(unsigned length)
{
    ARRAY8  status, DeclineAuthenticationName, DeclineAuthenticationData;

    status.data = 0;
    DeclineAuthenticationName.data = 0;
    DeclineAuthenticationData.data = 0;
    if (XdmcpReadARRAY8 (&buffer, &status) &&
	XdmcpReadARRAY8 (&buffer, &DeclineAuthenticationName) &&
	XdmcpReadARRAY8 (&buffer, &DeclineAuthenticationData))
    {
    	if (length == 6 + status.length +
		      	  DeclineAuthenticationName.length +
 		      	  DeclineAuthenticationData.length &&
	    XdmcpCheckAuthentication (&DeclineAuthenticationName,
				      &DeclineAuthenticationData, DECLINE))
    	{
	    XdmcpFatal ("Session declined", &status);
    	}
    }
    XdmcpDisposeARRAY8 (&status);
    XdmcpDisposeARRAY8 (&DeclineAuthenticationName);
    XdmcpDisposeARRAY8 (&DeclineAuthenticationData);
}

static void
send_manage_msg(void)
{
    XdmcpHeader	header;
    int socketfd = xdmcpSocket;

    header.version = XDM_PROTOCOL_VERSION;
    header.opcode = (CARD16) MANAGE;
    header.length = 8 + DisplayClass.length;

    if (!XdmcpWriteHeader (&buffer, &header))
	return;
    XdmcpWriteCARD32 (&buffer, SessionID);
    XdmcpWriteCARD16 (&buffer, DisplayNumber);
    XdmcpWriteARRAY8 (&buffer, &DisplayClass);
    state = XDM_AWAIT_MANAGE_RESPONSE;
#if defined(IPv6) && defined(AF_INET6)
    if (SOCKADDR_FAMILY(req_sockaddr) == AF_INET6)
	socketfd = xdmcpSocket6;
#endif
    XdmcpFlush (socketfd, &buffer, (XdmcpNetaddr) &req_sockaddr, req_socklen);
}

static void
recv_refuse_msg(unsigned length)
{
    CARD32  RefusedSessionID;

    if (state != XDM_AWAIT_MANAGE_RESPONSE)
	return;
    if (length != 4)
	return;
    if (XdmcpReadCARD32 (&buffer, &RefusedSessionID))
    {
	if (RefusedSessionID == SessionID)
	{
    	    state = XDM_START_CONNECTION;
    	    send_packet();
	}
    }
}

static void
recv_failed_msg(unsigned length)
{
    CARD32  FailedSessionID;
    ARRAY8  status;

    if (state != XDM_AWAIT_MANAGE_RESPONSE)
	return;
    status.data = 0;
    if (XdmcpReadCARD32 (&buffer, &FailedSessionID) &&
	XdmcpReadARRAY8 (&buffer, &status))
    {
    	if (length == 6 + status.length &&
	    SessionID == FailedSessionID)
	{
	    XdmcpFatal ("Session failed", &status);
	}
    }
    XdmcpDisposeARRAY8 (&status);
}

static void
send_keepalive_msg(void)
{
    XdmcpHeader	header;
    int socketfd = xdmcpSocket;

    header.version = XDM_PROTOCOL_VERSION;
    header.opcode = (CARD16) KEEPALIVE;
    header.length = 6;

    XdmcpWriteHeader (&buffer, &header);
    XdmcpWriteCARD16 (&buffer, DisplayNumber);
    XdmcpWriteCARD32 (&buffer, SessionID);

    state = XDM_AWAIT_ALIVE_RESPONSE;
#if defined(IPv6) && defined(AF_INET6)
    if (SOCKADDR_FAMILY(req_sockaddr) == AF_INET6)
	socketfd = xdmcpSocket6;
#endif
    XdmcpFlush (socketfd, &buffer, (XdmcpNetaddr) &req_sockaddr, req_socklen);
}

static void
recv_alive_msg (unsigned length)
{
    CARD8   SessionRunning;
    CARD32  AliveSessionID;

    if (state != XDM_AWAIT_ALIVE_RESPONSE)
	return;
    if (length != 5)
	return;
    if (XdmcpReadCARD8 (&buffer, &SessionRunning) &&
	XdmcpReadCARD32 (&buffer, &AliveSessionID))
    {
    	if (SessionRunning && AliveSessionID == SessionID)
    	{
	    /* backoff dormancy period */
	    state = XDM_RUN_SESSION;
	    if ((GetTimeInMillis() - lastDeviceEventTime.milliseconds) >
		keepaliveDormancy * 1000)
	    {
		keepaliveDormancy <<= 1;
		if (keepaliveDormancy > XDM_MAX_DORMANCY)
		    keepaliveDormancy = XDM_MAX_DORMANCY;
	    }
	    timeOutTime = GetTimeInMillis() + keepaliveDormancy * 1000;
    	}
	else
    	{
	    XdmcpDeadSession ("Alive response indicates session dead");
    	}
    }
}

static  void
XdmcpFatal (
    const char	*type,
    ARRAY8Ptr	status)
{
    FatalError ("XDMCP fatal error: %s %*.*s\n", type,
	   status->length, status->length, status->data);
}

static  void
XdmcpWarning(const char *str)
{
    ErrorF("XDMCP warning: %s\n", str);
}

static void
get_addr_by_name(
    const char *argtype,
    const char *namestr,
    int		port,
    int		socktype,
    SOCKADDR_TYPE *addr,
    SOCKLEN_TYPE *addrlen
#if defined(IPv6) && defined(AF_INET6)
      ,
    struct addrinfo **aip,
    struct addrinfo **aifirstp
#endif
    )
{
#if defined(IPv6) && defined(AF_INET6)
    struct addrinfo *ai;
    struct addrinfo hints;
    char portstr[6];
    char *pport = portstr;
    int gaierr;

    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = socktype;

    if (port == 0) {
	pport = NULL;
    } else if (port > 0 && port < 65535) {
	sprintf(portstr, "%d", port);
    } else {
	FatalError("Xserver: port out of range: %d\n", port);
    }

    if (*aifirstp != NULL) {
	freeaddrinfo(*aifirstp);	
	*aifirstp = NULL;
    }

    if ((gaierr = getaddrinfo(namestr, pport, &hints, aifirstp)) == 0) {
	for (ai = *aifirstp; ai != NULL; ai = ai->ai_next) {
	    if (ai->ai_family == AF_INET || ai->ai_family == AF_INET6)
		break;
	}
	if ((ai == NULL) || (ai->ai_addrlen > sizeof(SOCKADDR_TYPE))) {
	    FatalError ("Xserver: %s host %s not on supported network type\n", 
	      argtype, namestr);
	} else {
	    *aip = ai;
	    *addrlen = ai->ai_addrlen;
	    memcpy(addr, ai->ai_addr, ai->ai_addrlen);
	}
    } else {
	FatalError("Xserver: %s: %s %s\n", gai_strerror(gaierr), argtype, namestr);
    }    
#else
    struct hostent *hep;
#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
    _Xgethostbynameparams hparams;
#endif
#if defined(WIN32) && defined(TCPCONN)
    _XSERVTransWSAStartup(); 
#endif
    if (!(hep = _XGethostbyname(namestr, hparams)))
    {
	FatalError("Xserver: %s unknown host: %s\n", argtype, namestr);
    }
    if (hep->h_length == sizeof (struct in_addr))
    {
	memmove(&addr->sin_addr, hep->h_addr, hep->h_length);
	*addrlen = sizeof(struct sockaddr_in);
	addr->sin_family = AF_INET;
	addr->sin_port = htons (port);
    }
    else
    {
	FatalError("Xserver: %s host on strange network %s\n", argtype, namestr);
    }
#endif
}

static void
get_manager_by_name(
    int	    argc,
    char    **argv,
    int	    i)
{

    if ((i + 1) == argc)
    {
	FatalError("Xserver: missing %s host name in command line\n", argv[i]);
    }

    get_addr_by_name(argv[i], argv[i+1], xdm_udp_port, SOCK_DGRAM, 
      &ManagerAddress, &ManagerAddressLen
#if defined(IPv6) && defined(AF_INET6)
      , &mgrAddr, &mgrAddrFirst
#endif
	);
}


static void
get_fromaddr_by_name(
    int	    argc,
    char    **argv,
    int	    i)
{
#if defined(IPv6) && defined(AF_INET6)
    struct addrinfo *ai = NULL;
    struct addrinfo *aifirst = NULL;
#endif
    if (i == argc)
    {
	FatalError("Xserver: missing -from host name in command line\n");
    }
    get_addr_by_name("-from", argv[i], 0, 0, &FromAddress, &FromAddressLen
#if defined(IPv6) && defined(AF_INET6)
      , &ai, &aifirst
#endif
	);
#if defined(IPv6) && defined(AF_INET6)
    if (aifirst != NULL)
	freeaddrinfo(aifirst);
#endif
    xdm_from = argv[i];
}


#if defined(IPv6) && defined(AF_INET6)
static int
get_mcast_options(int argc, char **argv, int i)
{
    char *address = XDM_DEFAULT_MCAST_ADDR6;
    int hopcount = 1;
    struct addrinfo hints;
    char portstr[6];
    int gaierr;
    struct addrinfo *ai, *firstai;

    if ((i < argc) && (argv[i][0] != '-') && (argv[i][0] != '+')) {
	address = argv[i++];
	if ((i < argc) && (argv[i][0] != '-') && (argv[i][0] != '+')) {
	    hopcount = strtol(argv[i++], NULL, 10);
	    if ((hopcount < 1) || (hopcount > 255)) {
		FatalError("Xserver: multicast hop count out of range: %d\n",
		  hopcount);
	    }
	}
    }

    if (xdm_udp_port > 0 && xdm_udp_port < 65535) {
	sprintf(portstr, "%d", xdm_udp_port);
    } else {
	FatalError("Xserver: port out of range: %d\n", xdm_udp_port);
    }
    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_DGRAM;

    if ((gaierr = getaddrinfo(address, portstr, &hints, &firstai)) == 0) {
	for (ai = firstai; ai != NULL; ai = ai->ai_next) {
	    if (((ai->ai_family == AF_INET) && 
	      	IN_MULTICAST(((struct sockaddr_in *) ai->ai_addr)
							  ->sin_addr.s_addr))
		|| ((ai->ai_family == AF_INET6) && 
		  IN6_IS_ADDR_MULTICAST(&((struct sockaddr_in6 *) ai->ai_addr)
							    ->sin6_addr)))
		break;
	}
	if (ai == NULL) {
	    FatalError ("Xserver: address not supported multicast type %s\n", 
	      address);
	} else {
	    struct multicastinfo	*mcastinfo, *mcl;
	    
	    mcastinfo = malloc(sizeof(struct multicastinfo));
	    mcastinfo->next = NULL;
	    mcastinfo->ai = firstai;
	    mcastinfo->hops = hopcount;

	    if (mcastlist == NULL) {
		mcastlist = mcastinfo;
	    } else {
		for (mcl = mcastlist; mcl->next != NULL; mcl = mcl->next) {
		    /* Do nothing  - just find end of list */
		}
		mcl->next = mcastinfo;
	    }
	}
    } else {
	FatalError("Xserver: %s: %s\n", gai_strerror(gaierr), address);
    }    
    return i;
}
#endif

#else
static int xdmcp_non_empty; /* avoid complaint by ranlib */
#endif /* XDMCP */
/**
 * @file
 *
 * @section DESCRIPTION
 *
 * These functions provide a portable implementation of the common (but not
 * yet universal) asprintf & vasprintf routines to allocate a buffer big
 * enough to sprintf the arguments to.  The XNF variants terminate the server
 * if the allocation fails.
 */
/*
 * Copyright (c) 2004 Alexander Gottwald
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/Xos.h>
#include "os.h"
#include <stdarg.h>
#include <stdio.h>

#ifdef asprintf
# undef asprintf
#endif
#ifdef vasprintf
# undef vasprintf
#endif

#ifndef va_copy
# ifdef __va_copy
#  define va_copy __va_copy
# else
#  error "no working va_copy was found"
# endif
#endif

/**
 * Varargs sprintf that allocates a string buffer the right size for
 * the pattern & data provided and prints the requested data to it.
 *
 * @param ret     Pointer to which the newly allocated buffer is written
 *                (contents undefined on error)
 * @param format  printf style format string
 * @param va      variable argument list
 * @return        size of allocated buffer, or -1 on error.
 */
int
Xvasprintf(char **ret, const char * _X_RESTRICT_KYWD format, va_list va)
{
#ifdef HAVE_VASPRINTF
    return vasprintf(ret, format, va);
#else
    int size;
    va_list va2;

    va_copy(va2, va);
    size = vsnprintf(NULL, 0, format, va2);
    va_end(va2);

    *ret = malloc(size + 1);
    if (*ret == NULL)
        return -1;

    vsnprintf(*ret, size + 1, format, va);
    (*ret)[size] = 0;
    return size;
#endif
}

#ifndef HAVE_VASPRINTF
# define vasprintf Xvasprintf
#endif

/**
 * sprintf that allocates a string buffer the right size for
 * the pattern & data provided and prints the requested data to it.
 *
 * @param ret     Pointer to which the newly allocated buffer is written
 *                (contents undefined on error)
 * @param format  printf style format string
 * @param ...     arguments for specified format
 * @return        size of allocated buffer, or -1 on error.
 */
int
Xasprintf(char ** ret, const char * _X_RESTRICT_KYWD format, ...)
{
    int size;
    va_list va;
    va_start(va, format);
    size = vasprintf(ret, format, va);
    va_end(va);
    return size;
}

/**
 * Varargs sprintf that allocates a string buffer the right size for
 * the pattern & data provided and prints the requested data to it.
 * On failure, issues a FatalError message and aborts the server.
 *
 * @param ret     Pointer to which the newly allocated buffer is written
 *                (contents undefined on error)
 * @param format  printf style format string
 * @param va      variable argument list
 * @return        size of allocated buffer
 */
int
XNFvasprintf(char **ret, const char * _X_RESTRICT_KYWD format, va_list va)
{
    int size = vasprintf(ret, format, va);
    if ((size == -1) || (*ret == NULL)) {
	Error("XNFvasprintf");
	FatalError("XNFvasprintf failed");
    }
    return size;
}

/**
 * sprintf that allocates a string buffer the right size for
 * the pattern & data provided and prints the requested data to it.
 * On failure, issues a FatalError message and aborts the server.
 *
 * @param ret     Pointer to which the newly allocated buffer is written
 *                (contents undefined on error)
 * @param format  printf style format string
 * @param ...     arguments for specified format
 * @return        size of allocated buffer
 */
int
XNFasprintf(char ** ret, const char * _X_RESTRICT_KYWD format, ...)
{
    int size;
    va_list va;
    va_start(va, format);
    size = XNFvasprintf(ret, format, va);
    va_end(va);
    return size;
}

/* Old api, now deprecated, may be removed in the future */
char *
Xvprintf(const char *format, va_list va)
{
    char *ret;

    if (vasprintf(&ret, format, va) == -1)
	ret = NULL;

    return ret;
}

char *Xprintf(const char *format, ...)
{
    char *ret;
    va_list va;
    va_start(va, format);
    if (vasprintf(&ret, format, va) == -1)
	ret = NULL;
    va_end(va);
    return ret;
}

char *
XNFvprintf(const char *format, va_list va)
{
    char *ret;

    XNFvasprintf(&ret, format, va);

    return ret;
}

char *XNFprintf(const char *format, ...)
{
    char *ret;
    va_list va;
    va_start(va, format);
    XNFvasprintf(&ret, format, va);
    va_end(va);
    return ret;
}
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "os.h"
#include "xsha1.h"

#ifdef __MINGW32__
#include <X11/Xwinsock.h>
#endif

#if defined(HAVE_SHA1_IN_LIBMD)  /* Use libmd for SHA1 */ \
	|| defined(HAVE_SHA1_IN_LIBC) /* Use libc for SHA1 */

# include <sha1.h>

void *x_sha1_init(void)
{
    SHA1_CTX *ctx = malloc(sizeof(*ctx));
    if (!ctx)
        return NULL;
    SHA1Init(ctx);
    return ctx;
}

int x_sha1_update(void *ctx, void *data, int size)
{
    SHA1_CTX *sha1_ctx = ctx;
    SHA1Update(sha1_ctx, data, size);
    return 1;
}

int x_sha1_final(void *ctx, unsigned char result[20])
{
    SHA1_CTX *sha1_ctx = ctx;
    SHA1Final(result, sha1_ctx);
    free(sha1_ctx);
    return 1;
}

#elif defined(HAVE_SHA1_IN_COMMONCRYPTO) /* Use CommonCrypto for SHA1 */

#include <CommonCrypto/CommonDigest.h>

void *x_sha1_init(void)
{
    CC_SHA1_CTX *ctx = malloc(sizeof(*ctx));
    if (!ctx)
        return NULL;
    CC_SHA1_Init(ctx);
    return ctx;
}

int x_sha1_update(void *ctx, void *data, int size)
{
    CC_SHA1_CTX *sha1_ctx = ctx;
    CC_SHA1_Update(sha1_ctx, data, size);
    return 1;
}

int x_sha1_final(void *ctx, unsigned char result[20])
{
    CC_SHA1_CTX *sha1_ctx = ctx;
    CC_SHA1_Final(result, sha1_ctx);
    free(sha1_ctx);
    return 1;
}

#elif defined(HAVE_SHA1_IN_LIBGCRYPT) /* Use libgcrypt for SHA1 */

# include <gcrypt.h>

void *x_sha1_init(void)
{
    static int init;
    gcry_md_hd_t h;
    gcry_error_t err;

    if (!init) {
        if (!gcry_check_version(NULL))
            return NULL;
        gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
        gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
        init = 1;
    }

    err = gcry_md_open(&h, GCRY_MD_SHA1, 0);
    if (err)
        return NULL;
    return h;
}

int x_sha1_update(void *ctx, void *data, int size)
{
    gcry_md_hd_t h = ctx;
    gcry_md_write(h, data, size);
    return 1;
}

int x_sha1_final(void *ctx, unsigned char result[20])
{
    gcry_md_hd_t h = ctx;
    memcpy(result, gcry_md_read(h, GCRY_MD_SHA1), 20);
    gcry_md_close(h);
    return 1;
}

#elif defined(HAVE_SHA1_IN_LIBSHA1) /* Use libsha1 */

# include <libsha1.h>

void *x_sha1_init(void)
{
    sha1_ctx *ctx = malloc(sizeof(*ctx));
    if(!ctx)
        return NULL;
    sha1_begin(ctx);
    return ctx;
}

int x_sha1_update(void *ctx, void *data, int size)
{
    sha1_hash(data, size, ctx);
    return 1;
}

int x_sha1_final(void *ctx, unsigned char result[20])
{
    sha1_end(result, ctx);
    free(ctx);
    return 1;
}

#else /* Use OpenSSL's libcrypto */

# include <stddef.h>  /* buggy openssl/sha.h wants size_t */
# include <openssl/sha.h>

void *x_sha1_init(void)
{
    int ret;
    SHA_CTX *ctx = malloc(sizeof(*ctx));
    if (!ctx)
        return NULL;
    ret = SHA1_Init(ctx);
    if (!ret) {
        free(ctx);
        return NULL;
    }
    return ctx;
}

int x_sha1_update(void *ctx, void *data, int size)
{
    int ret;
    SHA_CTX *sha_ctx = ctx;
    ret = SHA1_Update(sha_ctx, data, size);
    if (!ret)
        free(sha_ctx);
    return ret;
}

int x_sha1_final(void *ctx, unsigned char result[20])
{
    int ret;
    SHA_CTX *sha_ctx = ctx;
    ret = SHA1_Final(result, sha_ctx);
    free(sha_ctx);
    return ret;
}

#endif
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/Xfuncproto.h>

/* ErrorF is used by xtrans */
extern _X_EXPORT void ErrorF(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2);

#define TRANS_REOPEN
#define TRANS_SERVER
#define XSERV_t
#include <X11/Xtrans/transport.c>
noinst_LTLIBRARIES = librandr.la

AM_CFLAGS = $(DIX_CFLAGS)

XINERAMA_SRCS = rrxinerama.c

if XORG
sdk_HEADERS = randrstr.h rrtransform.h
endif

librandr_la_SOURCES =	\
	randr.c		\
	randrstr.h	\
	rrcrtc.c	\
	rrdispatch.c	\
	rrinfo.c	\
	rrmode.c	\
	rroutput.c	\
	rrpointer.c	\
	rrproperty.c	\
	rrscreen.c	\
	rrsdispatch.c	\
	rrtransform.h	\
	rrtransform.c

if XINERAMA
librandr_la_SOURCES += ${XINERAMA_SRCS}
endif

/*
 * Copyright © 2000 Compaq Computer Corporation
 * Copyright © 2002 Hewlett-Packard Company
 * Copyright © 2006 Intel Corporation
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
 *	    Keith Packard, Intel Corporation
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "randrstr.h"

/* From render.h */
#ifndef SubPixelUnknown
#define SubPixelUnknown 0
#endif

#define RR_VALIDATE
static int	RRNScreens;

#define wrap(priv,real,mem,func) {\
    priv->mem = real->mem; \
    real->mem = func; \
}

#define unwrap(priv,real,mem) {\
    real->mem = priv->mem; \
}

static int ProcRRDispatch (ClientPtr pClient);
static int SProcRRDispatch (ClientPtr pClient);

int	RREventBase;
int	RRErrorBase;
RESTYPE RRClientType, RREventType; /* resource types for event masks */
DevPrivateKeyRec RRClientPrivateKeyRec;

DevPrivateKeyRec rrPrivKeyRec;

static void
RRClientCallback (CallbackListPtr	*list,
		  pointer		closure,
		  pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    rrClientPriv(pClient);
    RRTimesPtr		pTimes = (RRTimesPtr) (pRRClient + 1);
    int			i;

    pRRClient->major_version = 0;
    pRRClient->minor_version = 0;
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ScreenPtr   pScreen = screenInfo.screens[i];
	rrScrPriv(pScreen);

	if (pScrPriv)
	{
	    pTimes[i].setTime = pScrPriv->lastSetTime;
	    pTimes[i].configTime = pScrPriv->lastConfigTime;
	}
    }
}

static Bool
RRCloseScreen (int i, ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    int		    j;

    unwrap (pScrPriv, pScreen, CloseScreen);
    for (j = pScrPriv->numCrtcs - 1; j >= 0; j--)
	RRCrtcDestroy (pScrPriv->crtcs[j]);
    for (j = pScrPriv->numOutputs - 1; j >= 0; j--)
	RROutputDestroy (pScrPriv->outputs[j]);
    
    free(pScrPriv->crtcs);
    free(pScrPriv->outputs);
    free(pScrPriv);
    RRNScreens -= 1;	/* ok, one fewer screen with RandR running */
    return (*pScreen->CloseScreen) (i, pScreen);    
}

static void
SRRScreenChangeNotifyEvent(xRRScreenChangeNotifyEvent *from,
			   xRRScreenChangeNotifyEvent *to)
{
    to->type = from->type;
    to->rotation = from->rotation;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->configTimestamp, to->configTimestamp);
    cpswapl(from->root, to->root);
    cpswapl(from->window, to->window);
    cpswaps(from->sizeID, to->sizeID);
    cpswaps(from->subpixelOrder, to->subpixelOrder);
    cpswaps(from->widthInPixels, to->widthInPixels);
    cpswaps(from->heightInPixels, to->heightInPixels);
    cpswaps(from->widthInMillimeters, to->widthInMillimeters);
    cpswaps(from->heightInMillimeters, to->heightInMillimeters);
}

static void
SRRCrtcChangeNotifyEvent(xRRCrtcChangeNotifyEvent *from,
			 xRRCrtcChangeNotifyEvent *to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->window, to->window);
    cpswapl(from->crtc, to->crtc);
    cpswapl(from->mode, to->mode);
    cpswaps(from->rotation, to->rotation);
    /* pad1 */
    cpswaps(from->x, to->x);
    cpswaps(from->y, to->y);
    cpswaps(from->width, to->width);
    cpswaps(from->height, to->height);
}

static void
SRROutputChangeNotifyEvent(xRROutputChangeNotifyEvent *from,
			   xRROutputChangeNotifyEvent *to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->configTimestamp, to->configTimestamp);
    cpswapl(from->window, to->window);
    cpswapl(from->output, to->output);
    cpswapl(from->crtc, to->crtc);
    cpswapl(from->mode, to->mode);
    cpswaps(from->rotation, to->rotation);
    to->connection = from->connection;
    to->subpixelOrder = from->subpixelOrder;
}

static void
SRROutputPropertyNotifyEvent(xRROutputPropertyNotifyEvent *from,
			     xRROutputPropertyNotifyEvent *to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->window, to->window);
    cpswapl(from->output, to->output);
    cpswapl(from->atom, to->atom);
    cpswapl(from->timestamp, to->timestamp);
    to->state = from->state;
    /* pad1 */
    /* pad2 */
    /* pad3 */
    /* pad4 */
}

static void
SRRNotifyEvent (xEvent *from,
		xEvent *to)
{
    switch (from->u.u.detail) {
    case RRNotify_CrtcChange:
	SRRCrtcChangeNotifyEvent ((xRRCrtcChangeNotifyEvent *) from,
				  (xRRCrtcChangeNotifyEvent *) to);
	break;
    case RRNotify_OutputChange:
	SRROutputChangeNotifyEvent ((xRROutputChangeNotifyEvent *) from,
				    (xRROutputChangeNotifyEvent *) to);
	break;
    case RRNotify_OutputProperty:
	SRROutputPropertyNotifyEvent ((xRROutputPropertyNotifyEvent *) from,
				      (xRROutputPropertyNotifyEvent *) to);
	break;
    default:
	break;
    }
}

static int RRGeneration;

Bool RRInit (void)
{
    if (RRGeneration != serverGeneration)
    {
	if (!RRModeInit ())
	    return FALSE;
	if (!RRCrtcInit ())
	    return FALSE;
	if (!RROutputInit ())
	    return FALSE;
	RRGeneration = serverGeneration;
    }
    if (!dixRegisterPrivateKey(&rrPrivKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;

    return TRUE;
}

Bool RRScreenInit(ScreenPtr pScreen)
{
    rrScrPrivPtr   pScrPriv;

    if (!RRInit ())
	return FALSE;

    pScrPriv = (rrScrPrivPtr) calloc(1, sizeof (rrScrPrivRec));
    if (!pScrPriv)
	return FALSE;

    SetRRScreen(pScreen, pScrPriv);

    /*
     * Calling function best set these function vectors
     */
    pScrPriv->rrGetInfo = 0;
    pScrPriv->maxWidth = pScrPriv->minWidth = pScreen->width;
    pScrPriv->maxHeight = pScrPriv->minHeight = pScreen->height;
    
    pScrPriv->width = pScreen->width;
    pScrPriv->height = pScreen->height;
    pScrPriv->mmWidth = pScreen->mmWidth;
    pScrPriv->mmHeight = pScreen->mmHeight;
#if RANDR_12_INTERFACE
    pScrPriv->rrScreenSetSize = NULL;
    pScrPriv->rrCrtcSet = NULL;
    pScrPriv->rrCrtcSetGamma = NULL;
#endif
#if RANDR_10_INTERFACE    
    pScrPriv->rrSetConfig = 0;
    pScrPriv->rotations = RR_Rotate_0;
    pScrPriv->reqWidth = pScreen->width;
    pScrPriv->reqHeight = pScreen->height;
    pScrPriv->nSizes = 0;
    pScrPriv->pSizes = NULL;
    pScrPriv->rotation = RR_Rotate_0;
    pScrPriv->rate = 0;
    pScrPriv->size = 0;
#endif
    
    /*
     * This value doesn't really matter -- any client must call
     * GetScreenInfo before reading it which will automatically update
     * the time
     */
    pScrPriv->lastSetTime = currentTime;
    pScrPriv->lastConfigTime = currentTime;
    
    wrap (pScrPriv, pScreen, CloseScreen, RRCloseScreen);

    pScreen->ConstrainCursorHarder = RRConstrainCursorHarder;

    pScrPriv->numOutputs = 0;
    pScrPriv->outputs = NULL;
    pScrPriv->numCrtcs = 0;
    pScrPriv->crtcs = NULL;
    
    RRNScreens += 1;	/* keep count of screens that implement randr */
    return TRUE;
}

/*ARGSUSED*/
static int
RRFreeClient (pointer data, XID id)
{
    RREventPtr   pRREvent;
    WindowPtr	    pWin;
    RREventPtr   *pHead, pCur, pPrev;

    pRREvent = (RREventPtr) data;
    pWin = pRREvent->window;
    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
			    RREventType, serverClient, DixDestroyAccess);
    if (pHead) {
	pPrev = 0;
	for (pCur = *pHead; pCur && pCur != pRREvent; pCur=pCur->next)
	    pPrev = pCur;
	if (pCur)
	{
	    if (pPrev)
	    	pPrev->next = pRREvent->next;
	    else
	    	*pHead = pRREvent->next;
	}
    }
    free((pointer) pRREvent);
    return 1;
}

/*ARGSUSED*/
static int
RRFreeEvents (pointer data, XID id)
{
    RREventPtr   *pHead, pCur, pNext;

    pHead = (RREventPtr *) data;
    for (pCur = *pHead; pCur; pCur = pNext) {
	pNext = pCur->next;
	FreeResource (pCur->clientResource, RRClientType);
	free((pointer) pCur);
    }
    free((pointer) pHead);
    return 1;
}

void
RRExtensionInit (void)
{
    ExtensionEntry *extEntry;

    if (RRNScreens == 0) return;

    if (!dixRegisterPrivateKey(&RRClientPrivateKeyRec, PRIVATE_CLIENT,
			       sizeof (RRClientRec) +
			       screenInfo.numScreens * sizeof (RRTimesRec)))
	return;
    if (!AddCallback (&ClientStateCallback, RRClientCallback, 0))
	return;

    RRClientType = CreateNewResourceType(RRFreeClient, "RandRClient");
    if (!RRClientType)
	return;
    RREventType = CreateNewResourceType(RRFreeEvents, "RandREvent");
    if (!RREventType)
	return;
    extEntry = AddExtension (RANDR_NAME, RRNumberEvents, RRNumberErrors,
			     ProcRRDispatch, SProcRRDispatch,
			     NULL, StandardMinorOpcode);
    if (!extEntry)
	return;
    RRErrorBase = extEntry->errorBase;
    RREventBase = extEntry->eventBase;
    EventSwapVector[RREventBase + RRScreenChangeNotify] = (EventSwapPtr) 
	SRRScreenChangeNotifyEvent;
    EventSwapVector[RREventBase + RRNotify] = (EventSwapPtr)
	SRRNotifyEvent;

    RRModeInitErrorValue();
    RRCrtcInitErrorValue();
    RROutputInitErrorValue();

#ifdef PANORAMIX
    RRXineramaExtensionInit();
#endif
}

static int
TellChanged (WindowPtr pWin, pointer value)
{
    RREventPtr			*pHead, pRREvent;
    ClientPtr			client;
    ScreenPtr			pScreen = pWin->drawable.pScreen;
    rrScrPriv(pScreen);
    int				i;

    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
			    RREventType, serverClient, DixReadAccess);
    if (!pHead)
	return WT_WALKCHILDREN;

    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next) 
    {
	client = pRREvent->client;
	if (client == serverClient || client->clientGone)
	    continue;

	if (pRREvent->mask & RRScreenChangeNotifyMask)
	    RRDeliverScreenEvent (client, pWin, pScreen);
	
	if (pRREvent->mask & RRCrtcChangeNotifyMask)
	{
	    for (i = 0; i < pScrPriv->numCrtcs; i++)
	    {
		RRCrtcPtr   crtc = pScrPriv->crtcs[i];
		if (crtc->changed)
		    RRDeliverCrtcEvent (client, pWin, crtc);
	    }
	}
	
	if (pRREvent->mask & RROutputChangeNotifyMask)
	{
	    for (i = 0; i < pScrPriv->numOutputs; i++)
	    {
		RROutputPtr   output = pScrPriv->outputs[i];
		if (output->changed)
		    RRDeliverOutputEvent (client, pWin, output);
	    }
	}
    }
    return WT_WALKCHILDREN;
}

/*
 * Something changed; send events and adjust pointer position
 */
void
RRTellChanged (ScreenPtr pScreen)
{
    rrScrPriv (pScreen);
    int i;
    
    if (pScrPriv->changed)
    {
	UpdateCurrentTime ();
	if (pScrPriv->configChanged)
	{
	    pScrPriv->lastConfigTime = currentTime;
	    pScrPriv->configChanged = FALSE;
	}
	pScrPriv->changed = FALSE;
	WalkTree (pScreen, TellChanged, (pointer) pScreen);
	for (i = 0; i < pScrPriv->numOutputs; i++)
	    pScrPriv->outputs[i]->changed = FALSE;
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	    pScrPriv->crtcs[i]->changed = FALSE;
	if (pScrPriv->layoutChanged)
	{
	    pScrPriv->layoutChanged = FALSE;
	    RRPointerScreenConfigured (pScreen);
	    RRSendConfigNotify (pScreen);
	}
    }
}

/*
 * Return the first output which is connected to an active CRTC
 * Used in emulating 1.0 behaviour
 */
RROutputPtr
RRFirstOutput (ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    RROutputPtr		    output;
    int	i, j;
    
    if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc)
	return pScrPriv->primaryOutput;

    for (i = 0; i < pScrPriv->numCrtcs; i++)
    {
	RRCrtcPtr   crtc = pScrPriv->crtcs[i];
	for (j = 0; j < pScrPriv->numOutputs; j++)
	{
	    output = pScrPriv->outputs[j];
	    if (output->crtc == crtc)
		return output;
	}
    }
    return NULL;
}

CARD16
RRVerticalRefresh (xRRModeInfo *mode)
{
    CARD32  refresh;
    CARD32  dots = mode->hTotal * mode->vTotal;
    if (!dots)
	return 0;
    refresh = (mode->dotClock + dots/2) / dots;
    if (refresh > 0xffff)
	refresh = 0xffff;
    return (CARD16) refresh;
}

static int
ProcRRDispatch (ClientPtr client)
{
    REQUEST(xReq);
    if (stuff->data >= RRNumberRequests || !ProcRandrVector[stuff->data])
	return BadRequest;
    return (*ProcRandrVector[stuff->data]) (client);
}

static int
SProcRRDispatch (ClientPtr client)
{
    REQUEST(xReq);
    if (stuff->data >= RRNumberRequests || !ProcRandrVector[stuff->data])
	return BadRequest;
    return (*SProcRandrVector[stuff->data]) (client);
}

/*
 * Copyright © 2000 Compaq Computer Corporation
 * Copyright © 2002 Hewlett-Packard Company
 * Copyright © 2006 Intel Corporation
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
 *	    Keith Packard, Intel Corporation
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _RANDRSTR_H_
#define _RANDRSTR_H_

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "servermd.h"
#include "rrtransform.h"
#include <X11/extensions/randr.h>
#include <X11/extensions/randrproto.h>
#include <X11/extensions/render.h> 	/* we share subpixel order information */
#include "picturestr.h"
#include <X11/Xfuncproto.h>

/* required for ABI compatibility for now */
#define RANDR_10_INTERFACE 1
#define RANDR_12_INTERFACE 1
#define RANDR_13_INTERFACE 1 /* requires RANDR_12_INTERFACE */
#define RANDR_GET_CRTC_INTERFACE 1

#define RANDR_INTERFACE_VERSION 0x0103

typedef XID	RRMode;
typedef XID	RROutput;
typedef XID	RRCrtc;

extern _X_EXPORT int	RREventBase, RRErrorBase;

extern _X_EXPORT int (*ProcRandrVector[RRNumberRequests])(ClientPtr);
extern _X_EXPORT int (*SProcRandrVector[RRNumberRequests])(ClientPtr);
    
/*
 * Modeline for a monitor. Name follows directly after this struct
 */

#define RRModeName(pMode) ((char *) (pMode + 1))
typedef struct _rrMode		RRModeRec, *RRModePtr;
typedef struct _rrPropertyValue	RRPropertyValueRec, *RRPropertyValuePtr;
typedef struct _rrProperty	RRPropertyRec, *RRPropertyPtr;
typedef struct _rrCrtc		RRCrtcRec, *RRCrtcPtr;
typedef struct _rrOutput	RROutputRec, *RROutputPtr;

struct _rrMode {
    int		    refcnt;
    xRRModeInfo	    mode;
    char	    *name;
    ScreenPtr	    userScreen;
};

struct _rrPropertyValue {
    Atom	    type;       /* ignored by server */
    short	    format;     /* format of data for swapping - 8,16,32 */
    long	    size;	/* size of data in (format/8) bytes */
    pointer         data;	/* private to client */
};

struct _rrProperty {
    RRPropertyPtr   next;
    ATOM 	    propertyName;
    Bool	    is_pending;
    Bool	    range;
    Bool	    immutable;
    int		    num_valid;
    INT32	    *valid_values;
    RRPropertyValueRec	current, pending;
};

struct _rrCrtc {
    RRCrtc	    id;
    ScreenPtr	    pScreen;
    RRModePtr	    mode;
    int		    x, y;
    Rotation	    rotation;
    Rotation	    rotations;
    Bool	    changed;
    int		    numOutputs;
    RROutputPtr	    *outputs;
    int		    gammaSize;
    CARD16	    *gammaRed;
    CARD16	    *gammaBlue;
    CARD16	    *gammaGreen;
    void	    *devPrivate;
    Bool	    transforms;
    RRTransformRec  client_pending_transform;
    RRTransformRec  client_current_transform;
    PictTransform   transform;
    struct pict_f_transform f_transform;
    struct pict_f_transform f_inverse;
};

struct _rrOutput {
    RROutput	    id;
    ScreenPtr	    pScreen;
    char	    *name;
    int		    nameLength;
    CARD8	    connection;
    CARD8	    subpixelOrder;
    int		    mmWidth;
    int		    mmHeight;
    RRCrtcPtr	    crtc;
    int		    numCrtcs;
    RRCrtcPtr	    *crtcs;
    int		    numClones;
    RROutputPtr	    *clones;
    int		    numModes;
    int		    numPreferred;
    RRModePtr	    *modes;
    int		    numUserModes;
    RRModePtr	    *userModes;
    Bool	    changed;
    RRPropertyPtr   properties;
    Bool	    pendingProperties;
    void	    *devPrivate;
};

#if RANDR_12_INTERFACE
typedef Bool (*RRScreenSetSizeProcPtr) (ScreenPtr	pScreen,
					CARD16		width,
					CARD16		height,
					CARD32		mmWidth,
					CARD32		mmHeight);
					
typedef Bool (*RRCrtcSetProcPtr) (ScreenPtr		pScreen,
				  RRCrtcPtr		crtc,
				  RRModePtr		mode,
				  int			x,
				  int			y,
				  Rotation		rotation,
				  int			numOutputs,
				  RROutputPtr		*outputs);

typedef Bool (*RRCrtcSetGammaProcPtr) (ScreenPtr	pScreen,
				       RRCrtcPtr	crtc);

typedef Bool (*RRCrtcGetGammaProcPtr) (ScreenPtr	pScreen,
				       RRCrtcPtr	crtc);

typedef Bool (*RROutputSetPropertyProcPtr) (ScreenPtr		pScreen,
					    RROutputPtr		output,
					    Atom		property,
					    RRPropertyValuePtr	value);

typedef Bool (*RROutputValidateModeProcPtr) (ScreenPtr		pScreen,
					     RROutputPtr	output,
					     RRModePtr		mode);

typedef void (*RRModeDestroyProcPtr) (ScreenPtr	    pScreen,
				      RRModePtr	    mode);

#endif

#if RANDR_13_INTERFACE
typedef Bool (*RROutputGetPropertyProcPtr) (ScreenPtr		pScreen,
					    RROutputPtr		output,
					    Atom		property);
typedef Bool (*RRGetPanningProcPtr)    (ScreenPtr		pScrn,
					RRCrtcPtr		crtc,
					BoxPtr		totalArea,
					BoxPtr		trackingArea,
					INT16		*border);
typedef Bool (*RRSetPanningProcPtr)    (ScreenPtr		pScrn,
					RRCrtcPtr		crtc,
					BoxPtr		totalArea,
					BoxPtr		trackingArea,
					INT16		*border);

#endif /* RANDR_13_INTERFACE */

typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation *rotations);
typedef Bool (*RRCloseScreenProcPtr) ( int i, ScreenPtr pscreen);

/* These are for 1.0 compatibility */
 
typedef struct _rrRefresh {
    CARD16	    rate;
    RRModePtr	    mode;
} RRScreenRate, *RRScreenRatePtr;

typedef struct _rrScreenSize {
    int		    id;
    short	    width, height;
    short	    mmWidth, mmHeight;
    int		    nRates;
    RRScreenRatePtr pRates;
} RRScreenSize, *RRScreenSizePtr;

#ifdef RANDR_10_INTERFACE

typedef Bool (*RRSetConfigProcPtr) (ScreenPtr		pScreen,
				    Rotation		rotation,
				    int			rate,
				    RRScreenSizePtr	pSize);

#endif
	

typedef struct _rrScrPriv {
    /*
     * 'public' part of the structure; DDXen fill this in
     * as they initialize
     */
#if RANDR_10_INTERFACE
    RRSetConfigProcPtr	    rrSetConfig;
#endif
    RRGetInfoProcPtr	    rrGetInfo;
#if RANDR_12_INTERFACE
    RRScreenSetSizeProcPtr  rrScreenSetSize;
    RRCrtcSetProcPtr	    rrCrtcSet;
    RRCrtcSetGammaProcPtr   rrCrtcSetGamma;
    RRCrtcGetGammaProcPtr   rrCrtcGetGamma;
    RROutputSetPropertyProcPtr	rrOutputSetProperty;
    RROutputValidateModeProcPtr	rrOutputValidateMode;
    RRModeDestroyProcPtr	rrModeDestroy;
#endif
#if RANDR_13_INTERFACE
    RROutputGetPropertyProcPtr	rrOutputGetProperty;
    RRGetPanningProcPtr	rrGetPanning;
    RRSetPanningProcPtr	rrSetPanning;
#endif
    
    /*
     * Private part of the structure; not considered part of the ABI
     */
    TimeStamp		    lastSetTime;	/* last changed by client */
    TimeStamp		    lastConfigTime;	/* possible configs changed */
    RRCloseScreenProcPtr    CloseScreen;

    Bool		    changed;		/* some config changed */
    Bool		    configChanged;	/* configuration changed */
    Bool		    layoutChanged;	/* screen layout changed */

    CARD16		    minWidth, minHeight;
    CARD16		    maxWidth, maxHeight;
    CARD16		    width, height;	/* last known screen size */
    CARD16		    mmWidth, mmHeight;	/* last known screen size */

    int			    numOutputs;
    RROutputPtr		    *outputs;
    RROutputPtr		    primaryOutput;

    int			    numCrtcs;
    RRCrtcPtr		    *crtcs;

    /* Last known pointer position */
    RRCrtcPtr		    pointerCrtc;

#ifdef RANDR_10_INTERFACE
    /*
     * Configuration information
     */
    Rotation		    rotations;
    CARD16		    reqWidth, reqHeight;
    
    int			    nSizes;
    RRScreenSizePtr	    pSizes;
    
    Rotation		    rotation;
    int			    rate;
    int			    size;
#endif
    Bool                   discontiguous;
} rrScrPrivRec, *rrScrPrivPtr;

extern _X_EXPORT DevPrivateKeyRec rrPrivKeyRec;
#define rrPrivKey (&rrPrivKeyRec)

#define rrGetScrPriv(pScr)  ((rrScrPrivPtr)dixLookupPrivate(&(pScr)->devPrivates, rrPrivKey))
#define rrScrPriv(pScr)	rrScrPrivPtr    pScrPriv = rrGetScrPriv(pScr)
#define SetRRScreen(s,p) dixSetPrivate(&(s)->devPrivates, rrPrivKey, p)

/*
 * each window has a list of clients requesting
 * RRNotify events.  Each client has a resource
 * for each window it selects RRNotify input for,
 * this resource is used to delete the RRNotifyRec
 * entry from the per-window queue.
 */

typedef struct _RREvent *RREventPtr;

typedef struct _RREvent {
    RREventPtr  next;
    ClientPtr	client;
    WindowPtr	window;
    XID		clientResource;
    int		mask;
} RREventRec;

typedef struct _RRTimes {
    TimeStamp	setTime;
    TimeStamp	configTime;
} RRTimesRec, *RRTimesPtr;

typedef struct _RRClient {
    int		major_version;
    int		minor_version;
/*  RRTimesRec	times[0]; */
} RRClientRec, *RRClientPtr;

extern _X_EXPORT RESTYPE RRClientType, RREventType; /* resource types for event masks */
extern _X_EXPORT DevPrivateKeyRec RRClientPrivateKeyRec;
#define RRClientPrivateKey (&RRClientPrivateKeyRec)
extern _X_EXPORT RESTYPE RRCrtcType, RRModeType, RROutputType;

#define VERIFY_RR_OUTPUT(id, ptr, a)\
    {\
	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
	                                 RROutputType, client, a);\
	if (rc != Success) {\
	    client->errorValue = id;\
	    return rc;\
	}\
    }

#define VERIFY_RR_CRTC(id, ptr, a)\
    {\
	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
	                                 RRCrtcType, client, a);\
	if (rc != Success) {\
	    client->errorValue = id;\
	    return rc;\
	}\
    }

#define VERIFY_RR_MODE(id, ptr, a)\
    {\
	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
	                                 RRModeType, client, a);\
	if (rc != Success) {\
	    client->errorValue = id;\
	    return rc;\
	}\
    }

#define GetRRClient(pClient)    ((RRClientPtr)dixLookupPrivate(&(pClient)->devPrivates, RRClientPrivateKey))
#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)

/* Initialize the extension */
extern _X_EXPORT void
RRExtensionInit (void);

#ifdef RANDR_12_INTERFACE
/*
 * Set the range of sizes for the screen
 */
extern _X_EXPORT void
RRScreenSetSizeRange (ScreenPtr	pScreen,
		      CARD16	minWidth,
		      CARD16	minHeight,
		      CARD16	maxWidth,
		      CARD16	maxHeight);
#endif

/* rrscreen.c */
/*
 * Notify the extension that the screen size has been changed.
 * The driver is responsible for calling this whenever it has changed
 * the size of the screen
 */
extern _X_EXPORT void
RRScreenSizeNotify (ScreenPtr	pScreen);

/*
 * Request that the screen be resized
 */
extern _X_EXPORT Bool
RRScreenSizeSet (ScreenPtr  pScreen,
		 CARD16	    width,
		 CARD16	    height,
		 CARD32	    mmWidth,
		 CARD32	    mmHeight);

/*
 * Send ConfigureNotify event to root window when 'something' happens
 */
extern _X_EXPORT void
RRSendConfigNotify (ScreenPtr pScreen);
    
/*
 * screen dispatch
 */
extern _X_EXPORT int
ProcRRGetScreenSizeRange (ClientPtr client);

extern _X_EXPORT int
ProcRRSetScreenSize (ClientPtr client);

extern _X_EXPORT int
ProcRRGetScreenResources (ClientPtr client);

extern _X_EXPORT int
ProcRRGetScreenResourcesCurrent (ClientPtr client);

extern _X_EXPORT int
ProcRRSetScreenConfig (ClientPtr client);

extern _X_EXPORT int
ProcRRGetScreenInfo (ClientPtr client);

/*
 * Deliver a ScreenNotify event
 */
extern _X_EXPORT void
RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen);
    
/* randr.c */
/*
 * Send all pending events
 */
extern _X_EXPORT void
RRTellChanged (ScreenPtr pScreen);

/*
 * Poll the driver for changed information
 */
extern _X_EXPORT Bool
RRGetInfo (ScreenPtr pScreen, Bool force_query);

extern _X_EXPORT Bool RRInit (void);

extern _X_EXPORT Bool RRScreenInit(ScreenPtr pScreen);

extern _X_EXPORT RROutputPtr
RRFirstOutput (ScreenPtr pScreen);

extern _X_EXPORT Rotation
RRGetRotation (ScreenPtr pScreen);

extern _X_EXPORT CARD16
RRVerticalRefresh (xRRModeInfo *mode);

#ifdef RANDR_10_INTERFACE					
/*
 * This is the old interface, deprecated but left
 * around for compatibility
 */

/*
 * Then, register the specific size with the screen
 */

extern _X_EXPORT RRScreenSizePtr
RRRegisterSize (ScreenPtr		pScreen,
		short			width, 
		short			height,
		short			mmWidth,
		short			mmHeight);

extern _X_EXPORT Bool
RRRegisterRate (ScreenPtr		pScreen,
		     RRScreenSizePtr	pSize,
		     int		rate);

/*
 * Finally, set the current configuration of the screen
 */

extern _X_EXPORT void
RRSetCurrentConfig (ScreenPtr		pScreen,
		    Rotation		rotation,
		    int			rate,
		    RRScreenSizePtr	pSize);

extern _X_EXPORT Bool RRScreenInit (ScreenPtr pScreen);

extern _X_EXPORT Rotation
RRGetRotation (ScreenPtr pScreen);

#endif					

/* rrcrtc.c */

/*
 * Notify the CRTC of some change; layoutChanged indicates that
 * some position or size element changed
 */
extern _X_EXPORT void
RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged);

/*
 * Create a CRTC
 */
extern _X_EXPORT RRCrtcPtr
RRCrtcCreate (ScreenPtr pScreen, void	*devPrivate);

/*
 * Set the allowed rotations on a CRTC
 */
extern _X_EXPORT void
RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations);

/*
 * Set whether transforms are allowed on a CRTC
 */
extern _X_EXPORT void
RRCrtcSetTransformSupport (RRCrtcPtr crtc, Bool transforms);

/*
 * Notify the extension that the Crtc has been reconfigured,
 * the driver calls this whenever it has updated the mode
 */
extern _X_EXPORT Bool
RRCrtcNotify (RRCrtcPtr	    crtc,
	      RRModePtr	    mode,
	      int	    x,
	      int	    y,
	      Rotation	    rotation,
	      RRTransformPtr transform,
	      int	    numOutputs,
	      RROutputPtr   *outputs);

extern _X_EXPORT void
RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc);
    
/*
 * Request that the Crtc be reconfigured
 */
extern _X_EXPORT Bool
RRCrtcSet (RRCrtcPtr    crtc,
	   RRModePtr	mode,
	   int		x,
	   int		y,
	   Rotation	rotation,
	   int		numOutput,
	   RROutputPtr  *outputs);

/*
 * Request that the Crtc gamma be changed
 */

extern _X_EXPORT Bool
RRCrtcGammaSet (RRCrtcPtr   crtc,
		CARD16	    *red,
		CARD16	    *green,
		CARD16	    *blue);

/*
 * Request current gamma back from the DDX (if possible).
 * This includes gamma size.
 */
 
extern _X_EXPORT Bool
RRCrtcGammaGet(RRCrtcPtr crtc);

/*
 * Notify the extension that the Crtc gamma has been changed
 * The driver calls this whenever it has changed the gamma values
 * in the RRCrtcRec
 */

extern _X_EXPORT Bool
RRCrtcGammaNotify (RRCrtcPtr	crtc);

/*
 * Set the size of the gamma table at server startup time
 */

extern _X_EXPORT Bool
RRCrtcGammaSetSize (RRCrtcPtr	crtc,
		    int		size);

/*
 * Return the area of the frame buffer scanned out by the crtc,
 * taking into account the current mode and rotation
 */

extern _X_EXPORT void
RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height);

/*
 * Compute the complete transformation matrix including
 * client-specified transform, rotation/reflection values and the crtc 
 * offset.
 *
 * Return TRUE if the resulting transform is not a simple translation.
 */
extern _X_EXPORT Bool
RRTransformCompute (int			    x,
		    int			    y,
		    int			    width,
		    int			    height,
		    Rotation		    rotation,
		    RRTransformPtr	    rr_transform,

		    PictTransformPtr	    transform,
		    struct pict_f_transform *f_transform,
		    struct pict_f_transform *f_inverse);

/*
 * Return crtc transform
 */
extern _X_EXPORT RRTransformPtr
RRCrtcGetTransform (RRCrtcPtr crtc);

/*
 * Check whether the pending and current transforms are the same
 */
extern _X_EXPORT Bool
RRCrtcPendingTransform (RRCrtcPtr crtc);

/*
 * Destroy a Crtc at shutdown
 */
extern _X_EXPORT void
RRCrtcDestroy (RRCrtcPtr crtc);


/*
 * Set the pending CRTC transformation
 */

extern _X_EXPORT int
RRCrtcTransformSet (RRCrtcPtr		crtc,
		    PictTransformPtr	transform,
		    struct pict_f_transform *f_transform,
		    struct pict_f_transform *f_inverse,
		    char		*filter,
		    int			filter_len,
		    xFixed		*params,
		    int			nparams);

/*
 * Initialize crtc type
 */
extern _X_EXPORT Bool
RRCrtcInit (void);

/*
 * Initialize crtc type error value
 */
extern _X_EXPORT void
RRCrtcInitErrorValue (void);

/*
 * Crtc dispatch
 */

extern _X_EXPORT int
ProcRRGetCrtcInfo (ClientPtr client);

extern _X_EXPORT int
ProcRRSetCrtcConfig (ClientPtr client);

extern _X_EXPORT int
ProcRRGetCrtcGammaSize (ClientPtr client);

extern _X_EXPORT int
ProcRRGetCrtcGamma (ClientPtr client);

extern _X_EXPORT int
ProcRRSetCrtcGamma (ClientPtr client);

extern _X_EXPORT int
ProcRRSetCrtcTransform (ClientPtr client);

extern _X_EXPORT int
ProcRRGetCrtcTransform (ClientPtr client);

int
ProcRRGetPanning (ClientPtr client);

int
ProcRRSetPanning (ClientPtr client);

void
RRConstrainCursorHarder (DeviceIntPtr, ScreenPtr, int, int *, int *);

/* rrdispatch.c */
extern _X_EXPORT Bool
RRClientKnowsRates (ClientPtr	pClient);

/* rrmode.c */
/*
 * Find, and if necessary, create a mode
 */

extern _X_EXPORT RRModePtr
RRModeGet (xRRModeInfo	*modeInfo,
	   const char	*name);

/*
 * Destroy a mode.
 */

extern _X_EXPORT void
RRModeDestroy (RRModePtr mode);

/*
 * Return a list of modes that are valid for some output in pScreen
 */
extern _X_EXPORT RRModePtr *
RRModesForScreen (ScreenPtr pScreen, int *num_ret);
    
/*
 * Initialize mode type
 */
extern _X_EXPORT Bool
RRModeInit (void);

/*
 * Initialize mode type error value
 */
extern _X_EXPORT void
RRModeInitErrorValue (void);
    
extern _X_EXPORT int
ProcRRCreateMode (ClientPtr client);

extern _X_EXPORT int
ProcRRDestroyMode (ClientPtr client);

extern _X_EXPORT int
ProcRRAddOutputMode (ClientPtr client);

extern _X_EXPORT int
ProcRRDeleteOutputMode (ClientPtr client);

/* rroutput.c */

/*
 * Notify the output of some change. configChanged indicates whether
 * any external configuration (mode list, clones, connected status)
 * has changed, or whether the change was strictly internal
 * (which crtc is in use)
 */
extern _X_EXPORT void
RROutputChanged (RROutputPtr output, Bool configChanged);

/*
 * Create an output
 */

extern _X_EXPORT RROutputPtr
RROutputCreate (ScreenPtr   pScreen,
		const char  *name,
		int	    nameLength,
		void	    *devPrivate);

/*
 * Notify extension that output parameters have been changed
 */
extern _X_EXPORT Bool
RROutputSetClones (RROutputPtr  output,
		   RROutputPtr  *clones,
		   int		numClones);

extern _X_EXPORT Bool
RROutputSetModes (RROutputPtr	output,
		  RRModePtr	*modes,
		  int		numModes,
		  int		numPreferred);

extern _X_EXPORT int
RROutputAddUserMode (RROutputPtr    output,
		     RRModePtr	    mode);

extern _X_EXPORT int
RROutputDeleteUserMode (RROutputPtr output,
			RRModePtr   mode);

extern _X_EXPORT Bool
RROutputSetCrtcs (RROutputPtr	output,
		  RRCrtcPtr	*crtcs,
		  int		numCrtcs);

extern _X_EXPORT Bool
RROutputSetConnection (RROutputPtr  output,
		       CARD8	    connection);

extern _X_EXPORT Bool
RROutputSetSubpixelOrder (RROutputPtr output,
			  int	      subpixelOrder);

extern _X_EXPORT Bool
RROutputSetPhysicalSize (RROutputPtr	output,
			 int		mmWidth,
			 int		mmHeight);

extern _X_EXPORT void
RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output);

extern _X_EXPORT void
RROutputDestroy (RROutputPtr	output);

extern _X_EXPORT int
ProcRRGetOutputInfo (ClientPtr client);

extern _X_EXPORT int
ProcRRSetOutputPrimary (ClientPtr client);

extern _X_EXPORT int
ProcRRGetOutputPrimary (ClientPtr client);

/*
 * Initialize output type
 */
extern _X_EXPORT Bool
RROutputInit (void);

/*
 * Initialize output type error value
 */
extern _X_EXPORT void
RROutputInitErrorValue (void);
    
/* rrpointer.c */
extern _X_EXPORT void
RRPointerMoved (ScreenPtr pScreen, int x, int y);

extern _X_EXPORT void
RRPointerScreenConfigured (ScreenPtr pScreen);

/* rrproperty.c */

extern _X_EXPORT void
RRDeleteAllOutputProperties (RROutputPtr output);

extern _X_EXPORT RRPropertyValuePtr
RRGetOutputProperty (RROutputPtr output, Atom property, Bool pending);

extern _X_EXPORT RRPropertyPtr
RRQueryOutputProperty (RROutputPtr output, Atom property);
		       
extern _X_EXPORT void
RRDeleteOutputProperty (RROutputPtr output, Atom property);

extern _X_EXPORT Bool
RRPostPendingProperties (RROutputPtr output);
    
extern _X_EXPORT int
RRChangeOutputProperty (RROutputPtr output, Atom property, Atom type,
			int format, int mode, unsigned long len,
			pointer value, Bool sendevent, Bool pending);

extern _X_EXPORT int
RRConfigureOutputProperty (RROutputPtr output, Atom property,
			   Bool pending, Bool range, Bool immutable,
			   int num_values, INT32 *values);
extern _X_EXPORT int
ProcRRChangeOutputProperty (ClientPtr client);

extern _X_EXPORT int
ProcRRGetOutputProperty (ClientPtr client);

extern _X_EXPORT int
ProcRRListOutputProperties (ClientPtr client);

extern _X_EXPORT int
ProcRRQueryOutputProperty (ClientPtr client);

extern _X_EXPORT int
ProcRRConfigureOutputProperty (ClientPtr client);

extern _X_EXPORT int
ProcRRDeleteOutputProperty (ClientPtr client);

/* rrxinerama.c */
#ifdef XINERAMA
extern _X_EXPORT void
RRXineramaExtensionInit(void);
#endif

#endif /* _RANDRSTR_H_ */

/*
 
randr extension implementation structure

Query state:
    ProcRRGetScreenInfo/ProcRRGetScreenResources
	RRGetInfo
 
	    • Request configuration from driver, either 1.0 or 1.2 style
	    • These functions only record state changes, all
	      other actions are pended until RRTellChanged is called
 
	    ->rrGetInfo
	    1.0:
		RRRegisterSize
		RRRegisterRate
		RRSetCurrentConfig
	    1.2:
		RRScreenSetSizeRange
		RROutputSetCrtcs
		RRModeGet
		RROutputSetModes
		RROutputSetConnection
		RROutputSetSubpixelOrder
		RROutputSetClones
		RRCrtcNotify
 
	• Must delay scanning configuration until after ->rrGetInfo returns
	  because some drivers will call SetCurrentConfig in the middle
	  of the ->rrGetInfo operation.
 
	1.0:

	    • Scan old configuration, mirror to new structures
 
	    RRScanOldConfig
		RRCrtcCreate
		RROutputCreate
		RROutputSetCrtcs
		RROutputSetConnection
		RROutputSetSubpixelOrder
		RROldModeAdd	• This adds modes one-at-a-time
		    RRModeGet
		RRCrtcNotify
 
	• send events, reset pointer if necessary
 
	RRTellChanged
	    WalkTree (sending events)
 
	    • when layout has changed:
		RRPointerScreenConfigured
		RRSendConfigNotify
 
Asynchronous state setting (1.2 only)
    When setting state asynchronously, the driver invokes the
    ->rrGetInfo function and then calls RRTellChanged to flush
    the changes to the clients and reset pointer if necessary

Set state

    ProcRRSetScreenConfig
	RRCrtcSet
	    1.2:
		->rrCrtcSet
		    RRCrtcNotify
	    1.0:
		->rrSetConfig
		RRCrtcNotify
	    RRTellChanged
 */
/*
 * Copyright © 2006 Keith Packard
 * Copyright 2010 Red Hat, Inc
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"
#include "swaprep.h"
#include "mipointer.h"

RESTYPE	RRCrtcType;

/*
 * Notify the CRTC of some change
 */
void
RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged)
{
    ScreenPtr	pScreen = crtc->pScreen;

    crtc->changed = TRUE;
    if (pScreen)
    {
	rrScrPriv(pScreen);
    
	pScrPriv->changed = TRUE;
	/*
	 * Send ConfigureNotify on any layout change
	 */
	if (layoutChanged)
	    pScrPriv->layoutChanged = TRUE;
    }
}

/*
 * Create a CRTC
 */
RRCrtcPtr
RRCrtcCreate (ScreenPtr pScreen, void *devPrivate)
{
    RRCrtcPtr	    crtc;
    RRCrtcPtr	    *crtcs;
    rrScrPrivPtr    pScrPriv;

    if (!RRInit())
	return NULL;
    
    pScrPriv = rrGetScrPriv(pScreen);

    /* make space for the crtc pointer */
    if (pScrPriv->numCrtcs)
	crtcs = realloc(pScrPriv->crtcs, 
			  (pScrPriv->numCrtcs + 1) * sizeof (RRCrtcPtr));
    else
	crtcs = malloc(sizeof (RRCrtcPtr));
    if (!crtcs)
	return FALSE;
    pScrPriv->crtcs = crtcs;
    
    crtc = calloc(1, sizeof (RRCrtcRec));
    if (!crtc)
	return NULL;
    crtc->id = FakeClientID (0);
    crtc->pScreen = pScreen;
    crtc->mode = NULL;
    crtc->x = 0;
    crtc->y = 0;
    crtc->rotation = RR_Rotate_0;
    crtc->rotations = RR_Rotate_0;
    crtc->outputs = NULL;
    crtc->numOutputs = 0;
    crtc->gammaSize = 0;
    crtc->gammaRed = crtc->gammaBlue = crtc->gammaGreen = NULL;
    crtc->changed = FALSE;
    crtc->devPrivate = devPrivate;
    RRTransformInit (&crtc->client_pending_transform);
    RRTransformInit (&crtc->client_current_transform);
    pixman_transform_init_identity (&crtc->transform);
    pixman_f_transform_init_identity (&crtc->f_transform);
    pixman_f_transform_init_identity (&crtc->f_inverse);

    if (!AddResource (crtc->id, RRCrtcType, (pointer) crtc))
	return NULL;

    /* attach the screen and crtc together */
    crtc->pScreen = pScreen;
    pScrPriv->crtcs[pScrPriv->numCrtcs++] = crtc;
    
    return crtc;
}

/*
 * Set the allowed rotations on a CRTC
 */
void
RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations)
{
    crtc->rotations = rotations;
}

/*
 * Set whether transforms are allowed on a CRTC
 */
void
RRCrtcSetTransformSupport (RRCrtcPtr crtc, Bool transforms)
{
    crtc->transforms = transforms;
}

/*
 * Notify the extension that the Crtc has been reconfigured,
 * the driver calls this whenever it has updated the mode
 */
Bool
RRCrtcNotify (RRCrtcPtr	    crtc,
	      RRModePtr	    mode,
	      int	    x,
	      int	    y,
	      Rotation	    rotation,
	      RRTransformPtr transform,
	      int	    numOutputs,
	      RROutputPtr   *outputs)
{
    int	    i, j;
    
    /*
     * Check to see if any of the new outputs were
     * not in the old list and mark them as changed
     */
    for (i = 0; i < numOutputs; i++)
    {
	for (j = 0; j < crtc->numOutputs; j++)
	    if (outputs[i] == crtc->outputs[j])
		break;
	if (j == crtc->numOutputs)
	{
	    outputs[i]->crtc = crtc;
	    RROutputChanged (outputs[i], FALSE);
	    RRCrtcChanged (crtc, FALSE);
	}
    }
    /*
     * Check to see if any of the old outputs are
     * not in the new list and mark them as changed
     */
    for (j = 0; j < crtc->numOutputs; j++)
    {
	for (i = 0; i < numOutputs; i++)
	    if (outputs[i] == crtc->outputs[j])
		break;
	if (i == numOutputs)
	{
	    if (crtc->outputs[j]->crtc == crtc)
		crtc->outputs[j]->crtc = NULL;
	    RROutputChanged (crtc->outputs[j], FALSE);
	    RRCrtcChanged (crtc, FALSE);
	}
    }
    /*
     * Reallocate the crtc output array if necessary
     */
    if (numOutputs != crtc->numOutputs)
    {
	RROutputPtr *newoutputs;
	
	if (numOutputs)
	{
	    if (crtc->numOutputs)
		newoutputs = realloc(crtc->outputs,
				    numOutputs * sizeof (RROutputPtr));
	    else
		newoutputs = malloc(numOutputs * sizeof (RROutputPtr));
	    if (!newoutputs)
		return FALSE;
	}
	else
	{
	    free(crtc->outputs);
	    newoutputs = NULL;
	}
	crtc->outputs = newoutputs;
	crtc->numOutputs = numOutputs;
    }
    /*
     * Copy the new list of outputs into the crtc
     */
    memcpy (crtc->outputs, outputs, numOutputs * sizeof (RROutputPtr));
    /*
     * Update remaining crtc fields
     */
    if (mode != crtc->mode)
    {
	if (crtc->mode)
	    RRModeDestroy (crtc->mode);
	crtc->mode = mode;
	if (mode != NULL)
	    mode->refcnt++;
	RRCrtcChanged (crtc, TRUE);
    }
    if (x != crtc->x)
    {
	crtc->x = x;
	RRCrtcChanged (crtc, TRUE);
    }
    if (y != crtc->y)
    {
	crtc->y = y;
	RRCrtcChanged (crtc, TRUE);
    }
    if (rotation != crtc->rotation)
    {
	crtc->rotation = rotation;
	RRCrtcChanged (crtc, TRUE);
    }
    if (!RRTransformEqual (transform, &crtc->client_current_transform)) {
	RRTransformCopy (&crtc->client_current_transform, transform);
	RRCrtcChanged (crtc, TRUE);
    }
    if (crtc->changed && mode)
    {
	RRTransformCompute (x, y,
			    mode->mode.width, mode->mode.height,
			    rotation,
			    &crtc->client_current_transform,
			    &crtc->transform, &crtc->f_transform,
			    &crtc->f_inverse);
    }
    return TRUE;
}

void
RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    rrScrPriv (pScreen);
    xRRCrtcChangeNotifyEvent	ce;
    RRModePtr	mode = crtc->mode;
    
    ce.type = RRNotify + RREventBase;
    ce.subCode = RRNotify_CrtcChange;
    ce.timestamp = pScrPriv->lastSetTime.milliseconds;
    ce.window = pWin->drawable.id;
    ce.crtc = crtc->id;
    ce.rotation = crtc->rotation;
    if (mode)
    {
	ce.mode = mode->mode.id;
	ce.x = crtc->x;
	ce.y = crtc->y;
	ce.width = mode->mode.width;
	ce.height = mode->mode.height;
    }
    else
    {
	ce.mode = None;
	ce.x = 0;
	ce.y = 0;
	ce.width = 0;
	ce.height = 0;
    }
    WriteEventsToClient (client, 1, (xEvent *) &ce);
}

static Bool
RRCrtcPendingProperties (RRCrtcPtr crtc)
{
    ScreenPtr	pScreen = crtc->pScreen;
    rrScrPriv(pScreen);
    int		o;

    for (o = 0; o < pScrPriv->numOutputs; o++)
    {
	RROutputPtr output = pScrPriv->outputs[o];
	if (output->crtc == crtc && output->pendingProperties)
	    return TRUE;
    }
    return FALSE;
}

static void
crtc_bounds(RRCrtcPtr crtc, int *left, int *right, int *top, int *bottom)
{
    *left = crtc->x;
    *top = crtc->y;

    switch (crtc->rotation) {
    case RR_Rotate_0:
    case RR_Rotate_180:
    default:
       *right = crtc->x + crtc->mode->mode.width;
       *bottom = crtc->y + crtc->mode->mode.height;
       return;
    case RR_Rotate_90:
    case RR_Rotate_270:
       *right = crtc->x + crtc->mode->mode.height;
       *bottom = crtc->y + crtc->mode->mode.width;
       return;
    }
}

/* overlapping counts as adjacent */
static Bool
crtcs_adjacent(const RRCrtcPtr a, const RRCrtcPtr b)
{
    /* left, right, top, bottom... */
    int al, ar, at, ab;
    int bl, br, bt, bb;
    int cl, cr, ct, cb; /* the overlap, if any */

    crtc_bounds(a, &al, &ar, &at, &ab);
    crtc_bounds(b, &bl, &br, &bt, &bb);

    cl = max(al, bl);
    cr = min(ar, br);
    ct = max(at, bt);
    cb = min(ab, bb);

    return (cl <= cr) && (ct <= cb);
}

/* Depth-first search and mark all CRTCs reachable from cur */
static void
mark_crtcs (rrScrPrivPtr pScrPriv, int *reachable, int cur)
{
    int i;
    reachable[cur] = TRUE;
    for (i = 0; i < pScrPriv->numCrtcs; ++i) {
        if (reachable[i] || !pScrPriv->crtcs[i]->mode)
            continue;
        if (crtcs_adjacent(pScrPriv->crtcs[cur], pScrPriv->crtcs[i]))
            mark_crtcs(pScrPriv, reachable, i);
    }
}

static void
RRComputeContiguity (ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    Bool discontiguous = TRUE;
    int i, n = pScrPriv->numCrtcs;

    int *reachable = calloc(n, sizeof(int));
    if (!reachable)
        goto out;

    /* Find first enabled CRTC and start search for reachable CRTCs from it */
    for (i = 0; i < n; ++i) {
        if (pScrPriv->crtcs[i]->mode) {
            mark_crtcs(pScrPriv, reachable, i);
            break;
        }
    }

    /* Check that all enabled CRTCs were marked as reachable */
    for (i = 0; i < n; ++i)
        if (pScrPriv->crtcs[i]->mode && !reachable[i])
            goto out;

    discontiguous = FALSE;

out:
    free(reachable);
    pScrPriv->discontiguous = discontiguous;
}

/*
 * Request that the Crtc be reconfigured
 */
Bool
RRCrtcSet (RRCrtcPtr    crtc,
	   RRModePtr	mode,
	   int		x,
	   int		y,
	   Rotation	rotation,
	   int		numOutputs,
	   RROutputPtr  *outputs)
{
    ScreenPtr	pScreen = crtc->pScreen;
    Bool	ret = FALSE;
    Bool	recompute = TRUE;
    rrScrPriv(pScreen);

    /* See if nothing changed */
    if (crtc->mode == mode &&
	crtc->x == x &&
	crtc->y == y &&
	crtc->rotation == rotation &&
	crtc->numOutputs == numOutputs &&
	!memcmp (crtc->outputs, outputs, numOutputs * sizeof (RROutputPtr)) &&
	!RRCrtcPendingProperties (crtc) &&
	!RRCrtcPendingTransform (crtc))
    {
	recompute = FALSE;
	ret = TRUE;
    }
    else
    {
#if RANDR_12_INTERFACE
	if (pScrPriv->rrCrtcSet)
	{
	    ret = (*pScrPriv->rrCrtcSet) (pScreen, crtc, mode, x, y, 
					  rotation, numOutputs, outputs);
	}
	else
#endif
	{
#if RANDR_10_INTERFACE
	    if (pScrPriv->rrSetConfig)
	    {
		RRScreenSize	    size;
		RRScreenRate	    rate;

		if (!mode)
		{
		    RRCrtcNotify (crtc, NULL, x, y, rotation, NULL, 0, NULL);
		    ret = TRUE;
		}
		else
		{
		    size.width = mode->mode.width;
		    size.height = mode->mode.height;
		    if (outputs[0]->mmWidth && outputs[0]->mmHeight)
		    {
			size.mmWidth = outputs[0]->mmWidth;
			size.mmHeight = outputs[0]->mmHeight;
		    }
		    else
		    {
			size.mmWidth = pScreen->mmWidth;
			size.mmHeight = pScreen->mmHeight;
		    }
		    size.nRates = 1;
		    rate.rate = RRVerticalRefresh (&mode->mode);
		    size.pRates = &rate;
		    ret = (*pScrPriv->rrSetConfig) (pScreen, rotation, rate.rate, &size);
		    /*
		     * Old 1.0 interface tied screen size to mode size
		     */
		    if (ret)
		    {
			RRCrtcNotify (crtc, mode, x, y, rotation, NULL, 1, outputs);
			RRScreenSizeNotify (pScreen);
		    }
		}
	    }
#endif
	}
	if (ret)
	{
	    int	o;
	    RRTellChanged (pScreen);

	    for (o = 0; o < numOutputs; o++)
		RRPostPendingProperties (outputs[o]);
	}
    }

    if (recompute)
       RRComputeContiguity(pScreen);

    return ret;
}

/*
 * Return crtc transform
 */
RRTransformPtr
RRCrtcGetTransform (RRCrtcPtr crtc)
{
    RRTransformPtr  transform = &crtc->client_pending_transform;

    if (pixman_transform_is_identity (&transform->transform))
	return NULL;
    return transform;
}

/*
 * Check whether the pending and current transforms are the same
 */
Bool
RRCrtcPendingTransform (RRCrtcPtr crtc)
{
    return memcmp (&crtc->client_current_transform.transform,
		   &crtc->client_pending_transform.transform,
		   sizeof (PictTransform)) != 0;
}

/*
 * Destroy a Crtc at shutdown
 */
void
RRCrtcDestroy (RRCrtcPtr crtc)
{
    FreeResource (crtc->id, 0);
}

static int
RRCrtcDestroyResource (pointer value, XID pid)
{
    RRCrtcPtr	crtc = (RRCrtcPtr) value;
    ScreenPtr	pScreen = crtc->pScreen;

    if (pScreen)
    {
	rrScrPriv(pScreen);
	int		i;
    
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	{
	    if (pScrPriv->crtcs[i] == crtc)
	    {
		memmove (pScrPriv->crtcs + i, pScrPriv->crtcs + i + 1,
			 (pScrPriv->numCrtcs - (i + 1)) * sizeof (RRCrtcPtr));
		--pScrPriv->numCrtcs;
		break;
	    }
	}
    }
    free(crtc->gammaRed);
    if (crtc->mode)
	RRModeDestroy (crtc->mode);
    free(crtc);
    return 1;
}

/*
 * Request that the Crtc gamma be changed
 */

Bool
RRCrtcGammaSet (RRCrtcPtr   crtc,
		CARD16	    *red,
		CARD16	    *green,
		CARD16	    *blue)
{
    Bool	ret = TRUE;
#if RANDR_12_INTERFACE
    ScreenPtr	pScreen = crtc->pScreen;
#endif
    
    memcpy (crtc->gammaRed, red, crtc->gammaSize * sizeof (CARD16));
    memcpy (crtc->gammaGreen, green, crtc->gammaSize * sizeof (CARD16));
    memcpy (crtc->gammaBlue, blue, crtc->gammaSize * sizeof (CARD16));
#if RANDR_12_INTERFACE
    if (pScreen)
    {
	rrScrPriv(pScreen);
	if (pScrPriv->rrCrtcSetGamma)
	    ret = (*pScrPriv->rrCrtcSetGamma) (pScreen, crtc);
    }
#endif
    return ret;
}

/*
 * Request current gamma back from the DDX (if possible).
 * This includes gamma size.
 */
Bool
RRCrtcGammaGet(RRCrtcPtr crtc)
{
    Bool ret = TRUE;
#if RANDR_12_INTERFACE
    ScreenPtr	pScreen = crtc->pScreen;
#endif

#if RANDR_12_INTERFACE
    if (pScreen)
    {
        rrScrPriv(pScreen);
        if (pScrPriv->rrCrtcGetGamma)
            ret = (*pScrPriv->rrCrtcGetGamma) (pScreen, crtc);
    }
#endif
    return ret;
}

/*
 * Notify the extension that the Crtc gamma has been changed
 * The driver calls this whenever it has changed the gamma values
 * in the RRCrtcRec
 */

Bool
RRCrtcGammaNotify (RRCrtcPtr	crtc)
{
    return TRUE;    /* not much going on here */
}

static void
RRModeGetScanoutSize (RRModePtr mode, PictTransformPtr transform,
		      int *width, int *height)
{
    BoxRec  box;

    if (mode == NULL) {
	*width = 0;
	*height = 0;
	return;
    }

    box.x1 = 0;
    box.y1 = 0;
    box.x2 = mode->mode.width;
    box.y2 = mode->mode.height;

    pixman_transform_bounds (transform, &box);
    *width = box.x2 - box.x1;
    *height = box.y2 - box.y1;
}

/**
 * Returns the width/height that the crtc scans out from the framebuffer
 */
void
RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height)
{
    RRModeGetScanoutSize (crtc->mode, &crtc->transform, width, height);
}

/*
 * Set the size of the gamma table at server startup time
 */

Bool
RRCrtcGammaSetSize (RRCrtcPtr	crtc,
		    int		size)
{
    CARD16  *gamma;

    if (size == crtc->gammaSize)
	return TRUE;
    if (size)
    {
	gamma = malloc(size * 3 * sizeof (CARD16));
	if (!gamma)
	    return FALSE;
    }
    else
	gamma = NULL;
    free(crtc->gammaRed);
    crtc->gammaRed = gamma;
    crtc->gammaGreen = gamma + size;
    crtc->gammaBlue = gamma + size*2;
    crtc->gammaSize = size;
    return TRUE;
}

/*
 * Set the pending CRTC transformation
 */

int
RRCrtcTransformSet (RRCrtcPtr		crtc,
		    PictTransformPtr	transform,
		    struct pixman_f_transform *f_transform,
		    struct pixman_f_transform *f_inverse,
		    char		*filter_name,
		    int			filter_len,
		    xFixed		*params,
		    int			nparams)
{
    PictFilterPtr   filter = NULL;
    int		    width = 0, height = 0;

    if (!crtc->transforms)
	return BadValue;

    if (filter_len)
    {
	filter = PictureFindFilter (crtc->pScreen,
				    filter_name,
				    filter_len);
	if (!filter)
	    return BadName;
	if (filter->ValidateParams)
	{
	    if (!filter->ValidateParams (crtc->pScreen, filter->id,
					 params, nparams, &width, &height))
		return BadMatch;
	}
	else {
	    width = filter->width;
	    height = filter->height;
	}
    }
    else
    {
	if (nparams)
	    return BadMatch;
    }
    if (!RRTransformSetFilter (&crtc->client_pending_transform,
			       filter, params, nparams, width, height))
	return BadAlloc;

    crtc->client_pending_transform.transform = *transform;
    crtc->client_pending_transform.f_transform = *f_transform;
    crtc->client_pending_transform.f_inverse = *f_inverse;
    return Success;
}

/*
 * Initialize crtc type
 */
Bool
RRCrtcInit (void)
{
    RRCrtcType = CreateNewResourceType (RRCrtcDestroyResource, "CRTC");
    if (!RRCrtcType)
	return FALSE;
    
    return TRUE;
}

/*
 * Initialize crtc type error value
 */
void
RRCrtcInitErrorValue(void)
{
    SetResourceTypeErrorValue(RRCrtcType, RRErrorBase + BadRRCrtc);
}

int
ProcRRGetCrtcInfo (ClientPtr client)
{
    REQUEST(xRRGetCrtcInfoReq);
    xRRGetCrtcInfoReply	rep;
    RRCrtcPtr			crtc;
    CARD8			*extra;
    unsigned long		extraLen;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    RRModePtr			mode;
    RROutput			*outputs;
    RROutput			*possible;
    int				i, j, k, n;
    int				width, height;
    BoxRec			panned_area;
    
    REQUEST_SIZE_MATCH(xRRGetCrtcInfoReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* All crtcs must be associated with screens before client
     * requests are processed
     */
    pScreen = crtc->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    mode = crtc->mode;
    
    rep.type = X_Reply;
    rep.status = RRSetConfigSuccess;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.timestamp = pScrPriv->lastSetTime.milliseconds;
    if (pScrPriv->rrGetPanning &&
	pScrPriv->rrGetPanning (pScreen, crtc, &panned_area, NULL, NULL) &&
	(panned_area.x2 > panned_area.x1) && (panned_area.y2 > panned_area.y1))
    {
 	rep.x = panned_area.x1;
	rep.y = panned_area.y1;
	rep.width = panned_area.x2 - panned_area.x1;
	rep.height = panned_area.y2 - panned_area.y1;
    }
    else
    {
	RRCrtcGetScanoutSize (crtc, &width, &height);
	rep.x = crtc->x;
	rep.y = crtc->y;
	rep.width = width;
	rep.height = height;
    }
    rep.mode = mode ? mode->mode.id : 0;
    rep.rotation = crtc->rotation;
    rep.rotations = crtc->rotations;
    rep.nOutput = crtc->numOutputs;
    k = 0;
    for (i = 0; i < pScrPriv->numOutputs; i++)
	for (j = 0; j < pScrPriv->outputs[i]->numCrtcs; j++)
	    if (pScrPriv->outputs[i]->crtcs[j] == crtc)
		k++;
    rep.nPossibleOutput = k;
    
    rep.length = rep.nOutput + rep.nPossibleOutput;

    extraLen = rep.length << 2;
    if (extraLen)
    {
	extra = malloc(extraLen);
	if (!extra)
	    return BadAlloc;
    }
    else
	extra = NULL;

    outputs = (RROutput *) extra;
    possible = (RROutput *) (outputs + rep.nOutput);
    
    for (i = 0; i < crtc->numOutputs; i++)
    {
	outputs[i] = crtc->outputs[i]->id;
	if (client->swapped)
	    swapl (&outputs[i], n);
    }
    k = 0;
    for (i = 0; i < pScrPriv->numOutputs; i++)
	for (j = 0; j < pScrPriv->outputs[i]->numCrtcs; j++)
	    if (pScrPriv->outputs[i]->crtcs[j] == crtc)
	    {
		possible[k] = pScrPriv->outputs[i]->id;
		if (client->swapped)
		    swapl (&possible[k], n);
		k++;
	    }
    
    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swaps(&rep.x, n);
	swaps(&rep.y, n);
	swaps(&rep.width, n);
	swaps(&rep.height, n);
	swapl(&rep.mode, n);
	swaps(&rep.rotation, n);
	swaps(&rep.rotations, n);
	swaps(&rep.nOutput, n);
	swaps(&rep.nPossibleOutput, n);
    }
    WriteToClient(client, sizeof(xRRGetCrtcInfoReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	free(extra);
    }
    
    return Success;
}

int
ProcRRSetCrtcConfig (ClientPtr client)
{
    REQUEST(xRRSetCrtcConfigReq);
    xRRSetCrtcConfigReply   rep;
    ScreenPtr		    pScreen;
    rrScrPrivPtr	    pScrPriv;
    RRCrtcPtr		    crtc;
    RRModePtr		    mode;
    int			    numOutputs;
    RROutputPtr		    *outputs = NULL;
    RROutput		    *outputIds;
    TimeStamp		    configTime;
    TimeStamp		    time;
    Rotation		    rotation;
    int			    rc, i, j;
    
    REQUEST_AT_LEAST_SIZE(xRRSetCrtcConfigReq);
    numOutputs = (stuff->length - bytes_to_int32(SIZEOF (xRRSetCrtcConfigReq)));
    
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixSetAttrAccess);

    if (stuff->mode == None)
    {
	mode = NULL;
	if (numOutputs > 0)
	    return BadMatch;
    }
    else
    {
	VERIFY_RR_MODE(stuff->mode, mode, DixSetAttrAccess);
	if (numOutputs == 0)
	    return BadMatch;
    }
    if (numOutputs)
    {
	outputs = malloc(numOutputs * sizeof (RROutputPtr));
	if (!outputs)
	    return BadAlloc;
    }
    else
	outputs = NULL;
    
    outputIds = (RROutput *) (stuff + 1);
    for (i = 0; i < numOutputs; i++)
    {
	rc = dixLookupResourceByType((pointer *)(outputs + i), outputIds[i],
				     RROutputType, client, DixSetAttrAccess);
	if (rc != Success)
	{
	    free(outputs);
	    return rc;
	}
	/* validate crtc for this output */
	for (j = 0; j < outputs[i]->numCrtcs; j++)
	    if (outputs[i]->crtcs[j] == crtc)
		break;
	if (j == outputs[i]->numCrtcs)
	{
	    free(outputs);
	    return BadMatch;
	}
	/* validate mode for this output */
	for (j = 0; j < outputs[i]->numModes + outputs[i]->numUserModes; j++)
	{
	    RRModePtr	m = (j < outputs[i]->numModes ? 
			     outputs[i]->modes[j] :
			     outputs[i]->userModes[j - outputs[i]->numModes]);
	    if (m == mode)
		break;
	}
	if (j == outputs[i]->numModes + outputs[i]->numUserModes)
	{
	    free(outputs);
	    return BadMatch;
	}
    }
    /* validate clones */
    for (i = 0; i < numOutputs; i++)
    {
	for (j = 0; j < numOutputs; j++)
	{
	    int k;
	    if (i == j)
		continue;
	    for (k = 0; k < outputs[i]->numClones; k++)
	    {
		if (outputs[i]->clones[k] == outputs[j])
		    break;
	    }
	    if (k == outputs[i]->numClones)
	    {
		free(outputs);
		return BadMatch;
	    }
	}
    }

    pScreen = crtc->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    
    time = ClientTimeToServerTime(stuff->timestamp);
    configTime = ClientTimeToServerTime(stuff->configTimestamp);
    
    if (!pScrPriv)
    {
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
    }
    
    /*
     * Validate requested rotation
     */
    rotation = (Rotation) stuff->rotation;

    /* test the rotation bits only! */
    switch (rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_90:
    case RR_Rotate_180:
    case RR_Rotate_270:
	break;
    default:
	/*
	 * Invalid rotation
	 */
	client->errorValue = stuff->rotation;
	free(outputs);
	return BadValue;
    }

    if (mode)
    {
	if ((~crtc->rotations) & rotation)
	{
	    /*
	     * requested rotation or reflection not supported by screen
	     */
	    client->errorValue = stuff->rotation;
	    free(outputs);
	    return BadMatch;
	}
    
#ifdef RANDR_12_INTERFACE
	/*
	 * Check screen size bounds if the DDX provides a 1.2 interface
	 * for setting screen size. Else, assume the CrtcSet sets
	 * the size along with the mode. If the driver supports transforms,
	 * then it must allow crtcs to display a subset of the screen, so
	 * only do this check for drivers without transform support.
	 */
	if (pScrPriv->rrScreenSetSize && !crtc->transforms)
	{
	    int source_width;
	    int	source_height;
	    PictTransform transform;
	    struct pixman_f_transform f_transform, f_inverse;

	    RRTransformCompute (stuff->x, stuff->y,
				mode->mode.width, mode->mode.height,
				rotation,
				&crtc->client_pending_transform,
				&transform, &f_transform, &f_inverse);

	    RRModeGetScanoutSize (mode, &transform, &source_width, &source_height);
	    if (stuff->x + source_width > pScreen->width)
	    {
		client->errorValue = stuff->x;
		free(outputs);
		return BadValue;
	    }
	    
	    if (stuff->y + source_height > pScreen->height)
	    {
		client->errorValue = stuff->y;
		free(outputs);
		return BadValue;
	    }
	}
#endif
    }
    
    if (!RRCrtcSet (crtc, mode, stuff->x, stuff->y,
		   rotation, numOutputs, outputs))
    {
	rep.status = RRSetConfigFailed;
	goto sendReply;
    }
    rep.status = RRSetConfigSuccess;
    pScrPriv->lastSetTime = time;
    
sendReply:
    free(outputs);
    
    rep.type = X_Reply;
    /* rep.status has already been filled in */
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.newTimestamp = pScrPriv->lastSetTime.milliseconds;

    if (client->swapped) 
    {
	int n;
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.newTimestamp, n);
    }
    WriteToClient(client, sizeof(xRRSetCrtcConfigReply), (char *)&rep);
    
    return Success;
}

int
ProcRRGetPanning (ClientPtr client)
{
    REQUEST(xRRGetPanningReq);
    xRRGetPanningReply	rep;
    RRCrtcPtr		crtc;
    ScreenPtr		pScreen;
    rrScrPrivPtr	pScrPriv;
    BoxRec		total;
    BoxRec		tracking;
    INT16		border[4];
    int			n;
    
    REQUEST_SIZE_MATCH(xRRGetPanningReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* All crtcs must be associated with screens before client
     * requests are processed
     */
    pScreen = crtc->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    if (!pScrPriv)
	return RRErrorBase + BadRRCrtc;

    memset(&rep, 0, sizeof(rep));
    rep.type = X_Reply;
    rep.status = RRSetConfigSuccess;
    rep.sequenceNumber = client->sequence;
    rep.length = 1;
    rep.timestamp = pScrPriv->lastSetTime.milliseconds;

    if (pScrPriv->rrGetPanning &&
	pScrPriv->rrGetPanning (pScreen, crtc, &total, &tracking, border)) {
	rep.left          = total.x1;
	rep.top           = total.y1;
	rep.width         = total.x2 - total.x1;
	rep.height        = total.y2 - total.y1;
	rep.track_left    = tracking.x1;
	rep.track_top     = tracking.y1;
	rep.track_width   = tracking.x2 - tracking.x1;
	rep.track_height  = tracking.y2 - tracking.y1;
	rep.border_left   = border[0];
	rep.border_top    = border[1];
	rep.border_right  = border[2];
	rep.border_bottom = border[3];
    }

    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swaps(&rep.timestamp, n);
	swaps(&rep.left, n);
	swaps(&rep.top, n);
	swaps(&rep.width, n);
	swaps(&rep.height, n);
	swaps(&rep.track_left, n);
	swaps(&rep.track_top, n);
	swaps(&rep.track_width, n);
	swaps(&rep.track_height, n);
	swaps(&rep.border_left, n);
	swaps(&rep.border_top, n);
	swaps(&rep.border_right, n);
	swaps(&rep.border_bottom, n);
    }
    WriteToClient(client, sizeof(xRRGetPanningReply), (char *)&rep);
    return Success;
}

int
ProcRRSetPanning (ClientPtr client)
{
    REQUEST(xRRSetPanningReq);
    xRRSetPanningReply	rep;
    RRCrtcPtr		crtc;
    ScreenPtr		pScreen;
    rrScrPrivPtr	pScrPriv;
    TimeStamp		time;
    BoxRec		total;
    BoxRec		tracking;
    INT16		border[4];
    int			n;
    
    REQUEST_SIZE_MATCH(xRRSetPanningReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* All crtcs must be associated with screens before client
     * requests are processed
     */
    pScreen = crtc->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    if (!pScrPriv) {
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
    }
    
    time = ClientTimeToServerTime(stuff->timestamp);
    
    if (!pScrPriv->rrGetPanning)
	return RRErrorBase + BadRRCrtc;

    total.x1    = stuff->left;
    total.y1    = stuff->top;
    total.x2    = total.x1 + stuff->width;
    total.y2    = total.y1 + stuff->height;
    tracking.x1 = stuff->track_left;
    tracking.y1 = stuff->track_top;
    tracking.x2 = tracking.x1 + stuff->track_width;
    tracking.y2 = tracking.y1 + stuff->track_height;
    border[0]   = stuff->border_left;
    border[1]   = stuff->border_top;
    border[2]   = stuff->border_right;
    border[3]   = stuff->border_bottom;

    if (! pScrPriv->rrSetPanning (pScreen, crtc, &total, &tracking, border))
	return BadMatch;

    pScrPriv->lastSetTime = time;

    rep.status = RRSetConfigSuccess;

sendReply:
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.newTimestamp = pScrPriv->lastSetTime.milliseconds;

    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swaps(&rep.newTimestamp, n);
    }
    WriteToClient(client, sizeof(xRRSetPanningReply), (char *)&rep);
    return Success;
}

int
ProcRRGetCrtcGammaSize (ClientPtr client)
{
    REQUEST(xRRGetCrtcGammaSizeReq);
    xRRGetCrtcGammaSizeReply	reply;
    RRCrtcPtr			crtc;
    int				n;

    REQUEST_SIZE_MATCH(xRRGetCrtcGammaSizeReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* Gamma retrieval failed, any better error? */
    if (!RRCrtcGammaGet(crtc))
        return RRErrorBase + BadRRCrtc;

    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = 0;
    reply.size = crtc->gammaSize;
    if (client->swapped) {
	swaps (&reply.sequenceNumber, n);
	swapl (&reply.length, n);
	swaps (&reply.size, n);
    }
    WriteToClient (client, sizeof (xRRGetCrtcGammaSizeReply), (char *) &reply);
    return Success;
}

int
ProcRRGetCrtcGamma (ClientPtr client)
{
    REQUEST(xRRGetCrtcGammaReq);
    xRRGetCrtcGammaReply	reply;
    RRCrtcPtr			crtc;
    int				n;
    unsigned long		len;
    char			*extra = NULL;
    
    REQUEST_SIZE_MATCH(xRRGetCrtcGammaReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* Gamma retrieval failed, any better error? */
    if (!RRCrtcGammaGet(crtc))
        return RRErrorBase + BadRRCrtc;

    len = crtc->gammaSize * 3 * 2;
    
    if (crtc->gammaSize) {
	extra = malloc(len);
	if (!extra)
	    return BadAlloc;
    }

    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = bytes_to_int32(len);
    reply.size = crtc->gammaSize;
    if (client->swapped) {
	swaps (&reply.sequenceNumber, n);
	swapl (&reply.length, n);
	swaps (&reply.size, n);
    }
    WriteToClient (client, sizeof (xRRGetCrtcGammaReply), (char *) &reply);
    if (crtc->gammaSize)
    {
	memcpy(extra, crtc->gammaRed, len);
	client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write;
	WriteSwappedDataToClient (client, len, extra);
	free(extra);
    }
    return Success;
}

int
ProcRRSetCrtcGamma (ClientPtr client)
{
    REQUEST(xRRSetCrtcGammaReq);
    RRCrtcPtr			crtc;
    unsigned long		len;
    CARD16			*red, *green, *blue;
    
    REQUEST_AT_LEAST_SIZE(xRRSetCrtcGammaReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);
    
    len = client->req_len - bytes_to_int32(sizeof (xRRSetCrtcGammaReq));
    if (len < (stuff->size * 3 + 1) >> 1)
	return BadLength;

    if (stuff->size != crtc->gammaSize)
	return BadMatch;
    
    red = (CARD16 *) (stuff + 1);
    green = red + crtc->gammaSize;
    blue = green + crtc->gammaSize;
    
    RRCrtcGammaSet (crtc, red, green, blue);

    return Success;
}

/* Version 1.3 additions */

int
ProcRRSetCrtcTransform (ClientPtr client)
{
    REQUEST(xRRSetCrtcTransformReq);
    RRCrtcPtr		    crtc;
    PictTransform	    transform;
    struct pixman_f_transform f_transform, f_inverse;
    char		    *filter;
    int			    nbytes;
    xFixed		    *params;
    int			    nparams;

    REQUEST_AT_LEAST_SIZE(xRRSetCrtcTransformReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    PictTransform_from_xRenderTransform (&transform, &stuff->transform);
    pixman_f_transform_from_pixman_transform (&f_transform, &transform);
    if (!pixman_f_transform_invert (&f_inverse, &f_transform))
	return BadMatch;

    filter = (char *) (stuff + 1);
    nbytes = stuff->nbytesFilter;
    params = (xFixed *) (filter + pad_to_int32(nbytes));
    nparams = ((xFixed *) stuff + client->req_len) - params;
    if (nparams < 0)
	return BadLength;

    return RRCrtcTransformSet (crtc, &transform, &f_transform, &f_inverse,
			       filter, nbytes, params, nparams);
}


#define CrtcTransformExtra	(SIZEOF(xRRGetCrtcTransformReply) - 32)
				
static int
transform_filter_length (RRTransformPtr transform)
{
    int	nbytes, nparams;

    if (transform->filter == NULL)
	return 0;
    nbytes = strlen (transform->filter->name);
    nparams = transform->nparams;
    return pad_to_int32(nbytes) + (nparams * sizeof (xFixed));
}

static int
transform_filter_encode (ClientPtr client, char *output,
			 CARD16	*nbytesFilter,
			 CARD16	*nparamsFilter,
			 RRTransformPtr transform)
{
    int	    nbytes, nparams;
    int	    n;

    if (transform->filter == NULL) {
	*nbytesFilter = 0;
	*nparamsFilter = 0;
	return 0;
    }
    nbytes = strlen (transform->filter->name);
    nparams = transform->nparams;
    *nbytesFilter = nbytes;
    *nparamsFilter = nparams;
    memcpy (output, transform->filter->name, nbytes);
    while ((nbytes & 3) != 0)
	output[nbytes++] = 0;
    memcpy (output + nbytes, transform->params, nparams * sizeof (xFixed));
    if (client->swapped) {
	swaps (nbytesFilter, n);
	swaps (nparamsFilter, n);
	SwapLongs ((CARD32 *) (output + nbytes), nparams);
    }
    nbytes += nparams * sizeof (xFixed);
    return nbytes;
}

static void
transform_encode (ClientPtr client, xRenderTransform *wire, PictTransform *pict)
{
    xRenderTransform_from_PictTransform (wire, pict);
    if (client->swapped)
	SwapLongs ((CARD32 *) wire, bytes_to_int32(sizeof(xRenderTransform)));
}

int
ProcRRGetCrtcTransform (ClientPtr client)
{
    REQUEST(xRRGetCrtcTransformReq);
    xRRGetCrtcTransformReply	*reply;
    RRCrtcPtr			crtc;
    int				n, nextra;
    RRTransformPtr		current, pending;
    char			*extra;

    REQUEST_SIZE_MATCH (xRRGetCrtcTransformReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    pending = &crtc->client_pending_transform;
    current = &crtc->client_current_transform;

    nextra = (transform_filter_length (pending) +
	      transform_filter_length (current));

    reply = malloc(sizeof (xRRGetCrtcTransformReply) + nextra);
    if (!reply)
	return BadAlloc;

    extra = (char *) (reply + 1);
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = bytes_to_int32(CrtcTransformExtra + nextra);

    reply->hasTransforms = crtc->transforms;

    transform_encode (client, &reply->pendingTransform, &pending->transform);
    extra += transform_filter_encode (client, extra,
				      &reply->pendingNbytesFilter,
				      &reply->pendingNparamsFilter,
				      pending);

    transform_encode (client, &reply->currentTransform, &current->transform);
    extra += transform_filter_encode (client, extra,
				      &reply->currentNbytesFilter,
				      &reply->currentNparamsFilter,
				      current);

    if (client->swapped) {
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
    }
    WriteToClient (client, sizeof (xRRGetCrtcTransformReply) + nextra, (char *) reply);
    free(reply);
    return Success;
}

void
RRConstrainCursorHarder(DeviceIntPtr pDev, ScreenPtr pScreen, int mode, int *x, int *y)
{
    rrScrPriv (pScreen);
    int i;

    /* intentional dead space -> let it float */
    if (pScrPriv->discontiguous)
       return;

    /* if we're moving inside a crtc, we're fine */
    for (i = 0; i < pScrPriv->numCrtcs; i++) {
       RRCrtcPtr crtc = pScrPriv->crtcs[i];

       int left, right, top, bottom;

       if (!crtc->mode)
           continue;

       crtc_bounds(crtc, &left, &right, &top, &bottom);

       if ((*x >= left) && (*x <= right) && (*y >= top) && (*y <= bottom))
           return;
    }

    /* if we're trying to escape, clamp to the CRTC we're coming from */
    for (i = 0; i < pScrPriv->numCrtcs; i++) {
       RRCrtcPtr crtc = pScrPriv->crtcs[i];
       int nx, ny;
       int left, right, top, bottom;

       if (!crtc->mode)
           continue;

       crtc_bounds(crtc, &left, &right, &top, &bottom);
       miPointerGetPosition(pDev, &nx, &ny);

       if ((nx >= left) && (nx <= right) && (ny >= top) && (ny <= bottom)) {
           if ((*x <= left) || (*x >= right)) {
               int dx = *x - nx;

               if (dx > 0)
                   *x = right;
               else if (dx < 0)
                   *x = left;
           }

           if ((*y <= top) || (*y >= bottom)) {
               int dy = *y - ny;

               if (dy > 0)
                   *y = bottom;
               else if (dy < 0)
                   *y = top;
           }

           return;
       }
    }
}
/*
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"
#include "protocol-versions.h"

Bool
RRClientKnowsRates (ClientPtr	pClient)
{
    rrClientPriv(pClient);

    return version_compare(pRRClient->major_version, pRRClient->minor_version,
                           1, 1) >= 0;
}

static int
ProcRRQueryVersion (ClientPtr client)
{
    xRRQueryVersionReply rep = {0};
    register int n;
    REQUEST(xRRQueryVersionReq);
    rrClientPriv(client);

    REQUEST_SIZE_MATCH(xRRQueryVersionReq);
    pRRClient->major_version = stuff->majorVersion;
    pRRClient->minor_version = stuff->minorVersion;
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (version_compare(stuff->majorVersion, stuff->minorVersion,
                        SERVER_RANDR_MAJOR_VERSION, SERVER_RANDR_MINOR_VERSION) < 0)
    {
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else
    {
        rep.majorVersion = SERVER_RANDR_MAJOR_VERSION;
        rep.minorVersion = SERVER_RANDR_MINOR_VERSION;
    }

    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xRRQueryVersionReply), (char *)&rep);
    return Success;
}

static int
ProcRRSelectInput (ClientPtr client)
{
    REQUEST(xRRSelectInputReq);
    rrClientPriv(client);
    RRTimesPtr	pTimes;
    WindowPtr	pWin;
    RREventPtr	pRREvent, *pHead;
    XID		clientResource;
    int		rc;

    REQUEST_SIZE_MATCH(xRRSelectInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReceiveAccess);
    if (rc != Success)
	return rc;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 RREventType, client, DixWriteAccess);
    if (rc != Success && rc != BadValue)
	return rc;

    if (stuff->enable & (RRScreenChangeNotifyMask|
			 RRCrtcChangeNotifyMask|
			 RROutputChangeNotifyMask|
			 RROutputPropertyNotifyMask)) 
    {
	ScreenPtr	pScreen = pWin->drawable.pScreen;
	rrScrPriv	(pScreen);

	pRREvent = NULL;
	if (pHead) 
	{
	    /* check for existing entry. */
	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next)
		if (pRREvent->client == client)
		    break;
	}

	if (!pRREvent)
	{
	    /* build the entry */
	    pRREvent = (RREventPtr) malloc(sizeof (RREventRec));
	    if (!pRREvent)
		return BadAlloc;
	    pRREvent->next = 0;
	    pRREvent->client = client;
	    pRREvent->window = pWin;
	    pRREvent->mask = stuff->enable;
	    /*
	     * add a resource that will be deleted when
	     * the client goes away
	     */
	    clientResource = FakeClientID (client->index);
	    pRREvent->clientResource = clientResource;
	    if (!AddResource (clientResource, RRClientType, (pointer)pRREvent))
		return BadAlloc;
	    /*
	     * create a resource to contain a pointer to the list
	     * of clients selecting input.  This must be indirect as
	     * the list may be arbitrarily rearranged which cannot be
	     * done through the resource database.
	     */
	    if (!pHead)
	    {
		pHead = (RREventPtr *) malloc(sizeof (RREventPtr));
		if (!pHead ||
		    !AddResource (pWin->drawable.id, RREventType, (pointer)pHead))
		{
		    FreeResource (clientResource, RT_NONE);
		    return BadAlloc;
		}
		*pHead = 0;
	    }
	    pRREvent->next = *pHead;
	    *pHead = pRREvent;
	}
	/*
	 * Now see if the client needs an event
	 */
	if (pScrPriv)
	{
	    pTimes = &((RRTimesPtr) (pRRClient + 1))[pScreen->myNum];
	    if (CompareTimeStamps (pTimes->setTime, 
				   pScrPriv->lastSetTime) != 0 ||
		CompareTimeStamps (pTimes->configTime, 
				   pScrPriv->lastConfigTime) != 0)
	    {
		if (pRREvent->mask & RRScreenChangeNotifyMask)
		{
		    RRDeliverScreenEvent (client, pWin, pScreen);
		}

		if (pRREvent->mask & RRCrtcChangeNotifyMask)
		{
		    int i;

		    for (i = 0; i < pScrPriv->numCrtcs; i++)
		    {
			RRDeliverCrtcEvent (client, pWin, pScrPriv->crtcs[i]);
		    }
		}

		if (pRREvent->mask & RROutputChangeNotifyMask)
		{
		    int i;

		    for (i = 0; i < pScrPriv->numOutputs; i++)
		    {
			RRDeliverOutputEvent (client, pWin, pScrPriv->outputs[i]);
		    }
		}

		/* We don't check for RROutputPropertyNotifyMask, as randrproto.txt doesn't
		 * say if there ought to be notifications of changes to output properties
		 * if those changes occurred before the time RRSelectInput is called.
		 */
	    }
	}
    }
    else if (stuff->enable == 0) 
    {
	/* delete the interest */
	if (pHead) {
	    RREventPtr pNewRREvent = 0;
	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next) {
		if (pRREvent->client == client)
		    break;
		pNewRREvent = pRREvent;
	    }
	    if (pRREvent) {
		FreeResource (pRREvent->clientResource, RRClientType);
		if (pNewRREvent)
		    pNewRREvent->next = pRREvent->next;
		else
		    *pHead = pRREvent->next;
		free(pRREvent);
	    }
	}
    }
    else 
    {
	client->errorValue = stuff->enable;
	return BadValue;
    }
    return Success;
}

int (*ProcRandrVector[RRNumberRequests])(ClientPtr) = {
    ProcRRQueryVersion,	/* 0 */
/* we skip 1 to make old clients fail pretty immediately */
    NULL,			/* 1 ProcRandrOldGetScreenInfo */
/* V1.0 apps share the same set screen config request id */
    ProcRRSetScreenConfig,	/* 2 */
    NULL,			/* 3 ProcRandrOldScreenChangeSelectInput */
/* 3 used to be ScreenChangeSelectInput; deprecated */
    ProcRRSelectInput,		/* 4 */
    ProcRRGetScreenInfo,    	/* 5 */
/* V1.2 additions */
    ProcRRGetScreenSizeRange,	/* 6 */
    ProcRRSetScreenSize,	/* 7 */
    ProcRRGetScreenResources,	/* 8 */
    ProcRRGetOutputInfo,	/* 9 */
    ProcRRListOutputProperties,	/* 10 */
    ProcRRQueryOutputProperty,	/* 11 */
    ProcRRConfigureOutputProperty,  /* 12 */
    ProcRRChangeOutputProperty,	/* 13 */
    ProcRRDeleteOutputProperty,	/* 14 */
    ProcRRGetOutputProperty,	/* 15 */
    ProcRRCreateMode,		/* 16 */
    ProcRRDestroyMode,		/* 17 */
    ProcRRAddOutputMode,	/* 18 */
    ProcRRDeleteOutputMode,	/* 19 */
    ProcRRGetCrtcInfo,		/* 20 */
    ProcRRSetCrtcConfig,	/* 21 */
    ProcRRGetCrtcGammaSize,	/* 22 */
    ProcRRGetCrtcGamma,		/* 23 */
    ProcRRSetCrtcGamma,		/* 24 */
/* V1.3 additions */
    ProcRRGetScreenResourcesCurrent, /* 25 */
    ProcRRSetCrtcTransform,	/* 26 */
    ProcRRGetCrtcTransform,	/* 27 */
    ProcRRGetPanning,		/* 28 */
    ProcRRSetPanning,		/* 29 */
    ProcRRSetOutputPrimary,	/* 30 */
    ProcRRGetOutputPrimary,	/* 31 */
};

/*
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"

#ifdef RANDR_10_INTERFACE
static RRModePtr
RROldModeAdd (RROutputPtr output, RRScreenSizePtr size, int refresh)
{
    ScreenPtr	pScreen = output->pScreen;
    rrScrPriv(pScreen);
    xRRModeInfo	modeInfo;
    char	name[100];
    RRModePtr	mode;
    int		i;
    RRModePtr   *modes;
    
    memset (&modeInfo, '\0', sizeof (modeInfo));
    sprintf (name, "%dx%d", size->width, size->height);
    
    modeInfo.width = size->width;
    modeInfo.height = size->height;
    modeInfo.hTotal = size->width;
    modeInfo.vTotal = size->height;
    modeInfo.dotClock = ((CARD32) size->width * (CARD32) size->height *
			 (CARD32) refresh);
    modeInfo.nameLength = strlen (name);
    mode = RRModeGet (&modeInfo, name);
    if (!mode)
	return NULL;
    for (i = 0; i < output->numModes; i++)
	if (output->modes[i] == mode)
	{
	    RRModeDestroy (mode);
	    return mode;
	}
    
    if (output->numModes)
	modes = realloc(output->modes,
			  (output->numModes + 1) * sizeof (RRModePtr));
    else
	modes = malloc(sizeof (RRModePtr));
    if (!modes)
    {
	RRModeDestroy (mode);
	FreeResource (mode->mode.id, 0);
	return NULL;
    }
    modes[output->numModes++] = mode;
    output->modes = modes;
    output->changed = TRUE;
    pScrPriv->changed = TRUE;
    pScrPriv->configChanged = TRUE;
    return mode;
}

static void
RRScanOldConfig (ScreenPtr pScreen, Rotation rotations)
{
    rrScrPriv(pScreen);
    RROutputPtr	output;
    RRCrtcPtr	crtc;
    RRModePtr	mode, newMode = NULL;
    int		i;
    CARD16	minWidth = MAXSHORT, minHeight = MAXSHORT;
    CARD16	maxWidth = 0, maxHeight = 0;
    
    /*
     * First time through, create a crtc and output and hook
     * them together
     */
    if (pScrPriv->numOutputs == 0 &&
	pScrPriv->numCrtcs == 0)
    {
	crtc = RRCrtcCreate (pScreen, NULL);
	if (!crtc)
	    return;
	output = RROutputCreate (pScreen, "default", 7, NULL);
	if (!output)
	    return;
	RROutputSetCrtcs (output, &crtc, 1);
	RROutputSetConnection (output, RR_Connected);
	RROutputSetSubpixelOrder (output, PictureGetSubpixelOrder (pScreen));
    }

    output = pScrPriv->outputs[0];
    if (!output)
	return;
    crtc = pScrPriv->crtcs[0];
    if (!crtc)
	return;

    /* check rotations */
    if (rotations != crtc->rotations)
    {
        crtc->rotations = rotations;
	crtc->changed = TRUE;
	pScrPriv->changed = TRUE;
    }
	
    /* regenerate mode list */
    for (i = 0; i < pScrPriv->nSizes; i++)
    {
	RRScreenSizePtr	size = &pScrPriv->pSizes[i];
	int		r;

	if (size->nRates)
	{
	    for (r = 0; r < size->nRates; r++)
	    {
		mode = RROldModeAdd (output, size, size->pRates[r].rate);
		if (i == pScrPriv->size && 
		    size->pRates[r].rate == pScrPriv->rate)
		{
		    newMode = mode;
		}
	    }
	    free(size->pRates);
	}
	else
	{
	    mode = RROldModeAdd (output, size, 0);
	    if (i == pScrPriv->size)
		newMode = mode;
	}
    }
    if (pScrPriv->nSizes)
	free(pScrPriv->pSizes);
    pScrPriv->pSizes = NULL;
    pScrPriv->nSizes = 0;
	    
    /* find size bounds */
    for (i = 0; i < output->numModes + output->numUserModes; i++) 
    {
	RRModePtr   mode = (i < output->numModes ? 
			    output->modes[i] : 
			    output->userModes[i-output->numModes]);
        CARD16	    width = mode->mode.width;
        CARD16	    height = mode->mode.height;
	
	if (width < minWidth) minWidth = width;
	if (width > maxWidth) maxWidth = width;
	if (height < minHeight) minHeight = height;
	if (height > maxHeight) maxHeight = height;
    }

    RRScreenSetSizeRange (pScreen, minWidth, minHeight, maxWidth, maxHeight);

    /* notice current mode */
    if (newMode)
	RRCrtcNotify (crtc, newMode, 0, 0, pScrPriv->rotation,
		      NULL, 1, &output);
}
#endif

/*
 * Poll the driver for changed information
 */
Bool
RRGetInfo (ScreenPtr pScreen, Bool force_query)
{
    rrScrPriv (pScreen);
    Rotation	    rotations;
    int		    i;

    /* Return immediately if we don't need to re-query and we already have the
     * information.
     */
    if (!force_query) {
	if (pScrPriv->numCrtcs != 0 || pScrPriv->numOutputs != 0)
	    return TRUE;
    }

    for (i = 0; i < pScrPriv->numOutputs; i++)
	pScrPriv->outputs[i]->changed = FALSE;
    for (i = 0; i < pScrPriv->numCrtcs; i++)
	pScrPriv->crtcs[i]->changed = FALSE;
    
    rotations = 0;
    pScrPriv->changed = FALSE;
    pScrPriv->configChanged = FALSE;
    
    if (!(*pScrPriv->rrGetInfo) (pScreen, &rotations))
	return FALSE;

#if RANDR_10_INTERFACE
    if (pScrPriv->nSizes)
	RRScanOldConfig (pScreen, rotations);
#endif
    RRTellChanged (pScreen);
    return TRUE;
}

/*
 * Register the range of sizes for the screen
 */
void
RRScreenSetSizeRange (ScreenPtr	pScreen,
		      CARD16	minWidth,
		      CARD16	minHeight,
		      CARD16	maxWidth,
		      CARD16	maxHeight)
{
    rrScrPriv (pScreen);

    if (!pScrPriv)
	return;
    if (pScrPriv->minWidth == minWidth && pScrPriv->minHeight == minHeight &&
	pScrPriv->maxWidth == maxWidth && pScrPriv->maxHeight == maxHeight)
    {
	return;
    }
	
    pScrPriv->minWidth  = minWidth;
    pScrPriv->minHeight = minHeight;
    pScrPriv->maxWidth  = maxWidth;
    pScrPriv->maxHeight = maxHeight;
    pScrPriv->changed = TRUE;
    pScrPriv->configChanged = TRUE;
}

#ifdef RANDR_10_INTERFACE
static Bool
RRScreenSizeMatches (RRScreenSizePtr  a,
		   RRScreenSizePtr  b)
{
    if (a->width != b->width)
	return FALSE;
    if (a->height != b->height)
	return FALSE;
    if (a->mmWidth != b->mmWidth)
	return FALSE;
    if (a->mmHeight != b->mmHeight)
	return FALSE;
    return TRUE;
}

RRScreenSizePtr
RRRegisterSize (ScreenPtr	    pScreen,
		short		    width, 
		short		    height,
		short		    mmWidth,
		short		    mmHeight)
{
    rrScrPriv (pScreen);
    int		    i;
    RRScreenSize    tmp;
    RRScreenSizePtr pNew;

    if (!pScrPriv)
	return 0;
    
    tmp.id = 0;
    tmp.width = width;
    tmp.height= height;
    tmp.mmWidth = mmWidth;
    tmp.mmHeight = mmHeight;
    tmp.pRates = 0;
    tmp.nRates = 0;
    for (i = 0; i < pScrPriv->nSizes; i++)
	if (RRScreenSizeMatches (&tmp, &pScrPriv->pSizes[i]))
	    return &pScrPriv->pSizes[i];
    pNew = realloc(pScrPriv->pSizes,
		     (pScrPriv->nSizes + 1) * sizeof (RRScreenSize));
    if (!pNew)
	return 0;
    pNew[pScrPriv->nSizes++] = tmp;
    pScrPriv->pSizes = pNew;
    return &pNew[pScrPriv->nSizes-1];
}

Bool RRRegisterRate (ScreenPtr		pScreen,
		     RRScreenSizePtr	pSize,
		     int		rate)
{
    rrScrPriv(pScreen);
    int		    i;
    RRScreenRatePtr pNew, pRate;

    if (!pScrPriv)
	return FALSE;
    
    for (i = 0; i < pSize->nRates; i++)
	if (pSize->pRates[i].rate == rate)
	    return TRUE;

    pNew = realloc(pSize->pRates,
		     (pSize->nRates + 1) * sizeof (RRScreenRate));
    if (!pNew)
	return FALSE;
    pRate = &pNew[pSize->nRates++];
    pRate->rate = rate;
    pSize->pRates = pNew;
    return TRUE;
}

Rotation
RRGetRotation(ScreenPtr pScreen)
{
    RROutputPtr	output = RRFirstOutput (pScreen);

    if (!output)
	return RR_Rotate_0;

    return output->crtc->rotation;
}

void
RRSetCurrentConfig (ScreenPtr		pScreen,
		    Rotation		rotation,
		    int			rate,
		    RRScreenSizePtr	pSize)
{
    rrScrPriv (pScreen);

    if (!pScrPriv)
	return;
    pScrPriv->size = pSize - pScrPriv->pSizes;
    pScrPriv->rotation = rotation;
    pScrPriv->rate = rate;
}
#endif
/*
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"

RESTYPE	RRModeType;

static Bool
RRModeEqual (xRRModeInfo *a, xRRModeInfo *b)
{
    if (a->width != b->width) return FALSE;
    if (a->height != b->height) return FALSE;
    if (a->dotClock != b->dotClock) return FALSE;
    if (a->hSyncStart != b->hSyncStart) return FALSE;
    if (a->hSyncEnd != b->hSyncEnd) return FALSE;
    if (a->hTotal != b->hTotal) return FALSE;
    if (a->hSkew != b->hSkew) return FALSE;
    if (a->vSyncStart != b->vSyncStart) return FALSE;
    if (a->vSyncEnd != b->vSyncEnd) return FALSE;
    if (a->vTotal != b->vTotal) return FALSE;
    if (a->nameLength != b->nameLength) return FALSE;
    if (a->modeFlags != b->modeFlags) return FALSE;
    return TRUE;
}

/*
 * Keep a list so it's easy to find modes in the resource database.
 */
static int	    num_modes;
static RRModePtr    *modes;

static RRModePtr
RRModeCreate (xRRModeInfo   *modeInfo,
	      const char    *name,
	      ScreenPtr	    userScreen)
{
    RRModePtr	mode, *newModes;
    
    if (!RRInit ())
	return NULL;

    mode = malloc(sizeof (RRModeRec) + modeInfo->nameLength + 1);
    if (!mode)
	return NULL;
    mode->refcnt = 1;
    mode->mode = *modeInfo;
    mode->name = (char *) (mode + 1);
    memcpy (mode->name, name, modeInfo->nameLength);
    mode->name[modeInfo->nameLength] = '\0';
    mode->userScreen = userScreen;

    if (num_modes)
	newModes = realloc(modes, (num_modes + 1) * sizeof (RRModePtr));
    else
	newModes = malloc(sizeof (RRModePtr));

    if (!newModes)
    {
	free(mode);
	return NULL;
    }

    mode->mode.id = FakeClientID(0);
    if (!AddResource (mode->mode.id, RRModeType, (pointer) mode))
	return NULL;
    modes = newModes;
    modes[num_modes++] = mode;
    
    /*
     * give the caller a reference to this mode
     */
    ++mode->refcnt;
    return mode;
}

static RRModePtr
RRModeFindByName (const char	*name,
		  CARD16    	nameLength)
{
    int		i;
    RRModePtr	mode;

    for (i = 0; i < num_modes; i++)
    {
	mode = modes[i];
	if (mode->mode.nameLength == nameLength &&
	    !memcmp (name, mode->name, nameLength))
	{
	    return mode;
	}
    }
    return NULL;
}

RRModePtr
RRModeGet (xRRModeInfo	*modeInfo,
	   const char	*name)
{
    int	i;

    for (i = 0; i < num_modes; i++)
    {
	RRModePtr   mode = modes[i];
	if (RRModeEqual (&mode->mode, modeInfo) &&
	    !memcmp (name, mode->name, modeInfo->nameLength))
	{
	    ++mode->refcnt;
	    return mode;
	}
    }

    return RRModeCreate (modeInfo, name, NULL);
}

static RRModePtr
RRModeCreateUser (ScreenPtr	pScreen,
		  xRRModeInfo	*modeInfo,
		  const char	*name,
		  int		*error)
{
    RRModePtr	mode;

    mode = RRModeFindByName (name, modeInfo->nameLength);
    if (mode)
    {
	*error = BadName;
	return NULL;
    }
    
    mode = RRModeCreate (modeInfo, name, pScreen);
    if (!mode)
    {
	*error = BadAlloc;
	return NULL;
    }
    *error = Success;
    return mode;
}

RRModePtr *
RRModesForScreen (ScreenPtr pScreen, int *num_ret)
{
    rrScrPriv(pScreen);
    int		o, c, m;
    RRModePtr	*screen_modes;
    int		num_screen_modes = 0;

    screen_modes = malloc((num_modes ? num_modes : 1) * sizeof (RRModePtr));
    if (!screen_modes)
	return NULL;
    
    /*
     * Add modes from all outputs
     */
    for (o = 0; o < pScrPriv->numOutputs; o++)
    {
	RROutputPtr	output = pScrPriv->outputs[o];
	int		m, n;

	for (m = 0; m < output->numModes + output->numUserModes; m++)
	{
	    RRModePtr   mode = (m < output->numModes ? 
				output->modes[m] : 
				output->userModes[m-output->numModes]);
	    for (n = 0; n < num_screen_modes; n++)
		if (screen_modes[n] == mode)
		    break;
	    if (n == num_screen_modes)
		screen_modes[num_screen_modes++] = mode;
	}
    }
    /*
     * Add modes from all crtcs. The goal is to
     * make sure all available and active modes
     * are visible to the client
     */
    for (c = 0; c < pScrPriv->numCrtcs; c++)
    {
	RRCrtcPtr	crtc = pScrPriv->crtcs[c];
	RRModePtr	mode = crtc->mode;
	int		n;

	if (!mode) continue;
	for (n = 0; n < num_screen_modes; n++)
	    if (screen_modes[n] == mode)
		break;
	if (n == num_screen_modes)
	    screen_modes[num_screen_modes++] = mode;
    }
    /*
     * Add all user modes for this screen
     */
    for (m = 0; m < num_modes; m++)
    {
	RRModePtr	mode = modes[m];
	int		n;

	if (mode->userScreen != pScreen)
	    continue;
	for (n = 0; n < num_screen_modes; n++)
	    if (screen_modes[n] == mode)
		break;
	if (n == num_screen_modes)
	    screen_modes[num_screen_modes++] = mode;
    }
    
    *num_ret = num_screen_modes;
    return screen_modes;
}

void
RRModeDestroy (RRModePtr mode)
{
    int	m;
    
    if (--mode->refcnt > 0)
	return;
    for (m = 0; m < num_modes; m++)
    {
	if (modes[m] == mode)
	{
	    memmove (modes + m, modes + m + 1,
		     (num_modes - m - 1) * sizeof (RRModePtr));
	    num_modes--;
	    if (!num_modes)
	    {
		free(modes);
		modes = NULL;
	    }
	    break;
	}
    }
    
    free(mode);
}

static int
RRModeDestroyResource (pointer value, XID pid)
{
    RRModeDestroy ((RRModePtr) value);
    return 1;
}

/*
 * Initialize mode type
 */
Bool
RRModeInit (void)
{
    assert (num_modes == 0);
    assert (modes == NULL);
    RRModeType = CreateNewResourceType (RRModeDestroyResource, "MODE");
    if (!RRModeType)
	return FALSE;
    
    return TRUE;
}

/*
 * Initialize mode type error value
 */
void
RRModeInitErrorValue(void)
{
    SetResourceTypeErrorValue(RRModeType, RRErrorBase + BadRRMode);
}

int
ProcRRCreateMode (ClientPtr client)
{
    REQUEST(xRRCreateModeReq);
    xRRCreateModeReply	rep = {0};
    WindowPtr		pWin;
    ScreenPtr		pScreen;
    rrScrPrivPtr	pScrPriv;
    xRRModeInfo		*modeInfo;
    long		units_after;
    char		*name;
    int			error, rc;
    RRModePtr		mode;
    
    REQUEST_AT_LEAST_SIZE (xRRCreateModeReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    
    modeInfo = &stuff->modeInfo;
    name = (char *) (stuff + 1);
    units_after = (stuff->length - bytes_to_int32(sizeof (xRRCreateModeReq)));

    /* check to make sure requested name fits within the data provided */
    if (bytes_to_int32(modeInfo->nameLength) > units_after)
	return BadLength;

    mode = RRModeCreateUser (pScreen, modeInfo, name, &error);
    if (!mode)
	return error;

    rep.type = X_Reply;
    rep.pad0 = 0;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.mode = mode->mode.id;
    if (client->swapped)
    {
	int n;
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.mode, n);
    }
    WriteToClient(client, sizeof(xRRCreateModeReply), (char *)&rep);
    /* Drop out reference to this mode */
    RRModeDestroy (mode);
    return Success;
}

int
ProcRRDestroyMode (ClientPtr client)
{
    REQUEST(xRRDestroyModeReq);
    RRModePtr	mode;
    
    REQUEST_SIZE_MATCH(xRRDestroyModeReq);
    VERIFY_RR_MODE(stuff->mode, mode, DixDestroyAccess);

    if (!mode->userScreen)
	return BadMatch;
    if (mode->refcnt > 1)
	return BadAccess;
    FreeResource (stuff->mode, 0);
    return Success;
}

int
ProcRRAddOutputMode (ClientPtr client)
{
    REQUEST(xRRAddOutputModeReq);
    RRModePtr	mode;
    RROutputPtr	output;
    
    REQUEST_SIZE_MATCH(xRRAddOutputModeReq);
    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);
    VERIFY_RR_MODE(stuff->mode, mode, DixUseAccess);
    
    return RROutputAddUserMode (output, mode);
}

int
ProcRRDeleteOutputMode (ClientPtr client)
{
    REQUEST(xRRDeleteOutputModeReq);
    RRModePtr	mode;
    RROutputPtr	output;
    
    REQUEST_SIZE_MATCH(xRRDeleteOutputModeReq);
    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);
    VERIFY_RR_MODE(stuff->mode, mode, DixUseAccess);
    
    return RROutputDeleteUserMode (output, mode);
}
/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"

RESTYPE	RROutputType;

/*
 * Notify the output of some change
 */
void
RROutputChanged (RROutputPtr output, Bool configChanged)
{
    ScreenPtr	pScreen = output->pScreen;
    
    output->changed = TRUE;
    if (pScreen)
    {
	rrScrPriv (pScreen);
	pScrPriv->changed = TRUE;
	if (configChanged)
	    pScrPriv->configChanged = TRUE;
    }
}

/*
 * Create an output
 */

RROutputPtr
RROutputCreate (ScreenPtr   pScreen,
		const char  *name,
		int	    nameLength,
		void	    *devPrivate)
{
    RROutputPtr	    output;
    RROutputPtr	    *outputs;
    rrScrPrivPtr    pScrPriv;

    if (!RRInit())
	return NULL;
    
    pScrPriv = rrGetScrPriv(pScreen);

    if (pScrPriv->numOutputs)
	outputs = realloc(pScrPriv->outputs,
			    (pScrPriv->numOutputs + 1) * sizeof (RROutputPtr));
    else
	outputs = malloc(sizeof (RROutputPtr));
    if (!outputs)
	return FALSE;

    pScrPriv->outputs = outputs;
    
    output = malloc(sizeof (RROutputRec) + nameLength + 1);
    if (!output)
	return NULL;
    output->id = FakeClientID (0);
    output->pScreen = pScreen;
    output->name = (char *) (output + 1);
    output->nameLength = nameLength;
    memcpy (output->name, name, nameLength);
    output->name[nameLength] = '\0';
    output->connection = RR_UnknownConnection;
    output->subpixelOrder = SubPixelUnknown;
    output->mmWidth = 0;
    output->mmHeight = 0;
    output->crtc = NULL;
    output->numCrtcs = 0;
    output->crtcs = NULL;
    output->numClones = 0;
    output->clones = NULL;
    output->numModes = 0;
    output->numPreferred = 0;
    output->modes = NULL;
    output->numUserModes = 0;
    output->userModes = NULL;
    output->properties = NULL;
    output->pendingProperties = FALSE;
    output->changed = FALSE;
    output->devPrivate = devPrivate;
    
    if (!AddResource (output->id, RROutputType, (pointer) output))
	return NULL;

    pScrPriv->outputs[pScrPriv->numOutputs++] = output;
    return output;
}

/*
 * Notify extension that output parameters have been changed
 */
Bool
RROutputSetClones (RROutputPtr  output,
		   RROutputPtr  *clones,
		   int		numClones)
{
    RROutputPtr	*newClones;
    int		i;

    if (numClones == output->numClones)
    {
	for (i = 0; i < numClones; i++)
	    if (output->clones[i] != clones[i])
		break;
	if (i == numClones)
	    return TRUE;
    }
    if (numClones)
    {
	newClones = malloc(numClones * sizeof (RROutputPtr));
	if (!newClones)
	    return FALSE;
    }
    else
	newClones = NULL;
    free(output->clones);
    memcpy (newClones, clones, numClones * sizeof (RROutputPtr));
    output->clones = newClones;
    output->numClones = numClones;
    RROutputChanged (output, TRUE);
    return TRUE;
}

Bool
RROutputSetModes (RROutputPtr	output,
		  RRModePtr	*modes,
		  int		numModes,
		  int		numPreferred)
{
    RRModePtr	*newModes;
    int		i;

    if (numModes == output->numModes && numPreferred == output->numPreferred)
    {
	for (i = 0; i < numModes; i++)
	    if (output->modes[i] != modes[i])
		break;
	if (i == numModes)
	{
	    for (i = 0; i < numModes; i++)
		RRModeDestroy (modes[i]);
	    return TRUE;
	}
    }

    if (numModes)
    {
	newModes = malloc(numModes * sizeof (RRModePtr));
	if (!newModes)
	    return FALSE;
    }
    else
	newModes = NULL;
    if (output->modes)
    {
	for (i = 0; i < output->numModes; i++)
	    RRModeDestroy (output->modes[i]);
	free(output->modes);
    }
    memcpy (newModes, modes, numModes * sizeof (RRModePtr));
    output->modes = newModes;
    output->numModes = numModes;
    output->numPreferred = numPreferred;
    RROutputChanged (output, TRUE);
    return TRUE;
}

int
RROutputAddUserMode (RROutputPtr    output,
		     RRModePtr	    mode)
{
    int		m;
    ScreenPtr	pScreen = output->pScreen;
    rrScrPriv(pScreen);
    RRModePtr	*newModes;

    /* Check to see if this mode is already listed for this output */
    for (m = 0; m < output->numModes + output->numUserModes; m++)
    {
	RRModePtr   e = (m < output->numModes ?
			 output->modes[m] :
			 output->userModes[m - output->numModes]);
	if (mode == e)
	    return Success;
    }

    /* Check with the DDX to see if this mode is OK */
    if (pScrPriv->rrOutputValidateMode)
	if (!pScrPriv->rrOutputValidateMode (pScreen, output, mode))
	    return BadMatch;

    if (output->userModes)
	newModes = realloc(output->userModes,
			     (output->numUserModes + 1) * sizeof (RRModePtr));
    else
	newModes = malloc(sizeof (RRModePtr));
    if (!newModes)
	return BadAlloc;

    output->userModes = newModes;
    output->userModes[output->numUserModes++] = mode;
    ++mode->refcnt;
    RROutputChanged (output, TRUE);
    RRTellChanged (pScreen);
    return Success;
}

int
RROutputDeleteUserMode (RROutputPtr output,
			RRModePtr   mode)
{
    int		m;
    
    /* Find this mode in the user mode list */
    for (m = 0; m < output->numUserModes; m++)
    {
	RRModePtr   e = output->userModes[m];

	if (mode == e)
	    break;
    }
    /* Not there, access error */
    if (m == output->numUserModes)
	return BadAccess;

    /* make sure the mode isn't active for this output */
    if (output->crtc && output->crtc->mode == mode)
	return BadMatch;

    memmove (output->userModes + m, output->userModes + m + 1,
	     (output->numUserModes - m - 1) * sizeof (RRModePtr));
    output->numUserModes--;
    RRModeDestroy (mode);
    return Success;
}

Bool
RROutputSetCrtcs (RROutputPtr	output,
		  RRCrtcPtr	*crtcs,
		  int		numCrtcs)
{
    RRCrtcPtr	*newCrtcs;
    int		i;

    if (numCrtcs == output->numCrtcs)
    {
	for (i = 0; i < numCrtcs; i++)
	    if (output->crtcs[i] != crtcs[i])
		break;
	if (i == numCrtcs)
	    return TRUE;
    }
    if (numCrtcs)
    {
	newCrtcs = malloc(numCrtcs * sizeof (RRCrtcPtr));
	if (!newCrtcs)
	    return FALSE;
    }
    else
	newCrtcs = NULL;
    free(output->crtcs);
    memcpy (newCrtcs, crtcs, numCrtcs * sizeof (RRCrtcPtr));
    output->crtcs = newCrtcs;
    output->numCrtcs = numCrtcs;
    RROutputChanged (output, TRUE);
    return TRUE;
}

Bool
RROutputSetConnection (RROutputPtr  output,
		       CARD8	    connection)
{
    if (output->connection == connection)
	return TRUE;
    output->connection = connection;
    RROutputChanged (output, TRUE);
    return TRUE;
}

Bool
RROutputSetSubpixelOrder (RROutputPtr output,
			  int	      subpixelOrder)
{
    if (output->subpixelOrder == subpixelOrder)
	return TRUE;

    output->subpixelOrder = subpixelOrder;
    RROutputChanged (output, FALSE);
    return TRUE;
}

Bool
RROutputSetPhysicalSize (RROutputPtr	output,
			 int		mmWidth,
			 int		mmHeight)
{
    if (output->mmWidth == mmWidth && output->mmHeight == mmHeight)
	return TRUE;
    output->mmWidth = mmWidth;
    output->mmHeight = mmHeight;
    RROutputChanged (output, FALSE);
    return TRUE;
}


void
RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    rrScrPriv (pScreen);
    xRROutputChangeNotifyEvent	oe;
    RRCrtcPtr	crtc = output->crtc;
    RRModePtr	mode = crtc ? crtc->mode : 0;
    
    oe.type = RRNotify + RREventBase;
    oe.subCode = RRNotify_OutputChange;
    oe.timestamp = pScrPriv->lastSetTime.milliseconds;
    oe.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
    oe.window = pWin->drawable.id;
    oe.output = output->id;
    if (crtc)
    {
	oe.crtc = crtc->id;
	oe.mode = mode ? mode->mode.id : None;
	oe.rotation = crtc->rotation;
    }
    else
    {
	oe.crtc = None;
	oe.mode = None;
	oe.rotation = RR_Rotate_0;
    }
    oe.connection = output->connection;
    oe.subpixelOrder = output->subpixelOrder;
    WriteEventsToClient (client, 1, (xEvent *) &oe);
}

/*
 * Destroy a Output at shutdown
 */
void
RROutputDestroy (RROutputPtr output)
{
    FreeResource (output->id, 0);
}

static int
RROutputDestroyResource (pointer value, XID pid)
{
    RROutputPtr	output = (RROutputPtr) value;
    ScreenPtr	pScreen = output->pScreen;
    int		m;

    if (pScreen)
    {
	rrScrPriv(pScreen);
	int		i;

	if (pScrPriv->primaryOutput == output)
	    pScrPriv->primaryOutput = NULL;
    
	for (i = 0; i < pScrPriv->numOutputs; i++)
	{
	    if (pScrPriv->outputs[i] == output)
	    {
		memmove (pScrPriv->outputs + i, pScrPriv->outputs + i + 1,
			 (pScrPriv->numOutputs - (i + 1)) * sizeof (RROutputPtr));
		--pScrPriv->numOutputs;
		break;
	    }
	}
    }
    if (output->modes)
    {
	for (m = 0; m < output->numModes; m++)
	    RRModeDestroy (output->modes[m]);
	free(output->modes);
    }
    
    for (m = 0; m < output->numUserModes; m++)
	RRModeDestroy (output->userModes[m]);
    free(output->userModes);

    free(output->crtcs);
    free(output->clones);
    RRDeleteAllOutputProperties (output);
    free(output);
    return 1;
}

/*
 * Initialize output type
 */
Bool
RROutputInit (void)
{
    RROutputType = CreateNewResourceType (RROutputDestroyResource, "OUTPUT");
    if (!RROutputType)
	return FALSE;

    return TRUE;
}

/*
 * Initialize output type error value
 */
void
RROutputInitErrorValue(void)
{
    SetResourceTypeErrorValue(RROutputType, RRErrorBase + BadRROutput);
}

#define OutputInfoExtra	(SIZEOF(xRRGetOutputInfoReply) - 32)

int
ProcRRGetOutputInfo (ClientPtr client)
{
    REQUEST(xRRGetOutputInfoReq);
    xRRGetOutputInfoReply	rep;
    RROutputPtr			output;
    CARD8			*extra;
    unsigned long		extraLen;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    RRCrtc			*crtcs;
    RRMode			*modes;
    RROutput			*clones;
    char			*name;
    int				i, n;
    
    REQUEST_SIZE_MATCH(xRRGetOutputInfoReq);
    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

    pScreen = output->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = bytes_to_int32(OutputInfoExtra);
    rep.timestamp = pScrPriv->lastSetTime.milliseconds;
    rep.crtc = output->crtc ? output->crtc->id : None;
    rep.mmWidth = output->mmWidth;
    rep.mmHeight = output->mmHeight;
    rep.connection = output->connection;
    rep.subpixelOrder = output->subpixelOrder;
    rep.nCrtcs = output->numCrtcs;
    rep.nModes = output->numModes + output->numUserModes;
    rep.nPreferred = output->numPreferred;
    rep.nClones = output->numClones;
    rep.nameLength = output->nameLength;
    
    extraLen = ((output->numCrtcs +
		 output->numModes + output->numUserModes +
		 output->numClones +
		 bytes_to_int32(rep.nameLength)) << 2);

    if (extraLen)
    {
	rep.length += bytes_to_int32(extraLen);
	extra = malloc(extraLen);
	if (!extra)
	    return BadAlloc;
    }
    else
	extra = NULL;

    crtcs = (RRCrtc *) extra;
    modes = (RRMode *) (crtcs + output->numCrtcs);
    clones = (RROutput *) (modes + output->numModes + output->numUserModes);
    name = (char *) (clones + output->numClones);
    
    for (i = 0; i < output->numCrtcs; i++)
    {
	crtcs[i] = output->crtcs[i]->id;
	if (client->swapped)
	    swapl (&crtcs[i], n);
    }
    for (i = 0; i < output->numModes + output->numUserModes; i++)
    {
	if (i < output->numModes)
	    modes[i] = output->modes[i]->mode.id;
	else
	    modes[i] = output->userModes[i - output->numModes]->mode.id;
	if (client->swapped)
	    swapl (&modes[i], n);
    }
    for (i = 0; i < output->numClones; i++)
    {
	clones[i] = output->clones[i]->id;
	if (client->swapped)
	    swapl (&clones[i], n);
    }
    memcpy (name, output->name, output->nameLength);
    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swapl(&rep.crtc, n);
	swapl(&rep.mmWidth, n);
	swapl(&rep.mmHeight, n);
	swaps(&rep.nCrtcs, n);
	swaps(&rep.nModes, n);
	swaps(&rep.nClones, n);
	swaps(&rep.nameLength, n);
    }
    WriteToClient(client, sizeof(xRRGetOutputInfoReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	free(extra);
    }
    
    return Success;
}

static void
RRSetPrimaryOutput(ScreenPtr pScreen, rrScrPrivPtr pScrPriv,
		   RROutputPtr output)
{
    if (pScrPriv->primaryOutput == output)
	return;

    /* clear the old primary */
    if (pScrPriv->primaryOutput) {
	RROutputChanged(pScrPriv->primaryOutput, 0);
	pScrPriv->primaryOutput = NULL;
    }

    /* set the new primary */
    if (output) {
	pScrPriv->primaryOutput = output;
	RROutputChanged(output, 0);
    }

    pScrPriv->layoutChanged = TRUE;

    RRTellChanged(pScreen);
}

int
ProcRRSetOutputPrimary(ClientPtr client)
{
    REQUEST(xRRSetOutputPrimaryReq);
    RROutputPtr output = NULL;
    WindowPtr pWin;
    rrScrPrivPtr pScrPriv;
    int rc;

    REQUEST_SIZE_MATCH(xRRSetOutputPrimaryReq);

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    if (stuff->output) {
	VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

	if (output->pScreen != pWin->drawable.pScreen) {
	    client->errorValue = stuff->window;
	    return BadMatch;
	}
    }

    pScrPriv = rrGetScrPriv(pWin->drawable.pScreen);
    RRSetPrimaryOutput(pWin->drawable.pScreen, pScrPriv, output);

    return Success;
}

int
ProcRRGetOutputPrimary(ClientPtr client)
{
    REQUEST(xRRGetOutputPrimaryReq);
    WindowPtr pWin;
    rrScrPrivPtr pScrPriv;
    xRRGetOutputPrimaryReply rep;
    RROutputPtr primary = NULL;
    int rc;

    REQUEST_SIZE_MATCH(xRRGetOutputPrimaryReq);

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    pScrPriv = rrGetScrPriv(pWin->drawable.pScreen);
    if (pScrPriv)
	primary = pScrPriv->primaryOutput;

    memset(&rep, 0, sizeof(rep));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.output = primary ? primary->id : None;

    if (client->swapped) {
	int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.output, n);
    }

    WriteToClient(client, sizeof(xRRGetOutputPrimaryReply), &rep);

    return Success;
}
/*
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"
#include "inputstr.h"

/*
 * When the pointer moves, check to see if the specified position is outside
 * any of theavailable CRTCs and move it to a 'sensible' place if so, where
 * sensible is the closest monitor to the departing edge.
 *
 * Returns whether the position was adjusted
 */

static Bool
RRCrtcContainsPosition (RRCrtcPtr crtc, int x, int y)
{
    RRModePtr   mode = crtc->mode;
    int		scan_width, scan_height;

    if (!mode)
	return FALSE;

    RRCrtcGetScanoutSize (crtc, &scan_width, &scan_height);

    if (crtc->x <= x && x < crtc->x + scan_width &&
	crtc->y <= y && y < crtc->y + scan_height)
	return TRUE;
    return FALSE;
}

/*
 * Find the CRTC nearest the specified position, ignoring 'skip'
 */
static void
RRPointerToNearestCrtc (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y, RRCrtcPtr skip)
{
    rrScrPriv (pScreen);
    int		c;
    RRCrtcPtr	nearest = NULL;
    int		best = 0;
    int		best_dx = 0, best_dy = 0;

    for (c = 0; c < pScrPriv->numCrtcs; c++)
    {
	RRCrtcPtr   crtc = pScrPriv->crtcs[c];
	RRModePtr   mode = crtc->mode;
	int	    dx, dy;
	int	    dist;
	int	    scan_width, scan_height;

	if (!mode)
	    continue;
	if (crtc == skip)
	    continue;

	RRCrtcGetScanoutSize (crtc, &scan_width, &scan_height);

	if (x < crtc->x)
	    dx = crtc->x - x;
	else if (x > crtc->x + scan_width)
	    dx = x - (crtc->x + scan_width);
	else
	    dx = 0;
	if (y < crtc->y)
	    dy = crtc->y - x;
	else if (y > crtc->y + scan_height)
	    dy = y - (crtc->y + scan_height);
	else
	    dy = 0;
	dist = dx + dy;
	if (!nearest || dist < best)
	{
	    nearest = crtc;
	    best_dx = dx;
	    best_dy = dy;
	}
    }
    if (best_dx || best_dy)
	(*pScreen->SetCursorPosition) (pDev, pScreen, x + best_dx, y + best_dy, TRUE);
    pScrPriv->pointerCrtc = nearest;
}

void
RRPointerMoved (ScreenPtr pScreen, int x, int y)
{
    rrScrPriv (pScreen);
    RRCrtcPtr	pointerCrtc = pScrPriv->pointerCrtc;
    int	c;

    /* Check last known CRTC */
    if (pointerCrtc && RRCrtcContainsPosition (pointerCrtc, x, y))
	return;
    
    /* Check all CRTCs */
    for (c = 0; c < pScrPriv->numCrtcs; c++)
    {
	RRCrtcPtr   crtc = pScrPriv->crtcs[c];
	
	if (RRCrtcContainsPosition (crtc, x, y))
	{
	    /* Remember containing CRTC */
	    pScrPriv->pointerCrtc = crtc;
	    return;
	}
    }

    /* None contain pointer, find nearest */
    ErrorF("RRPointerMoved: Untested, may cause \"bogus pointer event\"\n");
    RRPointerToNearestCrtc (inputInfo.pointer, pScreen, x, y, pointerCrtc);
}

/*
 * When the screen is reconfigured, move all pointers to the nearest
 * CRTC
 */
void
RRPointerScreenConfigured (ScreenPtr pScreen)
{
    WindowPtr	pRoot;
    ScreenPtr	pCurrentScreen;
    int		x, y;
    DeviceIntPtr pDev;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (IsPointerDevice(pDev))
        {
            pRoot = GetCurrentRootWindow(pDev);
            pCurrentScreen = pRoot ? pRoot->drawable.pScreen : NULL;

            if (pScreen == pCurrentScreen)
            {
                GetSpritePosition(pDev, &x, &y);
                RRPointerToNearestCrtc (pDev, pScreen, x, y, NULL);
            }
        }
    }
}
/*
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"
#include "propertyst.h"
#include "swaprep.h"

static int
DeliverPropertyEvent(WindowPtr pWin, void *value)
{
    xRROutputPropertyNotifyEvent *event = value;
    RREventPtr *pHead, pRREvent;

    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
			    RREventType, serverClient, DixReadAccess);
    if (!pHead)
	return WT_WALKCHILDREN;

    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next)
    {
	if (!(pRREvent->mask & RROutputPropertyNotifyMask))
	    continue;

	event->window = pRREvent->window->drawable.id;
	WriteEventsToClient(pRREvent->client, 1, (xEvent *)event);
    }

    return WT_WALKCHILDREN;
}

static void RRDeliverPropertyEvent(ScreenPtr pScreen, xEvent *event)
{
    if (!(dispatchException & (DE_RESET | DE_TERMINATE)))
	WalkTree(pScreen, DeliverPropertyEvent, event);
}

static void
RRDestroyOutputProperty (RRPropertyPtr prop)
{
    free(prop->valid_values);
    free(prop->current.data);
    free(prop->pending.data);
    free(prop);
}

static void
RRDeleteProperty(RROutputRec *output, RRPropertyRec *prop)
{
    xRROutputPropertyNotifyEvent event;
    event.type = RREventBase + RRNotify;
    event.subCode = RRNotify_OutputProperty;
    event.output = output->id;
    event.state = PropertyDelete;
    event.atom = prop->propertyName;
    event.timestamp = currentTime.milliseconds;

    RRDeliverPropertyEvent(output->pScreen, (xEvent *)&event);

    RRDestroyOutputProperty(prop);
}

void
RRDeleteAllOutputProperties(RROutputPtr output)
{
    RRPropertyPtr prop, next;

    for (prop = output->properties; prop; prop = next) {
	next = prop->next;
        RRDeleteProperty(output, prop);
    }
}

static void
RRInitOutputPropertyValue (RRPropertyValuePtr property_value)
{
    property_value->type = None;
    property_value->format = 0;
    property_value->size = 0;
    property_value->data = NULL;
}

static RRPropertyPtr
RRCreateOutputProperty (Atom property)
{
    RRPropertyPtr   prop;

    prop = (RRPropertyPtr)malloc(sizeof(RRPropertyRec));
    if (!prop)
	return NULL;
    prop->next = NULL;
    prop->propertyName = property;
    prop->is_pending = FALSE;
    prop->range = FALSE;
    prop->immutable = FALSE;
    prop->num_valid = 0;
    prop->valid_values = NULL;
    RRInitOutputPropertyValue (&prop->current);
    RRInitOutputPropertyValue (&prop->pending);
    return prop;
}

void
RRDeleteOutputProperty(RROutputPtr output, Atom property)
{
    RRPropertyRec *prop, **prev;

    for (prev = &output->properties; (prop = *prev); prev = &(prop->next))
	if (prop->propertyName == property) {
            *prev = prop->next;
            RRDeleteProperty(output, prop);
            return;
        }
}

int
RRChangeOutputProperty (RROutputPtr output, Atom property, Atom type,
			int format, int mode, unsigned long len,
			pointer value, Bool sendevent, Bool pending)
{
    RRPropertyPtr		    prop;
    xRROutputPropertyNotifyEvent    event;
    rrScrPrivPtr		    pScrPriv = rrGetScrPriv(output->pScreen);
    int				    size_in_bytes;
    int				    total_size;
    unsigned long		    total_len;
    RRPropertyValuePtr		    prop_value;
    RRPropertyValueRec		    new_value;
    Bool			    add = FALSE;

    size_in_bytes = format >> 3;

    /* first see if property already exists */
    prop = RRQueryOutputProperty (output, property);
    if (!prop)   /* just add to list */
    {
	prop = RRCreateOutputProperty (property);
	if (!prop)
	    return BadAlloc;
	add = TRUE;
	mode = PropModeReplace;
    }
    if (pending && prop->is_pending)
	prop_value = &prop->pending;
    else
	prop_value = &prop->current;

    /* To append or prepend to a property the request format and type
     must match those of the already defined property.  The
     existing format and type are irrelevant when using the mode
     "PropModeReplace" since they will be written over. */

    if ((format != prop_value->format) && (mode != PropModeReplace))
	return BadMatch;
    if ((prop_value->type != type) && (mode != PropModeReplace))
	return BadMatch;
    new_value = *prop_value;
    if (mode == PropModeReplace)
	total_len = len;
    else
	total_len = prop_value->size + len;

    if (mode == PropModeReplace || len > 0)
    {
	pointer	    new_data = NULL, old_data = NULL;

	total_size = total_len * size_in_bytes;
	new_value.data = (pointer)malloc(total_size);
	if (!new_value.data && total_size)
	{
	    if (add)
		RRDestroyOutputProperty (prop);
	    return BadAlloc;
	}
	new_value.size = len;
	new_value.type = type;
	new_value.format = format;

	switch (mode) {
	case PropModeReplace:
	    new_data = new_value.data;
	    old_data = NULL;
	    break;
	case PropModeAppend:
	    new_data = (pointer) (((char *) new_value.data) + 
				  (prop_value->size * size_in_bytes));
	    old_data = new_value.data;
	    break;
	case PropModePrepend:
	    new_data = new_value.data;
	    old_data = (pointer) (((char *) new_value.data) + 
				  (prop_value->size * size_in_bytes));
	    break;
	}
	if (new_data)
	    memcpy ((char *) new_data, (char *) value, len * size_in_bytes);
	if (old_data)
	    memcpy ((char *) old_data, (char *) prop_value->data, 
		    prop_value->size * size_in_bytes);

	if (pending && pScrPriv->rrOutputSetProperty &&
	    !pScrPriv->rrOutputSetProperty(output->pScreen, output,
					   prop->propertyName, &new_value))
	{
	    free(new_value.data);
	    return BadValue;
	}
	free(prop_value->data);
	*prop_value = new_value;
    }

    else if (len == 0)
    {
	/* do nothing */
    }

    if (add)
    {
	prop->next = output->properties;
	output->properties = prop;
    }

    if (pending && prop->is_pending)
	output->pendingProperties = TRUE;

    if (sendevent)
    {
	event.type = RREventBase + RRNotify;
	event.subCode = RRNotify_OutputProperty;
	event.output = output->id;
	event.state = PropertyNewValue;
	event.atom = prop->propertyName;
	event.timestamp = currentTime.milliseconds;
	RRDeliverPropertyEvent (output->pScreen, (xEvent *)&event);
    }
    return Success;
}

Bool
RRPostPendingProperties (RROutputPtr output)
{
    RRPropertyValuePtr	pending_value;
    RRPropertyValuePtr	current_value;
    RRPropertyPtr	property;
    Bool		ret = TRUE;

    if (!output->pendingProperties)
	return TRUE;
    
    output->pendingProperties = FALSE;
    for (property = output->properties; property; property = property->next)
    {
	/* Skip non-pending properties */
	if (!property->is_pending)
	    continue;
	
	pending_value = &property->pending;
	current_value = &property->current;

	/*
	 * If the pending and current values are equal, don't mark it
	 * as changed (which would deliver an event)
	 */
	if (pending_value->type == current_value->type &&
	    pending_value->format == current_value->format &&
	    pending_value->size == current_value->size &&
	    !memcmp (pending_value->data, current_value->data,
		     pending_value->size * (pending_value->format / 8)))
	    continue;

	if (RRChangeOutputProperty (output, property->propertyName,
				    pending_value->type, pending_value->format,
				    PropModeReplace, pending_value->size,
				    pending_value->data, TRUE,
				    FALSE) != Success)
	    ret = FALSE;
    }
    return ret;
}

RRPropertyPtr
RRQueryOutputProperty (RROutputPtr output, Atom property)
{
    RRPropertyPtr   prop;
    
    for (prop = output->properties; prop; prop = prop->next)
	if (prop->propertyName == property)
	    return prop;
    return NULL;
}
		       
RRPropertyValuePtr
RRGetOutputProperty (RROutputPtr output, Atom property, Bool pending)
{
    RRPropertyPtr   prop = RRQueryOutputProperty (output, property);
    rrScrPrivPtr    pScrPriv = rrGetScrPriv(output->pScreen);

    if (!prop)
	return NULL;
    if (pending && prop->is_pending)
	return &prop->pending;
    else {
#if RANDR_13_INTERFACE
	/* If we can, try to update the property value first */
	if (pScrPriv->rrOutputGetProperty)
	    pScrPriv->rrOutputGetProperty(output->pScreen, output,
					  prop->propertyName);
#endif
	return &prop->current;
    }
}

int
RRConfigureOutputProperty (RROutputPtr output, Atom property,
			   Bool pending, Bool range, Bool immutable,
			   int num_values, INT32 *values)
{
    RRPropertyPtr   prop = RRQueryOutputProperty (output, property);
    Bool	    add = FALSE;
    INT32	    *new_values;

    if (!prop)
    {
        prop = RRCreateOutputProperty (property);
	if (!prop)
	    return BadAlloc;
	add = TRUE;
    } else if (prop->immutable && !immutable)
	return BadAccess;
    
    /*
     * ranges must have even number of values
     */
    if (range && (num_values & 1))
	return BadMatch;

    new_values = malloc(num_values * sizeof (INT32));
    if (!new_values && num_values)
	return BadAlloc;
    if (num_values)
	memcpy (new_values, values, num_values * sizeof (INT32));
    
    /*
     * Property moving from pending to non-pending
     * loses any pending values
     */
    if (prop->is_pending && !pending)
    {
	free(prop->pending.data);
	RRInitOutputPropertyValue (&prop->pending);
    }

    prop->is_pending = pending;
    prop->range = range;
    prop->immutable = immutable;
    prop->num_valid = num_values;
    free(prop->valid_values);
    prop->valid_values = new_values;

    if (add) {
	prop->next = output->properties;
	output->properties = prop;
    }

    return Success;
}

int
ProcRRListOutputProperties (ClientPtr client)
{
    REQUEST(xRRListOutputPropertiesReq);
    Atom			    *pAtoms = NULL, *temppAtoms;
    xRRListOutputPropertiesReply    rep;
    int				    numProps = 0;
    RROutputPtr			    output;
    RRPropertyPtr			    prop;
    
    REQUEST_SIZE_MATCH(xRRListOutputPropertiesReq);

    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

    for (prop = output->properties; prop; prop = prop->next)
	numProps++;
    if (numProps)
        if(!(pAtoms = (Atom *)malloc(numProps * sizeof(Atom))))
            return BadAlloc;

    rep.type = X_Reply;
    rep.length = bytes_to_int32(numProps * sizeof(Atom));
    rep.sequenceNumber = client->sequence;
    rep.nAtoms = numProps;
    if (client->swapped) 
    {
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swaps (&rep.nAtoms, n);
    }
    temppAtoms = pAtoms;
    for (prop = output->properties; prop; prop = prop->next)
	*temppAtoms++ = prop->propertyName;

    WriteToClient(client, sizeof(xRRListOutputPropertiesReply), (char*)&rep);
    if (numProps)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
        WriteSwappedDataToClient(client, numProps * sizeof(Atom), pAtoms);
        free(pAtoms);
    }
    return Success;
}

int
ProcRRQueryOutputProperty (ClientPtr client)
{
    REQUEST(xRRQueryOutputPropertyReq);
    xRRQueryOutputPropertyReply	    rep;
    RROutputPtr			    output;
    RRPropertyPtr		    prop;
    char *extra = NULL;
    
    REQUEST_SIZE_MATCH(xRRQueryOutputPropertyReq);

    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);
    
    prop = RRQueryOutputProperty (output, stuff->property);
    if (!prop)
	return BadName;
    
    if (prop->num_valid) {
	extra = malloc(prop->num_valid * sizeof(INT32));
	if (!extra)
	    return BadAlloc;
    }
    rep.type = X_Reply;
    rep.length = prop->num_valid;
    rep.sequenceNumber = client->sequence;
    rep.pending = prop->is_pending;
    rep.range = prop->range;
    rep.immutable = prop->immutable;
    if (client->swapped) 
    {
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
    }
    WriteToClient (client, sizeof (xRRQueryOutputPropertyReply), (char*)&rep);
    if (prop->num_valid)
    {
        memcpy(extra, prop->valid_values, prop->num_valid * sizeof(INT32));
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
        WriteSwappedDataToClient(client, prop->num_valid * sizeof(INT32),
				 extra);
        free(extra);
    }
    return Success;
}

int
ProcRRConfigureOutputProperty (ClientPtr client)
{
    REQUEST(xRRConfigureOutputPropertyReq);
    RROutputPtr				output;
    int					num_valid;
    
    REQUEST_AT_LEAST_SIZE(xRRConfigureOutputPropertyReq);

    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);
    
    num_valid = stuff->length - bytes_to_int32(sizeof (xRRConfigureOutputPropertyReq));
    return RRConfigureOutputProperty (output, stuff->property,
				      stuff->pending, stuff->range,
				      FALSE, num_valid, 
				      (INT32 *) (stuff + 1));
}

int
ProcRRChangeOutputProperty (ClientPtr client)
{
    REQUEST(xRRChangeOutputPropertyReq);
    RROutputPtr	    output;
    char	    format, mode;
    unsigned long   len;
    int		    sizeInBytes;
    int		    totalSize;
    int		    err;

    REQUEST_AT_LEAST_SIZE(xRRChangeOutputPropertyReq);
    UpdateCurrentTime();
    format = stuff->format;
    mode = stuff->mode;
    if ((mode != PropModeReplace) && (mode != PropModeAppend) &&
	(mode != PropModePrepend))
    {
	client->errorValue = mode;
	return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32))
    {
	client->errorValue = format;
        return BadValue;
    }
    len = stuff->nUnits;
    if (len > bytes_to_int32((0xffffffff - sizeof(xChangePropertyReq))))
	return BadLength;
    sizeInBytes = format>>3;
    totalSize = len * sizeInBytes;
    REQUEST_FIXED_SIZE(xRRChangeOutputPropertyReq, totalSize);

    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);
    
    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
    }
    if (!ValidAtom(stuff->type))
    {
	client->errorValue = stuff->type;
	return BadAtom;
    }

    err = RRChangeOutputProperty(output, stuff->property,
				 stuff->type, (int)format,
				 (int)mode, len, (pointer)&stuff[1], TRUE, TRUE);
    if (err != Success)
	return err;
    else
	return Success;
}

int
ProcRRDeleteOutputProperty (ClientPtr client)
{
    REQUEST(xRRDeleteOutputPropertyReq);
    RROutputPtr	output;
              
    REQUEST_SIZE_MATCH(xRRDeleteOutputPropertyReq);
    UpdateCurrentTime();
    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);
    
    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
    }


    RRDeleteOutputProperty(output, stuff->property);
    return Success;
}

int
ProcRRGetOutputProperty (ClientPtr client)
{
    REQUEST(xRRGetOutputPropertyReq);
    RRPropertyPtr		prop, *prev;
    RRPropertyValuePtr		prop_value;
    unsigned long		n, len, ind;
    RROutputPtr			output;
    xRRGetOutputPropertyReply	reply;
    char			*extra = NULL;

    REQUEST_SIZE_MATCH(xRRGetOutputPropertyReq);
    if (stuff->delete)
	UpdateCurrentTime();
    VERIFY_RR_OUTPUT(stuff->output, output,
		     stuff->delete ? DixWriteAccess : DixReadAccess);

    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
    }
    if ((stuff->delete != xTrue) && (stuff->delete != xFalse))
    {
	client->errorValue = stuff->delete;
	return BadValue;
    }
    if ((stuff->type != AnyPropertyType) && !ValidAtom(stuff->type))
    {
	client->errorValue = stuff->type;
	return BadAtom;
    }

    for (prev = &output->properties; (prop = *prev); prev = &prop->next)
	if (prop->propertyName == stuff->property) 
	    break;

    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    if (!prop) 
    {
	reply.nItems = 0;
	reply.length = 0;
	reply.bytesAfter = 0;
	reply.propertyType = None;
	reply.format = 0;
	if (client->swapped) {
	    int n;

	    swaps(&reply.sequenceNumber, n);
	    swapl(&reply.length, n);
	    swapl(&reply.propertyType, n);
	    swapl(&reply.bytesAfter, n);
	    swapl(&reply.nItems, n);
	}
	WriteToClient(client, sizeof(xRRGetOutputPropertyReply), &reply);
	return Success;
    }

    if (prop->immutable && stuff->delete)
	return BadAccess;

    prop_value = RRGetOutputProperty(output, stuff->property, stuff->pending);
    if (!prop_value)
	return BadAtom;

    /* If the request type and actual type don't match. Return the
    property information, but not the data. */

    if (((stuff->type != prop_value->type) &&
	 (stuff->type != AnyPropertyType))
       )
    {
	reply.bytesAfter = prop_value->size;
	reply.format = prop_value->format;
	reply.length = 0;
	reply.nItems = 0;
	reply.propertyType = prop_value->type;
	if (client->swapped) {
	    int n;

	    swaps(&reply.sequenceNumber, n);
	    swapl(&reply.length, n);
	    swapl(&reply.propertyType, n);
	    swapl(&reply.bytesAfter, n);
	    swapl(&reply.nItems, n);
	}
	WriteToClient(client, sizeof(xRRGetOutputPropertyReply), &reply);
	return Success;
    }

/*
 *  Return type, format, value to client
 */
    n = (prop_value->format/8) * prop_value->size; /* size (bytes) of prop */
    ind = stuff->longOffset << 2;        

   /* If longOffset is invalid such that it causes "len" to
	    be negative, it's a value error. */

    if (n < ind)
    {
	client->errorValue = stuff->longOffset;
	return BadValue;
    }

    len = min(n - ind, 4 * stuff->longLength);

    if (len) {
	extra = malloc(len);
	if (!extra)
	    return BadAlloc;
    }
    reply.bytesAfter = n - (ind + len);
    reply.format = prop_value->format;
    reply.length = bytes_to_int32(len);
    if (prop_value->format)
	reply.nItems = len / (prop_value->format / 8);
    else
	reply.nItems = 0;
    reply.propertyType = prop_value->type;

    if (stuff->delete && (reply.bytesAfter == 0))
    {
	xRROutputPropertyNotifyEvent    event;

	event.type = RREventBase + RRNotify;
	event.subCode = RRNotify_OutputProperty;
	event.output = output->id;
	event.state = PropertyDelete;
	event.atom = prop->propertyName;
	event.timestamp = currentTime.milliseconds;
	RRDeliverPropertyEvent (output->pScreen, (xEvent *)&event);
    }

    if (client->swapped) {
	int n;

	swaps(&reply.sequenceNumber, n);
	swapl(&reply.length, n);
	swapl(&reply.propertyType, n);
	swapl(&reply.bytesAfter, n);
	swapl(&reply.nItems, n);
    }
    WriteToClient(client, sizeof(xGenericReply), &reply);
    if (len)
    {
	memcpy(extra, (char *)prop_value->data + ind, len);
	switch (reply.format) {
	case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
	case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
	default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
	}
	WriteSwappedDataToClient(client, len,
				 extra);
	free(extra);
    }

    if (stuff->delete && (reply.bytesAfter == 0))
    { /* delete the Property */
	*prev = prop->next;
	RRDestroyOutputProperty (prop);
    }
    return Success;
}

/*
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"

static const int padlength[4] = {0, 3, 2, 1};

static CARD16
RR10CurrentSizeID (ScreenPtr pScreen);

/*
 * Edit connection information block so that new clients
 * see the current screen size on connect
 */
static void
RREditConnectionInfo (ScreenPtr pScreen)
{
    xConnSetup	    *connSetup;
    char	    *vendor;
    xPixmapFormat   *formats;
    xWindowRoot	    *root;
    xDepth	    *depth;
    xVisualType	    *visual;
    int		    screen = 0;
    int		    d;

    connSetup = (xConnSetup *) ConnectionInfo;
    vendor = (char *) connSetup + sizeof (xConnSetup);
    formats = (xPixmapFormat *) ((char *) vendor +
				 connSetup->nbytesVendor +
				 padlength[connSetup->nbytesVendor & 3]);
    root = (xWindowRoot *) ((char *) formats +
			    sizeof (xPixmapFormat) * screenInfo.numPixmapFormats);
    while (screen != pScreen->myNum)
    {
	depth = (xDepth *) ((char *) root + 
			    sizeof (xWindowRoot));
	for (d = 0; d < root->nDepths; d++)
	{
	    visual = (xVisualType *) ((char *) depth +
				      sizeof (xDepth));
	    depth = (xDepth *) ((char *) visual +
				depth->nVisuals * sizeof (xVisualType));
	}
	root = (xWindowRoot *) ((char *) depth);
	screen++;
    }
    root->pixWidth = pScreen->width;
    root->pixHeight = pScreen->height;
    root->mmWidth = pScreen->mmWidth;
    root->mmHeight = pScreen->mmHeight;
}

void
RRSendConfigNotify (ScreenPtr pScreen)
{
    WindowPtr	pWin = pScreen->root;
    xEvent	event;

    event.u.u.type = ConfigureNotify;
    event.u.configureNotify.window = pWin->drawable.id;
    event.u.configureNotify.aboveSibling = None;
    event.u.configureNotify.x = 0;
    event.u.configureNotify.y = 0;

    /* XXX xinerama stuff ? */
    
    event.u.configureNotify.width = pWin->drawable.width;
    event.u.configureNotify.height = pWin->drawable.height;
    event.u.configureNotify.borderWidth = wBorderWidth (pWin);
    event.u.configureNotify.override = pWin->overrideRedirect;
    DeliverEvents(pWin, &event, 1, NullWindow);
}

void
RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen)
{
    rrScrPriv (pScreen);
    xRRScreenChangeNotifyEvent	se;
    RRCrtcPtr	crtc = pScrPriv->numCrtcs ? pScrPriv->crtcs[0] : NULL;
    WindowPtr	pRoot = pScreen->root;
    
    se.type = RRScreenChangeNotify + RREventBase;
    se.rotation = (CARD8) (crtc ? crtc->rotation : RR_Rotate_0);
    se.timestamp = pScrPriv->lastSetTime.milliseconds;
    se.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
    se.root =  pRoot->drawable.id;
    se.window = pWin->drawable.id;
    se.subpixelOrder = PictureGetSubpixelOrder (pScreen);

    se.sizeID = RR10CurrentSizeID (pScreen);

    if (se.rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	se.widthInPixels = pScreen->height;
	se.heightInPixels = pScreen->width;
	se.widthInMillimeters = pScreen->mmHeight;
	se.heightInMillimeters = pScreen->mmWidth;
    } else {
	se.widthInPixels = pScreen->width;
	se.heightInPixels = pScreen->height;
	se.widthInMillimeters = pScreen->mmWidth;
	se.heightInMillimeters = pScreen->mmHeight;
    }

    WriteEventsToClient (client, 1, (xEvent *) &se);
}

/*
 * Notify the extension that the screen size has been changed.
 * The driver is responsible for calling this whenever it has changed
 * the size of the screen
 */
void
RRScreenSizeNotify (ScreenPtr	pScreen)
{
    rrScrPriv(pScreen);
    /*
     * Deliver ConfigureNotify events when root changes
     * pixel size
     */
    if (pScrPriv->width == pScreen->width &&
	pScrPriv->height == pScreen->height &&
	pScrPriv->mmWidth == pScreen->mmWidth &&
	pScrPriv->mmHeight == pScreen->mmHeight)
	return;
    
    pScrPriv->width = pScreen->width;
    pScrPriv->height = pScreen->height;
    pScrPriv->mmWidth = pScreen->mmWidth;
    pScrPriv->mmHeight = pScreen->mmHeight;
    pScrPriv->changed = TRUE;
/*    pScrPriv->sizeChanged = TRUE; */

    RRTellChanged (pScreen);
    RRSendConfigNotify (pScreen);
    RREditConnectionInfo (pScreen);
    
    RRPointerScreenConfigured (pScreen);
    /*
     * Fix pointer bounds and location
     */
    ScreenRestructured (pScreen);
}

/*
 * Request that the screen be resized
 */
Bool
RRScreenSizeSet (ScreenPtr  pScreen,
		 CARD16	    width,
		 CARD16	    height,
		 CARD32	    mmWidth,
		 CARD32	    mmHeight)
{
    rrScrPriv(pScreen);

#if RANDR_12_INTERFACE
    if (pScrPriv->rrScreenSetSize)
    {
	return (*pScrPriv->rrScreenSetSize) (pScreen,
					     width, height,
					     mmWidth, mmHeight);
    }
#endif
#if RANDR_10_INTERFACE
    if (pScrPriv->rrSetConfig)
    {
	return TRUE;	/* can't set size separately */
    }
#endif
    return FALSE;
}

/*
 * Retrieve valid screen size range
 */
int
ProcRRGetScreenSizeRange (ClientPtr client)
{
    REQUEST(xRRGetScreenSizeRangeReq);
    xRRGetScreenSizeRangeReply	rep;
    WindowPtr			pWin;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    int				rc;
    
    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    
    rep.type = X_Reply;
    rep.pad = 0;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    
    if (pScrPriv) 
    {
	if (!RRGetInfo (pScreen, FALSE))
	    return BadAlloc;
	rep.minWidth  = pScrPriv->minWidth;
	rep.minHeight = pScrPriv->minHeight;
	rep.maxWidth  = pScrPriv->maxWidth;
	rep.maxHeight = pScrPriv->maxHeight;
    }
    else
    {
	rep.maxWidth  = rep.minWidth  = pScreen->width;
	rep.maxHeight = rep.minHeight = pScreen->height;
    }
    if (client->swapped) 
    {
	int n;
	
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.minWidth, n);
	swaps(&rep.minHeight, n);
	swaps(&rep.maxWidth, n);
	swaps(&rep.maxHeight, n);
    }
    WriteToClient(client, sizeof(xRRGetScreenSizeRangeReply), (char *)&rep);
    return Success;
}

int
ProcRRSetScreenSize (ClientPtr client)
{
    REQUEST(xRRSetScreenSizeReq);
    WindowPtr		pWin;
    ScreenPtr		pScreen;
    rrScrPrivPtr	pScrPriv;
    int			i, rc;
    
    REQUEST_SIZE_MATCH(xRRSetScreenSizeReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    if (stuff->width < pScrPriv->minWidth || pScrPriv->maxWidth < stuff->width)
    {
	client->errorValue = stuff->width;
	return BadValue;
    }
    if (stuff->height < pScrPriv->minHeight || 
	pScrPriv->maxHeight < stuff->height)
    {
	client->errorValue = stuff->height;
	return BadValue;
    }
    for (i = 0; i < pScrPriv->numCrtcs; i++) 
    {
	RRCrtcPtr   crtc = pScrPriv->crtcs[i];
	RRModePtr   mode = crtc->mode;
	if (mode)
	{
	    int		source_width = mode->mode.width;
	    int		source_height = mode->mode.height;
	    Rotation	rotation = crtc->rotation;

	    if (rotation == RR_Rotate_90 || rotation == RR_Rotate_270)
	    {
		source_width = mode->mode.height;
		source_height = mode->mode.width;
	    }
	    
	    if (crtc->x + source_width > stuff->width ||
		crtc->y + source_height > stuff->height)
	    return BadMatch;
	}
    }
    if (stuff->widthInMillimeters == 0 || stuff->heightInMillimeters == 0)
    {
	client->errorValue = 0;
	return BadValue;
    }
    if (!RRScreenSizeSet (pScreen, 
			  stuff->width, stuff->height,
			  stuff->widthInMillimeters,
			  stuff->heightInMillimeters))
    {
	return BadMatch;
    }
    return Success;
}

static int
rrGetScreenResources(ClientPtr client, Bool query)
{
    REQUEST(xRRGetScreenResourcesReq);
    xRRGetScreenResourcesReply  rep;
    WindowPtr			pWin;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    CARD8			*extra;
    unsigned long		extraLen;
    int				i, n, rc, has_primary = 0;
    RRCrtc			*crtcs;
    RROutput			*outputs;
    xRRModeInfo			*modeinfos;
    CARD8			*names;
    
    REQUEST_SIZE_MATCH(xRRGetScreenResourcesReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    
    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    rep.pad = 0;
    
    if (query && pScrPriv)
	if (!RRGetInfo (pScreen, query))
	    return BadAlloc;

    if (!pScrPriv)
    {
	rep.type = X_Reply;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.timestamp = currentTime.milliseconds;
	rep.configTimestamp = currentTime.milliseconds;
	rep.nCrtcs = 0;
	rep.nOutputs = 0;
	rep.nModes = 0;
	rep.nbytesNames = 0;
	extra = NULL;
	extraLen = 0;
    }
    else
    {
	RRModePtr   *modes;
	int	    num_modes;

	modes = RRModesForScreen (pScreen, &num_modes);
	if (!modes)
	    return BadAlloc;
	
	rep.type = X_Reply;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.timestamp = pScrPriv->lastSetTime.milliseconds;
	rep.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
	rep.nCrtcs = pScrPriv->numCrtcs;
	rep.nOutputs = pScrPriv->numOutputs;
	rep.nModes = num_modes;
	rep.nbytesNames = 0;

	for (i = 0; i < num_modes; i++)
	    rep.nbytesNames += modes[i]->mode.nameLength;

	rep.length = (pScrPriv->numCrtcs + 
		      pScrPriv->numOutputs + 
		      num_modes * bytes_to_int32(SIZEOF(xRRModeInfo)) +
		      bytes_to_int32(rep.nbytesNames));
	
	extraLen = rep.length << 2;
	if (extraLen)
	{
	    extra = malloc(extraLen);
	    if (!extra)
	    {
		free(modes);
		return BadAlloc;
	    }
	}
	else
	    extra = NULL;

	crtcs = (RRCrtc *) extra;
	outputs = (RROutput *) (crtcs + pScrPriv->numCrtcs);
	modeinfos = (xRRModeInfo *) (outputs + pScrPriv->numOutputs);
	names = (CARD8 *) (modeinfos + num_modes);

	if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc)
	{
	    has_primary = 1;
	    crtcs[0] = pScrPriv->primaryOutput->crtc->id;
	    if (client->swapped)
		swapl (&crtcs[0], n);
	}
	
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	{
	    if (has_primary &&
		pScrPriv->primaryOutput->crtc == pScrPriv->crtcs[i])
	    {
		has_primary = 0;
		continue;
	    }
	    crtcs[i + has_primary] = pScrPriv->crtcs[i]->id;
	    if (client->swapped)
		swapl (&crtcs[i + has_primary], n);
	}
	
	for (i = 0; i < pScrPriv->numOutputs; i++)
	{
	    outputs[i] = pScrPriv->outputs[i]->id;
	    if (client->swapped)
		swapl (&outputs[i], n);
	}
	
	for (i = 0; i < num_modes; i++)
	{
	    RRModePtr	mode = modes[i];
	    modeinfos[i] = mode->mode;
	    if (client->swapped)
	    {
		swapl (&modeinfos[i].id, n);
		swaps (&modeinfos[i].width, n);
		swaps (&modeinfos[i].height, n);
		swapl (&modeinfos[i].dotClock, n);
		swaps (&modeinfos[i].hSyncStart, n);
		swaps (&modeinfos[i].hSyncEnd, n);
		swaps (&modeinfos[i].hTotal, n);
		swaps (&modeinfos[i].hSkew, n);
		swaps (&modeinfos[i].vSyncStart, n);
		swaps (&modeinfos[i].vSyncEnd, n);
		swaps (&modeinfos[i].vTotal, n);
		swaps (&modeinfos[i].nameLength, n);
		swapl (&modeinfos[i].modeFlags, n);
	    }
	    memcpy (names, mode->name, 
		    mode->mode.nameLength);
	    names += mode->mode.nameLength;
	}
        free(modes);
	assert (bytes_to_int32((char *) names - (char *) extra) == rep.length);
    }
    
    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swapl(&rep.configTimestamp, n);
	swaps(&rep.nCrtcs, n);
	swaps(&rep.nOutputs, n);
	swaps(&rep.nModes, n);
	swaps(&rep.nbytesNames, n);
    }
    WriteToClient(client, sizeof(xRRGetScreenResourcesReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	free(extra);
    }
    return Success;
}

int
ProcRRGetScreenResources (ClientPtr client)
{
    return rrGetScreenResources(client, TRUE);
}
    
int
ProcRRGetScreenResourcesCurrent (ClientPtr client)
{
    return rrGetScreenResources(client, FALSE);
}

typedef struct _RR10Data {
    RRScreenSizePtr sizes;
    int		    nsize;
    int		    nrefresh;
    int		    size;
    CARD16	    refresh;
} RR10DataRec, *RR10DataPtr;

/*
 * Convert 1.2 monitor data into 1.0 screen data
 */
static RR10DataPtr
RR10GetData (ScreenPtr pScreen, RROutputPtr output)
{
    RR10DataPtr	    data;
    RRScreenSizePtr size;
    int		    nmode = output->numModes + output->numUserModes;
    int		    o, os, l, r;
    RRScreenRatePtr refresh;
    CARD16	    vRefresh;
    RRModePtr	    mode;
    Bool	    *used;

    /* Make sure there is plenty of space for any combination */
    data = malloc (sizeof (RR10DataRec) + 
		   sizeof (RRScreenSize) * nmode + 
		   sizeof (RRScreenRate) * nmode +
		   sizeof (Bool) * nmode);
    if (!data)
	return NULL;
    size = (RRScreenSizePtr) (data + 1);
    refresh = (RRScreenRatePtr) (size + nmode);
    used = (Bool *) (refresh + nmode);
    memset (used, '\0', sizeof (Bool) * nmode);
    data->sizes = size;
    data->nsize = 0;
    data->nrefresh = 0;
    data->size = 0;
    data->refresh = 0;
    
    /*
     * find modes not yet listed
     */
    for (o = 0; o < output->numModes + output->numUserModes; o++)
    {
	if (used[o]) continue;
	
	if (o < output->numModes)
	    mode = output->modes[o];
	else
	    mode = output->userModes[o - output->numModes];
	
	l = data->nsize;
	size[l].id = data->nsize;
	size[l].width = mode->mode.width;
	size[l].height = mode->mode.height;
	if (output->mmWidth && output->mmHeight) {
	    size[l].mmWidth = output->mmWidth;
	    size[l].mmHeight = output->mmHeight;
	} else {
	    size[l].mmWidth = pScreen->mmWidth;
	    size[l].mmHeight = pScreen->mmHeight;
	}
	size[l].nRates = 0;
	size[l].pRates = &refresh[data->nrefresh];
	data->nsize++;
	
	/*
	 * Find all modes with matching size
	 */
	for (os = o; os < output->numModes + output->numUserModes; os++)
	{
	    if (os < output->numModes)
		mode = output->modes[os];
	    else
		mode = output->userModes[os - output->numModes];
	    if (mode->mode.width == size[l].width &&
		mode->mode.height == size[l].height)
	    {
		vRefresh = RRVerticalRefresh (&mode->mode);
		used[os] = TRUE;
		
		for (r = 0; r < size[l].nRates; r++)
		    if (vRefresh == size[l].pRates[r].rate)
			break;
		if (r == size[l].nRates)
		{
		    size[l].pRates[r].rate = vRefresh;
		    size[l].pRates[r].mode = mode;
		    size[l].nRates++;
		    data->nrefresh++;
		}
		if (mode == output->crtc->mode)
		{
		    data->size = l;
		    data->refresh = vRefresh;
		}
	    }
	}
    }
    return data;
}

int
ProcRRGetScreenInfo (ClientPtr client)
{
    REQUEST(xRRGetScreenInfoReq);
    xRRGetScreenInfoReply   rep;
    WindowPtr	    	    pWin;
    int			    n, rc;
    ScreenPtr		    pScreen;
    rrScrPrivPtr	    pScrPriv;
    CARD8		    *extra;
    unsigned long	    extraLen;
    RROutputPtr		    output;

    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    rep.pad = 0;
    
    if (pScrPriv)
	if (!RRGetInfo (pScreen, TRUE))
	    return BadAlloc;

    output = RRFirstOutput (pScreen);
    
    if (!pScrPriv || !output)
    {
	rep.type = X_Reply;
	rep.setOfRotations = RR_Rotate_0;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.root = pWin->drawable.pScreen->root->drawable.id;
	rep.timestamp = currentTime.milliseconds;
	rep.configTimestamp = currentTime.milliseconds;
	rep.nSizes = 0;
	rep.sizeID = 0;
	rep.rotation = RR_Rotate_0;
	rep.rate = 0;
	rep.nrateEnts = 0;
	extra = 0;
	extraLen = 0;
    }
    else
    {
	int			i, j;
	xScreenSizes		*size;
	CARD16			*rates;
	CARD8			*data8;
	Bool			has_rate = RRClientKnowsRates (client);
	RR10DataPtr		pData;
	RRScreenSizePtr		pSize;
    
	pData = RR10GetData (pScreen, output);
	if (!pData)
	    return BadAlloc;
	
	rep.type = X_Reply;
	rep.setOfRotations = output->crtc->rotations;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.root = pWin->drawable.pScreen->root->drawable.id;
	rep.timestamp = pScrPriv->lastSetTime.milliseconds;
	rep.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
	rep.rotation = output->crtc->rotation;
	rep.nSizes = pData->nsize;
        rep.nrateEnts = pData->nrefresh + pData->nsize;
	rep.sizeID = pData->size;
	rep.rate = pData->refresh;

	extraLen = rep.nSizes * sizeof (xScreenSizes);
	if (has_rate)
		extraLen += rep.nrateEnts * sizeof (CARD16);

	if (extraLen)
	{
	    extra = (CARD8 *) malloc(extraLen);
	    if (!extra)
	    {
		free(pData);
		return BadAlloc;
	    }
	}
	else
	    extra = NULL;

	/*
	 * First comes the size information
	 */
	size = (xScreenSizes *) extra;
	rates = (CARD16 *) (size + rep.nSizes);
	for (i = 0; i < pData->nsize; i++)
	{
	    pSize = &pData->sizes[i];
	    size->widthInPixels = pSize->width;
	    size->heightInPixels = pSize->height;
	    size->widthInMillimeters = pSize->mmWidth;
	    size->heightInMillimeters = pSize->mmHeight;
	    if (client->swapped)
	    {
	        swaps (&size->widthInPixels, n);
	        swaps (&size->heightInPixels, n);
	        swaps (&size->widthInMillimeters, n);
	        swaps (&size->heightInMillimeters, n);
	    }
	    size++;
	    if (has_rate)
	    {
		*rates = pSize->nRates;
		if (client->swapped)
		{
		    swaps (rates, n);
		}
		rates++;
		for (j = 0; j < pSize->nRates; j++)
		{
		    *rates = pSize->pRates[j].rate;
		    if (client->swapped)
		    {
			swaps (rates, n);
		    }
		    rates++;
		}
	    }
	}
        free(pData);
	
	data8 = (CARD8 *) rates;

	if (data8 - (CARD8 *) extra != extraLen)
	    FatalError ("RRGetScreenInfo bad extra len %ld != %ld\n",
			(unsigned long)(data8 - (CARD8 *) extra), extraLen);
	rep.length =  bytes_to_int32(extraLen);
    }
    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swaps(&rep.rotation, n);
	swaps(&rep.nSizes, n);
	swaps(&rep.sizeID, n);
	swaps(&rep.rate, n);
	swaps(&rep.nrateEnts, n);
    }
    WriteToClient(client, sizeof(xRRGetScreenInfoReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	free(extra);
    }
    return Success;
}

int
ProcRRSetScreenConfig (ClientPtr client)
{
    REQUEST(xRRSetScreenConfigReq);
    xRRSetScreenConfigReply rep;
    DrawablePtr		    pDraw;
    int			    n, rc;
    ScreenPtr		    pScreen;
    rrScrPrivPtr	    pScrPriv;
    TimeStamp		    time;
    int			    i;
    Rotation		    rotation;
    int			    rate;
    Bool		    has_rate;
    RROutputPtr		    output;
    RRCrtcPtr		    crtc;
    RRModePtr		    mode;
    RR10DataPtr		    pData = NULL;
    RRScreenSizePtr    	    pSize;
    int			    width, height;
    
    UpdateCurrentTime ();

    if (RRClientKnowsRates (client))
    {
	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
	has_rate = TRUE;
    }
    else
    {
	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
	has_rate = FALSE;
    }
    
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixWriteAccess);
    if (rc != Success)
	return rc;

    pScreen = pDraw->pScreen;

    pScrPriv = rrGetScrPriv(pScreen);
    
    time = ClientTimeToServerTime(stuff->timestamp);
    
    if (!pScrPriv)
    {
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
    }
    if (!RRGetInfo (pScreen, FALSE))
	return BadAlloc;
    
    output = RRFirstOutput (pScreen);
    if (!output)
    {
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
    }

    crtc = output->crtc;

    /*
     * If the client's config timestamp is not the same as the last config
     * timestamp, then the config information isn't up-to-date and
     * can't even be validated.
     *
     * Note that the client only knows about the milliseconds part of the
     * timestamp, so using CompareTimeStamps here would cause randr to suddenly
     * stop working after several hours have passed (freedesktop bug #6502).
     */
    if (stuff->configTimestamp != pScrPriv->lastConfigTime.milliseconds)
    {
	rep.status = RRSetConfigInvalidConfigTime;
	goto sendReply;
    }
    
    pData = RR10GetData (pScreen, output);
    if (!pData)
	return BadAlloc;
    
    if (stuff->sizeID >= pData->nsize)
    {
	/*
	 * Invalid size ID
	 */
	client->errorValue = stuff->sizeID;
	free(pData);
	return BadValue;
    }
    pSize = &pData->sizes[stuff->sizeID];
    
    /*
     * Validate requested rotation
     */
    rotation = (Rotation) stuff->rotation;

    /* test the rotation bits only! */
    switch (rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_90:
    case RR_Rotate_180:
    case RR_Rotate_270:
	break;
    default:
	/*
	 * Invalid rotation
	 */
	client->errorValue = stuff->rotation;
	free(pData);
	return BadValue;
    }

    if ((~crtc->rotations) & rotation)
    {
	/*
	 * requested rotation or reflection not supported by screen
	 */
	client->errorValue = stuff->rotation;
	free(pData);
	return BadMatch;
    }

    /*
     * Validate requested refresh
     */
    if (has_rate)
	rate = (int) stuff->rate;
    else
	rate = 0;

    if (rate)
    {
	for (i = 0; i < pSize->nRates; i++)
	{
	    if (pSize->pRates[i].rate == rate)
		break;
	}
	if (i == pSize->nRates)
	{
	    /*
	     * Invalid rate
	     */
	    client->errorValue = rate;
	    free(pData);
	    return BadValue;
	}
	mode = pSize->pRates[i].mode;
    }
    else
	mode = pSize->pRates[0].mode;
    
    /*
     * Make sure the requested set-time is not older than
     * the last set-time
     */
    if (CompareTimeStamps (time, pScrPriv->lastSetTime) < 0)
    {
	rep.status = RRSetConfigInvalidTime;
	goto sendReply;
    }

    /*
     * If the screen size is changing, adjust all of the other outputs
     * to fit the new size, mirroring as much as possible
     */
    width = mode->mode.width;
    height = mode->mode.height;
    if (width < pScrPriv->minWidth || pScrPriv->maxWidth < width) {
	client->errorValue = width;
	free(pData);
	return BadValue;
    }
    if (height < pScrPriv->minHeight || pScrPriv->maxHeight < height) {
	client->errorValue = height;
	free(pData);
	return BadValue;
    }

    if (rotation & (RR_Rotate_90|RR_Rotate_270))
    {
	width = mode->mode.height;
	height = mode->mode.width;
    }

    if (width != pScreen->width || height != pScreen->height)
    {
	int	c;

	for (c = 0; c < pScrPriv->numCrtcs; c++)
	{
	    if (!RRCrtcSet (pScrPriv->crtcs[c], NULL, 0, 0, RR_Rotate_0,
			    0, NULL))
	    {
		rep.status = RRSetConfigFailed;
		/* XXX recover from failure */
		goto sendReply;
	    }
	}
	if (!RRScreenSizeSet (pScreen, width, height,
			      pScreen->mmWidth, pScreen->mmHeight))
	{
	    rep.status = RRSetConfigFailed;
	    /* XXX recover from failure */
	    goto sendReply;
	}
    }

    if (!RRCrtcSet (crtc, mode, 0, 0, stuff->rotation, 1, &output))
	rep.status = RRSetConfigFailed;
    else {
	pScrPriv->lastSetTime = time;
	rep.status = RRSetConfigSuccess;
    }

    /*
     * XXX Configure other crtcs to mirror as much as possible
     */
    
sendReply:
    
    free(pData);

    rep.type = X_Reply;
    /* rep.status has already been filled in */
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rep.newTimestamp = pScrPriv->lastSetTime.milliseconds;
    rep.newConfigTimestamp = pScrPriv->lastConfigTime.milliseconds;
    rep.root = pDraw->pScreen->root->drawable.id;

    if (client->swapped) 
    {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.newTimestamp, n);
	swapl(&rep.newConfigTimestamp, n);
	swapl(&rep.root, n);
    }
    WriteToClient(client, sizeof(xRRSetScreenConfigReply), (char *)&rep);

    return Success;
}

static CARD16
RR10CurrentSizeID (ScreenPtr pScreen)
{
    CARD16	sizeID = 0xffff;
    RROutputPtr output = RRFirstOutput (pScreen);
    
    if (output)
    {
	RR10DataPtr data = RR10GetData (pScreen, output);
	if (data)
	{
	    int i;
	    for (i = 0; i < data->nsize; i++)
		if (data->sizes[i].width == pScreen->width &&
		    data->sizes[i].height == pScreen->height)
		{
		    sizeID = (CARD16) i;
		    break;
		}
	    free(data);
	}
    }
    return sizeID;
}
/*
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"

static int
SProcRRQueryVersion (ClientPtr client)
{
    register int n;
    REQUEST(xRRQueryVersionReq);

    swaps(&stuff->length, n);
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetScreenInfo (ClientPtr client)
{
    register int n;
    REQUEST(xRRGetScreenInfoReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRSetScreenConfig (ClientPtr client)
{
    register int n;
    REQUEST(xRRSetScreenConfigReq);

    if (RRClientKnowsRates (client))
    {
	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
	swaps (&stuff->rate, n);
    }
    else
    {
	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
    }
    
    swaps(&stuff->length, n);
    swapl(&stuff->drawable, n);
    swapl(&stuff->timestamp, n);
    swaps(&stuff->sizeID, n);
    swaps(&stuff->rotation, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRSelectInput (ClientPtr client)
{
    register int n;
    REQUEST(xRRSelectInputReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    swaps(&stuff->enable, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetScreenSizeRange (ClientPtr client)
{
    int n;
    REQUEST(xRRGetScreenSizeRangeReq);

    REQUEST_SIZE_MATCH(xRRGetScreenSizeRangeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRSetScreenSize (ClientPtr client)
{
    int n;
    REQUEST(xRRSetScreenSizeReq);

    REQUEST_SIZE_MATCH(xRRSetScreenSizeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    swapl(&stuff->widthInMillimeters, n);
    swapl(&stuff->heightInMillimeters, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetScreenResources (ClientPtr client)
{
    int n;
    REQUEST(xRRGetScreenResourcesReq);

    REQUEST_SIZE_MATCH(xRRGetScreenResourcesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetOutputInfo (ClientPtr client)
{
    int n;
    REQUEST(xRRGetOutputInfoReq);

    REQUEST_SIZE_MATCH(xRRGetOutputInfoReq);
    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    swapl(&stuff->configTimestamp, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRListOutputProperties (ClientPtr client)
{
    int n;
    REQUEST(xRRListOutputPropertiesReq);

    REQUEST_SIZE_MATCH(xRRListOutputPropertiesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRQueryOutputProperty (ClientPtr client)
{
    int n;
    REQUEST(xRRQueryOutputPropertyReq);

    REQUEST_SIZE_MATCH(xRRQueryOutputPropertyReq);
    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    swapl(&stuff->property, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRConfigureOutputProperty (ClientPtr client)
{
    int n;
    REQUEST(xRRConfigureOutputPropertyReq);

    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    swapl(&stuff->property, n);
    SwapRestL(stuff);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRChangeOutputProperty (ClientPtr client)
{
    int n;
    REQUEST(xRRChangeOutputPropertyReq);

    REQUEST_AT_LEAST_SIZE (xRRChangeOutputPropertyReq);
    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->nUnits, n);
    switch(stuff->format) {
	case 8:
	    break;
	case 16:
	    SwapRestS(stuff);
	    break;
	case 32:
	    SwapRestL(stuff);
	    break;
	default:
	    client->errorValue = stuff->format;
	    return BadValue;
    }
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRDeleteOutputProperty (ClientPtr client)
{
    int n;
    REQUEST(xRRDeleteOutputPropertyReq);
    
    REQUEST_SIZE_MATCH(xRRDeleteOutputPropertyReq);
    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    swapl(&stuff->property, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetOutputProperty (ClientPtr client)
{
    int n;
    REQUEST(xRRGetOutputPropertyReq);

    REQUEST_SIZE_MATCH(xRRGetOutputPropertyReq);
    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->longOffset, n);
    swapl(&stuff->longLength, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRCreateMode (ClientPtr client)
{
    int n;
    xRRModeInfo *modeinfo;
    REQUEST(xRRCreateModeReq);

    REQUEST_AT_LEAST_SIZE(xRRCreateModeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->window, n);

    modeinfo = &stuff->modeInfo;
    swapl(&modeinfo->id, n);
    swaps(&modeinfo->width, n);
    swaps(&modeinfo->height, n);
    swapl(&modeinfo->dotClock, n);
    swaps(&modeinfo->hSyncStart, n);
    swaps(&modeinfo->hSyncEnd, n);
    swaps(&modeinfo->hTotal, n);
    swaps(&modeinfo->vSyncStart, n);
    swaps(&modeinfo->vSyncEnd, n);
    swaps(&modeinfo->vTotal, n);
    swaps(&modeinfo->nameLength, n);
    swapl(&modeinfo->modeFlags, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRDestroyMode (ClientPtr client)
{
    int n;
    REQUEST(xRRDestroyModeReq);

    REQUEST_SIZE_MATCH(xRRDestroyModeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->mode, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRAddOutputMode (ClientPtr client)
{
    int n;
    REQUEST(xRRAddOutputModeReq);

    REQUEST_SIZE_MATCH(xRRAddOutputModeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    swapl(&stuff->mode, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRDeleteOutputMode (ClientPtr client)
{
    int n;
    REQUEST(xRRDeleteOutputModeReq);

    REQUEST_SIZE_MATCH(xRRDeleteOutputModeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->output, n);
    swapl(&stuff->mode, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetCrtcInfo (ClientPtr client)
{
    int n;
    REQUEST(xRRGetCrtcInfoReq);

    REQUEST_SIZE_MATCH(xRRGetCrtcInfoReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    swapl(&stuff->configTimestamp, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRSetCrtcConfig (ClientPtr client)
{
    int n;
    REQUEST(xRRSetCrtcConfigReq);

    REQUEST_AT_LEAST_SIZE(xRRSetCrtcConfigReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    swapl(&stuff->timestamp, n);
    swapl(&stuff->configTimestamp, n);
    swaps(&stuff->x, n);
    swaps(&stuff->y, n);
    swapl(&stuff->mode, n);
    swaps(&stuff->rotation, n);
    SwapRestL(stuff);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetCrtcGammaSize (ClientPtr client)
{
    int n;
    REQUEST(xRRGetCrtcGammaSizeReq);

    REQUEST_SIZE_MATCH(xRRGetCrtcGammaSizeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetCrtcGamma (ClientPtr client)
{
    int n;
    REQUEST(xRRGetCrtcGammaReq);

    REQUEST_SIZE_MATCH(xRRGetCrtcGammaReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRSetCrtcGamma (ClientPtr client)
{
    int n;
    REQUEST(xRRSetCrtcGammaReq);

    REQUEST_AT_LEAST_SIZE(xRRSetCrtcGammaReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    swaps(&stuff->size, n);
    SwapRestS(stuff);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRSetCrtcTransform (ClientPtr client)
{
    int n, nparams;
    char *filter;
    CARD32 *params;
    REQUEST(xRRSetCrtcTransformReq);

    REQUEST_AT_LEAST_SIZE(xRRSetCrtcTransformReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    SwapLongs((CARD32 *)&stuff->transform, bytes_to_int32(sizeof(xRenderTransform)));
    swaps(&stuff->nbytesFilter, n);
    filter = (char *)(stuff + 1);
    params = (CARD32 *) (filter + pad_to_int32(stuff->nbytesFilter));
    nparams = ((CARD32 *) stuff + client->req_len) - params;
    if (nparams < 0)
	return BadLength;

    SwapLongs(params, nparams);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetCrtcTransform (ClientPtr client)
{
    int n;
    REQUEST(xRRGetCrtcTransformReq);

    REQUEST_SIZE_MATCH(xRRGetCrtcTransformReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRGetPanning (ClientPtr client)
{
    int n;
    REQUEST(xRRGetPanningReq);
    
    REQUEST_SIZE_MATCH(xRRGetPanningReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRSetPanning (ClientPtr client)
{
    int n;
    REQUEST(xRRSetPanningReq);
    
    REQUEST_SIZE_MATCH(xRRSetPanningReq);
    swaps(&stuff->length, n);
    swapl(&stuff->crtc, n);
    swapl(&stuff->timestamp, n);
    swaps(&stuff->left, n);
    swaps(&stuff->top, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    swaps(&stuff->track_left, n);
    swaps(&stuff->track_top, n);
    swaps(&stuff->track_width, n);
    swaps(&stuff->track_height, n);
    swaps(&stuff->border_left, n);
    swaps(&stuff->border_top, n);
    swaps(&stuff->border_right, n);
    swaps(&stuff->border_bottom, n);
    return (*ProcRandrVector[stuff->randrReqType]) (client);
}

static int
SProcRRSetOutputPrimary (ClientPtr client)
{
    int n;
    REQUEST(xRRSetOutputPrimaryReq);

    REQUEST_SIZE_MATCH(xRRSetOutputPrimaryReq);
    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    swapl(&stuff->output, n);
    return ProcRandrVector[stuff->randrReqType](client);
}

static int
SProcRRGetOutputPrimary (ClientPtr client)
{
    int n;
    REQUEST(xRRGetOutputPrimaryReq);

    REQUEST_SIZE_MATCH(xRRGetOutputPrimaryReq);
    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    return ProcRandrVector[stuff->randrReqType](client);
}

int (*SProcRandrVector[RRNumberRequests])(ClientPtr) = {
    SProcRRQueryVersion,	/* 0 */
/* we skip 1 to make old clients fail pretty immediately */
    NULL,			/* 1 SProcRandrOldGetScreenInfo */
/* V1.0 apps share the same set screen config request id */
    SProcRRSetScreenConfig,	/* 2 */
    NULL,			/* 3 SProcRandrOldScreenChangeSelectInput */
/* 3 used to be ScreenChangeSelectInput; deprecated */
    SProcRRSelectInput,		/* 4 */
    SProcRRGetScreenInfo,    	/* 5 */
/* V1.2 additions */
    SProcRRGetScreenSizeRange,	/* 6 */
    SProcRRSetScreenSize,	/* 7 */
    SProcRRGetScreenResources,	/* 8 */
    SProcRRGetOutputInfo,	/* 9 */
    SProcRRListOutputProperties,/* 10 */
    SProcRRQueryOutputProperty,	/* 11 */
    SProcRRConfigureOutputProperty,  /* 12 */
    SProcRRChangeOutputProperty,/* 13 */
    SProcRRDeleteOutputProperty,/* 14 */
    SProcRRGetOutputProperty,	/* 15 */
    SProcRRCreateMode,		/* 16 */
    SProcRRDestroyMode,		/* 17 */
    SProcRRAddOutputMode,	/* 18 */
    SProcRRDeleteOutputMode,	/* 19 */
    SProcRRGetCrtcInfo,		/* 20 */
    SProcRRSetCrtcConfig,	/* 21 */
    SProcRRGetCrtcGammaSize,	/* 22 */
    SProcRRGetCrtcGamma,	/* 23 */
    SProcRRSetCrtcGamma,	/* 24 */
/* V1.3 additions */
    SProcRRGetScreenResources,	/* 25 GetScreenResourcesCurrent */
    SProcRRSetCrtcTransform,	/* 26 */
    SProcRRGetCrtcTransform,	/* 27 */
    SProcRRGetPanning,		/* 28 */
    SProcRRSetPanning,		/* 29 */
    SProcRRSetOutputPrimary,	/* 30 */
    SProcRRGetOutputPrimary,	/* 31 */
};

/*
 * Copyright © 2007 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"
#include "rrtransform.h"

void
RRTransformInit (RRTransformPtr transform)
{
    pixman_transform_init_identity (&transform->transform);
    pixman_f_transform_init_identity (&transform->f_transform);
    pixman_f_transform_init_identity (&transform->f_inverse);
    transform->filter = NULL;
    transform->params = NULL;
    transform->nparams = 0;
}

void
RRTransformFini (RRTransformPtr transform)
{
    free(transform->params);
}

Bool
RRTransformEqual (RRTransformPtr a, RRTransformPtr b)
{
    if (a && pixman_transform_is_identity (&a->transform))
	a = NULL;
    if (b && pixman_transform_is_identity (&b->transform))
	b = NULL;
    if (a == NULL && b == NULL)
	return TRUE;
    if (a == NULL || b == NULL)
	return FALSE;
    if (memcmp (&a->transform, &b->transform, sizeof (a->transform)) != 0)
	return FALSE;
    if (a->filter != b->filter)
	return FALSE;
    if (a->nparams != b->nparams)
	return FALSE;
    if (memcmp (a->params, b->params, a->nparams * sizeof (xFixed)) != 0)
	return FALSE;
    return TRUE;
}

Bool
RRTransformSetFilter (RRTransformPtr	dst,
		      PictFilterPtr	filter,
		      xFixed		*params,
		      int		nparams,
		      int		width,
		      int		height)
{
    xFixed  *new_params;

    if (nparams)
    {
	new_params = malloc(nparams * sizeof (xFixed));
	if (!new_params)
	    return FALSE;
	memcpy (new_params, params, nparams * sizeof (xFixed));
    }
    else
	new_params = NULL;
    free(dst->params);
    dst->filter = filter;
    dst->params = new_params;
    dst->nparams = nparams;
    dst->width = width;
    dst->height = height;
    return TRUE;
}

Bool
RRTransformCopy (RRTransformPtr dst, RRTransformPtr src)
{
    if (src && pixman_transform_is_identity (&src->transform))
	src = NULL;

    if (src)
    {
	if (!RRTransformSetFilter (dst, src->filter,
				   src->params, src->nparams, src->width, src->height))
	    return FALSE;
	dst->transform = src->transform;
	dst->f_transform = src->f_transform;
	dst->f_inverse = src->f_inverse;
    }
    else
    {
	if (!RRTransformSetFilter (dst, NULL, NULL, 0, 0, 0))
	    return FALSE;
	pixman_transform_init_identity (&dst->transform);
	pixman_f_transform_init_identity (&dst->f_transform);
	pixman_f_transform_init_identity (&dst->f_inverse);
    }
    return TRUE;
}

#define F(x)	IntToxFixed(x)

static void
RRTransformRescale(struct pixman_f_transform *f_transform, double limit)
{
    double max = 0, v, scale;
    int i, j;

    for (j = 0; j < 3; j++)
	for (i = 0; i < 3; i++)
	    if ((v = abs (f_transform->m[j][i])) > max)
		max = v;
    scale = limit / max;
    for (j = 0; j < 3; j++)
	for (i = 0; i < 3; i++)
	    f_transform->m[j][i] *= scale;
}

/*
 * Compute the complete transformation matrix including
 * client-specified transform, rotation/reflection values and the crtc 
 * offset.
 *
 * Return TRUE if the resulting transform is not a simple translation.
 */
Bool
RRTransformCompute (int			    x,
		    int			    y,
		    int			    width,
		    int			    height,
		    Rotation		    rotation,
		    RRTransformPtr	    rr_transform,

		    PictTransformPtr	    transform,
		    struct pixman_f_transform *f_transform,
		    struct pixman_f_transform *f_inverse)
{
    PictTransform	    t_transform, inverse;
    struct pixman_f_transform tf_transform, tf_inverse;
    Bool		    overflow = FALSE;

    if (!transform) transform = &t_transform;
    if (!f_transform) f_transform = &tf_transform;
    if (!f_inverse) f_inverse = &tf_inverse;

    pixman_transform_init_identity (transform);
    pixman_transform_init_identity (&inverse);
    pixman_f_transform_init_identity (f_transform);
    pixman_f_transform_init_identity (f_inverse);
    if (rotation != RR_Rotate_0)
    {
	double	f_rot_cos, f_rot_sin, f_rot_dx, f_rot_dy;
	double	f_scale_x, f_scale_y, f_scale_dx, f_scale_dy;
	xFixed	rot_cos, rot_sin, rot_dx, rot_dy;
	xFixed	scale_x, scale_y, scale_dx, scale_dy;

	/* rotation */
	switch (rotation & 0xf) {
	default:
	case RR_Rotate_0:
	    f_rot_cos = 1;	    f_rot_sin = 0;
	    f_rot_dx  = 0;	    f_rot_dy  = 0;
	    rot_cos = F ( 1);	    rot_sin = F ( 0);
	    rot_dx  = F ( 0);	    rot_dy  = F ( 0);
	    break;
	case RR_Rotate_90:
	    f_rot_cos = 0;	    f_rot_sin = 1;
	    f_rot_dx  = height;	    f_rot_dy  = 0;
	    rot_cos = F ( 0);	    rot_sin = F ( 1);
	    rot_dx =  F ( height);  rot_dy  = F (0);
	    break;
	case RR_Rotate_180:
	    f_rot_cos = -1;	    f_rot_sin = 0;
	    f_rot_dx  = width;	    f_rot_dy  = height;
	    rot_cos = F (-1);	    rot_sin = F ( 0);
	    rot_dx  = F (width);   rot_dy  = F ( height);
	    break;
	case RR_Rotate_270:
	    f_rot_cos = 0;	    f_rot_sin = -1;
	    f_rot_dx  = 0;	    f_rot_dy  = width;
	    rot_cos = F ( 0);	    rot_sin = F (-1);
	    rot_dx  = F ( 0);	    rot_dy  = F ( width);
	    break;
	}
	
	pixman_transform_rotate (transform, &inverse, rot_cos, rot_sin);
	pixman_transform_translate (transform, &inverse, rot_dx, rot_dy);
	pixman_f_transform_rotate (f_transform, f_inverse, f_rot_cos, f_rot_sin);
	pixman_f_transform_translate (f_transform, f_inverse, f_rot_dx, f_rot_dy);

	/* reflection */
	f_scale_x = 1;
	f_scale_dx = 0;
	f_scale_y = 1;
	f_scale_dy = 0;
	scale_x = F (1);
	scale_dx = 0;
	scale_y = F (1);
	scale_dy = 0;
	if (rotation & RR_Reflect_X)
	{
	    f_scale_x = -1;
	    scale_x = F(-1);
	    if (rotation & (RR_Rotate_0|RR_Rotate_180)) {
		f_scale_dx = width;
		scale_dx = F(width);
	    } else {
		f_scale_dx = height;
		scale_dx = F(height);
	    }
	}
	if (rotation & RR_Reflect_Y)
	{
	    f_scale_y = -1;
	    scale_y = F(-1);
	    if (rotation & (RR_Rotate_0|RR_Rotate_180)) {
		f_scale_dy = height;
		scale_dy = F(height);
	    } else {
		f_scale_dy = width;
		scale_dy = F(width);
	    }
	}
	
	pixman_transform_scale (transform, &inverse, scale_x, scale_y);
	pixman_f_transform_scale (f_transform, f_inverse, f_scale_x, f_scale_y);
	pixman_transform_translate (transform, &inverse, scale_dx, scale_dy);
	pixman_f_transform_translate (f_transform, f_inverse, f_scale_dx, f_scale_dy);
    }
    
#ifdef RANDR_12_INTERFACE
    if (rr_transform)
    {
        if (!pixman_transform_multiply (transform, &rr_transform->transform, transform))
	    overflow = TRUE;
	pixman_f_transform_multiply (f_transform, &rr_transform->f_transform, f_transform);
	pixman_f_transform_multiply (f_inverse, f_inverse, &rr_transform->f_inverse);
    }
#endif
    /*
     * Compute the class of the resulting transform
     */
    if (!overflow && pixman_transform_is_identity (transform))
    {
	pixman_transform_init_translate (transform, F ( x), F ( y));

	pixman_f_transform_init_translate (f_transform,  x,  y);
	pixman_f_transform_init_translate (f_inverse,   -x, -y);
	return FALSE;
    }
    else
    {
	pixman_f_transform_translate (f_transform, f_inverse, x, y);
	if (!pixman_transform_translate (transform, &inverse, F(x), F(y)))
	    overflow = TRUE;
	if (overflow)
	{
	    struct pixman_f_transform f_scaled;
	    f_scaled = *f_transform;
	    RRTransformRescale(&f_scaled, 16384.0);
	    pixman_transform_from_pixman_f_transform(transform, &f_scaled);
	}
	return TRUE;
    }
}
/*
 * Copyright © 2007 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifndef _RRTRANSFORM_H_
#define _RRTRANSFORM_H_

#include <X11/extensions/randr.h>
#include "picturestr.h"

typedef struct _rrTransform	RRTransformRec, *RRTransformPtr;

struct _rrTransform {
    PictTransform   transform;
    struct pict_f_transform f_transform;
    struct pict_f_transform f_inverse;
    PictFilterPtr   filter;
    xFixed	    *params;
    int		    nparams;
    int		    width;
    int		    height;
};

extern _X_EXPORT void
RRTransformInit (RRTransformPtr transform);

extern _X_EXPORT void
RRTransformFini (RRTransformPtr transform);

extern _X_EXPORT Bool
RRTransformEqual (RRTransformPtr a, RRTransformPtr b);

extern _X_EXPORT Bool
RRTransformSetFilter (RRTransformPtr	dst,
		      PictFilterPtr	filter,
		      xFixed		*params,
		      int		nparams,
		      int		width,
		      int		height);

extern _X_EXPORT Bool
RRTransformCopy (RRTransformPtr dst, RRTransformPtr src);

extern _X_EXPORT Bool
RRTransformCompute (int			    x,
		    int			    y,
		    int			    width,
		    int			    height,
		    Rotation		    rotation,
		    RRTransformPtr	    rr_transform,

		    PictTransformPtr	    transform,
		    struct pict_f_transform *f_transform,
		    struct pict_f_transform *f_inverse);


#endif /* _RRTRANSFORM_H_ */
/*
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */
/*
 * This Xinerama implementation comes from the SiS driver which has
 * the following notice:
 */
/* 
 * SiS driver main code
 *
 * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Thomas Winischhofer <thomas@winischhofer.net>
 *	- driver entirely rewritten since 2001, only basic structure taken from
 *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
 *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
 *	  new versions of the DRI layer)
 *
 * This notice covers the entire driver code unless indicated otherwise.
 *
 * Formerly based on code which was
 * 	     Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England.
 * 	     Written by:
 *           Alan Hourihane <alanh@fairlite.demon.co.uk>,
 *           Mike Chapman <mike@paranoia.com>,
 *           Juanjo Santamarta <santamarta@ctv.es>,
 *           Mitani Hiroshi <hmitani@drl.mei.co.jp>,
 *           David Thomas <davtom@dream.org.uk>.
 */

#include "randrstr.h"
#include "swaprep.h"
#include <X11/extensions/panoramiXproto.h>
#include "protocol-versions.h"

/* Xinerama is not multi-screen capable; just report about screen 0 */
#define RR_XINERAMA_SCREEN  0

static int ProcRRXineramaQueryVersion(ClientPtr client);
static int ProcRRXineramaGetState(ClientPtr client);
static int ProcRRXineramaGetScreenCount(ClientPtr client);
static int ProcRRXineramaGetScreenSize(ClientPtr client);
static int ProcRRXineramaIsActive(ClientPtr client);
static int ProcRRXineramaQueryScreens(ClientPtr client);
static int SProcRRXineramaDispatch(ClientPtr client);

/* Proc */

int
ProcRRXineramaQueryVersion(ClientPtr client)
{
    xPanoramiXQueryVersionReply	  rep;
    register int		  n;

    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_RRXINERAMA_MAJOR_VERSION;
    rep.minorVersion = SERVER_RRXINERAMA_MINOR_VERSION;
    if(client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&rep);
    return Success;
}

int
ProcRRXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    WindowPtr			pWin;
    xPanoramiXGetStateReply	rep;
    register int		n, rc;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    Bool			active = FALSE;

    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if(rc != Success)
	return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    if (pScrPriv)
    {
	/* XXX do we need more than this? */
	active = TRUE;
    }

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = active;
    rep.window = stuff->window;
    if(client->swapped) {
       swaps (&rep.sequenceNumber, n);
       swapl (&rep.length, n);
       swapl (&rep.window, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
    return Success;
}

static Bool
RRXineramaCrtcActive (RRCrtcPtr crtc)
{
    return crtc->mode != NULL && crtc->numOutputs > 0;
}

static int
RRXineramaScreenCount (ScreenPtr pScreen)
{
    int	i, n;
    
    n = 0;
    if (rrGetScrPriv (pScreen))
    {
	rrScrPriv(pScreen);
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	    if (RRXineramaCrtcActive (pScrPriv->crtcs[i]))
		n++;
    }
    return n;
}

static Bool
RRXineramaScreenActive (ScreenPtr pScreen)
{
    return RRXineramaScreenCount (pScreen) > 0;
}

int
ProcRRXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenCountReply	rep;
    register int			n, rc;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.ScreenCount = RRXineramaScreenCount (pWin->drawable.pScreen);
    rep.window = stuff->window;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swapl(&rep.window, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
    return Success;
}

int
ProcRRXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    WindowPtr				pWin, pRoot;
    ScreenPtr				pScreen;
    xPanoramiXGetScreenSizeReply	rep;
    register int			n, rc;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    pScreen = pWin->drawable.pScreen;
    pRoot = pScreen->root;
    
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.width  = pRoot->drawable.width;
    rep.height = pRoot->drawable.height;
    rep.window = stuff->window;
    rep.screen = stuff->screen;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swapl(&rep.width, n);
       swapl(&rep.height, n);
       swapl(&rep.window, n);
       swapl(&rep.screen, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
    return Success;
}

int
ProcRRXineramaIsActive(ClientPtr client)
{
    xXineramaIsActiveReply	rep;

    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);

    memset(&rep, 0, sizeof(xXineramaIsActiveReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = RRXineramaScreenActive (screenInfo.screens[RR_XINERAMA_SCREEN]);
    if(client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.state, n);
    }
    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
    return Success;
}

static void
RRXineramaWriteCrtc(ClientPtr client, RRCrtcPtr crtc)
{
    xXineramaScreenInfo scratch;

    if (RRXineramaCrtcActive (crtc))
    {
	ScreenPtr pScreen = crtc->pScreen;
	rrScrPrivPtr pScrPriv = rrGetScrPriv(pScreen);
	BoxRec panned_area;

	/* Check to see if crtc is panned and return the full area when applicable. */
	if (pScrPriv && pScrPriv->rrGetPanning &&
	    pScrPriv->rrGetPanning (pScreen, crtc, &panned_area, NULL, NULL) &&
	    (panned_area.x2 > panned_area.x1) && (panned_area.y2 > panned_area.y1)) {
	    scratch.x_org  = panned_area.x1;
	    scratch.y_org  = panned_area.y1;
	    scratch.width  = panned_area.x2  - panned_area.x1;
	    scratch.height = panned_area.y2  - panned_area.y1;
	} else {
	    int width, height;
	    RRCrtcGetScanoutSize (crtc, &width, &height);
	    scratch.x_org  = crtc->x;
	    scratch.y_org  = crtc->y;
	    scratch.width  = width;
	    scratch.height = height;
	}
	if(client->swapped) {
	    register int n;
	    swaps(&scratch.x_org, n);
	    swaps(&scratch.y_org, n);
	    swaps(&scratch.width, n);
	    swaps(&scratch.height, n);
	}
	WriteToClient(client, sz_XineramaScreenInfo, &scratch);
    }
}

int
ProcRRXineramaQueryScreens(ClientPtr client)
{
    xXineramaQueryScreensReply	rep;
    ScreenPtr	pScreen = screenInfo.screens[RR_XINERAMA_SCREEN];

    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);

    if (RRXineramaScreenActive (pScreen))
	RRGetInfo (pScreen, FALSE);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = RRXineramaScreenCount (pScreen);
    rep.length = bytes_to_int32(rep.number * sz_XineramaScreenInfo);
    if(client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.number, n);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);

    if(rep.number) {
	rrScrPriv(pScreen);
	int i;
	int has_primary = 0;

	if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc) {
	    has_primary = 1;
	    RRXineramaWriteCrtc(client, pScrPriv->primaryOutput->crtc);
	}

	for(i = 0; i < pScrPriv->numCrtcs; i++) {
	    if (has_primary &&
		pScrPriv->primaryOutput->crtc == pScrPriv->crtcs[i])
	    {
		has_primary = 0;
		continue;
	    }
	    RRXineramaWriteCrtc(client, pScrPriv->crtcs[i]);
	}
    }

    return Success;
}

static int
ProcRRXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return ProcRRXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return ProcRRXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return ProcRRXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return ProcRRXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return ProcRRXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return ProcRRXineramaQueryScreens(client);
    }
    return BadRequest;
}

/* SProc */

static int
SProcRRXineramaQueryVersion (ClientPtr client)
{
    REQUEST(xPanoramiXQueryVersionReq);
    register int n;
    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
    return ProcRRXineramaQueryVersion(client);
}

static int
SProcRRXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    swapl (&stuff->window, n);
    return ProcRRXineramaGetState(client);
}

static int
SProcRRXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    swapl (&stuff->window, n);
    return ProcRRXineramaGetScreenCount(client);
}

static int
SProcRRXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    swapl (&stuff->window, n);
    swapl (&stuff->screen, n);
    return ProcRRXineramaGetScreenSize(client);
}

static int
SProcRRXineramaIsActive(ClientPtr client)
{
    REQUEST(xXineramaIsActiveReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
    return ProcRRXineramaIsActive(client);
}

static int
SProcRRXineramaQueryScreens(ClientPtr client)
{
    REQUEST(xXineramaQueryScreensReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
    return ProcRRXineramaQueryScreens(client);
}

int
SProcRRXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return SProcRRXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return SProcRRXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SProcRRXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SProcRRXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return SProcRRXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SProcRRXineramaQueryScreens(client);
    }
    return BadRequest;
}

void
RRXineramaExtensionInit(void)
{
#ifdef PANORAMIX
    if(!noPanoramiXExtension)
	return;
#endif

    /*
     * Xinerama isn't capable enough to have multiple protocol screens each
     * with their own output geometry.  So if there's more than one protocol
     * screen, just don't even try.
     */
    if (screenInfo.numScreens > 1)
	return;

    (void) AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
			ProcRRXineramaDispatch,
			SProcRRXineramaDispatch,
			NULL,
			StandardMinorOpcode);
}
					X Server

The X server accepts requests from client applications to create windows,
which are (normally rectangular) "virtual screens" that the client program
can draw into.

Windows are then composed on the actual screen by the X server
(or by a separate composite manager) as directed by the window manager,
which usually communicates with the user via graphical controls such as buttons
and draggable titlebars and borders.

For a comprehensive overview of X Server and X Window System, consult the
following article:
http://en.wikipedia.org/wiki/X_server

All questions regarding this software should be directed at the
Xorg mailing list:

        http://lists.freedesktop.org/mailman/listinfo/xorg

Please submit bug reports to the Xorg bugzilla:

        https://bugs.freedesktop.org/enter_bug.cgi?product=xorg

The master development code repository can be found at:

        git://anongit.freedesktop.org/git/xorg/xserver

        http://cgit.freedesktop.org/xorg/xserver

For patch submission instructions, see:

	http://www.x.org/wiki/Development/Documentation/SubmittingPatches

For more information on the git code manager, see:

        http://wiki.x.org/wiki/GitPage

noinst_LTLIBRARIES = librecord.la

AM_CFLAGS = $(DIX_CFLAGS)

librecord_la_SOURCES = record.c set.c

EXTRA_DIST = set.h

/*

Copyright 1995, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

Author: David P. Wiggins, The Open Group

This work benefited from earlier work done by Martha Zimet of NCD
and Jim Haggerty of Metheus.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "dixstruct.h"
#include "extnsionst.h"
#include <X11/extensions/recordproto.h>
#include "set.h"
#include "swaprep.h"
#include "inputstr.h"
#include "eventconvert.h"
#include "scrnintstr.h"


#include <stdio.h>
#include <assert.h>

#ifdef PANORAMIX
#include "globals.h"
#include "panoramiX.h"
#include "panoramiXsrv.h"
#include "cursor.h"
#endif

#include "protocol-versions.h"

static RESTYPE RTContext;   /* internal resource type for Record contexts */

/* How many bytes of protocol data to buffer in a context. Don't set to less
 * than 32.
 */
#define REPLY_BUF_SIZE 1024

/* Record Context structure */

typedef struct {
    XID		id;		   /* resource id of context */
    ClientPtr	pRecordingClient;  /* client that has context enabled */
    struct _RecordClientsAndProtocolRec *pListOfRCAP; /* all registered info */
    ClientPtr	pBufClient;	   /* client whose protocol is in replyBuffer*/
    unsigned int continuedReply:1; /* recording a reply that is split up? */
    char	elemHeaders;	   /* element header flags (time/seq no.) */
    char	bufCategory;	   /* category of protocol in replyBuffer */
    int		numBufBytes;	   /* number of bytes in replyBuffer */
    char	replyBuffer[REPLY_BUF_SIZE]; /* buffered recorded protocol */
    int		inFlush;           /*  are we inside RecordFlushReplyBuffer */
} RecordContextRec, *RecordContextPtr;

/*  RecordMinorOpRec - to hold minor opcode selections for extension requests
 *  and replies
 */

typedef union {
    int count; /* first element of array: how many "major" structs to follow */
    struct {   /* rest of array elements are this */
	short first;		/* first major opcode */
	short last;		/* last major opcode */
	RecordSetPtr pMinOpSet; /*  minor opcode set for above major range */
    } major;
} RecordMinorOpRec, *RecordMinorOpPtr;


/*  RecordClientsAndProtocolRec, nicknamed RCAP - holds all the client and 
 *  protocol selections passed in a single CreateContext or RegisterClients.
 *  Generally, a context will have one of these from the create and an
 *  additional one for each RegisterClients.  RCAPs are freed when all their
 *  clients are unregistered.
 */

typedef struct _RecordClientsAndProtocolRec {
    RecordContextPtr pContext;		 /* context that owns this RCAP */
    struct _RecordClientsAndProtocolRec *pNextRCAP; /* next RCAP on context */
    RecordSetPtr     pRequestMajorOpSet; /* requests to record */
    RecordMinorOpPtr pRequestMinOpInfo;  /* extension requests to record */
    RecordSetPtr     pReplyMajorOpSet;   /* replies to record */
    RecordMinorOpPtr pReplyMinOpInfo;    /* extension replies to record */
    RecordSetPtr     pDeviceEventSet;    /* device events to record */
    RecordSetPtr     pDeliveredEventSet; /* delivered events to record */
    RecordSetPtr     pErrorSet;          /* errors to record */
    XID *	     pClientIDs;	 /* array of clients to record */
    short 	     numClients;	 /* number of clients in pClientIDs */
    short	     sizeClients;	 /* size of pClientIDs array */
    unsigned int     clientStarted:1;	 /* record new client connections? */
    unsigned int     clientDied:1;	 /* record client disconnections? */
    unsigned int     clientIDsSeparatelyAllocated:1; /* pClientIDs malloced? */
} RecordClientsAndProtocolRec, *RecordClientsAndProtocolPtr;

/* how much bigger to make pRCAP->pClientIDs when reallocing */
#define CLIENT_ARRAY_GROWTH_INCREMENT 4

/* counts the total number of RCAPs belonging to enabled contexts. */
static int numEnabledRCAPs;

/*  void VERIFY_CONTEXT(RecordContextPtr, XID, ClientPtr)
 *  In the spirit of the VERIFY_* macros in dix.h, this macro fills in
 *  the context pointer if the given ID is a valid Record Context, else it
 *  returns an error.
 */
#define VERIFY_CONTEXT(_pContext, _contextid, _client) { \
    int rc = dixLookupResourceByType((pointer *)&(_pContext), _contextid, \
                                     RTContext, _client, DixUseAccess); \
    if (rc != Success) \
	return rc; \
}

static int RecordDeleteContext(
    pointer /*value*/,
    XID /*id*/
);

void RecordExtensionInit(void);

/***************************************************************************/

/* client private stuff */

/*  To make declarations less obfuscated, have a typedef for a pointer to a
 *  Proc function.
 */
typedef int (*ProcFunctionPtr)(
    ClientPtr /*pClient*/
);

/* Record client private.  Generally a client only has one of these if
 * any of its requests are being recorded.
 */
typedef struct {
/* ptr to client's proc vector before Record stuck its nose in */
    ProcFunctionPtr *originalVector;   
					
/* proc vector with pointers for recorded requests redirected to the
 * function RecordARequest
 */
    ProcFunctionPtr recordVector[256]; 
} RecordClientPrivateRec, *RecordClientPrivatePtr;

static DevPrivateKeyRec RecordClientPrivateKeyRec;
#define RecordClientPrivateKey (&RecordClientPrivateKeyRec)

/*  RecordClientPrivatePtr RecordClientPrivate(ClientPtr)
 *  gets the client private of the given client.  Syntactic sugar.
 */
#define RecordClientPrivate(_pClient) (RecordClientPrivatePtr) \
    dixLookupPrivate(&(_pClient)->devPrivates, RecordClientPrivateKey)


/***************************************************************************/

/* global list of all contexts */

static RecordContextPtr *ppAllContexts;

static int numContexts;/* number of contexts in ppAllContexts */

/* number of currently enabled contexts.  All enabled contexts are bunched
 * up at the front of the ppAllContexts array, from ppAllContexts[0] to
 * ppAllContexts[numEnabledContexts-1], to eliminate time spent skipping
 * past disabled contexts.
 */
static int numEnabledContexts;

/* RecordFindContextOnAllContexts
 *
 * Arguments:
 *	pContext is the context to search for.
 *
 * Returns:
 *	The index into the array ppAllContexts at which pContext is stored.
 *	If pContext is not found in ppAllContexts, returns -1.
 *
 * Side Effects: none.
 */
static int
RecordFindContextOnAllContexts(RecordContextPtr pContext)
{
    int i;

    assert(numContexts >= numEnabledContexts);
    for (i = 0; i < numContexts; i++)
    {
	if (ppAllContexts[i] == pContext)
	    return i;
    }
    return -1;
} /* RecordFindContextOnAllContexts */


/***************************************************************************/

/* RecordFlushReplyBuffer
 *
 * Arguments:
 *	pContext is the context to flush.
 *	data1 is a pointer to additional data, and len1 is its length in bytes.
 *	data2 is a pointer to additional data, and len2 is its length in bytes.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	If the context is enabled, any buffered (recorded) protocol is written
 *	to the recording client, and the number of buffered bytes is set to
 *	zero.  If len1 is not zero, data1/len1 are then written to the
 *	recording client, and similarly for data2/len2 (written after
 *	data1/len1).
 */
static void
RecordFlushReplyBuffer(
    RecordContextPtr pContext,
    pointer data1,
    int len1,
    pointer data2,
    int len2
)
{
    if (!pContext->pRecordingClient || pContext->pRecordingClient->clientGone || pContext->inFlush)
	return;
    ++pContext->inFlush;
    if (pContext->numBufBytes)
	WriteToClient(pContext->pRecordingClient, pContext->numBufBytes,
		      (char *)pContext->replyBuffer);
    pContext->numBufBytes = 0;
    if (len1)
	WriteToClient(pContext->pRecordingClient, len1, (char *)data1);
    if (len2)
	WriteToClient(pContext->pRecordingClient, len2, (char *)data2);
    --pContext->inFlush;
} /* RecordFlushReplyBuffer */


/* RecordAProtocolElement
 *
 * Arguments:
 *	pContext is the context that is recording a protocol element.
 *	pClient is the client whose protocol is being recorded.  For
 *	  device events and EndOfData, pClient is NULL.
 *	category is the category of the protocol element, as defined
 *	  by the RECORD spec.
 *	data is a pointer to the protocol data, and datalen is its length
 *	  in bytes.
 *	futurelen is the number of bytes that will be sent in subsequent
 *	  calls to this function to complete this protocol element.  
 *	  In those subsequent calls, futurelen will be -1 to indicate
 *	  that the current data is a continuation of the same protocol
 *	  element.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	The context may be flushed.  The new protocol element will be
 *	added to the context's protocol buffer with appropriate element
 *	headers prepended (sequence number and timestamp).  If the data
 *	is continuation data (futurelen == -1), element headers won't
 *	be added.  If the protocol element and headers won't fit in
 *	the context's buffer, it is sent directly to the recording
 *	client (after any buffered data).
 */
static void
RecordAProtocolElement(RecordContextPtr pContext, ClientPtr pClient,
		       int category, pointer data, int datalen, int futurelen)
{
    CARD32 elemHeaderData[2];
    int numElemHeaders = 0;
    Bool recordingClientSwapped = pContext->pRecordingClient->swapped;
    int n;
    CARD32 serverTime = 0;
    Bool gotServerTime = FALSE;
    int replylen;

    if (futurelen >= 0)
    { /* start of new protocol element */
	xRecordEnableContextReply *pRep = (xRecordEnableContextReply *)
							pContext->replyBuffer;
	if (pContext->pBufClient != pClient ||
	    pContext->bufCategory != category)
	{
	    RecordFlushReplyBuffer(pContext, NULL, 0, NULL, 0);
	    pContext->pBufClient = pClient;
	    pContext->bufCategory = category;
	}

	if (!pContext->numBufBytes)
	{
	    serverTime = GetTimeInMillis();
	    gotServerTime = TRUE;
	    pRep->type          = X_Reply;
	    pRep->category      = category;
	    pRep->sequenceNumber = pContext->pRecordingClient->sequence;
	    pRep->length        = 0;
	    pRep->elementHeader = pContext->elemHeaders;
	    pRep->serverTime    = serverTime;
	    if (pClient)
	    {
		pRep->clientSwapped =
				(pClient->swapped != recordingClientSwapped);
		pRep->idBase = pClient->clientAsMask;
		pRep->recordedSequenceNumber = pClient->sequence;
	    }
	    else /* it's a device event, StartOfData, or EndOfData */
	    {
		pRep->clientSwapped = (category != XRecordFromServer) && 
						recordingClientSwapped;
		pRep->idBase = 0;
		pRep->recordedSequenceNumber = 0;
	    }

	    if (recordingClientSwapped)
	    {
		swaps(&pRep->sequenceNumber, n);
		swapl(&pRep->length, n);
		swapl(&pRep->idBase, n);
		swapl(&pRep->serverTime, n);
		swapl(&pRep->recordedSequenceNumber, n);
	    }
	    pContext->numBufBytes = SIZEOF(xRecordEnableContextReply);
	}

	/* generate element headers if needed */

	if ( ( (pContext->elemHeaders & XRecordFromClientTime)
	      && category == XRecordFromClient)
	    ||
	    ( (pContext->elemHeaders & XRecordFromServerTime)
	     && category == XRecordFromServer))
	{
	    if (gotServerTime)
		elemHeaderData[numElemHeaders] = serverTime;
	    else
		elemHeaderData[numElemHeaders] = GetTimeInMillis();
	    if (recordingClientSwapped)
		swapl(&elemHeaderData[numElemHeaders], n);
	    numElemHeaders++;
	}

	if ( (pContext->elemHeaders & XRecordFromClientSequence)
	    &&
	    (category == XRecordFromClient || category == XRecordClientDied))
	{
	    elemHeaderData[numElemHeaders] = pClient->sequence;
	    if (recordingClientSwapped)
		swapl(&elemHeaderData[numElemHeaders], n);
	    numElemHeaders++;
	}

	/* adjust reply length */

	replylen = pRep->length;
	if (recordingClientSwapped) swapl(&replylen, n);
	replylen += numElemHeaders + bytes_to_int32(datalen) +
            bytes_to_int32(futurelen);
	if (recordingClientSwapped) swapl(&replylen, n);
	pRep->length = replylen;
    } /* end if not continued reply */

    numElemHeaders *= 4;

    /* if space available >= space needed, buffer the data */

    if (REPLY_BUF_SIZE - pContext->numBufBytes >= datalen + numElemHeaders)
    {
	if (numElemHeaders)
	{
	    memcpy(pContext->replyBuffer + pContext->numBufBytes,
		   elemHeaderData, numElemHeaders);
	    pContext->numBufBytes += numElemHeaders;
	}
	if (datalen)
	{
	    memcpy(pContext->replyBuffer + pContext->numBufBytes,
		   data, datalen);
	    pContext->numBufBytes += datalen;
	}
    }
    else
	RecordFlushReplyBuffer(pContext, (pointer)elemHeaderData,
			       numElemHeaders, (pointer)data, datalen);

} /* RecordAProtocolElement */


/* RecordFindClientOnContext
 *
 * Arguments:
 *	pContext is the context to search.
 *	clientspec is the resource ID mask identifying the client to search
 *	  for, or XRecordFutureClients.
 *	pposition is a pointer to an int, or NULL.  See Returns.
 *
 * Returns:
 *	The RCAP on which clientspec was found, or NULL if not found on
 *	any RCAP on the given context.
 *	If pposition was not NULL and the returned RCAP is not NULL,
 *	*pposition will be set to the index into the returned the RCAP's
 *	pClientIDs array that holds clientspec.
 *
 * Side Effects: none.
 */
static RecordClientsAndProtocolPtr
RecordFindClientOnContext(
    RecordContextPtr pContext,
    XID clientspec,
    int *pposition
)
{
    RecordClientsAndProtocolPtr pRCAP;

    for (pRCAP = pContext->pListOfRCAP; pRCAP; pRCAP = pRCAP->pNextRCAP)
    {
	int i;
	for (i = 0; i < pRCAP->numClients; i++)
	{
	    if (pRCAP->pClientIDs[i] == clientspec)
	    {
		if (pposition)
		    *pposition = i;
		return pRCAP;
	    }
	}
    }
    return NULL;
} /* RecordFindClientOnContext */


/* RecordABigRequest
 *
 * Arguments:
 *	pContext is the recording context.
 *	client is the client being recorded.
 *	stuff is a pointer to the big request of client (see the Big Requests
 *	extension for details.)
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	The big request is recorded with the correct length field re-inserted.
 *	
 * Note: this function exists mainly to make RecordARequest smaller.
 */
static void
RecordABigRequest(RecordContextPtr pContext, ClientPtr client, xReq *stuff)
{
    CARD32 bigLength;
    char n;
    int bytesLeft;

    /* note: client->req_len has been frobbed by ReadRequestFromClient
     * (os/io.c) to discount the extra 4 bytes taken by the extended length
     * field in a big request.  The actual request length to record is
     * client->req_len + 1 (measured in CARD32s).
     */

    /* record the request header */
    bytesLeft = client->req_len << 2;
    RecordAProtocolElement(pContext, client, XRecordFromClient,
			   (pointer)stuff, SIZEOF(xReq), bytesLeft);

    /* reinsert the extended length field that was squished out */
    bigLength = client->req_len + bytes_to_int32(sizeof(bigLength));
    if (client->swapped)
	swapl(&bigLength, n);
    RecordAProtocolElement(pContext, client, XRecordFromClient,
		(pointer)&bigLength, sizeof(bigLength), /* continuation */ -1);
    bytesLeft -= sizeof(bigLength);

    /* record the rest of the request after the length */
    RecordAProtocolElement(pContext, client, XRecordFromClient,
		(pointer)(stuff + 1), bytesLeft, /* continuation */ -1);
} /* RecordABigRequest */


/* RecordARequest
 *
 * Arguments:
 *	client is a client that the server has dispatched a request to by
 *	calling client->requestVector[request opcode] .
 *	The request is in client->requestBuffer.
 *
 * Returns:
 *	Whatever is returned by the "real" Proc function for this request.
 *	The "real" Proc function is the function that was in
 *	client->requestVector[request opcode]  before it was replaced by
 *	RecordARequest.  (See the function RecordInstallHooks.)
 *
 * Side Effects:
 *	The request is recorded by all contexts that have registered this
 *	request for this client.  The real Proc function is called.
 */
static int
RecordARequest(ClientPtr client)
{
    RecordContextPtr pContext;
    RecordClientsAndProtocolPtr pRCAP;
    int i;
    RecordClientPrivatePtr pClientPriv;
    REQUEST(xReq);
    int majorop;

    majorop = stuff->reqType;
    for (i = 0; i < numEnabledContexts; i++)
    {
	pContext = ppAllContexts[i];
	pRCAP = RecordFindClientOnContext(pContext, client->clientAsMask,
					  NULL);
	if (pRCAP && pRCAP->pRequestMajorOpSet &&
	    RecordIsMemberOfSet(pRCAP->pRequestMajorOpSet, majorop))
	{
	    if (majorop <= 127)
	    { /* core request */

		if (stuff->length == 0)
		    RecordABigRequest(pContext, client, stuff);
		else
		    RecordAProtocolElement(pContext, client, XRecordFromClient,
				(pointer)stuff, client->req_len << 2, 0);
	    }
	    else /* extension, check minor opcode */
	    {
		int minorop = MinorOpcodeOfRequest(client);
		int numMinOpInfo;
		RecordMinorOpPtr pMinorOpInfo = pRCAP->pRequestMinOpInfo;

		assert (pMinorOpInfo);
		numMinOpInfo = pMinorOpInfo->count;
		pMinorOpInfo++;
		assert (numMinOpInfo);
		for ( ; numMinOpInfo; numMinOpInfo--, pMinorOpInfo++)
		{
		    if (majorop >= pMinorOpInfo->major.first &&
			majorop <= pMinorOpInfo->major.last &&
			RecordIsMemberOfSet(pMinorOpInfo->major.pMinOpSet,
					    minorop))
		    {
			if (stuff->length == 0)
			    RecordABigRequest(pContext, client, stuff);
			else
			    RecordAProtocolElement(pContext, client, 
					XRecordFromClient, (pointer)stuff,
					client->req_len << 2, 0);
			break;
		    }			    
		} /* end for each minor op info */
	    } /* end extension request */
	} /* end this RCAP wants this major opcode */
    } /* end for each context */
    pClientPriv = RecordClientPrivate(client);
    assert(pClientPriv);
    return (* pClientPriv->originalVector[majorop])(client);
} /* RecordARequest */

/* RecordAReply
 *
 * Arguments:
 *	pcbl is &ReplyCallback.
 *	nulldata is NULL.
 *	calldata is a pointer to a ReplyInfoRec (include/os.h)
 *	  which provides information about replies that are being sent
 *	  to clients.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	The reply is recorded by all contexts that have registered this
 *	reply type for this client.  If more data belonging to the same
 *	reply is expected, and if the reply is being recorded by any
 *	context, pContext->continuedReply is set to 1.
 *	If pContext->continuedReply was already 1 and this is the last
 *	chunk of data belonging to this reply, it is set to 0.
 */
static void
RecordAReply(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
{
    RecordContextPtr pContext;
    RecordClientsAndProtocolPtr pRCAP;
    int eci;
    int majorop;
    ReplyInfoRec *pri = (ReplyInfoRec *)calldata;
    ClientPtr client = pri->client;
    REQUEST(xReq);

    majorop = stuff->reqType;
    for (eci = 0; eci < numEnabledContexts; eci++)
    {
	pContext = ppAllContexts[eci];
	pRCAP = RecordFindClientOnContext(pContext, client->clientAsMask,
					  NULL);
	if (pRCAP)
	{
	    if (pContext->continuedReply)
	    {
		RecordAProtocolElement(pContext, client, XRecordFromServer,
		   (pointer)pri->replyData, pri->dataLenBytes, /* continuation */ -1);
		if (!pri->bytesRemaining)
		    pContext->continuedReply = 0;
	    }
	    else if (pri->startOfReply && pRCAP->pReplyMajorOpSet &&
		     RecordIsMemberOfSet(pRCAP->pReplyMajorOpSet, majorop))
	    {
		if (majorop <= 127)
		{ /* core reply */
		    RecordAProtocolElement(pContext, client, XRecordFromServer,
		       (pointer)pri->replyData, pri->dataLenBytes, pri->bytesRemaining);
		    if (pri->bytesRemaining)
			pContext->continuedReply = 1;
		}
		else /* extension, check minor opcode */
		{
		    int minorop = MinorOpcodeOfRequest(client);
		    int numMinOpInfo;
		    RecordMinorOpPtr pMinorOpInfo = pRCAP->pReplyMinOpInfo;
		    		    assert (pMinorOpInfo);
		    numMinOpInfo = pMinorOpInfo->count;
		    pMinorOpInfo++;
		    assert (numMinOpInfo);
		    for ( ; numMinOpInfo; numMinOpInfo--, pMinorOpInfo++)
		    {
			if (majorop >= pMinorOpInfo->major.first &&
			    majorop <= pMinorOpInfo->major.last &&
			    RecordIsMemberOfSet(pMinorOpInfo->major.pMinOpSet,
						minorop))
			{
			    RecordAProtocolElement(pContext, client, 
				XRecordFromServer, (pointer)pri->replyData,
				pri->dataLenBytes, pri->bytesRemaining);
			    if (pri->bytesRemaining)
				pContext->continuedReply = 1;
			    break;
			}			    
		    } /* end for each minor op info */
		} /* end extension reply */
	    } /* end continued reply vs. start of reply */
	} /* end client is registered on this context */
    } /* end for each context */
} /* RecordAReply */


/* RecordADeliveredEventOrError
 *
 * Arguments:
 *	pcbl is &EventCallback.
 *	nulldata is NULL.
 *	calldata is a pointer to a EventInfoRec (include/dix.h)
 *	  which provides information about events that are being sent
 *	  to clients.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	The event or error is recorded by all contexts that have registered
 *	it for this client.
 */
static void
RecordADeliveredEventOrError(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
{
    EventInfoRec *pei = (EventInfoRec *)calldata;
    RecordContextPtr pContext;
    RecordClientsAndProtocolPtr pRCAP;
    int eci; /* enabled context index */
    ClientPtr pClient = pei->client;

    for (eci = 0; eci < numEnabledContexts; eci++)
    {
	pContext = ppAllContexts[eci];
	pRCAP = RecordFindClientOnContext(pContext, pClient->clientAsMask,
					  NULL);
	if (pRCAP && (pRCAP->pDeliveredEventSet || pRCAP->pErrorSet))
	{
	    int ev; /* event index */
	    xEvent *pev = pei->events;
	    for (ev = 0; ev < pei->count; ev++, pev++)
	    {
		int recordit = 0;
		if (pRCAP->pErrorSet)
		{
		    recordit = RecordIsMemberOfSet(pRCAP->pErrorSet,
						((xError *)(pev))->errorCode);
		}
		else if (pRCAP->pDeliveredEventSet)
		{
		    recordit = RecordIsMemberOfSet(pRCAP->pDeliveredEventSet,
						   pev->u.u.type & 0177);
		}
		if (recordit)
		{
		    xEvent swappedEvent;
		    xEvent *pEvToRecord = pev;

		    if (pClient->swapped)
		    {
			(*EventSwapVector[pev->u.u.type & 0177])
			    (pev, &swappedEvent);
			pEvToRecord = &swappedEvent;
			
		    }
		    RecordAProtocolElement(pContext, pClient,
			XRecordFromServer, pEvToRecord, SIZEOF(xEvent), 0);
		}
	    } /* end for each event */
	} /* end this client is on this context */
    } /* end for each enabled context */
} /* RecordADeliveredEventOrError */


static void
RecordSendProtocolEvents(RecordClientsAndProtocolPtr pRCAP,
			RecordContextPtr pContext,
			xEvent* pev, int count)
{
    int ev; /* event index */

    for (ev = 0; ev < count; ev++, pev++)
    {
	if (RecordIsMemberOfSet(pRCAP->pDeviceEventSet,
		    pev->u.u.type & 0177))
	{
	    xEvent swappedEvent;
	    xEvent *pEvToRecord = pev;
#ifdef PANORAMIX
	    xEvent shiftedEvent;

	    if (!noPanoramiXExtension &&
		    (pev->u.u.type == MotionNotify ||
		     pev->u.u.type == ButtonPress ||
		     pev->u.u.type == ButtonRelease ||
		     pev->u.u.type == KeyPress ||
		     pev->u.u.type == KeyRelease)) {
		int scr = XineramaGetCursorScreen(inputInfo.pointer);
		memcpy(&shiftedEvent, pev, sizeof(xEvent));
		shiftedEvent.u.keyButtonPointer.rootX +=
		    screenInfo.screens[scr]->x -
		    screenInfo.screens[0]->x;
		shiftedEvent.u.keyButtonPointer.rootY +=
		    screenInfo.screens[scr]->y -
		    screenInfo.screens[0]->y;
		pEvToRecord = &shiftedEvent;
	    }
#endif /* PANORAMIX */

	    if (pContext->pRecordingClient->swapped)
	    {
		(*EventSwapVector[pEvToRecord->u.u.type & 0177])
		    (pEvToRecord, &swappedEvent);
		pEvToRecord = &swappedEvent;
	    }

	    RecordAProtocolElement(pContext, NULL,
		    XRecordFromServer,  pEvToRecord, SIZEOF(xEvent), 0);
	    /* make sure device events get flushed in the absence
	     * of other client activity
	     */
	    SetCriticalOutputPending();
	}
    } /* end for each event */

} /* RecordADeviceEvent */

/* RecordADeviceEvent
 *
 * Arguments:
 *	pcbl is &DeviceEventCallback.
 *	nulldata is NULL.
 *	calldata is a pointer to a DeviceEventInfoRec (include/dix.h)
 *	  which provides information about device events that occur.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	The device event is recorded by all contexts that have registered
 *	it for this client.
 */
static void
RecordADeviceEvent(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
{
    DeviceEventInfoRec *pei = (DeviceEventInfoRec *)calldata;
    RecordContextPtr pContext;
    RecordClientsAndProtocolPtr pRCAP;
    int eci; /* enabled context index */

    for (eci = 0; eci < numEnabledContexts; eci++)
    {
	pContext = ppAllContexts[eci];
	for (pRCAP = pContext->pListOfRCAP; pRCAP; pRCAP = pRCAP->pNextRCAP)
	{
	    if (pRCAP->pDeviceEventSet)
	    {
		int count;
		xEvent *xi_events = NULL;

		/* TODO check return values */
		if (IsMaster(pei->device))
		{
		    xEvent *core_events;
		    EventToCore(pei->event, &core_events, &count);
		    RecordSendProtocolEvents(pRCAP, pContext, core_events,
                                             count);
		    free(core_events);
		}

		EventToXI(pei->event, &xi_events, &count);
		RecordSendProtocolEvents(pRCAP, pContext, xi_events, count);
		free(xi_events);
	    } /* end this RCAP selects device events */
	} /* end for each RCAP on this context */
    } /* end for each enabled context */
}


/* RecordFlushAllContexts
 *
 * Arguments:
 *	pcbl is &FlushCallback.
 *	nulldata and calldata are NULL.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	All buffered reply data of all enabled contexts is written to
 *	the recording clients.
 */
static void
RecordFlushAllContexts(
    CallbackListPtr *pcbl,
    pointer nulldata,
    pointer calldata
)
{
    int eci; /* enabled context index */
    RecordContextPtr pContext;

    for (eci = 0; eci < numEnabledContexts; eci++)
    {
	pContext = ppAllContexts[eci];

	/* In most cases we leave it to RecordFlushReplyBuffer to make
	 * this check, but this function could be called very often, so we
	 * check before calling hoping to save the function call cost
	 * most of the time.
	 */
	if (pContext->numBufBytes)
	    RecordFlushReplyBuffer(ppAllContexts[eci], NULL, 0, NULL, 0);
    }
} /* RecordFlushAllContexts */


/* RecordInstallHooks
 *
 * Arguments:
 *	pRCAP is an RCAP on an enabled or being-enabled context.
 *	oneclient can be zero or the resource ID mask identifying a client.
 *
 * Returns: BadAlloc if a memory allocation error occurred, else Success.
 *
 * Side Effects:
 *	Recording hooks needed by RCAP are installed.
 *	If oneclient is zero, recording hooks needed for all clients and
 *	protocol on the RCAP are installed.  If oneclient is non-zero,
 *	only those hooks needed for the specified client are installed.
 *	
 *	Client requestVectors may be altered.  numEnabledRCAPs will be
 *	incremented if oneclient == 0.  Callbacks may be added to
 *	various callback lists.
 */
static int
RecordInstallHooks(RecordClientsAndProtocolPtr pRCAP, XID oneclient)
{
    int i = 0;
    XID client;

    if (oneclient)
	client = oneclient;
    else
	client = pRCAP->numClients ? pRCAP->pClientIDs[i++] : 0;

    while (client)
    {
	if (client != XRecordFutureClients)
	{
	    if (pRCAP->pRequestMajorOpSet)
	    {
		RecordSetIteratePtr pIter = NULL;
		RecordSetInterval interval;
		ClientPtr pClient = clients[CLIENT_ID(client)];

		if (pClient && !RecordClientPrivate(pClient))
		{
		    RecordClientPrivatePtr pClientPriv;
		    /* no Record proc vector; allocate one */
		    pClientPriv = (RecordClientPrivatePtr)
				malloc(sizeof(RecordClientPrivateRec));
		    if (!pClientPriv)
			return BadAlloc;
		    /* copy old proc vector to new */
		    memcpy(pClientPriv->recordVector, pClient->requestVector, 
			   sizeof (pClientPriv->recordVector));
		    pClientPriv->originalVector = pClient->requestVector;
		    dixSetPrivate(&pClient->devPrivates,
				  RecordClientPrivateKey, pClientPriv);
		    pClient->requestVector = pClientPriv->recordVector;
		}
		while ((pIter = RecordIterateSet(pRCAP->pRequestMajorOpSet,
						pIter, &interval)))
		{
		    unsigned int j;
		    for (j = interval.first; j <= interval.last; j++)
			pClient->requestVector[j] = RecordARequest;
		}
	    }
	}
	if (oneclient)
	    client = 0;
	else
	    client = (i < pRCAP->numClients) ? pRCAP->pClientIDs[i++] : 0;
    }

    assert(numEnabledRCAPs >= 0);
    if (!oneclient && ++numEnabledRCAPs == 1)
    { /* we're enabling the first context */
	if (!AddCallback(&EventCallback, RecordADeliveredEventOrError, NULL))
	    return BadAlloc;
	if (!AddCallback(&DeviceEventCallback, RecordADeviceEvent, NULL))
	    return BadAlloc;
	if (!AddCallback(&ReplyCallback, RecordAReply, NULL))
	    return BadAlloc;
	if (!AddCallback(&FlushCallback, RecordFlushAllContexts, NULL))
	    return BadAlloc;
	/* Alternate context flushing scheme: delete the line above
	 * and call RegisterBlockAndWakeupHandlers here passing
	 * RecordFlushAllContexts.  Is this any better?
	 */
    }
    return Success;
} /* RecordInstallHooks */


/* RecordUninstallHooks
 *
 * Arguments:
 *	pRCAP is an RCAP on an enabled or being-disabled context.
 *	oneclient can be zero or the resource ID mask identifying a client.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Recording hooks needed by RCAP may be uninstalled.
 *	If oneclient is zero, recording hooks needed for all clients and
 *	protocol on the RCAP may be uninstalled.  If oneclient is non-zero,
 *	only those hooks needed for the specified client may be uninstalled.
 *	
 *	Client requestVectors may be altered.  numEnabledRCAPs will be
 *	decremented if oneclient == 0.  Callbacks may be deleted from
 *	various callback lists.
 */
static void
RecordUninstallHooks(RecordClientsAndProtocolPtr pRCAP, XID oneclient)
{
    int i = 0;
    XID client;

    if (oneclient)
	client = oneclient;
    else
	client = pRCAP->numClients ? pRCAP->pClientIDs[i++] : 0;

    while (client)
    {
	if (client != XRecordFutureClients)
	{
	    if (pRCAP->pRequestMajorOpSet)
	    {
		ClientPtr pClient = clients[CLIENT_ID(client)];
		int c;
		Bool otherRCAPwantsProcVector = FALSE;
		RecordClientPrivatePtr pClientPriv = NULL;

		assert (pClient);
		pClientPriv = RecordClientPrivate(pClient);
		assert (pClientPriv);
		memcpy(pClientPriv->recordVector, pClientPriv->originalVector,
		       sizeof (pClientPriv->recordVector));

		for (c = 0; c < numEnabledContexts; c++)
		{
		    RecordClientsAndProtocolPtr pOtherRCAP;
		    RecordContextPtr pContext = ppAllContexts[c];

		    if (pContext == pRCAP->pContext) continue;
		    pOtherRCAP = RecordFindClientOnContext(pContext, client,
							   NULL);
		    if (pOtherRCAP && pOtherRCAP->pRequestMajorOpSet)
		    {
			RecordSetIteratePtr pIter = NULL;
			RecordSetInterval interval;

			otherRCAPwantsProcVector = TRUE;
			while ((pIter = RecordIterateSet(
						pOtherRCAP->pRequestMajorOpSet,
						pIter, &interval)))
			{
			    unsigned int j;
			    for (j = interval.first; j <= interval.last; j++)
				pClient->requestVector[j] = RecordARequest;
			}
		    }
		}
		if (!otherRCAPwantsProcVector)
		{ /* nobody needs it, so free it */
		    pClient->requestVector = pClientPriv->originalVector;
		    dixSetPrivate(&pClient->devPrivates,
				  RecordClientPrivateKey, NULL);
		    free(pClientPriv);
		}
	    } /* end if this RCAP specifies any requests */
	} /* end if not future clients */
	if (oneclient)
	    client = 0;
	else
	    client = (i < pRCAP->numClients) ? pRCAP->pClientIDs[i++] : 0;
    }

    assert(numEnabledRCAPs >= 1);
    if (!oneclient && --numEnabledRCAPs == 0)
    { /* we're disabling the last context */
	DeleteCallback(&EventCallback, RecordADeliveredEventOrError, NULL);
	DeleteCallback(&DeviceEventCallback, RecordADeviceEvent, NULL);
	DeleteCallback(&ReplyCallback, RecordAReply, NULL);
	DeleteCallback(&FlushCallback, RecordFlushAllContexts, NULL);
	/* Alternate context flushing scheme: delete the line above
	 * and call RemoveBlockAndWakeupHandlers here passing
	 * RecordFlushAllContexts.  Is this any better?
	 */
	/* Having deleted the callback, call it one last time. -gildea */
	RecordFlushAllContexts(&FlushCallback, NULL, NULL);
    }
} /* RecordUninstallHooks */


/* RecordDeleteClientFromRCAP
 *
 * Arguments:
 *	pRCAP is an RCAP to delete the client from.
 *	position is the index into the array pRCAP->pClientIDs of the
 *	client to delete.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Recording hooks needed by client will be uninstalled if the context
 *	is enabled.  The designated client will be removed from the 
 *	pRCAP->pClientIDs array.  If it was the only client on the RCAP, 
 *	the RCAP is removed from the context and freed.  (Invariant: RCAPs
 *	have at least one client.)
 */
static void
RecordDeleteClientFromRCAP(RecordClientsAndProtocolPtr pRCAP, int position)
{
    if (pRCAP->pContext->pRecordingClient)
	RecordUninstallHooks(pRCAP, pRCAP->pClientIDs[position]);
    if (position != pRCAP->numClients - 1)
	pRCAP->pClientIDs[position] = pRCAP->pClientIDs[pRCAP->numClients - 1];
    if (--pRCAP->numClients == 0)
    {	/* no more clients; remove RCAP from context's list */
	RecordContextPtr pContext = pRCAP->pContext;
	if (pContext->pRecordingClient)
	    RecordUninstallHooks(pRCAP, 0);
	if (pContext->pListOfRCAP == pRCAP)
	    pContext->pListOfRCAP = pRCAP->pNextRCAP;
	else
	{
	    RecordClientsAndProtocolPtr prevRCAP;
	    for (prevRCAP = pContext->pListOfRCAP;
		 prevRCAP->pNextRCAP != pRCAP;
		 prevRCAP = prevRCAP->pNextRCAP)
		;
	    prevRCAP->pNextRCAP = pRCAP->pNextRCAP;
	}
	/* free the RCAP */
	if (pRCAP->clientIDsSeparatelyAllocated)
	    free(pRCAP->pClientIDs);
	free(pRCAP);
    }
} /* RecordDeleteClientFromRCAP */


/* RecordAddClientToRCAP
 *
 * Arguments:
 *	pRCAP is an RCAP to add the client to.
 *	clientspec is the resource ID mask identifying a client, or
 *	  XRecordFutureClients.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Recording hooks needed by client will be installed if the context
 *	is enabled.  The designated client will be added to the 
 *	pRCAP->pClientIDs array, which may be realloced.
 *	pRCAP->clientIDsSeparatelyAllocated may be set to 1 if there
 *	is no more room to hold clients internal to the RCAP.
 */
static void
RecordAddClientToRCAP(RecordClientsAndProtocolPtr pRCAP, XID clientspec)
{
    if (pRCAP->numClients == pRCAP->sizeClients)
    {
	if (pRCAP->clientIDsSeparatelyAllocated)
	{
	    XID *pNewIDs = (XID *)realloc(pRCAP->pClientIDs,
			(pRCAP->sizeClients + CLIENT_ARRAY_GROWTH_INCREMENT) *
								sizeof(XID));
	    if (!pNewIDs)
		return;
	    pRCAP->pClientIDs = pNewIDs;
	    pRCAP->sizeClients += CLIENT_ARRAY_GROWTH_INCREMENT;
	}
	else
	{
	    XID *pNewIDs = (XID *)malloc((pRCAP->sizeClients +
				CLIENT_ARRAY_GROWTH_INCREMENT) * sizeof(XID));
	    if (!pNewIDs)
		return;
	    memcpy(pNewIDs, pRCAP->pClientIDs, pRCAP->numClients *sizeof(XID));
	    pRCAP->pClientIDs = pNewIDs;
	    pRCAP->sizeClients += CLIENT_ARRAY_GROWTH_INCREMENT;
	    pRCAP->clientIDsSeparatelyAllocated = 1;
	}
    }
    pRCAP->pClientIDs[pRCAP->numClients++] = clientspec;
    if (pRCAP->pContext->pRecordingClient)
	RecordInstallHooks(pRCAP, clientspec);
} /* RecordDeleteClientFromRCAP */


/* RecordDeleteClientFromContext
 *
 * Arguments:
 *	pContext is the context to delete from.
 *	clientspec is the resource ID mask identifying a client, or
 *	  XRecordFutureClients.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	If clientspec is on any RCAP of the context, it is deleted from that
 *	RCAP.  (A given clientspec can only be on one RCAP of a context.)
 */
static void
RecordDeleteClientFromContext(RecordContextPtr pContext, XID clientspec)
{
    RecordClientsAndProtocolPtr pRCAP;
    int position;

    if ((pRCAP = RecordFindClientOnContext(pContext, clientspec, &position)))
	RecordDeleteClientFromRCAP(pRCAP, position);
} /* RecordDeleteClientFromContext */


/* RecordSanityCheckClientSpecifiers
 *
 * Arguments:
 *	clientspecs is an array of alleged CLIENTSPECs passed by the client.
 *	nspecs is the number of elements in clientspecs.
 *	errorspec, if non-zero, is the resource id base of a client that
 *	  must not appear in clienspecs.
 *
 * Returns: BadMatch if any of the clientspecs are invalid, else Success.
 *
 * Side Effects: none.
 */
static int
RecordSanityCheckClientSpecifiers(ClientPtr client, XID *clientspecs, int nspecs, XID errorspec)
{
    int i;
    int clientIndex;
    int rc;
    pointer value;

    for (i = 0; i < nspecs; i++)
    {
	if (clientspecs[i] == XRecordCurrentClients ||
	    clientspecs[i] == XRecordFutureClients ||
	    clientspecs[i] == XRecordAllClients)
	    continue;
	if (errorspec && (CLIENT_BITS(clientspecs[i]) == errorspec) )
	    return BadMatch;
	clientIndex = CLIENT_ID(clientspecs[i]);
	if (clientIndex && clients[clientIndex] &&
	    clients[clientIndex]->clientState == ClientStateRunning)
	{
	    if (clientspecs[i] == clients[clientIndex]->clientAsMask)
		continue;
            rc = dixLookupResourceByClass(&value, clientspecs[i], RC_ANY,
                                          client, DixGetAttrAccess);
            if (rc != Success)
                return rc;
	}
	else
	    return BadMatch;
    }
    return Success;
} /* RecordSanityCheckClientSpecifiers */


/* RecordCanonicalizeClientSpecifiers
 *
 * Arguments:
 *	pClientspecs is an array of CLIENTSPECs that have been sanity
 *	  checked.
 *	pNumClientspecs is a pointer to the number of elements in pClientspecs.
 *	excludespec, if non-zero, is the resource id base of a client that 
 *	  should not be included in the expansion of XRecordAllClients or 
 *	  XRecordCurrentClients.
 *
 * Returns:
 *	A pointer to an array of CLIENTSPECs that is the same as the
 *	passed array with the following modifications:
 *	  - all but the client id bits of resource IDs are stripped off.
 *	  - duplicates removed.
 *	  - XRecordAllClients expanded to a list of all currently connected
 *	    clients + XRecordFutureClients - excludespec (if non-zero)
 *	  - XRecordCurrentClients expanded to a list of all currently
 *	    connected clients - excludespec (if non-zero)
 *	The returned array may be the passed array modified in place, or
 *	it may be an malloc'ed array.  The caller should keep a pointer to the
 *	original array and free the returned array if it is different.
 *
 *	*pNumClientspecs is set to the number of elements in the returned
 *	array.
 *
 * Side Effects:
 *	pClientspecs may be modified in place.
 */
static XID *
RecordCanonicalizeClientSpecifiers(XID *pClientspecs, int *pNumClientspecs, XID excludespec)
{
    int i;
    int numClients = *pNumClientspecs;

    /*  first pass strips off the resource index bits, leaving just the
     *  client id bits.  This makes searching for a particular client simpler
     *  (and faster.)
     */
    for (i = 0; i < numClients; i++)
    {
	XID cs = pClientspecs[i];
	if (cs > XRecordAllClients)
	    pClientspecs[i] = CLIENT_BITS(cs);
    }

    for (i = 0; i < numClients; i++)
    {
	if (pClientspecs[i] == XRecordAllClients ||
	    pClientspecs[i] == XRecordCurrentClients)
	{ /* expand All/Current */
	    int j, nc;
	    XID *pCanon = (XID *)malloc(sizeof(XID) * (currentMaxClients + 1));
	    if (!pCanon) return NULL;
	    for (nc = 0, j = 1; j < currentMaxClients; j++)
	    {
		ClientPtr client = clients[j];
		if (client != NullClient &&
		    client->clientState == ClientStateRunning &&
		    client->clientAsMask != excludespec)
		{
		    pCanon[nc++] = client->clientAsMask;
		}
	    }
	    if (pClientspecs[i] == XRecordAllClients)
		pCanon[nc++] = XRecordFutureClients;
	    *pNumClientspecs = nc;
	    return pCanon;
	}
	else /* not All or Current */
	{
	    int j;
	    for (j = i + 1; j < numClients; )
	    {
		if (pClientspecs[i] == pClientspecs[j])
		{
		    pClientspecs[j] = pClientspecs[--numClients];
		}
		else
		    j++;
	    }
	}
    } /* end for each clientspec */
    *pNumClientspecs = numClients;
    return pClientspecs;
} /* RecordCanonicalizeClientSpecifiers */


/****************************************************************************/

/* stuff for RegisterClients */

/* RecordPadAlign
 *
 * Arguments:
 *	size is the number of bytes taken by an object.
 *	align is a byte boundary (e.g. 4, 8)
 *
 * Returns:
 *	the number of pad bytes to add at the end of an object of the
 *	given size so that an object placed immediately behind it will
 *	begin on an <align>-byte boundary.
 *
 * Side Effects: none.
 */
static int
RecordPadAlign(int size, int align)
{
    return (align - (size & (align - 1))) & (align - 1);
} /* RecordPadAlign */


/* RecordSanityCheckRegisterClients
 *
 * Arguments:
 *	pContext is the context being registered on.
 *	client is the client that issued a RecordCreateContext or
 *	  RecordRegisterClients request.
 *	stuff is a pointer to the request.
 *
 * Returns:
 *	Any one of several possible error values if any of the request
 *	arguments are invalid.  Success if everything is OK.
 *
 * Side Effects: none.
 */
static int
RecordSanityCheckRegisterClients(RecordContextPtr pContext, ClientPtr client, xRecordRegisterClientsReq *stuff)
{
    int err;
    xRecordRange *pRange;
    int i;
    XID recordingClient;

    if (((client->req_len << 2) - SIZEOF(xRecordRegisterClientsReq)) !=
	4 * stuff->nClients + SIZEOF(xRecordRange) * stuff->nRanges)
	return BadLength;

    if (stuff->elementHeader &
     ~(XRecordFromClientSequence|XRecordFromClientTime|XRecordFromServerTime))
    {
	client->errorValue = stuff->elementHeader;
	return BadValue;
    }

    recordingClient = pContext->pRecordingClient ?
		      pContext->pRecordingClient->clientAsMask : 0;
    err = RecordSanityCheckClientSpecifiers(client, (XID *)&stuff[1],
					    stuff->nClients, recordingClient);
    if (err != Success) return err;

    pRange = (xRecordRange *)(((XID *)&stuff[1]) + stuff->nClients);
    for (i = 0; i < stuff->nRanges; i++, pRange++)
    {
	if (pRange->coreRequestsFirst > pRange->coreRequestsLast)
	{
	    client->errorValue = pRange->coreRequestsFirst;
	    return BadValue;
	}
	if (pRange->coreRepliesFirst > pRange->coreRepliesLast)
	{
	    client->errorValue = pRange->coreRepliesFirst;
	    return BadValue;
	}
	if ((pRange->extRequestsMajorFirst || pRange->extRequestsMajorLast) &&
	    (pRange->extRequestsMajorFirst < 128 ||
	     pRange->extRequestsMajorLast < 128 ||
	     pRange->extRequestsMajorFirst > pRange->extRequestsMajorLast))
	{
	    client->errorValue = pRange->extRequestsMajorFirst;
	    return BadValue;
	}
	if (pRange->extRequestsMinorFirst > pRange->extRequestsMinorLast)
	{
	    client->errorValue = pRange->extRequestsMinorFirst;
	    return BadValue;
	}
	if ((pRange->extRepliesMajorFirst || pRange->extRepliesMajorLast) &&
	    (pRange->extRepliesMajorFirst < 128 ||
	     pRange->extRepliesMajorLast < 128 ||
	     pRange->extRepliesMajorFirst > pRange->extRepliesMajorLast))
	{
	    client->errorValue = pRange->extRepliesMajorFirst;
	    return BadValue;
	}
	if (pRange->extRepliesMinorFirst > pRange->extRepliesMinorLast)
	{
	    client->errorValue = pRange->extRepliesMinorFirst;
	    return BadValue;
	}
	if ((pRange->deliveredEventsFirst || pRange->deliveredEventsLast) &&
	    (pRange->deliveredEventsFirst < 2 ||
	     pRange->deliveredEventsLast < 2 ||
	     pRange->deliveredEventsFirst > pRange->deliveredEventsLast))
	{
	    client->errorValue = pRange->deliveredEventsFirst;
	    return BadValue;
	}
	if ((pRange->deviceEventsFirst || pRange->deviceEventsLast) &&
	    (pRange->deviceEventsFirst < 2 ||
	     pRange->deviceEventsLast < 2 ||
	     pRange->deviceEventsFirst > pRange->deviceEventsLast))
	{
	    client->errorValue = pRange->deviceEventsFirst;
	    return BadValue;
	}
	if (pRange->errorsFirst > pRange->errorsLast)
	{
	    client->errorValue = pRange->errorsFirst;
	    return BadValue;
	}
	if (pRange->clientStarted != xFalse && pRange->clientStarted != xTrue)
	{
	    client->errorValue = pRange->clientStarted;
	    return BadValue;
	}
	if (pRange->clientDied != xFalse && pRange->clientDied != xTrue)
	{
	    client->errorValue = pRange->clientDied;
	    return BadValue;
	}
    } /* end for each range */
    return Success;
} /* end RecordSanityCheckRegisterClients */

/* This is a tactical structure used to gather information about all the sets
 * (RecordSetPtr) that need to be created for an RCAP in the process of 
 * digesting a list of RECORDRANGEs (converting it to the internal
 * representation).
 */
typedef struct
{
    int nintervals;	/* number of intervals in following array */
    RecordSetInterval *intervals;  /* array of intervals for this set */
    int size;		/* size of intevals array; >= nintervals */
    int align;		/* alignment restriction for set */
    int offset;		/* where to store set pointer rel. to start of RCAP */
    short first, last;	/* if for extension, major opcode interval */
} SetInfoRec, *SetInfoPtr;

/* These constant are used to index into an array of SetInfoRec. */
enum {REQ,	/* set info for requests */
      REP,	/* set info for replies */
      ERR,	/* set info for errors */
      DEV,	/* set info for device events */
      DLEV,	/* set info for delivered events */
      PREDEFSETS};  /* number of predefined array entries */


/* RecordAllocIntervals
 *
 * Arguments:
 *	psi is a pointer to a SetInfoRec whose intervals pointer is NULL.
 *	nIntervals is the desired size of the intervals array.
 *
 * Returns: BadAlloc if a memory allocation error occurred, else Success.
 *
 * Side Effects:
 *	If Success is returned, psi->intervals is a pointer to size
 *	RecordSetIntervals, all zeroed, and psi->size is set to size.
 */
static int
RecordAllocIntervals(SetInfoPtr psi, int nIntervals)
{
    assert(!psi->intervals);
    psi->intervals = (RecordSetInterval *)
			malloc(nIntervals * sizeof(RecordSetInterval));
    if (!psi->intervals)
	return BadAlloc;
    memset(psi->intervals, 0, nIntervals * sizeof(RecordSetInterval));
    psi->size = nIntervals;
    return Success;
} /* end RecordAllocIntervals */


/* RecordConvertRangesToIntervals
 *
 * Arguments:
 *	psi is a pointer to the SetInfoRec we are building.
 *	pRanges is an array of xRecordRanges.
 *	nRanges is the number of elements in pRanges.
 *	byteoffset is the offset from the start of an xRecordRange of the
 *	  two bytes (1 for first, 1 for last) we are interested in.
 *	pExtSetInfo, if non-NULL, indicates that the two bytes mentioned
 *	  above are followed by four bytes (2 for first, 2 for last)
 *	  representing a minor opcode range, and this information should be
 *	  stored in one of the SetInfoRecs starting at pExtSetInfo.
 *	pnExtSetInfo is the number of elements in the pExtSetInfo array.
 *
 * Returns:  BadAlloc if a memory allocation error occurred, else Success.
 *
 * Side Effects:
 *	The slice of pRanges indicated by byteoffset is stored in psi.  
 *	If pExtSetInfo is non-NULL, minor opcode intervals are stored
 *	in an existing SetInfoRec if the major opcode interval matches, else
 *	they are stored in a new SetInfoRec, and *pnExtSetInfo is
 *	increased accordingly.
 */
static int
RecordConvertRangesToIntervals(
    SetInfoPtr psi,
    xRecordRange *pRanges,
    int nRanges,
    int byteoffset,
    SetInfoPtr pExtSetInfo,
    int *pnExtSetInfo
)
{
    int i;
    CARD8 *pCARD8;
    int first, last;
    int err;

    for (i = 0; i < nRanges; i++, pRanges++)
    {
	pCARD8 = ((CARD8 *)pRanges) + byteoffset;
	first = pCARD8[0];
	last  = pCARD8[1];
	if (first || last)
	{
	    if (!psi->intervals)
	    {
		err = RecordAllocIntervals(psi, 2 * (nRanges - i));
		if (err != Success)
		    return err;
	    }
	    psi->intervals[psi->nintervals].first = first;
	    psi->intervals[psi->nintervals].last  = last;
	    psi->nintervals++;
	    assert(psi->nintervals <= psi->size);
	    if (pExtSetInfo)
	    {
		SetInfoPtr pesi = pExtSetInfo;
		CARD16 *pCARD16 = (CARD16 *)(pCARD8 + 2);
		int j;

		for (j = 0; j < *pnExtSetInfo; j++, pesi++)
		{
		    if ( (first == pesi->first) && (last == pesi->last) )
			break;
		}
		if (j == *pnExtSetInfo)
		{
		    err = RecordAllocIntervals(pesi, 2 * (nRanges - i));
		    if (err != Success)
			return err;
		    pesi->first = first;
		    pesi->last  = last;
		    (*pnExtSetInfo)++;
		}
		pesi->intervals[pesi->nintervals].first = pCARD16[0];
		pesi->intervals[pesi->nintervals].last  = pCARD16[1];
		pesi->nintervals++;
		assert(pesi->nintervals <= pesi->size);
	    }
	}
    }
    return Success;
}  /* end RecordConvertRangesToIntervals */

#define offset_of(_structure, _field) \
    ((char *)(& (_structure . _field)) - (char *)(&_structure))

/* RecordRegisterClients
 *
 * Arguments:
 *	pContext is the context on which to register the clients.
 *	client is the client that issued the RecordCreateContext or
 *	  RecordRegisterClients request.
 *	stuff is a pointer to the request.
 *
 * Returns:
 *	Any one of several possible error values defined by the protocol.
 *	Success if everything is OK.
 *
 * Side Effects:
 *	If different element headers are specified, the context is flushed.
 *	If any of the specified clients are already registered on the
 *	context, they are first unregistered.  A new RCAP is created to
 *	hold the specified protocol and clients, and it is linked onto the
 *	context.  If the context is enabled, appropriate hooks are installed
 *	to record the new clients and protocol.
 */
static int
RecordRegisterClients(RecordContextPtr pContext, ClientPtr client, xRecordRegisterClientsReq *stuff)
{
    int err;
    int i;
    SetInfoPtr si;
    int maxSets;
    int nExtReqSets = 0;
    int nExtRepSets = 0;
    int extReqSetsOffset = 0;
    int extRepSetsOffset = 0;
    SetInfoPtr pExtReqSets, pExtRepSets;
    int clientListOffset;
    XID *pCanonClients;
    int clientStarted = 0, clientDied = 0;
    xRecordRange *pRanges, rr;
    int nClients;
    int sizeClients;
    int totRCAPsize;
    RecordClientsAndProtocolPtr pRCAP;
    int pad;
    XID recordingClient;

    /* do all sanity checking up front */

    err = RecordSanityCheckRegisterClients(pContext, client, stuff);
    if (err != Success)
	return err;

    /* if element headers changed, flush buffer */
	
    if (pContext->elemHeaders != stuff->elementHeader)
    {
	RecordFlushReplyBuffer(pContext, NULL, 0, NULL, 0);
	pContext->elemHeaders = stuff->elementHeader;
    }

    nClients = stuff->nClients;
    if (!nClients)
	/* if empty clients list, we're done. */
	return Success;

    recordingClient = pContext->pRecordingClient ?
		      pContext->pRecordingClient->clientAsMask : 0;
    pCanonClients = RecordCanonicalizeClientSpecifiers((XID *)&stuff[1],
						 &nClients, recordingClient);
    if (!pCanonClients)
	return BadAlloc;

    /* We may have to create as many as one set for each "predefined"
     * protocol types, plus one per range for extension reuests, plus one per
     * range for extension replies.
     */
    maxSets = PREDEFSETS + 2 * stuff->nRanges;
    si = (SetInfoPtr)malloc(sizeof(SetInfoRec) * maxSets);
    if (!si)
    {
	err = BadAlloc;
	goto bailout;
    }
    memset(si, 0, sizeof(SetInfoRec) * maxSets);

    /* theoretically you must do this because NULL may not be all-bits-zero */
    for (i = 0; i < maxSets; i++)
	si[i].intervals = NULL;

    pExtReqSets = si + PREDEFSETS;
    pExtRepSets = pExtReqSets + stuff->nRanges;

    pRanges = (xRecordRange *)(((XID *)&stuff[1]) + stuff->nClients);

    err = RecordConvertRangesToIntervals(&si[REQ], pRanges, stuff->nRanges,
			offset_of(rr, coreRequestsFirst), NULL, NULL);
    if (err != Success) goto bailout;

    err = RecordConvertRangesToIntervals(&si[REQ], pRanges, stuff->nRanges,
	   offset_of(rr, extRequestsMajorFirst), pExtReqSets, &nExtReqSets);
    if (err != Success) goto bailout;

    err = RecordConvertRangesToIntervals(&si[REP], pRanges, stuff->nRanges,
			offset_of(rr, coreRepliesFirst), NULL, NULL);
    if (err != Success) goto bailout;

    err = RecordConvertRangesToIntervals(&si[REP], pRanges, stuff->nRanges,
	   offset_of(rr, extRepliesMajorFirst), pExtRepSets, &nExtRepSets);
    if (err != Success) goto bailout;

    err = RecordConvertRangesToIntervals(&si[ERR], pRanges, stuff->nRanges,
			offset_of(rr, errorsFirst), NULL, NULL);
    if (err != Success) goto bailout;

    err = RecordConvertRangesToIntervals(&si[DLEV], pRanges, stuff->nRanges,
			offset_of(rr, deliveredEventsFirst), NULL, NULL);
    if (err != Success) goto bailout;

    err = RecordConvertRangesToIntervals(&si[DEV], pRanges, stuff->nRanges,
			offset_of(rr, deviceEventsFirst), NULL, NULL);
    if (err != Success) goto bailout;

    /* collect client-started and client-died */

    for (i = 0; i < stuff->nRanges; i++)
    {
	if (pRanges[i].clientStarted) clientStarted = TRUE;
	if (pRanges[i].clientDied)    clientDied    = TRUE;
    }

    /*  We now have all the information collected to create all the sets,
     * and we can compute the total memory required for the RCAP.
     */

    totRCAPsize = sizeof(RecordClientsAndProtocolRec);

    /* leave a little room to grow before forcing a separate allocation */
    sizeClients = nClients + CLIENT_ARRAY_GROWTH_INCREMENT;
    pad = RecordPadAlign(totRCAPsize, sizeof(XID));
    clientListOffset = totRCAPsize + pad;
    totRCAPsize += pad + sizeClients * sizeof(XID);

    if (nExtReqSets)
    {
	pad = RecordPadAlign(totRCAPsize, sizeof(RecordSetPtr));
	extReqSetsOffset = totRCAPsize + pad;
	totRCAPsize += pad + (nExtReqSets + 1) * sizeof(RecordMinorOpRec);
    }
    if (nExtRepSets)
    {
	pad = RecordPadAlign(totRCAPsize, sizeof(RecordSetPtr));
	extRepSetsOffset = totRCAPsize + pad;
	totRCAPsize += pad + (nExtRepSets + 1) * sizeof(RecordMinorOpRec);
    }

    for (i = 0; i < maxSets; i++)
    {
	if (si[i].nintervals)
	{
	    si[i].size = RecordSetMemoryRequirements(
				si[i].intervals, si[i].nintervals, &si[i].align);
	    pad = RecordPadAlign(totRCAPsize, si[i].align);
	    si[i].offset = pad + totRCAPsize;
	    totRCAPsize += pad + si[i].size;
	}
    }

    /* allocate memory for the whole RCAP */

    pRCAP = (RecordClientsAndProtocolPtr)malloc(totRCAPsize);
    if (!pRCAP) 
    {
	err = BadAlloc;
	goto bailout;
    }

    /* fill in the RCAP */

    pRCAP->pContext = pContext;
    pRCAP->pClientIDs = (XID *)((char *)pRCAP + clientListOffset);
    pRCAP->numClients  = nClients;
    pRCAP->sizeClients = sizeClients;
    pRCAP->clientIDsSeparatelyAllocated = 0;
    for (i = 0; i < nClients; i++)
    {
	RecordDeleteClientFromContext(pContext, pCanonClients[i]);
	pRCAP->pClientIDs[i] = pCanonClients[i];
    }

    /* create all the sets */

    if (si[REQ].intervals)
    {
	pRCAP->pRequestMajorOpSet =
	    RecordCreateSet(si[REQ].intervals, si[REQ].nintervals,
		(RecordSetPtr)((char *)pRCAP + si[REQ].offset), si[REQ].size);
    }
    else pRCAP->pRequestMajorOpSet = NULL;

    if (si[REP].intervals)
    {
	pRCAP->pReplyMajorOpSet =
	    RecordCreateSet(si[REP].intervals, si[REP].nintervals,
		(RecordSetPtr)((char *)pRCAP + si[REP].offset), si[REP].size);
    }
    else pRCAP->pReplyMajorOpSet = NULL;

    if (si[ERR].intervals)
    {
	pRCAP->pErrorSet =
	    RecordCreateSet(si[ERR].intervals, si[ERR].nintervals,
		(RecordSetPtr)((char *)pRCAP + si[ERR].offset), si[ERR].size);
    }
    else pRCAP->pErrorSet = NULL;

    if (si[DEV].intervals)
    {
	pRCAP->pDeviceEventSet =
	    RecordCreateSet(si[DEV].intervals, si[DEV].nintervals,
		(RecordSetPtr)((char *)pRCAP + si[DEV].offset), si[DEV].size);
    }
    else pRCAP->pDeviceEventSet = NULL;

    if (si[DLEV].intervals)
    {
	pRCAP->pDeliveredEventSet =
	    RecordCreateSet(si[DLEV].intervals, si[DLEV].nintervals,
	      (RecordSetPtr)((char *)pRCAP + si[DLEV].offset), si[DLEV].size);
    }
    else pRCAP->pDeliveredEventSet = NULL;

    if (nExtReqSets)
    {
	pRCAP->pRequestMinOpInfo = (RecordMinorOpPtr)
					((char *)pRCAP + extReqSetsOffset);
	pRCAP->pRequestMinOpInfo[0].count = nExtReqSets;
	for (i = 0; i < nExtReqSets; i++, pExtReqSets++)
	{
	    pRCAP->pRequestMinOpInfo[i+1].major.first = pExtReqSets->first;
	    pRCAP->pRequestMinOpInfo[i+1].major.last  = pExtReqSets->last;
	    pRCAP->pRequestMinOpInfo[i+1].major.pMinOpSet =
		RecordCreateSet(pExtReqSets->intervals,
				pExtReqSets->nintervals, 
		  (RecordSetPtr)((char *)pRCAP + pExtReqSets->offset),
				pExtReqSets->size);
	}
    }
    else pRCAP->pRequestMinOpInfo = NULL;

    if (nExtRepSets)
    {
	pRCAP->pReplyMinOpInfo = (RecordMinorOpPtr)
					((char *)pRCAP + extRepSetsOffset);
	pRCAP->pReplyMinOpInfo[0].count = nExtRepSets;
	for (i = 0; i < nExtRepSets; i++, pExtRepSets++)
	{
	    pRCAP->pReplyMinOpInfo[i+1].major.first = pExtRepSets->first;
	    pRCAP->pReplyMinOpInfo[i+1].major.last  = pExtRepSets->last;
	    pRCAP->pReplyMinOpInfo[i+1].major.pMinOpSet =
		RecordCreateSet(pExtRepSets->intervals,
				pExtRepSets->nintervals, 
		  (RecordSetPtr)((char *)pRCAP + pExtRepSets->offset),
				pExtRepSets->size);
	}
    }
    else pRCAP->pReplyMinOpInfo = NULL;

    pRCAP->clientStarted = clientStarted;
    pRCAP->clientDied    = clientDied;

    /* link the RCAP onto the context */

    pRCAP->pNextRCAP = pContext->pListOfRCAP;
    pContext->pListOfRCAP = pRCAP;

    if (pContext->pRecordingClient) /* context enabled */
	RecordInstallHooks(pRCAP, 0);

bailout:
    if (si)
    {
	for (i = 0; i < maxSets; i++)
	    free(si[i].intervals);
	free(si);
    }
    if (pCanonClients && pCanonClients != (XID *)&stuff[1])
	free(pCanonClients);
    return err;
} /* RecordRegisterClients */


/* Proc functions all take a client argument, execute the request in
 * client->requestBuffer, and return a protocol error status.
 */

static int
ProcRecordQueryVersion(ClientPtr client)
{
    /* REQUEST(xRecordQueryVersionReq); */
    xRecordQueryVersionReply 	rep;
    int 		n;

    REQUEST_SIZE_MATCH(xRecordQueryVersionReq);
    rep.type        	= X_Reply;
    rep.sequenceNumber 	= client->sequence;
    rep.length         	= 0;
    rep.majorVersion  	= SERVER_RECORD_MAJOR_VERSION;
    rep.minorVersion  	= SERVER_RECORD_MINOR_VERSION;
    if(client->swapped)
    {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    (void)WriteToClient(client, sizeof(xRecordQueryVersionReply),
			(char *)&rep);
    return Success;
} /* ProcRecordQueryVersion */


static int
ProcRecordCreateContext(ClientPtr client)
{
    REQUEST(xRecordCreateContextReq);
    RecordContextPtr pContext;
    RecordContextPtr *ppNewAllContexts = NULL;
    int err = BadAlloc;

    REQUEST_AT_LEAST_SIZE(xRecordCreateContextReq);
    LEGAL_NEW_RESOURCE(stuff->context, client);

    pContext = (RecordContextPtr)malloc(sizeof(RecordContextRec));
    if (!pContext)
	goto bailout;

    /* make sure there is room in ppAllContexts to store the new context */

    ppNewAllContexts = (RecordContextPtr *)
	realloc(ppAllContexts, sizeof(RecordContextPtr) * (numContexts + 1));
    if (!ppNewAllContexts)
	goto bailout;
    ppAllContexts = ppNewAllContexts;

    pContext->id = stuff->context;
    pContext->pRecordingClient = NULL;
    pContext->pListOfRCAP = NULL;
    pContext->elemHeaders = 0;
    pContext->bufCategory = 0;
    pContext->numBufBytes = 0;
    pContext->pBufClient = NULL;
    pContext->continuedReply = 0;
    pContext->inFlush = 0;

    err = RecordRegisterClients(pContext, client,
				(xRecordRegisterClientsReq *)stuff);
    if (err != Success)
	goto bailout;

    if (AddResource(pContext->id, RTContext, pContext))
    {
	ppAllContexts[numContexts++] = pContext;
	return Success;
    }
    else
    {
	RecordDeleteContext((pointer)pContext, pContext->id);
	return BadAlloc;
    }
bailout:
    free(pContext);
    return err;
} /* ProcRecordCreateContext */


static int
ProcRecordRegisterClients(ClientPtr client)
{
    RecordContextPtr pContext;
    REQUEST(xRecordRegisterClientsReq);

    REQUEST_AT_LEAST_SIZE(xRecordRegisterClientsReq);
    VERIFY_CONTEXT(pContext, stuff->context, client);

    return RecordRegisterClients(pContext, client, stuff);
} /* ProcRecordRegisterClients */


static int
ProcRecordUnregisterClients(ClientPtr client)
{
    RecordContextPtr pContext;
    int err;
    REQUEST(xRecordUnregisterClientsReq);
    XID *pCanonClients;
    int nClients;
    int i;

    REQUEST_AT_LEAST_SIZE(xRecordUnregisterClientsReq);
    if ((client->req_len << 2) - SIZEOF(xRecordUnregisterClientsReq) !=
	4 * stuff->nClients)
	return BadLength;
    VERIFY_CONTEXT(pContext, stuff->context, client);
    err = RecordSanityCheckClientSpecifiers(client, (XID *)&stuff[1],
					    stuff->nClients, 0);
    if (err != Success)
	return err;

    nClients = stuff->nClients;
    pCanonClients = RecordCanonicalizeClientSpecifiers((XID *)&stuff[1],
						 &nClients, 0);
    if (!pCanonClients)
	return BadAlloc;

    for (i = 0; i < nClients; i++)
    {
	RecordDeleteClientFromContext(pContext, pCanonClients[i]);
    }
    if (pCanonClients != (XID *)&stuff[1])
	free(pCanonClients);
    return Success;
} /* ProcRecordUnregisterClients */


/****************************************************************************/

/* stuff for GetContext */

/* This is a tactical structure used to hold the xRecordRanges as they are
 * being reconstituted from the sets in the RCAPs.
 */

typedef struct {
    xRecordRange *pRanges;  /* array of xRecordRanges for one RCAP */
    int size;		/* number of elements in pRanges, >= nRanges */
    int nRanges;	/* number of occupied element of pRanges */
} GetContextRangeInfoRec, *GetContextRangeInfoPtr;


/* RecordAllocRanges
 *
 * Arguments:
 *	pri is a pointer to a GetContextRangeInfoRec to allocate for.
 *	nRanges is the number of xRecordRanges desired for pri.
 *
 * Returns: BadAlloc if a memory allocation error occurred, else Success.
 *
 * Side Effects:
 *	If Success is returned, pri->pRanges points to at least nRanges
 *	ranges.  pri->nRanges is set to nRanges.  pri->size is the actual
 *	number of ranges.  Newly allocated ranges are zeroed.
 */
static int
RecordAllocRanges(GetContextRangeInfoPtr pri, int nRanges)
{
    int newsize;
    xRecordRange *pNewRange;
#define SZINCR 8

    newsize = max(pri->size + SZINCR, nRanges);
    pNewRange = (xRecordRange *)realloc(pri->pRanges,
			 newsize * sizeof(xRecordRange));
    if (!pNewRange)
	return BadAlloc;

    pri->pRanges = pNewRange;
    pri->size = newsize;
    memset(&pri->pRanges[pri->size - SZINCR], 0, SZINCR * sizeof(xRecordRange));
    if (pri->nRanges < nRanges)
	pri->nRanges = nRanges;
    return Success;
} /* RecordAllocRanges */


/* RecordConvertSetToRanges
 *
 * Arguments:
 *	pSet is the set to be converted.
 *	pri is where the result should be stored.
 *	byteoffset is the offset from the start of an xRecordRange of the
 *	  two vales (first, last) we are interested in.
 *	card8 is TRUE if the vales are one byte each and FALSE if two bytes
 *	  each.
 *	imax is the largest set value to store in pri->pRanges.
 *	pStartIndex, if non-NULL, is the index of the first range in
 *	  pri->pRanges that should be stored to.  If NULL,
 *	  start at index 0.
 *
 * Returns: BadAlloc if a memory allocation error occurred, else Success.
 *
 * Side Effects:
 *	If Success is returned, the slice of pri->pRanges indicated by
 *	byteoffset and card8 is filled in with the intervals from pSet.
 *	if pStartIndex was non-NULL, *pStartIndex is filled in with one
 *	more than the index of the last xRecordRange that was touched.
 */
static int
RecordConvertSetToRanges(
    RecordSetPtr pSet,
    GetContextRangeInfoPtr pri,
    int byteoffset,
    Bool card8,
    unsigned int imax,
    int *pStartIndex
)
{
    int nRanges;
    RecordSetIteratePtr pIter = NULL;
    RecordSetInterval interval;
    CARD8 *pCARD8;
    CARD16 *pCARD16;
    int err;

    if (!pSet)
	return Success;

    nRanges = pStartIndex ? *pStartIndex : 0;
    while ((pIter = RecordIterateSet(pSet, pIter, &interval)))
    {
	if (interval.first > imax) break;
	if (interval.last  > imax) interval.last = imax;
	nRanges++;
	if (nRanges > pri->size)
	{
	    err = RecordAllocRanges(pri, nRanges);
	    if (err != Success)
		return err;
	}
	else
	    pri->nRanges = max(pri->nRanges, nRanges);
	if (card8)
	{
	    pCARD8 = ((CARD8 *)&pri->pRanges[nRanges-1]) + byteoffset;
	    *pCARD8++ = interval.first;
	    *pCARD8   = interval.last;
	}
	else
	{
	    pCARD16 = (CARD16 *)
			(((char *)&pri->pRanges[nRanges-1]) + byteoffset);
	    *pCARD16++ = interval.first;
	    *pCARD16   = interval.last;
	}
    }
    if (pStartIndex)
	*pStartIndex = nRanges;
    return Success;
} /* RecordConvertSetToRanges */


/* RecordConvertMinorOpInfoToRanges
 *
 * Arguments:
 *	pMinOpInfo is the minor opcode info to convert to xRecordRanges.
 *	pri is where the result should be stored.
 *	byteoffset is the offset from the start of an xRecordRange of the
 *	  four vales (CARD8 major_first, CARD8 major_last,
 *	  CARD16 minor_first, CARD16 minor_last) we are going to store.
 *
 * Returns: BadAlloc if a memory allocation error occurred, else Success.
 *
 * Side Effects:
 *	If Success is returned, the slice of pri->pRanges indicated by
 *	byteoffset is filled in with the information from pMinOpInfo.
 */
static int
RecordConvertMinorOpInfoToRanges(
    RecordMinorOpPtr pMinOpInfo,
    GetContextRangeInfoPtr pri,
    int byteoffset
)
{
    int nsets;
    int start;
    int i;
    int err;

    if (!pMinOpInfo)
	return Success;

    nsets = pMinOpInfo->count;
    pMinOpInfo++;
    start = 0;
    for (i = 0; i < nsets; i++)
    {
	int j, s;
	s = start;
	err = RecordConvertSetToRanges(pMinOpInfo[i].major.pMinOpSet, pri,
				byteoffset + 2, FALSE, 65535, &start);
	if (err != Success) return err;
	for (j = s; j < start; j++)
	{
	    CARD8 *pCARD8 = ((CARD8 *)&pri->pRanges[j]) + byteoffset;
	    *pCARD8++ = pMinOpInfo[i].major.first;
	    *pCARD8   = pMinOpInfo[i].major.last;
	}
    }
    return Success;
} /* RecordConvertMinorOpInfoToRanges */


/* RecordSwapRanges
 *
 * Arguments:
 *	pRanges is an array of xRecordRanges.
 *	nRanges is the number of elements in pRanges.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	The 16 bit fields of each xRecordRange are byte swapped.
 */
static void
RecordSwapRanges(xRecordRange *pRanges, int nRanges)
{
    int i;
    register char n;
    for (i = 0; i < nRanges; i++, pRanges++)
    {
	swaps(&pRanges->extRequestsMinorFirst, n);
	swaps(&pRanges->extRequestsMinorLast, n);
	swaps(&pRanges->extRepliesMinorFirst, n);
	swaps(&pRanges->extRepliesMinorLast, n);
    }
} /* RecordSwapRanges */


static int
ProcRecordGetContext(ClientPtr client)
{
    RecordContextPtr pContext;
    REQUEST(xRecordGetContextReq);
    xRecordGetContextReply rep;
    int n;
    RecordClientsAndProtocolPtr pRCAP;
    int nRCAPs = 0;
    GetContextRangeInfoPtr pRangeInfo;
    GetContextRangeInfoPtr pri;
    int i;
    int err;

    REQUEST_SIZE_MATCH(xRecordGetContextReq);
    VERIFY_CONTEXT(pContext, stuff->context, client);

    /* how many RCAPs are there on this context? */

    for (pRCAP = pContext->pListOfRCAP; pRCAP; pRCAP = pRCAP->pNextRCAP)
	nRCAPs++;

    /* allocate and initialize space for record range info */

    pRangeInfo = (GetContextRangeInfoPtr)malloc(
				nRCAPs * sizeof(GetContextRangeInfoRec));
    if (!pRangeInfo && nRCAPs > 0)
	return BadAlloc;
    for (i = 0; i < nRCAPs; i++)
    {
	pRangeInfo[i].pRanges = NULL;
	pRangeInfo[i].size = 0;
	pRangeInfo[i].nRanges = 0;
    }

    /* convert the RCAP (internal) representation of the recorded protocol
     * to the wire protocol (external) representation, storing the information
     * for the ith RCAP in pri[i]
     */

    for (pRCAP = pContext->pListOfRCAP, pri = pRangeInfo;
	 pRCAP;
	 pRCAP = pRCAP->pNextRCAP, pri++)
    {
	xRecordRange rr;

	err = RecordConvertSetToRanges(pRCAP->pRequestMajorOpSet, pri,
			offset_of(rr, coreRequestsFirst), TRUE, 127, NULL);
	if (err != Success) goto bailout;

	err = RecordConvertSetToRanges(pRCAP->pReplyMajorOpSet, pri,
			offset_of(rr, coreRepliesFirst), TRUE, 127, NULL);
	if (err != Success) goto bailout;

	err = RecordConvertSetToRanges(pRCAP->pDeliveredEventSet, pri,
			offset_of(rr, deliveredEventsFirst), TRUE, 255, NULL);
	if (err != Success) goto bailout;

	err = RecordConvertSetToRanges(pRCAP->pDeviceEventSet, pri,
			offset_of(rr, deviceEventsFirst), TRUE, 255, NULL);
	if (err != Success) goto bailout;

	err = RecordConvertSetToRanges(pRCAP->pErrorSet, pri,
			      offset_of(rr, errorsFirst), TRUE, 255, NULL);
	if (err != Success) goto bailout;

	err = RecordConvertMinorOpInfoToRanges(pRCAP->pRequestMinOpInfo,
				pri, offset_of(rr, extRequestsMajorFirst));
	if (err != Success) goto bailout;

	err = RecordConvertMinorOpInfoToRanges(pRCAP->pReplyMinOpInfo,
				pri, offset_of(rr, extRepliesMajorFirst));
	if (err != Success) goto bailout;

	if (pRCAP->clientStarted || pRCAP->clientDied)
	{
	    if (pri->nRanges == 0)
		RecordAllocRanges(pri, 1);
	    pri->pRanges[0].clientStarted = pRCAP->clientStarted;
	    pri->pRanges[0].clientDied    = pRCAP->clientDied;
	}
    }

    /* calculate number of clients and reply length */

    rep.nClients = 0;
    rep.length = 0;
    for (pRCAP = pContext->pListOfRCAP, pri = pRangeInfo;
	 pRCAP;
	 pRCAP = pRCAP->pNextRCAP, pri++)
    {
	rep.nClients += pRCAP->numClients;
	rep.length += pRCAP->numClients *
		( bytes_to_int32(sizeof(xRecordClientInfo)) +
		  pri->nRanges * bytes_to_int32(sizeof(xRecordRange)));
    }

    /* write the reply header */

    rep.type = X_Reply;
    rep.sequenceNumber 	= client->sequence;
    rep.enabled = pContext->pRecordingClient != NULL;
    rep.elementHeader = pContext->elemHeaders;
    if(client->swapped)
    {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swapl(&rep.nClients, n);
    }
    (void)WriteToClient(client, sizeof(xRecordGetContextReply),
			(char *)&rep);

    /* write all the CLIENT_INFOs */

    for (pRCAP = pContext->pListOfRCAP, pri = pRangeInfo;
	 pRCAP;
	 pRCAP = pRCAP->pNextRCAP, pri++)
    {
	xRecordClientInfo rci;
	rci.nRanges = pri->nRanges;
	if (client->swapped)
	{
	    swapl(&rci.nRanges, n);
	    RecordSwapRanges(pri->pRanges, pri->nRanges);
	}
	for (i = 0; i < pRCAP->numClients; i++)
	{
	    rci.clientResource = pRCAP->pClientIDs[i];
	    if (client->swapped) swapl(&rci.clientResource, n);
	    WriteToClient(client, sizeof(xRecordClientInfo), (char *)&rci);
	    WriteToClient(client, sizeof(xRecordRange) * pri->nRanges,
			  (char *)pri->pRanges);
	}
    }
    err = Success;

bailout:
    for (i = 0; i < nRCAPs; i++)
    {
	free(pRangeInfo[i].pRanges);
    }
    free(pRangeInfo);
    return err;
} /* ProcRecordGetContext */


static int
ProcRecordEnableContext(ClientPtr client)
{
    RecordContextPtr pContext;
    REQUEST(xRecordEnableContextReq);
    int i;
    RecordClientsAndProtocolPtr pRCAP;

    REQUEST_SIZE_MATCH(xRecordGetContextReq);
    VERIFY_CONTEXT(pContext, stuff->context, client);
    if (pContext->pRecordingClient)
	return BadMatch; /* already enabled */

    /* install record hooks for each RCAP */

    for (pRCAP = pContext->pListOfRCAP; pRCAP; pRCAP = pRCAP->pNextRCAP)
    {
	int err = RecordInstallHooks(pRCAP, 0);
	if (err != Success)
	{ /* undo the previous installs */
	    RecordClientsAndProtocolPtr pUninstallRCAP;
	    for (pUninstallRCAP = pContext->pListOfRCAP;
		 pUninstallRCAP != pRCAP;
		 pUninstallRCAP = pUninstallRCAP->pNextRCAP)
	    {
		RecordUninstallHooks(pUninstallRCAP, 0);
	    }
	    return err;
	}
    }

    /* Disallow further request processing on this connection until
     * the context is disabled.
     */
    IgnoreClient(client);
    pContext->pRecordingClient = client;

    /* Don't allow the data connection to record itself; unregister it. */
    RecordDeleteClientFromContext(pContext,
				  pContext->pRecordingClient->clientAsMask);

    /* move the newly enabled context to the front part of ppAllContexts,
     * where all the enabled contexts are
     */
    i = RecordFindContextOnAllContexts(pContext);
    assert(i >= numEnabledContexts);
    if (i != numEnabledContexts)
    {
	ppAllContexts[i] = ppAllContexts[numEnabledContexts];
	ppAllContexts[numEnabledContexts] = pContext;
    }

    ++numEnabledContexts;
    assert(numEnabledContexts > 0);

    /* send StartOfData */
    RecordAProtocolElement(pContext, NULL, XRecordStartOfData, NULL, 0, 0);
    RecordFlushReplyBuffer(pContext, NULL, 0, NULL, 0);
    return Success;
} /* ProcRecordEnableContext */


/* RecordDisableContext
 *
 * Arguments:
 *	pContext is the context to disable.
 *	nRanges is the number of elements in pRanges.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	If the context was enabled, it is disabled.  An EndOfData
 *	message is sent to the recording client.  Recording hooks for
 *	this context are uninstalled.  The context is moved to the
 *	rear part of the ppAllContexts array.  numEnabledContexts is
 *	decremented.  Request processing for the formerly recording client
 *	is resumed.
 */
static void
RecordDisableContext(RecordContextPtr pContext)
{
    RecordClientsAndProtocolPtr pRCAP;
    int i;

    if (!pContext->pRecordingClient) return;
    if (!pContext->pRecordingClient->clientGone)
    {
	RecordAProtocolElement(pContext, NULL, XRecordEndOfData, NULL, 0, 0);
	RecordFlushReplyBuffer(pContext, NULL, 0, NULL, 0);
	/* Re-enable request processing on this connection. */
	AttendClient(pContext->pRecordingClient);
    }

    for (pRCAP = pContext->pListOfRCAP; pRCAP; pRCAP = pRCAP->pNextRCAP)
    {
	RecordUninstallHooks(pRCAP, 0);
    }

    pContext->pRecordingClient = NULL;

    /* move the newly disabled context to the rear part of ppAllContexts,
     * where all the disabled contexts are
     */
    i = RecordFindContextOnAllContexts(pContext);
    assert( (i != -1) && (i < numEnabledContexts) );
    if (i != (numEnabledContexts - 1) )
    {
	ppAllContexts[i] = ppAllContexts[numEnabledContexts-1];
	ppAllContexts[numEnabledContexts-1] = pContext;
    }
    --numEnabledContexts;
    assert(numEnabledContexts >= 0);
} /* RecordDisableContext */


static int
ProcRecordDisableContext(ClientPtr client)
{
    RecordContextPtr pContext;
    REQUEST(xRecordDisableContextReq);

    REQUEST_SIZE_MATCH(xRecordDisableContextReq);
    VERIFY_CONTEXT(pContext, stuff->context, client);
    RecordDisableContext(pContext);
    return Success;
} /* ProcRecordDisableContext */


/* RecordDeleteContext
 *
 * Arguments:
 *	value is the context to delete.
 *	id is its resource ID.
 *
 * Returns: Success.
 *
 * Side Effects:
 *	Disables the context, frees all associated memory, and removes
 *	it from the ppAllContexts array.
 */
static int
RecordDeleteContext(pointer value, XID id)
{
    int i;
    RecordContextPtr pContext = (RecordContextPtr)value;
    RecordClientsAndProtocolPtr pRCAP;

    RecordDisableContext(pContext);

    /*  Remove all the clients from all the RCAPs.
     *  As a result, the RCAPs will be freed.
     */

    while ((pRCAP = pContext->pListOfRCAP))
    {
	int numClients = pRCAP->numClients;
	/* when the last client is deleted, the RCAP will go away. */
	while(numClients--)
	{
	    RecordDeleteClientFromRCAP(pRCAP, numClients);
	}
    }

    /* remove context from AllContexts list */

    if (-1 != (i = RecordFindContextOnAllContexts(pContext)))
    {
	ppAllContexts[i] = ppAllContexts[numContexts - 1];
	if (--numContexts == 0)
	{
	    free(ppAllContexts);
	    ppAllContexts = NULL;
	}
    }
    free(pContext);

    return Success;
} /* RecordDeleteContext */


static int
ProcRecordFreeContext(ClientPtr client)
{
    RecordContextPtr pContext;
    REQUEST(xRecordFreeContextReq);

    REQUEST_SIZE_MATCH(xRecordFreeContextReq);
    VERIFY_CONTEXT(pContext, stuff->context, client);
    FreeResource(stuff->context, RT_NONE);
    return Success;
} /* ProcRecordFreeContext */


static int
ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
	case X_RecordQueryVersion:
	    return ProcRecordQueryVersion(client);
	case X_RecordCreateContext:
	    return ProcRecordCreateContext(client);
	case X_RecordRegisterClients:
	    return ProcRecordRegisterClients(client);
	case X_RecordUnregisterClients:
	    return ProcRecordUnregisterClients(client);
	case X_RecordGetContext:
	    return ProcRecordGetContext(client);
	case X_RecordEnableContext:
	    return ProcRecordEnableContext(client);
	case X_RecordDisableContext:
	    return ProcRecordDisableContext(client);
	case X_RecordFreeContext:
	    return ProcRecordFreeContext(client);
       default:
	    return BadRequest;
    }
} /* ProcRecordDispatch */


static int
SProcRecordQueryVersion(ClientPtr client)
{
    REQUEST(xRecordQueryVersionReq);
    register char 	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xRecordQueryVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion,n);
    return ProcRecordQueryVersion(client);
} /* SProcRecordQueryVersion */


static int
SwapCreateRegister(xRecordRegisterClientsReq *stuff)
{
    register char n;
    int i;
    XID *pClientID;

    swapl(&stuff->context, n);
    swapl(&stuff->nClients, n);
    swapl(&stuff->nRanges, n);
    pClientID = (XID *)&stuff[1];
    if (stuff->nClients > stuff->length - bytes_to_int32(sz_xRecordRegisterClientsReq))
	return BadLength;
    for (i = 0; i < stuff->nClients; i++, pClientID++)
    {
	swapl(pClientID, n);
    }
    if (stuff->nRanges > stuff->length - bytes_to_int32(sz_xRecordRegisterClientsReq)
	- stuff->nClients)
	return BadLength;
    RecordSwapRanges((xRecordRange *)pClientID, stuff->nRanges);
    return Success;
} /* SwapCreateRegister */


static int
SProcRecordCreateContext(ClientPtr client)
{
    REQUEST(xRecordCreateContextReq);
    int			status;
    register char 	n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xRecordCreateContextReq);
    if ((status = SwapCreateRegister((pointer)stuff)) != Success)
	return status;
    return ProcRecordCreateContext(client);
} /* SProcRecordCreateContext */


static int
SProcRecordRegisterClients(ClientPtr client)
{
    REQUEST(xRecordRegisterClientsReq);
    int			status;
    register char 	n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xRecordRegisterClientsReq);
    if ((status = SwapCreateRegister((pointer)stuff)) != Success)
	return status;
    return ProcRecordRegisterClients(client);
} /* SProcRecordRegisterClients */


static int
SProcRecordUnregisterClients(ClientPtr client)
{
    REQUEST(xRecordUnregisterClientsReq);
    register char 	n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xRecordUnregisterClientsReq);
    swapl(&stuff->context, n);
    swapl(&stuff->nClients, n);
    SwapRestL(stuff);
    return ProcRecordUnregisterClients(client);
} /* SProcRecordUnregisterClients */


static int
SProcRecordGetContext(ClientPtr client)
{
    REQUEST(xRecordGetContextReq);
    register char 	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xRecordGetContextReq);
    swapl(&stuff->context, n);
    return ProcRecordGetContext(client);
} /* SProcRecordGetContext */

static int
SProcRecordEnableContext(ClientPtr client)
{
    REQUEST(xRecordEnableContextReq);
    register char 	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xRecordEnableContextReq);
    swapl(&stuff->context, n);
    return ProcRecordEnableContext(client);
} /* SProcRecordEnableContext */


static int
SProcRecordDisableContext(ClientPtr client)
{
    REQUEST(xRecordDisableContextReq);
    register char 	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xRecordDisableContextReq);
    swapl(&stuff->context, n);
    return ProcRecordDisableContext(client);
} /* SProcRecordDisableContext */


static int
SProcRecordFreeContext(ClientPtr client)
{
    REQUEST(xRecordFreeContextReq);
    register char 	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xRecordFreeContextReq);
    swapl(&stuff->context, n);
    return ProcRecordFreeContext(client);
} /* SProcRecordFreeContext */


static int
SProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
	case X_RecordQueryVersion:
	    return SProcRecordQueryVersion(client);
	case X_RecordCreateContext:
	    return SProcRecordCreateContext(client);
	case X_RecordRegisterClients:
	    return SProcRecordRegisterClients(client);
	case X_RecordUnregisterClients:
	    return SProcRecordUnregisterClients(client);
	case X_RecordGetContext:
	    return SProcRecordGetContext(client);
	case X_RecordEnableContext:
	    return SProcRecordEnableContext(client);
	case X_RecordDisableContext:
	    return SProcRecordDisableContext(client);
	case X_RecordFreeContext:
	    return SProcRecordFreeContext(client);
       default:
	    return BadRequest;
    }
} /* SProcRecordDispatch */

/* RecordConnectionSetupInfo
 *
 * Arguments:
 *	pContext is an enabled context that specifies recording of 
 *	  connection setup info.
 *	pci holds the connection setup info.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	The connection setup info is sent to the recording client.
 */
static void
RecordConnectionSetupInfo(RecordContextPtr pContext, NewClientInfoRec *pci)
{
    int prefixsize = SIZEOF(xConnSetupPrefix);
    int restsize = pci->prefix->length * 4;

    if (pci->client->swapped)
    {
	char *pConnSetup = (char *)malloc(prefixsize + restsize);
	if (!pConnSetup)
	    return;
	SwapConnSetupPrefix(pci->prefix, (xConnSetupPrefix*)pConnSetup);
	SwapConnSetupInfo((char*)pci->setup, (char*)(pConnSetup + prefixsize));
	RecordAProtocolElement(pContext, pci->client, XRecordClientStarted,
			       (pointer)pConnSetup, prefixsize + restsize, 0);
	free(pConnSetup);
    }
    else
    {
	/* don't alloc and copy as in the swapped case; just send the
	 * data in two pieces
	 */
	RecordAProtocolElement(pContext, pci->client, XRecordClientStarted,
			(pointer)pci->prefix, prefixsize, restsize);
	RecordAProtocolElement(pContext, pci->client, XRecordClientStarted,
			(pointer)pci->setup, restsize, /* continuation */ -1);
    }
} /* RecordConnectionSetupInfo */


/* RecordDeleteContext
 *
 * Arguments:
 *	pcbl is &ClientStateCallback.
 *	nullata is NULL.
 *	calldata is a pointer to a NewClientInfoRec (include/dixstruct.h)
 *	which contains information about client state changes.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	If a new client has connected and any contexts have specified
 *	XRecordFutureClients, the new client is registered on those contexts.
 *	If any of those contexts specify recording of the connection setup
 *	info, it is recorded.
 *
 *	If an existing client has disconnected, it is deleted from any
 *	contexts that it was registered on.  If any of those contexts
 *	specified XRecordClientDied, they record a ClientDied protocol element.
 *	If the disconnectiong client happened to be the data connection of an
 *	enabled context, the context is disabled.
 */

static void
RecordAClientStateChange(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
{
    NewClientInfoRec *pci = (NewClientInfoRec *)calldata;
    int i;
    ClientPtr pClient = pci->client;
    RecordContextPtr *ppAllContextsCopy = NULL;
    int numContextsCopy = 0;

    switch (pClient->clientState)
    {
    case ClientStateRunning: /* new client */
	for (i = 0; i < numContexts; i++)
	{
	    RecordClientsAndProtocolPtr pRCAP;
	    RecordContextPtr pContext = ppAllContexts[i];

	    if ((pRCAP = RecordFindClientOnContext(pContext,
					    XRecordFutureClients, NULL)))
	    {
		RecordAddClientToRCAP(pRCAP, pClient->clientAsMask);
		if (pContext->pRecordingClient && pRCAP->clientStarted)
		    RecordConnectionSetupInfo(pContext, pci);
	    }
	}
    break;

    case ClientStateGone:
    case ClientStateRetained: /* client disconnected */

        /* RecordDisableContext modifies contents of ppAllContexts. */
	numContextsCopy = numContexts;
	ppAllContextsCopy = malloc(numContextsCopy * sizeof(RecordContextPtr));
	assert(ppAllContextsCopy);
	memcpy(ppAllContextsCopy, ppAllContexts, numContextsCopy * sizeof(RecordContextPtr));

	for (i = 0; i < numContextsCopy; i++)
	{
	    RecordClientsAndProtocolPtr pRCAP;
	    RecordContextPtr pContext = ppAllContextsCopy[i];
	    int pos;

	    if (pContext->pRecordingClient == pClient)
		RecordDisableContext(pContext);
	    if ((pRCAP = RecordFindClientOnContext(pContext,
				    pClient->clientAsMask, &pos)))
	    {
		if (pContext->pRecordingClient && pRCAP->clientDied)
		    RecordAProtocolElement(pContext, pClient,
					   XRecordClientDied, NULL, 0, 0);
		RecordDeleteClientFromRCAP(pRCAP, pos);
	    }
	}

	free(ppAllContextsCopy);
    break;

    default:
    break;
    } /* end switch on client state */
} /* RecordAClientStateChange */


/* RecordCloseDown
 *
 * Arguments:
 *	extEntry is the extension information for RECORD.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Performs any cleanup needed by RECORD at server shutdown time.
 *	
 */
static void
RecordCloseDown(ExtensionEntry *extEntry)
{
    DeleteCallback(&ClientStateCallback, RecordAClientStateChange, NULL);
} /* RecordCloseDown */


/* RecordExtensionInit
 *
 * Arguments: none.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Enables the RECORD extension if possible.
 */
void 
RecordExtensionInit(void)
{
    ExtensionEntry *extentry;

    RTContext = CreateNewResourceType(RecordDeleteContext, "RecordContext");
    if (!RTContext)
	return;

    if (!dixRegisterPrivateKey(RecordClientPrivateKey, PRIVATE_CLIENT, 0))
        return;

    ppAllContexts = NULL;
    numContexts = numEnabledContexts = numEnabledRCAPs = 0;

    if (!AddCallback(&ClientStateCallback, RecordAClientStateChange, NULL))
	return;

    extentry = AddExtension(RECORD_NAME, RecordNumEvents, RecordNumErrors,
			    ProcRecordDispatch, SProcRecordDispatch,
			    RecordCloseDown, StandardMinorOpcode);
    if (!extentry)
    {
	DeleteCallback(&ClientStateCallback, RecordAClientStateChange, NULL);
	return;
    }
    SetResourceTypeErrorValue(RTContext, extentry->errorBase + XRecordBadContext);

} /* RecordExtensionInit */

/*

Copyright 1995, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*

    See the header set.h for a description of the set ADT.

    Implementation Strategy

    A bit vector is an obvious choice to represent the set, but may take
    too much memory, depending on the numerically largest member in the
    set.  One expected common case is for the client to ask for *all*
    protocol.  This means it would ask for minor opcodes 0 through 65535.
    Representing this as a bit vector takes 8K -- and there may be
    multiple minor opcode intervals, as many as one per major (extension)
    opcode).  In such cases, a list-of-intervals representation would be
    preferable to reduce memory consumption.  Both representations will be
    implemented, and RecordCreateSet will decide heuristically which one
    to use based on the set members.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include "misc.h"
#include "set.h"

static int
maxMemberInInterval(RecordSetInterval *pIntervals, int nIntervals)
{
    int i;
    int maxMember = -1;
    for (i = 0; i < nIntervals; i++)
    {
	if (maxMember < (int)pIntervals[i].last)
	    maxMember = pIntervals[i].last;
    }
    return maxMember;
}

static void
NoopDestroySet(RecordSetPtr pSet)
{
}

/***************************************************************************/

/* set operations for bit vector representation */

typedef struct {
    RecordSetRec baseSet;
    int maxMember;
    /* followed by the bit vector itself */
} BitVectorSet, *BitVectorSetPtr;

#define BITS_PER_LONG (sizeof(unsigned long) * 8)

static void
BitVectorDestroySet(RecordSetPtr pSet)
{
    free(pSet);
}

static unsigned long
BitVectorIsMemberOfSet(RecordSetPtr pSet, int pm)
{
    BitVectorSetPtr pbvs = (BitVectorSetPtr)pSet;
    unsigned long *pbitvec;

    if ((int)pm > pbvs->maxMember) return FALSE;
    pbitvec = (unsigned long *)(&pbvs[1]);
    return (pbitvec[pm / BITS_PER_LONG] & ((unsigned long)1 << (pm % BITS_PER_LONG)));
}


static int
BitVectorFindBit(RecordSetPtr pSet, int iterbit, Bool bitval)
{
    BitVectorSetPtr pbvs = (BitVectorSetPtr)pSet;
    unsigned long *pbitvec = (unsigned long *)(&pbvs[1]);
    int startlong;
    int startbit;
    int walkbit;
    int maxMember;
    unsigned long skipval;
    unsigned long bits;
    unsigned long usefulbits;

    startlong = iterbit / BITS_PER_LONG;
    pbitvec  += startlong;
    startbit  = startlong * BITS_PER_LONG;
    skipval = bitval ? 0L : ~0L;
    maxMember = pbvs->maxMember;


    if (startbit > maxMember) return -1;
    bits = *pbitvec;
    usefulbits = ~(((unsigned long)1 << (iterbit - startbit)) - 1);
    if ( (bits & usefulbits) == (skipval & usefulbits) )
    {
	pbitvec++;
	startbit += BITS_PER_LONG;

	while (startbit <= maxMember && *pbitvec == skipval)
	{
	    pbitvec++;
	    startbit += BITS_PER_LONG;
	}
	if (startbit > maxMember) return -1;
    }

    walkbit = (startbit < iterbit) ? iterbit - startbit : 0;

    bits = *pbitvec;
    while (walkbit < BITS_PER_LONG && ((!(bits & ((unsigned long)1 << walkbit))) == bitval))
	walkbit++;

    return startbit + walkbit;
}


static RecordSetIteratePtr
BitVectorIterateSet(RecordSetPtr pSet, RecordSetIteratePtr pIter,
		    RecordSetInterval *pInterval)
{
    int iterbit = (int)(long)pIter;
    int b;

    b = BitVectorFindBit(pSet, iterbit, TRUE);
    if (b == -1) return (RecordSetIteratePtr)0;
    pInterval->first = b;

    b = BitVectorFindBit(pSet, b, FALSE);
    pInterval->last = (b < 0) ? ((BitVectorSetPtr)pSet)->maxMember : b - 1;
    return (RecordSetIteratePtr)(long)(pInterval->last + 1);
}

static RecordSetOperations BitVectorSetOperations = {
    BitVectorDestroySet, BitVectorIsMemberOfSet, BitVectorIterateSet };

static RecordSetOperations BitVectorNoFreeOperations = {
    NoopDestroySet, BitVectorIsMemberOfSet, BitVectorIterateSet };

static int
BitVectorSetMemoryRequirements(RecordSetInterval *pIntervals, int nIntervals,
			       int maxMember, int *alignment)
{
    int nlongs;

    *alignment = sizeof(unsigned long);
    nlongs = (maxMember + BITS_PER_LONG) / BITS_PER_LONG;
    return (sizeof(BitVectorSet) + nlongs * sizeof(unsigned long));
}

static RecordSetPtr
BitVectorCreateSet(RecordSetInterval *pIntervals, int nIntervals,
		   void *pMem, int memsize)
{
    BitVectorSetPtr pbvs;
    int i, j;
    unsigned long *pbitvec;

    /* allocate all storage needed by this set in one chunk */

    if (pMem)
    {
	memset(pMem, 0, memsize);
	pbvs = (BitVectorSetPtr)pMem;
	pbvs->baseSet.ops = &BitVectorNoFreeOperations;
    }
    else
    {
	pbvs = (BitVectorSetPtr)calloc(1, memsize);
	if (!pbvs) return NULL;
	pbvs->baseSet.ops = &BitVectorSetOperations;
    }

    pbvs->maxMember = maxMemberInInterval(pIntervals, nIntervals);

    /* fill in the set */

    pbitvec = (unsigned long *)(&pbvs[1]);
    for (i = 0; i < nIntervals; i++)
    {
	for (j = pIntervals[i].first; j <= (int)pIntervals[i].last; j++)
	{
	    pbitvec[j/BITS_PER_LONG] |= ((unsigned long)1 << (j % BITS_PER_LONG));
	}
    }
    return (RecordSetPtr)pbvs;
}


/***************************************************************************/

/* set operations for interval list representation */

typedef struct {
    RecordSetRec baseSet;
    int nIntervals;
    /* followed by the intervals (RecordSetInterval) */
} IntervalListSet, *IntervalListSetPtr;

static void
IntervalListDestroySet(RecordSetPtr pSet)
{
    free(pSet);
}

static unsigned long
IntervalListIsMemberOfSet(RecordSetPtr pSet, int pm)
{
    IntervalListSetPtr prls = (IntervalListSetPtr)pSet;
    RecordSetInterval *pInterval = (RecordSetInterval *)(&prls[1]);
    int hi, lo, probe;

    /* binary search */
    lo = 0; hi = prls->nIntervals - 1;
    while (lo <= hi)
    {
	probe = (hi + lo) / 2;
	if (pm >= pInterval[probe].first && pm <= pInterval[probe].last) return 1;
	else if (pm < pInterval[probe].first) hi = probe - 1;
	else				   lo = probe + 1;
    }
    return 0;
}


static RecordSetIteratePtr
IntervalListIterateSet(RecordSetPtr pSet, RecordSetIteratePtr pIter,
		       RecordSetInterval *pIntervalReturn)
{
    RecordSetInterval *pInterval = (RecordSetInterval *)pIter;
    IntervalListSetPtr prls = (IntervalListSetPtr)pSet;

    if (pInterval == NULL)
    {
	pInterval = (RecordSetInterval *)(&prls[1]);
    }

    if ( (pInterval - (RecordSetInterval *)(&prls[1])) < prls->nIntervals )
    {
	*pIntervalReturn = *pInterval;
	return (RecordSetIteratePtr)(++pInterval);
    }
    else
	return (RecordSetIteratePtr)NULL;
}

static RecordSetOperations IntervalListSetOperations = {
    IntervalListDestroySet, IntervalListIsMemberOfSet, IntervalListIterateSet };

static RecordSetOperations IntervalListNoFreeOperations = {
    NoopDestroySet, IntervalListIsMemberOfSet, IntervalListIterateSet };

static int
IntervalListMemoryRequirements(RecordSetInterval *pIntervals, int nIntervals,
			       int maxMember, int *alignment)
{
    *alignment = sizeof(unsigned long);
    return sizeof(IntervalListSet) + nIntervals * sizeof(RecordSetInterval);
}

static RecordSetPtr
IntervalListCreateSet(RecordSetInterval *pIntervals, int nIntervals,
		      void *pMem, int memsize)
{
    IntervalListSetPtr prls;
    int i, j, k;
    RecordSetInterval *stackIntervals = NULL;
    CARD16 first;

    if (nIntervals > 0)
    {
	stackIntervals = (RecordSetInterval *)malloc(
				sizeof(RecordSetInterval) * nIntervals);
	if (!stackIntervals) return NULL;

	/* sort intervals, store in stackIntervals (insertion sort) */

	for (i = 0; i < nIntervals; i++)
	{
	    first = pIntervals[i].first;
	    for (j = 0; j < i; j++)
	    {
		if (first < stackIntervals[j].first)
		    break;
	    }
	    for (k = i; k > j; k--)
	    {
		stackIntervals[k] = stackIntervals[k-1];
	    }
	    stackIntervals[j] = pIntervals[i];
	}

	/* merge abutting/overlapping intervals */

	for (i = 0; i < nIntervals - 1; )
	{
	    if ( (stackIntervals[i].last + (unsigned int)1) <
		  stackIntervals[i + 1].first)
	    {
		i++; /* disjoint intervals */
	    }
	    else
	    {
		stackIntervals[i].last = max(stackIntervals[i].last,
					  stackIntervals[i + 1].last);
		nIntervals--;
		for (j = i + 1; j < nIntervals; j++)
		    stackIntervals[j] = stackIntervals[j + 1];
	    }
	}
    }

    /* allocate and fill in set structure */

    if (pMem)
    {
	prls = (IntervalListSetPtr)pMem;
	prls->baseSet.ops = &IntervalListNoFreeOperations;
    }
    else
    {
	prls = (IntervalListSetPtr)
	    malloc(sizeof(IntervalListSet) + nIntervals * sizeof(RecordSetInterval));
	if (!prls) goto bailout;
	prls->baseSet.ops = &IntervalListSetOperations;
    }
    memcpy(&prls[1], stackIntervals, nIntervals * sizeof(RecordSetInterval));
    prls->nIntervals = nIntervals;
bailout:
    free(stackIntervals);
    return (RecordSetPtr)prls;
}

typedef RecordSetPtr (*RecordCreateSetProcPtr)(
    RecordSetInterval *pIntervals,
    int nIntervals,
    void *pMem,
    int memsize
);

static int
_RecordSetMemoryRequirements(RecordSetInterval *pIntervals, int nIntervals,
			     int *alignment,
			     RecordCreateSetProcPtr *ppCreateSet)
{
    int bmsize, rlsize, bma, rla;
    int maxMember;

    /* find maximum member of set so we know how big to make the bit vector */
    maxMember = maxMemberInInterval(pIntervals, nIntervals);

    bmsize = BitVectorSetMemoryRequirements(pIntervals, nIntervals, maxMember,
					    &bma);
    rlsize = IntervalListMemoryRequirements(pIntervals, nIntervals, maxMember,
					    &rla);
    if ( ( (nIntervals > 1) && (maxMember <= 255) )
	|| (bmsize < rlsize) )
    {
	*alignment = bma;
	*ppCreateSet = BitVectorCreateSet;
	return bmsize;
    }
    else
    {
	*alignment = rla;
	*ppCreateSet = IntervalListCreateSet;
	return rlsize;
    }
}

/***************************************************************************/

/* user-visible functions */

int
RecordSetMemoryRequirements(RecordSetInterval *pIntervals, int nIntervals, int *alignment)
{
    RecordCreateSetProcPtr pCreateSet;
    return _RecordSetMemoryRequirements(pIntervals, nIntervals, alignment,
					&pCreateSet);
}

RecordSetPtr
RecordCreateSet(RecordSetInterval *pIntervals, int nIntervals, void *pMem, int memsize)
{
    RecordCreateSetProcPtr pCreateSet;
    int alignment;
    int size;

    size = _RecordSetMemoryRequirements(pIntervals, nIntervals, &alignment,
					&pCreateSet);
    if (pMem)
    {
	if ( ((long)pMem & (alignment-1) ) || memsize < size)
	    return NULL;
    }
    return (*pCreateSet)(pIntervals, nIntervals, pMem, size);
}
/*

Copyright 1995, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*
	  A Set Abstract Data Type (ADT) for the RECORD Extension
			   David P. Wiggins
			       7/25/95

    The RECORD extension server code needs to maintain sets of numbers
    that designate protocol message types.  In most cases the interval of
    numbers starts at 0 and does not exceed 255, but in a few cases (minor
    opcodes of extension requests) the maximum is 65535.  This disparity
    suggests that a single set representation may not be suitable for all
    sets, especially given that server memory is precious.  We introduce a
    set ADT to hide implementation differences so that multiple
    simultaneous set representations can exist.  A single interface is
    presented to the set user regardless of the implementation in use for
    a particular set.

    The existing RECORD SI appears to require only four set operations:
    create (given a list of members), destroy, see if a particular number
    is a member of the set, and iterate over the members of a set.  Though
    many more set operations are imaginable, to keep the code space down,
    we won't provide any more operations than are needed.

    The following types and functions/macros define the ADT.
*/

/* an interval of set members */
typedef struct {
    CARD16 first;
    CARD16 last;
} RecordSetInterval;

typedef struct _RecordSetRec *RecordSetPtr; /* primary set type */

typedef void *RecordSetIteratePtr;

/* table of function pointers for set operations.
   set users should never declare a variable of this type.
*/
typedef struct {
    void (*DestroySet)(
    RecordSetPtr pSet
);
    unsigned long (*IsMemberOfSet)(
    RecordSetPtr pSet,
    int possible_member
);
    RecordSetIteratePtr (*IterateSet)(
    RecordSetPtr pSet,
    RecordSetIteratePtr pIter,
    RecordSetInterval *interval
);
} RecordSetOperations;

/* "base class" for sets.
   set users should never declare a variable of this type.
 */
typedef struct _RecordSetRec {
    RecordSetOperations *ops;
} RecordSetRec;

RecordSetPtr RecordCreateSet(
    RecordSetInterval *intervals,
    int nintervals,
    void *pMem,
    int memsize
);
/*
    RecordCreateSet creates and returns a new set having members specified
    by intervals and nintervals.  nintervals is the number of RecordSetInterval
    structures pointed to by intervals.  The elements belonging to the new
    set are determined as follows.  For each RecordSetInterval structure, the
    elements between first and last inclusive are members of the new set.
    If a RecordSetInterval's first field is greater than its last field, the
    results are undefined.  It is valid to create an empty set (nintervals ==
    0).  If RecordCreateSet returns NULL, the set could not be created due
    to resource constraints.
*/

int RecordSetMemoryRequirements(
    RecordSetInterval * /*pIntervals*/,
    int /*nintervals*/,
    int * /*alignment*/
);

#define RecordDestroySet(_pSet) \
	/* void */ (*_pSet->ops->DestroySet)(/* RecordSetPtr */ _pSet)
/*
    RecordDestroySet frees all resources used by _pSet.  _pSet should not be
    used after it is destroyed.
*/

#define RecordIsMemberOfSet(_pSet, _m) \
  /* unsigned long */ (*_pSet->ops->IsMemberOfSet)(/* RecordSetPtr */ _pSet, \
						   /* int */ _m) 
/*
    RecordIsMemberOfSet returns a non-zero value if _m is a member of
    _pSet, else it returns zero.
*/

#define RecordIterateSet(_pSet, _pIter, _interval) \
 /* RecordSetIteratePtr */ (*_pSet->ops->IterateSet)(/* RecordSetPtr */ _pSet,\
	/* RecordSetIteratePtr */ _pIter, /* RecordSetInterval */ _interval)
/*
    RecordIterateSet returns successive intervals of members of _pSet.  If
    _pIter is NULL, the first interval of set members is copied into _interval.
    The return value should be passed as _pIter in the next call to
    RecordIterateSet to obtain the next interval.  When the return value is
    NULL, there were no more intervals in the set, and nothing is copied into
    the _interval parameter.  Intervals appear in increasing numerical order
    with no overlap between intervals.  As such, the list of intervals produced
    by RecordIterateSet may not match the list of intervals that were passed
    in RecordCreateSet.  Typical usage:

	pIter = NULL;
	while (pIter = RecordIterateSet(pSet, pIter, &interval))
	{
	    process interval;
	}
*/
/*
 *
 * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Animated cursors for X.  Not specific to Render in any way, but
 * stuck there because Render has the other cool cursor extension.
 * Besides, everyone has Render.
 *
 * Implemented as a simple layer over the core cursor code; it
 * creates composite cursors out of a set of static cursors and
 * delta times between each image.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xmd.h>
#include "servermd.h"
#include "scrnintstr.h"
#include "dixstruct.h"
#include "cursorstr.h"
#include "dixfontstr.h"
#include "opaque.h"
#include "picturestr.h"
#include "inputstr.h"
#include "xace.h"

typedef struct _AnimCurElt {
    CursorPtr	pCursor;    /* cursor to show */
    CARD32	delay;	    /* in ms */
} AnimCurElt;

typedef struct _AnimCur {
    int		nelt;	    /* number of elements in the elts array */
    AnimCurElt	*elts;	    /* actually allocated right after the structure */
} AnimCurRec, *AnimCurPtr;

typedef struct _AnimScrPriv {
    CloseScreenProcPtr		CloseScreen;

    ScreenBlockHandlerProcPtr	BlockHandler;

    CursorLimitsProcPtr		CursorLimits;
    DisplayCursorProcPtr	DisplayCursor;
    SetCursorPositionProcPtr	SetCursorPosition;
    RealizeCursorProcPtr	RealizeCursor;
    UnrealizeCursorProcPtr	UnrealizeCursor;
    RecolorCursorProcPtr	RecolorCursor;
} AnimCurScreenRec, *AnimCurScreenPtr;

static unsigned char empty[4];

static CursorBits   animCursorBits = {
    empty, empty, 2, 1, 1, 0, 0, 1
};

static DevPrivateKeyRec AnimCurScreenPrivateKeyRec;
#define AnimCurScreenPrivateKey (&AnimCurScreenPrivateKeyRec)

#define IsAnimCur(c)	    ((c) && ((c)->bits == &animCursorBits))
#define GetAnimCur(c)	    ((AnimCurPtr) ((((char *)(c) + CURSOR_REC_SIZE))))
#define GetAnimCurScreen(s) ((AnimCurScreenPtr)dixLookupPrivate(&(s)->devPrivates, AnimCurScreenPrivateKey))
#define SetAnimCurScreen(s,p) dixSetPrivate(&(s)->devPrivates, AnimCurScreenPrivateKey, p)

#define Wrap(as,s,elt,func) (((as)->elt = (s)->elt), (s)->elt = func)
#define Unwrap(as,s,elt)    ((s)->elt = (as)->elt)


static Bool
AnimCurCloseScreen (int index, ScreenPtr pScreen)
{
    AnimCurScreenPtr    as = GetAnimCurScreen(pScreen);
    Bool                ret;

    Unwrap(as, pScreen, CloseScreen);

    Unwrap(as, pScreen, CursorLimits);
    Unwrap(as, pScreen, DisplayCursor);
    Unwrap(as, pScreen, SetCursorPosition);
    Unwrap(as, pScreen, RealizeCursor);
    Unwrap(as, pScreen, UnrealizeCursor);
    Unwrap(as, pScreen, RecolorCursor);
    SetAnimCurScreen(pScreen,0);
    ret = (*pScreen->CloseScreen) (index, pScreen);
    free(as);
    return ret;
}

static void 
AnimCurCursorLimits (DeviceIntPtr pDev,
                     ScreenPtr pScreen,
		     CursorPtr pCursor,
		     BoxPtr pHotBox,
		     BoxPtr pTopLeftBox)
{
    AnimCurScreenPtr    as = GetAnimCurScreen(pScreen);

    Unwrap (as, pScreen, CursorLimits);
    if (IsAnimCur(pCursor))
    {
	AnimCurPtr	ac = GetAnimCur(pCursor);

        (*pScreen->CursorLimits) (pDev, pScreen, ac->elts[0].pCursor, 
                                  pHotBox, pTopLeftBox); 
    }
    else
    {
        (*pScreen->CursorLimits) (pDev, pScreen, pCursor,
                                  pHotBox, pTopLeftBox); 
    }
    Wrap (as, pScreen, CursorLimits, AnimCurCursorLimits);
}

/*
 * This has to be a screen block handler instead of a generic
 * block handler so that it is well ordered with respect to the DRI
 * block handler responsible for releasing the hardware to DRI clients
 */

static void
AnimCurScreenBlockHandler (int screenNum,
			   pointer blockData,
			   pointer pTimeout,
			   pointer pReadmask)
{
    ScreenPtr		pScreen = screenInfo.screens[screenNum];
    AnimCurScreenPtr    as = GetAnimCurScreen(pScreen);
    DeviceIntPtr        dev;
    Bool                activeDevice = FALSE;
    CARD32              now = 0, 
                        soonest = ~0; /* earliest time to wakeup again */

    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
	if (IsPointerDevice(dev) && pScreen == dev->spriteInfo->anim.pScreen)
	{
	    if (!activeDevice) {
                now = GetTimeInMillis ();
                activeDevice = TRUE;
            }

	    if ((INT32) (now - dev->spriteInfo->anim.time) >= 0)
	    {
		AnimCurPtr ac  = GetAnimCur(dev->spriteInfo->anim.pCursor);
		int        elt = (dev->spriteInfo->anim.elt + 1) % ac->nelt;
		DisplayCursorProcPtr DisplayCursor;

		/*
		 * Not a simple Unwrap/Wrap as this
		 * isn't called along the DisplayCursor 
		 * wrapper chain.
		 */
		DisplayCursor = pScreen->DisplayCursor;
		pScreen->DisplayCursor = as->DisplayCursor;
		(void) (*pScreen->DisplayCursor) (dev,
						  pScreen, 
						  ac->elts[elt].pCursor);
		as->DisplayCursor = pScreen->DisplayCursor;
		pScreen->DisplayCursor = DisplayCursor;

		dev->spriteInfo->anim.elt = elt;
		dev->spriteInfo->anim.time = now + ac->elts[elt].delay;
	    }

	    if (soonest > dev->spriteInfo->anim.time)
		soonest = dev->spriteInfo->anim.time;
	}
    }

    if (activeDevice)
        AdjustWaitForDelay (pTimeout, soonest - now);

    Unwrap (as, pScreen, BlockHandler);
    (*pScreen->BlockHandler) (screenNum, blockData, pTimeout, pReadmask);
    if (activeDevice)
        Wrap (as, pScreen, BlockHandler, AnimCurScreenBlockHandler);
    else
        as->BlockHandler = NULL;
}

static Bool
AnimCurDisplayCursor (DeviceIntPtr pDev,
                      ScreenPtr pScreen,
		      CursorPtr pCursor)
{
    AnimCurScreenPtr    as = GetAnimCurScreen(pScreen);
    Bool		ret;

    Unwrap (as, pScreen, DisplayCursor);
    if (IsAnimCur(pCursor))
    {
	if (pCursor != pDev->spriteInfo->anim.pCursor)
	{
	    AnimCurPtr		ac = GetAnimCur(pCursor);

	    ret = (*pScreen->DisplayCursor) 
                (pDev, pScreen, ac->elts[0].pCursor);
	    if (ret)
	    {
		pDev->spriteInfo->anim.elt = 0;
		pDev->spriteInfo->anim.time = GetTimeInMillis () + ac->elts[0].delay;
		pDev->spriteInfo->anim.pCursor = pCursor;
		pDev->spriteInfo->anim.pScreen = pScreen;

		if (!as->BlockHandler)
		    Wrap(as, pScreen, BlockHandler, AnimCurScreenBlockHandler);
	    }
	}
	else
	    ret = TRUE;
    }
    else
    {
	pDev->spriteInfo->anim.pCursor = 0;
	pDev->spriteInfo->anim.pScreen = 0;
	ret = (*pScreen->DisplayCursor) (pDev, pScreen, pCursor);
    }
    Wrap (as, pScreen, DisplayCursor, AnimCurDisplayCursor);
    return ret;
}

static Bool
AnimCurSetCursorPosition (DeviceIntPtr pDev,
                          ScreenPtr pScreen,
			  int x,
			  int y,
			  Bool generateEvent)
{
    AnimCurScreenPtr    as = GetAnimCurScreen(pScreen);
    Bool		ret;
    
    Unwrap (as, pScreen, SetCursorPosition);
    if (pDev->spriteInfo->anim.pCursor) {
	pDev->spriteInfo->anim.pScreen = pScreen;

	if (!as->BlockHandler)
	    Wrap(as, pScreen, BlockHandler, AnimCurScreenBlockHandler);
    }
    ret = (*pScreen->SetCursorPosition) (pDev, pScreen, x, y, generateEvent);
    Wrap (as, pScreen, SetCursorPosition, AnimCurSetCursorPosition);
    return ret;
}

static Bool 
AnimCurRealizeCursor (DeviceIntPtr pDev,
                      ScreenPtr pScreen,
		      CursorPtr pCursor)
{
    AnimCurScreenPtr    as = GetAnimCurScreen(pScreen);
    Bool		ret;
    
    Unwrap (as, pScreen, RealizeCursor);
    if (IsAnimCur(pCursor))
	ret = TRUE;
    else
	ret = (*pScreen->RealizeCursor) (pDev, pScreen, pCursor);
    Wrap (as, pScreen, RealizeCursor, AnimCurRealizeCursor);
    return ret;
}

static Bool 
AnimCurUnrealizeCursor (DeviceIntPtr pDev,
                        ScreenPtr pScreen,
			CursorPtr pCursor)
{
    AnimCurScreenPtr    as = GetAnimCurScreen(pScreen);
    Bool		ret;
    
    Unwrap (as, pScreen, UnrealizeCursor);
    if (IsAnimCur(pCursor))
    {
        AnimCurPtr  ac = GetAnimCur(pCursor);
	int	    i;

	if (pScreen->myNum == 0)
	    for (i = 0; i < ac->nelt; i++)
		FreeCursor (ac->elts[i].pCursor, 0);
	ret = TRUE;
    }
    else
	ret = (*pScreen->UnrealizeCursor) (pDev, pScreen, pCursor);
    Wrap (as, pScreen, UnrealizeCursor, AnimCurUnrealizeCursor);
    return ret;
}

static void
AnimCurRecolorCursor (DeviceIntPtr pDev,
                      ScreenPtr pScreen,
		      CursorPtr pCursor,
		      Bool displayed)
{
    AnimCurScreenPtr    as = GetAnimCurScreen(pScreen);
    
    Unwrap (as, pScreen, RecolorCursor);
    if (IsAnimCur(pCursor))
    {
        AnimCurPtr  ac = GetAnimCur(pCursor);
	int	    i;

        for (i = 0; i < ac->nelt; i++)
	    (*pScreen->RecolorCursor) (pDev, pScreen, ac->elts[i].pCursor,
				       displayed && 
				       pDev->spriteInfo->anim.elt == i);
    }
    else
	(*pScreen->RecolorCursor) (pDev, pScreen, pCursor, displayed);
    Wrap (as, pScreen, RecolorCursor, AnimCurRecolorCursor);
}

Bool
AnimCurInit (ScreenPtr pScreen)
{
    AnimCurScreenPtr    as;

    if (!dixRegisterPrivateKey(&AnimCurScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;

    as = (AnimCurScreenPtr) malloc(sizeof (AnimCurScreenRec));
    if (!as)
	return FALSE;
    Wrap(as, pScreen, CloseScreen, AnimCurCloseScreen);

    as->BlockHandler = NULL;

    Wrap(as, pScreen, CursorLimits, AnimCurCursorLimits);
    Wrap(as, pScreen, DisplayCursor, AnimCurDisplayCursor);
    Wrap(as, pScreen, SetCursorPosition, AnimCurSetCursorPosition);
    Wrap(as, pScreen, RealizeCursor, AnimCurRealizeCursor);
    Wrap(as, pScreen, UnrealizeCursor, AnimCurUnrealizeCursor);
    Wrap(as, pScreen, RecolorCursor, AnimCurRecolorCursor);
    SetAnimCurScreen(pScreen,as);
    return TRUE;
}

int
AnimCursorCreate (CursorPtr *cursors, CARD32 *deltas, int ncursor, CursorPtr *ppCursor, ClientPtr client, XID cid)
{
    CursorPtr	pCursor;
    int		rc, i;
    AnimCurPtr	ac;

    for (i = 0; i < screenInfo.numScreens; i++)
	if (!GetAnimCurScreen (screenInfo.screens[i]))
	    return BadImplementation;

    for (i = 0; i < ncursor; i++)
	if (IsAnimCur (cursors[i]))
	    return BadMatch;
	
    pCursor = (CursorPtr) calloc(CURSOR_REC_SIZE +
				 sizeof (AnimCurRec) +
				 ncursor * sizeof (AnimCurElt), 1);
    if (!pCursor)
	return BadAlloc;
    dixInitPrivates(pCursor, pCursor + 1, PRIVATE_CURSOR);
    pCursor->bits = &animCursorBits;
    pCursor->refcnt = 1;
    
    pCursor->foreRed = cursors[0]->foreRed;
    pCursor->foreGreen = cursors[0]->foreGreen;
    pCursor->foreBlue = cursors[0]->foreBlue;
    
    pCursor->backRed = cursors[0]->backRed;
    pCursor->backGreen = cursors[0]->backGreen;
    pCursor->backBlue = cursors[0]->backBlue;

    pCursor->id = cid;

    /* security creation/labeling check */
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, cid, RT_CURSOR, pCursor,
		  RT_NONE, NULL, DixCreateAccess);
    if (rc != Success) {
	dixFiniPrivates(pCursor, PRIVATE_CURSOR);
	free(pCursor);
	return rc;
    }
	
    /*
     * Fill in the AnimCurRec
     */
    animCursorBits.refcnt++;
    ac = GetAnimCur (pCursor);
    ac->nelt = ncursor;
    ac->elts = (AnimCurElt *) (ac + 1);
    
    for (i = 0; i < ncursor; i++)
    {
	cursors[i]->refcnt++;
	ac->elts[i].pCursor = cursors[i];
	ac->elts[i].delay = deltas[i];
    }
    
    *ppCursor = pCursor;
    return Success;
}
/*
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "misc.h"
#include "scrnintstr.h"
#include "os.h"
#include "regionstr.h"
#include "validate.h"
#include "windowstr.h"
#include "input.h"
#include "resource.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "servermd.h"
#include "picturestr.h"

static char **filterNames;
static int  nfilterNames;

/*
 * standard but not required filters don't have constant indices
 */

int
PictureGetFilterId (char *filter, int len, Bool makeit)
{
    int	    i;
    char    *name;
    char    **names;

    if (len < 0)
	len = strlen (filter);
    for (i = 0; i < nfilterNames; i++)
	if (!CompareISOLatin1Lowered ((unsigned char *) filterNames[i], -1, (unsigned char *) filter, len))
	    return i;
    if (!makeit)
	return -1;
    name = malloc(len + 1);
    if (!name)
	return -1;
    memcpy (name, filter, len);
    name[len] = '\0';
    if (filterNames)
	names = realloc(filterNames, (nfilterNames + 1) * sizeof (char *));
    else
	names = malloc(sizeof (char *));
    if (!names)
    {
	free(name);
	return -1;
    }
    filterNames = names;
    i = nfilterNames++;
    filterNames[i] = name;
    return i;
}

static Bool
PictureSetDefaultIds (void)
{
    /* careful here -- this list must match the #define values */

    if (PictureGetFilterId (FilterNearest, -1, TRUE) != PictFilterNearest)
	return FALSE;
    if (PictureGetFilterId (FilterBilinear, -1, TRUE) != PictFilterBilinear)
	return FALSE;

    if (PictureGetFilterId (FilterFast, -1, TRUE) != PictFilterFast)
	return FALSE;
    if (PictureGetFilterId (FilterGood, -1, TRUE) != PictFilterGood)
	return FALSE;
    if (PictureGetFilterId (FilterBest, -1, TRUE) != PictFilterBest)
	return FALSE;

    if (PictureGetFilterId (FilterConvolution, -1, TRUE) != PictFilterConvolution)
	return FALSE;
    return TRUE;
}

char *
PictureGetFilterName (int id)
{
    if (0 <= id && id < nfilterNames)
	return filterNames[id];
    else
	return 0;
}

static void
PictureFreeFilterIds (void)
{
    int	    i;

    for (i = 0; i < nfilterNames; i++)
	free(filterNames[i]);
    free(filterNames);
    nfilterNames = 0;
    filterNames = 0;
}

int
PictureAddFilter (ScreenPtr			    pScreen,
		  char				    *filter,
		  PictFilterValidateParamsProcPtr   ValidateParams,
		  int				    width,
		  int				    height)
{
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    int			id = PictureGetFilterId (filter, -1,  TRUE);
    int			i;
    PictFilterPtr	filters;

    if (id < 0)
	return -1;
    /*
     * It's an error to attempt to reregister a filter
     */
    for (i = 0; i < ps->nfilters; i++)
	if (ps->filters[i].id == id)
	    return -1;
    if (ps->filters)
	filters = realloc(ps->filters, (ps->nfilters + 1) * sizeof (PictFilterRec));
    else
	filters = malloc(sizeof (PictFilterRec));
    if (!filters)
	return -1;
    ps->filters = filters;
    i = ps->nfilters++;
    ps->filters[i].name = PictureGetFilterName (id);
    ps->filters[i].id = id;
    ps->filters[i].ValidateParams = ValidateParams;
    ps->filters[i].width = width;
    ps->filters[i].height = height;
    return id;
}

Bool
PictureSetFilterAlias (ScreenPtr pScreen, char *filter, char *alias)
{
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    int			filter_id = PictureGetFilterId (filter, -1, FALSE);
    int			alias_id = PictureGetFilterId (alias, -1, TRUE);
    int			i;

    if (filter_id < 0 || alias_id < 0)
	return FALSE;
    for (i = 0; i < ps->nfilterAliases; i++)
	if (ps->filterAliases[i].alias_id == alias_id)
	    break;
    if (i == ps->nfilterAliases)
    {
	PictFilterAliasPtr  aliases;

	if (ps->filterAliases)
	    aliases = realloc(ps->filterAliases,
				(ps->nfilterAliases + 1) *
				sizeof (PictFilterAliasRec));
	else
	    aliases = malloc(sizeof (PictFilterAliasRec));
	if (!aliases)
	    return FALSE;
	ps->filterAliases = aliases;
	ps->filterAliases[i].alias = PictureGetFilterName (alias_id);
	ps->filterAliases[i].alias_id = alias_id;
	ps->nfilterAliases++;
    }
    ps->filterAliases[i].filter_id = filter_id;
    return TRUE;
}

PictFilterPtr
PictureFindFilter (ScreenPtr pScreen, char *name, int len)
{
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    int			id = PictureGetFilterId (name, len, FALSE);
    int			i;

    if (id < 0)
	return 0;
    /* Check for an alias, allow them to recurse */
    for (i = 0; i < ps->nfilterAliases; i++)
	if (ps->filterAliases[i].alias_id == id)
	{
	    id = ps->filterAliases[i].filter_id;
	    i = 0;
	}
    /* find the filter */
    for (i = 0; i < ps->nfilters; i++)
	if (ps->filters[i].id == id)
	    return &ps->filters[i];
    return 0;
}

static Bool
convolutionFilterValidateParams (ScreenPtr pScreen,
                                 int	   filter,
                                 xFixed	   *params,
                                 int	   nparams,
				 int       *width,
				 int	   *height)
{
    int	w, h;
    if (nparams < 3)
        return FALSE;

    if (xFixedFrac (params[0]) || xFixedFrac (params[1]))
        return FALSE;

    w = xFixedToInt (params[0]);
    h = xFixedToInt (params[1]);

    nparams -= 2;
    if (w * h > nparams)
        return FALSE;

    *width = w;
    *height = h;
    return TRUE;
}


Bool
PictureSetDefaultFilters (ScreenPtr pScreen)
{
    if (!filterNames)
	if (!PictureSetDefaultIds ())
	    return FALSE;
    if (PictureAddFilter (pScreen, FilterNearest, 0, 1, 1) < 0)
	return FALSE;
    if (PictureAddFilter (pScreen, FilterBilinear, 0, 2, 2) < 0)
	return FALSE;

    if (!PictureSetFilterAlias (pScreen, FilterNearest, FilterFast))
	return FALSE;
    if (!PictureSetFilterAlias (pScreen, FilterBilinear, FilterGood))
	return FALSE;
    if (!PictureSetFilterAlias (pScreen, FilterBilinear, FilterBest))
	return FALSE;

    if (PictureAddFilter (pScreen, FilterConvolution, convolutionFilterValidateParams, 0, 0) < 0)
        return FALSE;

    return TRUE;
}

void
PictureResetFilters (ScreenPtr pScreen)
{
    PictureScreenPtr    ps = GetPictureScreen(pScreen);

    free(ps->filters);
    free(ps->filterAliases);
    PictureFreeFilterIds ();
}

int
SetPictureFilter (PicturePtr pPicture, char *name, int len, xFixed *params, int nparams)
{
    PictFilterPtr	pFilter;
    ScreenPtr		pScreen;

    if (pPicture->pDrawable != NULL)
	pScreen = pPicture->pDrawable->pScreen;
    else
	pScreen = screenInfo.screens[0];

    pFilter = PictureFindFilter (pScreen, name, len);

    if (!pFilter)
	return BadName;

    if (pPicture->pDrawable == NULL)
    {
	int s;
	/* For source pictures, the picture isn't tied to a screen.  So, ensure
	 * that all screens can handle a filter we set for the picture.
	 */
	for (s = 1; s < screenInfo.numScreens; s++)
	{
	    PictFilterPtr   pScreenFilter;
	    pScreenFilter = PictureFindFilter (screenInfo.screens[s],
					       name, len);
	    if (!pScreenFilter || pScreenFilter->id != pFilter->id)
		return BadMatch;
	}
    }
    return SetPicturePictFilter (pPicture, pFilter, params, nparams);
}

int
SetPicturePictFilter (PicturePtr pPicture, PictFilterPtr pFilter,
		      xFixed *params, int nparams)
{
    ScreenPtr	pScreen;
    int		i;

    if (pPicture->pDrawable)
	pScreen = pPicture->pDrawable->pScreen;
    else
	pScreen = screenInfo.screens[0];

    if (pFilter->ValidateParams)
    {
	int width, height;
	if (!(*pFilter->ValidateParams) (pScreen, pFilter->id, params, nparams, &width, &height))
	    return BadMatch;
    }
    else if (nparams)
	return BadMatch;

    if (nparams != pPicture->filter_nparams)
    {
	xFixed *new_params = malloc(nparams * sizeof (xFixed));
	if (!new_params && nparams)
	    return BadAlloc;
	free(pPicture->filter_params);
	pPicture->filter_params = new_params;
	pPicture->filter_nparams = nparams;
    }
    for (i = 0; i < nparams; i++)
	pPicture->filter_params[i] = params[i];
    pPicture->filter = pFilter->id;

    if (pPicture->pDrawable)
    {
	PictureScreenPtr    ps = GetPictureScreen(pScreen);
	int		    result;

	result = (*ps->ChangePictureFilter) (pPicture, pPicture->filter,
					     params, nparams);
	return result;
    }
    return Success;
}
/*
 *
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xsha1.h"

#include "misc.h"
#include "scrnintstr.h"
#include "os.h"
#include "regionstr.h"
#include "validate.h"
#include "windowstr.h"
#include "input.h"
#include "resource.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "servermd.h"
#include "picturestr.h"
#include "glyphstr.h"
#include "mipict.h"

/*
 * From Knuth -- a good choice for hash/rehash values is p, p-2 where
 * p and p-2 are both prime.  These tables are sized to have an extra 10%
 * free to avoid exponential performance degradation as the hash table fills
 */
static GlyphHashSetRec glyphHashSets[] = {
    { 32,		43,		41        },
    { 64,		73,		71        },
    { 128,		151,		149       },
    { 256,		283,		281       },
    { 512,		571,		569       },
    { 1024,		1153,		1151      },
    { 2048,		2269,		2267      },
    { 4096,		4519,		4517      },
    { 8192,		9013,		9011      },
    { 16384,		18043,		18041     },
    { 32768,		36109,		36107     },
    { 65536,		72091,		72089     },
    { 131072,		144409,		144407    },
    { 262144,		288361,		288359    },
    { 524288,		576883,		576881    },
    { 1048576,		1153459,	1153457   },
    { 2097152,		2307163,	2307161   },
    { 4194304,		4613893,	4613891   },
    { 8388608,		9227641,	9227639   },
    { 16777216,		18455029,	18455027  },
    { 33554432,		36911011,	36911009  },
    { 67108864,		73819861,	73819859  },
    { 134217728,	147639589,	147639587 },
    { 268435456,	295279081,	295279079 },
    { 536870912,	590559793,	590559791 }
};

#define NGLYPHHASHSETS	(sizeof(glyphHashSets)/sizeof(glyphHashSets[0]))

static const CARD8	glyphDepths[GlyphFormatNum] = { 1, 4, 8, 16, 32 };

static GlyphHashRec	globalGlyphs[GlyphFormatNum];

void
GlyphUninit (ScreenPtr pScreen)
{
    PictureScreenPtr ps = GetPictureScreen (pScreen);
    GlyphPtr	     glyph;
    int		     fdepth, i;
    int		     scrno = pScreen->myNum;

    for (fdepth = 0; fdepth < GlyphFormatNum; fdepth++)
    {
	if (!globalGlyphs[fdepth].hashSet)
	    continue;
	
	for (i = 0; i < globalGlyphs[fdepth].hashSet->size; i++)
	{
	    glyph = globalGlyphs[fdepth].table[i].glyph;
	    if (glyph && glyph != DeletedGlyph)
	    {
		if (GlyphPicture(glyph)[scrno])
		{
		    FreePicture ((pointer) GlyphPicture (glyph)[scrno], 0);
		    GlyphPicture(glyph)[scrno] = NULL;
		}
		(*ps->UnrealizeGlyph) (pScreen, glyph);
	    }
	}
    }
}

GlyphHashSetPtr
FindGlyphHashSet (CARD32 filled)
{
    int	i;

    for (i = 0; i < NGLYPHHASHSETS; i++)
	if (glyphHashSets[i].entries >= filled)
	    return &glyphHashSets[i];
    return 0;
}

GlyphRefPtr
FindGlyphRef (GlyphHashPtr	hash,
	      CARD32		signature,
	      Bool		match,
	      unsigned char	sha1[20])
{
    CARD32	elt, step, s;
    GlyphPtr	glyph;
    GlyphRefPtr	table, gr, del;
    CARD32	tableSize = hash->hashSet->size;

    table = hash->table;
    elt = signature % tableSize;
    step = 0;
    del = 0;
    for (;;)
    {
	gr = &table[elt];
	s = gr->signature;
	glyph = gr->glyph;
	if (!glyph)
	{
	    if (del)
		gr = del;
	    break;
	}
	if (glyph == DeletedGlyph)
	{
	    if (!del)
		del = gr;
	    else if (gr == del)
		break;
	}
	else if (s == signature &&
		 (!match || 
		  memcmp (glyph->sha1, sha1, 20) == 0))
	{
	    break;
	}
	if (!step)
	{
	    step = signature % hash->hashSet->rehash;
	    if (!step)
		step = 1;
	}
	elt += step;
	if (elt >= tableSize)
	    elt -= tableSize;
    }
    return gr;
}

int
HashGlyph (xGlyphInfo    *gi,
	   CARD8	 *bits,
	   unsigned long size,
	   unsigned char sha1[20])
{
    void *ctx = x_sha1_init();
    int success;

    if (!ctx)
	return BadAlloc;

    success = x_sha1_update(ctx, gi, sizeof(xGlyphInfo));
    if (!success)
	return BadAlloc;
    success = x_sha1_update(ctx, bits, size);
    if (!success)
	return BadAlloc;
    success = x_sha1_final(ctx, sha1);
    if (!success)
	return BadAlloc;
    return Success;
}

GlyphPtr
FindGlyphByHash (unsigned char sha1[20], int format)
{
    GlyphRefPtr gr;
    CARD32 signature = *(CARD32 *) sha1;

    if (!globalGlyphs[format].hashSet)
	return NULL;

    gr = FindGlyphRef (&globalGlyphs[format],
		       signature, TRUE, sha1);

    if (gr->glyph && gr->glyph != DeletedGlyph)
	return gr->glyph;
    else
	return NULL;
}

#ifdef CHECK_DUPLICATES
void
DuplicateRef (GlyphPtr glyph, char *where)
{
    ErrorF ("Duplicate Glyph 0x%x from %s\n", glyph, where);
}

void
CheckDuplicates (GlyphHashPtr hash, char *where)
{
    GlyphPtr	g;
    int		i, j;

    for (i = 0; i < hash->hashSet->size; i++)
    {
	g = hash->table[i].glyph;
	if (!g || g == DeletedGlyph)
	    continue;
	for (j = i + 1; j < hash->hashSet->size; j++)
	    if (hash->table[j].glyph == g)
		DuplicateRef (g, where);
    }
}
#else
#define CheckDuplicates(a,b)
#define DuplicateRef(a,b)
#endif

static void
FreeGlyphPicture(GlyphPtr glyph)
{
    PictureScreenPtr ps;
    int i;

    for (i = 0; i < screenInfo.numScreens; i++)
    {
        ScreenPtr pScreen = screenInfo.screens[i];

        if (GlyphPicture(glyph)[i])
            FreePicture ((pointer) GlyphPicture (glyph)[i], 0);

        ps = GetPictureScreenIfSet (pScreen);
        if (ps)
            (*ps->UnrealizeGlyph) (pScreen, glyph);
    }
}


void
FreeGlyph (GlyphPtr glyph, int format)
{
    CheckDuplicates (&globalGlyphs[format], "FreeGlyph");
    if (--glyph->refcnt == 0)
    {
	GlyphRefPtr      gr;
	int	         i;
	int	         first;
	CARD32		 signature;

	first = -1;
	for (i = 0; i < globalGlyphs[format].hashSet->size; i++)
	    if (globalGlyphs[format].table[i].glyph == glyph)
	    {
		if (first != -1)
		    DuplicateRef (glyph, "FreeGlyph check");
		first = i;
	    }

	signature = *(CARD32 *) glyph->sha1;
	gr = FindGlyphRef (&globalGlyphs[format], signature,
			   TRUE, glyph->sha1);
	if (gr - globalGlyphs[format].table != first)
	    DuplicateRef (glyph, "Found wrong one");
	if (gr->glyph && gr->glyph != DeletedGlyph)
	{
	    gr->glyph = DeletedGlyph;
	    gr->signature = 0;
	    globalGlyphs[format].tableEntries--;
	}

	FreeGlyphPicture(glyph);
	dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
    }
}

void
AddGlyph (GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id)
{
    GlyphRefPtr	    gr;
    CARD32	    signature;

    CheckDuplicates (&globalGlyphs[glyphSet->fdepth], "AddGlyph top global");
    /* Locate existing matching glyph */
    signature = *(CARD32 *) glyph->sha1;
    gr = FindGlyphRef (&globalGlyphs[glyphSet->fdepth], signature,
		       TRUE, glyph->sha1);
    if (gr->glyph && gr->glyph != DeletedGlyph && gr->glyph != glyph)
    {
	FreeGlyphPicture(glyph);
	dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
	glyph = gr->glyph;
    }
    else if (gr->glyph != glyph)
    {
	gr->glyph = glyph;
	gr->signature = signature;
	globalGlyphs[glyphSet->fdepth].tableEntries++;
    }
    
    /* Insert/replace glyphset value */
    gr = FindGlyphRef (&glyphSet->hash, id, FALSE, 0);
    ++glyph->refcnt;
    if (gr->glyph && gr->glyph != DeletedGlyph)
	FreeGlyph (gr->glyph, glyphSet->fdepth);
    else
	glyphSet->hash.tableEntries++;
    gr->glyph = glyph;
    gr->signature = id;
    CheckDuplicates (&globalGlyphs[glyphSet->fdepth], "AddGlyph bottom");
}

Bool
DeleteGlyph (GlyphSetPtr glyphSet, Glyph id)
{
    GlyphRefPtr     gr;
    GlyphPtr	    glyph;

    gr = FindGlyphRef (&glyphSet->hash, id, FALSE, 0);
    glyph = gr->glyph;
    if (glyph && glyph != DeletedGlyph)
    {
	gr->glyph = DeletedGlyph;
	glyphSet->hash.tableEntries--;
	FreeGlyph (glyph, glyphSet->fdepth);
	return TRUE;
    }
    return FALSE;
}

GlyphPtr
FindGlyph (GlyphSetPtr glyphSet, Glyph id)
{
    GlyphPtr        glyph;

    glyph = FindGlyphRef (&glyphSet->hash, id, FALSE, 0)->glyph;
    if (glyph == DeletedGlyph)
	glyph = 0;
    return glyph;
}

GlyphPtr
AllocateGlyph (xGlyphInfo *gi, int fdepth)
{
    PictureScreenPtr ps;
    int		     size;
    GlyphPtr	     glyph;
    int		     i;
    int		     head_size;

    head_size = sizeof (GlyphRec) + screenInfo.numScreens * sizeof (PicturePtr);
    size = (head_size + dixPrivatesSize(PRIVATE_GLYPH));
    glyph = (GlyphPtr) malloc (size);
    if (!glyph)
	return 0;
    glyph->refcnt = 0;
    glyph->size = size + sizeof (xGlyphInfo);
    glyph->info = *gi;
    dixInitPrivates(glyph, (char *) glyph + head_size, PRIVATE_GLYPH);

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	GlyphPicture(glyph)[i] = NULL;
	ps = GetPictureScreenIfSet (screenInfo.screens[i]);

	if (ps)
	{
	    if (!(*ps->RealizeGlyph) (screenInfo.screens[i], glyph))
		goto bail;
	}
    }
    
    return glyph;

bail:
    while (i--)
    {
	ps = GetPictureScreenIfSet (screenInfo.screens[i]);
	if (ps)
	    (*ps->UnrealizeGlyph) (screenInfo.screens[i], glyph);
    }

    dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
    return 0;
}
    
Bool
AllocateGlyphHash (GlyphHashPtr hash, GlyphHashSetPtr hashSet)
{
    hash->table = calloc(hashSet->size, sizeof (GlyphRefRec));
    if (!hash->table)
	return FALSE;
    hash->hashSet = hashSet;
    hash->tableEntries = 0;
    return TRUE;
}

Bool
ResizeGlyphHash (GlyphHashPtr hash, CARD32 change, Bool global)
{
    CARD32	    tableEntries;
    GlyphHashSetPtr hashSet;
    GlyphHashRec    newHash;
    GlyphRefPtr	    gr;
    GlyphPtr	    glyph;
    int		    i;
    int		    oldSize;
    CARD32	    s;

    tableEntries = hash->tableEntries + change;
    hashSet = FindGlyphHashSet (tableEntries);
    if (hashSet == hash->hashSet)
	return TRUE;
    if (global)
	CheckDuplicates (hash, "ResizeGlyphHash top");
    if (!AllocateGlyphHash (&newHash, hashSet))
	return FALSE;
    if (hash->table)
    {
	oldSize = hash->hashSet->size;
	for (i = 0; i < oldSize; i++)
	{
	    glyph = hash->table[i].glyph;
	    if (glyph && glyph != DeletedGlyph)
	    {
		s = hash->table[i].signature;
		gr = FindGlyphRef (&newHash, s, global, glyph->sha1);
		gr->signature = s;
		gr->glyph = glyph;
		++newHash.tableEntries;
	    }
	}
	free(hash->table);
    }
    *hash = newHash;
    if (global)
	CheckDuplicates (hash, "ResizeGlyphHash bottom");
    return TRUE;
}

Bool
ResizeGlyphSet (GlyphSetPtr glyphSet, CARD32 change)
{
    return (ResizeGlyphHash (&glyphSet->hash, change, FALSE) &&
	    ResizeGlyphHash (&globalGlyphs[glyphSet->fdepth], change, TRUE));
}
			    
GlyphSetPtr
AllocateGlyphSet (int fdepth, PictFormatPtr format)
{
    GlyphSetPtr	glyphSet;
    
    if (!globalGlyphs[fdepth].hashSet)
    {
	if (!AllocateGlyphHash (&globalGlyphs[fdepth], &glyphHashSets[0]))
	    return FALSE;
    }

    glyphSet = dixAllocateObjectWithPrivates(GlyphSetRec, PRIVATE_GLYPHSET);
    if (!glyphSet)
	return FALSE;

    if (!AllocateGlyphHash (&glyphSet->hash, &glyphHashSets[0]))
    {
	free(glyphSet);
	return FALSE;
    }
    glyphSet->refcnt = 1;
    glyphSet->fdepth = fdepth;
    glyphSet->format = format;
    return glyphSet;	
}

int
FreeGlyphSet (pointer	value,
	      XID       gid)
{
    GlyphSetPtr	glyphSet = (GlyphSetPtr) value;
    
    if (--glyphSet->refcnt == 0)
    {
	CARD32	    i, tableSize = glyphSet->hash.hashSet->size;
	GlyphRefPtr table = glyphSet->hash.table;
	GlyphPtr    glyph;
    
	for (i = 0; i < tableSize; i++)
	{
	    glyph = table[i].glyph;
	    if (glyph && glyph != DeletedGlyph)
		FreeGlyph (glyph, glyphSet->fdepth);
	}
	if (!globalGlyphs[glyphSet->fdepth].tableEntries)
	{
	    free(globalGlyphs[glyphSet->fdepth].table);
	    globalGlyphs[glyphSet->fdepth].table = 0;
	    globalGlyphs[glyphSet->fdepth].hashSet = 0;
	}
	else
	    ResizeGlyphHash (&globalGlyphs[glyphSet->fdepth], 0, TRUE);
	free(table);
	dixFreeObjectWithPrivates(glyphSet, PRIVATE_GLYPHSET);
    }
    return Success;
}

static void
GlyphExtents (int		nlist,
		GlyphListPtr	list,
		GlyphPtr	*glyphs,
		BoxPtr		extents)
{
    int		x1, x2, y1, y2;
    int		n;
    GlyphPtr	glyph;
    int		x, y;
    
    x = 0;
    y = 0;
    extents->x1 = MAXSHORT;
    extents->x2 = MINSHORT;
    extents->y1 = MAXSHORT;
    extents->y2 = MINSHORT;
    while (nlist--)
    {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	list++;
	while (n--)
	{
	    glyph = *glyphs++;
	    x1 = x - glyph->info.x;
	    if (x1 < MINSHORT)
		x1 = MINSHORT;
	    y1 = y - glyph->info.y;
	    if (y1 < MINSHORT)
		y1 = MINSHORT;
	    x2 = x1 + glyph->info.width;
	    if (x2 > MAXSHORT)
		x2 = MAXSHORT;
	    y2 = y1 + glyph->info.height;
	    if (y2 > MAXSHORT)
		y2 = MAXSHORT;
	    if (x1 < extents->x1)
		extents->x1 = x1;
	    if (x2 > extents->x2)
		extents->x2 = x2;
	    if (y1 < extents->y1)
		extents->y1 = y1;
	    if (y2 > extents->y2)
		extents->y2 = y2;
	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
	}
    }
}

#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)

void
CompositeGlyphs (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		nlist,
		 GlyphListPtr	lists,
		 GlyphPtr	*glyphs)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);

    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->Glyphs) (op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, lists, glyphs);
}

Bool
miRealizeGlyph (ScreenPtr pScreen,
		GlyphPtr  glyph)
{
    return TRUE;
}

void
miUnrealizeGlyph (ScreenPtr pScreen,
		  GlyphPtr  glyph)
{
}

void
miGlyphs (CARD8		op,
	  PicturePtr	pSrc,
	  PicturePtr	pDst,
	  PictFormatPtr	maskFormat,
	  INT16		xSrc,
	  INT16		ySrc,
	  int		nlist,
	  GlyphListPtr	list,
	  GlyphPtr	*glyphs)
{
    PicturePtr	pPicture;
    PixmapPtr   pMaskPixmap = 0;
    PicturePtr  pMask;
    ScreenPtr   pScreen = pDst->pDrawable->pScreen;
    int		width = 0, height = 0;
    int		x, y;
    int		xDst = list->xOff, yDst = list->yOff;
    int		n;
    GlyphPtr	glyph;
    int		error;
    BoxRec	extents = {0, 0, 0, 0};
    CARD32	component_alpha;

    if (maskFormat)
    {
	GCPtr	    pGC;
	xRectangle  rect;

	GlyphExtents (nlist, list, glyphs, &extents);

	if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
	    return;
	width = extents.x2 - extents.x1;
	height = extents.y2 - extents.y1;
	pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
						maskFormat->depth,
						CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pMaskPixmap)
	    return;
	component_alpha = NeedsComponent(maskFormat->format);
	pMask = CreatePicture (0, &pMaskPixmap->drawable,
			       maskFormat, CPComponentAlpha, &component_alpha,
			       serverClient, &error);
	if (!pMask)
	{
	    (*pScreen->DestroyPixmap) (pMaskPixmap);
	    return;
	}
	pGC = GetScratchGC (pMaskPixmap->drawable.depth, pScreen);
	ValidateGC (&pMaskPixmap->drawable, pGC);
	rect.x = 0;
	rect.y = 0;
	rect.width = width;
	rect.height = height;
	(*pGC->ops->PolyFillRect) (&pMaskPixmap->drawable, pGC, 1, &rect);
	FreeScratchGC (pGC);
	x = -extents.x1;
	y = -extents.y1;
    }
    else
    {
	pMask = pDst;
	x = 0;
	y = 0;
    }
    while (nlist--)
    {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	while (n--)
	{
	    glyph = *glyphs++;
	    pPicture = GlyphPicture (glyph)[pScreen->myNum];

	    if (pPicture)
	    {
		if (maskFormat)
		{
			CompositePicture (PictOpAdd,
					  pPicture,
					  None,
					  pMask,
					  0, 0,
					  0, 0,
					  x - glyph->info.x,
					  y - glyph->info.y,
					  glyph->info.width,
					  glyph->info.height);
		}
		else
		{
		    CompositePicture (op,
				      pSrc,
				      pPicture,
				      pDst,
				      xSrc + (x - glyph->info.x) - xDst,
				      ySrc + (y - glyph->info.y) - yDst,
				      0, 0,
				      x - glyph->info.x,
				      y - glyph->info.y,
				      glyph->info.width,
				      glyph->info.height);
		}
	    }

	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
	}
	list++;
    }
    if (maskFormat)
    {
	x = extents.x1;
	y = extents.y1;
	CompositePicture (op,
			  pSrc,
			  pMask,
			  pDst,
			  xSrc + x - xDst,
			  ySrc + y - yDst,
			  0, 0,
			  x, y,
			  width, height);
	FreePicture ((pointer) pMask, (XID) 0);
	(*pScreen->DestroyPixmap) (pMaskPixmap);
    }
}
/*
 *
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifndef _GLYPHSTR_H_
#define _GLYPHSTR_H_

#include <X11/extensions/renderproto.h>
#include "picture.h"
#include "screenint.h"
#include "regionstr.h"
#include "miscstruct.h"
#include "privates.h"

#define GlyphFormat1	0
#define GlyphFormat4	1
#define GlyphFormat8	2
#define GlyphFormat16	3
#define GlyphFormat32	4
#define GlyphFormatNum	5

typedef struct _Glyph {
    CARD32	    refcnt;
    PrivateRec	*devPrivates;
    unsigned char   sha1[20];
    CARD32	    size; /* info + bitmap */
    xGlyphInfo	    info;
    /* per-screen pixmaps follow */
} GlyphRec, *GlyphPtr;

#define GlyphPicture(glyph) ((PicturePtr *) ((glyph) + 1))

typedef struct _GlyphRef {
    CARD32	signature;
    GlyphPtr	glyph;
} GlyphRefRec, *GlyphRefPtr;

#define DeletedGlyph	((GlyphPtr) 1)

typedef struct _GlyphHashSet {
    CARD32	entries;
    CARD32	size;
    CARD32	rehash;
} GlyphHashSetRec, *GlyphHashSetPtr;

typedef struct _GlyphHash {
    GlyphRefPtr	    table;
    GlyphHashSetPtr hashSet;
    CARD32	    tableEntries;
} GlyphHashRec, *GlyphHashPtr;

typedef struct _GlyphSet {
    CARD32	    refcnt;
    int		    fdepth;
    PictFormatPtr   format;
    GlyphHashRec    hash;
    PrivateRec      *devPrivates;
} GlyphSetRec, *GlyphSetPtr;

#define GlyphSetGetPrivate(pGlyphSet,k)					\
    dixLookupPrivate(&(pGlyphSet)->devPrivates, k)

#define GlyphSetSetPrivate(pGlyphSet,k,ptr)				\
    dixSetPrivate(&(pGlyphSet)->devPrivates, k, ptr)

typedef struct _GlyphList {
    INT16	    xOff;
    INT16	    yOff;
    CARD8	    len;
    PictFormatPtr   format;
} GlyphListRec, *GlyphListPtr;

extern _X_EXPORT GlyphHashSetPtr
FindGlyphHashSet (CARD32 filled);

extern _X_EXPORT void
GlyphUninit (ScreenPtr pScreen);

extern _X_EXPORT GlyphHashSetPtr
FindGlyphHashSet (CARD32 filled);

extern _X_EXPORT GlyphRefPtr
FindGlyphRef (GlyphHashPtr	hash,
	      CARD32		signature,
	      Bool		match,
	      unsigned char	sha1[20]);

extern _X_EXPORT GlyphPtr
FindGlyphByHash (unsigned char sha1[20], int format);

extern _X_EXPORT int
HashGlyph (xGlyphInfo    *gi,
	   CARD8	 *bits,
	   unsigned long size,
	   unsigned char sha1[20]);

extern _X_EXPORT void
FreeGlyph (GlyphPtr glyph, int format);

extern _X_EXPORT void
AddGlyph (GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id);

extern _X_EXPORT Bool
DeleteGlyph (GlyphSetPtr glyphSet, Glyph id);

extern _X_EXPORT GlyphPtr
FindGlyph (GlyphSetPtr glyphSet, Glyph id);

extern _X_EXPORT GlyphPtr
AllocateGlyph (xGlyphInfo *gi, int format);

extern _X_EXPORT Bool
AllocateGlyphHash (GlyphHashPtr hash, GlyphHashSetPtr hashSet);

extern _X_EXPORT Bool
ResizeGlyphHash (GlyphHashPtr hash, CARD32 change, Bool global);

extern _X_EXPORT Bool
ResizeGlyphSet (GlyphSetPtr glyphSet, CARD32 change);

extern _X_EXPORT GlyphSetPtr
AllocateGlyphSet (int fdepth, PictFormatPtr format);

extern _X_EXPORT int
FreeGlyphSet (pointer   value,
	      XID       gid);



#endif /* _GLYPHSTR_H_ */
noinst_LTLIBRARIES = librender.la

AM_CFLAGS = $(DIX_CFLAGS)

librender_la_SOURCES =	\
	animcur.c	\
	filter.c	\
	glyph.c		\
	matrix.c	\
	miindex.c	\
	mipict.c	\
	mirect.c	\
	mitrap.c	\
	mitri.c		\
	picture.c	\
	render.c

if XORG
sdk_HEADERS = picture.h mipict.h glyphstr.h picturestr.h
endif
/*
 * Copyright © 2007 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "misc.h"
#include "scrnintstr.h"
#include "os.h"
#include "regionstr.h"
#include "validate.h"
#include "windowstr.h"
#include "input.h"
#include "resource.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "servermd.h"
#include "picturestr.h"

void
PictTransform_from_xRenderTransform (PictTransformPtr pict,
				     xRenderTransform *render)
{
    pict->matrix[0][0] = render->matrix11;
    pict->matrix[0][1] = render->matrix12;
    pict->matrix[0][2] = render->matrix13;

    pict->matrix[1][0] = render->matrix21;
    pict->matrix[1][1] = render->matrix22;
    pict->matrix[1][2] = render->matrix23;

    pict->matrix[2][0] = render->matrix31;
    pict->matrix[2][1] = render->matrix32;
    pict->matrix[2][2] = render->matrix33;
}

void
xRenderTransform_from_PictTransform (xRenderTransform *render,
				     PictTransformPtr pict)
{
    render->matrix11 = pict->matrix[0][0];
    render->matrix12 = pict->matrix[0][1];
    render->matrix13 = pict->matrix[0][2];

    render->matrix21 = pict->matrix[1][0];
    render->matrix22 = pict->matrix[1][1];
    render->matrix23 = pict->matrix[1][2];

    render->matrix31 = pict->matrix[2][0];
    render->matrix32 = pict->matrix[2][1];
    render->matrix33 = pict->matrix[2][2];
}

Bool
PictureTransformPoint (PictTransformPtr transform,
		       PictVectorPtr	vector)
{
	return pixman_transform_point(transform, vector);
}

Bool
PictureTransformPoint3d (PictTransformPtr transform,
                         PictVectorPtr	vector)
{
	return pixman_transform_point_3d(transform, vector);
}
/*
 *
 * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _MIINDEX_H_
#define _MIINDEX_H_

#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "mi.h"
#include "picturestr.h"
#include "mipict.h"
#include "colormapst.h"

#define NUM_CUBE_LEVELS	4
#define NUM_GRAY_LEVELS	13

static Bool
miBuildRenderColormap (ColormapPtr  pColormap, Pixel *pixels, int *nump)
{
    int		r, g, b;
    unsigned short  red, green, blue;
    Pixel	pixel;
    Bool	used[MI_MAX_INDEXED];
    int		needed;
    int		policy;
    int		cube, gray;
    int		i, n;
    
    if (pColormap->mid != pColormap->pScreen->defColormap)
    {
	policy = PictureCmapPolicyAll;
    }
    else
    {
	int	avail = pColormap->pVisual->ColormapEntries;
	policy = PictureCmapPolicy;
	if (policy == PictureCmapPolicyDefault)
	{
	    if (avail >= 256 && (pColormap->pVisual->class|DynamicClass) == PseudoColor)
		policy = PictureCmapPolicyColor;
	    else if (avail >= 64)
		policy = PictureCmapPolicyGray;
	    else
		policy = PictureCmapPolicyMono;
	}
    }
    /*
     * Make sure enough cells are free for the chosen policy
     */
    for (;;)
    {
	switch (policy) {
	case PictureCmapPolicyAll:
	    needed = 0;
	    break;
	case PictureCmapPolicyColor:
	    needed = 71;
	    break;
	case PictureCmapPolicyGray:
	    needed = 11;
	    break;
	case PictureCmapPolicyMono:
	default:
	    needed = 0;
	    break;
	}
	if (needed <= pColormap->freeRed)
	    break;
	policy--;
    } 
    
    /*
     * Compute size of cube and gray ramps
     */
    cube = gray = 0;
    switch (policy) {
    case PictureCmapPolicyAll:
	/*
	 * Allocate as big a cube as possible
	 */
	if ((pColormap->pVisual->class|DynamicClass) == PseudoColor)
	{
	    for (cube = 1; cube * cube * cube < pColormap->pVisual->ColormapEntries; cube++)
		;
	    cube--;
	    if (cube == 1)
		cube = 0;
	}
	else
	    cube = 0;
	/*
	 * Figure out how many gray levels to use so that they
	 * line up neatly with the cube
	 */
	if (cube)
	{
	    needed = pColormap->pVisual->ColormapEntries - (cube*cube*cube);
	    /* levels to fill in with */
	    gray = needed / (cube - 1);
	    /* total levels */
	    gray = (gray + 1) * (cube - 1) + 1;
	}
	else
	    gray = pColormap->pVisual->ColormapEntries;
	break;
		
    case PictureCmapPolicyColor:
	cube = NUM_CUBE_LEVELS;
	/* fall through ... */
    case PictureCmapPolicyGray:
	gray = NUM_GRAY_LEVELS;
	break;
    case PictureCmapPolicyMono:
    default:
	gray = 2;
	break;
    }
    
    memset (used, '\0', pColormap->pVisual->ColormapEntries * sizeof (Bool));
    for (r = 0; r < cube; r++)
	for (g = 0; g < cube; g++)
	    for (b = 0; b < cube; b++)
	    {
		pixel = 0;
		red = (r * 65535 + (cube-1)/2) / (cube - 1);
		green = (g * 65535 + (cube-1)/2) / (cube - 1);
		blue = (b * 65535 + (cube-1)/2) / (cube - 1);
		if (AllocColor (pColormap, &red, &green, 
				&blue, &pixel, 0) != Success)
		    return FALSE;
		used[pixel] = TRUE;
	    }
    for (g = 0; g < gray; g++)
    {
	pixel = 0;
	red = green = blue = (g * 65535 + (gray-1)/2) / (gray - 1);
	if (AllocColor (pColormap, &red, &green, &blue, &pixel, 0) != Success)
	    return FALSE;
	used[pixel] = TRUE;
    }
    n = 0;
    for (i = 0; i < pColormap->pVisual->ColormapEntries; i++)
	if (used[i])
	    pixels[n++] = i;

    *nump = n;
    
    return TRUE;
}

/* 0 <= red, green, blue < 32 */
static Pixel
FindBestColor (miIndexedPtr pIndexed, Pixel *pixels, int num,
	       int red, int green, int blue)
{
    Pixel   best = pixels[0];
    int	    bestDist = 1 << 30;
    int	    dist;
    int	    dr, dg, db;
    while (num--)
    {
	Pixel	pixel = *pixels++;
	CARD32	v = pIndexed->rgba[pixel];

	dr = ((v >> 19) & 0x1f);
	dg = ((v >> 11) & 0x1f);
	db = ((v >> 3) & 0x1f);
	dr = dr - red;
	dg = dg - green;
	db = db - blue;
	dist = dr * dr + dg * dg + db * db;
	if (dist < bestDist)
	{
	    bestDist = dist;
	    best = pixel;
	}
    }
    return best;
}

/* 0 <= gray < 32768 */
static Pixel
FindBestGray (miIndexedPtr pIndexed, Pixel *pixels, int num, int gray)
{
    Pixel   best = pixels[0];
    int	    bestDist = 1 << 30;
    int	    dist;
    int	    dr;
    int	    r;
    
    while (num--)
    {
	Pixel   pixel = *pixels++;
	CARD32	v = pIndexed->rgba[pixel];

	r = v & 0xff;
	r = r | (r << 8);
	dr = gray - (r >> 1);
	dist = dr * dr;
	if (dist < bestDist)
	{
	    bestDist = dist;
	    best = pixel;
	}
    }
    return best;
}

Bool
miInitIndexed (ScreenPtr	pScreen,
	       PictFormatPtr	pFormat)
{
    ColormapPtr	    pColormap = pFormat->index.pColormap;
    VisualPtr	    pVisual = pColormap->pVisual;
    miIndexedPtr    pIndexed;
    Pixel	    pixels[MI_MAX_INDEXED];
    xrgb	    rgb[MI_MAX_INDEXED];
    int		    num;
    int		    i;
    Pixel	    p, r, g, b;

    if (pVisual->ColormapEntries > MI_MAX_INDEXED)
	return FALSE;
    
    if (pVisual->class & DynamicClass)
    {
	if (!miBuildRenderColormap (pColormap, pixels, &num))
	    return FALSE;
    }
    else
    {
	num = pVisual->ColormapEntries;
	for (p = 0; p < num; p++)
	    pixels[p] = p;
    }
    
    pIndexed = malloc(sizeof (miIndexedRec));
    if (!pIndexed)
	return FALSE;
    
    pFormat->index.nvalues = num;
    pFormat->index.pValues = malloc(num * sizeof (xIndexValue));
    if (!pFormat->index.pValues)
    {
	free(pIndexed);
	return FALSE;
    }
    
    
    /*
     * Build mapping from pixel value to ARGB
     */
    QueryColors (pColormap, num, pixels, rgb, serverClient);
    for (i = 0; i < num; i++)
    {
	p = pixels[i];
	pFormat->index.pValues[i].pixel = p;
	pFormat->index.pValues[i].red   = rgb[i].red;
	pFormat->index.pValues[i].green = rgb[i].green;
	pFormat->index.pValues[i].blue  = rgb[i].blue;
	pFormat->index.pValues[i].alpha = 0xffff;
	pIndexed->rgba[p] = (0xff000000 |
			     ((rgb[i].red   & 0xff00) << 8) |
			     ((rgb[i].green & 0xff00)     ) |
			     ((rgb[i].blue  & 0xff00) >> 8));
    }

    /*
     * Build mapping from RGB to pixel value.  This could probably be
     * done a bit quicker...
     */
    switch (pVisual->class | DynamicClass) {
    case GrayScale:
	pIndexed->color = FALSE;
	for (r = 0; r < 32768; r++)
	    pIndexed->ent[r] = FindBestGray (pIndexed, pixels, num, r);
	break;
    case PseudoColor:
	pIndexed->color = TRUE;
	p = 0;
	for (r = 0; r < 32; r++)
	    for (g = 0; g < 32; g++)
		for (b = 0; b < 32; b++)
		{
		    pIndexed->ent[p] = FindBestColor (pIndexed, pixels, num,
						      r, g, b);
		    p++;
		}
	break;
    }
    pFormat->index.devPrivate = pIndexed;
    return TRUE;
}

void
miCloseIndexed (ScreenPtr	pScreen,
		PictFormatPtr	pFormat)
{
    free(pFormat->index.devPrivate);
    pFormat->index.devPrivate = NULL;
    free(pFormat->index.pValues);
    pFormat->index.pValues = NULL;
}

void
miUpdateIndexed (ScreenPtr	pScreen,
		 PictFormatPtr	pFormat,
		 int		ndef,
		 xColorItem	*pdef)
{
    miIndexedPtr pIndexed = pFormat->index.devPrivate;

    if (pIndexed)
    {
	while (ndef--)
	{
	    pIndexed->rgba[pdef->pixel] = (0xff000000 |
					   ((pdef->red   & 0xff00) << 8) |
					   ((pdef->green & 0xff00)     ) |
					   ((pdef->blue  & 0xff00) >> 8));
	    pdef++;
	}
    }
}

#endif /* _MIINDEX_H_ */
/*
 *
 * Copyright © 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "mi.h"
#include "picturestr.h"
#include "mipict.h"

#ifndef __GNUC__
#define __inline
#endif

int
miCreatePicture (PicturePtr pPicture)
{
    return Success;
}

void
miDestroyPicture (PicturePtr pPicture)
{
    if (pPicture->freeCompClip)
	RegionDestroy(pPicture->pCompositeClip);
}

void
miDestroyPictureClip (PicturePtr pPicture)
{
    switch (pPicture->clientClipType) {
    case CT_NONE:
	return;
    case CT_PIXMAP:
	(*pPicture->pDrawable->pScreen->DestroyPixmap) ((PixmapPtr) (pPicture->clientClip));
	break;
    default:
	/*
	 * we know we'll never have a list of rectangles, since ChangeClip
	 * immediately turns them into a region
	 */
	RegionDestroy(pPicture->clientClip);
	break;
    }
    pPicture->clientClip = NULL;
    pPicture->clientClipType = CT_NONE;
}    

int
miChangePictureClip (PicturePtr    pPicture,
		     int	   type,
		     pointer	   value,
		     int	   n)
{
    ScreenPtr		pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    pointer		clientClip;
    int			clientClipType;
    
    switch (type) {
    case CT_PIXMAP:
	/* convert the pixmap to a region */
	clientClip = (pointer) BitmapToRegion(pScreen, (PixmapPtr) value);
	if (!clientClip)
	    return BadAlloc;
	clientClipType = CT_REGION;
	(*pScreen->DestroyPixmap) ((PixmapPtr) value);
	break;
    case CT_REGION:
	clientClip = value;
	clientClipType = CT_REGION;
	break;
    case CT_NONE:
	clientClip = 0;
	clientClipType = CT_NONE;
	break;
    default:
	clientClip = (pointer) RegionFromRects(n,
					       (xRectangle *) value,
					       type);
	if (!clientClip)
	    return BadAlloc;
	clientClipType = CT_REGION;
	free(value);
	break;
    }
    (*ps->DestroyPictureClip) (pPicture);
    pPicture->clientClip = clientClip;
    pPicture->clientClipType = clientClipType;
    pPicture->stateChanges |= CPClipMask;
    return Success;
}

void
miChangePicture (PicturePtr pPicture,
		 Mask       mask)
{
    return;
}

void
miValidatePicture (PicturePtr pPicture,
		   Mask       mask)
{
    DrawablePtr	    pDrawable = pPicture->pDrawable;

    if ((mask & (CPClipXOrigin|CPClipYOrigin|CPClipMask|CPSubwindowMode)) ||
	(pDrawable->serialNumber != (pPicture->serialNumber & DRAWABLE_SERIAL_BITS)))
    {
	if (pDrawable->type == DRAWABLE_WINDOW)
	{
	    WindowPtr       pWin = (WindowPtr) pDrawable;
	    RegionPtr       pregWin;
	    Bool            freeTmpClip, freeCompClip;

	    if (pPicture->subWindowMode == IncludeInferiors)
	    {
		pregWin = NotClippedByChildren(pWin);
		freeTmpClip = TRUE;
	    }
	    else
	    {
		pregWin = &pWin->clipList;
		freeTmpClip = FALSE;
	    }
	    freeCompClip = pPicture->freeCompClip;

	    /*
	     * if there is no client clip, we can get by with just keeping the
	     * pointer we got, and remembering whether or not should destroy
	     * (or maybe re-use) it later.  this way, we avoid unnecessary
	     * copying of regions.  (this wins especially if many clients clip
	     * by children and have no client clip.)
	     */
	    if (pPicture->clientClipType == CT_NONE)
	    {
		if (freeCompClip)
		    RegionDestroy(pPicture->pCompositeClip);
		pPicture->pCompositeClip = pregWin;
		pPicture->freeCompClip = freeTmpClip;
	    }
	    else
	    {
		/*
		 * we need one 'real' region to put into the composite clip. if
		 * pregWin the current composite clip are real, we can get rid of
		 * one. if pregWin is real and the current composite clip isn't,
		 * use pregWin for the composite clip. if the current composite
		 * clip is real and pregWin isn't, use the current composite
		 * clip. if neither is real, create a new region.
		 */

		RegionTranslate(pPicture->clientClip,
				 pDrawable->x + pPicture->clipOrigin.x,
				 pDrawable->y + pPicture->clipOrigin.y);

		if (freeCompClip)
		{
		    RegionIntersect(pPicture->pCompositeClip,
				     pregWin, pPicture->clientClip);
		    if (freeTmpClip)
			RegionDestroy(pregWin);
		}
		else if (freeTmpClip)
		{
		    RegionIntersect(pregWin, pregWin, pPicture->clientClip);
		    pPicture->pCompositeClip = pregWin;
		}
		else
		{
		    pPicture->pCompositeClip = RegionCreate(NullBox, 0);
		    RegionIntersect(pPicture->pCompositeClip,
				     pregWin, pPicture->clientClip);
		}
		pPicture->freeCompClip = TRUE;
		RegionTranslate(pPicture->clientClip,
				 -(pDrawable->x + pPicture->clipOrigin.x),
				 -(pDrawable->y + pPicture->clipOrigin.y));
	    }
	}	/* end of composite clip for a window */
	else
	{
	    BoxRec          pixbounds;

	    /* XXX should we translate by drawable.x/y here ? */
	    /* If you want pixmaps in offscreen memory, yes */
	    pixbounds.x1 = pDrawable->x;
	    pixbounds.y1 = pDrawable->y;
	    pixbounds.x2 = pDrawable->x + pDrawable->width;
	    pixbounds.y2 = pDrawable->y + pDrawable->height;

	    if (pPicture->freeCompClip)
	    {
		RegionReset(pPicture->pCompositeClip, &pixbounds);
	    }
	    else
	    {
		pPicture->freeCompClip = TRUE;
		pPicture->pCompositeClip = RegionCreate(&pixbounds, 1);
	    }

	    if (pPicture->clientClipType == CT_REGION)
	    {
		if(pDrawable->x || pDrawable->y) {
		    RegionTranslate(pPicture->clientClip,
				     pDrawable->x + pPicture->clipOrigin.x, 
				     pDrawable->y + pPicture->clipOrigin.y);
		    RegionIntersect(pPicture->pCompositeClip,
				     pPicture->pCompositeClip, pPicture->clientClip);
		    RegionTranslate(pPicture->clientClip,
				     -(pDrawable->x + pPicture->clipOrigin.x), 
				     -(pDrawable->y + pPicture->clipOrigin.y));
		} else {
		    RegionTranslate(pPicture->pCompositeClip,
				     -pPicture->clipOrigin.x, -pPicture->clipOrigin.y);
		    RegionIntersect(pPicture->pCompositeClip,
				     pPicture->pCompositeClip, pPicture->clientClip);
		    RegionTranslate(pPicture->pCompositeClip,
				     pPicture->clipOrigin.x, pPicture->clipOrigin.y);
		}
	    }
	}	/* end of composite clip for pixmap */
    }
}

int
miChangePictureTransform (PicturePtr	pPicture,
			  PictTransform *transform)
{
    return Success;
}

int
miChangePictureFilter (PicturePtr pPicture,
		       int	  filter,
		       xFixed     *params,
		       int	  nparams)
{
    return Success;
}

#define BOUND(v)	(INT16) ((v) < MINSHORT ? MINSHORT : (v) > MAXSHORT ? MAXSHORT : (v))

static inline pixman_bool_t
miClipPictureReg (pixman_region16_t *	pRegion,
		  pixman_region16_t *	pClip,
		  int		dx,
		  int		dy)
{
    if (pixman_region_n_rects(pRegion) == 1 &&
	pixman_region_n_rects(pClip) == 1)
    {
	pixman_box16_t *  pRbox = pixman_region_rectangles(pRegion, NULL);
	pixman_box16_t *  pCbox = pixman_region_rectangles(pClip, NULL);
	int	v;
	
	if (pRbox->x1 < (v = pCbox->x1 + dx))
	    pRbox->x1 = BOUND(v);
	if (pRbox->x2 > (v = pCbox->x2 + dx))
	    pRbox->x2 = BOUND(v);
	if (pRbox->y1 < (v = pCbox->y1 + dy))
	    pRbox->y1 = BOUND(v);
	if (pRbox->y2 > (v = pCbox->y2 + dy))
	    pRbox->y2 = BOUND(v);
	if (pRbox->x1 >= pRbox->x2 ||
	    pRbox->y1 >= pRbox->y2)
	{
	    pixman_region_init (pRegion);
	}
    }
    else if (!pixman_region_not_empty (pClip))
	return FALSE;
    else
    {
	if (dx || dy)
	    pixman_region_translate (pRegion, -dx, -dy);
	if (!pixman_region_intersect (pRegion, pRegion, pClip))
	    return FALSE;
	if (dx || dy)
	    pixman_region_translate(pRegion, dx, dy);
    }
    return pixman_region_not_empty(pRegion);
}

static __inline Bool
miClipPictureSrc (RegionPtr	pRegion,
		  PicturePtr	pPicture,
		  int		dx,
		  int		dy)
{
    if (pPicture->clientClipType != CT_NONE)
    {
	Bool result;
	
	pixman_region_translate ( pPicture->clientClip,
				  pPicture->clipOrigin.x + dx,
				  pPicture->clipOrigin.y + dy);

	result = RegionIntersect(pRegion, pRegion, pPicture->clientClip);
	
	pixman_region_translate ( pPicture->clientClip,
				  - (pPicture->clipOrigin.x + dx),
				  - (pPicture->clipOrigin.y + dy));

	if (!result)
	    return FALSE;
    }
    return TRUE;
}

static void
SourceValidateOnePicture (PicturePtr pPicture)
{
    DrawablePtr	pDrawable = pPicture->pDrawable;
    ScreenPtr	pScreen;

    if (!pDrawable)
        return;

    pScreen = pDrawable->pScreen;

    if (pScreen->SourceValidate)
    {
	pScreen->SourceValidate (
	    pDrawable, 0, 0, pDrawable->width, pDrawable->height, pPicture->subWindowMode);
    }
}

void
miCompositeSourceValidate (PicturePtr pPicture)
{
    SourceValidateOnePicture (pPicture);
    if (pPicture->alphaMap)
	SourceValidateOnePicture (pPicture->alphaMap);
}

/*
 * returns FALSE if the final region is empty.  Indistinguishable from
 * an allocation failure, but rendering ignores those anyways.
 */

Bool
miComputeCompositeRegion (RegionPtr	pRegion,
			  PicturePtr	pSrc,
			  PicturePtr	pMask,
			  PicturePtr	pDst,
			  INT16		xSrc,
			  INT16		ySrc,
			  INT16		xMask,
			  INT16		yMask,
			  INT16		xDst,
			  INT16		yDst,
			  CARD16	width,
			  CARD16	height)
{
    
    int		v;

    pRegion->extents.x1 = xDst;
    v = xDst + width;
    pRegion->extents.x2 = BOUND(v);
    pRegion->extents.y1 = yDst;
    v = yDst + height;
    pRegion->extents.y2 = BOUND(v);
    pRegion->data = 0;
    /* Check for empty operation */
    if (pRegion->extents.x1 >= pRegion->extents.x2 ||
	pRegion->extents.y1 >= pRegion->extents.y2)
    {
	pixman_region_init (pRegion);
	return FALSE;
    }
    /* clip against dst */
    if (!miClipPictureReg (pRegion, pDst->pCompositeClip, 0, 0))
    {
	pixman_region_fini (pRegion);
	return FALSE;
    }
    if (pDst->alphaMap)
    {
	if (!miClipPictureReg (pRegion, pDst->alphaMap->pCompositeClip,
			       -pDst->alphaOrigin.x,
			       -pDst->alphaOrigin.y))
	{
	    pixman_region_fini (pRegion);
	    return FALSE;
	}
    }
    /* clip against src */
    if (!miClipPictureSrc (pRegion, pSrc, xDst - xSrc, yDst - ySrc))
    {
	pixman_region_fini (pRegion);
	return FALSE;
    }
    if (pSrc->alphaMap)
    {
	if (!miClipPictureSrc (pRegion, pSrc->alphaMap,
			       xDst - (xSrc - pSrc->alphaOrigin.x),
			       yDst - (ySrc - pSrc->alphaOrigin.y)))
	{
	    pixman_region_fini (pRegion);
	    return FALSE;
	}
    }
    /* clip against mask */
    if (pMask)
    {
	if (!miClipPictureSrc (pRegion, pMask, xDst - xMask, yDst - yMask))
	{
	    pixman_region_fini (pRegion);
	    return FALSE;
	}	
	if (pMask->alphaMap)
	{
	    if (!miClipPictureSrc (pRegion, pMask->alphaMap,
				   xDst - (xMask - pMask->alphaOrigin.x),
				   yDst - (yMask - pMask->alphaOrigin.y)))
	    {
		pixman_region_fini (pRegion);
		return FALSE;
	    }
	}
    }

    
    miCompositeSourceValidate (pSrc);
    if (pMask)
	miCompositeSourceValidate (pMask);

    return TRUE;
}

void
miRenderColorToPixel (PictFormatPtr format,
		      xRenderColor  *color,
		      CARD32	    *pixel)
{
    CARD32	    r, g, b, a;
    miIndexedPtr    pIndexed;

    switch (format->type) {
    case PictTypeDirect:
	r = color->red >> (16 - Ones (format->direct.redMask));
	g = color->green >> (16 - Ones (format->direct.greenMask));
	b = color->blue >> (16 - Ones (format->direct.blueMask));
	a = color->alpha >> (16 - Ones (format->direct.alphaMask));
	r = r << format->direct.red;
	g = g << format->direct.green;
	b = b << format->direct.blue;
	a = a << format->direct.alpha;
	*pixel = r|g|b|a;
	break;
    case PictTypeIndexed:
	pIndexed = (miIndexedPtr) (format->index.devPrivate);
	if (pIndexed->color)
	{
	    r = color->red >> 11;
	    g = color->green >> 11;
	    b = color->blue >> 11;
	    *pixel = miIndexToEnt15 (pIndexed, (r << 10) | (g << 5) | b);
	}
	else
	{
	    r = color->red >> 8;
	    g = color->green >> 8;
	    b = color->blue >> 8;
	    *pixel = miIndexToEntY24 (pIndexed, (r << 16) | (g << 8) | b);
	}
	break;
    }
}

static CARD16
miFillColor (CARD32 pixel, int bits)
{
    while (bits < 16)
    {
	pixel |= pixel << bits;
	bits <<= 1;
    }
    return (CARD16) pixel;
}

Bool
miIsSolidAlpha (PicturePtr pSrc)
{
    ScreenPtr	pScreen;
    char	line[1];

    if (!pSrc->pDrawable)
        return FALSE;

    pScreen = pSrc->pDrawable->pScreen;
    
    /* Alpha-only */
    if (PICT_FORMAT_TYPE (pSrc->format) != PICT_TYPE_A)
	return FALSE;
    /* repeat */
    if (!pSrc->repeat)
	return FALSE;
    /* 1x1 */
    if (pSrc->pDrawable->width != 1 || pSrc->pDrawable->height != 1)
	return FALSE;
    line[0] = 1;
    (*pScreen->GetImage) (pSrc->pDrawable, 0, 0, 1, 1, ZPixmap, ~0L, line);
    switch (pSrc->pDrawable->bitsPerPixel) {
    case 1:
	return (CARD8) line[0] == 1 || (CARD8) line[0] == 0x80;
    case 4:
	return (CARD8) line[0] == 0xf || (CARD8) line[0] == 0xf0;
    case 8:
	return (CARD8) line[0] == 0xff;
    default:
	return FALSE;
    }
}

void
miRenderPixelToColor (PictFormatPtr format,
		      CARD32	    pixel,
		      xRenderColor  *color)
{
    CARD32	    r, g, b, a;
    miIndexedPtr    pIndexed;
    
    switch (format->type) {
    case PictTypeDirect:
	r = (pixel >> format->direct.red) & format->direct.redMask;
	g = (pixel >> format->direct.green) & format->direct.greenMask;
	b = (pixel >> format->direct.blue) & format->direct.blueMask;
	a = (pixel >> format->direct.alpha) & format->direct.alphaMask;
	color->red = miFillColor (r, Ones (format->direct.redMask));
	color->green = miFillColor (g, Ones (format->direct.greenMask));
	color->blue = miFillColor (b, Ones (format->direct.blueMask));
	color->alpha = miFillColor (a, Ones (format->direct.alphaMask));
	break;
    case PictTypeIndexed:
	pIndexed = (miIndexedPtr) (format->index.devPrivate);
	pixel = pIndexed->rgba[pixel & (MI_MAX_INDEXED-1)];
	r = (pixel >> 16) & 0xff;
	g = (pixel >>  8) & 0xff;
	b = (pixel      ) & 0xff;
	color->red = miFillColor (r, 8);
	color->green = miFillColor (g, 8);
	color->blue = miFillColor (b, 8);
	color->alpha = 0xffff;
	break;
    }
}

Bool
miPictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats)
{
    PictureScreenPtr    ps;
    
    if (!PictureInit (pScreen, formats, nformats))
	return FALSE;
    ps = GetPictureScreen(pScreen);
    ps->CreatePicture = miCreatePicture;
    ps->DestroyPicture = miDestroyPicture;
    ps->ChangePictureClip = miChangePictureClip;
    ps->DestroyPictureClip = miDestroyPictureClip;
    ps->ChangePicture = miChangePicture;
    ps->ValidatePicture = miValidatePicture;
    ps->InitIndexed = miInitIndexed;
    ps->CloseIndexed = miCloseIndexed;
    ps->UpdateIndexed = miUpdateIndexed;
    ps->ChangePictureTransform = miChangePictureTransform;
    ps->ChangePictureFilter = miChangePictureFilter;
    ps->RealizeGlyph = miRealizeGlyph;
    ps->UnrealizeGlyph = miUnrealizeGlyph;

    /* MI rendering routines */
    ps->Composite	= 0;			/* requires DDX support */
    ps->Glyphs		= miGlyphs;
    ps->CompositeRects	= miCompositeRects;
    ps->Trapezoids	= 0;
    ps->Triangles	= 0;
    
    ps->RasterizeTrapezoid = 0;			/* requires DDX support */
    ps->AddTraps	= 0;			/* requires DDX support */
    ps->AddTriangles	= 0;			/* requires DDX support */

    return TRUE;
}
/*
 *
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifndef _MIPICT_H_
#define _MIPICT_H_

#include "picturestr.h"

#define MI_MAX_INDEXED	256 /* XXX depth must be <= 8 */

#if MI_MAX_INDEXED <= 256
typedef CARD8 miIndexType;
#endif

typedef struct _miIndexed {
    Bool	color;
    CARD32	rgba[MI_MAX_INDEXED];
    miIndexType	ent[32768];
} miIndexedRec, *miIndexedPtr;

#define miCvtR8G8B8to15(s) ((((s) >> 3) & 0x001f) | \
			     (((s) >> 6) & 0x03e0) | \
			     (((s) >> 9) & 0x7c00))
#define miIndexToEnt15(mif,rgb15) ((mif)->ent[rgb15])
#define miIndexToEnt24(mif,rgb24) miIndexToEnt15(mif,miCvtR8G8B8to15(rgb24))

#define miIndexToEntY24(mif,rgb24) ((mif)->ent[CvtR8G8B8toY15(rgb24)])

extern _X_EXPORT int
miCreatePicture (PicturePtr pPicture);

extern _X_EXPORT void
miDestroyPicture (PicturePtr pPicture);

extern _X_EXPORT void
miDestroyPictureClip (PicturePtr pPicture);

extern _X_EXPORT int
miChangePictureClip (PicturePtr    pPicture,
		     int	   type,
		     pointer	   value,
		     int	   n);

extern _X_EXPORT void
miChangePicture (PicturePtr pPicture,
		 Mask       mask);

extern _X_EXPORT void
miValidatePicture (PicturePtr pPicture,
		   Mask       mask);

extern _X_EXPORT int
miChangePictureTransform (PicturePtr	pPicture,
			  PictTransform *transform);

extern _X_EXPORT int
miChangePictureFilter (PicturePtr pPicture,
		       int	  filter,
		       xFixed     *params,
		       int	  nparams);

extern _X_EXPORT void
miCompositeSourceValidate (PicturePtr pPicture);

extern _X_EXPORT Bool
miComputeCompositeRegion (RegionPtr	pRegion,
			  PicturePtr	pSrc,
			  PicturePtr	pMask,
			  PicturePtr	pDst,
			  INT16		xSrc,
			  INT16		ySrc,
			  INT16		xMask,
			  INT16		yMask,
			  INT16		xDst,
			  INT16		yDst,
			  CARD16	width,
			  CARD16	height);

extern _X_EXPORT Bool
miPictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats);

extern _X_EXPORT Bool
miRealizeGlyph (ScreenPtr pScreen,
		GlyphPtr  glyph);

extern _X_EXPORT void
miUnrealizeGlyph (ScreenPtr pScreen,
		  GlyphPtr  glyph);

extern _X_EXPORT void
miGlyphs (CARD8		op,
	  PicturePtr	pSrc,
	  PicturePtr	pDst,
	  PictFormatPtr	maskFormat,
	  INT16		xSrc,
	  INT16		ySrc,
	  int		nlist,
	  GlyphListPtr	list,
	  GlyphPtr	*glyphs);

extern _X_EXPORT void
miRenderColorToPixel (PictFormatPtr pPict,
		      xRenderColor  *color,
		      CARD32	    *pixel);

extern _X_EXPORT void
miRenderPixelToColor (PictFormatPtr pPict,
		      CARD32	    pixel,
		      xRenderColor  *color);

extern _X_EXPORT Bool
miIsSolidAlpha (PicturePtr pSrc);

extern _X_EXPORT void
miCompositeRects (CARD8		op,
		  PicturePtr	pDst,
		  xRenderColor  *color,
		  int		nRect,
		  xRectangle    *rects);

extern _X_EXPORT void
miTrapezoidBounds (int ntrap, xTrapezoid *traps, BoxPtr box);

extern _X_EXPORT void
miPointFixedBounds (int npoint, xPointFixed *points, BoxPtr bounds);
    
extern _X_EXPORT void
miTriangleBounds (int ntri, xTriangle *tris, BoxPtr bounds);

extern _X_EXPORT Bool
miInitIndexed (ScreenPtr	pScreen,
	       PictFormatPtr	pFormat);

extern _X_EXPORT void
miCloseIndexed (ScreenPtr	pScreen,
		PictFormatPtr	pFormat);

extern _X_EXPORT void
miUpdateIndexed (ScreenPtr	pScreen,
		 PictFormatPtr	pFormat,
		 int		ndef,
		 xColorItem	*pdef);

#endif /* _MIPICT_H_ */
/*
 *
 * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "mi.h"
#include "picturestr.h"
#include "mipict.h"

static void
miColorRects (PicturePtr    pDst,
	      PicturePtr    pClipPict,
	      xRenderColor  *color,
	      int	    nRect,
	      xRectangle    *rects,
	      int	    xoff,
	      int	    yoff)
{
    CARD32		pixel;
    GCPtr		pGC;
    ChangeGCVal		tmpval[5];
    RegionPtr		pClip;
    unsigned long	mask;

    miRenderColorToPixel (pDst->pFormat, color, &pixel);

    pGC = GetScratchGC (pDst->pDrawable->depth, pDst->pDrawable->pScreen);
    if (!pGC)
	return;
    tmpval[0].val = GXcopy;
    tmpval[1].val = pixel;
    tmpval[2].val = pDst->subWindowMode;
    mask = GCFunction | GCForeground | GCSubwindowMode;
    if (pClipPict->clientClipType == CT_REGION)
    {
	tmpval[3].val = pDst->clipOrigin.x - xoff;
	tmpval[4].val = pDst->clipOrigin.y - yoff;
	mask |= GCClipXOrigin|GCClipYOrigin;
	
	pClip = RegionCreate(NULL, 1);
	RegionCopy(pClip,
		     (RegionPtr) pClipPict->clientClip);
	(*pGC->funcs->ChangeClip) (pGC, CT_REGION, pClip, 0);
    }

    ChangeGC (NullClient, pGC, mask, tmpval);
    ValidateGC (pDst->pDrawable, pGC);
    if (xoff || yoff)
    {
	int	i;
	for (i = 0; i < nRect; i++)
	{
	    rects[i].x -= xoff;
	    rects[i].y -= yoff;
	}
    }
    (*pGC->ops->PolyFillRect) (pDst->pDrawable, pGC, nRect, rects);
    if (xoff || yoff)
    {
	int	i;
	for (i = 0; i < nRect; i++)
	{
	    rects[i].x += xoff;
	    rects[i].y += yoff;
	}
    }
    FreeScratchGC (pGC);
}

void
miCompositeRects (CARD8		op,
		  PicturePtr	pDst,
		  xRenderColor  *color,
		  int		nRect,
		  xRectangle    *rects)
{
    ScreenPtr		pScreen = pDst->pDrawable->pScreen;
    
    if (color->alpha == 0xffff)
    {
	if (op == PictOpOver)
	    op = PictOpSrc;
    }
    if (op == PictOpClear)
	color->red = color->green = color->blue = color->alpha = 0;
    
    if (op == PictOpSrc || op == PictOpClear)
    {
	miColorRects (pDst, pDst, color, nRect, rects, 0, 0);
	if (pDst->alphaMap)
	    miColorRects (pDst->alphaMap, pDst,
			  color, nRect, rects,
			  pDst->alphaOrigin.x,
			  pDst->alphaOrigin.y);
    }
    else
    {
	PictFormatPtr	rgbaFormat;
	PixmapPtr	pPixmap;
	PicturePtr	pSrc;
	xRectangle	one;
	int		error;
	Pixel		pixel;
	GCPtr		pGC;
	ChangeGCVal	gcvals[2];
	XID		tmpval[1];

	rgbaFormat = PictureMatchFormat (pScreen, 32, PICT_a8r8g8b8);
	if (!rgbaFormat)
	    goto bail1;
	
	pPixmap = (*pScreen->CreatePixmap) (pScreen, 1, 1, rgbaFormat->depth,
					    CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pPixmap)
	    goto bail2;
	
	miRenderColorToPixel (rgbaFormat, color, &pixel);

	pGC = GetScratchGC (rgbaFormat->depth, pScreen);
	if (!pGC)
	    goto bail3;
	gcvals[0].val = GXcopy;
	gcvals[1].val = pixel;

	ChangeGC (NullClient, pGC, GCFunction | GCForeground, gcvals);
	ValidateGC (&pPixmap->drawable, pGC);
	one.x = 0;
	one.y = 0;
	one.width = 1;
	one.height = 1;
	(*pGC->ops->PolyFillRect) (&pPixmap->drawable, pGC, 1, &one);
	
	tmpval[0] = xTrue;
	pSrc = CreatePicture (0, &pPixmap->drawable, rgbaFormat,
			      CPRepeat, tmpval, serverClient, &error);
			      
	if (!pSrc)
	    goto bail4;

	while (nRect--)
	{
	    CompositePicture (op, pSrc, 0, pDst, 0, 0, 0, 0, 
			      rects->x,
			      rects->y,
			      rects->width,
			      rects->height);
	    rects++;
	}

	FreePicture ((pointer) pSrc, 0);
bail4:
	FreeScratchGC (pGC);
bail3:
	(*pScreen->DestroyPixmap) (pPixmap);
bail2:
bail1:
	;
    }
}
/*
 *
 * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "servermd.h"
#include "mi.h"
#include "picturestr.h"
#include "mipict.h"

static xFixed
miLineFixedX (xLineFixed *l, xFixed y, Bool ceil)
{
    xFixed	    dx = l->p2.x - l->p1.x;
    xFixed_32_32    ex = (xFixed_32_32) (y - l->p1.y) * dx;
    xFixed	    dy = l->p2.y - l->p1.y;
    if (ceil)
	ex += (dy - 1);
    return l->p1.x + (xFixed) (ex / dy);
}

void
miTrapezoidBounds (int ntrap, xTrapezoid *traps, BoxPtr box)
{
    box->y1 = MAXSHORT;
    box->y2 = MINSHORT;
    box->x1 = MAXSHORT;
    box->x2 = MINSHORT;
    for (; ntrap; ntrap--, traps++)
    {
	INT16 x1, y1, x2, y2;

	if (!xTrapezoidValid(traps))
	    continue;
	y1 = xFixedToInt (traps->top);
	if (y1 < box->y1)
	    box->y1 = y1;
	
	y2 = xFixedToInt (xFixedCeil (traps->bottom));
	if (y2 > box->y2)
	    box->y2 = y2;
	
	x1 = xFixedToInt (min (miLineFixedX (&traps->left, traps->top, FALSE),
			       miLineFixedX (&traps->left, traps->bottom, FALSE)));
	if (x1 < box->x1)
	    box->x1 = x1;
	
	x2 = xFixedToInt (xFixedCeil (max (miLineFixedX (&traps->right, traps->top, TRUE),
					   miLineFixedX (&traps->right, traps->bottom, TRUE))));
	if (x2 > box->x2)
	    box->x2 = x2;
    }
}
/*
 *
 * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "mi.h"
#include "picturestr.h"
#include "mipict.h"

void
miPointFixedBounds (int npoint, xPointFixed *points, BoxPtr bounds)
{
    bounds->x1 = xFixedToInt (points->x);
    bounds->x2 = xFixedToInt (xFixedCeil (points->x));
    bounds->y1 = xFixedToInt (points->y);
    bounds->y2 = xFixedToInt (xFixedCeil (points->y));
    points++;
    npoint--;
    while (npoint-- > 0)
    {
	INT16	x1 = xFixedToInt (points->x);
	INT16	x2 = xFixedToInt (xFixedCeil (points->x));
	INT16	y1 = xFixedToInt (points->y);
	INT16	y2 = xFixedToInt (xFixedCeil (points->y));

	if (x1 < bounds->x1)
	    bounds->x1 = x1;
	else if (x2 > bounds->x2)
	    bounds->x2 = x2;
	if (y1 < bounds->y1)
	    bounds->y1 = y1;
	else if (y2 > bounds->y2)
	    bounds->y2 = y2;
	points++;
    }
}

void
miTriangleBounds (int ntri, xTriangle *tris, BoxPtr bounds)
{
    miPointFixedBounds (ntri * 3, (xPointFixed *) tris, bounds);
}
/*
 *
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "misc.h"
#include "scrnintstr.h"
#include "os.h"
#include "regionstr.h"
#include "validate.h"
#include "windowstr.h"
#include "input.h"
#include "resource.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "servermd.h"
#include "picturestr.h"
#include "xace.h"

DevPrivateKeyRec PictureScreenPrivateKeyRec;
DevPrivateKeyRec PictureWindowPrivateKeyRec;
static int	PictureGeneration;
RESTYPE		PictureType;
RESTYPE		PictFormatType;
RESTYPE		GlyphSetType;
int		PictureCmapPolicy = PictureCmapPolicyDefault;

Bool
PictureDestroyWindow (WindowPtr pWindow)
{
    ScreenPtr		pScreen = pWindow->drawable.pScreen;
    PicturePtr		pPicture;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    Bool		ret;

    while ((pPicture = GetPictureWindow(pWindow)))
    {
	SetPictureWindow(pWindow, pPicture->pNext);
	if (pPicture->id)
	    FreeResource (pPicture->id, PictureType);
	FreePicture ((pointer) pPicture, pPicture->id);
    }
    pScreen->DestroyWindow = ps->DestroyWindow;
    ret = (*pScreen->DestroyWindow) (pWindow);
    ps->DestroyWindow = pScreen->DestroyWindow;
    pScreen->DestroyWindow = PictureDestroyWindow;
    return ret;
}

Bool
PictureCloseScreen (int index, ScreenPtr pScreen)
{
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    Bool                ret;
    int			n;

    pScreen->CloseScreen = ps->CloseScreen;
    ret = (*pScreen->CloseScreen) (index, pScreen);
    PictureResetFilters (pScreen);
    for (n = 0; n < ps->nformats; n++)
	if (ps->formats[n].type == PictTypeIndexed)
	    (*ps->CloseIndexed) (pScreen, &ps->formats[n]);
    GlyphUninit (pScreen);
    SetPictureScreen(pScreen, 0);
    free(ps->formats);
    free(ps);
    return ret;
}

void
PictureStoreColors (ColormapPtr pColormap, int ndef, xColorItem *pdef)
{
    ScreenPtr		pScreen = pColormap->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);

    pScreen->StoreColors = ps->StoreColors;
    (*pScreen->StoreColors) (pColormap, ndef, pdef);
    ps->StoreColors = pScreen->StoreColors;
    pScreen->StoreColors = PictureStoreColors;

    if (pColormap->class == PseudoColor || pColormap->class == GrayScale)
    {
	PictFormatPtr	format = ps->formats;
	int		nformats = ps->nformats;

	while (nformats--)
	{
	    if (format->type == PictTypeIndexed &&
		format->index.pColormap == pColormap)
	    {
		(*ps->UpdateIndexed) (pScreen, format, ndef, pdef);
		break;
	    }
	    format++;
	}
    }
}

static int
visualDepth (ScreenPtr pScreen, VisualPtr pVisual)
{
    int		d, v;
    DepthPtr	pDepth;

    for (d = 0; d < pScreen->numDepths; d++)
    {
	pDepth = &pScreen->allowedDepths[d];
	for (v = 0; v < pDepth->numVids; v++)
	    if (pDepth->vids[v] == pVisual->vid)
		return pDepth->depth;
    }
    return 0;
}

typedef struct _formatInit {
    CARD32  format;
    CARD8   depth;
} FormatInitRec, *FormatInitPtr;

static int
addFormat (FormatInitRec    formats[256],
	   int		    nformat,
	   CARD32	    format,
	   CARD8	    depth)
{
    int	n;

    for (n = 0; n < nformat; n++)
	if (formats[n].format == format && formats[n].depth == depth)
	    return nformat;
    formats[nformat].format = format;
    formats[nformat].depth = depth;
    return ++nformat;
}

#define Mask(n) ((1 << (n)) - 1)

PictFormatPtr
PictureCreateDefaultFormats (ScreenPtr pScreen, int *nformatp)
{
    int		    nformats, f;
    PictFormatPtr   pFormats;
    FormatInitRec   formats[1024];
    CARD32	    format;
    CARD8	    depth;
    VisualPtr	    pVisual;
    int		    v;
    int		    bpp;
    int		    type;
    int		    r, g, b;
    int		    d;
    DepthPtr	    pDepth;

    nformats = 0;
    /* formats required by protocol */
    formats[nformats].format = PICT_a1;
    formats[nformats].depth = 1;
    nformats++;
    formats[nformats].format = PICT_FORMAT(BitsPerPixel(8),
					   PICT_TYPE_A,
					   8, 0, 0, 0);
    formats[nformats].depth = 8;
    nformats++;
    formats[nformats].format = PICT_FORMAT(BitsPerPixel(4),
					   PICT_TYPE_A,
					   4, 0, 0, 0);
    formats[nformats].depth = 4;
    nformats++;
    formats[nformats].format = PICT_a8r8g8b8;
    formats[nformats].depth = 32;
    nformats++;
    formats[nformats].format = PICT_x8r8g8b8;
    formats[nformats].depth = 32;
    nformats++;
    formats[nformats].format = PICT_b8g8r8a8;
    formats[nformats].depth = 32;
    nformats++;
    formats[nformats].format = PICT_b8g8r8x8;
    formats[nformats].depth = 32;
    nformats++;

    /* now look through the depths and visuals adding other formats */
    for (v = 0; v < pScreen->numVisuals; v++)
    {
	pVisual = &pScreen->visuals[v];
	depth = visualDepth (pScreen, pVisual);
	if (!depth)
	    continue;
    	bpp = BitsPerPixel (depth);
	switch (pVisual->class) {
	case DirectColor:
	case TrueColor:
	    r = Ones (pVisual->redMask);
	    g = Ones (pVisual->greenMask);
	    b = Ones (pVisual->blueMask);
	    type = PICT_TYPE_OTHER;
	    /*
	     * Current rendering code supports only three direct formats,
	     * fields must be packed together at the bottom of the pixel
	     */
	    if (pVisual->offsetBlue == 0 &&
		pVisual->offsetGreen == b &&
		pVisual->offsetRed == b + g)
	    {
		type = PICT_TYPE_ARGB;
	    }
	    else if (pVisual->offsetRed == 0 &&
		     pVisual->offsetGreen == r && 
		     pVisual->offsetBlue == r + g)
	    {
		type = PICT_TYPE_ABGR;
	    }
	    else if (pVisual->offsetRed == pVisual->offsetGreen - r &&
		     pVisual->offsetGreen == pVisual->offsetBlue - g && 
		     pVisual->offsetBlue == bpp - b)
	    {
		type = PICT_TYPE_BGRA;
	    }
	    if (type != PICT_TYPE_OTHER)
	    {
		format = PICT_FORMAT(bpp, type, 0, r, g, b);
		nformats = addFormat (formats, nformats, format, depth);
	    }
	    break;
	case StaticColor:
	case PseudoColor:
	    format = PICT_VISFORMAT (bpp, PICT_TYPE_COLOR, v);
	    nformats = addFormat (formats, nformats, format, depth);
	    break;
	case StaticGray:
	case GrayScale:
	    format = PICT_VISFORMAT (bpp, PICT_TYPE_GRAY, v);
	    nformats = addFormat (formats, nformats, format, depth);
	    break;
	}
    }
    /*
     * Walk supported depths and add useful Direct formats
     */
    for (d = 0; d < pScreen->numDepths; d++)
    {
	pDepth = &pScreen->allowedDepths[d];
	bpp = BitsPerPixel (pDepth->depth);
	format = 0;
	switch (bpp) {
	case 16:
	    /* depth 12 formats */
	    if (pDepth->depth >= 12)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_x4r4g4b4, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x4b4g4r4, pDepth->depth);
	    }
	    /* depth 15 formats */
	    if (pDepth->depth >= 15)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_x1r5g5b5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x1b5g5r5, pDepth->depth);
	    }
	    /* depth 16 formats */
	    if (pDepth->depth >= 16) 
	    {
		nformats = addFormat (formats, nformats,
				      PICT_a1r5g5b5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a1b5g5r5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_r5g6b5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_b5g6r5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a4r4g4b4, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a4b4g4r4, pDepth->depth);
	    }
	    break;
	case 24:
	    if (pDepth->depth >= 24)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_r8g8b8, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_b8g8r8, pDepth->depth);
	    }
	    break;
	case 32:
	    if (pDepth->depth >= 24)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_x8r8g8b8, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x8b8g8r8, pDepth->depth);
	    }
	    if (pDepth->depth >= 30)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_a2r10g10b10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x2r10g10b10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a2b10g10r10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x2b10g10r10, pDepth->depth);
	    }
	    break;
	}
    }
    

    pFormats = calloc(nformats, sizeof (PictFormatRec));
    if (!pFormats)
	return 0;
    for (f = 0; f < nformats; f++)
    {
        pFormats[f].id = FakeClientID (0);
	pFormats[f].depth = formats[f].depth;
	format = formats[f].format;
	pFormats[f].format = format;
	switch (PICT_FORMAT_TYPE(format)) {
	case PICT_TYPE_ARGB:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    if (pFormats[f].direct.alphaMask)
		pFormats[f].direct.alpha = (PICT_FORMAT_R(format) +
					    PICT_FORMAT_G(format) +
					    PICT_FORMAT_B(format));
	    
	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = (PICT_FORMAT_G(format) + 
				      PICT_FORMAT_B(format));
	    
	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = PICT_FORMAT_B(format);
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = 0;
	    break;

	case PICT_TYPE_ABGR:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    if (pFormats[f].direct.alphaMask)
		pFormats[f].direct.alpha = (PICT_FORMAT_B(format) +
					    PICT_FORMAT_G(format) +
					    PICT_FORMAT_R(format));
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = (PICT_FORMAT_G(format) + 
				       PICT_FORMAT_R(format));
	    
	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = PICT_FORMAT_R(format);
	    
	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = 0;
	    break;

	case PICT_TYPE_BGRA:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format));

	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format) -
					PICT_FORMAT_G(format));

	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format) -
				      PICT_FORMAT_G(format) - PICT_FORMAT_R(format));

	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    pFormats[f].direct.alpha = 0;
	    break;

	case PICT_TYPE_A:
	    pFormats[f].type = PictTypeDirect;

	    pFormats[f].direct.alpha = 0;
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));

	    /* remaining fields already set to zero */
	    break;
	    
	case PICT_TYPE_COLOR:
	case PICT_TYPE_GRAY:
	    pFormats[f].type = PictTypeIndexed;
	    pFormats[f].index.vid = pScreen->visuals[PICT_FORMAT_VIS(format)].vid;
	    break;
	}
    }
    *nformatp = nformats;
    return pFormats;
}

static VisualPtr
PictureFindVisual (ScreenPtr pScreen, VisualID visual)
{
    int         i;
    VisualPtr   pVisual;
    for (i = 0, pVisual = pScreen->visuals;
         i < pScreen->numVisuals;
         i++, pVisual++)
    {
        if (pVisual->vid == visual)
            return pVisual;
    }
    return 0;
}

Bool
PictureInitIndexedFormat(ScreenPtr pScreen, PictFormatPtr format)
{
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    if (format->type != PictTypeIndexed || format->index.pColormap)
	return TRUE;

    if (format->index.vid == pScreen->rootVisual) {
	dixLookupResourceByType((pointer *)&format->index.pColormap,
				pScreen->defColormap, RT_COLORMAP,
				serverClient, DixGetAttrAccess);
    } else {
	VisualPtr pVisual = PictureFindVisual(pScreen, format->index.vid);
	if (CreateColormap(FakeClientID (0), pScreen, pVisual,
		    &format->index.pColormap, AllocNone, 0)
		!= Success)
	    return FALSE;
    }
    if (!ps->InitIndexed(pScreen, format))
	return FALSE;
    return TRUE;
}

static Bool
PictureInitIndexedFormats (ScreenPtr pScreen)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;

    if (!ps)
	return FALSE;
    format = ps->formats;
    nformat = ps->nformats;
    while (nformat--)
	if (!PictureInitIndexedFormat(pScreen, format++))
	    return FALSE;
    return TRUE;
}

Bool
PictureFinishInit (void)
{
    int	    s;

    for (s = 0; s < screenInfo.numScreens; s++)
    {
	if (!PictureInitIndexedFormats (screenInfo.screens[s]))
	    return FALSE;
	(void) AnimCurInit (screenInfo.screens[s]);
    }

    return TRUE;
}

Bool
PictureSetSubpixelOrder (ScreenPtr pScreen, int subpixel)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);

    if (!ps)
	return FALSE;
    ps->subpixel = subpixel;
    return TRUE;
    
}

int
PictureGetSubpixelOrder (ScreenPtr pScreen)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);

    if (!ps)
	return SubPixelUnknown;
    return ps->subpixel;
}
    
PictFormatPtr
PictureMatchVisual (ScreenPtr pScreen, int depth, VisualPtr pVisual)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;
    int			type;

    if (!ps)
	return 0;
    format = ps->formats;
    nformat = ps->nformats;
    switch (pVisual->class) {
    case StaticGray:
    case GrayScale:
    case StaticColor:
    case PseudoColor:
	type = PictTypeIndexed;
	break;
    case TrueColor:
    case DirectColor:
	type = PictTypeDirect;
	break;
    default:
	return 0;
    }
    while (nformat--)
    {
	if (format->depth == depth && format->type == type)
	{
	    if (type == PictTypeIndexed)
	    {
		if (format->index.vid == pVisual->vid)
		    return format;
	    }
	    else
	    {
		if (format->direct.redMask << format->direct.red == 
		    pVisual->redMask &&
		    format->direct.greenMask << format->direct.green == 
		    pVisual->greenMask &&
		    format->direct.blueMask << format->direct.blue == 
		    pVisual->blueMask)
		{
		    return format;
		}
	    }
	}
	format++;
    }
    return 0;
}

PictFormatPtr
PictureMatchFormat (ScreenPtr pScreen, int depth, CARD32 f)
{
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;

    if (!ps)
	return 0;
    format = ps->formats;
    nformat = ps->nformats;
    while (nformat--)
    {
	if (format->depth == depth && format->format == (f & 0xffffff))
	    return format;
	format++;
    }
    return 0;
}

int
PictureParseCmapPolicy (const char *name)
{
    if ( strcmp (name, "default" ) == 0)
	return PictureCmapPolicyDefault;
    else if ( strcmp (name, "mono" ) == 0)
	return PictureCmapPolicyMono;
    else if ( strcmp (name, "gray" ) == 0)
	return PictureCmapPolicyGray;
    else if ( strcmp (name, "color" ) == 0)
	return PictureCmapPolicyColor;
    else if ( strcmp (name, "all" ) == 0)
	return PictureCmapPolicyAll;
    else
	return PictureCmapPolicyInvalid;
}

Bool
PictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats)
{
    PictureScreenPtr	ps;
    int			n;
    CARD32		type, a, r, g, b;
    
    if (PictureGeneration != serverGeneration)
    {
	PictureType = CreateNewResourceType (FreePicture, "PICTURE");
	if (!PictureType)
	    return FALSE;
	PictFormatType = CreateNewResourceType (FreePictFormat, "PICTFORMAT");
	if (!PictFormatType)
	    return FALSE;
	GlyphSetType = CreateNewResourceType (FreeGlyphSet, "GLYPHSET");
	if (!GlyphSetType)
	    return FALSE;
	PictureGeneration = serverGeneration;
    }
    if (!dixRegisterPrivateKey(&PictureScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;

    if (!dixRegisterPrivateKey(&PictureWindowPrivateKeyRec, PRIVATE_WINDOW, 0))
	return FALSE;

    if (!formats)
    {
	formats = PictureCreateDefaultFormats (pScreen, &nformats);
	if (!formats)
	    return FALSE;
    }
    for (n = 0; n < nformats; n++)
    {
	if (!AddResource (formats[n].id, PictFormatType, (pointer) (formats+n)))
	{
	    free(formats);
	    return FALSE;
	}
	if (formats[n].type == PictTypeIndexed)
	{
            VisualPtr   pVisual = PictureFindVisual (pScreen, formats[n].index.vid);
	    if ((pVisual->class | DynamicClass) == PseudoColor)
		type = PICT_TYPE_COLOR;
	    else
		type = PICT_TYPE_GRAY;
	    a = r = g = b = 0;
	}
	else
	{
	    if ((formats[n].direct.redMask|
		 formats[n].direct.blueMask|
		 formats[n].direct.greenMask) == 0)
		type = PICT_TYPE_A;
	    else if (formats[n].direct.red > formats[n].direct.blue)
		type = PICT_TYPE_ARGB;
	    else if (formats[n].direct.red == 0)
		type = PICT_TYPE_ABGR;
	    else
		type = PICT_TYPE_BGRA;
	    a = Ones (formats[n].direct.alphaMask);
	    r = Ones (formats[n].direct.redMask);
	    g = Ones (formats[n].direct.greenMask);
	    b = Ones (formats[n].direct.blueMask);
	}
	formats[n].format = PICT_FORMAT(0,type,a,r,g,b);
    }
    ps = (PictureScreenPtr) malloc(sizeof (PictureScreenRec));
    if (!ps)
    {
	free(formats);
	return FALSE;
    }
    SetPictureScreen(pScreen, ps);

    ps->formats = formats;
    ps->fallback = formats;
    ps->nformats = nformats;
    
    ps->filters = 0;
    ps->nfilters = 0;
    ps->filterAliases = 0;
    ps->nfilterAliases = 0;

    ps->subpixel = SubPixelUnknown;

    ps->CloseScreen = pScreen->CloseScreen;
    ps->DestroyWindow = pScreen->DestroyWindow;
    ps->StoreColors = pScreen->StoreColors;
    pScreen->DestroyWindow = PictureDestroyWindow;
    pScreen->CloseScreen = PictureCloseScreen;
    pScreen->StoreColors = PictureStoreColors;

    if (!PictureSetDefaultFilters (pScreen))
    {
	PictureResetFilters (pScreen);
	SetPictureScreen(pScreen, 0);
	free(formats);
	free(ps);
	return FALSE;
    }

    return TRUE;
}

void
SetPictureToDefaults (PicturePtr    pPicture)
{
    pPicture->refcnt = 1;
    pPicture->repeat = 0;
    pPicture->graphicsExposures = FALSE;
    pPicture->subWindowMode = ClipByChildren;
    pPicture->polyEdge = PolyEdgeSharp;
    pPicture->polyMode = PolyModePrecise;
    pPicture->freeCompClip = FALSE;
    pPicture->clientClipType = CT_NONE;
    pPicture->componentAlpha = FALSE;
    pPicture->repeatType = RepeatNone;

    pPicture->alphaMap = 0;
    pPicture->alphaOrigin.x = 0;
    pPicture->alphaOrigin.y = 0;

    pPicture->clipOrigin.x = 0;
    pPicture->clipOrigin.y = 0;
    pPicture->clientClip = 0;

    pPicture->transform = 0;

    pPicture->filter = PictureGetFilterId (FilterNearest, -1, TRUE);
    pPicture->filter_params = 0;
    pPicture->filter_nparams = 0;

    pPicture->serialNumber = GC_CHANGE_SERIAL_BIT;
    pPicture->stateChanges = -1;
    pPicture->pSourcePict = 0;
}

PicturePtr
CreatePicture (Picture		pid,
	       DrawablePtr	pDrawable,
	       PictFormatPtr	pFormat,
	       Mask		vmask,
	       XID		*vlist,
	       ClientPtr	client,
	       int		*error)
{
    PicturePtr		pPicture;
    PictureScreenPtr	ps = GetPictureScreen(pDrawable->pScreen);

    pPicture = dixAllocateObjectWithPrivates(PictureRec, PRIVATE_PICTURE);
    if (!pPicture)
    {
	*error = BadAlloc;
	return 0;
    }

    pPicture->id = pid;
    pPicture->pDrawable = pDrawable;
    pPicture->pFormat = pFormat;
    pPicture->format = pFormat->format | (pDrawable->bitsPerPixel << 24);

    /* security creation/labeling check */
    *error = XaceHook(XACE_RESOURCE_ACCESS, client, pid, PictureType, pPicture,
		      RT_PIXMAP, pDrawable, DixCreateAccess|DixSetAttrAccess);
    if (*error != Success)
	goto out;

    if (pDrawable->type == DRAWABLE_PIXMAP)
    {
	++((PixmapPtr)pDrawable)->refcnt;
	pPicture->pNext = 0;
    }
    else
    {
	pPicture->pNext = GetPictureWindow(((WindowPtr) pDrawable));
	SetPictureWindow(((WindowPtr) pDrawable), pPicture);
    }

    SetPictureToDefaults (pPicture);
    
    if (vmask)
	*error = ChangePicture (pPicture, vmask, vlist, 0, client);
    else
	*error = Success;
    if (*error == Success)
	*error = (*ps->CreatePicture) (pPicture);
out:
    if (*error != Success)
    {
	FreePicture (pPicture, (XID) 0);
	pPicture = 0;
    }
    return pPicture;
}

static CARD32 xRenderColorToCard32(xRenderColor c)
{
    return
        (c.alpha >> 8 << 24) |
        (c.red >> 8 << 16) |
        (c.green & 0xff00) |
        (c.blue >> 8);
}

static void initGradient(SourcePictPtr pGradient, int stopCount,
                         xFixed *stopPoints, xRenderColor *stopColors, int *error)
{
    int i;
    xFixed dpos;

    if (stopCount <= 0) {
        *error = BadValue;
        return;
    }

    dpos = -1;
    for (i = 0; i < stopCount; ++i) {
        if (stopPoints[i] < dpos || stopPoints[i] > (1<<16)) {
            *error = BadValue;
            return;
        }
        dpos = stopPoints[i];
    }

    pGradient->gradient.stops = malloc(stopCount*sizeof(PictGradientStop));
    if (!pGradient->gradient.stops) {
        *error = BadAlloc;
        return;
    }

    pGradient->gradient.nstops = stopCount;

    for (i = 0; i < stopCount; ++i) {
        pGradient->gradient.stops[i].x = stopPoints[i];
        pGradient->gradient.stops[i].color = stopColors[i];
    }
}

static PicturePtr createSourcePicture(void)
{
    PicturePtr pPicture;
    pPicture = dixAllocateObjectWithPrivates(PictureRec, PRIVATE_PICTURE);
    pPicture->pDrawable = 0;
    pPicture->pFormat = 0;
    pPicture->pNext = 0;
    pPicture->format = PICT_a8r8g8b8;

    SetPictureToDefaults(pPicture);
    return pPicture;
}

PicturePtr
CreateSolidPicture (Picture pid, xRenderColor *color, int *error)
{
    PicturePtr pPicture;
    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictSolidFill));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }
    pPicture->pSourcePict->type = SourcePictTypeSolidFill;
    pPicture->pSourcePict->solidFill.color = xRenderColorToCard32(*color);
    return pPicture;
}

PicturePtr
CreateLinearGradientPicture (Picture pid, xPointFixed *p1, xPointFixed *p2,
                             int nStops, xFixed *stops, xRenderColor *colors, int *error)
{
    PicturePtr pPicture;

    if (nStops < 2) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictLinearGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }

    pPicture->pSourcePict->linear.type = SourcePictTypeLinear;
    pPicture->pSourcePict->linear.p1 = *p1;
    pPicture->pSourcePict->linear.p2 = *p2;

    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

PicturePtr
CreateRadialGradientPicture (Picture pid, xPointFixed *inner, xPointFixed *outer,
                             xFixed innerRadius, xFixed outerRadius,
                             int nStops, xFixed *stops, xRenderColor *colors, int *error)
{
    PicturePtr pPicture;
    PictRadialGradient *radial;

    if (nStops < 2) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictRadialGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }
    radial = &pPicture->pSourcePict->radial;

    radial->type = SourcePictTypeRadial;
    radial->c1.x = inner->x;
    radial->c1.y = inner->y;
    radial->c1.radius = innerRadius;
    radial->c2.x = outer->x;
    radial->c2.y = outer->y;
    radial->c2.radius = outerRadius;
    
    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

PicturePtr
CreateConicalGradientPicture (Picture pid, xPointFixed *center, xFixed angle,
                              int nStops, xFixed *stops, xRenderColor *colors, int *error)
{
    PicturePtr pPicture;

    if (nStops < 2) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictConicalGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }

    pPicture->pSourcePict->conical.type = SourcePictTypeConical;
    pPicture->pSourcePict->conical.center = *center;
    pPicture->pSourcePict->conical.angle = angle;

    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

#define NEXT_VAL(_type) (vlist ? (_type) *vlist++ : (_type) ulist++->val)

#define NEXT_PTR(_type) ((_type) ulist++->ptr)

int
ChangePicture (PicturePtr	pPicture,
	       Mask		vmask,
	       XID		*vlist,
	       DevUnion		*ulist,
	       ClientPtr	client)
{
    ScreenPtr pScreen = pPicture->pDrawable ? pPicture->pDrawable->pScreen : 0;
    PictureScreenPtr ps = pScreen ? GetPictureScreen(pScreen) : 0;
    BITS32		index2;
    int			error = 0;
    BITS32		maskQ;
    
    pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    maskQ = vmask;
    while (vmask && !error)
    {
	index2 = (BITS32) lowbit (vmask);
	vmask &= ~index2;
	pPicture->stateChanges |= index2;
	switch (index2)
	{
	case CPRepeat:
	    {
		unsigned int	newr;
		newr = NEXT_VAL(unsigned int);
		if (newr <= RepeatReflect)
		{
		    pPicture->repeat = (newr != RepeatNone);
		    pPicture->repeatType = newr;
		}
		else
		{
		    client->errorValue = newr;
		    error = BadValue;
		}
	    }
	    break;
	case CPAlphaMap:
	    {
		PicturePtr  pAlpha;
		
		if (vlist)
		{
		    Picture	pid = NEXT_VAL(Picture);

		    if (pid == None)
			pAlpha = 0;
		    else
		    {
			error = dixLookupResourceByType((pointer *)&pAlpha, pid,
						  PictureType, client,
						  DixReadAccess);
			if (error != Success)
			{
			    client->errorValue = pid;
			    break;
			}
			if (pAlpha->pDrawable == NULL ||
			    pAlpha->pDrawable->type != DRAWABLE_PIXMAP)
			{
			    client->errorValue = pid;
			    error = BadMatch;
			    break;
			}
		    }
		}
		else
		    pAlpha = NEXT_PTR(PicturePtr);
		if (!error)
		{
		    if (pAlpha && pAlpha->pDrawable->type == DRAWABLE_PIXMAP)
			pAlpha->refcnt++;
		    if (pPicture->alphaMap)
			FreePicture ((pointer) pPicture->alphaMap, (XID) 0);
		    pPicture->alphaMap = pAlpha;
		}
	    }
	    break;
	case CPAlphaXOrigin:
	    pPicture->alphaOrigin.x = NEXT_VAL(INT16);
	    break;
	case CPAlphaYOrigin:
	    pPicture->alphaOrigin.y = NEXT_VAL(INT16);
	    break;
	case CPClipXOrigin:
	    pPicture->clipOrigin.x = NEXT_VAL(INT16);
	    break;
	case CPClipYOrigin:
	    pPicture->clipOrigin.y = NEXT_VAL(INT16);
	    break;
	case CPClipMask:
	    {
		Pixmap	    pid;
		PixmapPtr   pPixmap;
		int	    clipType;
                if (!pScreen)
                    return BadDrawable;

		if (vlist)
		{
		    pid = NEXT_VAL(Pixmap);
		    if (pid == None)
		    {
			clipType = CT_NONE;
			pPixmap = NullPixmap;
		    }
		    else
		    {
			clipType = CT_PIXMAP;
			error = dixLookupResourceByType((pointer *)&pPixmap, pid,
						  RT_PIXMAP, client,
						  DixReadAccess);
			if (error != Success)
			{
			    client->errorValue = pid;
			    break;
			}
		    }
		}
		else
		{
		    pPixmap = NEXT_PTR(PixmapPtr);
		    if (pPixmap)
			clipType = CT_PIXMAP;
		    else
			clipType = CT_NONE;
		}

		if (pPixmap)
		{
		    if ((pPixmap->drawable.depth != 1) ||
			(pPixmap->drawable.pScreen != pScreen))
		    {
			error = BadMatch;
			break;
		    }
		    else
		    {
			clipType = CT_PIXMAP;
			pPixmap->refcnt++;
		    }
		}
		error = (*ps->ChangePictureClip)(pPicture, clipType,
						 (pointer)pPixmap, 0);
		break;
	    }
	case CPGraphicsExposure:
	    {
		unsigned int	newe;
		newe = NEXT_VAL(unsigned int);
		if (newe <= xTrue)
		    pPicture->graphicsExposures = newe;
		else
		{
		    client->errorValue = newe;
		    error = BadValue;
		}
	    }
	    break;
	case CPSubwindowMode:
	    {
		unsigned int	news;
		news = NEXT_VAL(unsigned int);
		if (news == ClipByChildren || news == IncludeInferiors)
		    pPicture->subWindowMode = news;
		else
		{
		    client->errorValue = news;
		    error = BadValue;
		}
	    }
	    break;
	case CPPolyEdge:
	    {
		unsigned int	newe;
		newe = NEXT_VAL(unsigned int);
		if (newe == PolyEdgeSharp || newe == PolyEdgeSmooth)
		    pPicture->polyEdge = newe;
		else
		{
		    client->errorValue = newe;
		    error = BadValue;
		}
	    }
	    break;
	case CPPolyMode:
	    {
		unsigned int	newm;
		newm = NEXT_VAL(unsigned int);
		if (newm == PolyModePrecise || newm == PolyModeImprecise)
		    pPicture->polyMode = newm;
		else
		{
		    client->errorValue = newm;
		    error = BadValue;
		}
	    }
	    break;
	case CPDither:
	    (void) NEXT_VAL(Atom); /* unimplemented */
	    break;
	case CPComponentAlpha:
	    {
		unsigned int	newca;

		newca = NEXT_VAL (unsigned int);
		if (newca <= xTrue)
		    pPicture->componentAlpha = newca;
		else
		{
		    client->errorValue = newca;
		    error = BadValue;
		}
	    }
	    break;
	default:
	    client->errorValue = maskQ;
	    error = BadValue;
	    break;
	}
    }
    if (ps)
        (*ps->ChangePicture) (pPicture, maskQ);
    return error;
}

int
SetPictureClipRects (PicturePtr	pPicture,
		     int	xOrigin,
		     int	yOrigin,
		     int	nRect,
		     xRectangle	*rects)
{
    ScreenPtr		pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
    RegionPtr		clientClip;
    int			result;

    clientClip = RegionFromRects(nRect, rects, CT_UNSORTED);
    if (!clientClip)
	return BadAlloc;
    result =(*ps->ChangePictureClip) (pPicture, CT_REGION, 
				      (pointer) clientClip, 0);
    if (result == Success)
    {
	pPicture->clipOrigin.x = xOrigin;
	pPicture->clipOrigin.y = yOrigin;
	pPicture->stateChanges |= CPClipXOrigin|CPClipYOrigin|CPClipMask;
	pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    }
    return result;
}

int
SetPictureClipRegion (PicturePtr    pPicture,
                      int           xOrigin,
                      int           yOrigin,
                      RegionPtr     pRegion)
{
    ScreenPtr           pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    RegionPtr           clientClip;
    int                 result;
    int                 type;

    if (pRegion)
    {
        type = CT_REGION;
        clientClip = RegionCreate(RegionExtents(pRegion),
                                  RegionNumRects(pRegion));
        if (!clientClip)
            return BadAlloc;
        if (!RegionCopy(clientClip, pRegion))
        {
            RegionDestroy(clientClip);
            return BadAlloc;
        }
    }
    else
    {
        type = CT_NONE;
        clientClip = 0;
    }

    result =(*ps->ChangePictureClip) (pPicture, type,
                                      (pointer) clientClip, 0);
    if (result == Success)
    {
        pPicture->clipOrigin.x = xOrigin;
        pPicture->clipOrigin.y = yOrigin;
        pPicture->stateChanges |= CPClipXOrigin|CPClipYOrigin|CPClipMask;
        pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    }
    return result;
}

static Bool
transformIsIdentity(PictTransform *t)
{
    return ((t->matrix[0][0] == t->matrix[1][1]) &&
            (t->matrix[0][0] == t->matrix[2][2]) &&
            (t->matrix[0][0] != 0) &&
            (t->matrix[0][1] == 0) &&
            (t->matrix[0][2] == 0) &&
            (t->matrix[1][0] == 0) &&
            (t->matrix[1][2] == 0) &&
            (t->matrix[2][0] == 0) &&
            (t->matrix[2][1] == 0));
}

int
SetPictureTransform (PicturePtr	    pPicture,
		     PictTransform  *transform)
{
    if (transform && transformIsIdentity (transform))
	transform = 0;
    
    if (transform)
    {
	if (!pPicture->transform)
	{
	    pPicture->transform = (PictTransform *) malloc(sizeof (PictTransform));
	    if (!pPicture->transform)
		return BadAlloc;
	}
	*pPicture->transform = *transform;
    }
    else
    {
	free(pPicture->transform);
	pPicture->transform = NULL;
    }
    pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;

    if (pPicture->pDrawable != NULL) {
	int result;
	PictureScreenPtr ps = GetPictureScreen(pPicture->pDrawable->pScreen);

	result = (*ps->ChangePictureTransform) (pPicture, transform);

	return result;
    }

    return Success;
}

void
CopyPicture (PicturePtr	pSrc,
	     Mask	mask,
	     PicturePtr	pDst)
{
    PictureScreenPtr ps = GetPictureScreen(pSrc->pDrawable->pScreen);
    Mask origMask = mask;

    pDst->serialNumber |= GC_CHANGE_SERIAL_BIT;
    pDst->stateChanges |= mask;

    while (mask) {
	Mask bit = lowbit(mask);

	switch (bit)
	{
	case CPRepeat:
	    pDst->repeat = pSrc->repeat;
	    pDst->repeatType = pSrc->repeatType;
	    break;
	case CPAlphaMap:
	    if (pSrc->alphaMap && pSrc->alphaMap->pDrawable->type == DRAWABLE_PIXMAP)
		pSrc->alphaMap->refcnt++;
	    if (pDst->alphaMap)
		FreePicture ((pointer) pDst->alphaMap, (XID) 0);
	    pDst->alphaMap = pSrc->alphaMap;
	    break;
	case CPAlphaXOrigin:
	    pDst->alphaOrigin.x = pSrc->alphaOrigin.x;
	    break;
	case CPAlphaYOrigin:
	    pDst->alphaOrigin.y = pSrc->alphaOrigin.y;
	    break;
	case CPClipXOrigin:
	    pDst->clipOrigin.x = pSrc->clipOrigin.x;
	    break;
	case CPClipYOrigin:
	    pDst->clipOrigin.y = pSrc->clipOrigin.y;
	    break;
	case CPClipMask:
	    switch (pSrc->clientClipType) {
	    case CT_NONE:
		(*ps->ChangePictureClip)(pDst, CT_NONE, NULL, 0);
		break;
	    case CT_REGION:
		if (!pSrc->clientClip) {
		    (*ps->ChangePictureClip)(pDst, CT_NONE, NULL, 0);
		} else {
		    RegionPtr clientClip;
		    RegionPtr srcClientClip = (RegionPtr)pSrc->clientClip;

		    clientClip = RegionCreate(
			RegionExtents(srcClientClip),
			RegionNumRects(srcClientClip));
		    (*ps->ChangePictureClip)(pDst, CT_REGION, clientClip, 0);
		}
		break;
	    default:
		/* XXX: CT_PIXMAP unimplemented */
		break;
	    }
	    break;
	case CPGraphicsExposure:
	    pDst->graphicsExposures = pSrc->graphicsExposures;
	    break;
	case CPPolyEdge:
	    pDst->polyEdge = pSrc->polyEdge;
	    break;
	case CPPolyMode:
	    pDst->polyMode = pSrc->polyMode;
	    break;
	case CPDither:
	    break;
	case CPComponentAlpha:
	    pDst->componentAlpha = pSrc->componentAlpha;
	    break;
	}
	mask &= ~bit;
    }

    (*ps->ChangePicture)(pDst, origMask);
}

static void
ValidateOnePicture (PicturePtr pPicture)
{
    if (pPicture->pDrawable && pPicture->serialNumber != pPicture->pDrawable->serialNumber)
    {
	PictureScreenPtr    ps = GetPictureScreen(pPicture->pDrawable->pScreen);

	(*ps->ValidatePicture) (pPicture, pPicture->stateChanges);
	pPicture->stateChanges = 0;
	pPicture->serialNumber = pPicture->pDrawable->serialNumber;
    }
}

void
ValidatePicture(PicturePtr pPicture)
{
    ValidateOnePicture (pPicture);
    if (pPicture->alphaMap)
	ValidateOnePicture (pPicture->alphaMap);
}

int
FreePicture (pointer	value,
	     XID	pid)
{
    PicturePtr	pPicture = (PicturePtr) value;

    if (--pPicture->refcnt == 0)
    {
	free(pPicture->transform);

	if (pPicture->pSourcePict)
	{
	    if (pPicture->pSourcePict->type != SourcePictTypeSolidFill)
		free(pPicture->pSourcePict->linear.stops);

	    free(pPicture->pSourcePict);
	}

	if (pPicture->pDrawable)
	{
            ScreenPtr	    pScreen = pPicture->pDrawable->pScreen;
            PictureScreenPtr    ps = GetPictureScreen(pScreen);
	
            if (pPicture->alphaMap)
                FreePicture ((pointer) pPicture->alphaMap, (XID) 0);
            (*ps->DestroyPicture) (pPicture);
            (*ps->DestroyPictureClip) (pPicture);
            if (pPicture->pDrawable->type == DRAWABLE_WINDOW)
            {
                WindowPtr	pWindow = (WindowPtr) pPicture->pDrawable;
                PicturePtr	*pPrev;

                for (pPrev = (PicturePtr *)dixLookupPrivateAddr
			 (&pWindow->devPrivates, PictureWindowPrivateKey);
                     *pPrev;
                     pPrev = &(*pPrev)->pNext)
                {
                    if (*pPrev == pPicture)
                    {
                        *pPrev = pPicture->pNext;
                        break;
                    }
                }
            }
            else if (pPicture->pDrawable->type == DRAWABLE_PIXMAP)
            {
                (*pScreen->DestroyPixmap) ((PixmapPtr)pPicture->pDrawable);
            }
        }
	dixFreeObjectWithPrivates(pPicture, PRIVATE_PICTURE);
    }
    return Success;
}

int
FreePictFormat (pointer	pPictFormat,
		XID     pid)
{
    return Success;
}

/**
 * ReduceCompositeOp is used to choose simpler ops for cases where alpha
 * channels are always one and so math on the alpha channel per pixel becomes
 * unnecessary.  It may also avoid destination reads sometimes if apps aren't
 * being careful to avoid these cases.
 */
static CARD8
ReduceCompositeOp (CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
		   INT16 xSrc, INT16 ySrc, CARD16 width, CARD16 height)
{
    Bool no_src_alpha, no_dst_alpha;

    /* Sampling off the edge of a RepeatNone picture introduces alpha
     * even if the picture itself doesn't have alpha. We don't try to
     * detect every case where we don't sample off the edge, just the
     * simplest case where there is no transform on the source
     * picture.
     */
    no_src_alpha = PICT_FORMAT_COLOR(pSrc->format) &&
                   PICT_FORMAT_A(pSrc->format) == 0 &&
                   (pSrc->repeatType != RepeatNone ||
		    (!pSrc->transform &&
		     xSrc >= 0 && ySrc >= 0 &&
		     xSrc + width <= pSrc->pDrawable->width &&
		     ySrc + height <= pSrc->pDrawable->height)) &&
                   pSrc->alphaMap == NULL &&
                   pMask == NULL;
    no_dst_alpha = PICT_FORMAT_COLOR(pDst->format) &&
                   PICT_FORMAT_A(pDst->format) == 0 &&
                   pDst->alphaMap == NULL;

    /* TODO, maybe: Conjoint and Disjoint op reductions? */
 
    /* Deal with simplifications where the source alpha is always 1. */
    if (no_src_alpha)
    {
	switch (op) {
	case PictOpOver:
	    op = PictOpSrc;
	    break;
	case PictOpInReverse:
	    op = PictOpDst;
	    break;
	case PictOpOutReverse:
	    op = PictOpClear;
	    break;
	case PictOpAtop:
	    op = PictOpIn;
	    break;
	case PictOpAtopReverse:
	    op = PictOpOverReverse;
	    break;
	case PictOpXor:
	    op = PictOpOut;
	    break;
	default:
	    break;
	}
    }

    /* Deal with simplifications when the destination alpha is always 1 */
    if (no_dst_alpha)
    {
	switch (op) {
	case PictOpOverReverse:
	    op = PictOpDst;
	    break;
	case PictOpIn:
	    op = PictOpSrc;
	    break;
	case PictOpOut:
	    op = PictOpClear;
	    break;
	case PictOpAtop:
	    op = PictOpOver;
	    break;
	case PictOpXor:
	    op = PictOpOutReverse;
	    break;
	default:
	    break;
	}
    }

    /* Reduce some con/disjoint ops to the basic names. */
    switch (op) {
    case PictOpDisjointClear:
    case PictOpConjointClear:
	op = PictOpClear;
	break;
    case PictOpDisjointSrc:
    case PictOpConjointSrc:
	op = PictOpSrc;
	break;
    case PictOpDisjointDst:
    case PictOpConjointDst:
	op = PictOpDst;
	break;
    default:
	break;
    }

    return op;
}

void
CompositePicture (CARD8		op,
		  PicturePtr	pSrc,
		  PicturePtr	pMask,
		  PicturePtr	pDst,
		  INT16		xSrc,
		  INT16		ySrc,
		  INT16		xMask,
		  INT16		yMask,
		  INT16		xDst,
		  INT16		yDst,
		  CARD16	width,
		  CARD16	height)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    if (pMask)
	ValidatePicture (pMask);
    ValidatePicture (pDst);

    op = ReduceCompositeOp (op, pSrc, pMask, pDst, xSrc, ySrc, width, height);
    if (op == PictOpDst)
	return;

    (*ps->Composite) (op,
		       pSrc,
		       pMask,
		       pDst,
		       xSrc,
		       ySrc,
		       xMask,
		       yMask,
		       xDst,
		       yDst,
		       width,
		       height);
}

void
CompositeRects (CARD8		op,
		PicturePtr	pDst,
		xRenderColor	*color,
		int		nRect,
		xRectangle      *rects)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pDst);
    (*ps->CompositeRects) (op, pDst, color, nRect, rects);
}

void
CompositeTrapezoids (CARD8	    op,
		     PicturePtr	    pSrc,
		     PicturePtr	    pDst,
		     PictFormatPtr  maskFormat,
		     INT16	    xSrc,
		     INT16	    ySrc,
		     int	    ntrap,
		     xTrapezoid	    *traps)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->Trapezoids) (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntrap, traps);
}

void
CompositeTriangles (CARD8	    op,
		    PicturePtr	    pSrc,
		    PicturePtr	    pDst,
		    PictFormatPtr   maskFormat,
		    INT16	    xSrc,
		    INT16	    ySrc,
		    int		    ntriangles,
		    xTriangle	    *triangles)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->Triangles) (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntriangles, triangles);
}

void
CompositeTriStrip (CARD8	    op,
		   PicturePtr	    pSrc,
		   PicturePtr	    pDst,
		   PictFormatPtr    maskFormat,
		   INT16	    xSrc,
		   INT16	    ySrc,
		   int		    npoints,
		   xPointFixed	    *points)
{
    xTriangle           *tris, *tri;
    int                 ntri;
    
    if (npoints < 3)
        return;
    ntri = npoints - 2;
    tris = malloc(ntri * sizeof (xTriangle));
    if (!tris)
        return;
    for (tri = tris; npoints >= 3; npoints--, points++, tri++)
    {
        tri->p1 = points[0];
        tri->p2 = points[1];
        tri->p3 = points[2];
    }
    CompositeTriangles (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, tris);
    free(tris);
}

void
CompositeTriFan (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		npoints,
		 xPointFixed	*points)
{
    xTriangle		*tris, *tri;
    xPointFixed		*first;
    int			ntri;
    
    if (npoints < 3)
	return;
    ntri = npoints - 2;
    tris = malloc(ntri * sizeof (xTriangle));
    if (!tris)
	return;
    first = points++;
    for (tri = tris; npoints >= 3; npoints--, points++, tri++)
    {
	tri->p1 = *first;
	tri->p2 = points[0];
	tri->p3 = points[1];
    }
    CompositeTriangles (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, tris);
    free(tris);
}

void
AddTraps (PicturePtr	pPicture,
	  INT16		xOff,
	  INT16		yOff,
	  int		ntrap,
	  xTrap		*traps)
{
    PictureScreenPtr	ps = GetPictureScreen(pPicture->pDrawable->pScreen);
    
    ValidatePicture (pPicture);
    (*ps->AddTraps) (pPicture, xOff, yOff, ntrap, traps);
}

/*
 *
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifndef _PICTURE_H_
#define _PICTURE_H_

#include "privates.h"

#include <pixman.h>

typedef struct _DirectFormat	*DirectFormatPtr;
typedef struct _PictFormat	*PictFormatPtr;
typedef struct _Picture		*PicturePtr;

/*
 * While the protocol is generous in format support, the
 * sample implementation allows only packed RGB and GBR
 * representations for data to simplify software rendering,
 */
#define PICT_FORMAT(bpp,type,a,r,g,b)	PIXMAN_FORMAT(bpp, type, a, r, g, b)

/*
 * gray/color formats use a visual index instead of argb
 */
#define PICT_VISFORMAT(bpp,type,vi)	(((bpp) << 24) |  \
					 ((type) << 16) | \
					 ((vi)))

#define PICT_FORMAT_BPP(f)	PIXMAN_FORMAT_BPP(f)
#define PICT_FORMAT_TYPE(f)	PIXMAN_FORMAT_TYPE(f)
#define PICT_FORMAT_A(f)	PIXMAN_FORMAT_A(f)
#define PICT_FORMAT_R(f)	PIXMAN_FORMAT_R(f)
#define PICT_FORMAT_G(f)	PIXMAN_FORMAT_G(f)
#define PICT_FORMAT_B(f)	PIXMAN_FORMAT_B(f)
#define PICT_FORMAT_RGB(f)	PIXMAN_FORMAT_RGB(f)
#define PICT_FORMAT_VIS(f)	PIXMAN_FORMAT_VIS(f)

#define PICT_TYPE_OTHER		PIXMAN_TYPE_OTHER
#define PICT_TYPE_A		PIXMAN_TYPE_A
#define PICT_TYPE_ARGB		PIXMAN_TYPE_ARGB
#define PICT_TYPE_ABGR		PIXMAN_TYPE_ABGR
#define PICT_TYPE_COLOR		PIXMAN_TYPE_COLOR
#define PICT_TYPE_GRAY		PIXMAN_TYPE_GRAY
#define PICT_TYPE_BGRA		PIXMAN_TYPE_BGRA

#define PICT_FORMAT_COLOR(f)	PIXMAN_FORMAT_COLOR(f)

/* 32bpp formats */
typedef enum _PictFormatShort {
    PICT_a2r10g10b10 =	PIXMAN_a2r10g10b10,
    PICT_x2r10g10b10 =	PIXMAN_x2r10g10b10,
    PICT_a2b10g10r10 =	PIXMAN_a2b10g10r10,
    PICT_x2b10g10r10 =	PIXMAN_x2b10g10r10,

    PICT_a8r8g8b8 =	PIXMAN_a8r8g8b8,
    PICT_x8r8g8b8 =	PIXMAN_x8r8g8b8,
    PICT_a8b8g8r8 =	PIXMAN_a8b8g8r8,
    PICT_x8b8g8r8 =	PIXMAN_x8b8g8r8,
    PICT_b8g8r8a8 =	PIXMAN_b8g8r8a8,
    PICT_b8g8r8x8 =	PIXMAN_b8g8r8x8,

/* 24bpp formats */
    PICT_r8g8b8 =	PIXMAN_r8g8b8,
    PICT_b8g8r8 =	PIXMAN_b8g8r8,

/* 16bpp formats */
    PICT_r5g6b5 =	PIXMAN_r5g6b5,
    PICT_b5g6r5 =	PIXMAN_b5g6r5,

    PICT_a1r5g5b5 =	PIXMAN_a1r5g5b5,
    PICT_x1r5g5b5 =	PIXMAN_x1r5g5b5,
    PICT_a1b5g5r5 =	PIXMAN_a1b5g5r5,
    PICT_x1b5g5r5 =	PIXMAN_x1b5g5r5,
    PICT_a4r4g4b4 =	PIXMAN_a4r4g4b4,
    PICT_x4r4g4b4 =	PIXMAN_x4r4g4b4,
    PICT_a4b4g4r4 =	PIXMAN_a4b4g4r4,
    PICT_x4b4g4r4 =	PIXMAN_x4b4g4r4,

/* 8bpp formats */
    PICT_a8 =		PIXMAN_a8,
    PICT_r3g3b2 =	PIXMAN_r3g3b2,
    PICT_b2g3r3 =	PIXMAN_b2g3r3,
    PICT_a2r2g2b2 =	PIXMAN_a2r2g2b2,
    PICT_a2b2g2r2 =	PIXMAN_a2b2g2r2,

    PICT_c8 =		PIXMAN_c8,
    PICT_g8 =		PIXMAN_g8,

    PICT_x4a4 =		PIXMAN_x4a4,
				    
    PICT_x4c4 =		PIXMAN_x4c4,
    PICT_x4g4 =		PIXMAN_x4g4,

/* 4bpp formats */
    PICT_a4 =		PIXMAN_a4,
    PICT_r1g2b1 =	PIXMAN_r1g2b1,
    PICT_b1g2r1 =	PIXMAN_b1g2r1,
    PICT_a1r1g1b1 =	PIXMAN_a1r1g1b1,
    PICT_a1b1g1r1 =	PIXMAN_a1b1g1r1,
				    
    PICT_c4 =		PIXMAN_c4,
    PICT_g4 =		PIXMAN_g4,

/* 1bpp formats */
    PICT_a1 =		PIXMAN_a1,

    PICT_g1 =		PIXMAN_g1
} PictFormatShort;

/*
 * For dynamic indexed visuals (GrayScale and PseudoColor), these control the 
 * selection of colors allocated for drawing to Pictures.  The default
 * policy depends on the size of the colormap:
 *
 * Size		Default Policy
 * ----------------------------
 *  < 64	PolicyMono
 *  < 256	PolicyGray
 *  256		PolicyColor (only on PseudoColor)
 *
 * The actual allocation code lives in miindex.c, and so is
 * austensibly server dependent, but that code does:
 *
 * PolicyMono	    Allocate no additional colors, use black and white
 * PolicyGray	    Allocate 13 gray levels (11 cells used)
 * PolicyColor	    Allocate a 4x4x4 cube and 13 gray levels (71 cells used)
 * PolicyAll	    Allocate as big a cube as possible, fill with gray (all)
 *
 * Here's a picture to help understand how many colors are
 * actually allocated (this is just the gray ramp):
 *
 *                 gray level
 * all   0000 1555 2aaa 4000 5555 6aaa 8000 9555 aaaa bfff d555 eaaa ffff
 * b/w   0000                                                        ffff
 * 4x4x4                     5555                aaaa
 * extra      1555 2aaa 4000      6aaa 8000 9555      bfff d555 eaaa
 *
 * The default colormap supplies two gray levels (black/white), the
 * 4x4x4 cube allocates another two and nine more are allocated to fill
 * in the 13 levels.  When the 4x4x4 cube is not allocated, a total of
 * 11 cells are allocated.
 */   

#define PictureCmapPolicyInvalid    -1
#define PictureCmapPolicyDefault    0
#define PictureCmapPolicyMono	    1
#define PictureCmapPolicyGray	    2
#define PictureCmapPolicyColor	    3
#define PictureCmapPolicyAll	    4

extern _X_EXPORT int PictureCmapPolicy;

extern _X_EXPORT int PictureParseCmapPolicy (const char *name);

extern _X_EXPORT int RenderErrBase;

/* Fixed point updates from Carl Worth, USC, Information Sciences Institute */

typedef pixman_fixed_32_32_t	xFixed_32_32;

typedef pixman_fixed_48_16_t	xFixed_48_16;

#define MAX_FIXED_48_16		pixman_max_fixed_48_16
#define MIN_FIXED_48_16		pixman_min_fixed_48_16

typedef pixman_fixed_1_31_t	xFixed_1_31;
typedef pixman_fixed_1_16_t	xFixed_1_16;
typedef pixman_fixed_16_16_t	xFixed_16_16;

/*
 * An unadorned "xFixed" is the same as xFixed_16_16, 
 * (since it's quite common in the code) 
 */
typedef	pixman_fixed_t	xFixed;
#define XFIXED_BITS	16

#define xFixedToInt(f)	pixman_fixed_to_int(f)
#define IntToxFixed(i)	pixman_int_to_fixed(i)
#define xFixedE		pixman_fixed_e
#define xFixed1		pixman_fixed_1
#define xFixed1MinusE	pixman_fixed_1_minus_e
#define xFixedFrac(f)	pixman_fixed_frac(f)
#define xFixedFloor(f)	pixman_fixed_floor(f)
#define xFixedCeil(f)	pixman_fixed_ceil(f)

#define xFixedFraction(f)	pixman_fixed_fraction(f)
#define xFixedMod2(f)		pixman_fixed_mod2(f)

/* whether 't' is a well defined not obviously empty trapezoid */
#define xTrapezoidValid(t)  ((t)->left.p1.y != (t)->left.p2.y && \
			     (t)->right.p1.y != (t)->right.p2.y && \
			     (int) ((t)->bottom - (t)->top) > 0)

/*
 * Standard NTSC luminance conversions:
 *
 *  y = r * 0.299 + g * 0.587 + b * 0.114
 *
 * Approximate this for a bit more speed:
 *
 *  y = (r * 153 + g * 301 + b * 58) / 512
 *
 * This gives 17 bits of luminance; to get 15 bits, lop the low two
 */

#define CvtR8G8B8toY15(s)	(((((s) >> 16) & 0xff) * 153 + \
				  (((s) >>  8) & 0xff) * 301 + \
				  (((s)      ) & 0xff) * 58) >> 2)

#endif /* _PICTURE_H_ */
/*
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifndef _PICTURESTR_H_
#define _PICTURESTR_H_

#include "scrnintstr.h"
#include "glyphstr.h"
#include "resource.h"
#include "privates.h"

typedef struct _DirectFormat {
    CARD16	    red, redMask;
    CARD16	    green, greenMask;
    CARD16	    blue, blueMask;
    CARD16	    alpha, alphaMask;
} DirectFormatRec;

typedef struct _IndexFormat {
    VisualID	    vid;
    ColormapPtr	    pColormap;
    int		    nvalues;
    xIndexValue	    *pValues;
    void	    *devPrivate;
} IndexFormatRec;

typedef struct _PictFormat {
    CARD32	    id;
    CARD32	    format;	    /* except bpp */
    unsigned char   type;
    unsigned char   depth;
    DirectFormatRec direct;
    IndexFormatRec  index;
} PictFormatRec;

typedef struct pixman_vector PictVector, *PictVectorPtr;
typedef struct pixman_transform PictTransform, *PictTransformPtr;

#define pict_f_vector pixman_f_vector
#define pict_f_transform pixman_f_transform

#define PICT_GRADIENT_STOPTABLE_SIZE 1024
#define SourcePictTypeSolidFill 0
#define SourcePictTypeLinear 1
#define SourcePictTypeRadial 2
#define SourcePictTypeConical 3

typedef struct _PictSolidFill {
    unsigned int type;
    CARD32 color;
} PictSolidFill, *PictSolidFillPtr;

typedef struct _PictGradientStop {
    xFixed x;
    xRenderColor color;
} PictGradientStop, *PictGradientStopPtr;

typedef struct _PictGradient {
    unsigned int type;
    int nstops;
    PictGradientStopPtr stops;
} PictGradient, *PictGradientPtr;

typedef struct _PictLinearGradient {
    unsigned int type;
    int nstops;
    PictGradientStopPtr stops;
    xPointFixed p1;
    xPointFixed p2;
} PictLinearGradient, *PictLinearGradientPtr;

typedef struct _PictCircle {
    xFixed x;
    xFixed y;
    xFixed radius;
} PictCircle, *PictCirclePtr;

typedef struct _PictRadialGradient {
    unsigned int type;
    int nstops;
    PictGradientStopPtr stops;
    PictCircle c1;
    PictCircle c2;
} PictRadialGradient, *PictRadialGradientPtr;

typedef struct _PictConicalGradient {
    unsigned int type;
    int nstops;
    PictGradientStopPtr stops;
    xPointFixed center;
    xFixed angle;
} PictConicalGradient, *PictConicalGradientPtr;

typedef union _SourcePict {
    unsigned int type;
    PictSolidFill solidFill;
    PictGradient gradient;
    PictLinearGradient linear;
    PictRadialGradient radial;
    PictConicalGradient conical;
} SourcePict, *SourcePictPtr;

typedef struct _Picture {
    DrawablePtr	    pDrawable;
    PictFormatPtr   pFormat;
    PictFormatShort format;	    /* PICT_FORMAT */
    int		    refcnt;
    CARD32	    id;
    unsigned int    repeat : 1;
    unsigned int    graphicsExposures : 1;
    unsigned int    subWindowMode : 1;
    unsigned int    polyEdge : 1;
    unsigned int    polyMode : 1;
    unsigned int    freeCompClip : 1;
    unsigned int    clientClipType : 2;
    unsigned int    componentAlpha : 1;
    unsigned int    repeatType : 2;
    unsigned int    filter : 3;
    unsigned int    stateChanges : CPLastBit;
    unsigned int    unused : 18 - CPLastBit;

    PicturePtr	    pNext;	    /* chain on same drawable */

    PicturePtr	    alphaMap;
    DDXPointRec	    alphaOrigin;

    DDXPointRec	    clipOrigin;
    pointer	    clientClip;

    unsigned long   serialNumber;

    RegionPtr	    pCompositeClip;

    PrivateRec	    *devPrivates;

    PictTransform   *transform;

    SourcePictPtr   pSourcePict;
    xFixed	    *filter_params;
    int		    filter_nparams;
} PictureRec;

typedef Bool (*PictFilterValidateParamsProcPtr) (ScreenPtr pScreen, int id,
						 xFixed *params, int nparams,
						 int *width, int *height);
typedef struct {
    char			    *name;
    int				    id;
    PictFilterValidateParamsProcPtr ValidateParams;
    int				    width, height;
} PictFilterRec, *PictFilterPtr;

#define PictFilterNearest	0
#define PictFilterBilinear	1

#define PictFilterFast		2
#define PictFilterGood		3
#define PictFilterBest		4

#define PictFilterConvolution	5
/* if you add an 8th filter, expand the filter bitfield above */

typedef struct {
    char	    *alias;
    int		    alias_id;
    int		    filter_id;
} PictFilterAliasRec, *PictFilterAliasPtr;

typedef int	(*CreatePictureProcPtr)	    (PicturePtr pPicture);
typedef void	(*DestroyPictureProcPtr)    (PicturePtr pPicture);
typedef int	(*ChangePictureClipProcPtr) (PicturePtr	pPicture,
					     int	clipType,
					     pointer    value,
					     int	n);
typedef void	(*DestroyPictureClipProcPtr)(PicturePtr	pPicture);

typedef int	(*ChangePictureTransformProcPtr)    (PicturePtr	    pPicture,
						     PictTransform  *transform);

typedef int	(*ChangePictureFilterProcPtr)	(PicturePtr	pPicture,
						 int		filter,
						 xFixed		*params,
						 int		nparams);

typedef void	(*DestroyPictureFilterProcPtr)	(PicturePtr pPicture);

typedef void	(*ChangePictureProcPtr)	    (PicturePtr pPicture,
					     Mask	mask);
typedef void	(*ValidatePictureProcPtr)    (PicturePtr pPicture,
					     Mask       mask);
typedef void	(*CompositeProcPtr)	    (CARD8	op,
					     PicturePtr pSrc,
					     PicturePtr pMask,
					     PicturePtr pDst,
					     INT16	xSrc,
					     INT16	ySrc,
					     INT16	xMask,
					     INT16	yMask,
					     INT16	xDst,
					     INT16	yDst,
					     CARD16	width,
					     CARD16	height);

typedef void	(*GlyphsProcPtr)	    (CARD8      op,
					     PicturePtr pSrc,
					     PicturePtr pDst,
					     PictFormatPtr  maskFormat,
					     INT16      xSrc,
					     INT16      ySrc,
					     int	nlists,
					     GlyphListPtr   lists,
					     GlyphPtr	*glyphs);

typedef void	(*CompositeRectsProcPtr)    (CARD8	    op,
					     PicturePtr	    pDst,
					     xRenderColor   *color,
					     int	    nRect,
					     xRectangle	    *rects);

typedef void	(*RasterizeTrapezoidProcPtr)(PicturePtr	    pMask,
					     xTrapezoid	    *trap,
					     int	    x_off,
					     int	    y_off);

typedef void	(*TrapezoidsProcPtr)	    (CARD8	    op,
					     PicturePtr	    pSrc,
					     PicturePtr	    pDst,
					     PictFormatPtr  maskFormat,
					     INT16	    xSrc,
					     INT16	    ySrc,
					     int	    ntrap,
					     xTrapezoid	    *traps);

typedef void	(*TrianglesProcPtr)	    (CARD8	    op,
					     PicturePtr	    pSrc,
					     PicturePtr	    pDst,
					     PictFormatPtr  maskFormat,
					     INT16	    xSrc,
					     INT16	    ySrc,
					     int	    ntri,
					     xTriangle	    *tris);

typedef Bool	(*InitIndexedProcPtr)	    (ScreenPtr	    pScreen,
					     PictFormatPtr  pFormat);

typedef void	(*CloseIndexedProcPtr)	    (ScreenPtr	    pScreen,
					     PictFormatPtr  pFormat);

typedef void	(*UpdateIndexedProcPtr)	    (ScreenPtr	    pScreen,
					     PictFormatPtr  pFormat,
					     int	    ndef,
					     xColorItem	    *pdef);

typedef void	(*AddTrapsProcPtr)	    (PicturePtr	    pPicture,
					     INT16	    xOff,
					     INT16	    yOff,
					     int	    ntrap,
					     xTrap	    *traps);

typedef void	(*AddTrianglesProcPtr)	    (PicturePtr	    pPicture,
					     INT16	    xOff,
					     INT16	    yOff,
					     int	    ntri,
					     xTriangle	    *tris);

typedef Bool	(*RealizeGlyphProcPtr)	    (ScreenPtr	    pScreen,
					     GlyphPtr	    glyph);

typedef void	(*UnrealizeGlyphProcPtr)    (ScreenPtr	    pScreen,
					     GlyphPtr	    glyph);

typedef struct _PictureScreen {
    PictFormatPtr		formats;
    PictFormatPtr		fallback;
    int				nformats;

    CreatePictureProcPtr	CreatePicture;
    DestroyPictureProcPtr	DestroyPicture;
    ChangePictureClipProcPtr	ChangePictureClip;
    DestroyPictureClipProcPtr	DestroyPictureClip;

    ChangePictureProcPtr	ChangePicture;
    ValidatePictureProcPtr	ValidatePicture;

    CompositeProcPtr		Composite;
    GlyphsProcPtr		Glyphs; /* unused */
    CompositeRectsProcPtr	CompositeRects;

    DestroyWindowProcPtr	DestroyWindow;
    CloseScreenProcPtr		CloseScreen;

    StoreColorsProcPtr		StoreColors;

    InitIndexedProcPtr		InitIndexed;
    CloseIndexedProcPtr		CloseIndexed;
    UpdateIndexedProcPtr	UpdateIndexed;

    int				subpixel;

    PictFilterPtr		filters;
    int				nfilters;
    PictFilterAliasPtr		filterAliases;
    int				nfilterAliases;

    /**
     * Called immediately after a picture's transform is changed through the
     * SetPictureTransform request.  Not called for source-only pictures.
     */
    ChangePictureTransformProcPtr   ChangePictureTransform;

    /**
     * Called immediately after a picture's transform is changed through the
     * SetPictureFilter request.  Not called for source-only pictures.
     */
    ChangePictureFilterProcPtr	ChangePictureFilter;

    DestroyPictureFilterProcPtr	DestroyPictureFilter;

    TrapezoidsProcPtr		Trapezoids;
    TrianglesProcPtr		Triangles;

    RasterizeTrapezoidProcPtr	RasterizeTrapezoid;

    AddTrianglesProcPtr		AddTriangles;

    AddTrapsProcPtr		AddTraps;

    RealizeGlyphProcPtr   	RealizeGlyph;
    UnrealizeGlyphProcPtr 	UnrealizeGlyph;

} PictureScreenRec, *PictureScreenPtr;

extern _X_EXPORT DevPrivateKeyRec PictureScreenPrivateKeyRec;
#define PictureScreenPrivateKey (&PictureScreenPrivateKeyRec)

extern _X_EXPORT DevPrivateKeyRec PictureWindowPrivateKeyRec;
#define	PictureWindowPrivateKey (&PictureWindowPrivateKeyRec)

extern _X_EXPORT RESTYPE	PictureType;
extern _X_EXPORT RESTYPE	PictFormatType;
extern _X_EXPORT RESTYPE	GlyphSetType;

#define GetPictureScreen(s) ((PictureScreenPtr)dixLookupPrivate(&(s)->devPrivates, PictureScreenPrivateKey))
#define GetPictureScreenIfSet(s) (dixPrivateKeyRegistered(PictureScreenPrivateKey) ? GetPictureScreen(s) : NULL)
#define SetPictureScreen(s,p) dixSetPrivate(&(s)->devPrivates, PictureScreenPrivateKey, p)
#define GetPictureWindow(w) ((PicturePtr)dixLookupPrivate(&(w)->devPrivates, PictureWindowPrivateKey))
#define SetPictureWindow(w,p) dixSetPrivate(&(w)->devPrivates, PictureWindowPrivateKey, p)

#define VERIFY_PICTURE(pPicture, pid, client, mode) {\
    int rc = dixLookupResourceByType((pointer)&(pPicture), pid,\
	                             PictureType, client, mode);\
    if (rc != Success)\
	return rc;\
}

#define VERIFY_ALPHA(pPicture, pid, client, mode) {\
    if (pid == None) \
	pPicture = 0; \
    else { \
	VERIFY_PICTURE(pPicture, pid, client, mode); \
    } \
} \

extern _X_EXPORT Bool
PictureDestroyWindow (WindowPtr pWindow);

extern _X_EXPORT Bool
PictureCloseScreen (int Index, ScreenPtr pScreen);

extern _X_EXPORT void
PictureStoreColors (ColormapPtr pColormap, int ndef, xColorItem *pdef);

extern _X_EXPORT Bool
PictureInitIndexedFormat (ScreenPtr pScreen, PictFormatPtr format);

extern _X_EXPORT Bool
PictureSetSubpixelOrder (ScreenPtr pScreen, int subpixel);

extern _X_EXPORT int
PictureGetSubpixelOrder (ScreenPtr pScreen);

extern _X_EXPORT PictFormatPtr
PictureCreateDefaultFormats (ScreenPtr pScreen, int *nformatp);

extern _X_EXPORT PictFormatPtr
PictureMatchVisual (ScreenPtr pScreen, int depth, VisualPtr pVisual);

extern _X_EXPORT PictFormatPtr
PictureMatchFormat (ScreenPtr pScreen, int depth, CARD32 format);

extern _X_EXPORT Bool
PictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats);

extern _X_EXPORT int
PictureGetFilterId (char *filter, int len, Bool makeit);

extern _X_EXPORT char *
PictureGetFilterName (int id);

extern _X_EXPORT int
PictureAddFilter (ScreenPtr			    pScreen,
		  char				    *filter,
		  PictFilterValidateParamsProcPtr   ValidateParams,
		  int				    width,
		  int				    height);

extern _X_EXPORT Bool
PictureSetFilterAlias (ScreenPtr pScreen, char *filter, char *alias);

extern _X_EXPORT Bool
PictureSetDefaultFilters (ScreenPtr pScreen);

extern _X_EXPORT void
PictureResetFilters (ScreenPtr pScreen);

extern _X_EXPORT PictFilterPtr
PictureFindFilter (ScreenPtr pScreen, char *name, int len);

extern _X_EXPORT int
SetPicturePictFilter (PicturePtr pPicture, PictFilterPtr pFilter,
		      xFixed *params, int nparams);

extern _X_EXPORT int
SetPictureFilter (PicturePtr pPicture, char *name, int len,
		  xFixed *params, int nparams);

extern _X_EXPORT Bool
PictureFinishInit (void);

extern _X_EXPORT void
SetPictureToDefaults (PicturePtr pPicture);

extern _X_EXPORT PicturePtr
CreatePicture (Picture		pid,
	       DrawablePtr	pDrawable,
	       PictFormatPtr	pFormat,
	       Mask		mask,
	       XID		*list,
	       ClientPtr	client,
	       int		*error);

extern _X_EXPORT int
ChangePicture (PicturePtr	pPicture,
	       Mask		vmask,
	       XID		*vlist,
	       DevUnion		*ulist,
	       ClientPtr	client);

extern _X_EXPORT int
SetPictureClipRects (PicturePtr	pPicture,
		     int	xOrigin,
		     int	yOrigin,
		     int	nRect,
		     xRectangle	*rects);

extern _X_EXPORT int
SetPictureClipRegion (PicturePtr    pPicture,
		      int	    xOrigin,
		      int	    yOrigin,
		      RegionPtr	    pRegion);

extern _X_EXPORT int
SetPictureTransform (PicturePtr	    pPicture,
		     PictTransform  *transform);

extern _X_EXPORT void
CopyPicture (PicturePtr	pSrc,
	     Mask	mask,
	     PicturePtr	pDst);

extern _X_EXPORT void
ValidatePicture(PicturePtr pPicture);

extern _X_EXPORT int
FreePicture (pointer	pPicture,
	     XID	pid);

extern _X_EXPORT int
FreePictFormat (pointer	pPictFormat,
		XID     pid);

extern _X_EXPORT void
CompositePicture (CARD8		op,
		  PicturePtr	pSrc,
		  PicturePtr	pMask,
		  PicturePtr	pDst,
		  INT16		xSrc,
		  INT16		ySrc,
		  INT16		xMask,
		  INT16		yMask,
		  INT16		xDst,
		  INT16		yDst,
		  CARD16	width,
		  CARD16	height);

extern _X_EXPORT void
CompositeGlyphs (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		nlist,
		 GlyphListPtr	lists,
		 GlyphPtr	*glyphs);

extern _X_EXPORT void
CompositeRects (CARD8		op,
		PicturePtr	pDst,
		xRenderColor	*color,
		int		nRect,
		xRectangle      *rects);

extern _X_EXPORT void
CompositeTrapezoids (CARD8	    op,
		     PicturePtr	    pSrc,
		     PicturePtr	    pDst,
		     PictFormatPtr  maskFormat,
		     INT16	    xSrc,
		     INT16	    ySrc,
		     int	    ntrap,
		     xTrapezoid	    *traps);

extern _X_EXPORT void
CompositeTriangles (CARD8	    op,
		    PicturePtr	    pSrc,
		    PicturePtr	    pDst,
		    PictFormatPtr   maskFormat,
		    INT16	    xSrc,
		    INT16	    ySrc,
		    int		    ntriangles,
		    xTriangle	    *triangles);

extern _X_EXPORT void
CompositeTriStrip (CARD8	    op,
		   PicturePtr	    pSrc,
		   PicturePtr	    pDst,
		   PictFormatPtr    maskFormat,
		   INT16	    xSrc,
		   INT16	    ySrc,
		   int		    npoints,
		   xPointFixed	    *points);

extern _X_EXPORT void
CompositeTriFan (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		npoints,
		 xPointFixed	*points);

extern _X_EXPORT void RenderExtensionInit (void);

Bool
AnimCurInit (ScreenPtr pScreen);

int
AnimCursorCreate (CursorPtr *cursors, CARD32 *deltas, int ncursor, CursorPtr *ppCursor, ClientPtr client, XID cid);

extern _X_EXPORT void
AddTraps (PicturePtr	pPicture,
	  INT16		xOff,
	  INT16		yOff,
	  int		ntraps,
	  xTrap		*traps);

extern _X_EXPORT PicturePtr
CreateSolidPicture (Picture pid,
                    xRenderColor *color,
                    int *error);

extern _X_EXPORT PicturePtr
CreateLinearGradientPicture (Picture pid,
                             xPointFixed *p1,
                             xPointFixed *p2,
                             int nStops,
                             xFixed *stops,
                             xRenderColor *colors,
                             int *error);

extern _X_EXPORT PicturePtr
CreateRadialGradientPicture (Picture pid,
                             xPointFixed *inner,
                             xPointFixed *outer,
                             xFixed innerRadius,
                             xFixed outerRadius,
                             int nStops,
                             xFixed *stops,
                             xRenderColor *colors,
                             int *error);

extern _X_EXPORT PicturePtr
CreateConicalGradientPicture (Picture pid,
                              xPointFixed *center,
                              xFixed angle,
                              int nStops,
                              xFixed *stops,
                              xRenderColor *colors,
                              int *error);

#ifdef PANORAMIX
extern _X_EXPORT void PanoramiXRenderInit (void);
extern _X_EXPORT void PanoramiXRenderReset (void);
#endif

/*
 * matrix.c
 */

extern _X_EXPORT void
PictTransform_from_xRenderTransform (PictTransformPtr pict,
				     xRenderTransform *render);

extern _X_EXPORT void
xRenderTransform_from_PictTransform (xRenderTransform *render,
				     PictTransformPtr pict);

extern _X_EXPORT Bool
PictureTransformPoint (PictTransformPtr transform,
		       PictVectorPtr	vector);

extern _X_EXPORT Bool
PictureTransformPoint3d (PictTransformPtr transform,
                         PictVectorPtr	vector);

#endif /* _PICTURESTR_H_ */
/*
 *
 * Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "colormapst.h"
#include "extnsionst.h"
#include "servermd.h"
#include <X11/extensions/render.h>
#include <X11/extensions/renderproto.h>
#include "picturestr.h"
#include "glyphstr.h"
#include <X11/Xfuncproto.h>
#include "cursorstr.h"
#include "xace.h"
#include "protocol-versions.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

#if HAVE_STDINT_H
#include <stdint.h>
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif

static int ProcRenderQueryVersion (ClientPtr pClient);
static int ProcRenderQueryPictFormats (ClientPtr pClient);
static int ProcRenderQueryPictIndexValues (ClientPtr pClient);
static int ProcRenderQueryDithers (ClientPtr pClient);
static int ProcRenderCreatePicture (ClientPtr pClient);
static int ProcRenderChangePicture (ClientPtr pClient);
static int ProcRenderSetPictureClipRectangles (ClientPtr pClient);
static int ProcRenderFreePicture (ClientPtr pClient);
static int ProcRenderComposite (ClientPtr pClient);
static int ProcRenderScale (ClientPtr pClient);
static int ProcRenderTrapezoids (ClientPtr pClient);
static int ProcRenderTriangles (ClientPtr pClient);
static int ProcRenderTriStrip (ClientPtr pClient);
static int ProcRenderTriFan (ClientPtr pClient);
static int ProcRenderColorTrapezoids (ClientPtr pClient);
static int ProcRenderColorTriangles (ClientPtr pClient);
static int ProcRenderTransform (ClientPtr pClient);
static int ProcRenderCreateGlyphSet (ClientPtr pClient);
static int ProcRenderReferenceGlyphSet (ClientPtr pClient);
static int ProcRenderFreeGlyphSet (ClientPtr pClient);
static int ProcRenderAddGlyphs (ClientPtr pClient);
static int ProcRenderAddGlyphsFromPicture (ClientPtr pClient);
static int ProcRenderFreeGlyphs (ClientPtr pClient);
static int ProcRenderCompositeGlyphs (ClientPtr pClient);
static int ProcRenderFillRectangles (ClientPtr pClient);
static int ProcRenderCreateCursor (ClientPtr pClient);
static int ProcRenderSetPictureTransform (ClientPtr pClient);
static int ProcRenderQueryFilters (ClientPtr pClient);
static int ProcRenderSetPictureFilter (ClientPtr pClient);
static int ProcRenderCreateAnimCursor (ClientPtr pClient);
static int ProcRenderAddTraps (ClientPtr pClient);
static int ProcRenderCreateSolidFill (ClientPtr pClient);
static int ProcRenderCreateLinearGradient (ClientPtr pClient);
static int ProcRenderCreateRadialGradient (ClientPtr pClient);
static int ProcRenderCreateConicalGradient (ClientPtr pClient);

static int ProcRenderDispatch (ClientPtr pClient);

static int SProcRenderQueryVersion (ClientPtr pClient);
static int SProcRenderQueryPictFormats (ClientPtr pClient);
static int SProcRenderQueryPictIndexValues (ClientPtr pClient);
static int SProcRenderQueryDithers (ClientPtr pClient);
static int SProcRenderCreatePicture (ClientPtr pClient);
static int SProcRenderChangePicture (ClientPtr pClient);
static int SProcRenderSetPictureClipRectangles (ClientPtr pClient);
static int SProcRenderFreePicture (ClientPtr pClient);
static int SProcRenderComposite (ClientPtr pClient);
static int SProcRenderScale (ClientPtr pClient);
static int SProcRenderTrapezoids (ClientPtr pClient);
static int SProcRenderTriangles (ClientPtr pClient);
static int SProcRenderTriStrip (ClientPtr pClient);
static int SProcRenderTriFan (ClientPtr pClient);
static int SProcRenderColorTrapezoids (ClientPtr pClient);
static int SProcRenderColorTriangles (ClientPtr pClient);
static int SProcRenderTransform (ClientPtr pClient);
static int SProcRenderCreateGlyphSet (ClientPtr pClient);
static int SProcRenderReferenceGlyphSet (ClientPtr pClient);
static int SProcRenderFreeGlyphSet (ClientPtr pClient);
static int SProcRenderAddGlyphs (ClientPtr pClient);
static int SProcRenderAddGlyphsFromPicture (ClientPtr pClient);
static int SProcRenderFreeGlyphs (ClientPtr pClient);
static int SProcRenderCompositeGlyphs (ClientPtr pClient);
static int SProcRenderFillRectangles (ClientPtr pClient);
static int SProcRenderCreateCursor (ClientPtr pClient);
static int SProcRenderSetPictureTransform (ClientPtr pClient);
static int SProcRenderQueryFilters (ClientPtr pClient);
static int SProcRenderSetPictureFilter (ClientPtr pClient);
static int SProcRenderCreateAnimCursor (ClientPtr pClient);
static int SProcRenderAddTraps (ClientPtr pClient);
static int SProcRenderCreateSolidFill (ClientPtr pClient);
static int SProcRenderCreateLinearGradient (ClientPtr pClient);
static int SProcRenderCreateRadialGradient (ClientPtr pClient);
static int SProcRenderCreateConicalGradient (ClientPtr pClient);

static int SProcRenderDispatch (ClientPtr pClient);

int	(*ProcRenderVector[RenderNumberRequests])(ClientPtr) = {
    ProcRenderQueryVersion,
    ProcRenderQueryPictFormats,
    ProcRenderQueryPictIndexValues,
    ProcRenderQueryDithers,
    ProcRenderCreatePicture,
    ProcRenderChangePicture,
    ProcRenderSetPictureClipRectangles,
    ProcRenderFreePicture,
    ProcRenderComposite,
    ProcRenderScale,
    ProcRenderTrapezoids,
    ProcRenderTriangles,
    ProcRenderTriStrip,
    ProcRenderTriFan,
    ProcRenderColorTrapezoids,
    ProcRenderColorTriangles,
    ProcRenderTransform,
    ProcRenderCreateGlyphSet,
    ProcRenderReferenceGlyphSet,
    ProcRenderFreeGlyphSet,
    ProcRenderAddGlyphs,
    ProcRenderAddGlyphsFromPicture,
    ProcRenderFreeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderFillRectangles,
    ProcRenderCreateCursor,
    ProcRenderSetPictureTransform,
    ProcRenderQueryFilters,
    ProcRenderSetPictureFilter,
    ProcRenderCreateAnimCursor,
    ProcRenderAddTraps,
    ProcRenderCreateSolidFill,
    ProcRenderCreateLinearGradient,
    ProcRenderCreateRadialGradient,
    ProcRenderCreateConicalGradient
};

int	(*SProcRenderVector[RenderNumberRequests])(ClientPtr) = {
    SProcRenderQueryVersion,
    SProcRenderQueryPictFormats,
    SProcRenderQueryPictIndexValues,
    SProcRenderQueryDithers,
    SProcRenderCreatePicture,
    SProcRenderChangePicture,
    SProcRenderSetPictureClipRectangles,
    SProcRenderFreePicture,
    SProcRenderComposite,
    SProcRenderScale,
    SProcRenderTrapezoids,
    SProcRenderTriangles,
    SProcRenderTriStrip,
    SProcRenderTriFan,
    SProcRenderColorTrapezoids,
    SProcRenderColorTriangles,
    SProcRenderTransform,
    SProcRenderCreateGlyphSet,
    SProcRenderReferenceGlyphSet,
    SProcRenderFreeGlyphSet,
    SProcRenderAddGlyphs,
    SProcRenderAddGlyphsFromPicture,
    SProcRenderFreeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderFillRectangles,
    SProcRenderCreateCursor,
    SProcRenderSetPictureTransform,
    SProcRenderQueryFilters,
    SProcRenderSetPictureFilter,
    SProcRenderCreateAnimCursor,
    SProcRenderAddTraps,
    SProcRenderCreateSolidFill,
    SProcRenderCreateLinearGradient,
    SProcRenderCreateRadialGradient,
    SProcRenderCreateConicalGradient
};

int	RenderErrBase;
static DevPrivateKeyRec RenderClientPrivateKeyRec;
#define RenderClientPrivateKey (&RenderClientPrivateKeyRec )

typedef struct _RenderClient {
    int	    major_version;
    int	    minor_version;
} RenderClientRec, *RenderClientPtr;

#define GetRenderClient(pClient) ((RenderClientPtr)dixLookupPrivate(&(pClient)->devPrivates, RenderClientPrivateKey))

static void
RenderClientCallback (CallbackListPtr	*list,
		      pointer		closure,
		      pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    RenderClientPtr	pRenderClient = GetRenderClient (pClient);

    pRenderClient->major_version = 0;
    pRenderClient->minor_version = 0;
}

#ifdef PANORAMIX
RESTYPE	XRT_PICTURE;
#endif

void
RenderExtensionInit (void)
{
    ExtensionEntry *extEntry;

    if (!PictureType)
	return;
    if (!PictureFinishInit ())
	return;
    if (!dixRegisterPrivateKey(&RenderClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(RenderClientRec)))
	return;
    if (!AddCallback (&ClientStateCallback, RenderClientCallback, 0))
	return;

    extEntry = AddExtension (RENDER_NAME, 0, RenderNumberErrors,
			     ProcRenderDispatch, SProcRenderDispatch,
			     NULL, StandardMinorOpcode);
    if (!extEntry)
	return;
    RenderErrBase = extEntry->errorBase;
#ifdef PANORAMIX
    if (XRT_PICTURE)
	SetResourceTypeErrorValue(XRT_PICTURE, RenderErrBase + BadPicture);
#endif
    SetResourceTypeErrorValue(PictureType, RenderErrBase + BadPicture);
    SetResourceTypeErrorValue(PictFormatType, RenderErrBase + BadPictFormat);
    SetResourceTypeErrorValue(GlyphSetType, RenderErrBase + BadGlyphSet);
}

static int
ProcRenderQueryVersion (ClientPtr client)
{
    RenderClientPtr pRenderClient = GetRenderClient (client);
    xRenderQueryVersionReply rep;
    register int n;
    REQUEST(xRenderQueryVersionReq);

    pRenderClient->major_version = stuff->majorVersion;
    pRenderClient->minor_version = stuff->minorVersion;

    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);
    memset(&rep, 0, sizeof(xRenderQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if ((stuff->majorVersion * 1000 + stuff->minorVersion) <
        (SERVER_RENDER_MAJOR_VERSION * 1000 + SERVER_RENDER_MINOR_VERSION))
    {
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else
    {
	rep.majorVersion = SERVER_RENDER_MAJOR_VERSION;
	rep.minorVersion = SERVER_RENDER_MINOR_VERSION;
    }

    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xRenderQueryVersionReply), (char *)&rep);
    return Success;
}

static VisualPtr
findVisual (ScreenPtr pScreen, VisualID vid)
{
    VisualPtr	pVisual;
    int		v;

    for (v = 0; v < pScreen->numVisuals; v++)
    {
	pVisual = pScreen->visuals + v;
	if (pVisual->vid == vid)
	    return pVisual;
    }
    return 0;
}

static int
ProcRenderQueryPictFormats (ClientPtr client)
{
    RenderClientPtr		    pRenderClient = GetRenderClient (client);
    xRenderQueryPictFormatsReply    *reply;
    xPictScreen			    *pictScreen;
    xPictDepth			    *pictDepth;
    xPictVisual			    *pictVisual;
    xPictFormInfo		    *pictForm;
    CARD32			    *pictSubpixel;
    ScreenPtr			    pScreen;
    VisualPtr			    pVisual;
    DepthPtr			    pDepth;
    int				    v, d;
    PictureScreenPtr		    ps;
    PictFormatPtr		    pFormat;
    int				    nformat;
    int				    ndepth;
    int				    nvisual;
    int				    rlength;
    int				    s;
    int				    n;
    int				    numScreens;
    int				    numSubpixel;
/*    REQUEST(xRenderQueryPictFormatsReq); */

    REQUEST_SIZE_MATCH(xRenderQueryPictFormatsReq);

#ifdef PANORAMIX
    if (noPanoramiXExtension)
	numScreens = screenInfo.numScreens;
    else 
        numScreens = ((xConnSetup *)ConnectionInfo)->numRoots;
#else
    numScreens = screenInfo.numScreens;
#endif
    ndepth = nformat = nvisual = 0;
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	for (d = 0; d < pScreen->numDepths; d++)
	{
	    pDepth = pScreen->allowedDepths + d;
	    ++ndepth;

	    for (v = 0; v < pDepth->numVids; v++)
	    {
		pVisual = findVisual (pScreen, pDepth->vids[v]);
		if (pVisual && PictureMatchVisual (pScreen, pDepth->depth, pVisual))
		    ++nvisual;
	    }
	}
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    nformat += ps->nformats;
    }
    if (pRenderClient->major_version == 0 && pRenderClient->minor_version < 6)
	numSubpixel = 0;
    else
	numSubpixel = numScreens;
    
    rlength = (sizeof (xRenderQueryPictFormatsReply) +
	       nformat * sizeof (xPictFormInfo) +
	       numScreens * sizeof (xPictScreen) +
	       ndepth * sizeof (xPictDepth) +
	       nvisual * sizeof (xPictVisual) +
	       numSubpixel * sizeof (CARD32));
    reply = (xRenderQueryPictFormatsReply *) calloc(1, rlength);
    if (!reply)
	return BadAlloc;
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
    reply->numFormats = nformat;
    reply->numScreens = numScreens;
    reply->numDepths = ndepth;
    reply->numVisuals = nvisual;
    reply->numSubpixel = numSubpixel;
    
    pictForm = (xPictFormInfo *) (reply + 1);
    
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	{
	    for (nformat = 0, pFormat = ps->formats; 
		 nformat < ps->nformats;
		 nformat++, pFormat++)
	    {
		pictForm->id = pFormat->id;
		pictForm->type = pFormat->type;
		pictForm->depth = pFormat->depth;
		pictForm->direct.red = pFormat->direct.red;
		pictForm->direct.redMask = pFormat->direct.redMask;
		pictForm->direct.green = pFormat->direct.green;
		pictForm->direct.greenMask = pFormat->direct.greenMask;
		pictForm->direct.blue = pFormat->direct.blue;
		pictForm->direct.blueMask = pFormat->direct.blueMask;
		pictForm->direct.alpha = pFormat->direct.alpha;
		pictForm->direct.alphaMask = pFormat->direct.alphaMask;
		if (pFormat->type == PictTypeIndexed && pFormat->index.pColormap)
		    pictForm->colormap = pFormat->index.pColormap->mid;
		else
		    pictForm->colormap = None;
		if (client->swapped)
		{
		    swapl (&pictForm->id, n);
		    swaps (&pictForm->direct.red, n);
		    swaps (&pictForm->direct.redMask, n);
		    swaps (&pictForm->direct.green, n);
		    swaps (&pictForm->direct.greenMask, n);
		    swaps (&pictForm->direct.blue, n);
		    swaps (&pictForm->direct.blueMask, n);
		    swaps (&pictForm->direct.alpha, n);
		    swaps (&pictForm->direct.alphaMask, n);
		    swapl (&pictForm->colormap, n);
		}
		pictForm++;
	    }
	}
    }
    
    pictScreen = (xPictScreen *) pictForm;
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	pictDepth = (xPictDepth *) (pictScreen + 1);
	ndepth = 0;
	for (d = 0; d < pScreen->numDepths; d++)
	{
	    pictVisual = (xPictVisual *) (pictDepth + 1);
	    pDepth = pScreen->allowedDepths + d;

	    nvisual = 0;
	    for (v = 0; v < pDepth->numVids; v++)
	    {
		pVisual = findVisual (pScreen, pDepth->vids[v]);
		if (pVisual && (pFormat = PictureMatchVisual (pScreen, 
							      pDepth->depth, 
							      pVisual)))
		{
		    pictVisual->visual = pVisual->vid;
		    pictVisual->format = pFormat->id;
		    if (client->swapped)
		    {
			swapl (&pictVisual->visual, n);
			swapl (&pictVisual->format, n);
		    }
		    pictVisual++;
		    nvisual++;
		}
	    }
	    pictDepth->depth = pDepth->depth;
	    pictDepth->nPictVisuals = nvisual;
	    if (client->swapped)
	    {
		swaps (&pictDepth->nPictVisuals, n);
	    }
	    ndepth++;
	    pictDepth = (xPictDepth *) pictVisual;
	}
	pictScreen->nDepth = ndepth;
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    pictScreen->fallback = ps->fallback->id;
	else
	    pictScreen->fallback = 0;
	if (client->swapped)
	{
	    swapl (&pictScreen->nDepth, n);
	    swapl (&pictScreen->fallback, n);
	}
	pictScreen = (xPictScreen *) pictDepth;
    }
    pictSubpixel = (CARD32 *) pictScreen;
    
    for (s = 0; s < numSubpixel; s++)
    {
	pScreen = screenInfo.screens[s];
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    *pictSubpixel = ps->subpixel;
	else
	    *pictSubpixel = SubPixelUnknown;
	if (client->swapped)
	{
	    swapl (pictSubpixel, n);
	}
	++pictSubpixel;
    }
    
    if (client->swapped)
    {
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swapl (&reply->numFormats, n);
	swapl (&reply->numScreens, n);
	swapl (&reply->numDepths, n);
	swapl (&reply->numVisuals, n);
	swapl (&reply->numSubpixel, n);
    }
    WriteToClient(client, rlength, (char *) reply);
    free(reply);
    return Success;
}

static int
ProcRenderQueryPictIndexValues (ClientPtr client)
{
    PictFormatPtr   pFormat;
    int		    rc, num;
    int		    rlength;
    int		    i, n;
    REQUEST(xRenderQueryPictIndexValuesReq);
    xRenderQueryPictIndexValuesReply *reply;
    xIndexValue	    *values;

    REQUEST_AT_LEAST_SIZE(xRenderQueryPictIndexValuesReq);

    rc = dixLookupResourceByType((pointer *)&pFormat, stuff->format,
				 PictFormatType, client, DixReadAccess);
    if (rc != Success)
	return rc;

    if (pFormat->type != PictTypeIndexed)
    {
	client->errorValue = stuff->format;
	return BadMatch;
    }
    num = pFormat->index.nvalues;
    rlength = (sizeof (xRenderQueryPictIndexValuesReply) + 
	       num * sizeof(xIndexValue));
    reply = (xRenderQueryPictIndexValuesReply *) malloc(rlength);
    if (!reply)
	return BadAlloc;

    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
    reply->numIndexValues = num;

    values = (xIndexValue *) (reply + 1);
    
    memcpy (reply + 1, pFormat->index.pValues, num * sizeof (xIndexValue));
    
    if (client->swapped)
    {
	for (i = 0; i < num; i++)
	{
	    swapl (&values[i].pixel, n);
	    swaps (&values[i].red, n);
	    swaps (&values[i].green, n);
	    swaps (&values[i].blue, n);
	    swaps (&values[i].alpha, n);
	}
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swapl (&reply->numIndexValues, n);
    }

    WriteToClient(client, rlength, (char *) reply);
    free(reply);
    return Success;
}

static int
ProcRenderQueryDithers (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderCreatePicture (ClientPtr client)
{
    PicturePtr	    pPicture;
    DrawablePtr	    pDrawable;
    PictFormatPtr   pFormat;
    int		    len, error, rc;
    REQUEST(xRenderCreatePictureReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
			   DixReadAccess|DixAddAccess);
    if (rc != Success)
	return rc;

    rc = dixLookupResourceByType((pointer *)&pFormat, stuff->format,
				 PictFormatType, client, DixReadAccess);
    if (rc != Success)
	return rc;

    if (pFormat->depth != pDrawable->depth)
	return BadMatch;
    len = client->req_len - bytes_to_int32(sizeof(xRenderCreatePictureReq));
    if (Ones(stuff->mask) != len)
	return BadLength;
    
    pPicture = CreatePicture (stuff->pid,
			      pDrawable,
			      pFormat,
			      stuff->mask,
			      (XID *) (stuff + 1),
			      client,
			      &error);
    if (!pPicture)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}

static int
ProcRenderChangePicture (ClientPtr client)
{
    PicturePtr	    pPicture;
    REQUEST(xRenderChangePictureReq);
    int len;

    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);

    len = client->req_len - bytes_to_int32(sizeof(xRenderChangePictureReq));
    if (Ones(stuff->mask) != len)
	return BadLength;
    
    return ChangePicture (pPicture, stuff->mask, (XID *) (stuff + 1),
			  (DevUnion *) 0, client);
}

static int
ProcRenderSetPictureClipRectangles (ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    PicturePtr	    pPicture;
    int		    nr;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
    if (!pPicture->pDrawable)
        return BadDrawable;

    nr = (client->req_len << 2) - sizeof(xRenderSetPictureClipRectanglesReq);
    if (nr & 4)
	return BadLength;
    nr >>= 3;
    return SetPictureClipRects (pPicture,
				  stuff->xOrigin, stuff->yOrigin,
				  nr, (xRectangle *) &stuff[1]);
}

static int
ProcRenderFreePicture (ClientPtr client)
{
    PicturePtr	pPicture;
    REQUEST(xRenderFreePictureReq);

    REQUEST_SIZE_MATCH(xRenderFreePictureReq);

    VERIFY_PICTURE (pPicture, stuff->picture, client, DixDestroyAccess);
    FreeResource (stuff->picture, RT_NONE);
    return Success;
}

static Bool
PictOpValid (CARD8 op)
{
    if (/*PictOpMinimum <= op && */ op <= PictOpMaximum)
	return TRUE;
    if (PictOpDisjointMinimum <= op && op <= PictOpDisjointMaximum)
	return TRUE;
    if (PictOpConjointMinimum <= op && op <= PictOpConjointMaximum)
	return TRUE;
    if (PictOpBlendMinimum <= op && op <= PictOpBlendMaximum)
	return TRUE;
    return FALSE;
}

static int
ProcRenderComposite (ClientPtr client)
{
    PicturePtr	pSrc, pMask, pDst;
    REQUEST(xRenderCompositeReq);

    REQUEST_SIZE_MATCH(xRenderCompositeReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_ALPHA (pMask, stuff->mask, client, DixReadAccess);
    if ((pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen) ||
	(pMask && pMask->pDrawable && pDst->pDrawable->pScreen != pMask->pDrawable->pScreen))
	return BadMatch;
    CompositePicture (stuff->op,
		      pSrc,
		      pMask,
		      pDst,
		      stuff->xSrc,
		      stuff->ySrc,
		      stuff->xMask,
		      stuff->yMask,
		      stuff->xDst,
		      stuff->yDst,
		      stuff->width,
		      stuff->height);
    return Success;
}

static int
ProcRenderScale (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderTrapezoids (ClientPtr client)
{
    int		rc, ntraps;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
    REQUEST(xRenderTrapezoidsReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;
    ntraps = (client->req_len << 2) - sizeof (xRenderTrapezoidsReq);
    if (ntraps % sizeof (xTrapezoid))
	return BadLength;
    ntraps /= sizeof (xTrapezoid);
    if (ntraps)
	CompositeTrapezoids (stuff->op, pSrc, pDst, pFormat,
			     stuff->xSrc, stuff->ySrc,
			     ntraps, (xTrapezoid *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriangles (ClientPtr client)
{
    int		rc, ntris;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;
    ntris = (client->req_len << 2) - sizeof (xRenderTrianglesReq);
    if (ntris % sizeof (xTriangle))
	return BadLength;
    ntris /= sizeof (xTriangle);
    if (ntris)
	CompositeTriangles (stuff->op, pSrc, pDst, pFormat,
			    stuff->xSrc, stuff->ySrc,
			    ntris, (xTriangle *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriStrip (ClientPtr client)
{
    int		rc, npoints;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;
    npoints = ((client->req_len << 2) - sizeof (xRenderTriStripReq));
    if (npoints & 4)
	return BadLength;
    npoints >>= 3;
    if (npoints >= 3)
	CompositeTriStrip (stuff->op, pSrc, pDst, pFormat,
			   stuff->xSrc, stuff->ySrc,
			   npoints, (xPointFixed *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriFan (ClientPtr client)
{
    int		rc, npoints;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;
    npoints = ((client->req_len << 2) - sizeof (xRenderTriStripReq));
    if (npoints & 4)
	return BadLength;
    npoints >>= 3;
    if (npoints >= 3)
	CompositeTriFan (stuff->op, pSrc, pDst, pFormat,
			 stuff->xSrc, stuff->ySrc,
			 npoints, (xPointFixed *) &stuff[1]);
    return Success;
}

static int
ProcRenderColorTrapezoids (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderColorTriangles (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderTransform (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderCreateGlyphSet (ClientPtr client)
{
    GlyphSetPtr	    glyphSet;
    PictFormatPtr   format;
    int		    rc, f;
    REQUEST(xRenderCreateGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderCreateGlyphSetReq);

    LEGAL_NEW_RESOURCE(stuff->gsid, client);
    rc = dixLookupResourceByType((pointer *)&format, stuff->format,
				 PictFormatType, client, DixReadAccess);
    if (rc != Success)
	return rc;

    switch (format->depth) {
    case 1:
	f = GlyphFormat1;
	break;
    case 4:
	f = GlyphFormat4;
	break;
    case 8:
	f = GlyphFormat8;
	break;
    case 16:
	f = GlyphFormat16;
	break;
    case 32:
	f = GlyphFormat32;
	break;
    default:
	return BadMatch;
    }
    if (format->type != PictTypeDirect)
	return BadMatch;
    glyphSet = AllocateGlyphSet (f, format);
    if (!glyphSet)
	return BadAlloc;
    /* security creation/labeling check */
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->gsid, GlyphSetType,
		  glyphSet, RT_NONE, NULL, DixCreateAccess);
    if (rc != Success)
	return rc;
    if (!AddResource (stuff->gsid, GlyphSetType, (pointer)glyphSet))
	return BadAlloc;
    return Success;
}

static int
ProcRenderReferenceGlyphSet (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    int rc;
    REQUEST(xRenderReferenceGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderReferenceGlyphSetReq);

    LEGAL_NEW_RESOURCE(stuff->gsid, client);

    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->existing, GlyphSetType,
			   client, DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->existing;
	return rc;
    }
    glyphSet->refcnt++;
    if (!AddResource (stuff->gsid, GlyphSetType, (pointer)glyphSet))
	return BadAlloc;
    return Success;
}

#define NLOCALDELTA	64
#define NLOCALGLYPH	256

static int
ProcRenderFreeGlyphSet (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    int rc;
    REQUEST(xRenderFreeGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderFreeGlyphSetReq);
    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			   client, DixDestroyAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->glyphset;
	return rc;
    }
    FreeResource (stuff->glyphset, RT_NONE);
    return Success;
}

typedef struct _GlyphNew {
    Glyph	    id;
    GlyphPtr        glyph;
    Bool	    found;
    unsigned char   sha1[20];
} GlyphNewRec, *GlyphNewPtr;

#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)

static int
ProcRenderAddGlyphs (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    REQUEST(xRenderAddGlyphsReq);
    GlyphNewRec	    glyphsLocal[NLOCALGLYPH];
    GlyphNewPtr	    glyphsBase, glyphs, glyph_new;
    int		    remain, nglyphs;
    CARD32	    *gids;
    xGlyphInfo	    *gi;
    CARD8	    *bits;
    unsigned int    size;
    int		    err;
    int		    i, screen;
    PicturePtr	    pSrc = NULL, pDst = NULL;
    PixmapPtr	    pSrcPix = NULL, pDstPix = NULL;
    CARD32	    component_alpha;

    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);
    err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			    client, DixAddAccess);
    if (err != Success)
    {
	client->errorValue = stuff->glyphset;
	return err;
    }

    err = BadAlloc;
    nglyphs = stuff->nglyphs;
    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))
	    return BadAlloc;

    component_alpha = NeedsComponent (glyphSet->format->format);

    if (nglyphs <= NLOCALGLYPH) {
	memset (glyphsLocal, 0, sizeof (glyphsLocal));
	glyphsBase = glyphsLocal;
    }
    else
    {
	glyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));
	if (!glyphsBase)
	    return BadAlloc;
    }

    remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);

    glyphs = glyphsBase;

    gids = (CARD32 *) (stuff + 1);
    gi = (xGlyphInfo *) (gids + nglyphs);
    bits = (CARD8 *) (gi + nglyphs);
    remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;

    /* protect against bad nglyphs */
    if (gi < ((xGlyphInfo *)stuff) ||
        gi > ((xGlyphInfo *)((CARD32 *)stuff + client->req_len)) ||
        bits < ((CARD8 *)stuff) ||
        bits > ((CARD8 *)((CARD32 *)stuff + client->req_len))) {
        err = BadLength;
        goto bail;
    }

    for (i = 0; i < nglyphs; i++)
    {
	size_t padded_width;
	glyph_new = &glyphs[i];

	padded_width = PixmapBytePad (gi[i].width,
				      glyphSet->format->depth);

	if (gi[i].height && padded_width > (UINT32_MAX - sizeof(GlyphRec))/gi[i].height)
	    break;
	
	size = gi[i].height * padded_width;
	if (remain < size)
	    break;

	err = HashGlyph (&gi[i], bits, size, glyph_new->sha1);
	if (err)
	    goto bail;

	glyph_new->glyph = FindGlyphByHash (glyph_new->sha1,
					    glyphSet->fdepth);

	if (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)
	{
	    glyph_new->found = TRUE;
	}
	else
	{
	    GlyphPtr glyph;

	    glyph_new->found = FALSE;
	    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);
	    if (! glyph)
	    {
		err = BadAlloc;
		goto bail;
	    }

	    for (screen = 0; screen < screenInfo.numScreens; screen++)
	    {
		int	    width = gi[i].width;
		int	    height = gi[i].height;
		int	    depth = glyphSet->format->depth;
		ScreenPtr   pScreen;
		int	    error;

		/* Skip work if it's invisibly small anyway */
		if (!width || !height)
		    break;

		pScreen = screenInfo.screens[screen];
		pSrcPix = GetScratchPixmapHeader (pScreen,
						  width, height,
						  depth, depth,
						  -1, bits);
		if (! pSrcPix)
		{
		    err = BadAlloc;
		    goto bail;
		}

		pSrc = CreatePicture (0, &pSrcPix->drawable,
				      glyphSet->format, 0, NULL,
				      serverClient, &error);
		if (! pSrc)
		{
		    err = BadAlloc;
		    goto bail;
		}

		pDstPix = (pScreen->CreatePixmap) (pScreen,
						   width, height, depth,
						   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);

		if (!pDstPix)
		{
		    err = BadAlloc;
		    goto bail;
		}

		GlyphPicture (glyph)[screen] = pDst =
			CreatePicture (0, &pDstPix->drawable,
				       glyphSet->format,
				       CPComponentAlpha, &component_alpha,
				       serverClient, &error);

		/* The picture takes a reference to the pixmap, so we
		   drop ours. */
		(pScreen->DestroyPixmap) (pDstPix);
		pDstPix = NULL;

		if (! pDst)
		{
		    err = BadAlloc;
		    goto bail;
		}

		CompositePicture (PictOpSrc,
				  pSrc,
				  None,
				  pDst,
				  0, 0,
				  0, 0,
				  0, 0,
				  width, height);

		FreePicture ((pointer) pSrc, 0);
		pSrc = NULL;
		FreeScratchPixmapHeader (pSrcPix);
		pSrcPix = NULL;
	    }

	    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);
	}

	glyph_new->id = gids[i];
	
	if (size & 3)
	    size += 4 - (size & 3);
	bits += size;
	remain -= size;
    }
    if (remain || i < nglyphs)
    {
	err = BadLength;
	goto bail;
    }
    if (!ResizeGlyphSet (glyphSet, nglyphs))
    {
	err = BadAlloc;
	goto bail;
    }
    for (i = 0; i < nglyphs; i++)
	AddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);

    if (glyphsBase != glyphsLocal)
	free(glyphsBase);
    return Success;
bail:
    if (pSrc)
	FreePicture ((pointer) pSrc, 0);
    if (pSrcPix)
	FreeScratchPixmapHeader (pSrcPix);
    for (i = 0; i < nglyphs; i++)
	if (glyphs[i].glyph && ! glyphs[i].found)
	    free(glyphs[i].glyph);
    if (glyphsBase != glyphsLocal)
	free(glyphsBase);
    return err;
}

static int
ProcRenderAddGlyphsFromPicture (ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderFreeGlyphs (ClientPtr client)
{
    REQUEST(xRenderFreeGlyphsReq);
    GlyphSetPtr     glyphSet;
    int		    rc, nglyph;
    CARD32	    *gids;
    CARD32	    glyph;

    REQUEST_AT_LEAST_SIZE(xRenderFreeGlyphsReq);
    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			   client, DixRemoveAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->glyphset;
	return rc;
    }
    nglyph = bytes_to_int32((client->req_len << 2) - sizeof (xRenderFreeGlyphsReq));
    gids = (CARD32 *) (stuff + 1);
    while (nglyph-- > 0)
    {
	glyph = *gids++;
	if (!DeleteGlyph (glyphSet, glyph))
	{
	    client->errorValue = glyph;
	    return RenderErrBase + BadGlyph;
	}
    }
    return Success;
}

static int
ProcRenderCompositeGlyphs (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    GlyphSet	    gs;
    PicturePtr      pSrc, pDst;
    PictFormatPtr   pFormat;
    GlyphListRec    listsLocal[NLOCALDELTA];
    GlyphListPtr    lists, listsBase;
    GlyphPtr	    glyphsLocal[NLOCALGLYPH];
    Glyph	    glyph;
    GlyphPtr	    *glyphs, *glyphsBase;
    xGlyphElt	    *elt;
    CARD8	    *buffer, *end;
    int		    nglyph;
    int		    nlist;
    int		    space;
    int		    size;
    int		    rc, n;
    
    REQUEST(xRenderCompositeGlyphsReq);

    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);

    switch (stuff->renderReqType) {
    default:			    size = 1; break;
    case X_RenderCompositeGlyphs16: size = 2; break;
    case X_RenderCompositeGlyphs32: size = 4; break;
    }
	    
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
    }
    else
	pFormat = 0;

    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset,
				 GlyphSetType, client, DixUseAccess);
    if (rc != Success)
	return rc;

    buffer = (CARD8 *) (stuff + 1);
    end = (CARD8 *) stuff + (client->req_len << 2);
    nglyph = 0;
    nlist = 0;
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	if (elt->len == 0xff)
	{
	    buffer += 4;
	}
	else
	{
	    nlist++;
	    nglyph += elt->len;
	    space = size * elt->len;
	    if (space & 3)
		space += 4 - (space & 3);
	    buffer += space;
	}
    }
    if (nglyph <= NLOCALGLYPH)
	glyphsBase = glyphsLocal;
    else
    {
	glyphsBase = (GlyphPtr *) malloc(nglyph * sizeof (GlyphPtr));
	if (!glyphsBase)
	    return BadAlloc;
    }
    if (nlist <= NLOCALDELTA)
	listsBase = listsLocal;
    else
    {
	listsBase = (GlyphListPtr) malloc(nlist * sizeof (GlyphListRec));
	if (!listsBase) {
	    rc = BadAlloc;
	    goto bail;
	}
    }
    buffer = (CARD8 *) (stuff + 1);
    glyphs = glyphsBase;
    lists = listsBase;
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	if (elt->len == 0xff)
	{
	    if (buffer + sizeof (GlyphSet) < end)
	    {
                memcpy(&gs, buffer, sizeof(GlyphSet));
		rc = dixLookupResourceByType((pointer *)&glyphSet, gs,
					     GlyphSetType, client,
					     DixUseAccess);
		if (rc != Success)
		    goto bail;
	    }
	    buffer += 4;
	}
	else
	{
	    lists->xOff = elt->deltax;
	    lists->yOff = elt->deltay;
	    lists->format = glyphSet->format;
	    lists->len = 0;
	    n = elt->len;
	    while (n--)
	    {
		if (buffer + size <= end)
		{
		    switch (size) {
		    case 1:
			glyph = *((CARD8 *)buffer); break;
		    case 2:
			glyph = *((CARD16 *)buffer); break;
		    case 4:
		    default:
			glyph = *((CARD32 *)buffer); break;
		    }
		    if ((*glyphs = FindGlyph (glyphSet, glyph)))
		    {
			lists->len++;
			glyphs++;
		    }
		}
		buffer += size;
	    }
	    space = size * elt->len;
	    if (space & 3)
		buffer += 4 - (space & 3);
	    lists++;
	}
    }
    if (buffer > end) {
	rc = BadLength;
	goto bail;
    }

    CompositeGlyphs (stuff->op,
		     pSrc,
		     pDst,
		     pFormat,
		     stuff->xSrc,
		     stuff->ySrc,
		     nlist,
		     listsBase,
		     glyphsBase);
    rc = Success;

bail:
    if (glyphsBase != glyphsLocal)
	free(glyphsBase);
    if (listsBase != listsLocal)
	free(listsBase);
    return rc;
}

static int
ProcRenderFillRectangles (ClientPtr client)
{
    PicturePtr	    pDst;
    int             things;
    REQUEST(xRenderFillRectanglesReq);
    
    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
    }
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    
    things = (client->req_len << 2) - sizeof(xRenderFillRectanglesReq);
    if (things & 4)
	return BadLength;
    things >>= 3;
    
    CompositeRects (stuff->op,
		    pDst,
		    &stuff->color,
		    things,
		    (xRectangle *) &stuff[1]);
    
    return Success;
}

static void
RenderSetBit (unsigned char *line, int x, int bit)
{
    unsigned char   mask;
    
    if (screenInfo.bitmapBitOrder == LSBFirst)
	mask = (1 << (x & 7));
    else
	mask = (0x80 >> (x & 7));
    /* XXX assumes byte order is host byte order */
    line += (x >> 3);
    if (bit)
	*line |= mask;
    else
	*line &= ~mask;
}

#define DITHER_DIM 2

static CARD32 orderedDither[DITHER_DIM][DITHER_DIM] = {
    {  1,  3,  },
    {  4,  2,  },
};

#define DITHER_SIZE  ((sizeof orderedDither / sizeof orderedDither[0][0]) + 1)

static int
ProcRenderCreateCursor (ClientPtr client)
{
    REQUEST(xRenderCreateCursorReq);
    PicturePtr	    pSrc;
    ScreenPtr	    pScreen;
    unsigned short  width, height;
    CARD32	    *argbbits, *argb;
    unsigned char   *srcbits, *srcline;
    unsigned char   *mskbits, *mskline;
    int		    stride;
    int		    x, y;
    int		    nbytes_mono;
    CursorMetricRec cm;
    CursorPtr	    pCursor;
    CARD32	    twocolor[3];
    int		    rc, ncolor;

    REQUEST_SIZE_MATCH (xRenderCreateCursorReq);
    LEGAL_NEW_RESOURCE(stuff->cid, client);
    
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    if (!pSrc->pDrawable)
        return BadDrawable;
    pScreen = pSrc->pDrawable->pScreen;
    width = pSrc->pDrawable->width;
    height = pSrc->pDrawable->height;
    if (height && width > UINT32_MAX/(height*sizeof(CARD32)))
	return BadAlloc;
    if ( stuff->x > width 
      || stuff->y > height )
	return BadMatch;
    argbbits = malloc(width * height * sizeof (CARD32));
    if (!argbbits)
	return BadAlloc;
    
    stride = BitmapBytePad(width);
    nbytes_mono = stride*height;
    srcbits = calloc(1, nbytes_mono);
    if (!srcbits)
    {
	free(argbbits);
	return BadAlloc;
    }
    mskbits = calloc(1, nbytes_mono);
    if (!mskbits)
    {
	free(argbbits);
	free(srcbits);
	return BadAlloc;
    }

    if (pSrc->format == PICT_a8r8g8b8)
    {
	(*pScreen->GetImage) (pSrc->pDrawable,
			      0, 0, width, height, ZPixmap,
			      0xffffffff, (pointer) argbbits);
    }
    else
    {
	PixmapPtr	pPixmap;
	PicturePtr	pPicture;
	PictFormatPtr	pFormat;
	int		error;

	pFormat = PictureMatchFormat (pScreen, 32, PICT_a8r8g8b8);
	if (!pFormat)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return BadImplementation;
	}
	pPixmap = (*pScreen->CreatePixmap) (pScreen, width, height, 32,
					    CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pPixmap)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return BadAlloc;
	}
	pPicture = CreatePicture (0, &pPixmap->drawable, pFormat, 0, 0, 
				  client, &error);
	if (!pPicture)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return error;
	}
	(*pScreen->DestroyPixmap) (pPixmap);
	CompositePicture (PictOpSrc,
			  pSrc, 0, pPicture,
			  0, 0, 0, 0, 0, 0, width, height);
	(*pScreen->GetImage) (pPicture->pDrawable,
			      0, 0, width, height, ZPixmap,
			      0xffffffff, (pointer) argbbits);
	FreePicture (pPicture, 0);
    }
    /*
     * Check whether the cursor can be directly supported by 
     * the core cursor code
     */
    ncolor = 0;
    argb = argbbits;
    for (y = 0; ncolor <= 2 && y < height; y++)
    {
	for (x = 0; ncolor <= 2 && x < width; x++)
	{
	    CARD32  p = *argb++;
	    CARD32  a = (p >> 24);

	    if (a == 0)	    /* transparent */
		continue;
	    if (a == 0xff)  /* opaque */
	    {
		int n;
		for (n = 0; n < ncolor; n++)
		    if (p == twocolor[n])
			break;
		if (n == ncolor)
		    twocolor[ncolor++] = p;
	    }
	    else
		ncolor = 3;
	}
    }
    
    /*
     * Convert argb image to two plane cursor
     */
    srcline = srcbits;
    mskline = mskbits;
    argb = argbbits;
    for (y = 0; y < height; y++)
    {
	for (x = 0; x < width; x++)
	{
	    CARD32  p = *argb++;

	    if (ncolor <= 2)
	    {
		CARD32	a = ((p >> 24));

		RenderSetBit (mskline, x, a != 0);
		RenderSetBit (srcline, x, a != 0 && p == twocolor[0]);
	    }
	    else
	    {
		CARD32	a = ((p >> 24) * DITHER_SIZE + 127) / 255;
		CARD32	i = ((CvtR8G8B8toY15(p) >> 7) * DITHER_SIZE + 127) / 255;
		CARD32	d = orderedDither[y&(DITHER_DIM-1)][x&(DITHER_DIM-1)];
		/* Set mask from dithered alpha value */
		RenderSetBit(mskline, x, a > d);
		/* Set src from dithered intensity value */
		RenderSetBit(srcline, x, a > d && i <= d);
	    }
	}
	srcline += stride;
	mskline += stride;
    }
    /*
     * Dither to white and black if the cursor has more than two colors
     */
    if (ncolor > 2)
    {
	twocolor[0] = 0xff000000;
	twocolor[1] = 0xffffffff;
    }
    else
    {
	free(argbbits);
	argbbits = 0;
    }
    
#define GetByte(p,s)	(((p) >> (s)) & 0xff)
#define GetColor(p,s)	(GetByte(p,s) | (GetByte(p,s) << 8))
    
    cm.width = width;
    cm.height = height;
    cm.xhot = stuff->x;
    cm.yhot = stuff->y;
    rc = AllocARGBCursor(srcbits, mskbits, argbbits, &cm,
			 GetColor(twocolor[0], 16),
			 GetColor(twocolor[0], 8),
			 GetColor(twocolor[0], 0),
			 GetColor(twocolor[1], 16),
			 GetColor(twocolor[1], 8),
			 GetColor(twocolor[1], 0),
			 &pCursor, client, stuff->cid);
    if (rc != Success)
	goto bail;
    if (!AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor)) {
	rc = BadAlloc;
	goto bail;
    }

    return Success;
bail:
    free(srcbits);
    free(mskbits);
    return rc;
}

static int
ProcRenderSetPictureTransform (ClientPtr client)
{
    REQUEST(xRenderSetPictureTransformReq);
    PicturePtr	pPicture;

    REQUEST_SIZE_MATCH(xRenderSetPictureTransformReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
    return SetPictureTransform (pPicture, (PictTransform *) &stuff->transform);
}

static int
ProcRenderQueryFilters (ClientPtr client)
{
    REQUEST (xRenderQueryFiltersReq);
    DrawablePtr			pDrawable;
    xRenderQueryFiltersReply	*reply;
    int				nbytesName;
    int				nnames;
    ScreenPtr			pScreen;
    PictureScreenPtr		ps;
    int				i, j, len, total_bytes, rc;
    INT16			*aliases;
    char			*names;

    REQUEST_SIZE_MATCH(xRenderQueryFiltersReq);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;
    
    pScreen = pDrawable->pScreen;
    nbytesName = 0;
    nnames = 0;
    ps = GetPictureScreenIfSet(pScreen);
    if (ps)
    {
	for (i = 0; i < ps->nfilters; i++)
	    nbytesName += 1 + strlen (ps->filters[i].name);
	for (i = 0; i < ps->nfilterAliases; i++)
	    nbytesName += 1 + strlen (ps->filterAliases[i].alias);
	nnames = ps->nfilters + ps->nfilterAliases;
    }
    len = ((nnames + 1) >> 1) + bytes_to_int32(nbytesName);
    total_bytes = sizeof (xRenderQueryFiltersReply) + (len << 2);
    reply = (xRenderQueryFiltersReply *) malloc(total_bytes);
    if (!reply)
	return BadAlloc;
    aliases = (INT16 *) (reply + 1);
    names = (char *) (aliases + ((nnames + 1) & ~1));
    
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = len;
    reply->numAliases = nnames;
    reply->numFilters = nnames;
    if (ps)
    {

	/* fill in alias values */
	for (i = 0; i < ps->nfilters; i++)
	    aliases[i] = FilterAliasNone;
	for (i = 0; i < ps->nfilterAliases; i++)
	{
	    for (j = 0; j < ps->nfilters; j++)
		if (ps->filterAliases[i].filter_id == ps->filters[j].id)
		    break;
	    if (j == ps->nfilters)
	    {
		for (j = 0; j < ps->nfilterAliases; j++)
		    if (ps->filterAliases[i].filter_id == 
			ps->filterAliases[j].alias_id)
		    {
			break;
		    }
		if (j == ps->nfilterAliases)
		    j = FilterAliasNone;
		else
		    j = j + ps->nfilters;
	    }
	    aliases[i + ps->nfilters] = j;
	}

	/* fill in filter names */
	for (i = 0; i < ps->nfilters; i++)
	{
	    j = strlen (ps->filters[i].name);
	    *names++ = j;
	    strncpy (names, ps->filters[i].name, j);
	    names += j;
	}
	
	/* fill in filter alias names */
	for (i = 0; i < ps->nfilterAliases; i++)
	{
	    j = strlen (ps->filterAliases[i].alias);
	    *names++ = j;
	    strncpy (names, ps->filterAliases[i].alias, j);
	    names += j;
	}
    }

    if (client->swapped)
    {
	register int n;

	for (i = 0; i < reply->numAliases; i++)
	{
	    swaps (&aliases[i], n);
	}
    	swaps(&reply->sequenceNumber, n);
    	swapl(&reply->length, n);
	swapl(&reply->numAliases, n);
	swapl(&reply->numFilters, n);
    }
    WriteToClient(client, total_bytes, (char *) reply);
    free(reply);
    
    return Success;
}

static int
ProcRenderSetPictureFilter (ClientPtr client)
{
    REQUEST (xRenderSetPictureFilterReq);
    PicturePtr	pPicture;
    int		result;
    xFixed	*params;
    int		nparams;
    char	*name;
    
    REQUEST_AT_LEAST_SIZE (xRenderSetPictureFilterReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
    name = (char *) (stuff + 1);
    params = (xFixed *) (name + pad_to_int32(stuff->nbytes));
    nparams = ((xFixed *) stuff + client->req_len) - params;
    result = SetPictureFilter (pPicture, name, stuff->nbytes, params, nparams);
    return result;
}

static int
ProcRenderCreateAnimCursor (ClientPtr client)
{
    REQUEST(xRenderCreateAnimCursorReq);
    CursorPtr	    *cursors;
    CARD32	    *deltas;
    CursorPtr	    pCursor;
    int		    ncursor;
    xAnimCursorElt  *elt;
    int		    i;
    int		    ret;

    REQUEST_AT_LEAST_SIZE(xRenderCreateAnimCursorReq);
    LEGAL_NEW_RESOURCE(stuff->cid, client);
    if (client->req_len & 1)
	return BadLength;
    ncursor = (client->req_len - (bytes_to_int32(sizeof(xRenderCreateAnimCursorReq)))) >> 1;
    cursors = malloc(ncursor * (sizeof (CursorPtr) + sizeof (CARD32)));
    if (!cursors)
	return BadAlloc;
    deltas = (CARD32 *) (cursors + ncursor);
    elt = (xAnimCursorElt *) (stuff + 1);
    for (i = 0; i < ncursor; i++)
    {
	ret = dixLookupResourceByType((pointer *)(cursors + i), elt->cursor,
				      RT_CURSOR, client, DixReadAccess);
	if (ret != Success)
	{
	    free(cursors);
	    return ret;
	}
	deltas[i] = elt->delay;
	elt++;
    }
    ret = AnimCursorCreate (cursors, deltas, ncursor, &pCursor, client,
			    stuff->cid);
    free(cursors);
    if (ret != Success)
	return ret;
    
    if (AddResource (stuff->cid, RT_CURSOR, (pointer)pCursor))
	return Success;
    return BadAlloc;
}

static int
ProcRenderAddTraps (ClientPtr client)
{
    int		ntraps;
    PicturePtr	pPicture;
    REQUEST(xRenderAddTrapsReq);

    REQUEST_AT_LEAST_SIZE(xRenderAddTrapsReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess);
    if (!pPicture->pDrawable)
        return BadDrawable;
    ntraps = (client->req_len << 2) - sizeof (xRenderAddTrapsReq);
    if (ntraps % sizeof (xTrap))
	return BadLength;
    ntraps /= sizeof (xTrap);
    if (ntraps)
	AddTraps (pPicture,
		  stuff->xOff, stuff->yOff,
		  ntraps, (xTrap *) &stuff[1]);
    return Success;
}

static int ProcRenderCreateSolidFill(ClientPtr client)
{
    PicturePtr	    pPicture;
    int		    error = 0;
    REQUEST(xRenderCreateSolidFillReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateSolidFillReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    pPicture = CreateSolidPicture(stuff->pid, &stuff->color, &error);
    if (!pPicture)
	return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
		     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}

static int ProcRenderCreateLinearGradient (ClientPtr client)
{
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
    REQUEST(xRenderCreateLinearGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateLinearGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateLinearGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);

    pPicture = CreateLinearGradientPicture (stuff->pid, &stuff->p1, &stuff->p2,
                                            stuff->nStops, stops, colors, &error);
    if (!pPicture)
	return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
		     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}

static int ProcRenderCreateRadialGradient (ClientPtr client)
{
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
    REQUEST(xRenderCreateRadialGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateRadialGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);

    pPicture = CreateRadialGradientPicture (stuff->pid, &stuff->inner, &stuff->outer,
                                            stuff->inner_radius, stuff->outer_radius,
                                            stuff->nStops, stops, colors, &error);
    if (!pPicture)
	return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
		     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}

static int ProcRenderCreateConicalGradient (ClientPtr client)
{
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
    REQUEST(xRenderCreateConicalGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);

    pPicture = CreateConicalGradientPicture (stuff->pid, &stuff->center, stuff->angle,
                                             stuff->nStops, stops, colors, &error);
    if (!pPicture)
	return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
		     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
    return Success;
}


static int
ProcRenderDispatch (ClientPtr client)
{
    REQUEST(xReq);
    
    if (stuff->data < RenderNumberRequests)
	return (*ProcRenderVector[stuff->data]) (client);
    else
	return BadRequest;
}

static int
SProcRenderQueryVersion (ClientPtr client)
{
    register int n;
    REQUEST(xRenderQueryVersionReq);

    swaps(&stuff->length, n);
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
    return (*ProcRenderVector[stuff->renderReqType])(client);
}

static int
SProcRenderQueryPictFormats (ClientPtr client)
{
    register int n;
    REQUEST(xRenderQueryPictFormatsReq);
    swaps(&stuff->length, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryPictIndexValues (ClientPtr client)
{
    register int n;
    REQUEST(xRenderQueryPictIndexValuesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->format, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryDithers (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderCreatePicture (ClientPtr client)
{
    register int n;
    REQUEST(xRenderCreatePictureReq);
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->drawable, n);
    swapl(&stuff->format, n);
    swapl(&stuff->mask, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderChangePicture (ClientPtr client)
{
    register int n;
    REQUEST(xRenderChangePictureReq);
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swapl(&stuff->mask, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderSetPictureClipRectangles (ClientPtr client)
{
    register int n;
    REQUEST(xRenderSetPictureClipRectanglesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->xOrigin, n);
    swaps(&stuff->yOrigin, n);
    SwapRestS(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderFreePicture (ClientPtr client)
{
    register int n;
    REQUEST(xRenderFreePictureReq);
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderComposite (ClientPtr client)
{
    register int n;
    REQUEST(xRenderCompositeReq);
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->mask, n);
    swapl(&stuff->dst, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
    swaps(&stuff->xMask, n);
    swaps(&stuff->yMask, n);
    swaps(&stuff->xDst, n);
    swaps(&stuff->yDst, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderScale (ClientPtr client)
{
    register int n;
    REQUEST(xRenderScaleReq);
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->dst, n);
    swapl(&stuff->colorScale, n);
    swapl(&stuff->alphaScale, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
    swaps(&stuff->xDst, n);
    swaps(&stuff->yDst, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTrapezoids (ClientPtr client)
{
    register int n;
    REQUEST(xRenderTrapezoidsReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriangles (ClientPtr client)
{
    register int n;
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriStrip (ClientPtr client)
{
    register int n;
    REQUEST(xRenderTriStripReq);

    REQUEST_AT_LEAST_SIZE(xRenderTriStripReq);
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriFan (ClientPtr client)
{
    register int n;
    REQUEST(xRenderTriFanReq);

    REQUEST_AT_LEAST_SIZE(xRenderTriFanReq);
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderColorTrapezoids (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderColorTriangles (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderTransform (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderCreateGlyphSet (ClientPtr client)
{
    register int n;
    REQUEST(xRenderCreateGlyphSetReq);
    swaps(&stuff->length, n);
    swapl(&stuff->gsid, n);
    swapl(&stuff->format, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderReferenceGlyphSet (ClientPtr client)
{
    register int n;
    REQUEST(xRenderReferenceGlyphSetReq);
    swaps(&stuff->length, n);
    swapl(&stuff->gsid, n);
    swapl(&stuff->existing, n);
    return (*ProcRenderVector[stuff->renderReqType])  (client);
}

static int
SProcRenderFreeGlyphSet (ClientPtr client)
{
    register int n;
    REQUEST(xRenderFreeGlyphSetReq);
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddGlyphs (ClientPtr client)
{
    register int n;
    register int i;
    CARD32  *gids;
    void    *end;
    xGlyphInfo *gi;
    REQUEST(xRenderAddGlyphsReq);
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
    swapl(&stuff->nglyphs, n);
    if (stuff->nglyphs & 0xe0000000)
	return BadLength;
    end = (CARD8 *) stuff + (client->req_len << 2);
    gids = (CARD32 *) (stuff + 1);
    gi = (xGlyphInfo *) (gids + stuff->nglyphs);
    if ((char *) end - (char *) (gids + stuff->nglyphs) < 0)
	return BadLength;
    if ((char *) end - (char *) (gi + stuff->nglyphs) < 0)
	return BadLength;
    for (i = 0; i < stuff->nglyphs; i++)
    {
	swapl (&gids[i], n);
	swaps (&gi[i].width, n);
	swaps (&gi[i].height, n);
	swaps (&gi[i].x, n);
	swaps (&gi[i].y, n);
	swaps (&gi[i].xOff, n);
	swaps (&gi[i].yOff, n);
    }
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddGlyphsFromPicture (ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderFreeGlyphs (ClientPtr client)
{
    register int n;
    REQUEST(xRenderFreeGlyphsReq);
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCompositeGlyphs (ClientPtr client)
{
    register int n;
    xGlyphElt	*elt;
    CARD8	*buffer;
    CARD8	*end;
    int		space;
    int		i;
    int		size;
    
    REQUEST(xRenderCompositeGlyphsReq);
    
    switch (stuff->renderReqType) {
    default:			    size = 1; break;
    case X_RenderCompositeGlyphs16: size = 2; break;
    case X_RenderCompositeGlyphs32: size = 4; break;
    }
	    
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->dst, n);
    swapl(&stuff->maskFormat, n);
    swapl(&stuff->glyphset, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
    buffer = (CARD8 *) (stuff + 1);
    end = (CARD8 *) stuff + (client->req_len << 2);
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	swaps (&elt->deltax, n);
	swaps (&elt->deltay, n);
	
	i = elt->len;
	if (i == 0xff)
	{
	    swapl (buffer, n);
	    buffer += 4;
	}
	else
	{
	    space = size * i;
	    switch (size) {
	    case 1:
		buffer += i;
		break;
	    case 2:
		while (i--)
		{
		    swaps (buffer, n);
		    buffer += 2;
		}
		break;
	    case 4:
		while (i--)
		{
		    swapl (buffer, n);
		    buffer += 4;
		}
		break;
	    }
	    if (space & 3)
		buffer += 4 - (space & 3);
	}
    }
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderFillRectangles (ClientPtr client)
{
    register int n;
    REQUEST(xRenderFillRectanglesReq);

    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->dst, n);
    swaps(&stuff->color.red, n);
    swaps(&stuff->color.green, n);
    swaps(&stuff->color.blue, n);
    swaps(&stuff->color.alpha, n);
    SwapRestS(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
    
static int
SProcRenderCreateCursor (ClientPtr client)
{
    register int n;
    REQUEST(xRenderCreateCursorReq);
    REQUEST_SIZE_MATCH (xRenderCreateCursorReq);
    
    swaps(&stuff->length, n);
    swapl(&stuff->cid, n);
    swapl(&stuff->src, n);
    swaps(&stuff->x, n);
    swaps(&stuff->y, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
    
static int
SProcRenderSetPictureTransform (ClientPtr client)
{
    register int n;
    REQUEST(xRenderSetPictureTransformReq);
    REQUEST_SIZE_MATCH(xRenderSetPictureTransformReq);

    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swapl(&stuff->transform.matrix11, n);
    swapl(&stuff->transform.matrix12, n);
    swapl(&stuff->transform.matrix13, n);
    swapl(&stuff->transform.matrix21, n);
    swapl(&stuff->transform.matrix22, n);
    swapl(&stuff->transform.matrix23, n);
    swapl(&stuff->transform.matrix31, n);
    swapl(&stuff->transform.matrix32, n);
    swapl(&stuff->transform.matrix33, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryFilters (ClientPtr client)
{
    register int n;
    REQUEST (xRenderQueryFiltersReq);
    REQUEST_SIZE_MATCH (xRenderQueryFiltersReq);

    swaps(&stuff->length, n);
    swapl(&stuff->drawable, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
    
static int
SProcRenderSetPictureFilter (ClientPtr client)
{
    register int n;
    REQUEST (xRenderSetPictureFilterReq);
    REQUEST_AT_LEAST_SIZE (xRenderSetPictureFilterReq);

    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->nbytes, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
    
static int
SProcRenderCreateAnimCursor (ClientPtr client)
{
    register int n;
    REQUEST (xRenderCreateAnimCursorReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateAnimCursorReq);

    swaps(&stuff->length, n);
    swapl(&stuff->cid, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddTraps (ClientPtr client)
{
    register int n;
    REQUEST (xRenderAddTrapsReq);
    REQUEST_AT_LEAST_SIZE (xRenderAddTrapsReq);

    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->xOff, n);
    swaps(&stuff->yOff, n);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateSolidFill(ClientPtr client)
{
    register int n;
    REQUEST (xRenderCreateSolidFillReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateSolidFillReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swaps(&stuff->color.alpha, n);
    swaps(&stuff->color.red, n);
    swaps(&stuff->color.green, n);
    swaps(&stuff->color.blue, n);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static void swapStops(void *stuff, int num)
{
    int i, n;
    CARD32 *stops;
    CARD16 *colors;
    stops = (CARD32 *)(stuff);
    for (i = 0; i < num; ++i) {
        swapl(stops, n);
        ++stops;
    }
    colors = (CARD16 *)(stops);
    for (i = 0; i < 4*num; ++i) {
        swaps(colors, n);
        ++colors;
    }
}

static int
SProcRenderCreateLinearGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateLinearGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateLinearGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->p1.x, n);
    swapl(&stuff->p1.y, n);
    swapl(&stuff->p2.x, n);
    swapl(&stuff->p2.y, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateLinearGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateConicalGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateConicalGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateConicalGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->center.x, n);
    swapl(&stuff->center.y, n);
    swapl(&stuff->angle, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderDispatch (ClientPtr client)
{
    REQUEST(xReq);
    
    if (stuff->data < RenderNumberRequests)
	return (*SProcRenderVector[stuff->data]) (client);
    else
	return BadRequest;
}

#ifdef PANORAMIX
#define VERIFY_XIN_PICTURE(pPicture, pid, client, mode) {\
    int rc = dixLookupResourceByType((pointer *)&(pPicture), pid,\
                                     XRT_PICTURE, client, mode);\
    if (rc != Success)\
	return rc;\
}

#define VERIFY_XIN_ALPHA(pPicture, pid, client, mode) {\
    if (pid == None) \
	pPicture = 0; \
    else { \
	VERIFY_XIN_PICTURE(pPicture, pid, client, mode); \
    } \
} \

int	    (*PanoramiXSaveRenderVector[RenderNumberRequests])(ClientPtr);

static int
PanoramiXRenderCreatePicture (ClientPtr client)
{
    REQUEST(xRenderCreatePictureReq);
    PanoramiXRes    *refDraw, *newPict;
    int		    result, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);
    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;
    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    
    if (refDraw->type == XRT_WINDOW &&
	stuff->drawable == screenInfo.screens[0]->root->drawable.id)
    {
	newPict->u.pict.root = TRUE;
    }
    else
	newPict->u.pict.root = FALSE;
    
    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	stuff->drawable = refDraw->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreatePicture]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else 
	free(newPict);

    return result;
}

static int
PanoramiXRenderChangePicture (ClientPtr client)
{
    PanoramiXRes    *pict;
    int		    result = Success, j;
    REQUEST(xRenderChangePictureReq);

    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);
    
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderChangePicture]) (client);
        if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureClipRectangles (ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int		    result = Success, j;
    PanoramiXRes    *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
    
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles]) (client);
        if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureTransform (ClientPtr client)
{
    REQUEST(xRenderSetPictureTransformReq);
    int		    result = Success, j;
    PanoramiXRes    *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureTransformReq);
    
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureTransform]) (client);
        if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureFilter (ClientPtr client)
{
    REQUEST(xRenderSetPictureFilterReq);
    int		    result = Success, j;
    PanoramiXRes    *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureFilterReq);
    
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureFilter]) (client);
        if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderFreePicture (ClientPtr client)
{
    PanoramiXRes *pict;
    int         result = Success, j;
    REQUEST(xRenderFreePictureReq);

    REQUEST_SIZE_MATCH(xRenderFreePictureReq);

    client->errorValue = stuff->picture;

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixDestroyAccess);
    

    FOR_NSCREENS_BACKWARD(j) {
	stuff->picture = pict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderFreePicture]) (client);
	if(result != Success) break;
    }

    /* Since ProcRenderFreePicture is using FreeResource, it will free
	our resource for us on the last pass through the loop above */
 
    return result;
}

static int
PanoramiXRenderComposite (ClientPtr client)
{
    PanoramiXRes	*src, *msk, *dst;
    int			result = Success, j;
    xRenderCompositeReq	orig;
    REQUEST(xRenderCompositeReq);

    REQUEST_SIZE_MATCH(xRenderCompositeReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_ALPHA (msk, stuff->mask, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);
    
    orig = *stuff;
    
    FOR_NSCREENS_FORWARD(j) {
	stuff->src = src->info[j].id;
	if (src->u.pict.root)
	{
	    stuff->xSrc = orig.xSrc - screenInfo.screens[j]->x;
	    stuff->ySrc = orig.ySrc - screenInfo.screens[j]->y;
	}
	stuff->dst = dst->info[j].id;
	if (dst->u.pict.root)
	{
	    stuff->xDst = orig.xDst - screenInfo.screens[j]->x;
	    stuff->yDst = orig.yDst - screenInfo.screens[j]->y;
	}
	if (msk)
	{
	    stuff->mask = msk->info[j].id;
	    if (msk->u.pict.root)
	    {
		stuff->xMask = orig.xMask - screenInfo.screens[j]->x;
		stuff->yMask = orig.yMask - screenInfo.screens[j]->y;
	    }
	}
	result = (*PanoramiXSaveRenderVector[X_RenderComposite]) (client);
	if(result != Success) break;
    }

    return result;
}

static int
PanoramiXRenderCompositeGlyphs (ClientPtr client)
{
    PanoramiXRes    *src, *dst;
    int		    result = Success, j;
    REQUEST(xRenderCompositeGlyphsReq);
    xGlyphElt	    origElt, *elt;
    INT16	    xSrc, ySrc;

    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    if (client->req_len << 2 >= (sizeof (xRenderCompositeGlyphsReq) +
				 sizeof (xGlyphElt)))
    {
	elt = (xGlyphElt *) (stuff + 1);
	origElt = *elt;
	xSrc = stuff->xSrc;
	ySrc = stuff->ySrc;
	FOR_NSCREENS_FORWARD(j) {
	    stuff->src = src->info[j].id;
	    if (src->u.pict.root)
	    {
		stuff->xSrc = xSrc - screenInfo.screens[j]->x;
		stuff->ySrc = ySrc - screenInfo.screens[j]->y;
	    }
	    stuff->dst = dst->info[j].id;
	    if (dst->u.pict.root)
	    {
		elt->deltax = origElt.deltax - screenInfo.screens[j]->x;
		elt->deltay = origElt.deltay - screenInfo.screens[j]->y;
	    }
	    result = (*PanoramiXSaveRenderVector[stuff->renderReqType]) (client);
	    if(result != Success) break;
	}
    }

    return result;
}

static int
PanoramiXRenderFillRectangles (ClientPtr client)
{
    PanoramiXRes    *dst;
    int		    result = Success, j;
    REQUEST(xRenderFillRectanglesReq);
    char	    *extra;
    int		    extra_len;

    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);
    extra_len = (client->req_len << 2) - sizeof (xRenderFillRectanglesReq);
    if (extra_len &&
	(extra = (char *) malloc(extra_len)))
    {
	memcpy (extra, stuff + 1, extra_len);
	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root)
	    {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xRectangle	*rects = (xRectangle *) (stuff + 1);
		    int		i = extra_len / sizeof (xRectangle);

		    while (i--)
		    {
			rects->x -= x_off;
			rects->y -= y_off;
			rects++;
		    }
		}
	    }
	    stuff->dst = dst->info[j].id;
	    result = (*PanoramiXSaveRenderVector[X_RenderFillRectangles]) (client);
	    if(result != Success) break;
	}
	free(extra);
    }

    return result;
}

static int
PanoramiXRenderTrapezoids(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderTrapezoidsReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTrapezoidsReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTrapezoidsReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xTrapezoid  *trap = (xTrapezoid *) (stuff + 1);
		    int         i = extra_len / sizeof (xTrapezoid);

		    while (i--) {
			trap->top -= y_off;
			trap->bottom -= y_off;
			trap->left.p1.x -= x_off;
			trap->left.p1.y -= y_off;
			trap->left.p2.x -= x_off;
			trap->left.p2.y -= y_off;
			trap->right.p1.x -= x_off;
			trap->right.p1.y -= y_off;
			trap->right.p2.x -= x_off;
			trap->right.p2.y -= y_off;
			trap++;
		    }
		}
	    }
	    
            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTrapezoids]) (client);

	    if(result != Success) break;
	}
	
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriangles(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderTrianglesReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTrianglesReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTrianglesReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xTriangle  *tri = (xTriangle *) (stuff + 1);
		    int         i = extra_len / sizeof (xTriangle);

		    while (i--) {
			tri->p1.x -= x_off;
			tri->p1.y -= y_off;
			tri->p2.x -= x_off;
			tri->p2.y -= y_off;
			tri->p3.x -= x_off;
			tri->p3.y -= y_off;
			tri++;
		    }
		}
	    }
	    
            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriangles]) (client);

	    if(result != Success) break;
	}
	
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriStrip(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderTriStripReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTriStripReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTriStripReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xPointFixed  *fixed = (xPointFixed *) (stuff + 1);
		    int         i = extra_len / sizeof (xPointFixed);

		    while (i--) {
			fixed->x -= x_off;
			fixed->y -= y_off;
			fixed++;
		    }
		}
	    }
	    
            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriStrip]) (client);

	    if(result != Success) break;
	}
	
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriFan(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderTriFanReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTriFanReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTriFanReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xPointFixed  *fixed = (xPointFixed *) (stuff + 1);
		    int         i = extra_len / sizeof (xPointFixed);

		    while (i--) {
			fixed->x -= x_off;
			fixed->y -= y_off;
			fixed++;
		    }
		}
	    }
	    
            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriFan]) (client);

	    if(result != Success) break;
	}
	
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderAddTraps (ClientPtr client)
{
    PanoramiXRes    *picture;
    int		    result = Success, j;
    REQUEST(xRenderAddTrapsReq);
    char	    *extra;
    int		    extra_len;
    INT16    	    x_off, y_off;

    REQUEST_AT_LEAST_SIZE (xRenderAddTrapsReq);
    VERIFY_XIN_PICTURE (picture, stuff->picture, client, DixWriteAccess);
    extra_len = (client->req_len << 2) - sizeof (xRenderAddTrapsReq);
    if (extra_len &&
	(extra = (char *) malloc(extra_len)))
    {
	memcpy (extra, stuff + 1, extra_len);
	x_off = stuff->xOff;
	y_off = stuff->yOff;
	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    stuff->picture = picture->info[j].id;
	    
	    if (picture->u.pict.root)
	    {
		stuff->xOff = x_off + screenInfo.screens[j]->x;
		stuff->yOff = y_off + screenInfo.screens[j]->y;
	    }
	    result = (*PanoramiXSaveRenderVector[X_RenderAddTraps]) (client);
	    if(result != Success) break;
	}
	free(extra);
    }

    return result;
}

static int
PanoramiXRenderCreateSolidFill (ClientPtr client)
{
    REQUEST(xRenderCreateSolidFillReq);
    PanoramiXRes    *newPict;
    int		    result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateSolidFillReq);

    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;
	
    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateSolidFill]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
	free(newPict);

    return result;
}

static int
PanoramiXRenderCreateLinearGradient (ClientPtr client)
{
    REQUEST(xRenderCreateLinearGradientReq);
    PanoramiXRes    *newPict;
    int		    result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateLinearGradientReq);

    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateLinearGradient]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
	free(newPict);

    return result;
}

static int
PanoramiXRenderCreateRadialGradient (ClientPtr client)
{
    REQUEST(xRenderCreateRadialGradientReq);
    PanoramiXRes    *newPict;
    int		    result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateRadialGradientReq);

    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateRadialGradient]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
	free(newPict);

    return result;
}

static int
PanoramiXRenderCreateConicalGradient (ClientPtr client)
{
    REQUEST(xRenderCreateConicalGradientReq);
    PanoramiXRes    *newPict;
    int		    result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);

    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateConicalGradient]) (client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
	free(newPict);

    return result;
}

void
PanoramiXRenderInit (void)
{
    int	    i;
    
    XRT_PICTURE = CreateNewResourceType (XineramaDeleteResource,
					 "XineramaPicture");
    if (RenderErrBase)
	SetResourceTypeErrorValue(XRT_PICTURE, RenderErrBase + BadPicture);
    for (i = 0; i < RenderNumberRequests; i++)
	PanoramiXSaveRenderVector[i] = ProcRenderVector[i];
    /*
     * Stuff in Xinerama aware request processing hooks
     */
    ProcRenderVector[X_RenderCreatePicture] = PanoramiXRenderCreatePicture;
    ProcRenderVector[X_RenderChangePicture] = PanoramiXRenderChangePicture;
    ProcRenderVector[X_RenderSetPictureTransform] = PanoramiXRenderSetPictureTransform;
    ProcRenderVector[X_RenderSetPictureFilter] = PanoramiXRenderSetPictureFilter;
    ProcRenderVector[X_RenderSetPictureClipRectangles] = PanoramiXRenderSetPictureClipRectangles;
    ProcRenderVector[X_RenderFreePicture] = PanoramiXRenderFreePicture;
    ProcRenderVector[X_RenderComposite] = PanoramiXRenderComposite;
    ProcRenderVector[X_RenderCompositeGlyphs8] = PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs16] = PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs32] = PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderFillRectangles] = PanoramiXRenderFillRectangles;

    ProcRenderVector[X_RenderTrapezoids] = PanoramiXRenderTrapezoids;
    ProcRenderVector[X_RenderTriangles] = PanoramiXRenderTriangles;
    ProcRenderVector[X_RenderTriStrip] = PanoramiXRenderTriStrip;
    ProcRenderVector[X_RenderTriFan] = PanoramiXRenderTriFan;
    ProcRenderVector[X_RenderAddTraps] = PanoramiXRenderAddTraps;

    ProcRenderVector[X_RenderCreateSolidFill] = PanoramiXRenderCreateSolidFill;
    ProcRenderVector[X_RenderCreateLinearGradient] = PanoramiXRenderCreateLinearGradient;
    ProcRenderVector[X_RenderCreateRadialGradient] = PanoramiXRenderCreateRadialGradient;
    ProcRenderVector[X_RenderCreateConicalGradient] = PanoramiXRenderCreateConicalGradient;
}

void
PanoramiXRenderReset (void)
{
    int	    i;
    for (i = 0; i < RenderNumberRequests; i++)
	ProcRenderVector[i] = PanoramiXSaveRenderVector[i];
    RenderErrBase = 0;
}

#endif	/* PANORAMIX */
xkb
input
xtest
list
misc
fixes
/**
 * Copyright © 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <X11/X.h>
#include <xfixesint.h>
#include <X11/extensions/xfixeswire.h>

static void
_fixes_test_direction(struct PointerBarrier *barrier, int d[4], int permitted)
{
    BOOL blocking;
    int i, j;
    int dir = barrier_get_direction(d[0], d[1], d[2], d[3]);

    barrier->directions = 0;
    blocking = barrier_is_blocking_direction(barrier, dir);
    assert(blocking);

    for (j = 0; j <= BarrierNegativeY; j++)
    {
        for (i = 0; i <= BarrierNegativeY; i++)
        {
            barrier->directions |= 1 << i;
            blocking = barrier_is_blocking_direction(barrier, dir);
            assert((barrier->directions & permitted) == permitted ? !blocking : blocking);
        }
    }

}

static void
fixes_pointer_barrier_direction_test(void)
{
    struct PointerBarrier barrier;

    int x = 100;
    int y = 100;

    int directions[8][4] = {
        { x, y, x, y + 100},            /* S  */
        { x + 50, y, x - 50, y + 100},  /* SW */
        { x + 100, y, x, y},            /* W  */
        { x + 100, y + 50, x, y - 50},  /* NW */
        { x, y + 100, x, y},            /* N  */
        { x - 50, y + 100, x + 50, y},  /* NE */
        { x, y, x + 100, y},            /* E  */
        { x, y - 50, x + 100, y + 50},  /* SE */
    };

    barrier.x1 = x;
    barrier.x2 = x;
    barrier.y1 = y - 50;
    barrier.y2 = y + 49;


    _fixes_test_direction(&barrier, directions[0], BarrierPositiveY);
    _fixes_test_direction(&barrier, directions[1], BarrierPositiveY | BarrierNegativeX);
    _fixes_test_direction(&barrier, directions[2], BarrierNegativeX);
    _fixes_test_direction(&barrier, directions[3], BarrierNegativeY | BarrierNegativeX);
    _fixes_test_direction(&barrier, directions[4], BarrierNegativeY);
    _fixes_test_direction(&barrier, directions[5], BarrierPositiveX | BarrierNegativeY);
    _fixes_test_direction(&barrier, directions[6], BarrierPositiveX);
    _fixes_test_direction(&barrier, directions[7], BarrierPositiveY | BarrierPositiveX);


}


static void
fixes_pointer_barriers_test(void)
{
    struct PointerBarrier barrier;
    int x1, y1, x2, y2;
    double distance;

    int x = 100;
    int y = 100;

    /* vert barrier */
    barrier.x1 = x;
    barrier.x2 = x;
    barrier.y1 = y - 50;
    barrier.y2 = y + 50;

    /* across at half-way */
    x1 = x + 1;
    x2 = x - 1;
    y1 = y;
    y2 = y;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));
    assert(distance == 1);

    /* definitely not across */
    x1 = x + 10;
    x2 = x + 5;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across, but outside of y range */
    x1 = x + 1;
    x2 = x -1;
    y1 = y + 100;
    y2 = y + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across, diagonally */
    x1 = x + 5;
    x2 = x - 5;
    y1 = y + 5;
    y2 = y - 5;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across but outside boundary, diagonally */
    x1 = x + 5;
    x2 = x - 5;
    y1 = y + 100;
    y2 = y + 50;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → blocking */
    x1 = x;
    x2 = x - 1;
    y1 = y;
    y2 = y;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → not blocking, positive */
    x1 = x;
    x2 = x + 1;
    y1 = y;
    y2 = y;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → not blocking, negative */
    x1 = x - 1;
    x2 = x - 2;
    y1 = y;
    y2 = y;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: endpoint of movement on barrier → blocking */
    x1 = x + 1;
    x2 = x;
    y1 = y;
    y2 = y;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* startpoint on barrier but outside y range */
    x1 = x;
    x2 = x - 1;
    y1 = y + 100;
    y2 = y + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* endpoint on barrier but outside y range */
    x1 = x + 1;
    x2 = x;
    y1 = y + 100;
    y2 = y + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));


    /* horizontal barrier */
    barrier.x1 = x - 50;
    barrier.x2 = x + 50;
    barrier.y1 = y;
    barrier.y2 = y;

    /* across at half-way */
    x1 = x;
    x2 = x;
    y1 = y - 1;
    y2 = y + 1;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* definitely not across */
    y1 = y + 10;
    y2 = y + 5;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across, but outside of y range */
    x1 = x + 100;
    x2 = x + 100;
    y1 = y + 1;
    y2 = y -1;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across, diagonally */
    y1 = y + 5;
    y2 = y - 5;
    x1 = x + 5;
    x2 = x - 5;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* across but outside boundary, diagonally */
    y1 = y + 5;
    y2 = y - 5;
    x1 = x + 100;
    x2 = x + 50;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → blocking */
    y1 = y;
    y2 = y - 1;
    x1 = x;
    x2 = x;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → not blocking, positive */
    y1 = y;
    y2 = y + 1;
    x1 = x;
    x2 = x;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: startpoint of movement on barrier → not blocking, negative */
    y1 = y - 1;
    y2 = y - 2;
    x1 = x;
    x2 = x;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* edge case: endpoint of movement on barrier → blocking */
    y1 = y + 1;
    y2 = y;
    x1 = x;
    x2 = x;
    assert(barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* startpoint on barrier but outside y range */
    y1 = y;
    y2 = y - 1;
    x1 = x + 100;
    x2 = x + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

    /* endpoint on barrier but outside y range */
    y1 = y + 1;
    y2 = y;
    x1 = x + 100;
    x2 = x + 100;
    assert(!barrier_is_blocking(&barrier, x1, y1, x2, y2, &distance));

}

static void fixes_pointer_barrier_clamp_test(void)
{
    struct PointerBarrier barrier;

    int x = 100;
    int y = 100;

    int cx, cy; /* clamped */

    /* vert barrier */
    barrier.x1 = x;
    barrier.x2 = x;
    barrier.y1 = y - 50;
    barrier.y2 = y + 49;
    barrier.directions = 0;

    cx = INT_MAX;
    cy = INT_MAX;
    barrier_clamp_to_barrier(&barrier, BarrierPositiveX, &cx, &cy);
    assert(cx == barrier.x1 - 1);
    assert(cy == INT_MAX);

    cx = 0;
    cy = INT_MAX;
    barrier_clamp_to_barrier(&barrier, BarrierNegativeX, &cx, &cy);
    assert(cx == barrier.x1);
    assert(cy == INT_MAX);

    /* horiz barrier */
    barrier.x1 = x - 50;
    barrier.x2 = x + 49;
    barrier.y1 = y;
    barrier.y2 = y;
    barrier.directions = 0;

    cx = INT_MAX;
    cy = INT_MAX;
    barrier_clamp_to_barrier(&barrier, BarrierPositiveY, &cx, &cy);
    assert(cx == INT_MAX);
    assert(cy == barrier.y1 - 1);

    cx = INT_MAX;
    cy = 0;
    barrier_clamp_to_barrier(&barrier, BarrierNegativeY, &cx, &cy);
    assert(cx == INT_MAX);
    assert(cy == barrier.y1);
}

int main(int argc, char** argv)
{

    fixes_pointer_barriers_test();
    fixes_pointer_barrier_direction_test();
    fixes_pointer_barrier_clamp_test();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include <X11/X.h>
#include "misc.h"
#include "resource.h"
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/Xatom.h>
#include "windowstr.h"
#include "inputstr.h"
#include "eventconvert.h"
#include "exevents.h"
#include "exglobals.h"
#include "dixgrabs.h"
#include "eventstr.h"
#include "inpututils.h"
#include "assert.h"

/**
 * Init a device with axes.
 * Verify values set on the device.
 *
 * Result: All axes set to default values (usually 0).
 */
static void dix_init_valuators(void)
{
    DeviceIntRec dev;
    ValuatorClassPtr val;
    const int num_axes = 2;
    int i;
    Atom atoms[MAX_VALUATORS] = { 0 };


    memset(&dev, 0, sizeof(DeviceIntRec));
    dev.type = MASTER_POINTER; /* claim it's a master to stop ptracccel */

    assert(InitValuatorClassDeviceStruct(NULL, 0, atoms, 0, 0) == FALSE);
    assert(InitValuatorClassDeviceStruct(&dev, num_axes, atoms, 0, Absolute));

    val = dev.valuator;
    assert(val);
    assert(val->numAxes == num_axes);
    assert(val->numMotionEvents == 0);
    assert(val->axisVal);

    for (i = 0; i < num_axes; i++)
    {
        assert(val->axisVal[i] == 0);
        assert(val->axes->min_value == NO_AXIS_LIMITS);
        assert(val->axes->max_value == NO_AXIS_LIMITS);
        assert(val->axes->mode == Absolute);
    }

    assert(dev.last.numValuators == num_axes);
}

/* just check the known success cases, and that error cases set the client's
 * error value correctly. */
static void dix_check_grab_values(void)
{
    ClientRec client;
    GrabParameters param;
    int rc;

    memset(&client, 0, sizeof(client));

    param.grabtype = GRABTYPE_CORE;
    param.this_device_mode = GrabModeSync;
    param.other_devices_mode = GrabModeSync;
    param.modifiers = AnyModifier;
    param.ownerEvents = FALSE;

    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.this_device_mode = GrabModeAsync;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.this_device_mode = GrabModeAsync + 1;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.this_device_mode);
    assert(client.errorValue == GrabModeAsync + 1);

    param.this_device_mode = GrabModeSync;
    param.other_devices_mode = GrabModeAsync;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.other_devices_mode = GrabModeAsync + 1;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.other_devices_mode);
    assert(client.errorValue == GrabModeAsync + 1);

    param.other_devices_mode = GrabModeSync;

    param.modifiers = 1 << 13;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.modifiers);
    assert(client.errorValue == (1 << 13));


    param.modifiers = AnyModifier;
    param.ownerEvents = TRUE;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.ownerEvents = 3;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.ownerEvents);
    assert(client.errorValue == 3);
}


/**
 * Convert various internal events to the matching core event and verify the
 * parameters.
 */
static void dix_event_to_core(int type)
{
    DeviceEvent ev;
    xEvent *core;
    int time;
    int x, y;
    int rc;
    int state;
    int detail;
    int count;
    const int ROOT_WINDOW_ID = 0x100;

    /* EventToCore memsets the event to 0 */
#define test_event() \
    assert(rc == Success); \
    assert(core); \
    assert(count == 1); \
    assert(core->u.u.type == type); \
    assert(core->u.u.detail == detail); \
    assert(core->u.keyButtonPointer.time == time); \
    assert(core->u.keyButtonPointer.rootX == x); \
    assert(core->u.keyButtonPointer.rootY == y); \
    assert(core->u.keyButtonPointer.state == state); \
    assert(core->u.keyButtonPointer.eventX == 0); \
    assert(core->u.keyButtonPointer.eventY == 0); \
    assert(core->u.keyButtonPointer.root == ROOT_WINDOW_ID); \
    assert(core->u.keyButtonPointer.event == 0); \
    assert(core->u.keyButtonPointer.child == 0); \
    assert(core->u.keyButtonPointer.sameScreen == FALSE);

    x = 0;
    y = 0;
    time = 12345;
    state = 0;
    detail = 0;

    ev.header   = 0xFF;
    ev.length   = sizeof(DeviceEvent);
    ev.time     = time;
    ev.root_y   = x;
    ev.root_x   = y;
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    ev.root     = ROOT_WINDOW_ID;
    ev.corestate = state;
    ev.detail.key = detail;

    ev.type = type;
    ev.detail.key = 0;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    x = 1;
    y = 2;
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    x = 0x7FFF;
    y = 0x7FFF;
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    x = 0x8000; /* too high */
    y = 0x8000; /* too high */
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    assert(rc == Success);
    assert(core);
    assert(count == 1);
    assert(core->u.keyButtonPointer.rootX != x);
    assert(core->u.keyButtonPointer.rootY != y);

    x = 0x7FFF;
    y = 0x7FFF;
    ev.root_x = x;
    ev.root_y = y;
    time = 0;
    ev.time = time;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    detail = 1;
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    detail = 0xFF; /* highest value */
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    detail = 0xFFF; /* too big */
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    assert(rc == BadMatch);

    detail = 0xFF; /* too big */
    ev.detail.key = detail;
    state = 0xFFFF; /* highest value */
    ev.corestate = state;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    test_event();

    state = 0x10000; /* too big */
    ev.corestate = state;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    assert(rc == Success);
    assert(core);
    assert(count == 1);
    assert(core->u.keyButtonPointer.state != state);
    assert(core->u.keyButtonPointer.state == (state & 0xFFFF));

#undef test_event
}

static void dix_event_to_core_fail(int evtype, int expected_rc)
{
    DeviceEvent ev;
    xEvent *core;
    int rc;
    int count;

    ev.header   = 0xFF;
    ev.length   = sizeof(DeviceEvent);

    ev.type     = evtype;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
    assert(rc == expected_rc);
}

static void dix_event_to_core_conversion(void)
{
    dix_event_to_core_fail(0, BadImplementation);
    dix_event_to_core_fail(1, BadImplementation);
    dix_event_to_core_fail(ET_ProximityOut + 1, BadImplementation);
    dix_event_to_core_fail(ET_ProximityIn, BadMatch);
    dix_event_to_core_fail(ET_ProximityOut, BadMatch);

    dix_event_to_core(ET_KeyPress);
    dix_event_to_core(ET_KeyRelease);
    dix_event_to_core(ET_ButtonPress);
    dix_event_to_core(ET_ButtonRelease);
    dix_event_to_core(ET_Motion);
}

static void
_dix_test_xi_convert(DeviceEvent *ev, int expected_rc, int expected_count)
{
    xEvent *xi;
    int count = 0;
    int rc;

    rc = EventToXI((InternalEvent*)ev, &xi, &count);
    assert(rc == expected_rc);
    assert(count >= expected_count);
    if (count > 0){
        deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer*)xi;
        assert(kbp->type == IEventBase + ev->type);
        assert(kbp->detail == ev->detail.key);
        assert(kbp->time == ev->time);
        assert((kbp->deviceid & ~MORE_EVENTS) == ev->deviceid);
        assert(kbp->root_x == ev->root_x);
        assert(kbp->root_y == ev->root_y);
        assert(kbp->state == ev->corestate);
        assert(kbp->event_x == 0);
        assert(kbp->event_y == 0);
        assert(kbp->root == ev->root);
        assert(kbp->event == 0);
        assert(kbp->child == 0);
        assert(kbp->same_screen == FALSE);

        while (--count > 0) {
            deviceValuator *v = (deviceValuator*)&xi[count];
            assert(v->type == DeviceValuator);
            assert(v->num_valuators <= 6);
        }


        free(xi);
    }
}

/**
 * This tests for internal event → XI1 event conversion
 * - all conversions should generate the right XI event type
 * - right number of events generated
 * - extra events are valuators
 */
static void dix_event_to_xi1_conversion(void)
{
    DeviceEvent ev = {0};
    int time;
    int x, y;
    int state;
    int detail;
    const int ROOT_WINDOW_ID = 0x100;
    int deviceid;

    IEventBase = 80;
    DeviceValuator      = IEventBase - 1;
    DeviceKeyPress      = IEventBase + ET_KeyPress;
    DeviceKeyRelease    = IEventBase + ET_KeyRelease;
    DeviceButtonPress   = IEventBase + ET_ButtonPress;
    DeviceButtonRelease = IEventBase + ET_ButtonRelease;
    DeviceMotionNotify  = IEventBase + ET_Motion;
    DeviceFocusIn       = IEventBase + ET_FocusIn;
    DeviceFocusOut      = IEventBase + ET_FocusOut;
    ProximityIn         = IEventBase + ET_ProximityIn;
    ProximityOut        = IEventBase + ET_ProximityOut;

    /* EventToXI callocs */
    x = 0;
    y = 0;
    time = 12345;
    state = 0;
    detail = 0;
    deviceid = 4;

    ev.header   = 0xFF;

    ev.header           = 0xFF;
    ev.length           = sizeof(DeviceEvent);
    ev.time             = time;
    ev.root_y           = x;
    ev.root_x           = y;
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    ev.root             = ROOT_WINDOW_ID;
    ev.corestate        = state;
    ev.detail.key       = detail;
    ev.deviceid         = deviceid;

    /* test all types for bad match */
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, Success, 1);

    /* No axes */
    ClearBit(ev.valuators.mask, 0);
    ClearBit(ev.valuators.mask, 1);
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, BadMatch, 0);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, BadMatch, 0);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, BadMatch, 0);

    /* more than 6 axes → 2 valuator events */
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    SetBit(ev.valuators.mask, 2);
    SetBit(ev.valuators.mask, 3);
    SetBit(ev.valuators.mask, 4);
    SetBit(ev.valuators.mask, 5);
    SetBit(ev.valuators.mask, 6);
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, Success, 2);


    /* keycode too high */
    ev.type = ET_KeyPress;
    ev.detail.key = 256;
    _dix_test_xi_convert(&ev, Success, 0);

    /* deviceid too high */
    ev.type = ET_KeyPress;
    ev.detail.key = 18;
    ev.deviceid = 128;
    _dix_test_xi_convert(&ev, Success, 0);
}


static void xi2_struct_sizes(void)
{
#define compare(req) \
    assert(sizeof(req) == sz_##req);

    compare(xXIQueryVersionReq);
    compare(xXIWarpPointerReq);
    compare(xXIChangeCursorReq);
    compare(xXIChangeHierarchyReq);
    compare(xXISetClientPointerReq);
    compare(xXIGetClientPointerReq);
    compare(xXISelectEventsReq);
    compare(xXIQueryVersionReq);
    compare(xXIQueryDeviceReq);
    compare(xXISetFocusReq);
    compare(xXIGetFocusReq);
    compare(xXIGrabDeviceReq);
    compare(xXIUngrabDeviceReq);
    compare(xXIAllowEventsReq);
    compare(xXIPassiveGrabDeviceReq);
    compare(xXIPassiveUngrabDeviceReq);
    compare(xXIListPropertiesReq);
    compare(xXIChangePropertyReq);
    compare(xXIDeletePropertyReq);
    compare(xXIGetPropertyReq);
    compare(xXIGetSelectedEventsReq);
#undef compare
}


static void dix_grab_matching(void)
{
    DeviceIntRec xi_all_devices, xi_all_master_devices, dev1, dev2;
    GrabRec a, b;
    BOOL rc;

    memset(&a, 0, sizeof(a));
    memset(&b, 0, sizeof(b));

    /* different grabtypes must fail */
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_XI2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XI2 grabs for different devices must fail, regardless of ignoreDevice
     * XI2 grabs for master devices must fail against a slave */
    memset(&xi_all_devices, 0, sizeof(DeviceIntRec));
    memset(&xi_all_master_devices, 0, sizeof(DeviceIntRec));
    memset(&dev1, 0, sizeof(DeviceIntRec));
    memset(&dev2, 0, sizeof(DeviceIntRec));

    xi_all_devices.id = XIAllDevices;
    xi_all_master_devices.id = XIAllMasterDevices;
    dev1.id = 10;
    dev1.type = SLAVE;
    dev2.id = 11;
    dev2.type = SLAVE;

    inputInfo.all_devices = &xi_all_devices;
    inputInfo.all_master_devices = &xi_all_master_devices;
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.device = &dev1;
    b.device = &dev2;

    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.device = &dev2;
    b.device = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.device = inputInfo.all_master_devices;
    b.device = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.device = &dev1;
    b.device = inputInfo.all_master_devices;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    /* ignoreDevice FALSE must fail for different devices for CORE and XI */
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.device = &dev1;
    b.device = &dev2;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.device = &dev1;
    b.device = &dev2;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    /* ignoreDevice FALSE must fail for different modifier devices for CORE
     * and XI */
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    /* different event type must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    /* different modifiers must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyPress;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* AnyModifier must fail for XI2 */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XIAnyModifier must fail for CORE and XI */
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* different detail must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = 1;
    b.detail.exact = 2;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* detail of AnyModifier must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = AnyModifier;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* detail of XIAnyModifier must fail */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = XIAnyModifier;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XIAnyModifier or AnyModifer must succeed */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    /* AnyKey or XIAnyKeycode must succeed */
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
    a.detail.exact = XIAnyKeycode;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
    a.detail.exact = AnyKey;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
    a.detail.exact = AnyKey;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);
}

static void test_bits_to_byte(int i)
{
        int expected_bytes;
        expected_bytes = (i + 7)/8;

        assert(bits_to_bytes(i) >= i/8);
        assert((bits_to_bytes(i) * 8) - i <= 7);
        assert(expected_bytes == bits_to_bytes(i));
}

static void test_bytes_to_int32(int i)
{
        int expected_4byte;
        expected_4byte = (i + 3)/4;

        assert(bytes_to_int32(i) <= i);
        assert((bytes_to_int32(i) * 4) - i <= 3);
        assert(expected_4byte == bytes_to_int32(i));
}

static void test_pad_to_int32(int i)
{
        int expected_bytes;
        expected_bytes = ((i + 3)/4) * 4;

        assert(pad_to_int32(i) >= i);
        assert(pad_to_int32(i) - i <= 3);
        assert(expected_bytes == pad_to_int32(i));
}
static void include_byte_padding_macros(void)
{
    printf("Testing bits_to_bytes()\n");

    /* the macros don't provide overflow protection */
    test_bits_to_byte(0);
    test_bits_to_byte(1);
    test_bits_to_byte(2);
    test_bits_to_byte(7);
    test_bits_to_byte(8);
    test_bits_to_byte(0xFF);
    test_bits_to_byte(0x100);
    test_bits_to_byte(INT_MAX - 9);
    test_bits_to_byte(INT_MAX - 8);

    printf("Testing bytes_to_int32()\n");

    test_bytes_to_int32(0);
    test_bytes_to_int32(1);
    test_bytes_to_int32(2);
    test_bytes_to_int32(7);
    test_bytes_to_int32(8);
    test_bytes_to_int32(0xFF);
    test_bytes_to_int32(0x100);
    test_bytes_to_int32(0xFFFF);
    test_bytes_to_int32(0x10000);
    test_bytes_to_int32(0xFFFFFF);
    test_bytes_to_int32(0x1000000);
    test_bytes_to_int32(INT_MAX - 4);
    test_bytes_to_int32(INT_MAX - 3);

    printf("Testing pad_to_int32\n");

    test_pad_to_int32(0);
    test_pad_to_int32(0);
    test_pad_to_int32(1);
    test_pad_to_int32(2);
    test_pad_to_int32(7);
    test_pad_to_int32(8);
    test_pad_to_int32(0xFF);
    test_pad_to_int32(0x100);
    test_pad_to_int32(0xFFFF);
    test_pad_to_int32(0x10000);
    test_pad_to_int32(0xFFFFFF);
    test_pad_to_int32(0x1000000);
    test_pad_to_int32(INT_MAX - 4);
    test_pad_to_int32(INT_MAX - 3);
}

static void xi_unregister_handlers(void)
{
    DeviceIntRec dev;
    int handler;

    memset(&dev, 0, sizeof(dev));

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 1);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 2);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 3);

    printf("Unlinking from front.\n");

    XIUnregisterPropertyHandler(&dev, 4); /* NOOP */
    assert(dev.properties.handlers->id == 3);
    XIUnregisterPropertyHandler(&dev, 3);
    assert(dev.properties.handlers->id == 2);
    XIUnregisterPropertyHandler(&dev, 2);
    assert(dev.properties.handlers->id == 1);
    XIUnregisterPropertyHandler(&dev, 1);
    assert(dev.properties.handlers == NULL);

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 4);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 5);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 6);
    XIUnregisterPropertyHandler(&dev, 3); /* NOOP */
    assert(dev.properties.handlers->next->next->next == NULL);
    XIUnregisterPropertyHandler(&dev, 4);
    assert(dev.properties.handlers->next->next == NULL);
    XIUnregisterPropertyHandler(&dev, 5);
    assert(dev.properties.handlers->next == NULL);
    XIUnregisterPropertyHandler(&dev, 6);
    assert(dev.properties.handlers == NULL);

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 7);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 8);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 9);

    XIDeleteAllDeviceProperties(&dev);
    assert(dev.properties.handlers == NULL);
    XIUnregisterPropertyHandler(&dev, 7); /* NOOP */

}

static void cmp_attr_fields(InputAttributes *attr1,
                            InputAttributes *attr2)
{
    char **tags1, **tags2;

    assert(attr1 && attr2);
    assert(attr1 != attr2);
    assert(attr1->flags == attr2->flags);

    if (attr1->product != NULL)
    {
        assert(attr1->product != attr2->product);
        assert(strcmp(attr1->product, attr2->product) == 0);
    } else
        assert(attr2->product == NULL);

    if (attr1->vendor != NULL)
    {
        assert(attr1->vendor != attr2->vendor);
        assert(strcmp(attr1->vendor, attr2->vendor) == 0);
    } else
        assert(attr2->vendor == NULL);

    if (attr1->device != NULL)
    {
        assert(attr1->device != attr2->device);
        assert(strcmp(attr1->device, attr2->device) == 0);
    } else
        assert(attr2->device == NULL);

    if (attr1->pnp_id != NULL)
    {
        assert(attr1->pnp_id != attr2->pnp_id);
        assert(strcmp(attr1->pnp_id, attr2->pnp_id) == 0);
    } else
        assert(attr2->pnp_id == NULL);

    if (attr1->usb_id != NULL)
    {
        assert(attr1->usb_id != attr2->usb_id);
        assert(strcmp(attr1->usb_id, attr2->usb_id) == 0);
    } else
        assert(attr2->usb_id == NULL);

    tags1 = attr1->tags;
    tags2 = attr2->tags;

    /* if we don't have any tags, skip the tag checking bits */
    if (!tags1)
    {
        assert(!tags2);
        return;
    }

    /* Don't lug around empty arrays */
    assert(*tags1);
    assert(*tags2);

    /* check for identical content, but duplicated */
    while (*tags1)
    {
        assert(*tags1 != *tags2);
        assert(strcmp(*tags1, *tags2) == 0);
        tags1++;
        tags2++;
    }

    /* ensure tags1 and tags2 have the same no of elements */
    assert(!*tags2);

    /* check for not sharing memory */
    tags1 = attr1->tags;
    while (*tags1)
    {
        tags2 = attr2->tags;
        while (*tags2)
            assert(*tags1 != *tags2++);

        tags1++;
    }
}

static void dix_input_attributes(void)
{
    InputAttributes orig = {0};
    InputAttributes *new;
    char *tags[4] = {"tag1", "tag2", "tag2", NULL};

    new = DuplicateInputAttributes(NULL);
    assert(!new);

    new = DuplicateInputAttributes(&orig);
    assert(memcmp(&orig, new, sizeof(InputAttributes)) == 0);

    orig.product = "product name";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.vendor = "vendor name";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.device = "device path";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.pnp_id = "PnPID";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.usb_id = "USBID";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.flags = 0xF0;
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);

    orig.tags = tags;
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
    FreeInputAttributes(new);
}

static void dix_input_valuator_masks(void)
{
    ValuatorMask *mask = NULL, *copy;
    int nvaluators = MAX_VALUATORS;
    int valuators[nvaluators];
    int i;
    int first_val, num_vals;

    for (i = 0; i < nvaluators; i++)
        valuators[i] = i;

    mask = valuator_mask_new(nvaluators);
    assert(mask != NULL);
    assert(valuator_mask_size(mask) == 0);
    assert(valuator_mask_num_valuators(mask) == 0);

    for (i = 0; i < nvaluators; i++)
    {
        assert(!valuator_mask_isset(mask, i));
        valuator_mask_set(mask, i, valuators[i]);
        assert(valuator_mask_isset(mask, i));
        assert(valuator_mask_get(mask, i) == valuators[i]);
        assert(valuator_mask_size(mask) == i + 1);
        assert(valuator_mask_num_valuators(mask) == i + 1);
    }

    for (i = 0; i < nvaluators; i++)
    {
        assert(valuator_mask_isset(mask, i));
        valuator_mask_unset(mask, i);
        /* we're removing valuators from the front, so size should stay the
         * same until the last bit is removed */
        if (i < nvaluators - 1)
            assert(valuator_mask_size(mask) == nvaluators);
        assert(!valuator_mask_isset(mask, i));
    }

    assert(valuator_mask_size(mask) == 0);
    valuator_mask_zero(mask);
    assert(valuator_mask_size(mask) == 0);
    assert(valuator_mask_num_valuators(mask) == 0);
    for (i = 0; i < nvaluators; i++)
        assert(!valuator_mask_isset(mask, i));

    first_val = 5;
    num_vals = 6;

    valuator_mask_set_range(mask, first_val, num_vals, valuators);
    assert(valuator_mask_size(mask) == first_val + num_vals);
    assert(valuator_mask_num_valuators(mask) == num_vals);
    for (i = 0; i < nvaluators; i++)
    {
        if (i < first_val || i >= first_val + num_vals)
            assert(!valuator_mask_isset(mask, i));
        else
        {
            assert(valuator_mask_isset(mask, i));
            assert(valuator_mask_get(mask, i) == valuators[i - first_val]);
        }
    }

    copy = valuator_mask_new(nvaluators);
    valuator_mask_copy(copy, mask);
    assert(mask != copy);
    assert(valuator_mask_size(mask) == valuator_mask_size(copy));
    assert(valuator_mask_num_valuators(mask) == valuator_mask_num_valuators(copy));

    for (i = 0; i < nvaluators; i++)
    {
        assert(valuator_mask_isset(mask, i) == valuator_mask_isset(copy, i));
        assert(valuator_mask_get(mask, i) == valuator_mask_get(copy, i));
    }

    valuator_mask_free(&mask);
    assert(mask == NULL);
}

static void dix_valuator_mode(void)
{
    DeviceIntRec dev;
    const int num_axes = MAX_VALUATORS;
    int i;
    Atom atoms[MAX_VALUATORS] = { 0 };

    memset(&dev, 0, sizeof(DeviceIntRec));
    dev.type = MASTER_POINTER; /* claim it's a master to stop ptracccel */

    assert(InitValuatorClassDeviceStruct(NULL, 0, atoms, 0, 0) == FALSE);
    assert(InitValuatorClassDeviceStruct(&dev, num_axes, atoms, 0, Absolute));

    for (i = 0; i < num_axes; i++)
    {
        assert(valuator_get_mode(&dev, i) == Absolute);
        valuator_set_mode(&dev, i, Relative);
        assert(dev.valuator->axes[i].mode == Relative);
        assert(valuator_get_mode(&dev, i) == Relative);
    }

    valuator_set_mode(&dev, VALUATOR_MODE_ALL_AXES, Absolute);
    for (i = 0; i < num_axes; i++)
        assert(valuator_get_mode(&dev, i) == Absolute);

    valuator_set_mode(&dev, VALUATOR_MODE_ALL_AXES, Relative);
    for (i = 0; i < num_axes; i++)
        assert(valuator_get_mode(&dev, i) == Relative);
}

static void include_bit_test_macros(void)
{
    uint8_t mask[9] = { 0 };
    int i;

    for (i = 0; i < sizeof(mask)/sizeof(mask[0]); i++)
    {
        assert(BitIsOn(mask, i) == 0);
        SetBit(mask, i);
        assert(BitIsOn(mask, i) == 1);
        assert(!!(mask[i/8] & (1 << (i % 8))));
        assert(CountBits(mask, sizeof(mask)) == 1);
        ClearBit(mask, i);
        assert(BitIsOn(mask, i) == 0);
    }
}

/**
 * Ensure that val->axisVal and val->axes are aligned on doubles.
 */
static void dix_valuator_alloc(void)
{
    ValuatorClassPtr v = NULL;
    int num_axes = 0;

    while (num_axes < 5)
    {
        v = AllocValuatorClass(v, num_axes);

        assert(v);
        assert(v->numAxes == num_axes);
#if !defined(__i386__) && !defined(__sh__)
        /* must be double-aligned on 64 bit */
        assert(((void*)v->axisVal - (void*)v) % sizeof(double) == 0);
        assert(((void*)v->axes - (void*)v) % sizeof(double) == 0);
#endif
        num_axes ++;
    }

    free(v);
}

int main(int argc, char** argv)
{
    dix_input_valuator_masks();
    dix_input_attributes();
    dix_init_valuators();
    dix_event_to_core_conversion();
    dix_event_to_xi1_conversion();
    dix_check_grab_values();
    xi2_struct_sizes();
    dix_grab_matching();
    dix_valuator_mode();
    include_byte_padding_macros();
    include_bit_test_macros();
    xi_unregister_handlers();
    dix_valuator_alloc();

    return 0;
}
/**
 * Copyright © 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/Xlib.h>
#include <list.h>
#include <string.h>
#include <assert.h>

struct parent {
    int a;
    struct list children;
    int b;
};

struct child {
    int foo;
    int bar;
    struct list node;
};

static void
test_list_init(void)
{
    struct parent parent, tmp;

    memset(&parent, 0, sizeof(parent));
    parent.a = 0xa5a5a5;
    parent.b = ~0xa5a5a5;

    tmp = parent;

    list_init(&parent.children);

    /* test we haven't touched anything else. */
    assert(parent.a == tmp.a);
    assert(parent.b == tmp.b);

    assert(list_is_empty(&parent.children));
}

static void
test_list_add(void)
{
    struct parent parent = {0};
    struct child child[3];
    struct child *c;

    list_init(&parent.children);

    list_add(&child[0].node, &parent.children);
    assert(!list_is_empty(&parent.children));

    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[0], sizeof(struct child)) == 0);

    /* note: list_add prepends */
    list_add(&child[1].node, &parent.children);
    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[1], sizeof(struct child)) == 0);

    list_add(&child[2].node, &parent.children);
    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[2], sizeof(struct child)) == 0);
};

static void
test_list_del(void)
{
    struct parent parent = {0};
    struct child child[3];
    struct child *c;

    list_init(&parent.children);

    list_add(&child[0].node, &parent.children);
    assert(!list_is_empty(&parent.children));

    list_del(&parent.children);
    assert(list_is_empty(&parent.children));

    list_add(&child[0].node, &parent.children);
    list_del(&child[0].node);
    assert(list_is_empty(&parent.children));

    list_add(&child[0].node, &parent.children);
    list_add(&child[1].node, &parent.children);

    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[1], sizeof(struct child)) == 0);

    /* delete first node */
    list_del(&child[1].node);
    assert(!list_is_empty(&parent.children));
    assert(list_is_empty(&child[1].node));
    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[0], sizeof(struct child)) == 0);

    /* delete last node */
    list_add(&child[1].node, &parent.children);
    list_del(&child[0].node);
    c = list_first_entry(&parent.children, struct child, node);
    assert(memcmp(c, &child[1], sizeof(struct child)) == 0);

    /* delete list head */
    list_add(&child[0].node, &parent.children);
    list_del(&parent.children);
    assert(list_is_empty(&parent.children));
    assert(!list_is_empty(&child[1].node));
    assert(!list_is_empty(&child[2].node));
}

static void
test_list_for_each(void)
{
    struct parent parent = {0};
    struct child child[3];
    struct child *c;
    int i = 0;

    list_init(&parent.children);

    list_add(&child[2].node, &parent.children);
    list_add(&child[1].node, &parent.children);
    list_add(&child[0].node, &parent.children);

    list_for_each_entry(c, &parent.children, node) {
        assert(memcmp(c, &child[i], sizeof(struct child)) == 0);
        i++;
    }

    /* foreach on empty list */
    list_del(&parent.children);
    assert(list_is_empty(&parent.children));

    list_for_each_entry(c, &parent.children, node) {
        assert(0); /* we must not get here */
    }
}


int main(int argc, char** argv)
{
    test_list_init();
    test_list_add();
    test_list_del();
    test_list_for_each();

    return 0;
}
if ENABLE_UNIT_TESTS
if HAVE_LD_WRAP
SUBDIRS= . xi2
noinst_PROGRAMS = xkb input xtest list misc fixes
check_LTLIBRARIES = libxservertest.la

TESTS=$(noinst_PROGRAMS)

AM_CFLAGS = $(DIX_CFLAGS) @XORG_CFLAGS@
INCLUDES = $(XORG_INCS) -I$(top_srcdir)/hw/xfree86/parser \
	-I$(top_srcdir)/miext/cw -I$(top_srcdir)/hw/xfree86/ddc \
	-I$(top_srcdir)/hw/xfree86/i2c -I$(top_srcdir)/hw/xfree86/modes \
	-I$(top_srcdir)/hw/xfree86/ramdac
TEST_LDADD=libxservertest.la $(XORG_SYS_LIBS) $(XSERVER_SYS_LIBS)

if SPECIAL_DTRACE_OBJECTS
TEST_LDADD += $(OS_LIB) $(DIX_LIB)
endif

xkb_LDADD=$(TEST_LDADD)
input_LDADD=$(TEST_LDADD)
xtest_LDADD=$(TEST_LDADD)
list_LDADD=$(TEST_LDADD)
misc_LDADD=$(TEST_LDADD)
fixes_LDADD=$(TEST_LDADD)

nodist_libxservertest_la_SOURCES = $(top_builddir)/hw/xfree86/sdksyms.c
libxservertest_la_LIBADD = \
            $(XSERVER_LIBS) \
            $(top_builddir)/hw/xfree86/loader/libloader.la \
            $(top_builddir)/hw/xfree86/os-support/libxorgos.la \
            $(top_builddir)/hw/xfree86/common/libcommon.la \
            $(top_builddir)/hw/xfree86/parser/libxf86config_internal.la \
            $(top_builddir)/hw/xfree86/dixmods/libdixmods.la \
            $(top_builddir)/hw/xfree86/modes/libxf86modes.la \
            $(top_builddir)/hw/xfree86/ramdac/libramdac.la \
            $(top_builddir)/hw/xfree86/ddc/libddc.la \
            $(top_builddir)/hw/xfree86/i2c/libi2c.la \
            $(top_builddir)/hw/xfree86/dixmods/libxorgxkb.la \
            $(top_builddir)/mi/libmi.la \
            $(top_builddir)/os/libos.la \
            @XORG_LIBS@
libxservertest_la_DEPENDENCIES = $(libxservertest_la_LIBADD)
endif
endif
/**
 * Copyright © 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include "misc.h"

static void dix_version_compare(void)
{
    int rc;

    rc = version_compare(0, 0, 1, 0);
    assert(rc < 0);
    rc = version_compare(1, 0, 0, 0);
    assert(rc > 0);
    rc = version_compare(0, 0, 0, 0);
    assert(rc == 0);
    rc = version_compare(1, 0, 1, 0);
    assert(rc == 0);
    rc = version_compare(1, 0, 0, 9);
    assert(rc > 0);
    rc = version_compare(0, 9, 1, 0);
    assert(rc < 0);
    rc = version_compare(1, 0, 1, 9);
    assert(rc < 0);
    rc = version_compare(1, 9, 1, 0);
    assert(rc > 0);
    rc = version_compare(2, 0, 1, 9);
    assert(rc > 0);
    rc = version_compare(1, 9, 2, 0);
    assert(rc < 0);
}

int main(int argc, char** argv)
{
    dix_version_compare();

    return 0;
}
                        X server test suite

This suite contains a set of tests to verify the behaviour of functions used
internally to the server. This test suite is based on glib's testing
framework [1].

= How it works =
Through some automake abuse, we link the test programs with the same static
libraries as the Xorg binary. The test suites can then call various functions
and verify their behaviour - without the need to start the server or connect
clients.

This testing only works for functions that do not rely on a particular state
of the X server. Unless the test suite replicates the expected state, which
may be difficult.

= How to run the tests =
Run "make check" the test directory. This will compile the tests and execute
them in the order specified in the TESTS variable in test/Makefile.am.

Each set of tests related to a subsystem are available as a binary that can be
executed directly. For example, run "xkb" to perform some xkb-related tests.

== Adding a new test ==
When adding a new test, ensure that you add a short description of what the
test does and what the expected outcome is. If the test reproduces a
particular bug, using g_test_bug().

== Misc ==

The programs "gtester" and "gtester-report" may be used to generate XML/HTML
log files of tests succeeded and failed.

---------

[1] http://library.gnome.org/devel/glib/stable/glib-Testing.html
protocol-eventconvert
protocol-xigetclientpointer
protocol-xigetselectedevents
protocol-xipassivegrabdevice
protocol-xiquerydevice
protocol-xiquerypointer
protocol-xiqueryversion
protocol-xiselectevents
protocol-xisetclientpointer
protocol-xiwarppointer
if ENABLE_UNIT_TESTS
if HAVE_LD_WRAP
noinst_PROGRAMS =  \
	protocol-xiqueryversion \
	protocol-xiquerydevice \
	protocol-xiselectevents \
	protocol-xigetselectedevents \
        protocol-xisetclientpointer \
        protocol-xigetclientpointer \
        protocol-xipassivegrabdevice \
        protocol-xiquerypointer \
        protocol-xiwarppointer \
        protocol-eventconvert

TESTS=$(noinst_PROGRAMS)

AM_CFLAGS = $(DIX_CFLAGS) @XORG_CFLAGS@
INCLUDES = @XORG_INCS@
TEST_LDADD=../libxservertest.la $(XORG_SYS_LIBS) $(XSERVER_SYS_LIBS)
COMMON_SOURCES=protocol-common.h protocol-common.c

if SPECIAL_DTRACE_OBJECTS
TEST_LDADD += $(OS_LIB) $(DIX_LIB)
endif

protocol_xiqueryversion_LDADD=$(TEST_LDADD)
protocol_xiquerydevice_LDADD=$(TEST_LDADD)
protocol_xiselectevents_LDADD=$(TEST_LDADD)
protocol_xigetselectedevents_LDADD=$(TEST_LDADD)
protocol_xisetclientpointer_LDADD=$(TEST_LDADD)
protocol_xigetclientpointer_LDADD=$(TEST_LDADD)
protocol_xiquerypointer_LDADD=$(TEST_LDADD)
protocol_xipassivegrabdevice_LDADD=$(TEST_LDADD)
protocol_xiwarppointer_LDADD=$(TEST_LDADD)
protocol_eventconvert_LDADD=$(TEST_LDADD)

protocol_xiqueryversion_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient
protocol_xiquerydevice_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient
protocol_xiselectevents_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,dixLookupWindow -Wl,-wrap,XISetEventMask
protocol_xigetselectedevents_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient -Wl,-wrap,dixLookupWindow -Wl,-wrap,AddResource
protocol_xisetclientpointer_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,dixLookupClient
protocol_xigetclientpointer_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient -Wl,-wrap,dixLookupClient
protocol_xipassivegrabdevice_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,GrabButton -Wl,-wrap,dixLookupWindow -Wl,-wrap,WriteToClient
protocol_xiquerypointer_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient -Wl,-wrap,dixLookupWindow
protocol_xiwarppointer_LDFLAGS=$(AM_LDFLAGS) -Wl,-wrap,WriteToClient -Wl,-wrap,dixLookupWindow

protocol_xiqueryversion_SOURCES=$(COMMON_SOURCES) protocol-xiqueryversion.c
protocol_xiquerydevice_SOURCES=$(COMMON_SOURCES) protocol-xiquerydevice.c
protocol_xiselectevents_SOURCES=$(COMMON_SOURCES) protocol-xiselectevents.c
protocol_xigetselectedevents_SOURCES=$(COMMON_SOURCES) protocol-xigetselectedevents.c
protocol_xisetclientpointer_SOURCES=$(COMMON_SOURCES) protocol-xisetclientpointer.c
protocol_xigetclientpointer_SOURCES=$(COMMON_SOURCES) protocol-xigetclientpointer.c
protocol_xiquerypointer_SOURCES=$(COMMON_SOURCES) protocol-xiquerypointer.c
protocol_xipassivegrabdevice_SOURCES=$(COMMON_SOURCES) protocol-xipassivegrabdevice.c
protocol_xiwarppointer_SOURCES=$(COMMON_SOURCES) protocol-xiwarppointer.c
endif
endif
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include "extinit.h" /* for XInputExtensionInit */
#include "exglobals.h"
#include "xkbsrv.h" /* for XkbInitPrivates */

#include "protocol-common.h"

struct devices devices;
ScreenRec screen;
WindowRec root;
WindowRec window;

void *userdata;

extern int CorePointerProc(DeviceIntPtr pDev, int what);
extern int CoreKeyboardProc(DeviceIntPtr pDev, int what);

static void fake_init_sprite(DeviceIntPtr dev)
{
    SpritePtr sprite;
    sprite = dev->spriteInfo->sprite;

    sprite->spriteTraceSize = 10;
    sprite->spriteTrace = calloc(sprite->spriteTraceSize, sizeof(WindowPtr));
    sprite->spriteTraceGood = 1;
    sprite->spriteTrace[0] = &root;
    sprite->hot.x = SPRITE_X;
    sprite->hot.y = SPRITE_Y;
    sprite->hotPhys.x = sprite->hot.x;
    sprite->hotPhys.y = sprite->hot.y;
    sprite->win = &window;
    sprite->hotPhys.pScreen = &screen;
    sprite->physLimits.x1 = 0;
    sprite->physLimits.y1 = 0;
    sprite->physLimits.x2 = screen.width;
    sprite->physLimits.y2 = screen.height;
}

/**
 * Create and init 2 master devices (VCP + VCK) and two slave devices, one
 * default mouse, one default keyboard.
 */
struct devices init_devices(void)
{
    ClientRec client;
    struct devices devices;

    client = init_client(0, NULL);

    AllocDevicePair(&client, "Virtual core", &devices.vcp, &devices.vck,
                    CorePointerProc, CoreKeyboardProc, TRUE);
    inputInfo.pointer = devices.vcp;
    inputInfo.keyboard = devices.vck;
    ActivateDevice(devices.vcp, FALSE);
    ActivateDevice(devices.vck, FALSE);
    EnableDevice(devices.vcp, FALSE);
    EnableDevice(devices.vck, FALSE);

    AllocDevicePair(&client, "", &devices.mouse, &devices.kbd,
                    CorePointerProc, CoreKeyboardProc, FALSE);
    ActivateDevice(devices.mouse, FALSE);
    ActivateDevice(devices.kbd, FALSE);
    EnableDevice(devices.mouse, FALSE);
    EnableDevice(devices.kbd, FALSE);

    devices.num_devices = 4;
    devices.num_master_devices = 2;

    fake_init_sprite(devices.mouse);
    fake_init_sprite(devices.vcp);

    return devices;
}


/* Create minimal client, with the given buffer and len as request buffer */
ClientRec init_client(int len, void *data)
{
    ClientRec client = { 0 };

    /* we store the privates now and reassign it after the memset. this way
     * we can share them across multiple test runs and don't have to worry
     * about freeing them after each test run. */

    client.index = CLIENT_INDEX;
    client.clientAsMask = CLIENT_MASK;
    client.sequence = CLIENT_SEQUENCE;
    client.req_len = len;

    client.requestBuffer = data;
    dixAllocatePrivates(&client.devPrivates, PRIVATE_CLIENT);
    return client;
}

void init_window(WindowPtr window, WindowPtr parent, int id)
{
    memset(window, 0, sizeof(*window));

    window->drawable.id = id;
    if (parent)
    {
        window->drawable.x = 30;
        window->drawable.y = 50;
        window->drawable.width = 100;
        window->drawable.height = 200;
    }
    window->parent = parent;
    window->optional = calloc(1, sizeof(WindowOptRec));
    assert(window->optional);
}

extern DevPrivateKeyRec miPointerScreenKeyRec;
extern DevPrivateKeyRec miPointerPrivKeyRec;

/* Needed for the screen setup, otherwise we crash during sprite initialization */
static Bool device_cursor_init(DeviceIntPtr dev, ScreenPtr screen) { return TRUE; }
static Bool set_cursor_pos(DeviceIntPtr dev, ScreenPtr screen, int x, int y, Bool event) { return TRUE; }
void init_simple(void)
{
    screenInfo.numScreens = 1;
    screenInfo.screens[0] = &screen;

    screen.myNum = 0;
    screen.id = 100;
    screen.width = 640;
    screen.height = 480;
    screen.DeviceCursorInitialize = device_cursor_init;
    screen.SetCursorPosition = set_cursor_pos;

    dixResetPrivates();
    InitAtoms();
    XkbInitPrivates();
    dixRegisterPrivateKey(&XIClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(XIClientRec));
    dixRegisterPrivateKey(&miPointerScreenKeyRec, PRIVATE_SCREEN, 0);
    dixRegisterPrivateKey(&miPointerPrivKeyRec, PRIVATE_DEVICE, 0);
    XInputExtensionInit();

    init_window(&root, NULL, ROOT_WINDOW_ID);
    init_window(&window, &root, CLIENT_WINDOW_ID);

    devices = init_devices();
}

void __wrap_WriteToClient(ClientPtr client, int len, void *data)
{
    assert(reply_handler != NULL);

    (*reply_handler)(client, len, data, userdata);
}

/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "windowstr.h"
#include "exevents.h"
#include <assert.h>

#ifndef PROTOCOL_COMMON_H
#define PROTOCOL_COMMON_H

extern int BadDevice;

/* Check default values in a reply */
#define reply_check_defaults(rep, len, type) \
    { \
        assert((len) >= sz_x##type##Reply); \
        assert((rep)->repType == X_Reply); \
        assert((rep)->RepType == X_##type); \
        assert((rep)->sequenceNumber == CLIENT_SEQUENCE); \
        assert((rep)->length >= (sz_x##type##Reply - 32)/4); \
    }

/* initialise default values for request */
#define request_init(req, type) \
    { \
        (req)->reqType = 128; /* doesn't matter */ \
        (req)->ReqType = X_##type; \
        (req)->length = (sz_x##type##Req >> 2); \
    }


/* Various defines used in the tests. Some tests may use different values
 * than these defaults */
/* default client index */
#define CLIENT_INDEX            1
/* default client mask for resources and windows */
#define CLIENT_MASK             ((CLIENT_INDEX) << CLIENTOFFSET)
/* default client sequence number for replies */
#define CLIENT_SEQUENCE         0x100
/* default root window id */
#define ROOT_WINDOW_ID          0x10
/* default client window id */
#define CLIENT_WINDOW_ID        0x100001
/* invalid window ID. use for BadWindow checks. */
#define INVALID_WINDOW_ID       0x111111
/* initial fake sprite position */
#define SPRITE_X                100
#define SPRITE_Y                200


/* Various structs used throughout the tests */


/* The default devices struct, contains one pointer + keyboard and the
 * matching master devices. Initialize with init_devices() if needed. */
struct devices {
    DeviceIntPtr vcp;
    DeviceIntPtr vck;
    DeviceIntPtr mouse;
    DeviceIntPtr kbd;

    int num_devices;
    int num_master_devices;
} devices;

/**
 * The set of default devices available in all tests if necessary.
 */
extern struct devices devices;

/**
 * test-specific userdata, passed into the reply handler.
 */
extern void *userdata;
/**
 * The reply handler called from WriteToClient. Set this handler if you need
 * to check the reply values.
 */
void (*reply_handler)(ClientPtr client, int len, char *data, void *userdata);

/**
 * The default screen used for the windows. Initialized by init_simple().
 */
extern ScreenRec screen;
/**
 * Semi-initialized root window. initialized by init().
 */
extern WindowRec root;
/**
 * Semi-initialized top-level window. initialized by init().
 */
extern WindowRec window;

/* various simple functions for quick setup */
/**
 * Initialize the above struct with default devices and return the struct.
 * Usually not needed if you call ::init_simple.
 */
struct devices init_devices(void);
/**
 * Init a mostly zeroed out client with default values for index and mask.
 */
ClientRec init_client(int request_len, void *request_data);
/**
 * Init a mostly zeroed out window with the given window ID.
 * Usually not needed if you call ::init_simple which sets up root and
 * window.
 */
void init_window(WindowPtr window, WindowPtr parent, int id);
/**
 * Create a very simple setup that provides the minimum values for most
 * tests, including a screen, the root and client window and the default
 * device setup.
 */
void init_simple(void);

/* Declarations for various overrides in the test files. */
void __wrap_WriteToClient(ClientPtr client, int len, void *data);
int __wrap_XISetEventMask(DeviceIntPtr dev, WindowPtr win, int len, unsigned char* mask);
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access);
int __real_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access);
Bool __wrap_AddResource(XID id, RESTYPE type, pointer value);
int __wrap_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);
int __real_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);


#endif /* PROTOCOL_COMMON_H */

/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>

#include "inputstr.h"
#include "eventstr.h"
#include "eventconvert.h"
#include "exevents.h"
#include <X11/extensions/XI2proto.h>

static void test_values_XIRawEvent(RawDeviceEvent *in, xXIRawEvent *out,
                                   BOOL swap)
{
    int i;
    unsigned char *ptr;
    FP3232 *value, *raw_value;
    int nvals = 0;
    int bits_set;
    int len;

    if (swap)
    {
        char n;

        swaps(&out->sequenceNumber, n);
        swapl(&out->length, n);
        swaps(&out->evtype, n);
        swaps(&out->deviceid, n);
        swapl(&out->time, n);
        swapl(&out->detail, n);
        swaps(&out->valuators_len, n);
    }


    assert(out->type == GenericEvent);
    assert(out->extension == 0); /* IReqCode defaults to 0 */
    assert(out->evtype == GetXI2Type((InternalEvent*)in));
    assert(out->time == in->time);
    assert(out->detail == in->detail.button);
    assert(out->deviceid == in->deviceid);
    assert(out->valuators_len >= bytes_to_int32(bits_to_bytes(sizeof(in->valuators.mask))));
    assert(out->flags == 0); /* FIXME: we don't set the flags yet */

    ptr = (unsigned char*)&out[1];
    bits_set = 0;

    for (i = 0; out->valuators_len && i < sizeof(in->valuators.mask) * 8; i++)
    {
        if (i >= MAX_VALUATORS)
            assert (!XIMaskIsSet(in->valuators.mask, i));
        assert (XIMaskIsSet(in->valuators.mask, i) == XIMaskIsSet(ptr, i));
        if (XIMaskIsSet(in->valuators.mask, i))
            bits_set++;
    }

    /* length is len of valuator mask (in 4-byte units) + the number of bits
     * set. Each bit set represents 2 8-byte values, hence the
     * 'bits_set * 4' */
    len = out->valuators_len + bits_set * 4;
    assert(out->length == len);

    nvals = 0;

    for (i = 0; out->valuators_len && i < MAX_VALUATORS; i++)
    {
        assert (XIMaskIsSet(in->valuators.mask, i) == XIMaskIsSet(ptr, i));
        if (XIMaskIsSet(in->valuators.mask, i))
        {
            FP3232 vi, vo;
            value = (FP3232*)(((unsigned char*)&out[1]) + out->valuators_len * 4);
            value += nvals;

            vi.integral = in->valuators.data[i];
            vi.frac = in->valuators.data_frac[i];

            vo.integral = value->integral;
            vo.frac = value->frac;
            if (swap)
            {
                char n;
                swapl(&vo.integral, n);
                swapl(&vo.frac, n);
            }

            assert(vi.integral == vo.integral);
            assert(vi.frac == vo.frac);

            raw_value = value + bits_set;

            vi.integral = in->valuators.data_raw[i];
            vi.frac = in->valuators.data_raw_frac[i];

            vo.integral = raw_value->integral;
            vo.frac = raw_value->frac;
            if (swap)
            {
                char n;
                swapl(&vo.integral, n);
                swapl(&vo.frac, n);
            }

            assert(vi.integral == vo.integral);
            assert(vi.frac == vo.frac);

            nvals++;
        }
    }
}

static void test_XIRawEvent(RawDeviceEvent *in)
{
    xXIRawEvent *out, *swapped;
    int rc;

    rc = EventToXI2((InternalEvent*)in, (xEvent**)&out);
    assert(rc == Success);

    test_values_XIRawEvent(in, out, FALSE);

    swapped = calloc(1, sizeof(xEvent) + out->length * 4);
    XI2EventSwap((xGenericEvent*)out, (xGenericEvent*)swapped);
    test_values_XIRawEvent(in, swapped, TRUE);

    free(out);
    free(swapped);
}

static void test_convert_XIFocusEvent(void)
{
    xEvent *out;
    DeviceEvent in;
    int rc;

    in.header = ET_Internal;
    in.type = ET_Enter;
    rc = EventToXI2((InternalEvent*)&in, &out);
    assert(rc == Success);
    assert(out == NULL);

    in.header = ET_Internal;
    in.type = ET_FocusIn;
    rc = EventToXI2((InternalEvent*)&in, &out);
    assert(rc == Success);
    assert(out == NULL);

    in.header = ET_Internal;
    in.type = ET_FocusOut;
    rc = EventToXI2((InternalEvent*)&in, &out);
    assert(rc == BadImplementation);

    in.header = ET_Internal;
    in.type = ET_Leave;
    rc = EventToXI2((InternalEvent*)&in, &out);
    assert(rc == BadImplementation);
}


static void test_convert_XIRawEvent(void)
{
    RawDeviceEvent in;
    int i;

    memset(&in, 0, sizeof(in));

    printf("Testing all event types\n");
    in.header = ET_Internal;
    in.type = ET_RawMotion;
    test_XIRawEvent(&in);

    in.header = ET_Internal;
    in.type = ET_RawKeyPress;
    test_XIRawEvent(&in);

    in.header = ET_Internal;
    in.type = ET_RawKeyRelease;
    test_XIRawEvent(&in);

    in.header = ET_Internal;
    in.type = ET_RawButtonPress;
    test_XIRawEvent(&in);

    in.header = ET_Internal;
    in.type = ET_RawButtonRelease;
    test_XIRawEvent(&in);

    printf("Testing details and other fields\n");
    in.detail.button = 1L;
    test_XIRawEvent(&in);
    in.detail.button = 1L << 8;
    test_XIRawEvent(&in);
    in.detail.button = 1L << 16;
    test_XIRawEvent(&in);
    in.detail.button = 1L << 24;
    test_XIRawEvent(&in);
    in.detail.button = ~0L;
    test_XIRawEvent(&in);

    in.detail.button = 0;

    in.time = 1L;
    test_XIRawEvent(&in);
    in.time = 1L << 8;
    test_XIRawEvent(&in);
    in.time = 1L << 16;
    test_XIRawEvent(&in);
    in.time = 1L << 24;
    test_XIRawEvent(&in);
    in.time = ~0L;
    test_XIRawEvent(&in);

    in.deviceid = 1;
    test_XIRawEvent(&in);
    in.deviceid = 1 << 8;
    test_XIRawEvent(&in);
    in.deviceid = ~0 & 0xFF;
    test_XIRawEvent(&in);

    printf("Testing valuator masks\n");
    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);
        test_XIRawEvent(&in);
        XIClearMask(in.valuators.mask, i);
    }

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);

        in.valuators.data[i] = i;
        in.valuators.data_raw[i] = i + 10;
        in.valuators.data_frac[i] = i + 20;
        in.valuators.data_raw_frac[i] = i + 30;
        test_XIRawEvent(&in);
        XIClearMask(in.valuators.mask, i);
    }

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);
        test_XIRawEvent(&in);
    }
}

static void test_values_XIDeviceEvent(DeviceEvent *in, xXIDeviceEvent *out,
                                      BOOL swap)
{
    int buttons, valuators;
    int i;
    unsigned char *ptr;
    uint32_t flagmask = 0;
    FP3232 *values;

    if (swap) {
        char n;

        swaps(&out->sequenceNumber, n);
        swapl(&out->length, n);
        swaps(&out->evtype, n);
        swaps(&out->deviceid, n);
        swaps(&out->sourceid, n);
        swapl(&out->time, n);
        swapl(&out->detail, n);
        swapl(&out->root, n);
        swapl(&out->event, n);
        swapl(&out->child, n);
        swapl(&out->root_x, n);
        swapl(&out->root_y, n);
        swapl(&out->event_x, n);
        swapl(&out->event_y, n);
        swaps(&out->buttons_len, n);
        swaps(&out->valuators_len, n);
        swapl(&out->mods.base_mods, n);
        swapl(&out->mods.latched_mods, n);
        swapl(&out->mods.locked_mods, n);
        swapl(&out->mods.effective_mods, n);
        swapl(&out->flags, n);
    }

    assert(out->extension == 0); /* IReqCode defaults to 0 */
    assert(out->evtype == GetXI2Type((InternalEvent*)in));
    assert(out->time == in->time);
    assert(out->detail == in->detail.button);
    assert(out->length >= 12);

    assert(out->deviceid == in->deviceid);
    assert(out->sourceid == in->sourceid);

    switch (in->type) {
        case ET_KeyPress:
            flagmask = XIKeyRepeat;
            break;
        default:
            flagmask = 0;
            break;
    }
    assert((out->flags & ~flagmask) == 0);

    assert(out->root == in->root);
    assert(out->event == None); /* set in FixUpEventFromWindow */
    assert(out->child == None); /* set in FixUpEventFromWindow */

    assert(out->mods.base_mods == in->mods.base);
    assert(out->mods.latched_mods == in->mods.latched);
    assert(out->mods.locked_mods == in->mods.locked);
    assert(out->mods.effective_mods == in->mods.effective);

    assert(out->group.base_group == in->group.base);
    assert(out->group.latched_group == in->group.latched);
    assert(out->group.locked_group == in->group.locked);
    assert(out->group.effective_group == in->group.effective);

    assert(out->event_x == 0); /* set in FixUpEventFromWindow */
    assert(out->event_y == 0); /* set in FixUpEventFromWindow */

    assert(out->root_x == FP1616(in->root_x, in->root_x_frac));
    assert(out->root_y == FP1616(in->root_y, in->root_y_frac));

    buttons = 0;
    for (i = 0; i < bits_to_bytes(sizeof(in->buttons)); i++)
    {
        if (XIMaskIsSet(in->buttons, i))
        {
            assert(out->buttons_len >= bytes_to_int32(bits_to_bytes(i)));
            buttons++;
        }
    }

    ptr = (unsigned char*)&out[1];
    for (i = 0; i < sizeof(in->buttons) * 8; i++)
        assert(XIMaskIsSet(in->buttons, i) == XIMaskIsSet(ptr, i));


    valuators = 0;
    for (i = 0; i < MAX_VALUATORS; i++)
        if (XIMaskIsSet(in->valuators.mask, i))
            valuators++;

    assert(out->valuators_len >= bytes_to_int32(bits_to_bytes(valuators)));

    ptr += out->buttons_len * 4;
    values = (FP3232*)(ptr + out->valuators_len * 4);
    for (i = 0; i < sizeof(in->valuators.mask) * 8 ||
                i < (out->valuators_len * 4) * 8; i++)
    {
        if (i >= MAX_VALUATORS)
            assert(!XIMaskIsSet(in->valuators.mask, i) && !XIMaskIsSet(ptr, i));
        else if (i > sizeof(in->valuators.mask) * 8)
            assert(!XIMaskIsSet(ptr, i));
        else if (i > out->valuators_len * 4 * 8)
            assert(!XIMaskIsSet(in->valuators.mask, i));
        else {
            assert(XIMaskIsSet(in->valuators.mask, i) ==
                     XIMaskIsSet(ptr, i));

            if (XIMaskIsSet(ptr, i))
            {
                FP3232 vi, vo;

                vi.integral = in->valuators.data[i];
                vi.frac = in->valuators.data_frac[i];

                vo = *values;

                if (swap)
                {
                    char n;
                    swapl(&vo.integral, n);
                    swapl(&vo.frac, n);
                }


                assert(vi.integral == vo.integral);
                assert(vi.frac == vo.frac);
                values++;
            }
        }
    }
}

static void test_XIDeviceEvent(DeviceEvent *in)
{
    xXIDeviceEvent *out, *swapped;
    int rc;

    rc = EventToXI2((InternalEvent*)in, (xEvent**)&out);
    assert(rc == Success);

    test_values_XIDeviceEvent(in, out, FALSE);

    swapped = calloc(1, sizeof(xEvent) + out->length * 4);
    XI2EventSwap((xGenericEvent*)out, (xGenericEvent*)swapped);
    test_values_XIDeviceEvent(in, swapped, TRUE);

    free(out);
    free(swapped);
}

static void test_convert_XIDeviceEvent(void)
{
    DeviceEvent in;
    int i;

    memset(&in, 0, sizeof(in));

    printf("Testing simple field values\n");
    in.header = ET_Internal;
    in.type = ET_Motion;
    in.length = sizeof(DeviceEvent);
    in.time             = 0;
    in.deviceid         = 1;
    in.sourceid         = 2;
    in.root             = 3;
    in.root_x           = 4;
    in.root_x_frac      = 5;
    in.root_y           = 6;
    in.root_y_frac      = 7;
    in.detail.button    = 8;
    in.mods.base        = 9;
    in.mods.latched     = 10;
    in.mods.locked      = 11;
    in.mods.effective   = 11;
    in.group.base       = 12;
    in.group.latched    = 13;
    in.group.locked     = 14;
    in.group.effective  = 15;

    test_XIDeviceEvent(&in);

    printf("Testing field ranges\n");
    /* 32 bit */
    in.detail.button = 1L;
    test_XIDeviceEvent(&in);
    in.detail.button = 1L << 8;
    test_XIDeviceEvent(&in);
    in.detail.button = 1L << 16;
    test_XIDeviceEvent(&in);
    in.detail.button = 1L << 24;
    test_XIDeviceEvent(&in);
    in.detail.button = ~0L;
    test_XIDeviceEvent(&in);

    /* 32 bit */
    in.time = 1L;
    test_XIDeviceEvent(&in);
    in.time = 1L << 8;
    test_XIDeviceEvent(&in);
    in.time = 1L << 16;
    test_XIDeviceEvent(&in);
    in.time = 1L << 24;
    test_XIDeviceEvent(&in);
    in.time = ~0L;
    test_XIDeviceEvent(&in);

    /* 16 bit */
    in.deviceid = 1;
    test_XIDeviceEvent(&in);
    in.deviceid = 1 << 8;
    test_XIDeviceEvent(&in);
    in.deviceid = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    /* 16 bit */
    in.sourceid = 1;
    test_XIDeviceEvent(&in);
    in.deviceid = 1 << 8;
    test_XIDeviceEvent(&in);
    in.deviceid = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    /* 32 bit */
    in.root = 1L;
    test_XIDeviceEvent(&in);
    in.root = 1L << 8;
    test_XIDeviceEvent(&in);
    in.root = 1L << 16;
    test_XIDeviceEvent(&in);
    in.root = 1L << 24;
    test_XIDeviceEvent(&in);
    in.root = ~0L;
    test_XIDeviceEvent(&in);

    /* 16 bit */
    in.root_x = 1;
    test_XIDeviceEvent(&in);
    in.root_x = 1 << 8;
    test_XIDeviceEvent(&in);
    in.root_x = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.root_x_frac = 1;
    test_XIDeviceEvent(&in);
    in.root_x_frac = 1 << 8;
    test_XIDeviceEvent(&in);
    in.root_x_frac = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.root_y = 1;
    test_XIDeviceEvent(&in);
    in.root_y = 1 << 8;
    test_XIDeviceEvent(&in);
    in.root_y = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.root_y_frac = 1;
    test_XIDeviceEvent(&in);
    in.root_y_frac = 1 << 8;
    test_XIDeviceEvent(&in);
    in.root_y_frac = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    /* 32 bit */
    in.mods.base = 1L;
    test_XIDeviceEvent(&in);
    in.mods.base = 1L << 8;
    test_XIDeviceEvent(&in);
    in.mods.base = 1L << 16;
    test_XIDeviceEvent(&in);
    in.mods.base = 1L << 24;
    test_XIDeviceEvent(&in);
    in.mods.base = ~0L;
    test_XIDeviceEvent(&in);

    in.mods.latched = 1L;
    test_XIDeviceEvent(&in);
    in.mods.latched = 1L << 8;
    test_XIDeviceEvent(&in);
    in.mods.latched = 1L << 16;
    test_XIDeviceEvent(&in);
    in.mods.latched = 1L << 24;
    test_XIDeviceEvent(&in);
    in.mods.latched = ~0L;
    test_XIDeviceEvent(&in);

    in.mods.locked = 1L;
    test_XIDeviceEvent(&in);
    in.mods.locked = 1L << 8;
    test_XIDeviceEvent(&in);
    in.mods.locked = 1L << 16;
    test_XIDeviceEvent(&in);
    in.mods.locked = 1L << 24;
    test_XIDeviceEvent(&in);
    in.mods.locked = ~0L;
    test_XIDeviceEvent(&in);

    in.mods.effective = 1L;
    test_XIDeviceEvent(&in);
    in.mods.effective = 1L << 8;
    test_XIDeviceEvent(&in);
    in.mods.effective = 1L << 16;
    test_XIDeviceEvent(&in);
    in.mods.effective = 1L << 24;
    test_XIDeviceEvent(&in);
    in.mods.effective = ~0L;
    test_XIDeviceEvent(&in);

    /* 8 bit */
    in.group.base = 1;
    test_XIDeviceEvent(&in);
    in.group.base = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.group.latched = 1;
    test_XIDeviceEvent(&in);
    in.group.latched = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.group.locked = 1;
    test_XIDeviceEvent(&in);
    in.group.locked = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    in.mods.effective = 1;
    test_XIDeviceEvent(&in);
    in.mods.effective = ~0 & 0xFF;
    test_XIDeviceEvent(&in);

    printf("Testing button masks\n");
    for (i = 0; i < sizeof(in.buttons) * 8; i++)
    {
        XISetMask(in.buttons, i);
        test_XIDeviceEvent(&in);
        XIClearMask(in.buttons, i);
    }

    for (i = 0; i < sizeof(in.buttons) * 8; i++)
    {
        XISetMask(in.buttons, i);
        test_XIDeviceEvent(&in);
    }

    printf("Testing valuator masks\n");
    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);
        test_XIDeviceEvent(&in);
        XIClearMask(in.valuators.mask, i);
    }

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);

        in.valuators.data[i] = i;
        in.valuators.data_frac[i] = i + 20;
        test_XIDeviceEvent(&in);
        XIClearMask(in.valuators.mask, i);
    }

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        XISetMask(in.valuators.mask, i);
        test_XIDeviceEvent(&in);
    }
}

static void test_values_XIDeviceChangedEvent(DeviceChangedEvent *in,
                                             xXIDeviceChangedEvent *out,
                                             BOOL swap)
{
    int i, j;
    unsigned char *ptr;

    if (swap)
    {
        char n;

        swaps(&out->sequenceNumber, n);
        swapl(&out->length, n);
        swaps(&out->evtype, n);
        swaps(&out->deviceid, n);
        swaps(&out->sourceid, n);
        swapl(&out->time, n);
        swaps(&out->num_classes, n);
    }

    assert(out->type == GenericEvent);
    assert(out->extension == 0); /* IReqCode defaults to 0 */
    assert(out->evtype == GetXI2Type((InternalEvent*)in));
    assert(out->time == in->time);
    assert(out->deviceid == in->deviceid);
    assert(out->sourceid == in->sourceid);

    ptr = (unsigned char*)&out[1];
    for (i = 0; i < out->num_classes; i++)
    {
        xXIAnyInfo* any = (xXIAnyInfo*)ptr;

        if (swap)
        {
            char n;
            swaps(&any->length, n);
            swaps(&any->type, n);
            swaps(&any->sourceid, n);
        }

        switch(any->type)
        {
            case XIButtonClass:
                {
                    xXIButtonInfo *b = (xXIButtonInfo*)any;
                    Atom *names;

                    if (swap)
                    {
                        char n;
                        swaps(&b->num_buttons, n);
                    }

                    assert(b->length ==
                            bytes_to_int32(sizeof(xXIButtonInfo)) +
                            bytes_to_int32(bits_to_bytes(b->num_buttons)) +
                            b->num_buttons);
                    assert(b->num_buttons == in->buttons.num_buttons);

                    names = (Atom*)((char*)&b[1] +
                            pad_to_int32(bits_to_bytes(b->num_buttons)));
                    for (j = 0; j < b->num_buttons; j++)
                    {
                        if (swap)
                        {
                            char n;
                            swapl(&names[j], n);
                        }
                        assert(names[j] == in->buttons.names[j]);
                    }
                }
                break;
            case XIKeyClass:
                {
                    xXIKeyInfo *k = (xXIKeyInfo*)any;
                    uint32_t *kc;

                    if (swap)
                    {
                        char n;
                        swaps(&k->num_keycodes, n);
                    }

                    assert(k->length ==
                            bytes_to_int32(sizeof(xXIKeyInfo)) +
                            k->num_keycodes);
                    assert(k->num_keycodes == in->keys.max_keycode -
                            in->keys.min_keycode + 1);

                    kc = (uint32_t*)&k[1];
                    for (j = 0; j < k->num_keycodes; j++)
                    {
                        if (swap)
                        {
                            char n;
                            swapl(&kc[j], n);
                        }
                        assert(kc[j] >= in->keys.min_keycode);
                        assert(kc[j] <= in->keys.max_keycode);
                    }
                }
                break;
            case XIValuatorClass:
                {
                    xXIValuatorInfo *v = (xXIValuatorInfo*)any;
                    assert(v->length ==
                             bytes_to_int32(sizeof(xXIValuatorInfo)));

                }
                break;
            default:
                printf("Invalid class type.\n\n");
                assert(1);
                break;
        }

        ptr += any->length * 4;
    }

}

static void test_XIDeviceChangedEvent(DeviceChangedEvent *in)
{
    xXIDeviceChangedEvent *out, *swapped;
    int rc;

    rc = EventToXI2((InternalEvent*)in, (xEvent**)&out);
    assert(rc == Success);

    test_values_XIDeviceChangedEvent(in, out, FALSE);

    swapped = calloc(1, sizeof(xEvent) + out->length * 4);
    XI2EventSwap((xGenericEvent*)out, (xGenericEvent*)swapped);
    test_values_XIDeviceChangedEvent(in, swapped, TRUE);

    free(out);
    free(swapped);
}

static void test_convert_XIDeviceChangedEvent(void)
{
    DeviceChangedEvent in;
    int i;

    printf("Testing simple field values\n");
    memset(&in, 0, sizeof(in));
    in.header = ET_Internal;
    in.type = ET_DeviceChanged;
    in.length = sizeof(DeviceChangedEvent);
    in.time             = 0;
    in.deviceid         = 1;
    in.sourceid         = 2;
    in.masterid         = 3;
    in.num_valuators    = 4;
    in.flags = DEVCHANGE_SLAVE_SWITCH | DEVCHANGE_POINTER_EVENT | DEVCHANGE_KEYBOARD_EVENT;

    for (i = 0; i < MAX_BUTTONS; i++)
        in.buttons.names[i] = i + 10;

    in.keys.min_keycode = 8;
    in.keys.max_keycode = 255;

    test_XIDeviceChangedEvent(&in);

    in.time = 1L;
    test_XIDeviceChangedEvent(&in);
    in.time = 1L << 8;
    test_XIDeviceChangedEvent(&in);
    in.time = 1L << 16;
    test_XIDeviceChangedEvent(&in);
    in.time = 1L << 24;
    test_XIDeviceChangedEvent(&in);
    in.time = ~0L;
    test_XIDeviceChangedEvent(&in);

    in.deviceid = 1L;
    test_XIDeviceChangedEvent(&in);
    in.deviceid = 1L << 8;
    test_XIDeviceChangedEvent(&in);
    in.deviceid = ~0 & 0xFFFF;
    test_XIDeviceChangedEvent(&in);

    in.sourceid = 1L;
    test_XIDeviceChangedEvent(&in);
    in.sourceid = 1L << 8;
    test_XIDeviceChangedEvent(&in);
    in.sourceid = ~0 & 0xFFFF;
    test_XIDeviceChangedEvent(&in);

    in.masterid = 1L;
    test_XIDeviceChangedEvent(&in);
    in.masterid = 1L << 8;
    test_XIDeviceChangedEvent(&in);
    in.masterid = ~0 & 0xFFFF;
    test_XIDeviceChangedEvent(&in);

    in.buttons.num_buttons = 0;
    test_XIDeviceChangedEvent(&in);

    in.buttons.num_buttons = 1;
    test_XIDeviceChangedEvent(&in);

    in.buttons.num_buttons = MAX_BUTTONS;
    test_XIDeviceChangedEvent(&in);

    in.keys.min_keycode = 0;
    in.keys.max_keycode = 0;
    test_XIDeviceChangedEvent(&in);

    in.keys.max_keycode = 1 << 8;
    test_XIDeviceChangedEvent(&in);

    in.keys.max_keycode = 0xFFFC; /* highest range, above that the length
                                     field gives up */
    test_XIDeviceChangedEvent(&in);

    in.keys.min_keycode = 1 << 8;
    in.keys.max_keycode = 1 << 8;
    test_XIDeviceChangedEvent(&in);

    in.keys.min_keycode = 1 << 8;
    in.keys.max_keycode = 0;
    test_XIDeviceChangedEvent(&in);

    in.num_valuators = 0;
    test_XIDeviceChangedEvent(&in);

    in.num_valuators = 1;
    test_XIDeviceChangedEvent(&in);

    in.num_valuators = MAX_VALUATORS;
    test_XIDeviceChangedEvent(&in);

    for (i = 0; i < MAX_VALUATORS; i++)
    {
        in.valuators[i].min = 0;
        in.valuators[i].max = 0;
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].max = 1 << 8;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].max = 1 << 16;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].max = 1 << 24;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].max = abs(~0);
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].resolution = 1 << 8;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].resolution = 1 << 16;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].resolution = 1 << 24;
        test_XIDeviceChangedEvent(&in);
        in.valuators[i].resolution = abs(~0);
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].name = i;
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].mode = Relative;
        test_XIDeviceChangedEvent(&in);

        in.valuators[i].mode = Absolute;
        test_XIDeviceChangedEvent(&in);
    }
}

int main(int argc, char** argv)
{
    test_convert_XIRawEvent();
    test_convert_XIFocusEvent();
    test_convert_XIDeviceEvent();
    test_convert_XIDeviceChangedEvent();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIGetClientPointer request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xigetclientpointer.h"
#include "exevents.h"

#include "protocol-common.h"

struct {
    int cp_is_set;
    DeviceIntPtr dev;
    int win;
} test_data;

static ClientRec client_window;
static ClientRec client_request;

int __wrap_dixLookupClient(ClientPtr *pClient, XID rid, ClientPtr client, Mask access)
{
    if (rid == ROOT_WINDOW_ID)
        return BadWindow;

    if (rid == CLIENT_WINDOW_ID)
    {
        *pClient = &client_window;
        return Success;
    }

    return __real_dixLookupClient(pClient, rid, client, access);
}


static void reply_XIGetClientPointer(ClientPtr client, int len, char *data, void *userdata)
{
    xXIGetClientPointerReply *rep = (xXIGetClientPointerReply*)data;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swaps(&rep->deviceid, n);
    }

    reply_check_defaults(rep, len, XIGetClientPointer);

    assert(rep->set == test_data.cp_is_set);
    if (rep->set)
        assert(rep->deviceid == test_data.dev->id);
}

static void request_XIGetClientPointer(ClientPtr client, xXIGetClientPointerReq* req, int error)
{
    char n;
    int rc;

    test_data.win = req->win;

    rc = ProcXIGetClientPointer(&client_request);
    assert(rc == error);

    if (rc == BadWindow)
        assert(client_request.errorValue == req->win);

    client_request.swapped = TRUE;
    swapl(&req->win, n);
    swaps(&req->length, n);
    rc = SProcXIGetClientPointer(&client_request);
    assert(rc == error);

    if (rc == BadWindow)
        assert(client_request.errorValue == req->win);

}

static void test_XIGetClientPointer(void)
{
    xXIGetClientPointerReq request;

    request_init(&request, XIGetClientPointer);

    request.win = CLIENT_WINDOW_ID;


    reply_handler = reply_XIGetClientPointer;

    client_request = init_client(request.length, &request);

    printf("Testing invalid window\n");
    request.win = INVALID_WINDOW_ID;
    request_XIGetClientPointer(&client_request, &request, BadWindow);

    test_data.cp_is_set = FALSE;

    printf("Testing window None, unset ClientPointer.\n");
    request.win = None;
    request_XIGetClientPointer(&client_request, &request, Success);

    printf("Testing valid window, unset ClientPointer.\n");
    request.win = CLIENT_WINDOW_ID;
    request_XIGetClientPointer(&client_request, &request, Success);

    printf("Testing valid window, set ClientPointer.\n");
    client_window.clientPtr = devices.vcp;
    test_data.dev = devices.vcp;
    test_data.cp_is_set = TRUE;
    request.win = CLIENT_WINDOW_ID;
    request_XIGetClientPointer(&client_request, &request, Success);

    client_window.clientPtr = NULL;

    printf("Testing window None, set ClientPointer.\n");
    client_request.clientPtr = devices.vcp;
    test_data.dev = devices.vcp;
    test_data.cp_is_set = TRUE;
    request.win = None;
    request_XIGetClientPointer(&client_request, &request, Success);
}

int main(int argc, char** argv)
{
    init_simple();
    client_window = init_client(0, NULL);

    test_XIGetClientPointer();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIGetSelectedEvents request.
 *
 * Tests include:
 * BadWindow on wrong window.
 * Zero-length masks if no masks are set.
 * Valid masks for valid devices.
 * Masks set on non-existent devices are not returned.
 *
 * Note that this test is not connected to the XISelectEvents request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "extinit.h" /* for XInputExtensionInit */
#include "scrnintstr.h"
#include "xiselectev.h"
#include "exevents.h"

#include "protocol-common.h"

static void reply_XIGetSelectedEvents(ClientPtr client, int len, char *data, void *userdata);
static void reply_XIGetSelectedEvents_data(ClientPtr client, int len, char *data, void *userdata);


struct {
    int num_masks_expected;
    unsigned char mask[MAXDEVICES][XI2LASTEVENT]; /* intentionally bigger */
    int mask_len;
} test_data;

/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

/* AddResource is called from XISetSEventMask, we don't need this */
Bool __wrap_AddResource(XID id, RESTYPE type, pointer value)
{
    return TRUE;
}

static void reply_XIGetSelectedEvents(ClientPtr client, int len, char *data, void *userdata)
{
    xXIGetSelectedEventsReply *rep = (xXIGetSelectedEventsReply*)data;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swaps(&rep->num_masks, n);
    }

    reply_check_defaults(rep, len, XIGetSelectedEvents);

    assert(rep->num_masks == test_data.num_masks_expected);

    reply_handler = reply_XIGetSelectedEvents_data;
}

static void reply_XIGetSelectedEvents_data(ClientPtr client, int len, char *data, void *userdata)
{
    int i;
    xXIEventMask *mask;
    unsigned char *bitmask;

    mask = (xXIEventMask*)data;
    for (i = 0; i < test_data.num_masks_expected; i++)
    {
        if (client->swapped)
        {
            char n;
            swaps(&mask->deviceid, n);
            swaps(&mask->mask_len, n);
        }

        assert(mask->deviceid < 6);
        assert(mask->mask_len <= (((XI2LASTEVENT + 8)/8) + 3)/4) ;

        bitmask = (unsigned char*)&mask[1];
        assert(memcmp(bitmask,
                    test_data.mask[mask->deviceid],
                    mask->mask_len * 4) == 0);

        mask = (xXIEventMask*)((char*)mask + mask->mask_len * 4 + sizeof(xXIEventMask));
    }


}

static void request_XIGetSelectedEvents(xXIGetSelectedEventsReq* req, int error)
{
    char n;
    int rc;
    ClientRec client;
    client = init_client(req->length, req);

    reply_handler = reply_XIGetSelectedEvents;

    rc = ProcXIGetSelectedEvents(&client);
    assert(rc == error);

    reply_handler = reply_XIGetSelectedEvents;
    client.swapped = TRUE;
    swapl(&req->win, n);
    swaps(&req->length, n);
    rc = SProcXIGetSelectedEvents(&client);
    assert(rc == error);
}

static void test_XIGetSelectedEvents(void)
{
    int i, j;
    xXIGetSelectedEventsReq request;
    ClientRec client = init_client(0, NULL);
    unsigned char *mask;
    DeviceIntRec dev;

    request_init(&request, XIGetSelectedEvents);

    printf("Testing for BadWindow on invalid window.\n");
    request.win = None;
    request_XIGetSelectedEvents(&request, BadWindow);

    printf("Testing for zero-length (unset) masks.\n");
    /* No masks set yet */
    test_data.num_masks_expected = 0;
    request.win = ROOT_WINDOW_ID;
    request_XIGetSelectedEvents(&request, Success);

    request.win = CLIENT_WINDOW_ID;
    request_XIGetSelectedEvents(&request, Success);

    memset(test_data.mask, 0,
           sizeof(test_data.mask));

    printf("Testing for valid masks\n");
    memset(&dev, 0, sizeof(dev)); /* dev->id is enough for XISetEventMask */
    request.win = ROOT_WINDOW_ID;

    /* devices 6 - MAXDEVICES don't exist, they mustn't be included in the
     * reply even if a mask is set */
    for (j = 0; j < MAXDEVICES; j++)
    {
        test_data.num_masks_expected = min(j + 1, devices.num_devices + 2);
        dev.id = j;
        mask = test_data.mask[j];
        /* bits one-by-one */
        for (i = 0; i < XI2LASTEVENT; i++)
        {
            SetBit(mask, i);
            XISetEventMask(&dev, &root, &client, (i + 8)/8, mask);
            request_XIGetSelectedEvents(&request, Success);
            ClearBit(mask, i);
        }

        /* all valid mask bits */
        for (i = 0; i < XI2LASTEVENT; i++)
        {
            SetBit(mask, i);
            XISetEventMask(&dev, &root, &client, (i + 8)/8, mask);
            request_XIGetSelectedEvents(&request, Success);
        }
    }

    printf("Testing removing all masks\n");
    /* Unset all masks one-by-one */
    for (j = MAXDEVICES - 1; j >= 0; j--)
    {
        if (j < devices.num_devices + 2)
            test_data.num_masks_expected--;

        mask = test_data.mask[j];
        memset(mask, 0, XI2LASTEVENT);

        dev.id = j;
        XISetEventMask(&dev, &root, &client, 0, NULL);

        request_XIGetSelectedEvents(&request, Success);
    }
}

int main(int argc, char** argv)
{
    init_simple();

    test_XIGetSelectedEvents();

    return 0;
}

/**
 * Copyright © 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIPassiveGrab request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xipassivegrab.h"
#include "exevents.h"

#include "protocol-common.h"

static ClientRec client_request;
#define N_MODS 7
static uint32_t modifiers[N_MODS] = {1, 2, 3, 4, 5, 6, 7};

struct test_data {
    int num_modifiers;
} testdata;

int __wrap_GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
                      int button, GrabParameters *param, GrabType grabtype,
                      GrabMask *mask);
static void reply_XIPassiveGrabDevice_data(ClientPtr client, int len, char *data, void *userdata);

int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

int __wrap_GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
                      int button, GrabParameters *param, GrabType grabtype,
                      GrabMask *mask)
{
    /* Fail every odd modifier */
    if (param->modifiers % 2)
        return BadAccess;

    return Success;
}

static void reply_XIPassiveGrabDevice(ClientPtr client, int len, char *data, void *userdata)
{
    xXIPassiveGrabDeviceReply *rep = (xXIPassiveGrabDeviceReply*)data;

    if (client->swapped)
    {
        char n;
        swaps(&rep->sequenceNumber, n);
        swapl(&rep->length, n);
        swaps(&rep->num_modifiers, n);

        testdata.num_modifiers = rep->num_modifiers;
    }

    reply_check_defaults(rep, len, XIPassiveGrabDevice);

    /* ProcXIPassiveGrabDevice sends the data in two batches, let the second
     * handler handle the modifier data */
    if (rep->num_modifiers > 0)
        reply_handler = reply_XIPassiveGrabDevice_data;
}

static void reply_XIPassiveGrabDevice_data(ClientPtr client, int len, char *data, void *userdata)
{
    int i;
    int n;

    xXIGrabModifierInfo *mods = (xXIGrabModifierInfo*)data;

    for (i = 0; i < testdata.num_modifiers; i++, mods++)
    {
        if (client->swapped)
            swapl(&mods->modifiers, n);

        /* 1 - 7 is the range we use for the global modifiers array
         * above */
        assert(mods->modifiers > 0);
        assert(mods->modifiers <= 7);
        assert(mods->modifiers % 2 == 1); /* because we fail odd ones */
        assert(mods->status != Success);
        assert(mods->pad0 == 0);
        assert(mods->pad1 == 0);
    }

    reply_handler = reply_XIPassiveGrabDevice;
}

static void request_XIPassiveGrabDevice(ClientPtr client, xXIPassiveGrabDeviceReq* req, int error, int errval)
{
    char n;
    int rc;
    int modifiers;

    rc = ProcXIPassiveGrabDevice(&client_request);
    assert(rc == error);

    if (rc != Success)
        assert(client_request.errorValue == errval);

    client_request.swapped = TRUE;
    swaps(&req->length, n);
    swapl(&req->time, n);
    swapl(&req->grab_window, n);
    swapl(&req->cursor, n);
    swapl(&req->detail, n);
    swaps(&req->deviceid, n);
    modifiers = req->num_modifiers;
    swaps(&req->num_modifiers, n);
    swaps(&req->mask_len, n);

    while(modifiers--)
    {
        CARD32 *mod = ((CARD32*)(req + 1)) + modifiers;
        swapl(mod, n);
    }

    rc = SProcXIPassiveGrabDevice(&client_request);
    assert(rc == error);

    if (rc != Success)
        assert(client_request.errorValue == errval);
}

static unsigned char *data[4096]; /* the request buffer */
static void test_XIPassiveGrabDevice(void)
{
    int i;
    xXIPassiveGrabDeviceReq *request = (xXIPassiveGrabDeviceReq*)data;
    unsigned char *mask;

    request_init(request, XIPassiveGrabDevice);

    request->grab_window = CLIENT_WINDOW_ID;

    reply_handler = reply_XIPassiveGrabDevice;
    client_request = init_client(request->length, request);

    printf("Testing invalid device\n");
    request->deviceid = 12;
    request_XIPassiveGrabDevice(&client_request, request, BadDevice, request->deviceid);

    request->deviceid = XIAllMasterDevices;

    printf("Testing invalid grab types\n");
    for (i = XIGrabtypeFocusIn + 1; i < 0xFF; i++)
    {
        request->grab_type = i;
        request_XIPassiveGrabDevice(&client_request, request, BadValue, request->grab_type);
    }

    printf("Testing invalid grab type + detail combinations\n");
    request->grab_type = XIGrabtypeEnter;
    request->detail = 1;
    request_XIPassiveGrabDevice(&client_request, request, BadValue, request->detail);

    request->grab_type = XIGrabtypeFocusIn;
    request_XIPassiveGrabDevice(&client_request, request, BadValue, request->detail);

    request->detail = 0;

    printf("Testing invalid masks\n");
    mask = (unsigned char*)&request[1];

    request->mask_len = bytes_to_int32(XI2LASTEVENT + 1);
    request->length += request->mask_len;
    SetBit(mask, XI2LASTEVENT + 1);
    request_XIPassiveGrabDevice(&client_request, request, BadValue, XI2LASTEVENT + 1);

    ClearBit(mask, XI2LASTEVENT + 1);

    /* tested all special cases now, test a few valid cases */

    /* no modifiers */
    request->deviceid = XIAllDevices;
    request->grab_type = XIGrabtypeButton;
    request->detail = XIAnyButton;
    request_XIPassiveGrabDevice(&client_request, request, Success, 0);

    /* some modifiers */
    request->num_modifiers = N_MODS;
    request->length += N_MODS;
    memcpy((uint32_t*)(request + 1) + request->mask_len, modifiers, sizeof(modifiers));
    request_XIPassiveGrabDevice(&client_request, request, Success, 0);
}

int main(int argc, char** argv)
{
    init_simple();

    test_XIPassiveGrabDevice();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/Xatom.h>
#include "inputstr.h"
#include "extinit.h"
#include "scrnintstr.h"
#include "xkbsrv.h"

#include "xiquerydevice.h"

#include "protocol-common.h"
/*
 * Protocol testing for XIQueryDevice request and reply.
 *
 * Test approach:
 * Wrap WriteToClient to intercept server's reply. ProcXIQueryDevice returns
 * data in two batches, once for the request, once for the trailing data
 * with the device information.
 * Repeatedly test with varying deviceids and check against data in reply.
 */

struct test_data {
    int which_device;
    int num_devices_in_reply;
};

static void reply_XIQueryDevice_data(ClientPtr client, int len, char *data, void *userdata);
static void reply_XIQueryDevice(ClientPtr client, int len, char* data, void *userdata);

/* reply handling for the first bytes that constitute the reply */
static void reply_XIQueryDevice(ClientPtr client, int len, char* data, void *userdata)
{
    xXIQueryDeviceReply *rep = (xXIQueryDeviceReply*)data;
    struct test_data *querydata = (struct test_data*)userdata;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swaps(&rep->num_devices, n);
    }

    reply_check_defaults(rep, len, XIQueryDevice);

    if (querydata->which_device == XIAllDevices)
        assert(rep->num_devices == devices.num_devices);
    else if (querydata->which_device == XIAllMasterDevices)
        assert(rep->num_devices == devices.num_master_devices);
    else
        assert(rep->num_devices == 1);

    querydata->num_devices_in_reply = rep->num_devices;
    reply_handler = reply_XIQueryDevice_data;
}

/* reply handling for the trailing bytes that constitute the device info */
static void reply_XIQueryDevice_data(ClientPtr client, int len, char *data, void *userdata)
{
    char n;
    int i, j;
    struct test_data *querydata = (struct test_data*)userdata;

    DeviceIntPtr dev;
    xXIDeviceInfo *info = (xXIDeviceInfo*)data;
    xXIAnyInfo *any;

    for (i = 0; i < querydata->num_devices_in_reply; i++)
    {
        if (client->swapped)
        {
            swaps(&info->deviceid, n);
            swaps(&info->attachment, n);
            swaps(&info->use, n);
            swaps(&info->num_classes, n);
            swaps(&info->name_len, n);
        }

        if (querydata->which_device > XIAllMasterDevices)
            assert(info->deviceid == querydata->which_device);

        assert(info->deviceid >=  2); /* 0 and 1 is reserved */


        switch(info->deviceid)
        {
            case 2:  /* VCP */
                dev = devices.vcp;
                assert(info->use == XIMasterPointer);
                assert(info->attachment == devices.vck->id);
                assert(info->num_classes == 3); /* 2 axes + button */
                break;
            case 3:  /* VCK */
                dev = devices.vck;
                assert(info->use == XIMasterKeyboard);
                assert(info->attachment == devices.vcp->id);
                assert(info->num_classes == 1);
                break;
            case 4:  /* mouse */
                dev = devices.mouse;
                assert(info->use == XISlavePointer);
                assert(info->attachment == devices.vcp->id);
                assert(info->num_classes == 3); /* 2 axes + button */
                break;
            case 5:  /* keyboard */
                dev = devices.kbd;
                assert(info->use == XISlaveKeyboard);
                assert(info->attachment == devices.vck->id);
                assert(info->num_classes == 1);
                break;

            default:
                /* We shouldn't get here */
                assert(0);
                break;
        }
        assert(info->enabled == dev->enabled);
        assert(info->name_len == strlen(dev->name));
        assert(strncmp((char*)&info[1], dev->name, info->name_len) == 0);

        any = (xXIAnyInfo*)((char*)&info[1] + ((info->name_len + 3)/4) * 4);
        for (j = 0; j < info->num_classes; j++)
        {
            if (client->swapped)
            {
                swaps(&any->type, n);
                swaps(&any->length, n);
                swaps(&any->sourceid, n);
            }

            switch(info->deviceid)
            {
                case 3: /* VCK and kbd have the same properties */
                case 5:
                    {
                        int k;
                        xXIKeyInfo *ki = (xXIKeyInfo*)any;
                        XkbDescPtr xkb = devices.vck->key->xkbInfo->desc;
                        uint32_t *kc;

                        if (client->swapped)
                            swaps(&ki->num_keycodes, n);

                        assert(any->type == XIKeyClass);
                        assert(ki->num_keycodes == (xkb->max_key_code - xkb->min_key_code + 1));
                        assert(any->length == (2 + ki->num_keycodes));

                        kc = (uint32_t*)&ki[1];
                        for (k = 0; k < ki->num_keycodes; k++, kc++)
                        {
                            if (client->swapped)
                                swapl(kc, n);

                            assert(*kc >= xkb->min_key_code);
                            assert(*kc <= xkb->max_key_code);
                        }
                        break;
                    }
                case 2: /* VCP and mouse have the same properties */
                case 4:
                    {
                        assert(any->type == XIButtonClass ||
                                any->type == XIValuatorClass);

                        if (any->type == XIButtonClass)
                        {
                            int len;
                            xXIButtonInfo *bi = (xXIButtonInfo*)any;

                            if (client->swapped)
                                swaps(&bi->num_buttons, n);

                            assert(bi->num_buttons == devices.vcp->button->numButtons);

                            len = 2 + bi->num_buttons + bytes_to_int32(bits_to_bytes(bi->num_buttons));
                            assert(bi->length == len);
                        } else if (any->type == XIValuatorClass)
                        {
                            xXIValuatorInfo *vi = (xXIValuatorInfo*)any;

                            if (client->swapped)
                            {
                                swaps(&vi->number, n);
                                swapl(&vi->label, n);
                                swapl(&vi->min.integral, n);
                                swapl(&vi->min.frac, n);
                                swapl(&vi->max.integral, n);
                                swapl(&vi->max.frac, n);
                                swapl(&vi->resolution, n);
                            }

                            assert(vi->length == 11);
                            assert(vi->number == 0 ||
                                     vi->number == 1);
                            assert(vi->mode == XIModeRelative);
                            /* device was set up as relative, so standard
                             * values here. */
                            assert(vi->min.integral == -1);
                            assert(vi->min.frac == 0);
                            assert(vi->max.integral == -1);
                            assert(vi->max.frac == 0);
                            assert(vi->resolution == 0);
                        }
                    }
                    break;
            }
            any = (xXIAnyInfo*)(((char*)any) + any->length * 4);
        }

        info = (xXIDeviceInfo*)any;
    }
}

static void request_XIQueryDevice(struct test_data *querydata,
                                 int deviceid, int error)
{
    int rc;
    char n;
    ClientRec client;
    xXIQueryDeviceReq request;

    request_init(&request, XIQueryDevice);
    client = init_client(request.length, &request);
    reply_handler = reply_XIQueryDevice;

    querydata->which_device = deviceid;

    request.deviceid = deviceid;
    rc = ProcXIQueryDevice(&client);
    assert(rc == error);

    if (rc != Success)
        assert(client.errorValue == deviceid);

    reply_handler = reply_XIQueryDevice;

    client.swapped = TRUE;
    swaps(&request.length, n);
    swaps(&request.deviceid, n);
    rc = SProcXIQueryDevice(&client);
    assert(rc == error);

    if (rc != Success)
        assert(client.errorValue == deviceid);
}

static void test_XIQueryDevice(void)
{
    int i;
    xXIQueryDeviceReq request;
    struct test_data data;

    reply_handler = reply_XIQueryDevice;
    userdata = &data;
    request_init(&request, XIQueryDevice);

    printf("Testing XIAllDevices.\n");
    request_XIQueryDevice(&data, XIAllDevices, Success);
    printf("Testing XIAllMasterDevices.\n");
    request_XIQueryDevice(&data, XIAllMasterDevices, Success);

    printf("Testing existing device ids.\n");
    for (i = 2; i < 6; i++)
        request_XIQueryDevice(&data, i, Success);

    printf("Testing non-existing device ids.\n");
    for (i = 6; i <= 0xFFFF; i++)
        request_XIQueryDevice(&data, i, BadDevice);


    reply_handler = NULL;

}

int main(int argc, char** argv)
{
    init_simple();

    test_XIQueryDevice();

    return 0;
}

/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIQueryPointer request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xiquerypointer.h"
#include "exevents.h"

#include "protocol-common.h"

static ClientRec client_request;
static void reply_XIQueryPointer_data(ClientPtr client, int len,
                                      char *data, void *userdata);

static struct {
    DeviceIntPtr dev;
    WindowPtr win;
} test_data;


/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

static void reply_XIQueryPointer(ClientPtr client, int len, char *data,
                                 void *userdata)
{
    xXIQueryPointerReply *rep = (xXIQueryPointerReply*)data;
    SpritePtr sprite;

    if (!rep->repType)
        return;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swapl(&rep->root, n);
        swapl(&rep->child, n);
        swapl(&rep->root_x, n);
        swapl(&rep->root_y, n);
        swapl(&rep->win_x, n);
        swapl(&rep->win_y, n);
        swaps(&rep->buttons_len, n);
    }

    reply_check_defaults(rep, len, XIQueryPointer);

    assert(rep->root == root.drawable.id);
    assert(rep->same_screen == xTrue);

    sprite = test_data.dev->spriteInfo->sprite;
    assert((rep->root_x >> 16) == sprite->hot.x);
    assert((rep->root_y >> 16) == sprite->hot.y);

    if (test_data.win == &root)
    {
        assert(rep->root_x == rep->win_x);
        assert(rep->root_y == rep->win_y);
        assert(rep->child == window.drawable.id);
    } else
    {
        int x, y;

        x = sprite->hot.x - window.drawable.x;
        y = sprite->hot.y - window.drawable.y;

        assert((rep->win_x >> 16) == x);
        assert((rep->win_y >> 16) == y);
        assert(rep->child == None);
    }


    assert(rep->same_screen == xTrue);

    reply_handler = reply_XIQueryPointer_data;
}

static void reply_XIQueryPointer_data(ClientPtr client, int len, char *data, void *userdata)
{
    reply_handler = reply_XIQueryPointer;
}

static void request_XIQueryPointer(ClientPtr client, xXIQueryPointerReq* req, int error)
{
    char n;
    int rc;

    rc = ProcXIQueryPointer(&client_request);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client_request.errorValue == req->deviceid);

    client_request.swapped = TRUE;
    swaps(&req->deviceid, n);
    swaps(&req->length, n);
    rc = SProcXIQueryPointer(&client_request);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client_request.errorValue == req->deviceid);
}

static void test_XIQueryPointer(void)
{
    int i;
    xXIQueryPointerReq request;

    memset(&request, 0, sizeof(request));

    request_init(&request, XIQueryPointer);

    reply_handler = reply_XIQueryPointer;

    client_request = init_client(request.length, &request);

    request.deviceid = XIAllDevices;
    request_XIQueryPointer(&client_request, &request, BadDevice);

    request.deviceid = XIAllMasterDevices;
    request_XIQueryPointer(&client_request, &request, BadDevice);

    request.win = root.drawable.id;
    test_data.win = &root;

    test_data.dev = devices.vcp;
    request.deviceid = devices.vcp->id;
    request_XIQueryPointer(&client_request, &request, Success);
    request.deviceid = devices.vck->id;
    request_XIQueryPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.mouse->id;
    request_XIQueryPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.kbd->id;
    request_XIQueryPointer(&client_request, &request, BadDevice);

    test_data.dev = devices.mouse;
    devices.mouse->master = NULL; /* Float, kind-of */
    request.deviceid = devices.mouse->id;
    request_XIQueryPointer(&client_request, &request, Success);

    for (i = devices.kbd->id + 1; i <= 0xFFFF; i++)
    {
        request.deviceid = i;
        request_XIQueryPointer(&client_request, &request, BadDevice);
    }

    request.win = window.drawable.id;

    test_data.dev = devices.vcp;
    test_data.win = &window;
    request.deviceid = devices.vcp->id;
    request_XIQueryPointer(&client_request, &request, Success);

    test_data.dev = devices.mouse;
    request.deviceid = devices.mouse->id;
    request_XIQueryPointer(&client_request, &request, Success);
}

int main(int argc, char** argv)
{
    init_simple();

    test_XIQueryPointer();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIQueryVersion request and reply.
 *
 * Test approach:
 * Wrap WriteToClient to intercept the server's reply.
 * Repeatedly test a client/server version combination, compare version in
 * reply with versions given. Version must be equal to either
 * server version or client version, whichever is smaller.
 * Client version less than 2 must return BadValue.
 */

#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "extinit.h" /* for XInputExtensionInit */
#include "scrnintstr.h"
#include "xiqueryversion.h"

#include "protocol-common.h"

extern XExtensionVersion XIVersion;

struct test_data {
    int major_client;
    int minor_client;
    int major_server;
    int minor_server;
};

static void reply_XIQueryVersion(ClientPtr client, int len, char* data, void *userdata)
{
    xXIQueryVersionReply *rep = (xXIQueryVersionReply*)data;
    struct test_data *versions = (struct test_data*)userdata;
    unsigned int sver, cver, ver;

    if (client->swapped)
    {
        char n;
        swapl(&rep->length, n);
        swaps(&rep->sequenceNumber, n);
        swaps(&rep->major_version, n);
        swaps(&rep->minor_version, n);
    }

    reply_check_defaults(rep, len, XIQueryVersion);

    assert(rep->length == 0);

    sver = versions->major_server * 1000 + versions->minor_server;
    cver = versions->major_client * 1000 + versions->minor_client;
    ver = rep->major_version * 1000 + rep->minor_version;

    assert(ver >= 2000);
    assert((sver > cver) ? ver == cver : ver == sver);
}

/**
 * Run a single test with server version smaj.smin and client
 * version cmaj.cmin. Verify that return code is equal to 'error'.
 *
 * Test is run normal, then for a swapped client.
 */
static void request_XIQueryVersion(int smaj, int smin, int cmaj, int cmin, int error)
{
    char n;
    int rc;
    struct test_data versions;
    xXIQueryVersionReq request;
    ClientRec client;

    request_init(&request, XIQueryVersion);
    client = init_client(request.length, &request);
    userdata = (void*)&versions;

    /* Change the server to support smaj.smin */
    XIVersion.major_version = smaj;
    XIVersion.minor_version = smin;

    /* remember versions we send and expect */
    versions.major_client = cmaj;
    versions.minor_client = cmin;
    versions.major_server = XIVersion.major_version;
    versions.minor_server = XIVersion.minor_version;

    request.major_version = versions.major_client;
    request.minor_version = versions.minor_client;
    rc = ProcXIQueryVersion(&client);
    assert(rc == error);

    client.swapped = TRUE;

    swaps(&request.length, n);
    swaps(&request.major_version, n);
    swaps(&request.minor_version, n);

    rc = SProcXIQueryVersion(&client);
    assert(rc == error);
}

/* Client version less than 2.0 must return BadValue, all other combinations
 * Success */
static void test_XIQueryVersion(void)
{
    reply_handler = reply_XIQueryVersion;

    printf("Server version 2.0 - client versions [1..3].0\n");
    /* some simple tests to catch common errors quickly */
    request_XIQueryVersion(2, 0, 1, 0, BadValue);
    request_XIQueryVersion(2, 0, 2, 0, Success);
    request_XIQueryVersion(2, 0, 3, 0, Success);

    printf("Server version 3.0 - client versions [1..3].0\n");
    request_XIQueryVersion(3, 0, 1, 0, BadValue);
    request_XIQueryVersion(3, 0, 2, 0, Success);
    request_XIQueryVersion(3, 0, 3, 0, Success);

    printf("Server version 2.0 - client versions [1..3].[1..3]\n");
    request_XIQueryVersion(2, 0, 1, 1, BadValue);
    request_XIQueryVersion(2, 0, 2, 2, Success);
    request_XIQueryVersion(2, 0, 3, 3, Success);

    printf("Server version 2.2 - client versions [1..3].0\n");
    request_XIQueryVersion(2, 2, 1, 0, BadValue);
    request_XIQueryVersion(2, 2, 2, 0, Success);
    request_XIQueryVersion(2, 2, 3, 0, Success);

#if 0
    /* this one takes a while */
    unsigned int cmin, cmaj, smin, smaj;

    printf("Testing all combinations.\n");
    for (smaj = 2; smaj <= 0xFFFF; smaj++)
        for (smin = 0; smin <= 0xFFFF; smin++)
            for (cmin = 0; cmin <= 0xFFFF; cmin++)
                for (cmaj = 0; cmaj <= 0xFFFF; cmaj++)
                {
                    int error = (cmaj < 2) ? BadValue : Success;
                    request_XIQueryVersion(smaj, smin, cmaj, cmin, error);
                }

#endif

    reply_handler = NULL;
}

int main(int argc, char** argv)
{
    init_simple();

    test_XIQueryVersion();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XISelectEvents request.
 *
 * Test approach:
 *
 * Wrap XISetEventMask to intercept when the server tries to apply the event
 * mask. Ensure that the mask passed in is equivalent to the one supplied by
 * the client. Ensure that invalid devices and invalid masks return errors
 * as appropriate.
 *
 * Tests included:
 * BadValue for num_masks < 0
 * BadWindow for invalid windows
 * BadDevice for non-existing devices
 * BadImplemenation for devices >= 0xFF
 * BadValue if HierarchyChanged bit is set for devices other than
 *          XIAllDevices
 * BadValue for invalid mask bits
 * Sucecss for excessive mask lengths
 *
 */

#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "extinit.h" /* for XInputExtensionInit */
#include "scrnintstr.h"
#include "xiselectev.h"

#include "protocol-common.h"

static unsigned char *data[4096 * 20]; /* the request data buffer */

int __wrap_XISetEventMask(DeviceIntPtr dev, WindowPtr win, int len, unsigned char* mask)
{
    return Success;
}

/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}


static void request_XISelectEvent(xXISelectEventsReq *req, int error)
{
    char n;
    int i;
    int rc;
    ClientRec client;
    xXIEventMask *mask, *next;

    req->length = (sz_xXISelectEventsReq/4);
    mask = (xXIEventMask*)&req[1];
    for (i = 0; i < req->num_masks; i++)
    {
        req->length += sizeof(xXIEventMask)/4 + mask->mask_len;
        mask = (xXIEventMask*)((char*)&mask[1] + mask->mask_len * 4);
    }

    client = init_client(req->length, req);

    rc = ProcXISelectEvents(&client);
    assert(rc == error);

    client.swapped = TRUE;

    mask = (xXIEventMask*)&req[1];
    for (i = 0; i < req->num_masks; i++)
    {
        next = (xXIEventMask*)((char*)&mask[1] + mask->mask_len * 4);
        swaps(&mask->deviceid, n);
        swaps(&mask->mask_len, n);
        mask = next;
    }

    swapl(&req->win, n);
    swaps(&req->length, n);
    swaps(&req->num_masks, n);
    rc = SProcXISelectEvents(&client);
    assert(rc == error);
}

static void request_XISelectEvents_masks(xXISelectEventsReq *req)
{
    int i, j;
    xXIEventMask *mask;
    int nmasks = (XI2LASTEVENT + 7)/8;
    unsigned char *bits;

    mask = (xXIEventMask*)&req[1];
    req->win = ROOT_WINDOW_ID;

    /* if a clients submits more than 100 masks, consider it insane and untested */
    for (i = 1; i <= 1000; i++)
    {
        req->num_masks = i;
        mask->deviceid = XIAllDevices;

        /* Test 0:
         * mask_len is 0 -> Success
         */
        mask->mask_len = 0;
        request_XISelectEvent(req, Success);

        /* Test 1:
         * mask may be larger than needed for XI2LASTEVENT.
         * Test setting each valid mask bit, while leaving unneeded bits 0.
         * -> Success
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4 * 10;
        memset(bits, 0, mask->mask_len * 4);
        for (j = 0; j <= XI2LASTEVENT; j++)
        {
            SetBit(bits, j);
            request_XISelectEvent(req, Success);
            ClearBit(bits, j);
        }

        /* Test 2:
         * mask may be larger than needed for XI2LASTEVENT.
         * Test setting all valid mask bits, while leaving unneeded bits 0.
         * -> Success
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4 * 10;
        memset(bits, 0, mask->mask_len * 4);

        for (j = 0; j <= XI2LASTEVENT; j++)
        {
            SetBit(bits, j);
            request_XISelectEvent(req, Success);
        }

        /* Test 3:
         * mask is larger than needed for XI2LASTEVENT. If any unneeded bit
         * is set -> BadValue
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4 * 10;
        memset(bits, 0, mask->mask_len * 4);

        for (j = XI2LASTEVENT + 1; j < mask->mask_len * 4; j++)
        {
            SetBit(bits, j);
            request_XISelectEvent(req, BadValue);
            ClearBit(bits, j);
        }

        /* Test 4:
         * Mask len is a sensible length, only valid bits are set -> Success
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4;
        memset(bits, 0, mask->mask_len * 4);
        for (j = 0; j <= XI2LASTEVENT; j++)
        {
            SetBit(bits, j);
            request_XISelectEvent(req, Success);
        }

        /* Test 5:
         * HierarchyChanged bit is BadValue for devices other than
         * XIAllDevices
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4;
        memset(bits, 0, mask->mask_len * 4);
        SetBit(bits, XI_HierarchyChanged);
        mask->deviceid = XIAllDevices;
        request_XISelectEvent(req, Success);
        for (j = 1; j < devices.num_devices; j++)
        {
            mask->deviceid = j;
            request_XISelectEvent(req, BadValue);
        }

        /* Test 6:
         * All bits set minus hierarchy changed bit -> Success
         */
        bits = (unsigned char*)&mask[1];
        mask->mask_len = (nmasks + 3)/4;
        memset(bits, 0, mask->mask_len * 4);
        for (j = 0; j <= XI2LASTEVENT; j++)
            SetBit(bits, j);
        ClearBit(bits, XI_HierarchyChanged);
        for (j = 1; j < 6; j++)
        {
            mask->deviceid = j;
            request_XISelectEvent(req, Success);
        }

        mask = (xXIEventMask*)((char*)mask + sizeof(xXIEventMask) + mask->mask_len * 4);
    }
}

static void test_XISelectEvents(void)
{
    int i;
    xXIEventMask *mask;
    xXISelectEventsReq *req;
    req = (xXISelectEventsReq*)data;

    request_init(req, XISelectEvents);

    printf("Testing for BadValue on zero-length masks\n");
    /* zero masks are BadValue, regardless of the window */
    req->num_masks = 0;

    req->win = None;
    request_XISelectEvent(req, BadValue);

    req->win = ROOT_WINDOW_ID;
    request_XISelectEvent(req, BadValue);

    req->win = CLIENT_WINDOW_ID;
    request_XISelectEvent(req, BadValue);

    printf("Testing for BadWindow.\n");
    /* None window is BadWindow, regardless of the masks.
     * We don't actually need to set the masks here, BadWindow must occur
     * before checking the masks.
     */
    req->win = None;
    req->num_masks = 1;
    request_XISelectEvent(req, BadWindow);

    req->num_masks = 2;
    request_XISelectEvent(req, BadWindow);

    req->num_masks = 0xFF;
    request_XISelectEvent(req, BadWindow);

    /* request size is 3, so 0xFFFC is the highest num_mask that doesn't
     * overflow req->length */
    req->num_masks = 0xFFFC;
    request_XISelectEvent(req, BadWindow);

    printf("Triggering num_masks/length overflow\n");
    req->win = ROOT_WINDOW_ID;
    /* Integer overflow - req->length can't hold that much */
    req->num_masks = 0xFFFF;
    request_XISelectEvent(req, BadLength);

    req->win = ROOT_WINDOW_ID;
    req->num_masks = 1;

    printf("Triggering bogus mask length error\n");
    mask = (xXIEventMask*)&req[1];
    mask->deviceid = 0;
    mask->mask_len = 0xFFFF;
    request_XISelectEvent(req, BadLength);

    /* testing various device ids */
    printf("Testing existing device ids.\n");
    for (i = 0; i < 6; i++)
    {
        mask = (xXIEventMask*)&req[1];
        mask->deviceid = i;
        mask->mask_len = 1;
        req->win = ROOT_WINDOW_ID;
        req->num_masks = 1;
        request_XISelectEvent(req, Success);
    }

    printf("Testing non-existing device ids.\n");
    for (i = 6; i <= 0xFFFF; i++)
    {
        req->win = ROOT_WINDOW_ID;
        req->num_masks = 1;
        mask = (xXIEventMask*)&req[1];
        mask->deviceid = i;
        mask->mask_len = 1;
        request_XISelectEvent(req, BadDevice);
    }

    request_XISelectEvents_masks(req);
}

int main(int argc, char** argv)
{
    init_simple();

    test_XISelectEvents();

    return 0;
}

/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XISetClientPointer request.
 *
 * Tests include:
 * BadDevice of all devices except master pointers.
 * Success for a valid window.
 * Success for window None.
 * BadWindow for invalid windows.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "extinit.h" /* for XInputExtensionInit */
#include "scrnintstr.h"
#include "xisetclientpointer.h"
#include "exevents.h"

#include "protocol-common.h"

static ClientRec client_window;
static ClientRec client_request;

int __wrap_dixLookupClient(ClientPtr *pClient, XID rid, ClientPtr client, Mask access)
{
    if (rid == ROOT_WINDOW_ID)
        return BadWindow;

    if (rid == CLIENT_WINDOW_ID)
    {
        *pClient = &client_window;
        return Success;
    }

    return __real_dixLookupClient(pClient, rid, client, access);
}

static void request_XISetClientPointer(xXISetClientPointerReq* req, int error)
{
    char n;
    int rc;
    client_request = init_client(req->length, req);

    rc = ProcXISetClientPointer(&client_request);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client_request.errorValue == req->deviceid);

    client_request.swapped = TRUE;
    swapl(&req->win, n);
    swaps(&req->length, n);
    swaps(&req->deviceid, n);
    rc = SProcXISetClientPointer(&client_request);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client_request.errorValue == req->deviceid);

}

static void test_XISetClientPointer(void)
{
    int i;
    xXISetClientPointerReq request;

    request_init(&request, XISetClientPointer);

    request.win = CLIENT_WINDOW_ID;

    printf("Testing BadDevice error for XIAllDevices and XIMasterDevices.\n");
    request.deviceid = XIAllDevices;
    request_XISetClientPointer(&request, BadDevice);

    request.deviceid = XIAllMasterDevices;
    request_XISetClientPointer(&request, BadDevice);

    printf("Testing Success for VCP and VCK.\n");
    request.deviceid = devices.vcp->id; /* 2 */
    request_XISetClientPointer(&request, Success);
    assert(client_window.clientPtr->id == 2);

    request.deviceid = devices.vck->id; /* 3 */
    request_XISetClientPointer(&request, Success);
    assert(client_window.clientPtr->id == 2);

    printf("Testing BadDevice error for all other devices.\n");
    for (i = 4; i <= 0xFFFF; i++)
    {
        request.deviceid = i;
        request_XISetClientPointer(&request, BadDevice);
    }

    printf("Testing window None\n");
    request.win = None;
    request.deviceid = devices.vcp->id; /* 2 */
    request_XISetClientPointer(&request, Success);
    assert(client_request.clientPtr->id == 2);

    printf("Testing invalid window\n");
    request.win = INVALID_WINDOW_ID;
    request.deviceid = devices.vcp->id;
    request_XISetClientPointer(&request, BadWindow);

}


int main(int argc, char** argv)
{
    init_simple();
    client_window = init_client(0, NULL);

    test_XISetClientPointer();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIWarpPointer request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xiwarppointer.h"
#include "exevents.h"

#include "protocol-common.h"

static int expected_x = SPRITE_X;
static int expected_y = SPRITE_Y;

/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id)
    {
        *win = &root;
        return Success;
    } else if (id == window.drawable.id)
    {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

/**
 * This function overrides the one in the screen rec.
 */
static Bool ScreenSetCursorPosition(DeviceIntPtr dev, ScreenPtr screen,
                                    int x, int y, Bool generateEvent)
{
    assert(x == expected_x);
    assert(y == expected_y);
    return TRUE;
}


static void request_XIWarpPointer(ClientPtr client, xXIWarpPointerReq* req,
        int error)
{
    char n;
    int rc;

    rc = ProcXIWarpPointer(client);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client->errorValue == req->deviceid);
    else if (rc == BadWindow)
        assert(client->errorValue == req->dst_win ||
                 client->errorValue == req->src_win);


    client->swapped = TRUE;

    swapl(&req->src_win, n);
    swapl(&req->dst_win, n);
    swapl(&req->src_x, n);
    swapl(&req->src_y, n);
    swapl(&req->dst_x, n);
    swapl(&req->dst_y, n);
    swaps(&req->src_width, n);
    swaps(&req->src_height, n);
    swaps(&req->deviceid, n);

    rc = SProcXIWarpPointer(client);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client->errorValue == req->deviceid);
    else if (rc == BadWindow)
        assert(client->errorValue == req->dst_win ||
                 client->errorValue == req->src_win);

    client->swapped = FALSE;
}

static void test_XIWarpPointer(void)
{
    int i;
    ClientRec client_request;
    xXIWarpPointerReq request;

    memset(&request, 0, sizeof(request));

    request_init(&request, XIWarpPointer);

    client_request = init_client(request.length, &request);

    request.deviceid = XIAllDevices;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    request.deviceid = XIAllMasterDevices;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    request.src_win = root.drawable.id;
    request.dst_win = root.drawable.id;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);
    request.deviceid = devices.vck->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.kbd->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    devices.mouse->master = NULL; /* Float, kind-of */
    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, Success);

    for (i = devices.kbd->id + 1; i <= 0xFFFF; i++)
    {
        request.deviceid = i;
        request_XIWarpPointer(&client_request, &request, BadDevice);
    }

    request.src_win = window.drawable.id;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.src_win = root.drawable.id;
    request.dst_win = 0xFFFF; /* invalid window */
    request_XIWarpPointer(&client_request, &request, BadWindow);

    request.src_win = 0xFFFF; /* invalid window */
    request.dst_win = root.drawable.id;
    request_XIWarpPointer(&client_request, &request, BadWindow);

    request.src_win = None;
    request.dst_win = None;

    request.dst_y = 0;
    expected_y = SPRITE_Y;

    request.dst_x = 1 << 16;
    expected_x = SPRITE_X + 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_x = -1 << 16;
    expected_x = SPRITE_X - 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_x = 0;
    expected_x = SPRITE_X;

    request.dst_y = 1 << 16;
    expected_y = SPRITE_Y + 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_y = -1 << 16;
    expected_y = SPRITE_Y - 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    /* FIXME: src_x/y checks */
}

int main(int argc, char** argv)
{
    init_simple();
    screen.SetCursorPosition = ScreenSetCursorPosition;

    test_XIWarpPointer();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "inputstr.h"
#include "opaque.h"
#include "property.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "../xkb/xkbgeom.h"
#include <X11/extensions/XKMformat.h>
#include "xkbfile.h"
#include "../xkb/xkb.h"
#include <assert.h>

/**
 * Initialize an empty XkbRMLVOSet.
 * Call XkbGetRulesDflts to obtain the default ruleset.
 * Compare obtained ruleset with the built-in defaults.
 *
 * Result: RMLVO defaults are the same as obtained.
 */
static void xkb_get_rules_test(void)
{
    XkbRMLVOSet rmlvo = { NULL};
    XkbGetRulesDflts(&rmlvo);


    assert(rmlvo.rules);
    assert(rmlvo.model);
    assert(rmlvo.layout);
    assert(rmlvo.variant);
    assert(rmlvo.options);
    assert(strcmp(rmlvo.rules, XKB_DFLT_RULES) == 0);
    assert(strcmp(rmlvo.model, XKB_DFLT_MODEL) == 0);
    assert(strcmp(rmlvo.layout, XKB_DFLT_LAYOUT) == 0);
    assert(strcmp(rmlvo.variant, XKB_DFLT_VARIANT) == 0);
    assert(strcmp(rmlvo.options, XKB_DFLT_OPTIONS) == 0);
}

/**
 * Initialize an random XkbRMLVOSet.
 * Call XkbGetRulesDflts to obtain the default ruleset.
 * Compare obtained ruleset with the built-in defaults.
 * Result: RMLVO defaults are the same as obtained.
 */
static void xkb_set_rules_test(void)
{
    XkbRMLVOSet rmlvo = {
        .rules = "test-rules",
        .model = "test-model",
        .layout = "test-layout",
        .variant = "test-variant",
        .options = "test-options"
    };
    XkbRMLVOSet rmlvo_new = { NULL };

    XkbSetRulesDflts(&rmlvo);
    XkbGetRulesDflts(&rmlvo_new);

    /* XkbGetRulesDflts strdups the values */
    assert(rmlvo.rules != rmlvo_new.rules);
    assert(rmlvo.model != rmlvo_new.model);
    assert(rmlvo.layout != rmlvo_new.layout);
    assert(rmlvo.variant != rmlvo_new.variant);
    assert(rmlvo.options != rmlvo_new.options);

    assert(strcmp(rmlvo.rules, rmlvo_new.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_new.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_new.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_new.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_new.options) == 0);
}


/**
 * Get the default RMLVO set.
 * Set the default RMLVO set.
 * Get the default RMLVO set.
 * Repeat the last two steps.
 *
 * Result: RMLVO set obtained is the same as previously set.
 */
static void xkb_set_get_rules_test(void)
{
/* This test failed before XkbGetRulesDftlts changed to strdup.
   We test this twice because the first time using XkbGetRulesDflts we obtain
   the built-in defaults. The unexpected free isn't triggered until the second
   XkbSetRulesDefaults.
 */
    XkbRMLVOSet rmlvo = { NULL };
    XkbRMLVOSet rmlvo_backup;

    XkbGetRulesDflts(&rmlvo);

    /* pass 1 */
    XkbSetRulesDflts(&rmlvo);
    XkbGetRulesDflts(&rmlvo);

    /* Make a backup copy */
    rmlvo_backup.rules = strdup(rmlvo.rules);
    rmlvo_backup.layout = strdup(rmlvo.layout);
    rmlvo_backup.model = strdup(rmlvo.model);
    rmlvo_backup.variant = strdup(rmlvo.variant);
    rmlvo_backup.options = strdup(rmlvo.options);

    /* pass 2 */
    XkbSetRulesDflts(&rmlvo);

    /* This test is iffy, because strictly we may be comparing against already
     * freed memory */
    assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);

    XkbGetRulesDflts(&rmlvo);
    assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);
}


int main(int argc, char** argv)
{
    xkb_set_get_rules_test();
    xkb_get_rules_test();
    xkb_set_rules_test();

    return 0;
}
/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif
#include <stdint.h>
#include <X11/Xatom.h>
#include "input.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "exevents.h"
#include "xkbsrv.h"
#include "xserver-properties.h"

/**
 */

/* from Xext/xtest.c */
extern DeviceIntPtr xtestpointer, xtestkeyboard;

/* Needed for the screen setup, otherwise we crash during sprite initialization */
static Bool device_cursor_init(DeviceIntPtr dev, ScreenPtr screen) { return TRUE; }

static void xtest_init_devices(void)
{
    ScreenRec screen;

    /* random stuff that needs initialization */
    memset(&screen, 0, sizeof(screen));
    screenInfo.numScreens = 1;
    screenInfo.screens[0] = &screen;
    screen.myNum = 0;
    screen.id = 100;
    screen.width = 640;
    screen.height = 480;
    screen.DeviceCursorInitialize = device_cursor_init;
    dixResetPrivates();
    InitAtoms();

    XkbInitPrivates();

    /* this also inits the xtest devices */
    InitCoreDevices();

    assert(xtestpointer);
    assert(xtestkeyboard);
    assert(IsXTestDevice(xtestpointer, NULL));
    assert(IsXTestDevice(xtestkeyboard, NULL));
    assert(IsXTestDevice(xtestpointer, inputInfo.pointer));
    assert(IsXTestDevice(xtestkeyboard, inputInfo.keyboard));
    assert(GetXTestDevice(inputInfo.pointer) == xtestpointer);
    assert(GetXTestDevice(inputInfo.keyboard) == xtestkeyboard);
}

/**
 * Each xtest devices has a property attached marking it. This property
 * cannot be changed.
 */
static void xtest_properties(void)
{
    int rc;
    char value = 1;
    XIPropertyValuePtr prop;
    Atom xtest_prop = XIGetKnownProperty(XI_PROP_XTEST_DEVICE);

    rc = XIGetDeviceProperty(xtestpointer, xtest_prop, &prop);
    assert(rc == Success);
    assert(prop);

    rc = XIGetDeviceProperty(xtestkeyboard, xtest_prop, &prop);
    assert(rc == Success);
    assert(prop != NULL);

    rc = XIChangeDeviceProperty(xtestpointer, xtest_prop,
                                XA_INTEGER, 8, PropModeReplace, 1, &value, FALSE);
    assert(rc == BadAccess);
    rc = XIChangeDeviceProperty(xtestkeyboard, xtest_prop,
                                XA_INTEGER, 8, PropModeReplace, 1, &value, FALSE);
    assert(rc == BadAccess);
}



int main(int argc, char** argv)
{
    xtest_init_devices();
    xtest_properties();

    return 0;
}


/*

Copyright 1992, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include <X11/extensions/bigreqsproto.h>
#include "opaque.h"
#include "modinit.h"

void BigReqExtensionInit(INITARGS);

static int
ProcBigReqDispatch (ClientPtr client)
{
    REQUEST(xBigReqEnableReq);
    xBigReqEnableReply rep;
     int n;

    if (client->swapped) {
	swaps(&stuff->length, n);
    }
    if (stuff->brReqType != X_BigReqEnable)
	return BadRequest;
    REQUEST_SIZE_MATCH(xBigReqEnableReq);
    client->big_requests = TRUE;
    memset(&rep, 0, sizeof(xBigReqEnableReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.max_request_size = maxBigRequestSize;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.max_request_size, n);
    }
    WriteToClient(client, sizeof(xBigReqEnableReply), (char *)&rep);
    return Success;
}

void
BigReqExtensionInit(INITARGS)
{
    AddExtension(XBigReqExtensionName, 0, 0,
		 ProcBigReqDispatch, ProcBigReqDispatch,
		 NULL, StandardMinorOpcode);
}
/*****************************************************************

Copyright (c) 1996 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING, 
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation 
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital 
Equipment Corporation.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "opaque.h"
#include <X11/extensions/dpmsproto.h>
#include "dpmsproc.h"
#include "modinit.h"

static int
ProcDPMSGetVersion(ClientPtr client)
{
    /* REQUEST(xDPMSGetVersionReq); */
    xDPMSGetVersionReply rep;
    int n;

    REQUEST_SIZE_MATCH(xDPMSGetVersionReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = DPMSMajorVersion;
    rep.minorVersion = DPMSMinorVersion;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xDPMSGetVersionReply), (char *)&rep);
    return Success;
}

static int
ProcDPMSCapable(ClientPtr client)
{
    /* REQUEST(xDPMSCapableReq); */
    xDPMSCapableReply rep;
    int n;

    REQUEST_SIZE_MATCH(xDPMSCapableReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.capable = DPMSCapableFlag;

    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
    }
    WriteToClient(client, sizeof(xDPMSCapableReply), (char *)&rep);
    return Success;
}

static int
ProcDPMSGetTimeouts(ClientPtr client)
{
    /* REQUEST(xDPMSGetTimeoutsReq); */
    xDPMSGetTimeoutsReply rep;
    int n;

    REQUEST_SIZE_MATCH(xDPMSGetTimeoutsReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.standby = DPMSStandbyTime / MILLI_PER_SECOND;
    rep.suspend = DPMSSuspendTime / MILLI_PER_SECOND;
    rep.off = DPMSOffTime / MILLI_PER_SECOND;

    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.standby, n);
	swaps(&rep.suspend, n);
	swaps(&rep.off, n);
    }
    WriteToClient(client, sizeof(xDPMSGetTimeoutsReply), (char *)&rep);
    return Success;
}

static int
ProcDPMSSetTimeouts(ClientPtr client)
{
    REQUEST(xDPMSSetTimeoutsReq);

    REQUEST_SIZE_MATCH(xDPMSSetTimeoutsReq);

    if ((stuff->off != 0)&&(stuff->off < stuff->suspend)) 
    {
	client->errorValue = stuff->off;
	return BadValue;
    }
    if ((stuff->suspend != 0)&&(stuff->suspend < stuff->standby))
    {
	client->errorValue = stuff->suspend;
	return BadValue;
    }  

    DPMSStandbyTime = stuff->standby * MILLI_PER_SECOND;
    DPMSSuspendTime = stuff->suspend * MILLI_PER_SECOND;
    DPMSOffTime = stuff->off * MILLI_PER_SECOND;
    SetScreenSaverTimer();

    return Success;
}

static int
ProcDPMSEnable(ClientPtr client)
{
    Bool was_enabled = DPMSEnabled;

    REQUEST_SIZE_MATCH(xDPMSEnableReq);

    if (DPMSCapableFlag) {
	DPMSEnabled = TRUE;
	if (!was_enabled)
	    SetScreenSaverTimer();
    }

    return Success;
}

static int
ProcDPMSDisable(ClientPtr client)
{
    /* REQUEST(xDPMSDisableReq); */

    REQUEST_SIZE_MATCH(xDPMSDisableReq);

    DPMSSet(client, DPMSModeOn);

    DPMSEnabled = FALSE;

    return Success;
}

static int
ProcDPMSForceLevel(ClientPtr client)
{
    REQUEST(xDPMSForceLevelReq);

    REQUEST_SIZE_MATCH(xDPMSForceLevelReq);

    if (!DPMSEnabled)
	return BadMatch;

    if (stuff->level != DPMSModeOn &&
        stuff->level != DPMSModeStandby &&
        stuff->level != DPMSModeSuspend &&
        stuff->level != DPMSModeOff) {
	client->errorValue = stuff->level;
	return BadValue;
    }

    DPMSSet(client, stuff->level);

    return Success;
}

static int
ProcDPMSInfo(ClientPtr client)
{
    /* REQUEST(xDPMSInfoReq); */
    xDPMSInfoReply rep;
    int n;

    REQUEST_SIZE_MATCH(xDPMSInfoReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.power_level = DPMSPowerLevel;
    rep.state = DPMSEnabled;

    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.power_level, n);
    }
    WriteToClient(client, sizeof(xDPMSInfoReply), (char *)&rep);
    return Success;
}

static int
ProcDPMSDispatch (ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
    case X_DPMSGetVersion:
	return ProcDPMSGetVersion(client);
    case X_DPMSCapable:
	return ProcDPMSCapable(client);
    case X_DPMSGetTimeouts:
	return ProcDPMSGetTimeouts(client);
    case X_DPMSSetTimeouts:
	return ProcDPMSSetTimeouts(client);
    case X_DPMSEnable:
	return ProcDPMSEnable(client);
    case X_DPMSDisable:
	return ProcDPMSDisable(client);
    case X_DPMSForceLevel:
	return ProcDPMSForceLevel(client);
    case X_DPMSInfo:
	return ProcDPMSInfo(client);
    default:
	return BadRequest;
    }
}

static int
SProcDPMSGetVersion(ClientPtr client)
{
    int n;
    REQUEST(xDPMSGetVersionReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSGetVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion, n);
    return ProcDPMSGetVersion(client);
}

static int
SProcDPMSCapable(ClientPtr client)
{
    REQUEST(xDPMSCapableReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSCapableReq);

    return ProcDPMSCapable(client);
}

static int
SProcDPMSGetTimeouts(ClientPtr client)
{
    REQUEST(xDPMSGetTimeoutsReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSGetTimeoutsReq);

    return ProcDPMSGetTimeouts(client);
}

static int
SProcDPMSSetTimeouts(ClientPtr client)
{
    REQUEST(xDPMSSetTimeoutsReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSSetTimeoutsReq);

    swaps(&stuff->standby, n);
    swaps(&stuff->suspend, n);
    swaps(&stuff->off, n);
    return ProcDPMSSetTimeouts(client);
}

static int
SProcDPMSEnable(ClientPtr client)
{
    REQUEST(xDPMSEnableReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSEnableReq);

    return ProcDPMSEnable(client);
}

static int
SProcDPMSDisable(ClientPtr client)
{
    REQUEST(xDPMSDisableReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSDisableReq);

    return ProcDPMSDisable(client);
}

static int
SProcDPMSForceLevel(ClientPtr client)
{
    REQUEST(xDPMSForceLevelReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSForceLevelReq);

    swaps(&stuff->level, n);

    return ProcDPMSForceLevel(client);
}

static int
SProcDPMSInfo(ClientPtr client)
{
    REQUEST(xDPMSInfoReq);
    int n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xDPMSInfoReq);

    return ProcDPMSInfo(client);
}

static int
SProcDPMSDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_DPMSGetVersion:
	return SProcDPMSGetVersion(client);
    case X_DPMSCapable:
	return SProcDPMSCapable(client);
    case X_DPMSGetTimeouts:
	return SProcDPMSGetTimeouts(client);
    case X_DPMSSetTimeouts:
	return SProcDPMSSetTimeouts(client);
    case X_DPMSEnable:
	return SProcDPMSEnable(client);
    case X_DPMSDisable:
	return SProcDPMSDisable(client);
    case X_DPMSForceLevel:
	return SProcDPMSForceLevel(client);
    case X_DPMSInfo:
	return SProcDPMSInfo(client);
    default:
	return BadRequest;
    }
}

void
DPMSExtensionInit(INITARGS)
{
    AddExtension(DPMSExtensionName, 0, 0,
		 ProcDPMSDispatch, SProcDPMSDispatch,
		 NULL, StandardMinorOpcode);
}
/* Prototypes for functions that the DDX must provide */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _DPMSPROC_H_
#define _DPMSPROC_H_

#include "dixstruct.h"

int  DPMSSet(ClientPtr client, int level);
Bool DPMSSupported(void);

#endif
/*****************************************************************

Copyright (c) 1996 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING, 
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation 
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital 
Equipment Corporation.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "dpmsproc.h"

#define FALSE 0

Bool DPMSSupported(void)
{
    return FALSE;
}

int DPMSSet(ClientPtr client, int level)
{
    return Success;
}
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif
#include "windowstr.h"
#include <X11/extensions/ge.h>

#include "geint.h"
#include "geext.h"
#include "protocol-versions.h"

DevPrivateKeyRec GEClientPrivateKeyRec;

int RT_GECLIENT  = 0;

GEExtension GEExtensions[MAXEXTENSIONS];

/* Major available requests */
static const int version_requests[] = {
    X_GEQueryVersion,	/* before client sends QueryVersion */
    X_GEQueryVersion,	/* must be set to last request in version 1 */
};

/* Forward declarations */
static void SGEGenericEvent(xEvent* from, xEvent* to);

#define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))
#define EXT_MASK(ext) ((ext) & 0x7F)

/************************************************************/
/*                request handlers                          */
/************************************************************/

static int
ProcGEQueryVersion(ClientPtr client)
{
    int n;
    GEClientInfoPtr pGEClient = GEGetClient(client);
    xGEQueryVersionReply rep;
    REQUEST(xGEQueryVersionReq);

    REQUEST_SIZE_MATCH(xGEQueryVersionReq);

    rep.repType = X_Reply;
    rep.RepType = X_GEQueryVersion;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    /* return the supported version by the server */
    rep.majorVersion = SERVER_GE_MAJOR_VERSION;
    rep.minorVersion = SERVER_GE_MINOR_VERSION;

    /* Remember version the client requested */
    pGEClient->major_version = stuff->majorVersion;
    pGEClient->minor_version = stuff->minorVersion;

    if (client->swapped)
    {
	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
    }

    WriteToClient(client, sizeof(xGEQueryVersionReply), (char*)&rep);
    return Success;
}

int (*ProcGEVector[GENumberRequests])(ClientPtr) = {
    /* Version 1.0 */
    ProcGEQueryVersion
};

/************************************************************/
/*                swapped request handlers                  */
/************************************************************/
static int
SProcGEQueryVersion(ClientPtr client)
{
    int n;
    REQUEST(xGEQueryVersionReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGEQueryVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion, n);
    return(*ProcGEVector[stuff->ReqType])(client);
}

int (*SProcGEVector[GENumberRequests])(ClientPtr) = {
    /* Version 1.0 */
    SProcGEQueryVersion
};


/************************************************************/
/*                callbacks                                 */
/************************************************************/

/* dispatch requests */
static int
ProcGEDispatch(ClientPtr client)
{
    GEClientInfoPtr pGEClient = GEGetClient(client);
    REQUEST(xGEReq);

    if (pGEClient->major_version >= NUM_VERSION_REQUESTS)
        return BadRequest;
    if (stuff->ReqType > version_requests[pGEClient->major_version])
        return BadRequest;

    return (ProcGEVector[stuff->ReqType])(client);
}

/* dispatch swapped requests */
static int
SProcGEDispatch(ClientPtr client)
{
    REQUEST(xGEReq);
    if (stuff->ReqType >= GENumberRequests)
        return BadRequest;
    return (*SProcGEVector[stuff->ReqType])(client);
}

/**
 * Called when a new client inits a connection to the X server.
 *
 * We alloc a simple struct to store the client's major/minor version. Can be
 * used in the furture for versioning support.
 */
static void
GEClientCallback(CallbackListPtr *list,
                 pointer closure,
                 pointer data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    GEClientInfoPtr     pGEClient = GEGetClient(pClient);

    pGEClient->major_version = 0;
    pGEClient->minor_version = 0;
}

/* Reset extension. Called on server shutdown. */
static void
GEResetProc(ExtensionEntry *extEntry)
{
    DeleteCallback(&ClientStateCallback, GEClientCallback, 0);
    EventSwapVector[GenericEvent] = NotImplemented;
}

/*  Calls the registered event swap function for the extension.
 *
 *  Each extension can register a swap function to handle GenericEvents being
 *  swapped properly. The server calls SGEGenericEvent() before the event is
 *  written on the wire, this one calls the registered swap function to do the
 *  work.
 */
static void
SGEGenericEvent(xEvent* from, xEvent* to)
{
    xGenericEvent* gefrom = (xGenericEvent*)from;
    xGenericEvent* geto = (xGenericEvent*)to;

    if ((gefrom->extension & 0x7f) > MAXEXTENSIONS)
    {
        ErrorF("GE: Invalid extension offset for event.\n");
        return;
    }

    if (GEExtensions[EXT_MASK(gefrom->extension)].evswap)
        GEExtensions[EXT_MASK(gefrom->extension)].evswap(gefrom, geto);
}

/* Init extension, register at server.
 * Since other extensions may rely on XGE (XInput does already), it is a good
 * idea to init XGE first, before any other extension.
 */
void
GEExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!dixRegisterPrivateKey(&GEClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(GEClientInfoRec)))
        FatalError("GEExtensionInit: GE private request failed.\n");

    if(!AddCallback(&ClientStateCallback, GEClientCallback, 0))
    {
        FatalError("GEExtensionInit: register client callback failed.\n");
    }

    if((extEntry = AddExtension(GE_NAME,
                        0, GENumberErrors,
                        ProcGEDispatch, SProcGEDispatch,
                        GEResetProc, StandardMinorOpcode)) != 0)
    {
        memset(GEExtensions, 0, sizeof(GEExtensions));

        EventSwapVector[GenericEvent] = (EventSwapPtr) SGEGenericEvent;
    } else {
        FatalError("GEInit: AddExtensions failed.\n");
    }

}

/************************************************************/
/*                interface for extensions                  */
/************************************************************/

/* Register an extension with GE. The given swap function will be called each
 * time an event is sent to a client with different byte order.
 * @param extension The extensions major opcode
 * @param ev_swap The event swap function.
 * @param ev_fill Called for an event before delivery. The extension now has
 * the chance to fill in necessary fields for the event.
 */
void
GERegisterExtension(int extension,
                    void (*ev_swap)(xGenericEvent* from, xGenericEvent* to))
{
    if (EXT_MASK(extension) >=  MAXEXTENSIONS)
        FatalError("GE: extension > MAXEXTENSIONS. This should not happen.\n");

    /* extension opcodes are > 128, might as well save some space here */
    GEExtensions[EXT_MASK(extension)].evswap = ev_swap;
}


/* Sets type and extension field for a generic event. This is just an
 * auxiliary function, extensions could do it manually too.
 */
void
GEInitEvent(xGenericEvent* ev, int extension)
{
    ev->type = GenericEvent;
    ev->extension = extension;
    ev->length = 0;
}

/*

Copyright 2007 Peter Hutterer <peter@cs.unisa.edu.au>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the author shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from the author.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _GEEXT_H_
#define _GEEXT_H_
#include <X11/extensions/geproto.h>

/** Struct to keep information about registered extensions */
typedef struct _GEExtension {
    /** Event swapping routine */
    void (*evswap)(xGenericEvent* from, xGenericEvent* to);
} GEExtension, *GEExtensionPtr;


/* All registered extensions and their handling functions. */
extern _X_EXPORT GEExtension GEExtensions[MAXEXTENSIONS];

/* Typecast to generic event */
#define GEV(ev) ((xGenericEvent*)(ev))
/* Returns the extension offset from the event */
#define GEEXT(ev) (GEV(ev)->extension)

/* Return zero-based extension offset (offset - 128). Only for use in arrays */
#define GEEXTIDX(ev) (GEEXT(ev) & 0x7F)
/* True if mask is set for extension on window */
#define GEMaskIsSet(pWin, extension, mask) \
    ((pWin)->optional && \
     (pWin)->optional->geMasks && \
     ((pWin)->optional->geMasks->eventMasks[(extension) & 0x7F] & (mask)))

/* Returns first client */
#define GECLIENT(pWin) \
    (((pWin)->optional) ? (pWin)->optional->geMasks->geClients : NULL)

/* Returns the event_fill for the given event */
#define GEEventFill(ev) \
    GEExtensions[GEEXTIDX(ev)].evfill

#define GEIsType(ev, ext, ev_type) \
        ((GEV(ev)->type == GenericEvent) &&  \
         GEEXT(ev) == (ext) && \
         GEV(ev)->evtype == (ev_type))


/* Interface for other extensions */
extern _X_EXPORT void GERegisterExtension(
        int extension,
        void (*ev_dispatch)(xGenericEvent* from, xGenericEvent* to));

extern _X_EXPORT void GEInitEvent(xGenericEvent* ev, int extension);

extern _X_EXPORT void GEExtensionInit(void);

#endif /* _GEEXT_H_ */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _GEINT_H_
#define _GEINT_H_

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include <X11/extensions/geproto.h>

extern _X_EXPORT DevPrivateKeyRec GEClientPrivateKeyRec;
#define GEClientPrivateKey (&GEClientPrivateKeyRec)

typedef struct _GEClientInfo {
    CARD32  major_version;
    CARD32  minor_version;
} GEClientInfoRec, *GEClientInfoPtr;

#define GEGetClient(pClient)    ((GEClientInfoPtr)(dixLookupPrivate(&((pClient)->devPrivates), GEClientPrivateKey)))

extern _X_EXPORT int (*ProcGEVector[/*GENumRequests*/])(ClientPtr);
extern _X_EXPORT int (*SProcGEVector[/*GENumRequests*/])(ClientPtr);

#endif /* _GEINT_H_ */
# libXext.la:        includes all extensions and should be linked into Xvfb,
#                    Xnest, Xdmx and Xprt
# libXextbuiltin.la: includes those extensions that are built directly into
#                    Xorg by default
# libXextmodule.la:  includes those extensions that are built into a module
#                    that Xorg loads
if XORG
noinst_LTLIBRARIES = libXext.la libXextbuiltin.la libXextmodule.la
else
noinst_LTLIBRARIES = libXext.la
endif

INCLUDES = -I$(top_srcdir)/hw/xfree86/dixmods/extmod

AM_CFLAGS = $(DIX_CFLAGS)

if XORG
sdk_HEADERS = xvdix.h xvmcext.h geext.h geint.h shmint.h syncsdk.h
endif

# Sources always included in libXextbuiltin.la & libXext.la
BUILTIN_SRCS =			\
	bigreq.c		\
        geext.c			\
	shape.c			\
	sleepuntil.c		\
	sleepuntil.h		\
	sync.c			\
	syncsdk.h		\
	syncsrv.h		\
	xcmisc.c		\
	xtest.c

# Sources always included in libXextmodule.la & libXext.la. That's right, zero.
MODULE_SRCS =
MODULE_LIBS =

# Optional sources included if extension enabled by configure.ac rules

# MIT Shared Memory extension
MITSHM_SRCS = shm.c shmint.h
if MITSHM
BUILTIN_SRCS += $(MITSHM_SRCS)
endif

# XVideo extension
XV_SRCS = xvmain.c xvdisp.c xvmc.c xvdix.h xvmcext.h xvdisp.h
if XV
MODULE_SRCS  += $(XV_SRCS)
endif

# XResource extension: lets clients get data about per-client resource usage
RES_SRCS = xres.c
if RES
MODULE_SRCS  += $(RES_SRCS)
endif

# MIT ScreenSaver extension
SCREENSAVER_SRCS = saver.c
if SCREENSAVER
MODULE_SRCS  += $(SCREENSAVER_SRCS)
endif

# Xinerama extension: making multiple video devices act as one virtual screen
XINERAMA_SRCS = panoramiX.c panoramiX.h panoramiXh.h panoramiXsrv.h panoramiXprocs.c panoramiXSwap.c 
if XINERAMA
BUILTIN_SRCS += $(XINERAMA_SRCS)
if XORG
sdk_HEADERS += panoramiXsrv.h panoramiX.h
endif
endif

# X-ACE extension: provides hooks for building security policy extensions
# like XC-Security, X-SELinux & XTSol
XACE_SRCS = xace.c xace.h xacestr.h
if XACE
BUILTIN_SRCS += $(XACE_SRCS)
if XORG
sdk_HEADERS += xace.h xacestr.h
endif
endif

# SELinux extension: provides SELinux policy support for X objects
# requires X-ACE extension
XSELINUX_SRCS = xselinux_ext.c xselinux_hooks.c xselinux_label.c xselinux.h xselinuxint.h
if XSELINUX
MODULE_SRCS += $(XSELINUX_SRCS)
MODULE_LIBS += $(SELINUX_LIBS)
endif

# Security extension: multi-level security to protect clients from each other
XCSECURITY_SRCS = security.c securitysrv.h
if XCSECURITY   
BUILTIN_SRCS += $(XCSECURITY_SRCS)
endif

# XF86 Big Font extension
BIGFONT_SRCS = xf86bigfont.c xf86bigfontsrv.h
if XF86BIGFONT
BUILTIN_SRCS += $(BIGFONT_SRCS)
endif

# DPMS extension
DPMS_SRCS = dpms.c dpmsproc.h
if DPMSExtension
MODULE_SRCS += $(DPMS_SRCS)
endif

# Now take all of the above, mix well, bake for 10 minutes and get libXext*.la

libXext_la_SOURCES =		$(BUILTIN_SRCS) $(MODULE_SRCS)
libXext_la_LIBADD =		$(MODULE_LIBS)

if XORG
libXextbuiltin_la_SOURCES =	$(BUILTIN_SRCS)

libXextmodule_la_SOURCES =	$(MODULE_SRCS)
libXextmodule_la_LIBADD =	$(MODULE_LIBS)
endif

EXTRA_DIST = \
	$(MITSHM_SRCS) \
	$(XV_SRCS) \
	$(RES_SRCS) \
	$(SCREENSAVER_SRCS) \
	$(XACE_SRCS) \
	$(XCSECURITY_SRCS) \
	$(XSELINUX_SRCS) \
	$(XINERAMA_SRCS) \
	$(BIGFONT_SRCS) \
	$(DPMS_SRCS) \
        $(GE_SRCS)

/*****************************************************************
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xarch.h>
#include "misc.h"
#include "cursor.h"
#include "cursorstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "gc.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#include "window.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "panoramiX.h"
#include <X11/extensions/panoramiXproto.h>
#include "panoramiXsrv.h"
#include "globals.h"
#include "servermd.h"
#include "resource.h"
#include "picturestr.h"
#ifdef XFIXES
#include "xfixesint.h"
#endif
#ifdef COMPOSITE
#include "compint.h"
#endif
#include "modinit.h"
#include "protocol-versions.h"

#ifdef GLXPROXY
extern VisualPtr glxMatchVisual(ScreenPtr pScreen,
				VisualPtr pVisual,
				ScreenPtr pMatchScreen);
#endif

/*
 *	PanoramiX data declarations
 */

int 		PanoramiXPixWidth = 0;
int 		PanoramiXPixHeight = 0;
int 		PanoramiXNumScreens = 0;

static RegionRec   	PanoramiXScreenRegion = {{0, 0, 0, 0}, NULL};

static int		PanoramiXNumDepths;
static DepthPtr		PanoramiXDepths;
static int		PanoramiXNumVisuals;
static VisualPtr	PanoramiXVisuals;

RESTYPE XRC_DRAWABLE;
RESTYPE XRT_WINDOW;
RESTYPE XRT_PIXMAP;
RESTYPE XRT_GC;
RESTYPE XRT_COLORMAP;

static Bool VisualsEqual(VisualPtr, ScreenPtr, VisualPtr);
XineramaVisualsEqualProcPtr XineramaVisualsEqualPtr = &VisualsEqual;

/*
 *	Function prototypes
 */

static int panoramiXGeneration;
static int ProcPanoramiXDispatch(ClientPtr client); 

static void PanoramiXResetProc(ExtensionEntry*);

/*
 *	External references for functions and data variables
 */

#include "panoramiXh.h"

int (* SavedProcVector[256]) (ClientPtr client) = { NULL, };

static DevPrivateKeyRec PanoramiXGCKeyRec;
#define PanoramiXGCKey (&PanoramiXGCKeyRec)
static DevPrivateKeyRec PanoramiXScreenKeyRec;
#define PanoramiXScreenKey (&PanoramiXScreenKeyRec)

typedef struct {
  DDXPointRec clipOrg;
  DDXPointRec patOrg;
  GCFuncs *wrapFuncs;
} PanoramiXGCRec, *PanoramiXGCPtr;

typedef struct {
  CreateGCProcPtr	CreateGC;
  CloseScreenProcPtr	CloseScreen;
} PanoramiXScreenRec, *PanoramiXScreenPtr;

static void XineramaValidateGC(GCPtr, unsigned long, DrawablePtr);
static void XineramaChangeGC(GCPtr, unsigned long);
static void XineramaCopyGC(GCPtr, unsigned long, GCPtr);
static void XineramaDestroyGC(GCPtr);
static void XineramaChangeClip(GCPtr, int, pointer, int);
static void XineramaDestroyClip(GCPtr);
static void XineramaCopyClip(GCPtr, GCPtr);

static GCFuncs XineramaGCFuncs = {
    XineramaValidateGC, XineramaChangeGC, XineramaCopyGC, XineramaDestroyGC,
    XineramaChangeClip, XineramaDestroyClip, XineramaCopyClip
};

#define Xinerama_GC_FUNC_PROLOGUE(pGC)\
    PanoramiXGCPtr  pGCPriv = (PanoramiXGCPtr) \
	dixLookupPrivate(&(pGC)->devPrivates, PanoramiXGCKey); \
    (pGC)->funcs = pGCPriv->wrapFuncs;

#define Xinerama_GC_FUNC_EPILOGUE(pGC)\
    pGCPriv->wrapFuncs = (pGC)->funcs;\
    (pGC)->funcs = &XineramaGCFuncs;


static Bool
XineramaCloseScreen (int i, ScreenPtr pScreen)
{
    PanoramiXScreenPtr pScreenPriv = (PanoramiXScreenPtr)
	dixLookupPrivate(&pScreen->devPrivates, PanoramiXScreenKey);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->CreateGC = pScreenPriv->CreateGC;

    if (pScreen->myNum == 0)
	RegionUninit(&PanoramiXScreenRegion);

    free((pointer) pScreenPriv);

    return (*pScreen->CloseScreen) (i, pScreen);
}

static Bool
XineramaCreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;
    PanoramiXScreenPtr pScreenPriv = (PanoramiXScreenPtr)
	dixLookupPrivate(&pScreen->devPrivates, PanoramiXScreenKey);
    Bool ret;

    pScreen->CreateGC = pScreenPriv->CreateGC;
    if((ret = (*pScreen->CreateGC)(pGC))) {
	PanoramiXGCPtr pGCPriv = (PanoramiXGCPtr)
	    dixLookupPrivate(&pGC->devPrivates, PanoramiXGCKey);

	pGCPriv->wrapFuncs = pGC->funcs;
        pGC->funcs = &XineramaGCFuncs;

	pGCPriv->clipOrg.x = pGC->clipOrg.x; 
	pGCPriv->clipOrg.y = pGC->clipOrg.y;
	pGCPriv->patOrg.x = pGC->patOrg.x;
	pGCPriv->patOrg.y = pGC->patOrg.y;
    }
    pScreen->CreateGC = XineramaCreateGC;

    return ret;
}

static void
XineramaValidateGC(
   GCPtr         pGC,
   unsigned long changes,
   DrawablePtr   pDraw 
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);

    if((pDraw->type == DRAWABLE_WINDOW) && !(((WindowPtr)pDraw)->parent)) {
	/* the root window */
	int x_off = pGC->pScreen->x;
	int y_off = pGC->pScreen->y;
	int new_val;

	new_val = pGCPriv->clipOrg.x - x_off;
	if(pGC->clipOrg.x != new_val) {
	    pGC->clipOrg.x = new_val;
	    changes |= GCClipXOrigin;
	}
	new_val = pGCPriv->clipOrg.y - y_off;
	if(pGC->clipOrg.y != new_val) {
	    pGC->clipOrg.y = new_val;
	    changes |= GCClipYOrigin;
	}
	new_val = pGCPriv->patOrg.x - x_off;
	if(pGC->patOrg.x != new_val) {
	    pGC->patOrg.x = new_val;
	    changes |= GCTileStipXOrigin;
	}
	new_val = pGCPriv->patOrg.y - y_off;
	if(pGC->patOrg.y != new_val) {
	    pGC->patOrg.y = new_val;
	    changes |= GCTileStipYOrigin;
	}
    } else {
	if(pGC->clipOrg.x != pGCPriv->clipOrg.x) {
	    pGC->clipOrg.x = pGCPriv->clipOrg.x;
	    changes |= GCClipXOrigin;
	}
	if(pGC->clipOrg.y != pGCPriv->clipOrg.y) {
	    pGC->clipOrg.y = pGCPriv->clipOrg.y;
	    changes |= GCClipYOrigin;
	}
	if(pGC->patOrg.x != pGCPriv->patOrg.x) {
	    pGC->patOrg.x = pGCPriv->patOrg.x;
	    changes |= GCTileStipXOrigin;
	}
	if(pGC->patOrg.y != pGCPriv->patOrg.y) {
	    pGC->patOrg.y = pGCPriv->patOrg.y;
	    changes |= GCTileStipYOrigin;
	}
    }
  
    (*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

static void
XineramaDestroyGC(GCPtr pGC)
{
    Xinerama_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->DestroyGC)(pGC);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

static void
XineramaChangeGC (
    GCPtr	    pGC,
    unsigned long   mask
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);

    if(mask & GCTileStipXOrigin)
	pGCPriv->patOrg.x = pGC->patOrg.x;
    if(mask & GCTileStipYOrigin)
	pGCPriv->patOrg.y = pGC->patOrg.y;
    if(mask & GCClipXOrigin)
	pGCPriv->clipOrg.x = pGC->clipOrg.x; 
    if(mask & GCClipYOrigin)
	pGCPriv->clipOrg.y = pGC->clipOrg.y;

    (*pGC->funcs->ChangeGC) (pGC, mask);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

static void
XineramaCopyGC (
    GCPtr	    pGCSrc, 
    unsigned long   mask,
    GCPtr	    pGCDst
){
    PanoramiXGCPtr pSrcPriv = (PanoramiXGCPtr)
	dixLookupPrivate(&pGCSrc->devPrivates, PanoramiXGCKey);
    Xinerama_GC_FUNC_PROLOGUE (pGCDst);

    if(mask & GCTileStipXOrigin)
        pGCPriv->patOrg.x = pSrcPriv->patOrg.x;
    if(mask & GCTileStipYOrigin)
        pGCPriv->patOrg.y = pSrcPriv->patOrg.y;
    if(mask & GCClipXOrigin)
        pGCPriv->clipOrg.x = pSrcPriv->clipOrg.x;
    if(mask & GCClipYOrigin)
        pGCPriv->clipOrg.y = pSrcPriv->clipOrg.y;

    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    Xinerama_GC_FUNC_EPILOGUE (pGCDst);
}

static void
XineramaChangeClip (
    GCPtr   pGC,
    int		type,
    pointer	pvalue,
    int		nrects 
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

static void
XineramaCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    Xinerama_GC_FUNC_PROLOGUE (pgcDst);
    (* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
    Xinerama_GC_FUNC_EPILOGUE (pgcDst);
}

static void
XineramaDestroyClip(GCPtr pGC)
{
    Xinerama_GC_FUNC_PROLOGUE (pGC);
    (* pGC->funcs->DestroyClip)(pGC);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
}

int
XineramaDeleteResource(pointer data, XID id)
{
    free(data);
    return 1;
}

typedef struct {
   int screen;
   int id;
} PanoramiXSearchData; 

static Bool 
XineramaFindIDByScrnum(pointer resource, XID id, pointer privdata)
{
    PanoramiXRes *res = (PanoramiXRes*)resource;
    PanoramiXSearchData *data = (PanoramiXSearchData*)privdata;
    
    return res->info[data->screen].id == data->id;
}

PanoramiXRes *
PanoramiXFindIDByScrnum(RESTYPE type, XID id, int screen)
{
    PanoramiXSearchData data;
    pointer val;

    if(!screen) {
	dixLookupResourceByType(&val, id, type, serverClient, DixReadAccess);
	return val;
    }

    data.screen = screen;
    data.id = id;

    return LookupClientResourceComplex(clients[CLIENT_ID(id)], type,
		XineramaFindIDByScrnum, &data);
}

typedef struct _connect_callback_list {
    void (*func)(void);
    struct _connect_callback_list *next;
} XineramaConnectionCallbackList;

static XineramaConnectionCallbackList *ConnectionCallbackList = NULL;

Bool
XineramaRegisterConnectionBlockCallback(void (*func)(void))
{
    XineramaConnectionCallbackList *newlist;

    if(!(newlist = malloc(sizeof(XineramaConnectionCallbackList))))
	return FALSE;

    newlist->next = ConnectionCallbackList;
    newlist->func = func;
    ConnectionCallbackList = newlist;

    return TRUE;
}

static void XineramaInitData(ScreenPtr pScreen)
{
    int i, w, h;

    RegionNull(&PanoramiXScreenRegion);
    FOR_NSCREENS(i) {
	BoxRec TheBox;
	RegionRec ScreenRegion;

        pScreen = screenInfo.screens[i];

	TheBox.x1 = pScreen->x;
	TheBox.x2 = TheBox.x1 + pScreen->width;
	TheBox.y1 = pScreen->y;
	TheBox.y2 = TheBox.y1 + pScreen->height;

	RegionInit(&ScreenRegion, &TheBox, 1);
	RegionUnion(&PanoramiXScreenRegion, &PanoramiXScreenRegion,
		     &ScreenRegion);
	RegionUninit(&ScreenRegion);
    }

    PanoramiXPixWidth = screenInfo.screens[0]->x + screenInfo.screens[0]->width;
    PanoramiXPixHeight = screenInfo.screens[0]->y + screenInfo.screens[0]->height;

    FOR_NSCREENS_FORWARD_SKIP(i) {
	pScreen = screenInfo.screens[i];
	w = pScreen->x + pScreen->width;
	h = pScreen->y + pScreen->height;

	if (PanoramiXPixWidth < w)
	    PanoramiXPixWidth = w;
	if (PanoramiXPixHeight < h)
	    PanoramiXPixHeight = h;
    }
}

void XineramaReinitData(ScreenPtr pScreen)
{
    RegionUninit(&PanoramiXScreenRegion);
    XineramaInitData(pScreen);
}

/*
 *	PanoramiXExtensionInit():
 *		Called from InitExtensions in main().  
 *		Register PanoramiXeen Extension
 *		Initialize global variables.
 */ 

void PanoramiXExtensionInit(int argc, char *argv[])
{
    int 	     	i;
    Bool	     	success = FALSE;
    ExtensionEntry 	*extEntry;
    ScreenPtr		pScreen = screenInfo.screens[0];
    PanoramiXScreenPtr	pScreenPriv;

    if (noPanoramiXExtension) 
	return;

    if (!dixRegisterPrivateKey(&PanoramiXScreenKeyRec, PRIVATE_SCREEN, 0)) {
	noPanoramiXExtension = TRUE;
	return;
    }

    if (!dixRegisterPrivateKey(&PanoramiXGCKeyRec, PRIVATE_GC, sizeof(PanoramiXGCRec))) {
	noPanoramiXExtension = TRUE;
	return;
    }

    PanoramiXNumScreens = screenInfo.numScreens;
    if (PanoramiXNumScreens == 1) {		/* Only 1 screen 	*/
	noPanoramiXExtension = TRUE;
	return;
    }

    while (panoramiXGeneration != serverGeneration) {
	extEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0, 
				ProcPanoramiXDispatch,
				SProcPanoramiXDispatch, PanoramiXResetProc, 
				StandardMinorOpcode);
	if (!extEntry)
	    break;

	/*
	 *	First make sure all the basic allocations succeed.  If not,
	 *	run in non-PanoramiXeen mode.
	 */

	FOR_NSCREENS(i) {
	   pScreen = screenInfo.screens[i];
	   pScreenPriv = malloc(sizeof(PanoramiXScreenRec));
	   dixSetPrivate(&pScreen->devPrivates, PanoramiXScreenKey,
			 pScreenPriv);
	   if(!pScreenPriv) {
		noPanoramiXExtension = TRUE;
		return;
	   }
	
	   pScreenPriv->CreateGC = pScreen->CreateGC;
	   pScreenPriv->CloseScreen = pScreen->CloseScreen;
	
	   pScreen->CreateGC = XineramaCreateGC;
	   pScreen->CloseScreen = XineramaCloseScreen;
	}

	XRC_DRAWABLE = CreateNewResourceClass();
	XRT_WINDOW = CreateNewResourceType(XineramaDeleteResource,
					   "XineramaWindow");
	if (XRT_WINDOW)
	    XRT_WINDOW |= XRC_DRAWABLE;
	XRT_PIXMAP = CreateNewResourceType(XineramaDeleteResource,
					   "XineramaPixmap");
	if (XRT_PIXMAP)
	    XRT_PIXMAP |= XRC_DRAWABLE;
	XRT_GC = CreateNewResourceType(XineramaDeleteResource,
				       "XineramaGC");
	XRT_COLORMAP = CreateNewResourceType(XineramaDeleteResource,
					     "XineramaColormap");

	if (XRT_WINDOW && XRT_PIXMAP && XRT_GC && XRT_COLORMAP) {
	    panoramiXGeneration = serverGeneration;
	    success = TRUE;
	}
	SetResourceTypeErrorValue(XRT_WINDOW, BadWindow);
	SetResourceTypeErrorValue(XRT_PIXMAP, BadPixmap);
	SetResourceTypeErrorValue(XRT_GC, BadGC);
	SetResourceTypeErrorValue(XRT_COLORMAP, BadColor);
    }

    if (!success) {
	noPanoramiXExtension = TRUE;
	ErrorF(PANORAMIX_PROTOCOL_NAME " extension failed to initialize\n");
	return;
    }
  
    XineramaInitData(pScreen);

    /*
     *	Put our processes into the ProcVector
     */

    for (i = 256; i--; )
	SavedProcVector[i] = ProcVector[i];

    ProcVector[X_CreateWindow] = PanoramiXCreateWindow;
    ProcVector[X_ChangeWindowAttributes] = PanoramiXChangeWindowAttributes;
    ProcVector[X_DestroyWindow] = PanoramiXDestroyWindow;
    ProcVector[X_DestroySubwindows] = PanoramiXDestroySubwindows;
    ProcVector[X_ChangeSaveSet] = PanoramiXChangeSaveSet;
    ProcVector[X_ReparentWindow] = PanoramiXReparentWindow;
    ProcVector[X_MapWindow] = PanoramiXMapWindow;
    ProcVector[X_MapSubwindows] = PanoramiXMapSubwindows;
    ProcVector[X_UnmapWindow] = PanoramiXUnmapWindow;
    ProcVector[X_UnmapSubwindows] = PanoramiXUnmapSubwindows;
    ProcVector[X_ConfigureWindow] = PanoramiXConfigureWindow;
    ProcVector[X_CirculateWindow] = PanoramiXCirculateWindow;
    ProcVector[X_GetGeometry] = PanoramiXGetGeometry;
    ProcVector[X_TranslateCoords] = PanoramiXTranslateCoords;
    ProcVector[X_CreatePixmap] = PanoramiXCreatePixmap;
    ProcVector[X_FreePixmap] = PanoramiXFreePixmap;
    ProcVector[X_CreateGC] = PanoramiXCreateGC;
    ProcVector[X_ChangeGC] = PanoramiXChangeGC;
    ProcVector[X_CopyGC] = PanoramiXCopyGC;
    ProcVector[X_SetDashes] = PanoramiXSetDashes;
    ProcVector[X_SetClipRectangles] = PanoramiXSetClipRectangles;
    ProcVector[X_FreeGC] = PanoramiXFreeGC;
    ProcVector[X_ClearArea] = PanoramiXClearToBackground;
    ProcVector[X_CopyArea] = PanoramiXCopyArea;
    ProcVector[X_CopyPlane] = PanoramiXCopyPlane;
    ProcVector[X_PolyPoint] = PanoramiXPolyPoint;
    ProcVector[X_PolyLine] = PanoramiXPolyLine;
    ProcVector[X_PolySegment] = PanoramiXPolySegment;
    ProcVector[X_PolyRectangle] = PanoramiXPolyRectangle;
    ProcVector[X_PolyArc] = PanoramiXPolyArc;
    ProcVector[X_FillPoly] = PanoramiXFillPoly;
    ProcVector[X_PolyFillRectangle] = PanoramiXPolyFillRectangle;
    ProcVector[X_PolyFillArc] = PanoramiXPolyFillArc;
    ProcVector[X_PutImage] = PanoramiXPutImage;
    ProcVector[X_GetImage] = PanoramiXGetImage;
    ProcVector[X_PolyText8] = PanoramiXPolyText8;
    ProcVector[X_PolyText16] = PanoramiXPolyText16;
    ProcVector[X_ImageText8] = PanoramiXImageText8;
    ProcVector[X_ImageText16] = PanoramiXImageText16;
    ProcVector[X_CreateColormap] = PanoramiXCreateColormap;
    ProcVector[X_FreeColormap] = PanoramiXFreeColormap;
    ProcVector[X_CopyColormapAndFree] = PanoramiXCopyColormapAndFree;
    ProcVector[X_InstallColormap] = PanoramiXInstallColormap;
    ProcVector[X_UninstallColormap] = PanoramiXUninstallColormap;
    ProcVector[X_AllocColor] = PanoramiXAllocColor;
    ProcVector[X_AllocNamedColor] = PanoramiXAllocNamedColor;
    ProcVector[X_AllocColorCells] = PanoramiXAllocColorCells;
    ProcVector[X_AllocColorPlanes] = PanoramiXAllocColorPlanes;
    ProcVector[X_FreeColors] = PanoramiXFreeColors;
    ProcVector[X_StoreColors] = PanoramiXStoreColors;
    ProcVector[X_StoreNamedColor] = PanoramiXStoreNamedColor;

    PanoramiXRenderInit ();
#ifdef XFIXES
    PanoramiXFixesInit ();
#endif
#ifdef COMPOSITE
    PanoramiXCompositeInit ();
#endif

}

extern Bool CreateConnectionBlock(void);

Bool PanoramiXCreateConnectionBlock(void)
{
    int i, j, length;
    Bool disableBackingStore = FALSE;
    int old_width, old_height;
    float width_mult, height_mult;
    xWindowRoot *root;
    xVisualType *visual;
    xDepth *depth;
    VisualPtr pVisual;
    ScreenPtr pScreen;

    /*
     *	Do normal CreateConnectionBlock but faking it for only one screen
     */

    if(!PanoramiXNumDepths) {
	ErrorF("Xinerama error: No common visuals\n");
	return FALSE;
    }

    for(i = 1; i < screenInfo.numScreens; i++) {
	pScreen = screenInfo.screens[i];
	if(pScreen->rootDepth != screenInfo.screens[0]->rootDepth) {
	    ErrorF("Xinerama error: Root window depths differ\n");
	    return FALSE;
	}
	if(pScreen->backingStoreSupport != screenInfo.screens[0]->backingStoreSupport)
	     disableBackingStore = TRUE;
    }

    if (disableBackingStore) {
    	for (i = 0; i < screenInfo.numScreens; i++) {
	    pScreen = screenInfo.screens[i];
	    pScreen->backingStoreSupport = NotUseful;
	}
    }

    i = screenInfo.numScreens;
    screenInfo.numScreens = 1;
    if (!CreateConnectionBlock()) {
	screenInfo.numScreens = i;
	return FALSE;
    }

    screenInfo.numScreens = i;
    
    root = (xWindowRoot *) (ConnectionInfo + connBlockScreenStart);
    length = connBlockScreenStart + sizeof(xWindowRoot);

    /* overwrite the connection block */
    root->nDepths = PanoramiXNumDepths;

    for (i = 0; i < PanoramiXNumDepths; i++) {
	depth = (xDepth *) (ConnectionInfo + length);
	depth->depth = PanoramiXDepths[i].depth;
	depth->nVisuals = PanoramiXDepths[i].numVids;
	length += sizeof(xDepth);
	visual = (xVisualType *)(ConnectionInfo + length);
	
	for (j = 0; j < depth->nVisuals; j++, visual++) {
	    visual->visualID = PanoramiXDepths[i].vids[j];

	    for (pVisual = PanoramiXVisuals;
		 pVisual->vid != visual->visualID;
		 pVisual++)
	         ;

	    visual->class = pVisual->class;
	    visual->bitsPerRGB = pVisual->bitsPerRGBValue;
	    visual->colormapEntries = pVisual->ColormapEntries;
	    visual->redMask = pVisual->redMask;
	    visual->greenMask = pVisual->greenMask;
	    visual->blueMask = pVisual->blueMask;
	}

	length += (depth->nVisuals * sizeof(xVisualType));
    }

    connSetupPrefix.length = bytes_to_int32(length);

    for (i = 0; i < PanoramiXNumDepths; i++)
	free(PanoramiXDepths[i].vids);
    free(PanoramiXDepths);
    PanoramiXDepths = NULL;

    /*
     *  OK, change some dimensions so it looks as if it were one big screen
     */
    
    old_width = root->pixWidth;
    old_height = root->pixHeight;

    root->pixWidth = PanoramiXPixWidth;
    root->pixHeight = PanoramiXPixHeight;
    width_mult = (1.0 * root->pixWidth) / old_width;
    height_mult = (1.0 * root->pixHeight) / old_height;
    root->mmWidth *= width_mult;
    root->mmHeight *= height_mult;

    while(ConnectionCallbackList) {
	pointer tmp;

	tmp = (pointer)ConnectionCallbackList;
	(*ConnectionCallbackList->func)();
	ConnectionCallbackList = ConnectionCallbackList->next;
	free(tmp);
    }

    return TRUE;
}

/*
 * This isn't just memcmp(), bitsPerRGBValue is skipped.  markv made that
 * change way back before xf86 4.0, but the comment for _why_ is a bit
 * opaque, so I'm not going to question it for now.
 *
 * This is probably better done as a screen hook so DBE/EVI/GLX can add
 * their own tests, and adding privates to VisualRec so they don't have to
 * do their own back-mapping.
 */
static Bool
VisualsEqual(VisualPtr a, ScreenPtr pScreenB, VisualPtr b)
{
    return ((a->class == b->class) &&
	(a->ColormapEntries == b->ColormapEntries) &&
	(a->nplanes == b->nplanes) &&
	(a->redMask == b->redMask) &&
	(a->greenMask == b->greenMask) &&
	(a->blueMask == b->blueMask) &&
	(a->offsetRed == b->offsetRed) &&
	(a->offsetGreen == b->offsetGreen) &&
	(a->offsetBlue == b->offsetBlue));
}

static void
PanoramiXMaybeAddDepth(DepthPtr pDepth)
{
    ScreenPtr pScreen;
    int j, k;
    Bool found = FALSE;

    FOR_NSCREENS_FORWARD_SKIP(j) {
	pScreen = screenInfo.screens[j];
	for (k = 0; k < pScreen->numDepths; k++) {
	    if (pScreen->allowedDepths[k].depth == pDepth->depth) {
		found = TRUE;
		break;
	    }
	}
    }

    if (!found)
	return;

    j = PanoramiXNumDepths;
    PanoramiXNumDepths++;
    PanoramiXDepths = realloc(PanoramiXDepths,
	    PanoramiXNumDepths * sizeof(DepthRec));
    PanoramiXDepths[j].depth = pDepth->depth;
    PanoramiXDepths[j].numVids = 0;
    /* XXX suboptimal, should grow these dynamically */
    if(pDepth->numVids)
	PanoramiXDepths[j].vids = malloc(sizeof(VisualID) * pDepth->numVids);
    else
	PanoramiXDepths[j].vids = NULL;
}

static void
PanoramiXMaybeAddVisual(VisualPtr pVisual)
{
    ScreenPtr pScreen;
    int j, k;
    Bool found = FALSE;

    FOR_NSCREENS_FORWARD_SKIP(j) {
	pScreen = screenInfo.screens[j];
	found = FALSE;

	for (k = 0; k < pScreen->numVisuals; k++) {
	    VisualPtr candidate = &pScreen->visuals[k];

	    if ((*XineramaVisualsEqualPtr)(pVisual, pScreen, candidate)
#ifdef GLXPROXY
		&& glxMatchVisual(screenInfo.screens[0], pVisual, pScreen)
#endif
		    ) {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	    return;
    }

    /* found a matching visual on all screens, add it to the subset list */
    j = PanoramiXNumVisuals;
    PanoramiXNumVisuals++;
    PanoramiXVisuals = realloc(PanoramiXVisuals,
	    PanoramiXNumVisuals * sizeof(VisualRec));

    memcpy(&PanoramiXVisuals[j], pVisual, sizeof(VisualRec));

    for (k = 0; k < PanoramiXNumDepths; k++) {
	if (PanoramiXDepths[k].depth == pVisual->nplanes) {
	    PanoramiXDepths[k].vids[PanoramiXDepths[k].numVids] = pVisual->vid;
	    PanoramiXDepths[k].numVids++;
	    break;
	}	
    }   
}

extern void
PanoramiXConsolidate(void)
{
    int 	i;
    PanoramiXRes *root, *defmap, *saver;
    ScreenPtr   pScreen = screenInfo.screens[0];
    DepthPtr    pDepth = pScreen->allowedDepths;
    VisualPtr   pVisual = pScreen->visuals;

    PanoramiXNumDepths = 0;
    PanoramiXNumVisuals = 0;

    for (i = 0; i < pScreen->numDepths; i++)
	PanoramiXMaybeAddDepth(pDepth++);

    for (i = 0; i < pScreen->numVisuals; i++)
	PanoramiXMaybeAddVisual(pVisual++);

    root = malloc(sizeof(PanoramiXRes));
    root->type = XRT_WINDOW;
    defmap = malloc(sizeof(PanoramiXRes));
    defmap->type = XRT_COLORMAP;
    saver = malloc(sizeof(PanoramiXRes));
    saver->type = XRT_WINDOW;

    FOR_NSCREENS(i) {
	ScreenPtr pScreen = screenInfo.screens[i];
	root->info[i].id = pScreen->root->drawable.id;
	root->u.win.class = InputOutput;
        root->u.win.root = TRUE;
        saver->info[i].id = pScreen->screensaver.wid;
        saver->u.win.class = InputOutput;
        saver->u.win.root = TRUE;
	defmap->info[i].id = pScreen->defColormap;
    }

    AddResource(root->info[0].id, XRT_WINDOW, root);
    AddResource(saver->info[0].id, XRT_WINDOW, saver);
    AddResource(defmap->info[0].id, XRT_COLORMAP, defmap);
}

VisualID
PanoramiXTranslateVisualID(int screen, VisualID orig)
{
    ScreenPtr pOtherScreen = screenInfo.screens[screen];
    VisualPtr pVisual = NULL;
    int i;

    for (i = 0; i < PanoramiXNumVisuals; i++) {
	if (orig == PanoramiXVisuals[i].vid) {
	    pVisual = &PanoramiXVisuals[i];
	    break;
	}
    }

    if (!pVisual)
	return 0;

    /* if screen is 0, orig is already the correct visual ID */
    if (screen == 0)
	return orig;

    /* found the original, now translate it relative to the backend screen */
    for (i = 0; i < pOtherScreen->numVisuals; i++) {
	VisualPtr pOtherVisual = &pOtherScreen->visuals[i];

	if ((*XineramaVisualsEqualPtr)(pVisual, pOtherScreen, pOtherVisual))
	    return pOtherVisual->vid;
    }

    return 0;
}


/*
 *	PanoramiXResetProc()
 *		Exit, deallocating as needed.
 */

static void PanoramiXResetProc(ExtensionEntry* extEntry)
{
    int		i;

    PanoramiXRenderReset ();
#ifdef XFIXES
    PanoramiXFixesReset ();
#endif
    screenInfo.numScreens = PanoramiXNumScreens;
    for (i = 256; i--; )
	ProcVector[i] = SavedProcVector[i];
}


int
ProcPanoramiXQueryVersion (ClientPtr client)
{
    /* REQUEST(xPanoramiXQueryVersionReq); */
    xPanoramiXQueryVersionReply		rep;
    register 	int			n;

    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_PANORAMIX_MAJOR_VERSION;
    rep.minorVersion = SERVER_PANORAMIX_MINOR_VERSION;
    if (client->swapped) { 
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);     
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof (xPanoramiXQueryVersionReply), (char *)&rep);
    return Success;
}

int
ProcPanoramiXGetState(ClientPtr client)
{
	REQUEST(xPanoramiXGetStateReq);
    	WindowPtr			pWin;
	xPanoramiXGetStateReply		rep;
	int			n, rc;
	
	REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
	rep.state = !noPanoramiXExtension;
	rep.window = stuff->window;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.window, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetStateReply), (char *) &rep);
	return Success;

}

int 
ProcPanoramiXGetScreenCount(ClientPtr client)
{
	REQUEST(xPanoramiXGetScreenCountReq);
    	WindowPtr			pWin;
	xPanoramiXGetScreenCountReply	rep;
	int			n, rc;

	REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
	rep.ScreenCount = PanoramiXNumScreens;
	rep.window = stuff->window;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.window, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetScreenCountReply), (char *) &rep);
	return Success;
}

int 
ProcPanoramiXGetScreenSize(ClientPtr client)
{
	REQUEST(xPanoramiXGetScreenSizeReq);
    	WindowPtr			pWin;
	xPanoramiXGetScreenSizeReply	rep;
	int			n, rc;
	
	if (stuff->screen >= PanoramiXNumScreens)
	    return BadMatch;

	REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
		/* screen dimensions */
	rep.width  = screenInfo.screens[stuff->screen]->width;
	rep.height = screenInfo.screens[stuff->screen]->height;
	rep.window = stuff->window;
	rep.screen = stuff->screen;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.width, n);
	    swapl (&rep.height, n);
	    swapl (&rep.window, n);
	    swapl (&rep.screen, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetScreenSizeReply), (char *) &rep);
	return Success;
}


int
ProcXineramaIsActive(ClientPtr client)
{
    /* REQUEST(xXineramaIsActiveReq); */
    xXineramaIsActiveReply	rep;

    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
#if 1
    {
	/* The following hack fools clients into thinking that Xinerama
	 * is disabled even though it is not. */
	rep.state = !noPanoramiXExtension && !PanoramiXExtensionDisabledHack;
    }
#else
    rep.state = !noPanoramiXExtension;
#endif
    if (client->swapped) {
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.state, n);
    }	
    WriteToClient (client, sizeof (xXineramaIsActiveReply), (char *) &rep);
    return Success;
}


int
ProcXineramaQueryScreens(ClientPtr client)
{
    /* REQUEST(xXineramaQueryScreensReq); */
    xXineramaQueryScreensReply	rep;

    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = (noPanoramiXExtension) ? 0 : PanoramiXNumScreens;
    rep.length = bytes_to_int32(rep.number * sz_XineramaScreenInfo);
    if (client->swapped) {
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.number, n);
    }	
    WriteToClient (client, sizeof (xXineramaQueryScreensReply), (char *) &rep);

    if(!noPanoramiXExtension) {
	xXineramaScreenInfo scratch;
	int i;

	FOR_NSCREENS(i) {
	    scratch.x_org  = screenInfo.screens[i]->x;
	    scratch.y_org  = screenInfo.screens[i]->y;
	    scratch.width  = screenInfo.screens[i]->width;
	    scratch.height = screenInfo.screens[i]->height;
	
	    if(client->swapped) {
		int n;
		swaps (&scratch.x_org, n);
		swaps (&scratch.y_org, n);
		swaps (&scratch.width, n);
		swaps (&scratch.height, n);
	    }
	    WriteToClient (client, sz_XineramaScreenInfo, (char *) &scratch);
	}
    }

    return Success;
}


static int
ProcPanoramiXDispatch (ClientPtr client)
{   REQUEST(xReq);
    switch (stuff->data)
    {
	case X_PanoramiXQueryVersion:
	     return ProcPanoramiXQueryVersion(client);
	case X_PanoramiXGetState:
	     return ProcPanoramiXGetState(client);
	case X_PanoramiXGetScreenCount:
	     return ProcPanoramiXGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return ProcPanoramiXGetScreenSize(client);
	case X_XineramaIsActive:
	     return ProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return ProcXineramaQueryScreens(client);
    }
    return BadRequest;
}


#if X_BYTE_ORDER == X_LITTLE_ENDIAN
#define SHIFT_L(v,s) (v) << (s)
#define SHIFT_R(v,s) (v) >> (s)
#else
#define SHIFT_L(v,s) (v) >> (s)
#define SHIFT_R(v,s) (v) << (s)
#endif

static void
CopyBits(char *dst, int shiftL, char *src, int bytes)
{
   /* Just get it to work.  Worry about speed later */
    int shiftR = 8 - shiftL;

    while(bytes--) {
	*dst |= SHIFT_L(*src, shiftL);
	*(dst + 1) |= SHIFT_R(*src, shiftR);
	dst++; src++;
    }     
}


/* Caution.  This doesn't support 2 and 4 bpp formats.  We expect
   1 bpp and planar data to be already cleared when presented
   to this function */

void
XineramaGetImageData(
    DrawablePtr *pDrawables,
    int left,
    int top,
    int width, 
    int height,
    unsigned int format,
    unsigned long planemask,
    char *data,
    int pitch,
    Bool isRoot
){
    RegionRec SrcRegion, ScreenRegion, GrabRegion;
    BoxRec SrcBox, *pbox;
    int x, y, w, h, i, j, nbox, size, sizeNeeded, ScratchPitch, inOut, depth;
    DrawablePtr pDraw = pDrawables[0];
    char *ScratchMem = NULL;

    size = 0;

    /* find box in logical screen space */
    SrcBox.x1 = left;
    SrcBox.y1 = top;
    if(!isRoot) {
	SrcBox.x1 += pDraw->x + screenInfo.screens[0]->x;
	SrcBox.y1 += pDraw->y + screenInfo.screens[0]->y;
    }
    SrcBox.x2 = SrcBox.x1 + width;
    SrcBox.y2 = SrcBox.y1 + height;
    
    RegionInit(&SrcRegion, &SrcBox, 1);
    RegionNull(&GrabRegion);

    depth = (format == XYPixmap) ? 1 : pDraw->depth;

    FOR_NSCREENS(i) {
	BoxRec TheBox;
	ScreenPtr pScreen;
	pDraw = pDrawables[i];
	pScreen = pDraw->pScreen;

	TheBox.x1 = pScreen->x;
	TheBox.x2 = TheBox.x1 + pScreen->width;
	TheBox.y1 = pScreen->y;
	TheBox.y2 = TheBox.y1 + pScreen->height;

	RegionInit(&ScreenRegion, &TheBox, 1);
	inOut = RegionContainsRect(&ScreenRegion, &SrcBox);
	if(inOut == rgnPART)
	    RegionIntersect(&GrabRegion, &SrcRegion, &ScreenRegion);
	RegionUninit(&ScreenRegion);

	if(inOut == rgnIN) {	   
	    (*pScreen->GetImage)(pDraw,
			SrcBox.x1 - pDraw->x - screenInfo.screens[i]->x,
			SrcBox.y1 - pDraw->y - screenInfo.screens[i]->y,
			width, height, format, planemask, data);
	    break;
	} else if (inOut == rgnOUT)
	    continue;

	nbox = RegionNumRects(&GrabRegion);

	if(nbox) {
	    pbox = RegionRects(&GrabRegion);

	    while(nbox--) {
		w = pbox->x2 - pbox->x1;
		h = pbox->y2 - pbox->y1;
		ScratchPitch = PixmapBytePad(w, depth);
		sizeNeeded = ScratchPitch * h;

		if(sizeNeeded > size) {
		    char *tmpdata = ScratchMem;
		    ScratchMem = realloc(ScratchMem, sizeNeeded);
		    if(ScratchMem)
			size = sizeNeeded;
		    else {
			ScratchMem = tmpdata;
			break;
		    }	
		}

		x = pbox->x1 - pDraw->x - screenInfo.screens[i]->x;
		y = pbox->y1 - pDraw->y - screenInfo.screens[i]->y;

		(*pScreen->GetImage)(pDraw, x, y, w, h,
					format, planemask, ScratchMem);
		
		/* copy the memory over */

		if(depth == 1) {
		   int k, shift, leftover, index, index2;
		
		   x = pbox->x1 - SrcBox.x1;
		   y = pbox->y1 - SrcBox.y1;
		   shift = x & 7;
		   x >>= 3;
		   leftover = w & 7;
		   w >>= 3;

		   /* clean up the edge */
		   if(leftover) {
			int mask = (1 << leftover) - 1;
			for(j = h, k = w; j--; k += ScratchPitch)
			    ScratchMem[k] &= mask;
		   }

		   for(j = 0, index = (pitch * y) + x, index2 = 0; j < h;
		       j++, index += pitch, index2 += ScratchPitch) 
		   {
			if(w) {
			    if(!shift)
				memcpy(data + index, ScratchMem + index2, w);
			    else
				CopyBits(data + index, shift, 
						ScratchMem + index2, w);
			}
	
			if(leftover) {
			    data[index + w] |= 
				SHIFT_L(ScratchMem[index2 + w], shift);
			    if((shift + leftover) > 8)
				data[index + w + 1] |= 
				  SHIFT_R(ScratchMem[index2 + w],(8 - shift));
			}
		    }
		} else {
		    j = BitsPerPixel(depth) >> 3;
		    x = (pbox->x1 - SrcBox.x1) * j;
		    y = pbox->y1 - SrcBox.y1;
		    w *= j;

		    for(j = 0; j < h; j++) {
			memcpy(data + (pitch * (y + j)) + x, 
				ScratchMem + (ScratchPitch * j), w);
		    }
		}
		pbox++;
	    }

	    RegionSubtract(&SrcRegion, &SrcRegion, &GrabRegion);
	    if(!RegionNotEmpty(&SrcRegion))
		break;
	}
	
    }

    free(ScratchMem);

    RegionUninit(&SrcRegion);
    RegionUninit(&GrabRegion);
}
/*****************************************************************

Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/


/* THIS IS NOT AN X PROJECT TEAM SPECIFICATION */

/*  
 *	PanoramiX definitions
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _PANORAMIX_H_
#define _PANORAMIX_H_

#define _PANORAMIX_SERVER
#include <X11/extensions/panoramiXproto.h>
#undef _PANORAMIX_SERVER
#include "gcstruct.h"
#include "dixstruct.h"

typedef struct _PanoramiXInfo {
    XID id ;
} PanoramiXInfo;

typedef struct {
    PanoramiXInfo info[MAXSCREENS];
    RESTYPE type;
    union {
	struct {
	    char   visibility;
	    char   class;
            char   root;
	} win;
	struct {
	    Bool shared;
	} pix;
	struct {
	    Bool root;
	} pict;
	char raw_data[4];
    } u;
} PanoramiXRes;

#define FOR_NSCREENS_FORWARD(j) for(j = 0; j < PanoramiXNumScreens; j++)
#define FOR_NSCREENS_FORWARD_SKIP(j) for(j = 1; j < PanoramiXNumScreens; j++)
#define FOR_NSCREENS_BACKWARD(j) for(j = PanoramiXNumScreens - 1; j >= 0; j--)
#define FOR_NSCREENS(j) FOR_NSCREENS_FORWARD(j)

#define IS_SHARED_PIXMAP(r) (((r)->type == XRT_PIXMAP) && (r)->u.pix.shared)

#define IS_ROOT_DRAWABLE(d) (((d)->type == XRT_WINDOW) && (d)->u.win.root)
#endif /* _PANORAMIX_H_ */

/*
 *	Server dispatcher function replacements
 */

extern int PanoramiXCreateWindow(ClientPtr client);
extern int PanoramiXChangeWindowAttributes(ClientPtr client);
extern int PanoramiXDestroyWindow(ClientPtr client);
extern int PanoramiXDestroySubwindows(ClientPtr client);
extern int PanoramiXChangeSaveSet(ClientPtr client);
extern int PanoramiXReparentWindow(ClientPtr client);
extern int PanoramiXMapWindow(ClientPtr client);
extern int PanoramiXMapSubwindows(ClientPtr client);
extern int PanoramiXUnmapWindow(ClientPtr client);
extern int PanoramiXUnmapSubwindows(ClientPtr client);
extern int PanoramiXConfigureWindow(ClientPtr client);
extern int PanoramiXCirculateWindow(ClientPtr client);
extern int PanoramiXGetGeometry(ClientPtr client);
extern int PanoramiXTranslateCoords(ClientPtr client);	
extern int PanoramiXCreatePixmap(ClientPtr client);
extern int PanoramiXFreePixmap(ClientPtr client);
extern int PanoramiXChangeGC(ClientPtr client);
extern int PanoramiXCopyGC(ClientPtr client);
extern int PanoramiXCopyColormapAndFree(ClientPtr client);
extern int PanoramiXCreateGC(ClientPtr client);
extern int PanoramiXSetDashes(ClientPtr client);
extern int PanoramiXSetClipRectangles(ClientPtr client);
extern int PanoramiXFreeGC(ClientPtr client);
extern int PanoramiXClearToBackground(ClientPtr client);
extern int PanoramiXCopyArea(ClientPtr client);
extern int PanoramiXCopyPlane(ClientPtr client);
extern int PanoramiXPolyPoint(ClientPtr client);
extern int PanoramiXPolyLine(ClientPtr client);
extern int PanoramiXPolySegment(ClientPtr client);
extern int PanoramiXPolyRectangle(ClientPtr client);
extern int PanoramiXPolyArc(ClientPtr client);
extern int PanoramiXFillPoly(ClientPtr client);
extern int PanoramiXPolyFillArc(ClientPtr client);
extern int PanoramiXPolyFillRectangle(ClientPtr client);
extern int PanoramiXPutImage(ClientPtr client);
extern int PanoramiXGetImage(ClientPtr client);
extern int PanoramiXPolyText8(ClientPtr client);
extern int PanoramiXPolyText16(ClientPtr client);	
extern int PanoramiXImageText8(ClientPtr client);
extern int PanoramiXImageText16(ClientPtr client);
extern int PanoramiXCreateColormap(ClientPtr client);
extern int PanoramiXFreeColormap(ClientPtr client);
extern int PanoramiXInstallColormap(ClientPtr client);
extern int PanoramiXUninstallColormap(ClientPtr client);
extern int PanoramiXAllocColor(ClientPtr client);
extern int PanoramiXAllocNamedColor(ClientPtr client);
extern int PanoramiXAllocColorCells(ClientPtr client);
extern int PanoramiXStoreNamedColor(ClientPtr client);
extern int PanoramiXFreeColors(ClientPtr client);
extern int PanoramiXStoreColors(ClientPtr client);
extern int PanoramiXAllocColorPlanes(ClientPtr client);

#define PROC_EXTERN(pfunc)      extern int pfunc(ClientPtr)

PROC_EXTERN(ProcPanoramiXQueryVersion); 
PROC_EXTERN(ProcPanoramiXGetState); 
PROC_EXTERN(ProcPanoramiXGetScreenCount); 
PROC_EXTERN(ProcPanoramiXGetScreenSize); 
 
PROC_EXTERN(ProcXineramaQueryScreens);
PROC_EXTERN(ProcXineramaIsActive);

extern int SProcPanoramiXDispatch(ClientPtr client);

extern int connBlockScreenStart;
extern xConnSetupPrefix connSetupPrefix;

extern int (* SavedProcVector[256]) (ClientPtr client);
/*****************************************************************
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/

/* Massively rewritten by Mark Vojkovich <markv@valinux.com> */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "windowstr.h"
#include "dixfontstr.h"
#include "gcstruct.h"
#include "colormapst.h"
#include "scrnintstr.h"
#include "opaque.h"
#include "inputstr.h"
#include "migc.h"
#include "misc.h"
#include "dixstruct.h"
#include "panoramiX.h"
#include "panoramiXsrv.h"
#include "resource.h"
#include "panoramiXh.h"

#define XINERAMA_IMAGE_BUFSIZE (256*1024)
#define INPUTONLY_LEGAL_MASK (CWWinGravity | CWEventMask | \
                              CWDontPropagate | CWOverrideRedirect | CWCursor )

int PanoramiXCreateWindow(ClientPtr client)
{
    PanoramiXRes *parent, *newWin;
    PanoramiXRes *backPix = NULL;
    PanoramiXRes *bordPix = NULL;
    PanoramiXRes *cmap    = NULL;
    REQUEST(xCreateWindowReq);
    int pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
    int result, len, j;
    int orig_x, orig_y;
    XID orig_visual, tmp;
    Bool parentIsRoot;

    REQUEST_AT_LEAST_SIZE(xCreateWindowReq);
    
    len = client->req_len - bytes_to_int32(sizeof(xCreateWindowReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByType((pointer *)&parent, stuff->parent,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    if(stuff->class == CopyFromParent)
	stuff->class = parent->u.win.class;

    if((stuff->class == InputOnly) && (stuff->mask & (~INPUTONLY_LEGAL_MASK)))
        return BadMatch;

    if ((Mask)stuff->mask & CWBackPixmap) {
	pback_offset = Ones((Mask)stuff->mask & (CWBackPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pback_offset);
	if ((tmp != None) && (tmp != ParentRelative)) {
	    result = dixLookupResourceByType((pointer *)&backPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & CWBorderPixmap) {
	pbord_offset = Ones((Mask)stuff->mask & (CWBorderPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pbord_offset);
	if (tmp != CopyFromParent) {
	    result = dixLookupResourceByType((pointer *)&bordPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & CWColormap) {
	cmap_offset = Ones((Mask)stuff->mask & (CWColormap - 1));
	tmp = *((CARD32 *) &stuff[1] + cmap_offset);
	if ((tmp != CopyFromParent) && (tmp != None)) {
	    result = dixLookupResourceByType((pointer *)&cmap, tmp,
					     XRT_COLORMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    if(!(newWin = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newWin->type = XRT_WINDOW;
    newWin->u.win.visibility = VisibilityNotViewable;
    newWin->u.win.class = stuff->class;
    newWin->u.win.root = FALSE;
    panoramix_setup_ids(newWin, client, stuff->wid);

    if (stuff->class == InputOnly)
	stuff->visual = CopyFromParent;
    orig_visual = stuff->visual;
    orig_x = stuff->x;
    orig_y = stuff->y;
    parentIsRoot = (stuff->parent == screenInfo.screens[0]->root->drawable.id) ||
                   (stuff->parent == screenInfo.screens[0]->screensaver.wid);
    FOR_NSCREENS_BACKWARD(j) {
        stuff->wid = newWin->info[j].id;
        stuff->parent = parent->info[j].id;
	if (parentIsRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	if (backPix)
	    *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[j].id;
	if (bordPix)
	    *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[j].id;
	if (cmap)
	    *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[j].id;
	if ( orig_visual != CopyFromParent ) 
	    stuff->visual = PanoramiXTranslateVisualID(j, orig_visual);
        result = (*SavedProcVector[X_CreateWindow])(client);
        if(result != Success) break;
    }

    if (result == Success)
        AddResource(newWin->info[0].id, XRT_WINDOW, newWin);
    else 
        free(newWin);

    return result;
}


int PanoramiXChangeWindowAttributes(ClientPtr client)
{
    PanoramiXRes *win;
    PanoramiXRes *backPix = NULL;
    PanoramiXRes *bordPix = NULL;
    PanoramiXRes *cmap    = NULL;
    REQUEST(xChangeWindowAttributesReq);
    int pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xChangeWindowAttributesReq);
    
    len = client->req_len - bytes_to_int32(sizeof(xChangeWindowAttributesReq));
    if (Ones(stuff->valueMask) != len)
        return BadLength;

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    if((win->u.win.class == InputOnly) && 
       (stuff->valueMask & (~INPUTONLY_LEGAL_MASK)))
        return BadMatch;

    if ((Mask)stuff->valueMask & CWBackPixmap) {
	pback_offset = Ones((Mask)stuff->valueMask & (CWBackPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pback_offset);
	if ((tmp != None) && (tmp != ParentRelative)) {
	    result = dixLookupResourceByType((pointer *)&backPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->valueMask & CWBorderPixmap) {
	pbord_offset = Ones((Mask)stuff->valueMask & (CWBorderPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pbord_offset);
	if (tmp != CopyFromParent) {
	    result = dixLookupResourceByType((pointer *)&bordPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->valueMask & CWColormap) {
	cmap_offset = Ones((Mask)stuff->valueMask & (CWColormap - 1));
	tmp = *((CARD32 *) &stuff[1] + cmap_offset);
	if ((tmp != CopyFromParent) && (tmp != None)) {
	    result = dixLookupResourceByType((pointer *)&cmap, tmp,
					     XRT_COLORMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->window = win->info[j].id;
	if (backPix)
	    *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[j].id;
	if (bordPix)
	    *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[j].id;
	if (cmap)
	    *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[j].id;
        result = (*SavedProcVector[X_ChangeWindowAttributes])(client);
    }

    return result;
}


int PanoramiXDestroyWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id, XRT_WINDOW,
				     client, DixDestroyAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_DestroyWindow])(client);
        if(result != Success) break;
    }

    /* Since ProcDestroyWindow is using FreeResource, it will free
	our resource for us on the last pass through the loop above */
 
    return result;
}


int PanoramiXDestroySubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id, XRT_WINDOW,
				     client, DixDestroyAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_DestroySubwindows])(client);
        if(result != Success) break;
    }

    /* DestroySubwindows is using FreeResource which will free
	our resources for us on the last pass through the loop above */

    return result;
}


int PanoramiXChangeSaveSet(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xChangeSaveSetReq);

    REQUEST_SIZE_MATCH(xChangeSaveSetReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->window = win->info[j].id;
	result = (*SavedProcVector[X_ChangeSaveSet])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXReparentWindow(ClientPtr client)
{
    PanoramiXRes *win, *parent;
    int         result, j;
    int		x, y;
    Bool	parentIsRoot;
    REQUEST(xReparentWindowReq);

    REQUEST_SIZE_MATCH(xReparentWindowReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    result = dixLookupResourceByType((pointer *)&parent, stuff->parent,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    x = stuff->x;
    y = stuff->y;
    parentIsRoot = (stuff->parent == screenInfo.screens[0]->root->drawable.id) ||
                   (stuff->parent == screenInfo.screens[0]->screensaver.wid);
    FOR_NSCREENS_BACKWARD(j) {
	stuff->window = win->info[j].id;
	stuff->parent = parent->info[j].id;
	if(parentIsRoot) {
	    stuff->x = x - screenInfo.screens[j]->x;
	    stuff->y = y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ReparentWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXMapWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_MapWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXMapSubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_MapSubwindows])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXUnmapWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_UnmapWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXUnmapSubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_UnmapSubwindows])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXConfigureWindow(ClientPtr client)
{
    PanoramiXRes *win;
    PanoramiXRes *sib = NULL;
    WindowPtr   pWin;
    int         result, j, len, sib_offset = 0, x = 0, y = 0;
    int		x_offset = -1;
    int		y_offset = -1;
    REQUEST(xConfigureWindowReq);

    REQUEST_AT_LEAST_SIZE(xConfigureWindowReq);

    len = client->req_len - bytes_to_int32(sizeof(xConfigureWindowReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    /* because we need the parent */
    result = dixLookupResourceByType((pointer *)&pWin, stuff->window,
				     RT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    if ((Mask)stuff->mask & CWSibling) {
	XID tmp;
	sib_offset = Ones((Mask)stuff->mask & (CWSibling - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + sib_offset))) {
	    result = dixLookupResourceByType((pointer *)&sib, tmp, XRT_WINDOW,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    if(pWin->parent && ((pWin->parent == screenInfo.screens[0]->root) ||
                        (pWin->parent->drawable.id == screenInfo.screens[0]->screensaver.wid)))
    {
	if ((Mask)stuff->mask & CWX) {
	    x_offset = 0;
	    x = *((CARD32 *)&stuff[1]);
	}
	if ((Mask)stuff->mask & CWY) {
	    y_offset = (x_offset == -1) ? 0 : 1;
	    y = *((CARD32 *) &stuff[1] + y_offset);
	}
    }

    /* have to go forward or you get expose events before 
	ConfigureNotify events */
    FOR_NSCREENS_FORWARD(j) {
	stuff->window = win->info[j].id;
	if(sib)
	    *((CARD32 *) &stuff[1] + sib_offset) = sib->info[j].id;
	if(x_offset >= 0)
	    *((CARD32 *) &stuff[1] + x_offset) = x - screenInfo.screens[j]->x;
	if(y_offset >= 0)
	    *((CARD32 *) &stuff[1] + y_offset) = y - screenInfo.screens[j]->y;
	result = (*SavedProcVector[X_ConfigureWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXCirculateWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j;
    REQUEST(xCirculateWindowReq);

    REQUEST_SIZE_MATCH(xCirculateWindowReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_FORWARD(j) {
	stuff->window = win->info[j].id;
	result = (*SavedProcVector[X_CirculateWindow])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXGetGeometry(ClientPtr client)
{
    xGetGeometryReply 	 rep;
    DrawablePtr pDraw;
    int rc;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupDrawable(&pDraw, stuff->id, client, M_ANY, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.root = screenInfo.screens[0]->root->drawable.id;
    rep.depth = pDraw->depth;
    rep.width = pDraw->width;
    rep.height = pDraw->height;
    rep.x = rep.y = rep.borderWidth = 0;

    if (stuff->id == rep.root) {
	xWindowRoot *root  = (xWindowRoot *)
				    (ConnectionInfo + connBlockScreenStart);

	rep.width = root->pixWidth;
	rep.height = root->pixHeight;
    } else 
    if (WindowDrawable(pDraw->type))
    {
        WindowPtr pWin = (WindowPtr)pDraw;
	rep.x = pWin->origin.x - wBorderWidth (pWin);
	rep.y = pWin->origin.y - wBorderWidth (pWin);
	if((pWin->parent == screenInfo.screens[0]->root) ||
           (pWin->parent->drawable.id == screenInfo.screens[0]->screensaver.wid))
        {
	   rep.x += screenInfo.screens[0]->x;
	   rep.y += screenInfo.screens[0]->y;
	}
	rep.borderWidth = pWin->borderWidth;
    }

    WriteReplyToClient(client, sizeof(xGetGeometryReply), &rep);
    return Success;
}

int PanoramiXTranslateCoords(ClientPtr client)
{
    INT16 x, y;
    REQUEST(xTranslateCoordsReq);
    int rc;
    WindowPtr pWin, pDst;
    xTranslateCoordsReply rep;

    REQUEST_SIZE_MATCH(xTranslateCoordsReq);
    rc = dixLookupWindow(&pWin, stuff->srcWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pDst, stuff->dstWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.sameScreen = xTrue;
    rep.child = None;

    if((pWin == screenInfo.screens[0]->root) ||
       (pWin->drawable.id == screenInfo.screens[0]->screensaver.wid))
    { 
	x = stuff->srcX - screenInfo.screens[0]->x;
	y = stuff->srcY - screenInfo.screens[0]->y;
    } else {
	x = pWin->drawable.x + stuff->srcX;
	y = pWin->drawable.y + stuff->srcY;
    }
    pWin = pDst->firstChild;
    while (pWin) {
	    BoxRec  box;
	    if ((pWin->mapped) &&
		(x >= pWin->drawable.x - wBorderWidth (pWin)) &&
		(x < pWin->drawable.x + (int)pWin->drawable.width +
		 wBorderWidth (pWin)) &&
		(y >= pWin->drawable.y - wBorderWidth (pWin)) &&
		(y < pWin->drawable.y + (int)pWin->drawable.height +
		 wBorderWidth (pWin))
		/* When a window is shaped, a further check
		 * is made to see if the point is inside
		 * borderSize
		 */
		&& (!wBoundingShape(pWin) ||
		    RegionContainsPoint(wBoundingShape(pWin),
					x - pWin->drawable.x, 
					y - pWin->drawable.y, &box))
		)
            {
		rep.child = pWin->drawable.id;
		pWin = (WindowPtr) NULL;
	    }
	    else
		pWin = pWin->nextSib;
    }
    rep.dstX = x - pDst->drawable.x;
    rep.dstY = y - pDst->drawable.y;
    if((pDst == screenInfo.screens[0]->root) ||
       (pDst->drawable.id == screenInfo.screens[0]->screensaver.wid))
    {
	rep.dstX += screenInfo.screens[0]->x;
	rep.dstY += screenInfo.screens[0]->y;
    }

    WriteReplyToClient(client, sizeof(xTranslateCoordsReply), &rep);
    return Success;
}

int PanoramiXCreatePixmap(ClientPtr client)
{
    PanoramiXRes *refDraw, *newPix;
    int result, j;
    REQUEST(xCreatePixmapReq);

    REQUEST_SIZE_MATCH(xCreatePixmapReq);
    client->errorValue = stuff->pid;

    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(!(newPix = malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPix->type = XRT_PIXMAP;
    newPix->u.pix.shared = FALSE;
    panoramix_setup_ids(newPix, client, stuff->pid);
   
    FOR_NSCREENS_BACKWARD(j) {
	stuff->pid = newPix->info[j].id;
	stuff->drawable = refDraw->info[j].id;
	result = (*SavedProcVector[X_CreatePixmap])(client);
	if(result != Success) break;
    }

    if (result == Success)
	AddResource(newPix->info[0].id, XRT_PIXMAP, newPix);
    else 
	free(newPix);

    return result;
}


int PanoramiXFreePixmap(ClientPtr client)
{
    PanoramiXRes *pix;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((pointer *)&pix, stuff->id, XRT_PIXMAP,
				     client, DixDestroyAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = pix->info[j].id;
	result = (*SavedProcVector[X_FreePixmap])(client);
	if(result != Success) break;
    }

    /* Since ProcFreePixmap is using FreeResource, it will free
	our resource for us on the last pass through the loop above */
 
    return result;
}


int PanoramiXCreateGC(ClientPtr client)
{
    PanoramiXRes *refDraw;
    PanoramiXRes *newGC;
    PanoramiXRes *stip = NULL;
    PanoramiXRes *tile = NULL;
    PanoramiXRes *clip = NULL;
    REQUEST(xCreateGCReq);
    int tile_offset = 0, stip_offset = 0, clip_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xCreateGCReq);
    
    client->errorValue = stuff->gc;
    len = client->req_len - bytes_to_int32(sizeof(xCreateGCReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if ((Mask)stuff->mask & GCTile) {
	tile_offset = Ones((Mask)stuff->mask & (GCTile - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + tile_offset))) {
	    result = dixLookupResourceByType((pointer *)&tile, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCStipple) {
	stip_offset = Ones((Mask)stuff->mask & (GCStipple - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + stip_offset))) {
	    result = dixLookupResourceByType((pointer *)&stip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCClipMask) {
	clip_offset = Ones((Mask)stuff->mask & (GCClipMask - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + clip_offset))) {
	    result = dixLookupResourceByType((pointer *)&clip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    if(!(newGC = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newGC->type = XRT_GC;
    panoramix_setup_ids(newGC, client, stuff->gc);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = newGC->info[j].id;
        stuff->drawable = refDraw->info[j].id;
	if (tile)
	    *((CARD32 *) &stuff[1] + tile_offset) = tile->info[j].id;
	if (stip)
	    *((CARD32 *) &stuff[1] + stip_offset) = stip->info[j].id;
	if (clip)
	    *((CARD32 *) &stuff[1] + clip_offset) = clip->info[j].id;
        result = (*SavedProcVector[X_CreateGC])(client);
        if(result != Success) break;
    }

    if (result == Success)
        AddResource(newGC->info[0].id, XRT_GC, newGC);
    else 
        free(newGC);

    return result;
}

int PanoramiXChangeGC(ClientPtr client)
{
    PanoramiXRes *gc;
    PanoramiXRes *stip = NULL;
    PanoramiXRes *tile = NULL;
    PanoramiXRes *clip = NULL;
    REQUEST(xChangeGCReq);
    int tile_offset = 0, stip_offset = 0, clip_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xChangeGCReq);
    
    len = client->req_len - bytes_to_int32(sizeof(xChangeGCReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    if ((Mask)stuff->mask & GCTile) {
	tile_offset = Ones((Mask)stuff->mask & (GCTile - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + tile_offset))) {
	    result = dixLookupResourceByType((pointer *)&tile, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCStipple) {
	stip_offset = Ones((Mask)stuff->mask & (GCStipple - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + stip_offset))) {
	    result = dixLookupResourceByType((pointer *)&stip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCClipMask) {
	clip_offset = Ones((Mask)stuff->mask & (GCClipMask - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + clip_offset))) {
	    result = dixLookupResourceByType((pointer *)&clip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }


    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = gc->info[j].id;
	if (tile)
	    *((CARD32 *) &stuff[1] + tile_offset) = tile->info[j].id;
	if (stip)
	    *((CARD32 *) &stuff[1] + stip_offset) = stip->info[j].id;
	if (clip)
	    *((CARD32 *) &stuff[1] + clip_offset) = clip->info[j].id;
        result = (*SavedProcVector[X_ChangeGC])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXCopyGC(ClientPtr client)
{
    PanoramiXRes *srcGC, *dstGC;
    int         result, j;
    REQUEST(xCopyGCReq);

    REQUEST_SIZE_MATCH(xCopyGCReq);

    result = dixLookupResourceByType((pointer *)&srcGC, stuff->srcGC, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    result = dixLookupResourceByType((pointer *)&dstGC, stuff->dstGC, XRT_GC,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS(j) {
	stuff->srcGC = srcGC->info[j].id;
	stuff->dstGC = dstGC->info[j].id;
	result = (*SavedProcVector[X_CopyGC])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXSetDashes(ClientPtr client)
{
    PanoramiXRes *gc;
    int         result, j;
    REQUEST(xSetDashesReq);

    REQUEST_FIXED_SIZE(xSetDashesReq, stuff->nDashes);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->gc = gc->info[j].id;
	result = (*SavedProcVector[X_SetDashes])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXSetClipRectangles(ClientPtr client)
{
    PanoramiXRes *gc;
    int         result, j;
    REQUEST(xSetClipRectanglesReq);

    REQUEST_AT_LEAST_SIZE(xSetClipRectanglesReq);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->gc = gc->info[j].id;
	result = (*SavedProcVector[X_SetClipRectangles])(client);
        if(result != Success) break;
    }

    return result;
}


int PanoramiXFreeGC(ClientPtr client)
{
    PanoramiXRes *gc;
    int         result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((pointer *)&gc, stuff->id, XRT_GC,
				     client, DixDestroyAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = gc->info[j].id;
	result = (*SavedProcVector[X_FreeGC])(client);
	if(result != Success) break;
    }

    /* Since ProcFreeGC is using FreeResource, it will free
	our resource for us on the last pass through the loop above */
 
    return result;
}


int PanoramiXClearToBackground(ClientPtr client)
{
    PanoramiXRes *win;
    int         result, j, x, y;
    Bool	isRoot;
    REQUEST(xClearAreaReq);

    REQUEST_SIZE_MATCH(xClearAreaReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
	return result;

    x = stuff->x;
    y = stuff->y;
    isRoot = win->u.win.root;
    FOR_NSCREENS_BACKWARD(j) {
	stuff->window = win->info[j].id;
	if(isRoot) {
	    stuff->x = x - screenInfo.screens[j]->x;
	    stuff->y = y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ClearArea])(client);
	if(result != Success) break;
    }
 
    return result;
}


/* 
    For Window to Pixmap copies you're screwed since each screen's
    pixmap will look like what it sees on its screen.  Unless the
    screens overlap and the window lies on each, the two copies
    will be out of sync.  To remedy this we do a GetImage and PutImage
    in place of the copy.  Doing this as a single Image isn't quite
    correct since it will include the obscured areas but we will
    have to fix this later. (MArk).
*/

int PanoramiXCopyArea(ClientPtr client)
{
    int			j, result, srcx, srcy, dstx, dsty;
    PanoramiXRes	*gc, *src, *dst;
    Bool		srcIsRoot = FALSE;
    Bool		dstIsRoot = FALSE;
    Bool		srcShared, dstShared;
    REQUEST(xCopyAreaReq);

    REQUEST_SIZE_MATCH(xCopyAreaReq);

    result = dixLookupResourceByClass((pointer *)&src, stuff->srcDrawable,
				      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    srcShared = IS_SHARED_PIXMAP(src);

    result = dixLookupResourceByClass((pointer *)&dst, stuff->dstDrawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    dstShared = IS_SHARED_PIXMAP(dst);

    if(dstShared && srcShared)
	return (* SavedProcVector[X_CopyArea])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    if((dst->type == XRT_WINDOW) && dst->u.win.root)
	dstIsRoot = TRUE;
    if((src->type == XRT_WINDOW) && src->u.win.root)
	srcIsRoot = TRUE;

    srcx = stuff->srcX; srcy = stuff->srcY;
    dstx = stuff->dstX; dsty = stuff->dstY;
    if((dst->type == XRT_PIXMAP) && (src->type == XRT_WINDOW)) {
	DrawablePtr drawables[MAXSCREENS];
	DrawablePtr pDst;
	GCPtr pGC;
        char *data;
	int pitch, rc;

	FOR_NSCREENS(j) {
	    rc = dixLookupDrawable(drawables+j, src->info[j].id, client, 0,
				   DixGetAttrAccess);
	    if (rc != Success)
		return rc;
	}

	pitch = PixmapBytePad(stuff->width, drawables[0]->depth); 
	if(!(data = calloc(1, stuff->height * pitch)))
	    return BadAlloc;

	XineramaGetImageData(drawables, srcx, srcy, 
		stuff->width, stuff->height, ZPixmap, ~0, data, pitch, 
		srcIsRoot);

	FOR_NSCREENS_BACKWARD(j) {
	    stuff->gc = gc->info[j].id;
	    VALIDATE_DRAWABLE_AND_GC(dst->info[j].id, pDst, DixWriteAccess);
	    if(drawables[0]->depth != pDst->depth) {
		client->errorValue = stuff->dstDrawable;
		free(data);
		return BadMatch;
	    }

	    (*pGC->ops->PutImage) (pDst, pGC, pDst->depth, dstx, dsty, 
				   stuff->width, stuff->height, 
				   0, ZPixmap, data);

	    if(dstShared) break;
	}

	free(data);
    } else {
	DrawablePtr pDst = NULL, pSrc = NULL;
	GCPtr pGC = NULL;
	RegionRec totalReg;
	int rc;

	RegionNull(&totalReg);
	FOR_NSCREENS_BACKWARD(j) {
	    RegionPtr pRgn;
	    stuff->dstDrawable = dst->info[j].id;
	    stuff->srcDrawable = src->info[j].id;
	    stuff->gc          = gc->info[j].id;
 	    if (srcIsRoot) {	
		stuff->srcX = srcx - screenInfo.screens[j]->x;
		stuff->srcY = srcy - screenInfo.screens[j]->y;
	    }
 	    if (dstIsRoot) {	
		stuff->dstX = dstx - screenInfo.screens[j]->x;
		stuff->dstY = dsty - screenInfo.screens[j]->y;
	    }

	    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pDst, DixWriteAccess);

	    if (stuff->dstDrawable != stuff->srcDrawable) {
		rc = dixLookupDrawable(&pSrc, stuff->srcDrawable, client, 0,
				       DixReadAccess);
		if (rc != Success)
		    return rc;

		if ((pDst->pScreen != pSrc->pScreen) || 
		    (pDst->depth != pSrc->depth)) {
			client->errorValue = stuff->dstDrawable;
			return BadMatch;
   		}
 	    } else
		pSrc = pDst;

	    pRgn = (*pGC->ops->CopyArea)(pSrc, pDst, pGC,
				stuff->srcX, stuff->srcY,
				stuff->width, stuff->height, 
				stuff->dstX, stuff->dstY);
	    if(pGC->graphicsExposures && pRgn) {
	       if(srcIsRoot) {
		   RegionTranslate(pRgn,
			    screenInfo.screens[j]->x, screenInfo.screens[j]->y);
	       }
	       RegionAppend(&totalReg, pRgn);
	       RegionDestroy(pRgn);
	    }

	    if(dstShared)
		break;
	}

	if(pGC->graphicsExposures) {
	    Bool overlap;
	    RegionValidate(&totalReg, &overlap);
	    (*pDst->pScreen->SendGraphicsExpose)(
		client, &totalReg, stuff->dstDrawable, X_CopyArea, 0);
	    RegionUninit(&totalReg);
	}
    }

    return Success;
}


int PanoramiXCopyPlane(ClientPtr client)
{
    int			j, srcx, srcy, dstx, dsty, rc;
    PanoramiXRes	*gc, *src, *dst;
    Bool		srcIsRoot = FALSE;
    Bool		dstIsRoot = FALSE;
    Bool		srcShared, dstShared;
    DrawablePtr 	psrcDraw, pdstDraw = NULL;
    GCPtr 		pGC = NULL;
    RegionRec		totalReg;
    REQUEST(xCopyPlaneReq);

    REQUEST_SIZE_MATCH(xCopyPlaneReq);

    rc = dixLookupResourceByClass((pointer *)&src, stuff->srcDrawable,
				  XRC_DRAWABLE, client, DixReadAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    srcShared = IS_SHARED_PIXMAP(src);

    rc = dixLookupResourceByClass((pointer *)&dst, stuff->dstDrawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    dstShared = IS_SHARED_PIXMAP(dst);

    if(dstShared && srcShared)
	return (* SavedProcVector[X_CopyPlane])(client);

    rc = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				 client, DixReadAccess);
    if (rc != Success)
	return rc;

    if((dst->type == XRT_WINDOW) && dst->u.win.root)
	dstIsRoot = TRUE;
    if((src->type == XRT_WINDOW) && src->u.win.root)
	srcIsRoot = TRUE;

    srcx = stuff->srcX; srcy = stuff->srcY;
    dstx = stuff->dstX; dsty = stuff->dstY;
 
    RegionNull(&totalReg);
    FOR_NSCREENS_BACKWARD(j) {
	RegionPtr pRgn;
	stuff->dstDrawable = dst->info[j].id;
	stuff->srcDrawable = src->info[j].id;
	stuff->gc          = gc->info[j].id;
	if (srcIsRoot) {	
	    stuff->srcX = srcx - screenInfo.screens[j]->x;
	    stuff->srcY = srcy - screenInfo.screens[j]->y;
	}
	if (dstIsRoot) {	
	    stuff->dstX = dstx - screenInfo.screens[j]->x;
	    stuff->dstY = dsty - screenInfo.screens[j]->y;
	}

	VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pdstDraw, DixWriteAccess);
	if (stuff->dstDrawable != stuff->srcDrawable) {
	    rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,
				   DixReadAccess);
	    if (rc != Success)
		return rc;

            if (pdstDraw->pScreen != psrcDraw->pScreen) {
		client->errorValue = stuff->dstDrawable;
		return BadMatch;
	    }
	} else
	    psrcDraw = pdstDraw;

	if(stuff->bitPlane == 0 || (stuff->bitPlane & (stuff->bitPlane - 1)) ||
		(stuff->bitPlane > (1L << (psrcDraw->depth - 1)))) {
	    client->errorValue = stuff->bitPlane;
	    return BadValue;
	}

	pRgn = (*pGC->ops->CopyPlane)(psrcDraw, pdstDraw, pGC,
				stuff->srcX, stuff->srcY,
				stuff->width, stuff->height, 
				stuff->dstX, stuff->dstY, stuff->bitPlane);
	if(pGC->graphicsExposures && pRgn) {
	    RegionAppend(&totalReg, pRgn);
	    RegionDestroy(pRgn);
	}

	if(dstShared)
	    break;
    }

    if(pGC->graphicsExposures) {
	Bool overlap;
	RegionValidate(&totalReg, &overlap);
	(*pdstDraw->pScreen->SendGraphicsExpose)(
		client, &totalReg, stuff->dstDrawable, X_CopyPlane, 0);
	RegionUninit(&totalReg);
    }

    return Success;
}


int PanoramiXPolyPoint(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    int 	  result, npoint, j;
    xPoint 	  *origPts;
    Bool	  isRoot;
    REQUEST(xPolyPointReq);

    REQUEST_AT_LEAST_SIZE(xPolyPointReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyPoint])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyPointReq));
    if (npoint > 0) {
        origPts = malloc(npoint * sizeof(xPoint));
        memcpy((char *) origPts, (char *) &stuff[1], npoint * sizeof(xPoint));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origPts, npoint * sizeof(xPoint));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xPoint *pnts = (xPoint*)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : npoint;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
                    }
		}
            }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyPoint])(client);
	    if(result != Success) break;
        }
        free(origPts);
        return result;
    } else
	return Success;
}


int PanoramiXPolyLine(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    int 	  result, npoint, j;
    xPoint 	  *origPts;
    Bool	  isRoot;
    REQUEST(xPolyLineReq);

    REQUEST_AT_LEAST_SIZE(xPolyLineReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyLine])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);
    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyLineReq));
    if (npoint > 0){
        origPts = malloc(npoint * sizeof(xPoint));
        memcpy((char *) origPts, (char *) &stuff[1], npoint * sizeof(xPoint));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origPts, npoint * sizeof(xPoint));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xPoint *pnts = (xPoint*)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : npoint;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
		    }
		}
            }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyLine])(client);
	    if(result != Success) break;
        }
        free(origPts);
        return result;
   } else
	return Success;
}


int PanoramiXPolySegment(ClientPtr client)
{
    int		  result, nsegs, i, j;
    PanoramiXRes *gc, *draw;
    xSegment 	  *origSegs;
    Bool	  isRoot;
    REQUEST(xPolySegmentReq);

    REQUEST_AT_LEAST_SIZE(xPolySegmentReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolySegment])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    nsegs = (client->req_len << 2) - sizeof(xPolySegmentReq);
    if(nsegs & 4) return BadLength;
    nsegs >>= 3;
    if (nsegs > 0) {
	origSegs = malloc(nsegs * sizeof(xSegment));
        memcpy((char *) origSegs, (char *) &stuff[1], nsegs * sizeof(xSegment));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origSegs, nsegs * sizeof(xSegment));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xSegment *segs = (xSegment*)&stuff[1];

		    for (i = nsegs; i--; segs++) {
			segs->x1 -= x_off;
			segs->x2 -= x_off;
			segs->y1 -= y_off;
			segs->y2 -= y_off;
		    }
		}
            }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolySegment])(client);
	    if(result != Success) break;
    	}
	free(origSegs);
	return result;
    } else
	  return Success;
}


int PanoramiXPolyRectangle(ClientPtr client)
{
    int 	  result, nrects, i, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    xRectangle 	  *origRecs;
    REQUEST(xPolyRectangleReq);

    REQUEST_AT_LEAST_SIZE(xPolyRectangleReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyRectangle])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    nrects = (client->req_len << 2) - sizeof(xPolyRectangleReq);
    if(nrects & 4) return BadLength;
    nrects >>= 3;
    if (nrects > 0){
	origRecs = malloc(nrects * sizeof(xRectangle));
	memcpy((char *)origRecs,(char *)&stuff[1],nrects * sizeof(xRectangle));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origRecs, nrects * sizeof(xRectangle));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;


		if(x_off || y_off) {
	    	    xRectangle *rects = (xRectangle *) &stuff[1];

		    for (i = nrects; i--; rects++) {
			rects->x -= x_off;
			rects->y -= y_off;
		    }
		}
	    } 

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyRectangle])(client);
	    if(result != Success) break;
	}
	free(origRecs);
	return result;
    } else
       return Success;
}


int PanoramiXPolyArc(ClientPtr client)
{
    int 	  result, narcs, i, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    xArc	  *origArcs;
    REQUEST(xPolyArcReq);

    REQUEST_AT_LEAST_SIZE(xPolyArcReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyArc])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    narcs = (client->req_len << 2) - sizeof(xPolyArcReq);
    if(narcs % sizeof(xArc)) return BadLength;
    narcs /= sizeof(xArc);
    if (narcs > 0){
	origArcs = malloc(narcs * sizeof(xArc));
	memcpy((char *) origArcs, (char *) &stuff[1], narcs * sizeof(xArc));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origArcs, narcs * sizeof(xArc));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;
	
		if(x_off || y_off) {
		    xArc *arcs = (xArc *) &stuff[1];

		    for (i = narcs; i--; arcs++) {
			arcs->x -= x_off;
			arcs->y -= y_off;
		    }
		}
            }
	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyArc])(client);
	    if(result != Success) break;
        }
	free(origArcs);
	return result;
    } else
       return Success;
}


int PanoramiXFillPoly(ClientPtr client)
{
    int 	  result, count, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    DDXPointPtr	  locPts;
    REQUEST(xFillPolyReq);

    REQUEST_AT_LEAST_SIZE(xFillPolyReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_FillPoly])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    count = bytes_to_int32((client->req_len << 2) - sizeof(xFillPolyReq));
    if (count > 0){
	locPts = malloc(count * sizeof(DDXPointRec));
	memcpy((char *)locPts, (char *)&stuff[1], count * sizeof(DDXPointRec));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], locPts, count * sizeof(DDXPointRec));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    DDXPointPtr pnts = (DDXPointPtr)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : count;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_FillPoly])(client);
	    if(result != Success) break;
	}
	free(locPts);
	return result;
    } else
       return Success;
}


int PanoramiXPolyFillRectangle(ClientPtr client)
{
    int 	  result, things, i, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    xRectangle	  *origRects;
    REQUEST(xPolyFillRectangleReq);

    REQUEST_AT_LEAST_SIZE(xPolyFillRectangleReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyFillRectangle])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    things = (client->req_len << 2) - sizeof(xPolyFillRectangleReq);
    if(things & 4) return BadLength;
    things >>= 3;
    if (things > 0){
	origRects = malloc(things * sizeof(xRectangle));
	memcpy((char*)origRects,(char*)&stuff[1], things * sizeof(xRectangle));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], origRects, things * sizeof(xRectangle));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xRectangle *rects = (xRectangle *) &stuff[1];

		    for (i = things; i--; rects++) {
			rects->x -= x_off;
			rects->y -= y_off;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyFillRectangle])(client);
	    if(result != Success) break;
	}
	free(origRects);
	return result;
    } else
       return Success;
}


int PanoramiXPolyFillArc(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int 	  result, narcs, i, j;
    xArc	  *origArcs;
    REQUEST(xPolyFillArcReq);

    REQUEST_AT_LEAST_SIZE(xPolyFillArcReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyFillArc])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    narcs = (client->req_len << 2) - sizeof(xPolyFillArcReq);
    if (narcs % sizeof(xArc)) return BadLength;
    narcs /= sizeof(xArc);
    if (narcs > 0) {
	origArcs = malloc(narcs * sizeof(xArc));
	memcpy((char *) origArcs, (char *)&stuff[1], narcs * sizeof(xArc));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], origArcs, narcs * sizeof(xArc));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xArc *arcs = (xArc *) &stuff[1];

		    for (i = narcs; i--; arcs++) {
			arcs->x -= x_off;
			arcs->y -= y_off;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyFillArc])(client);
	    if(result != Success) break;
	}
	free(origArcs);
	return result;
    } else
       return Success;
}


int PanoramiXPutImage(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int		  j, result, orig_x, orig_y;
    REQUEST(xPutImageReq);

    REQUEST_AT_LEAST_SIZE(xPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PutImage])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->dstX;
    orig_y = stuff->dstY;
    FOR_NSCREENS_BACKWARD(j){
	if (isRoot) {
	  stuff->dstX = orig_x - screenInfo.screens[j]->x;
	  stuff->dstY = orig_y - screenInfo.screens[j]->y;
	}
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	result = (* SavedProcVector[X_PutImage])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXGetImage(ClientPtr client)
{
    DrawablePtr 	drawables[MAXSCREENS];
    DrawablePtr 	pDraw;
    PanoramiXRes	*draw;
    xGetImageReply	xgi;
    Bool		isRoot;
    char		*pBuf;
    int         	i, x, y, w, h, format, rc;
    Mask		plane = 0, planemask;
    int			linesDone, nlines, linesPerBuf;
    long		widthBytesLine, length;

    REQUEST(xGetImageReq);

    REQUEST_SIZE_MATCH(xGetImageReq);

    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap)) {
	client->errorValue = stuff->format;
        return BadValue;
    }

    rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    if(draw->type == XRT_PIXMAP)
	return (*SavedProcVector[X_GetImage])(client);

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;

    if(!((WindowPtr)pDraw)->realized)
	return BadMatch;

    x = stuff->x;
    y = stuff->y;
    w = stuff->width;
    h = stuff->height;
    format = stuff->format;
    planemask = stuff->planeMask;

    isRoot = IS_ROOT_DRAWABLE(draw);

    if(isRoot) {
      if( /* check for being onscreen */
	x < 0 || x + w > PanoramiXPixWidth ||
	y < 0 || y + h > PanoramiXPixHeight )
	    return BadMatch;
    } else {
      if( /* check for being onscreen */
	screenInfo.screens[0]->x + pDraw->x + x < 0 ||
	screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth ||
	screenInfo.screens[0]->y + pDraw->y + y < 0 ||
	screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight ||
	 /* check for being inside of border */
       	x < - wBorderWidth((WindowPtr)pDraw) ||
	x + w > wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
	y < -wBorderWidth((WindowPtr)pDraw) ||
	y + h > wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height)
	    return BadMatch;
    }

    drawables[0] = pDraw;
    FOR_NSCREENS_FORWARD_SKIP(i) {
	rc = dixLookupDrawable(drawables+i, draw->info[i].id, client, 0,
			       DixGetAttrAccess);
	if (rc != Success)
	    return rc;
    }

    xgi.visual = wVisual (((WindowPtr) pDraw));
    xgi.type = X_Reply;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
    if(format == ZPixmap) {
	widthBytesLine = PixmapBytePad(w, pDraw->depth);
	length = widthBytesLine * h;


    } else {
	widthBytesLine = BitmapBytePad(w);
	plane = ((Mask)1) << (pDraw->depth - 1);
	/* only planes asked for */
	length = widthBytesLine * h *
		 Ones(planemask & (plane | (plane - 1)));

    }

    xgi.length = bytes_to_int32(length);

    if (widthBytesLine == 0 || h == 0)
	linesPerBuf = 0;
    else if (widthBytesLine >= XINERAMA_IMAGE_BUFSIZE)
	linesPerBuf = 1;
    else {
	linesPerBuf = XINERAMA_IMAGE_BUFSIZE / widthBytesLine;
	if (linesPerBuf > h)
	    linesPerBuf = h;
    }
    length = linesPerBuf * widthBytesLine;
    if(!(pBuf = malloc(length)))
	return BadAlloc;

    WriteReplyToClient(client, sizeof (xGetImageReply), &xgi);

    if (linesPerBuf == 0) {
	/* nothing to do */
    }
    else if (format == ZPixmap) {
        linesDone = 0;
        while (h - linesDone > 0) {
	    nlines = min(linesPerBuf, h - linesDone);

	    if(pDraw->depth == 1)
		memset(pBuf, 0, nlines * widthBytesLine);

	    XineramaGetImageData(drawables, x, y + linesDone, w, nlines,
			format, planemask, pBuf, widthBytesLine, isRoot);

		(void)WriteToClient(client,
				    (int)(nlines * widthBytesLine),
				    pBuf);
	    linesDone += nlines;
        }
    } else { /* XYPixmap */
        for (; plane; plane >>= 1) {
	    if (planemask & plane) {
	        linesDone = 0;
	        while (h - linesDone > 0) {
		    nlines = min(linesPerBuf, h - linesDone);

		    memset(pBuf, 0, nlines * widthBytesLine);

		    XineramaGetImageData(drawables, x, y + linesDone, w, 
					nlines, format, plane, pBuf,
					widthBytesLine, isRoot);

		    (void)WriteToClient(client,
				    (int)(nlines * widthBytesLine),
				    pBuf);

		    linesDone += nlines;
		}
            }
	}
    }
    free(pBuf);
    return Success;
}


/* The text stuff should be rewritten so that duplication happens
   at the GlyphBlt level.  That is, loading the font and getting
   the glyphs should only happen once */

int 
PanoramiXPolyText8(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int 	  result, j;
    int	 	  orig_x, orig_y;
    REQUEST(xPolyTextReq);

    REQUEST_AT_LEAST_SIZE(xPolyTextReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyText8])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_PolyText8])(client);
	if(result != Success) break;
    }
    return result;
}

int 
PanoramiXPolyText16(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int 	  result, j;
    int	 	  orig_x, orig_y;
    REQUEST(xPolyTextReq);

    REQUEST_AT_LEAST_SIZE(xPolyTextReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyText16])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_PolyText16])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXImageText8(ClientPtr client)
{
    int 	  result, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int		  orig_x, orig_y;
    REQUEST(xImageTextReq);

    REQUEST_FIXED_SIZE(xImageTextReq, stuff->nChars);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_ImageText8])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ImageText8])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXImageText16(ClientPtr client)
{
    int 	  result, j;
    PanoramiXRes *gc, *draw;
    Bool	  isRoot;
    int		  orig_x, orig_y;
    REQUEST(xImageTextReq);

    REQUEST_FIXED_SIZE(xImageTextReq, stuff->nChars << 1);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_ImageText16])(client);

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ImageText16])(client);
	if(result != Success) break;
    }
    return result;
}



int PanoramiXCreateColormap(ClientPtr client)
{
    PanoramiXRes	*win, *newCmap;
    int 		result, j, orig_visual;
    REQUEST(xCreateColormapReq);

    REQUEST_SIZE_MATCH(xCreateColormapReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
	return result;

    if(!(newCmap = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newCmap->type = XRT_COLORMAP;
    panoramix_setup_ids(newCmap, client, stuff->mid);

    orig_visual = stuff->visual;
    FOR_NSCREENS_BACKWARD(j){
	stuff->mid = newCmap->info[j].id;
	stuff->window = win->info[j].id;
	stuff->visual = PanoramiXTranslateVisualID(j, orig_visual);
	result = (* SavedProcVector[X_CreateColormap])(client);
	if(result != Success) break;
    }
 
    if (result == Success)
        AddResource(newCmap->info[0].id, XRT_COLORMAP, newCmap);
    else 
        free(newCmap);

    return result;
}


int PanoramiXFreeColormap(ClientPtr client)
{
    PanoramiXRes *cmap;
    int          result, j;
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixDestroyAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = cmap->info[j].id;
        result = (* SavedProcVector[X_FreeColormap])(client);
	if(result != Success) break;
    }

    /* Since ProcFreeColormap is using FreeResource, it will free
	our resource for us on the last pass through the loop above */

    return result;
}


int
PanoramiXCopyColormapAndFree(ClientPtr client)
{
    PanoramiXRes *cmap, *newCmap;
    int          result, j;
    REQUEST(xCopyColormapAndFreeReq);

    REQUEST_SIZE_MATCH(xCopyColormapAndFreeReq);

    client->errorValue = stuff->srcCmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->srcCmap,
				     XRT_COLORMAP, client,
				     DixReadAccess | DixWriteAccess);
    if (result != Success)
        return result;

    if(!(newCmap = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newCmap->type = XRT_COLORMAP;
    panoramix_setup_ids(newCmap, client, stuff->mid);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->srcCmap = cmap->info[j].id;
	stuff->mid = newCmap->info[j].id;
        result = (* SavedProcVector[X_CopyColormapAndFree])(client);
	if(result != Success) break;
    }

    if (result == Success)
        AddResource(newCmap->info[0].id, XRT_COLORMAP, newCmap);
    else 
        free(newCmap);

    return result;
}


int PanoramiXInstallColormap(ClientPtr client)
{
    REQUEST(xResourceReq);
    int 	result, j;
    PanoramiXRes *cmap;

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
	stuff->id = cmap->info[j].id;
	result = (* SavedProcVector[X_InstallColormap])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXUninstallColormap(ClientPtr client)
{
    REQUEST(xResourceReq);
    int 	result, j;
    PanoramiXRes *cmap;

    REQUEST_SIZE_MATCH(xResourceReq);
 
    client->errorValue = stuff->id;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
	stuff->id = cmap->info[j].id;
	result = (* SavedProcVector[X_UninstallColormap])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXAllocColor(ClientPtr client)
{
    int           result, j;
    PanoramiXRes *cmap;
    REQUEST(xAllocColorReq);

    REQUEST_SIZE_MATCH(xAllocColorReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColor])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXAllocNamedColor(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xAllocNamedColorReq);

    REQUEST_FIXED_SIZE(xAllocNamedColorReq, stuff->nbytes);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
        stuff->cmap = cmap->info[j].id;
        result = (* SavedProcVector[X_AllocNamedColor])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXAllocColorCells(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xAllocColorCellsReq);

    REQUEST_SIZE_MATCH(xAllocColorCellsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;
	
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColorCells])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXAllocColorPlanes(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xAllocColorPlanesReq);

    REQUEST_SIZE_MATCH(xAllocColorPlanesReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;
	
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColorPlanes])(client);
	if(result != Success) break;
    }
    return result;
}



int PanoramiXFreeColors(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xFreeColorsReq);

    REQUEST_AT_LEAST_SIZE(xFreeColorsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (* SavedProcVector[X_FreeColors])(client);
    }
    return result;
}


int PanoramiXStoreColors(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xStoreColorsReq);

    REQUEST_AT_LEAST_SIZE(xStoreColorsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_StoreColors])(client);
	if(result != Success) break;
    }
    return result;
}


int PanoramiXStoreNamedColor(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
    REQUEST(xStoreNamedColorReq);

    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_StoreNamedColor])(client);
	if(result != Success) break;
    }
    return result;
}

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _PANORAMIXSRV_H_
#define _PANORAMIXSRV_H_

#include "panoramiX.h"

extern _X_EXPORT int PanoramiXNumScreens;
extern _X_EXPORT int PanoramiXPixWidth;
extern _X_EXPORT int PanoramiXPixHeight;

extern _X_EXPORT VisualID PanoramiXTranslateVisualID(int screen, VisualID orig);
extern _X_EXPORT void PanoramiXConsolidate(void);
extern _X_EXPORT Bool PanoramiXCreateConnectionBlock(void);
extern _X_EXPORT PanoramiXRes * PanoramiXFindIDByScrnum(RESTYPE, XID, int);
extern _X_EXPORT Bool XineramaRegisterConnectionBlockCallback(void (*func)(void));
extern _X_EXPORT int XineramaDeleteResource(pointer, XID);

extern _X_EXPORT void XineramaReinitData(ScreenPtr);

extern _X_EXPORT RESTYPE XRC_DRAWABLE;
extern _X_EXPORT RESTYPE XRT_WINDOW;
extern _X_EXPORT RESTYPE XRT_PIXMAP;
extern _X_EXPORT RESTYPE XRT_GC;
extern _X_EXPORT RESTYPE XRT_COLORMAP;
extern _X_EXPORT RESTYPE XRT_PICTURE;

/*
 * Drivers are allowed to wrap this function.  Each wrapper can decide that the
 * two visuals are unequal, but if they are deemed equal, the wrapper must call
 * down and return FALSE if the wrapped function does.  This ensures that all
 * layers agree that the visuals are equal.  The first visual is always from
 * screen 0.
 */
typedef Bool (*XineramaVisualsEqualProcPtr)(VisualPtr, ScreenPtr, VisualPtr);
extern _X_EXPORT XineramaVisualsEqualProcPtr XineramaVisualsEqualPtr;

extern _X_EXPORT void XineramaGetImageData(
    DrawablePtr *pDrawables,
    int left,
    int top,
    int width, 
    int height,
    unsigned int format,
    unsigned long planemask,
    char *data,
    int pitch,
    Bool isRoot
);

static inline void panoramix_setup_ids(PanoramiXRes *resource, 
                                       ClientPtr client, XID base_id)
{
    int j;

    resource->info[0].id = base_id;
    FOR_NSCREENS_FORWARD_SKIP(j) {
        resource->info[j].id = FakeClientID(client->index);
    }
}

#endif /* _PANORAMIXSRV_H_ */
/*****************************************************************
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "cursor.h"
#include "cursorstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "gc.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#include "window.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "panoramiX.h"
#include <X11/extensions/panoramiXproto.h>
#include "panoramiXsrv.h"
#include "globals.h"
#include "panoramiXh.h"

static int
SProcPanoramiXQueryVersion (ClientPtr client)
{
	REQUEST(xPanoramiXQueryVersionReq);
	int n;

	swaps(&stuff->length,n);
	REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
	return ProcPanoramiXQueryVersion(client);
}

static int
SProcPanoramiXGetState(ClientPtr client)
{
	REQUEST(xPanoramiXGetStateReq);
	int n;

 	swaps (&stuff->length, n);	
	REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
	swapl (&stuff->window, n);
	return ProcPanoramiXGetState(client);
}

static int 
SProcPanoramiXGetScreenCount(ClientPtr client)
{
	REQUEST(xPanoramiXGetScreenCountReq);
	int n;

	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
	swapl (&stuff->window, n);
	return ProcPanoramiXGetScreenCount(client);
}

static int 
SProcPanoramiXGetScreenSize(ClientPtr client)
{
	REQUEST(xPanoramiXGetScreenSizeReq);
	int n;

	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
	swapl (&stuff->window, n);
	swapl (&stuff->screen, n);
	return ProcPanoramiXGetScreenSize(client);
}


static int 
SProcXineramaIsActive(ClientPtr client)
{
	REQUEST(xXineramaIsActiveReq);
	int n;

	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
	return ProcXineramaIsActive(client);
}


static int 
SProcXineramaQueryScreens(ClientPtr client)
{
	REQUEST(xXineramaQueryScreensReq);
	int n;

	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
	return ProcXineramaQueryScreens(client);
}


int
SProcPanoramiXDispatch (ClientPtr client)
{   REQUEST(xReq);
    switch (stuff->data)
    {
	case X_PanoramiXQueryVersion:
	     return SProcPanoramiXQueryVersion(client);
	case X_PanoramiXGetState:
	     return SProcPanoramiXGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SProcPanoramiXGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SProcPanoramiXGetScreenSize(client);
	case X_XineramaIsActive:
	     return SProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SProcXineramaQueryScreens(client);
    }
    return BadRequest;
}
/*
 *
Copyright (c) 1992  X Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the X Consortium.
 *
 * Author:  Keith Packard, MIT X Consortium
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/saverproto.h>
#include "gcstruct.h"
#include "cursorstr.h"
#include "colormapst.h"
#include "xace.h"
#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
#ifdef DPMSExtension
#include <X11/extensions/dpmsconst.h>
#endif
#include "protocol-versions.h"

#include <stdio.h>

#include "modinit.h"

static int ScreenSaverEventBase = 0;


static Bool ScreenSaverHandle (
	ScreenPtr /* pScreen */,
	int /* xstate */,
	Bool /* force */
	);

static Bool
CreateSaverWindow (
	ScreenPtr /* pScreen */
	);

static Bool
DestroySaverWindow (
	ScreenPtr /* pScreen */
	);

static void
UninstallSaverColormap (
	ScreenPtr /* pScreen */
	);

static void
CheckScreenPrivate (
	ScreenPtr /* pScreen */
	);

static void SScreenSaverNotifyEvent (
	xScreenSaverNotifyEvent * /* from */,
	xScreenSaverNotifyEvent * /* to */
	);

static RESTYPE SuspendType;  /* resource type for suspension records */

typedef struct _ScreenSaverSuspension *ScreenSaverSuspensionPtr;

/* List of clients that are suspending the screensaver. */
static ScreenSaverSuspensionPtr suspendingClients = NULL;

/*
 * clientResource is a resource ID that's added when the record is
 * allocated, so the record is freed and the screensaver resumed when
 * the client disconnects. count is the number of times the client has
 * requested the screensaver be suspended.
 */
typedef struct _ScreenSaverSuspension
{
    ScreenSaverSuspensionPtr  next;
    ClientPtr                 pClient;
    XID                       clientResource;
    int                       count;
} ScreenSaverSuspensionRec;

static int ScreenSaverFreeSuspend(
    pointer /*value */,
    XID /* id */
);

/*
 * each screen has a list of clients requesting
 * ScreenSaverNotify events.  Each client has a resource
 * for each screen it selects ScreenSaverNotify input for,
 * this resource is used to delete the ScreenSaverNotifyRec
 * entry from the per-screen queue.
 */

static RESTYPE SaverEventType;   /* resource type for event masks */

typedef struct _ScreenSaverEvent *ScreenSaverEventPtr;

typedef struct _ScreenSaverEvent {
    ScreenSaverEventPtr	next;
    ClientPtr		client;
    ScreenPtr		screen;
    XID			resource;
    CARD32		mask;
} ScreenSaverEventRec;

static int ScreenSaverFreeEvents(
    pointer /* value */,
    XID /* id */
);

static Bool setEventMask (
    ScreenPtr /* pScreen */,
    ClientPtr /* client */,
    unsigned long /* mask */
);

static unsigned long getEventMask (
    ScreenPtr /* pScreen */,
    ClientPtr /* client */
);

/*
 * when a client sets the screen saver attributes, a resource is
 * kept to be freed when the client exits
 */

static RESTYPE AttrType;    /* resource type for attributes */

typedef struct _ScreenSaverAttr {
    ScreenPtr	    screen;
    ClientPtr	    client;
    XID		    resource;
    short	    x, y;
    unsigned short  width, height, borderWidth;
    unsigned char   class;
    unsigned char   depth;
    VisualID	    visual;
    CursorPtr	    pCursor;
    PixmapPtr	    pBackgroundPixmap;
    PixmapPtr	    pBorderPixmap;
    Colormap	    colormap;
    unsigned long   mask;		/* no pixmaps or cursors */
    unsigned long   *values;
} ScreenSaverAttrRec, *ScreenSaverAttrPtr;

static int ScreenSaverFreeAttr (
    pointer /* value */,
    XID /* id */
);

static void FreeAttrs (
    ScreenSaverAttrPtr	/* pAttr */
);

static void FreeScreenAttr (
    ScreenSaverAttrPtr	/* pAttr */
);

static void
SendScreenSaverNotify (
    ScreenPtr /* pScreen */,
    int /* state */,
    Bool /* forced */
);

typedef struct _ScreenSaverScreenPrivate {
    ScreenSaverEventPtr	    events;
    ScreenSaverAttrPtr	    attr;
    Bool		    hasWindow;
    Colormap		    installedMap;
} ScreenSaverScreenPrivateRec, *ScreenSaverScreenPrivatePtr;

static ScreenSaverScreenPrivatePtr
MakeScreenPrivate (
	ScreenPtr /* pScreen */
	);

static DevPrivateKeyRec ScreenPrivateKeyRec;
#define ScreenPrivateKey (&ScreenPrivateKeyRec)

#define GetScreenPrivate(s) ((ScreenSaverScreenPrivatePtr) \
    dixLookupPrivate(&(s)->devPrivates, ScreenPrivateKey))
#define SetScreenPrivate(s,v) \
    dixSetPrivate(&(s)->devPrivates, ScreenPrivateKey, v);
#define SetupScreen(s)	ScreenSaverScreenPrivatePtr pPriv = (s ? GetScreenPrivate(s) : NULL)

#define New(t)	(malloc(sizeof (t)))

static void
CheckScreenPrivate (ScreenPtr pScreen)
{
    SetupScreen (pScreen);

    if (!pPriv)
	return;
    if (!pPriv->attr && !pPriv->events &&
	!pPriv->hasWindow && pPriv->installedMap == None)
    {
	free(pPriv);
	SetScreenPrivate (pScreen, NULL);
	pScreen->screensaver.ExternalScreenSaver = NULL;
    }
}

static ScreenSaverScreenPrivatePtr
MakeScreenPrivate (ScreenPtr pScreen)
{
    SetupScreen (pScreen);

    if (pPriv)
	return pPriv;
    pPriv = New (ScreenSaverScreenPrivateRec);
    if (!pPriv)
	return 0;
    pPriv->events = 0;
    pPriv->attr = 0;
    pPriv->hasWindow = FALSE;
    pPriv->installedMap = None;
    SetScreenPrivate (pScreen, pPriv);
    pScreen->screensaver.ExternalScreenSaver = ScreenSaverHandle;
    return pPriv;
}

static unsigned long
getEventMask (ScreenPtr pScreen, ClientPtr client)
{
    SetupScreen(pScreen);
    ScreenSaverEventPtr	pEv;

    if (!pPriv)
	return 0;
    for (pEv = pPriv->events; pEv; pEv = pEv->next)
	if (pEv->client == client)
	    return pEv->mask;
    return 0;
}

static Bool
setEventMask (ScreenPtr pScreen, ClientPtr client, unsigned long mask)
{
    SetupScreen(pScreen);
    ScreenSaverEventPtr	pEv, *pPrev;

    if (getEventMask (pScreen, client) == mask)
	return TRUE;
    if (!pPriv)
    {
	pPriv = MakeScreenPrivate (pScreen);
	if (!pPriv)
	    return FALSE;
    }
    for (pPrev = &pPriv->events; (pEv = *pPrev) != 0; pPrev = &pEv->next)
	if (pEv->client == client)
	    break;
    if (mask == 0)
    {
	FreeResource (pEv->resource, SaverEventType);
	*pPrev = pEv->next;
	free(pEv);
	CheckScreenPrivate (pScreen);
    }
    else
    {
    	if (!pEv) 
    	{
	    pEv = New (ScreenSaverEventRec);
	    if (!pEv) 
	    {
		CheckScreenPrivate (pScreen);
	    	return FALSE;
	    }
    	    *pPrev = pEv;
    	    pEv->next = NULL;
    	    pEv->client = client;
    	    pEv->screen = pScreen;
    	    pEv->resource = FakeClientID (client->index);
	    if (!AddResource (pEv->resource, SaverEventType, (pointer) pEv))
		return FALSE;
    	}
	pEv->mask = mask;
    }
    return TRUE;
}

static void
FreeAttrs (ScreenSaverAttrPtr pAttr)
{
    PixmapPtr	    pPixmap;
    CursorPtr	    pCursor;

    if ((pPixmap = pAttr->pBackgroundPixmap) != 0)
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
    if ((pPixmap = pAttr->pBorderPixmap) != 0)
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
    if ((pCursor = pAttr->pCursor) != 0)
	FreeCursor (pCursor, (Cursor) 0);
}

static void
FreeScreenAttr (ScreenSaverAttrPtr pAttr)
{
    FreeAttrs (pAttr);
    free(pAttr->values);
    free(pAttr);
}

static int
ScreenSaverFreeEvents (pointer value, XID id)
{
    ScreenSaverEventPtr	pOld = (ScreenSaverEventPtr)value;
    ScreenPtr pScreen = pOld->screen;
    SetupScreen (pScreen);
    ScreenSaverEventPtr	pEv, *pPrev;

    if (!pPriv)
	return TRUE;
    for (pPrev = &pPriv->events; (pEv = *pPrev) != 0; pPrev = &pEv->next)
	if (pEv == pOld)
	    break;
    if (!pEv)
	return TRUE;
    *pPrev = pEv->next;
    free(pEv);
    CheckScreenPrivate (pScreen);
    return TRUE;
}

static int
ScreenSaverFreeAttr (pointer value, XID id)
{
    ScreenSaverAttrPtr	pOldAttr = (ScreenSaverAttrPtr)value;
    ScreenPtr	pScreen = pOldAttr->screen;
    SetupScreen (pScreen);

    if (!pPriv)
	return TRUE;
    if (pPriv->attr != pOldAttr)
	return TRUE;
    FreeScreenAttr (pOldAttr);
    pPriv->attr = NULL;
    if (pPriv->hasWindow)
    {
	dixSaveScreens (serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);
	dixSaveScreens (serverClient, SCREEN_SAVER_FORCER, ScreenSaverActive);
    }
    CheckScreenPrivate (pScreen);
    return TRUE;
}

static int
ScreenSaverFreeSuspend (pointer value, XID id)
{
    ScreenSaverSuspensionPtr data = (ScreenSaverSuspensionPtr) value;
    ScreenSaverSuspensionPtr *prev, this;

    /* Unlink and free the suspension record for the client */
    for (prev = &suspendingClients; (this = *prev); prev = &this->next)
    {
	if (this == data)
	{
	    *prev = this->next;
	    free(this);
	    break;
	}
    }

    /* Reenable the screensaver if this was the last client suspending it. */
    if (screenSaverSuspended && suspendingClients == NULL)
    {
	screenSaverSuspended = FALSE;

	/* The screensaver could be active, since suspending it (by design)
	   doesn't prevent it from being forceably activated */
#ifdef DPMSExtension
	if (screenIsSaved != SCREEN_SAVER_ON && DPMSPowerLevel == DPMSModeOn)
#else
	if (screenIsSaved != SCREEN_SAVER_ON)
#endif
	{
	    UpdateCurrentTimeIf();
	    lastDeviceEventTime = currentTime;
	    SetScreenSaverTimer();
	}
    }

    return Success;
}

static void
SendScreenSaverNotify (ScreenPtr pScreen, int state, Bool forced)
{
    ScreenSaverScreenPrivatePtr	pPriv;
    ScreenSaverEventPtr		pEv;
    unsigned long		mask;
    xScreenSaverNotifyEvent	ev;
    int				kind;

    UpdateCurrentTimeIf ();
    mask = ScreenSaverNotifyMask;
    if (state == ScreenSaverCycle)
	mask = ScreenSaverCycleMask;
    pScreen = screenInfo.screens[pScreen->myNum];
    pPriv = GetScreenPrivate(pScreen);
    if (!pPriv)
	return;
    if (pPriv->attr)
	kind = ScreenSaverExternal;
    else if (ScreenSaverBlanking != DontPreferBlanking)
	kind = ScreenSaverBlanked;
    else
	kind = ScreenSaverInternal;
    for (pEv = pPriv->events; pEv; pEv = pEv->next)
    {
	if (!(pEv->mask & mask))
	    continue;
	ev.type = ScreenSaverNotify + ScreenSaverEventBase;
	ev.state = state;
	ev.timestamp = currentTime.milliseconds;
	ev.root = pScreen->root->drawable.id;
	ev.window = pScreen->screensaver.wid;
	ev.kind = kind;
	ev.forced = forced;
	WriteEventsToClient (pEv->client, 1, (xEvent *) &ev);
    }
}

static void
SScreenSaverNotifyEvent (xScreenSaverNotifyEvent *from,
                         xScreenSaverNotifyEvent *to)
{
    to->type = from->type;
    to->state = from->state;
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->timestamp, to->timestamp);    
    cpswapl (from->root, to->root);    
    cpswapl (from->window, to->window);    
    to->kind = from->kind;
    to->forced = from->forced;
}

static void
UninstallSaverColormap (ScreenPtr pScreen)
{
    SetupScreen(pScreen);
    ColormapPtr			pCmap;
    int rc;

    if (pPriv && pPriv->installedMap != None)
    {
	rc = dixLookupResourceByType((pointer *)&pCmap, pPriv->installedMap,
				     RT_COLORMAP, serverClient,
				     DixUninstallAccess);
	if (rc == Success)
	    (*pCmap->pScreen->UninstallColormap) (pCmap);
	pPriv->installedMap = None;
	CheckScreenPrivate (pScreen);
    }
}

static Bool
CreateSaverWindow (ScreenPtr pScreen)
{
    SetupScreen (pScreen);
    ScreenSaverStuffPtr		pSaver;
    ScreenSaverAttrPtr		pAttr;
    WindowPtr			pWin;
    int				result;
    unsigned long		mask;
    Colormap			*installedMaps;
    int				numInstalled;
    int				i;
    Colormap			wantMap;
    ColormapPtr			pCmap;

    pSaver = &pScreen->screensaver;
    if (pSaver->pWindow)
    {
	pSaver->pWindow = NullWindow;
	FreeResource (pSaver->wid, RT_NONE);
	if (pPriv)
	{
	    UninstallSaverColormap (pScreen);
	    pPriv->hasWindow = FALSE;
	    CheckScreenPrivate (pScreen);
	}
    }

    if (!pPriv || !(pAttr = pPriv->attr))
	return FALSE;

    pPriv->installedMap = None;

    if (GrabInProgress && GrabInProgress != pAttr->client->index)
	return FALSE;

    pWin = CreateWindow (pSaver->wid, pScreen->root,
			 pAttr->x, pAttr->y, pAttr->width, pAttr->height,
			 pAttr->borderWidth, pAttr->class, 
			 pAttr->mask, (XID *)pAttr->values, 
			 pAttr->depth, serverClient, pAttr->visual, 
			 &result);
    if (!pWin)
	return FALSE;

    if (!AddResource(pWin->drawable.id, RT_WINDOW, pWin))
	return FALSE;

    mask = 0;
    if (pAttr->pBackgroundPixmap)
    {
	pWin->backgroundState = BackgroundPixmap;
	pWin->background.pixmap = pAttr->pBackgroundPixmap;
	pAttr->pBackgroundPixmap->refcnt++;
	mask |= CWBackPixmap;
    }
    if (pAttr->pBorderPixmap)
    {
	pWin->borderIsPixel = FALSE;
	pWin->border.pixmap = pAttr->pBorderPixmap;
	pAttr->pBorderPixmap->refcnt++;
	mask |= CWBorderPixmap;
    }
    if (pAttr->pCursor)
    {
	if (!pWin->optional)
	    if (!MakeWindowOptional (pWin))
	    {
    	    	FreeResource (pWin->drawable.id, RT_NONE);
    	    	return FALSE;
	    }
	pAttr->pCursor->refcnt++;
	if (pWin->optional->cursor)
	    FreeCursor (pWin->optional->cursor, (Cursor)0);
	pWin->optional->cursor = pAttr->pCursor;
	pWin->cursorIsNone = FALSE;
	CheckWindowOptionalNeed (pWin);
	mask |= CWCursor;
    }
    if (mask)
	(*pScreen->ChangeWindowAttributes) (pWin, mask);

    if (pAttr->colormap != None)
	(void) ChangeWindowAttributes (pWin, CWColormap, &pAttr->colormap,
				       serverClient);

    MapWindow (pWin, serverClient);

    pPriv->hasWindow = TRUE;
    pSaver->pWindow = pWin;

    /* check and install our own colormap if it isn't installed now */
    wantMap = wColormap (pWin);
    if (wantMap == None)
	return TRUE;
    installedMaps = malloc(pScreen->maxInstalledCmaps * sizeof (Colormap));
    numInstalled = (*pWin->drawable.pScreen->ListInstalledColormaps)
						    (pScreen, installedMaps);
    for (i = 0; i < numInstalled; i++) 
	if (installedMaps[i] == wantMap)
	    break;

    free((char *) installedMaps);

    if (i < numInstalled)
	return TRUE;

    result = dixLookupResourceByType((pointer *)&pCmap, wantMap, RT_COLORMAP,
				     serverClient, DixInstallAccess);
    if (result != Success)
	return TRUE;

    pPriv->installedMap = wantMap;

    (*pCmap->pScreen->InstallColormap) (pCmap);

    return TRUE;
}

static Bool
DestroySaverWindow (ScreenPtr pScreen)
{
    SetupScreen(pScreen);
    ScreenSaverStuffPtr		pSaver;

    if (!pPriv || !pPriv->hasWindow)
	return FALSE;

    pSaver = &pScreen->screensaver;
    if (pSaver->pWindow)
    {
	pSaver->pWindow = NullWindow;
	FreeResource (pSaver->wid, RT_NONE);
    }
    pPriv->hasWindow = FALSE;
    CheckScreenPrivate (pScreen);
    UninstallSaverColormap (pScreen);
    return TRUE;
}

static Bool
ScreenSaverHandle (ScreenPtr pScreen, int xstate, Bool force)
{
    int				state = 0;
    Bool			ret = FALSE;
    ScreenSaverScreenPrivatePtr	pPriv;

    switch (xstate)
    {
    case SCREEN_SAVER_ON:	
	state = ScreenSaverOn;
	ret = CreateSaverWindow (pScreen);
	break;
    case SCREEN_SAVER_OFF:	
	state = ScreenSaverOff;
	ret = DestroySaverWindow (pScreen);
	break;
    case SCREEN_SAVER_CYCLE:	
	state = ScreenSaverCycle;
	pPriv = GetScreenPrivate (pScreen);
	if (pPriv && pPriv->hasWindow)
	    ret = TRUE;
	
    }
#ifdef PANORAMIX
    if(noPanoramiXExtension || !pScreen->myNum)
#endif
       SendScreenSaverNotify (pScreen, state, force);
    return ret;
}

static int
ProcScreenSaverQueryVersion (ClientPtr client)
{
    xScreenSaverQueryVersionReply	rep;
    int		n;

    REQUEST_SIZE_MATCH (xScreenSaverQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SAVER_MAJOR_VERSION;
    rep.minorVersion = SERVER_SAVER_MINOR_VERSION;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    }
    WriteToClient(client, sizeof (xScreenSaverQueryVersionReply), (char *)&rep);
    return Success;
}

static int
ProcScreenSaverQueryInfo (ClientPtr client)
{
    REQUEST(xScreenSaverQueryInfoReq);
    xScreenSaverQueryInfoReply	rep;
    int		n, rc;
    ScreenSaverStuffPtr		pSaver;
    DrawablePtr			pDraw;
    CARD32			lastInput;
    ScreenSaverScreenPrivatePtr	pPriv;

    REQUEST_SIZE_MATCH (xScreenSaverQueryInfoReq);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;
    rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, pDraw->pScreen,
		  DixGetAttrAccess);
    if (rc != Success)
	return rc;

    pSaver = &pDraw->pScreen->screensaver;
    pPriv = GetScreenPrivate (pDraw->pScreen);

    UpdateCurrentTime ();
    lastInput = GetTimeInMillis() - lastDeviceEventTime.milliseconds;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.window = pSaver->wid;
    if (screenIsSaved != SCREEN_SAVER_OFF)
    {
	rep.state = ScreenSaverOn;
	if (ScreenSaverTime)
	    rep.tilOrSince = lastInput - ScreenSaverTime;
	else
	    rep.tilOrSince = 0;
    }
    else
    {
	if (ScreenSaverTime)
	{
	    rep.state = ScreenSaverOff;
	    if (ScreenSaverTime < lastInput)
		rep.tilOrSince = 0;
	    else
		rep.tilOrSince = ScreenSaverTime - lastInput;
	}
	else
	{
	    rep.state = ScreenSaverDisabled;
	    rep.tilOrSince = 0;
	}
    }
    rep.idle = lastInput;
    rep.eventMask = getEventMask (pDraw->pScreen, client);
    if (pPriv && pPriv->attr)
	rep.kind = ScreenSaverExternal;
    else if (ScreenSaverBlanking != DontPreferBlanking)
	rep.kind = ScreenSaverBlanked;
    else
	rep.kind = ScreenSaverInternal;
    if (client->swapped)
    {
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.window, n);
	swapl (&rep.tilOrSince, n);
	swapl (&rep.idle, n);
	swapl (&rep.eventMask, n);
    }
    WriteToClient(client, sizeof (xScreenSaverQueryInfoReply), (char *)&rep);
    return Success;
}

static int
ProcScreenSaverSelectInput (ClientPtr client)
{
    REQUEST(xScreenSaverSelectInputReq);
    DrawablePtr			pDraw;
    int				rc;

    REQUEST_SIZE_MATCH (xScreenSaverSelectInputReq);
    rc = dixLookupDrawable (&pDraw, stuff->drawable, client, 0,
			    DixGetAttrAccess);
    if (rc != Success)
	return rc;

    rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, pDraw->pScreen,
		  DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if (!setEventMask (pDraw->pScreen, client, stuff->eventMask))
	return BadAlloc;
    return Success;
}

static int
ScreenSaverSetAttributes (ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    DrawablePtr			pDraw;
    WindowPtr			pParent;
    ScreenPtr			pScreen;
    ScreenSaverScreenPrivatePtr pPriv = 0;
    ScreenSaverAttrPtr		pAttr = 0;
    int				ret, len, class, bw, depth;
    unsigned long		visual;
    int				idepth, ivisual;
    Bool			fOK;
    DepthPtr			pDepth;
    WindowOptPtr		ancwopt;
    unsigned int		*pVlist;
    unsigned long		*values = 0;
    unsigned long		tmask, imask;
    unsigned long		val;
    Pixmap			pixID;
    PixmapPtr			pPixmap;
    Cursor			cursorID;
    CursorPtr			pCursor;
    Colormap			cmap;
    ColormapPtr			pCmap;

    REQUEST_AT_LEAST_SIZE (xScreenSaverSetAttributesReq);
    ret = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			    DixGetAttrAccess);
    if (ret != Success)
	return ret;
    pScreen = pDraw->pScreen;
    pParent = pScreen->root;

    ret = XaceHook(XACE_SCREENSAVER_ACCESS, client, pScreen, DixSetAttrAccess);
    if (ret != Success)
	return ret;

    len = stuff->length -  bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));
    if (Ones(stuff->mask) != len)
        return BadLength;
    if (!stuff->width || !stuff->height)
    {
	client->errorValue = 0;
        return BadValue;
    }
    switch (class = stuff->c_class) 
    {
    case CopyFromParent:
    case InputOnly:
    case InputOutput:
	break;
    default:
	client->errorValue = class;
	return BadValue;
    }
    bw = stuff->borderWidth;
    depth = stuff->depth;
    visual = stuff->visualID;

    /* copied directly from CreateWindow */

    if (class == CopyFromParent)
	class = pParent->drawable.class;

    if ((class != InputOutput) && (class != InputOnly))
    {
	client->errorValue = class;
	return BadValue;
    }

    if ((class != InputOnly) && (pParent->drawable.class == InputOnly))
        return BadMatch;

    if ((class == InputOnly) && ((bw != 0) || (depth != 0)))
        return BadMatch;

    if ((class == InputOutput) && (depth == 0))
        depth = pParent->drawable.depth;
    ancwopt = pParent->optional;
    if (!ancwopt)
	ancwopt = FindWindowWithOptional(pParent)->optional;
    if (visual == CopyFromParent)
	visual = ancwopt->visual;

    /* Find out if the depth and visual are acceptable for this Screen */
    if ((visual != ancwopt->visual) || (depth != pParent->drawable.depth))
    {
	fOK = FALSE;
	for(idepth = 0; idepth < pScreen->numDepths; idepth++)
	{
	    pDepth = (DepthPtr) &pScreen->allowedDepths[idepth];
	    if ((depth == pDepth->depth) || (depth == 0))
	    {
		for (ivisual = 0; ivisual < pDepth->numVids; ivisual++)
		{
		    if (visual == pDepth->vids[ivisual])
		    {
			fOK = TRUE;
			break;
		    }
		}
	    }
	}
	if (fOK == FALSE)
	    return BadMatch;
    }

    if (((stuff->mask & (CWBorderPixmap | CWBorderPixel)) == 0) &&
	(class != InputOnly) &&
	(depth != pParent->drawable.depth))
    {
        return BadMatch;
    }

    if (((stuff->mask & CWColormap) == 0) &&
	(class != InputOnly) &&
	((visual != ancwopt->visual) || (ancwopt->colormap == None)))
    {
	return BadMatch;
    }

    /* end of errors from CreateWindow */

    pPriv = GetScreenPrivate (pScreen);
    if (pPriv && pPriv->attr)
    {
	if (pPriv->attr->client != client)
	    return BadAccess;
    }
    if (!pPriv)
    {
	pPriv = MakeScreenPrivate (pScreen);
	if (!pPriv)
	    return FALSE;
    }
    pAttr = New (ScreenSaverAttrRec);
    if (!pAttr)
    {
	ret = BadAlloc;
	goto bail;
    }
    /* over allocate for override redirect */
    values = malloc((len + 1) * sizeof (unsigned long));
    if (!values)
    {
	ret = BadAlloc;
	goto bail;
    }
    pAttr->screen = pScreen;
    pAttr->client = client;
    pAttr->x = stuff->x;
    pAttr->y = stuff->y;
    pAttr->width = stuff->width;
    pAttr->height = stuff->height;
    pAttr->borderWidth = stuff->borderWidth;
    pAttr->class = stuff->c_class;
    pAttr->depth = depth;
    pAttr->visual = visual;
    pAttr->colormap = None;
    pAttr->pCursor = NullCursor;
    pAttr->pBackgroundPixmap = NullPixmap;
    pAttr->pBorderPixmap = NullPixmap;
    pAttr->values = values;
    /*
     * go through the mask, checking the values,
     * looking up pixmaps and cursors and hold a reference
     * to them.
     */
    pAttr->mask = tmask = stuff->mask | CWOverrideRedirect;
    pVlist = (unsigned int *) (stuff + 1);
    while (tmask) {
	imask = lowbit (tmask);
	tmask &= ~imask;
	switch (imask)
        {
	case CWBackPixmap:
	    pixID = (Pixmap )*pVlist;
	    if (pixID == None)
	    {
		*values++ = None;
	    }
	    else if (pixID == ParentRelative)
	    {
		if (depth != pParent->drawable.depth)
		{
		    ret = BadMatch;
		    goto PatchUp;
		}
		*values++ = ParentRelative;
	    }
            else
	    {	
		ret = dixLookupResourceByType((pointer *)&pPixmap, pixID, RT_PIXMAP,
					client, DixReadAccess);
		if (ret == Success)
		{
                    if  ((pPixmap->drawable.depth != depth) ||
			 (pPixmap->drawable.pScreen != pScreen))
		    {
                        ret = BadMatch;
			goto PatchUp;
		    }
		    pAttr->pBackgroundPixmap = pPixmap;
		    pPixmap->refcnt++;
		    pAttr->mask &= ~CWBackPixmap;
		}
	        else
		{
		    client->errorValue = pixID;
		    goto PatchUp;
		}
	    }
	    break;
	case CWBackPixel:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWBorderPixmap:
	    pixID = (Pixmap ) *pVlist;
	    if (pixID == CopyFromParent)
	    {
		if (depth != pParent->drawable.depth)
		{
		    ret = BadMatch;
		    goto PatchUp;
		}
		*values++ = CopyFromParent;
	    }
	    else
	    {	
		ret = dixLookupResourceByType((pointer *)&pPixmap, pixID, RT_PIXMAP,
					client, DixReadAccess);
		if (ret == Success)
		{
                    if  ((pPixmap->drawable.depth != depth) ||
			 (pPixmap->drawable.pScreen != pScreen))
		    {
			ret = BadMatch;
			goto PatchUp;
		    }
		    pAttr->pBorderPixmap = pPixmap;
		    pPixmap->refcnt++;
		    pAttr->mask &= ~CWBorderPixmap;
		}
    	        else
		{
		    client->errorValue = pixID;
		    goto PatchUp;
		}
	    }
	    break;
	case CWBorderPixel:
            *values++ = (CARD32) *pVlist;
            break;
	case CWBitGravity:
	    val = (CARD8 )*pVlist;
	    if (val > StaticGravity)
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWWinGravity:
	    val = (CARD8 )*pVlist;
	    if (val > StaticGravity)
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWBackingStore:
	    val = (CARD8 )*pVlist;
	    if ((val != NotUseful) && (val != WhenMapped) && (val != Always))
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWBackingPlanes:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWBackingPixel:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWSaveUnder:
	    val = (BOOL) *pVlist;
	    if ((val != xTrue) && (val != xFalse))
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWEventMask:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWDontPropagate:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWOverrideRedirect:
	    if (!(stuff->mask & CWOverrideRedirect))
		pVlist--;
	    else
	    {
	    	val = (BOOL ) *pVlist;
	    	if ((val != xTrue) && (val != xFalse))
	    	{
		    ret = BadValue;
		    client->errorValue = val;
		    goto PatchUp;
	    	}
	    }
	    *values++ = xTrue;
	    break;
	case CWColormap:
	    cmap = (Colormap) *pVlist;
	    ret = dixLookupResourceByType((pointer *)&pCmap, cmap, RT_COLORMAP,
				    client, DixUseAccess);
	    if (ret != Success)
	    {
		client->errorValue = cmap;
		goto PatchUp;
	    }
	    if (pCmap->pVisual->vid != visual || pCmap->pScreen != pScreen)
	    {
		ret = BadMatch;
		goto PatchUp;
	    }
	    pAttr->colormap = cmap;
	    pAttr->mask &= ~CWColormap;
	    break;
	case CWCursor:
	    cursorID = (Cursor ) *pVlist;
	    if ( cursorID == None)
	    {
		*values++ = None;
	    }
	    else
	    {
		ret = dixLookupResourceByType((pointer *)&pCursor, cursorID,
					RT_CURSOR, client, DixUseAccess);
	    	if (ret != Success)
	    	{
		    client->errorValue = cursorID;
		    goto PatchUp;
	    	}
		pCursor->refcnt++;
		pAttr->pCursor = pCursor;
		pAttr->mask &= ~CWCursor;
	    }
	    break;
     	 default:
	    ret = BadValue;
	    client->errorValue = stuff->mask;
	    goto PatchUp;
	}
	pVlist++;
    }
    if (pPriv->attr)
	FreeScreenAttr (pPriv->attr);
    pPriv->attr = pAttr;
    pAttr->resource = FakeClientID (client->index);
    if (!AddResource (pAttr->resource, AttrType, (pointer) pAttr))
	return BadAlloc;
    return Success;
PatchUp:
    FreeAttrs (pAttr);
bail:
    CheckScreenPrivate (pScreen);
    if (pAttr) free(pAttr->values);
    free(pAttr);
    return ret;
}

static int
ScreenSaverUnsetAttributes (ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    DrawablePtr			pDraw;
    ScreenSaverScreenPrivatePtr	pPriv;
    int				rc;

    REQUEST_SIZE_MATCH (xScreenSaverUnsetAttributesReq);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;
    pPriv = GetScreenPrivate (pDraw->pScreen);
    if (pPriv && pPriv->attr && pPriv->attr->client == client)
    {
	FreeResource (pPriv->attr->resource, AttrType);
    	FreeScreenAttr (pPriv->attr);
	pPriv->attr = NULL;
	CheckScreenPrivate (pDraw->pScreen);
    }
    return Success;
}

static int
ProcScreenSaverSetAttributes (ClientPtr client)
{
#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
       REQUEST(xScreenSaverSetAttributesReq);
       PanoramiXRes *draw;
       PanoramiXRes *backPix = NULL;
       PanoramiXRes *bordPix = NULL;
       PanoramiXRes *cmap    = NULL;
       int i, status, len;
       int  pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
       XID orig_visual, tmp;

       REQUEST_AT_LEAST_SIZE (xScreenSaverSetAttributesReq);

       status = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
					 XRC_DRAWABLE, client, DixWriteAccess);
       if (status != Success)
           return (status == BadValue) ? BadDrawable : status;

       len = stuff->length -  bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));
       if (Ones(stuff->mask) != len)
           return BadLength;

       if((Mask)stuff->mask & CWBackPixmap) {
          pback_offset = Ones((Mask)stuff->mask & (CWBackPixmap - 1));
          tmp = *((CARD32 *) &stuff[1] + pback_offset);
          if ((tmp != None) && (tmp != ParentRelative)) {
	      status = dixLookupResourceByType((pointer *)&backPix, tmp,
					       XRT_PIXMAP, client,
					       DixReadAccess);
	      if (status != Success)
		  return status;
          }
       }

       if ((Mask)stuff->mask & CWBorderPixmap) {
          pbord_offset = Ones((Mask)stuff->mask & (CWBorderPixmap - 1));
          tmp = *((CARD32 *) &stuff[1] + pbord_offset);
          if (tmp != CopyFromParent) {
	      status = dixLookupResourceByType((pointer *)&bordPix, tmp,
					       XRT_PIXMAP, client,
					       DixReadAccess);
	      if (status != Success)
		  return status;
          }
       }

       if ((Mask)stuff->mask & CWColormap) {
           cmap_offset = Ones((Mask)stuff->mask & (CWColormap - 1));
           tmp = *((CARD32 *) &stuff[1] + cmap_offset);
           if ((tmp != CopyFromParent) && (tmp != None)) {
	       status = dixLookupResourceByType((pointer *)&cmap, tmp,
						XRT_COLORMAP, client,
						DixReadAccess);
	       if (status != Success)
		   return status;
           }
       }

       orig_visual = stuff->visualID;

       FOR_NSCREENS_BACKWARD(i) {
          stuff->drawable = draw->info[i].id;  
          if (backPix)
             *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[i].id;
          if (bordPix)
             *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[i].id;
          if (cmap)
             *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[i].id;

          if (orig_visual != CopyFromParent) 
            stuff->visualID = PanoramiXTranslateVisualID(i, orig_visual);

          status = ScreenSaverSetAttributes(client);
       }

       return status;
    }
#endif

    return ScreenSaverSetAttributes(client);
}

static int
ProcScreenSaverUnsetAttributes (ClientPtr client)
{
#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
       REQUEST(xScreenSaverUnsetAttributesReq);
       PanoramiXRes *draw;
       int rc, i;

       rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				     XRC_DRAWABLE, client, DixWriteAccess);
       if (rc != Success)
           return (rc == BadValue) ? BadDrawable : rc;

       for(i = PanoramiXNumScreens - 1; i > 0; i--) {
            stuff->drawable = draw->info[i].id;
            ScreenSaverUnsetAttributes(client);
       }

       stuff->drawable = draw->info[0].id;
    }
#endif

    return ScreenSaverUnsetAttributes(client);
}

static int
ProcScreenSaverSuspend (ClientPtr client)
{
    ScreenSaverSuspensionPtr *prev, this;

    REQUEST(xScreenSaverSuspendReq);
    REQUEST_SIZE_MATCH(xScreenSaverSuspendReq);

    /* Check if this client is suspending the screensaver */
    for (prev = &suspendingClients; (this = *prev); prev = &this->next)
	if (this->pClient == client)
	    break;

    if (this)
    {
	if (stuff->suspend == TRUE)
	   this->count++;
	else if (--this->count == 0)
	   FreeResource (this->clientResource, RT_NONE);

	return Success;
    }

    /* If we get to this point, this client isn't suspending the screensaver */
    if (stuff->suspend == FALSE)
	return Success;

    /*
     * Allocate a suspension record for the client, and stop the screensaver
     * if it isn't already suspended by another client. We attach a resource ID
     * to the record, so the screensaver will be reenabled and the record freed
     * if the client disconnects without reenabling it first.
     */
    this = malloc(sizeof (ScreenSaverSuspensionRec));

    if (!this)
	return BadAlloc;

    this->next           = NULL;
    this->pClient        = client;
    this->count          = 1;
    this->clientResource = FakeClientID (client->index);

    if (!AddResource (this->clientResource, SuspendType, (pointer) this))
    {
	free(this);
	return BadAlloc;
    }

    *prev = this;
    if (!screenSaverSuspended)
    {
	screenSaverSuspended = TRUE;
	FreeScreenSaverTimer();
    }

    return Success;
}

static int (*NormalVector[]) (ClientPtr /* client */) = {
    ProcScreenSaverQueryVersion,
    ProcScreenSaverQueryInfo,
    ProcScreenSaverSelectInput,
    ProcScreenSaverSetAttributes,
    ProcScreenSaverUnsetAttributes,
    ProcScreenSaverSuspend,
};

#define NUM_REQUESTS	((sizeof NormalVector) / (sizeof NormalVector[0]))

static int
ProcScreenSaverDispatch (ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < NUM_REQUESTS)
	return (*NormalVector[stuff->data])(client);
    return BadRequest;
}

static int
SProcScreenSaverQueryVersion (ClientPtr client)
{
    REQUEST(xScreenSaverQueryVersionReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverQueryVersionReq);
    return ProcScreenSaverQueryVersion (client);
}

static int
SProcScreenSaverQueryInfo (ClientPtr client)
{
    REQUEST(xScreenSaverQueryInfoReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverQueryInfoReq);
    swapl (&stuff->drawable, n);
    return ProcScreenSaverQueryInfo (client);
}

static int
SProcScreenSaverSelectInput (ClientPtr client)
{
    REQUEST(xScreenSaverSelectInputReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverSelectInputReq);
    swapl (&stuff->drawable, n);
    swapl (&stuff->eventMask, n);
    return ProcScreenSaverSelectInput (client);
}

static int
SProcScreenSaverSetAttributes (ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xScreenSaverSetAttributesReq);
    swapl (&stuff->drawable, n);
    swaps (&stuff->x, n);
    swaps (&stuff->y, n);
    swaps (&stuff->width, n);
    swaps (&stuff->height, n);
    swaps (&stuff->borderWidth, n);
    swapl (&stuff->visualID, n);
    swapl (&stuff->mask, n);
    SwapRestL(stuff);
    return ProcScreenSaverSetAttributes (client);
}

static int
SProcScreenSaverUnsetAttributes (ClientPtr client)
{
    REQUEST(xScreenSaverUnsetAttributesReq);
    int	    n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);
    swapl (&stuff->drawable, n);
    return ProcScreenSaverUnsetAttributes (client);
}

static int
SProcScreenSaverSuspend (ClientPtr client)
{
    int n;
    REQUEST(xScreenSaverSuspendReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xScreenSaverSuspendReq);
    swapl(&stuff->suspend, n);
    return ProcScreenSaverSuspend (client);
}

static int (*SwappedVector[]) (ClientPtr /* client */) = {
    SProcScreenSaverQueryVersion,
    SProcScreenSaverQueryInfo,
    SProcScreenSaverSelectInput,
    SProcScreenSaverSetAttributes,
    SProcScreenSaverUnsetAttributes,
    SProcScreenSaverSuspend,
};

static int
SProcScreenSaverDispatch (ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < NUM_REQUESTS)
	return (*SwappedVector[stuff->data])(client);
    return BadRequest;
}

void
ScreenSaverExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;
    int		    i;
    ScreenPtr	    pScreen;

    if (!dixRegisterPrivateKey(&ScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return;

    AttrType = CreateNewResourceType(ScreenSaverFreeAttr, "SaverAttr");
    SaverEventType = CreateNewResourceType(ScreenSaverFreeEvents,
					   "SaverEvent");
    SuspendType = CreateNewResourceType(ScreenSaverFreeSuspend,
					"SaverSuspend");

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	pScreen = screenInfo.screens[i];
	SetScreenPrivate (pScreen, NULL);
    }
    if (AttrType && SaverEventType && SuspendType &&
	(extEntry = AddExtension(ScreenSaverName, ScreenSaverNumberEvents, 0,
				 ProcScreenSaverDispatch, SProcScreenSaverDispatch,
				 NULL, StandardMinorOpcode)))
    {
	ScreenSaverEventBase = extEntry->eventBase;
	EventSwapVector[ScreenSaverEventBase] = (EventSwapPtr) SScreenSaverNotifyEvent;
    }
}
/*

Copyright 1996, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "inputstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "colormapst.h"
#include "privates.h"
#include "registry.h"
#include "xacestr.h"
#include "securitysrv.h"
#include <X11/extensions/securproto.h>
#include "modinit.h"
#include "protocol-versions.h"

/* Extension stuff */
static int SecurityErrorBase;  /* first Security error number */
static int SecurityEventBase;  /* first Security event number */

RESTYPE SecurityAuthorizationResType; /* resource type for authorizations */
static RESTYPE RTEventClient;

static CallbackListPtr SecurityValidateGroupCallback = NULL;

/* Private state record */
static DevPrivateKeyRec stateKeyRec;
#define stateKey (&stateKeyRec)

/* This is what we store as client security state */
typedef struct {
    int haveState;
    unsigned int trustLevel;
    XID authId;
} SecurityStateRec;

/* Extensions that untrusted clients shouldn't have access to */
static char *SecurityTrustedExtensions[] = {
    "XC-MISC",
    "BIG-REQUESTS",
    "XpExtension",
    NULL
};

/*
 * Access modes that untrusted clients are allowed on trusted objects.
 */
static const Mask SecurityResourceMask =
    DixGetAttrAccess | DixReceiveAccess | DixListPropAccess |
    DixGetPropAccess | DixListAccess;
static const Mask SecurityWindowExtraMask = DixRemoveAccess;
static const Mask SecurityRootWindowExtraMask =
    DixReceiveAccess | DixSendAccess | DixAddAccess | DixRemoveAccess;
static const Mask SecurityDeviceMask =
    DixGetAttrAccess | DixReceiveAccess | DixGetFocusAccess |
    DixGrabAccess | DixSetAttrAccess | DixUseAccess;
static const Mask SecurityServerMask = DixGetAttrAccess | DixGrabAccess;
static const Mask SecurityClientMask = DixGetAttrAccess;


/* SecurityAudit
 *
 * Arguments:
 *	format is the formatting string to be used to interpret the
 *	  remaining arguments.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Writes the message to the log file if security logging is on.
 */

static void
SecurityAudit(char *format, ...)
{
    va_list args;

    if (auditTrailLevel < SECURITY_AUDIT_LEVEL)
	return;
    va_start(args, format);
    VAuditF(format, args);
    va_end(args);
} /* SecurityAudit */

/*
 * Performs a Security permission check.
 */
static int
SecurityDoCheck(SecurityStateRec *subj, SecurityStateRec *obj,
		Mask requested, Mask allowed)
{
    if (!subj->haveState || !obj->haveState)
	return Success;
    if (subj->trustLevel == XSecurityClientTrusted)
	return Success;
    if (obj->trustLevel != XSecurityClientTrusted)
	return Success;
    if ((requested | allowed) == allowed)
	return Success;

    return BadAccess;
}

/*
 * Labels initial server objects.
 */
static void
SecurityLabelInitial(void)
{
    SecurityStateRec *state;

    /* Do the serverClient */
    state = dixLookupPrivate(&serverClient->devPrivates, stateKey);
    state->trustLevel = XSecurityClientTrusted;
    state->haveState = TRUE;
}

/*
 * Looks up a request name
 */
static _X_INLINE const char *
SecurityLookupRequestName(ClientPtr client)
{
    int major = ((xReq *)client->requestBuffer)->reqType;
    int minor = MinorOpcodeOfRequest(client);
    return LookupRequestName(major, minor);
}


/* SecurityDeleteAuthorization
 *
 * Arguments:
 *	value is the authorization to delete.
 *	id is its resource ID.
 *
 * Returns: Success.
 *
 * Side Effects:
 *	Frees everything associated with the authorization.
 */

static int
SecurityDeleteAuthorization(
    pointer value,
    XID id)
{
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)value;
    unsigned short name_len, data_len;
    char *name, *data;
    int status;
    int i;
    OtherClientsPtr pEventClient;

    /* Remove the auth using the os layer auth manager */

    status = AuthorizationFromID(pAuth->id, &name_len, &name,
				 &data_len, &data);
    assert(status);
    status = RemoveAuthorization(name_len, name, data_len, data);
    assert(status);
    (void)status;

    /* free the auth timer if there is one */

    if (pAuth->timer) TimerFree(pAuth->timer);

    /* send revoke events */

    while ((pEventClient = pAuth->eventClients))
    {
	/* send revocation event event */
	xSecurityAuthorizationRevokedEvent are;
	are.type = SecurityEventBase + XSecurityAuthorizationRevoked;
	are.authId = pAuth->id;
	WriteEventsToClient(rClient(pEventClient), 1, (xEvent *)&are);
	FreeResource(pEventClient->resource, RT_NONE);
    }

    /* kill all clients using this auth */

    for (i = 1; i<currentMaxClients; i++)
	if (clients[i]) {
	    SecurityStateRec *state;
	    state = dixLookupPrivate(&clients[i]->devPrivates, stateKey);
	    if (state->haveState && state->authId == pAuth->id)
		CloseDownClient(clients[i]);
	}

    SecurityAudit("revoked authorization ID %d\n", pAuth->id);
    free(pAuth);
    return Success;

} /* SecurityDeleteAuthorization */


/* resource delete function for RTEventClient */
static int
SecurityDeleteAuthorizationEventClient(
    pointer value,
    XID id)
{
    OtherClientsPtr pEventClient, prev = NULL;
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)value;

    for (pEventClient = pAuth->eventClients;
	 pEventClient;
	 pEventClient = pEventClient->next)
    {
	if (pEventClient->resource == id)
	{
	    if (prev)
		prev->next = pEventClient->next;
	    else
		pAuth->eventClients = pEventClient->next;
	    free(pEventClient);
	    return Success;
	}
	prev = pEventClient;
    }
    /*NOTREACHED*/
    return -1; /* make compiler happy */
} /* SecurityDeleteAuthorizationEventClient */


/* SecurityComputeAuthorizationTimeout
 *
 * Arguments:
 *	pAuth is the authorization for which we are computing the timeout
 *	seconds is the number of seconds we want to wait
 *
 * Returns:
 *	the number of milliseconds that the auth timer should be set to
 *
 * Side Effects:
 *	Sets pAuth->secondsRemaining to any "overflow" amount of time
 *	that didn't fit in 32 bits worth of milliseconds
 */

static CARD32
SecurityComputeAuthorizationTimeout(
    SecurityAuthorizationPtr pAuth,
    unsigned int seconds)
{
    /* maxSecs is the number of full seconds that can be expressed in
     * 32 bits worth of milliseconds
     */
    CARD32 maxSecs = (CARD32)(~0) / (CARD32)MILLI_PER_SECOND;

    if (seconds > maxSecs)
    { /* only come here if we want to wait more than 49 days */
	pAuth->secondsRemaining = seconds - maxSecs;
	return maxSecs * MILLI_PER_SECOND;
    }
    else
    { /* by far the common case */
	pAuth->secondsRemaining = 0;
	return seconds * MILLI_PER_SECOND;
    }
} /* SecurityStartAuthorizationTimer */

/* SecurityAuthorizationExpired
 *
 * This function is passed as an argument to TimerSet and gets called from
 * the timer manager in the os layer when its time is up.
 *
 * Arguments:
 *	timer is the timer for this authorization.
 *	time is the current time.
 *	pval is the authorization whose time is up.
 *
 * Returns:
 *	A new time delay in milliseconds if the timer should wait some
 *	more, else zero.
 *
 * Side Effects:
 *	Frees the authorization resource if the timeout period is really
 *	over, otherwise recomputes pAuth->secondsRemaining.
 */

static CARD32
SecurityAuthorizationExpired(
    OsTimerPtr timer,
    CARD32 time,
    pointer pval)
{
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)pval;

    assert(pAuth->timer == timer);

    if (pAuth->secondsRemaining)
    {
	return SecurityComputeAuthorizationTimeout(pAuth,
						   pAuth->secondsRemaining);
    }
    else
    {
	FreeResource(pAuth->id, RT_NONE);
	return 0;
    }
} /* SecurityAuthorizationExpired */

/* SecurityStartAuthorizationTimer
 *
 * Arguments:
 *	pAuth is the authorization whose timer should be started.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	A timer is started, set to expire after the timeout period for
 *	this authorization.  When it expires, the function
 *	SecurityAuthorizationExpired will be called.
 */

static void
SecurityStartAuthorizationTimer(
    SecurityAuthorizationPtr pAuth)
{
    pAuth->timer = TimerSet(pAuth->timer, 0,
	SecurityComputeAuthorizationTimeout(pAuth, pAuth->timeout),
			    SecurityAuthorizationExpired, pAuth);
} /* SecurityStartAuthorizationTimer */


/* Proc functions all take a client argument, execute the request in
 * client->requestBuffer, and return a protocol error status.
 */

static int
ProcSecurityQueryVersion(
    ClientPtr client)
{
    /* REQUEST(xSecurityQueryVersionReq); */
    xSecurityQueryVersionReply 	rep;

    REQUEST_SIZE_MATCH(xSecurityQueryVersionReq);
    rep.type        	= X_Reply;
    rep.sequenceNumber 	= client->sequence;
    rep.length         	= 0;
    rep.majorVersion  	= SERVER_SECURITY_MAJOR_VERSION;
    rep.minorVersion  	= SERVER_SECURITY_MINOR_VERSION;
    if(client->swapped)
    {
	char n;
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    (void)WriteToClient(client, SIZEOF(xSecurityQueryVersionReply),
			(char *)&rep);
    return Success;
} /* ProcSecurityQueryVersion */


static int
SecurityEventSelectForAuthorization(
    SecurityAuthorizationPtr pAuth,
    ClientPtr client,
    Mask mask)
{
    OtherClients *pEventClient;

    for (pEventClient = pAuth->eventClients;
	 pEventClient;
	 pEventClient = pEventClient->next)
    {
	if (SameClient(pEventClient, client))
	{
	    if (mask == 0)
		FreeResource(pEventClient->resource, RT_NONE);
	    else
		pEventClient->mask = mask;
	    return Success;
	}
    }
    
    pEventClient = malloc(sizeof(OtherClients));
    if (!pEventClient)
	return BadAlloc;
    pEventClient->mask = mask;
    pEventClient->resource = FakeClientID(client->index);
    pEventClient->next = pAuth->eventClients;
    if (!AddResource(pEventClient->resource, RTEventClient,
		     (pointer)pAuth))
    {
	free(pEventClient);
	return BadAlloc;
    }
    pAuth->eventClients = pEventClient;

    return Success;
} /* SecurityEventSelectForAuthorization */


static int
ProcSecurityGenerateAuthorization(
    ClientPtr client)
{
    REQUEST(xSecurityGenerateAuthorizationReq);
    int len;			/* request length in CARD32s*/
    Bool removeAuth = FALSE;	/* if bailout, call RemoveAuthorization? */
    SecurityAuthorizationPtr pAuth = NULL;  /* auth we are creating */
    int err;			/* error to return from this function */
    XID authId;			/* authorization ID assigned by os layer */
    xSecurityGenerateAuthorizationReply rep; /* reply struct */
    unsigned int trustLevel;    /* trust level of new auth */
    XID group;			/* group of new auth */
    CARD32 timeout;		/* timeout of new auth */
    CARD32 *values;		/* list of supplied attributes */
    char *protoname;		/* auth proto name sent in request */
    char *protodata;		/* auth proto data sent in request */
    unsigned int authdata_len;  /* # bytes of generated auth data */
    char *pAuthdata;		/* generated auth data */
    Mask eventMask;		/* what events on this auth does client want */

    /* check request length */

    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);
    len = bytes_to_int32(SIZEOF(xSecurityGenerateAuthorizationReq));
    len += bytes_to_int32(stuff->nbytesAuthProto);
    len += bytes_to_int32(stuff->nbytesAuthData);
    values = ((CARD32 *)stuff) + len;
    len += Ones(stuff->valueMask);
    if (client->req_len != len)
	return BadLength;

    /* check valuemask */
    if (stuff->valueMask & ~XSecurityAllAuthorizationAttributes)
    {
	client->errorValue = stuff->valueMask;
	return BadValue;
    }

    /* check timeout */
    timeout = 60;
    if (stuff->valueMask & XSecurityTimeout)
    {
	timeout = *values++;
    }

    /* check trustLevel */
    trustLevel = XSecurityClientUntrusted;
    if (stuff->valueMask & XSecurityTrustLevel)
    {
	trustLevel = *values++;
	if (trustLevel != XSecurityClientTrusted &&
	    trustLevel != XSecurityClientUntrusted)
	{
	    client->errorValue = trustLevel;
	    return BadValue;
	}
    }

    /* check group */
    group = None;
    if (stuff->valueMask & XSecurityGroup)
    {
	group = *values++;
	if (SecurityValidateGroupCallback)
	{
	    SecurityValidateGroupInfoRec vgi;
	    vgi.group = group;
	    vgi.valid = FALSE;
	    CallCallbacks(&SecurityValidateGroupCallback, (pointer)&vgi);

	    /* if nobody said they recognized it, it's an error */

	    if (!vgi.valid)
	    {
		client->errorValue = group;
		return BadValue;
	    }
	}
    }

    /* check event mask */
    eventMask = 0;
    if (stuff->valueMask & XSecurityEventMask)
    {
	eventMask = *values++;
	if (eventMask & ~XSecurityAllEventMasks)
	{
	    client->errorValue = eventMask;
	    return BadValue;
	}
    }

    protoname = (char *)&stuff[1];
    protodata = protoname + bytes_to_int32(stuff->nbytesAuthProto);

    /* call os layer to generate the authorization */

    authId = GenerateAuthorization(stuff->nbytesAuthProto, protoname,
				   stuff->nbytesAuthData,  protodata,
				   &authdata_len, &pAuthdata);
    if ((XID) ~0L == authId)
    {
	err = SecurityErrorBase + XSecurityBadAuthorizationProtocol;
	goto bailout;
    }

    /* now that we've added the auth, remember to remove it if we have to
     * abort the request for some reason (like allocation failure)
     */
    removeAuth = TRUE;

    /* associate additional information with this auth ID */

    pAuth = malloc(sizeof(SecurityAuthorizationRec));
    if (!pAuth)
    {
	err = BadAlloc;
	goto bailout;
    }

    /* fill in the auth fields */

    pAuth->id = authId;
    pAuth->timeout = timeout;
    pAuth->group = group;
    pAuth->trustLevel = trustLevel;
    pAuth->refcnt = 0;	/* the auth was just created; nobody's using it yet */
    pAuth->secondsRemaining = 0;
    pAuth->timer = NULL;
    pAuth->eventClients = NULL;

    /* handle event selection */
    if (eventMask)
    {
	err = SecurityEventSelectForAuthorization(pAuth, client, eventMask);
	if (err != Success)
	    goto bailout;
    }

    if (!AddResource(authId, SecurityAuthorizationResType, pAuth))
    {
	err = BadAlloc;
	goto bailout;
    }

    /* start the timer ticking */

    if (pAuth->timeout != 0)
	SecurityStartAuthorizationTimer(pAuth);

    /* tell client the auth id and data */

    rep.type = X_Reply;
    rep.length = bytes_to_int32(authdata_len);
    rep.sequenceNumber = client->sequence;
    rep.authId = authId;
    rep.dataLength = authdata_len;

    if (client->swapped)
    {
	char n;
    	swapl(&rep.length, n);
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.authId, n);
    	swaps(&rep.dataLength, n);
    }

    WriteToClient(client, SIZEOF(xSecurityGenerateAuthorizationReply),
		  (char *)&rep);
    WriteToClient(client, authdata_len, pAuthdata);

    SecurityAudit("client %d generated authorization %d trust %d timeout %d group %d events %d\n",
		  client->index, pAuth->id, pAuth->trustLevel, pAuth->timeout,
		  pAuth->group, eventMask);

    /* the request succeeded; don't call RemoveAuthorization or free pAuth */
    return Success;

bailout:
    if (removeAuth)
	RemoveAuthorization(stuff->nbytesAuthProto, protoname,
			    authdata_len, pAuthdata);
    free(pAuth);
    return err;

} /* ProcSecurityGenerateAuthorization */

static int
ProcSecurityRevokeAuthorization(
    ClientPtr client)
{
    REQUEST(xSecurityRevokeAuthorizationReq);
    SecurityAuthorizationPtr pAuth;
    int rc;

    REQUEST_SIZE_MATCH(xSecurityRevokeAuthorizationReq);

    rc = dixLookupResourceByType((pointer *)&pAuth, stuff->authId,
				 SecurityAuthorizationResType, client,
				 DixDestroyAccess);
    if (rc != Success)
	return rc;

    FreeResource(stuff->authId, RT_NONE);
    return Success;
} /* ProcSecurityRevokeAuthorization */


static int
ProcSecurityDispatch(
    ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
	case X_SecurityQueryVersion:
	    return ProcSecurityQueryVersion(client);
	case X_SecurityGenerateAuthorization:
	    return ProcSecurityGenerateAuthorization(client);
	case X_SecurityRevokeAuthorization:
	    return ProcSecurityRevokeAuthorization(client);
	default:
	    return BadRequest;
    }
} /* ProcSecurityDispatch */

static int
SProcSecurityQueryVersion(
    ClientPtr client)
{
    REQUEST(xSecurityQueryVersionReq);
    char	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xSecurityQueryVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion,n);
    return ProcSecurityQueryVersion(client);
} /* SProcSecurityQueryVersion */


static int
SProcSecurityGenerateAuthorization(
    ClientPtr client)
{
    REQUEST(xSecurityGenerateAuthorizationReq);
    char	n;
    CARD32 *values;
    unsigned long nvalues;
    int values_offset;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);
    swaps(&stuff->nbytesAuthProto, n);
    swaps(&stuff->nbytesAuthData, n);
    swapl(&stuff->valueMask, n);
    values_offset = bytes_to_int32(stuff->nbytesAuthProto) +
		    bytes_to_int32(stuff->nbytesAuthData);
    if (values_offset > 
	stuff->length - bytes_to_int32(sz_xSecurityGenerateAuthorizationReq))
	return BadLength;
    values = (CARD32 *)(&stuff[1]) + values_offset;
    nvalues = (((CARD32 *)stuff) + stuff->length) - values;
    SwapLongs(values, nvalues);
    return ProcSecurityGenerateAuthorization(client);
} /* SProcSecurityGenerateAuthorization */


static int
SProcSecurityRevokeAuthorization(
    ClientPtr client)
{
    REQUEST(xSecurityRevokeAuthorizationReq);
    char	n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xSecurityRevokeAuthorizationReq);
    swapl(&stuff->authId, n);
    return ProcSecurityRevokeAuthorization(client);
} /* SProcSecurityRevokeAuthorization */


static int
SProcSecurityDispatch(
    ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
	case X_SecurityQueryVersion:
	    return SProcSecurityQueryVersion(client);
	case X_SecurityGenerateAuthorization:
	    return SProcSecurityGenerateAuthorization(client);
	case X_SecurityRevokeAuthorization:
	    return SProcSecurityRevokeAuthorization(client);
	default:
	    return BadRequest;
    }
} /* SProcSecurityDispatch */

static void 
SwapSecurityAuthorizationRevokedEvent(
    xSecurityAuthorizationRevokedEvent *from,
    xSecurityAuthorizationRevokedEvent *to)
{
    to->type = from->type;
    to->detail = from->detail;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->authId, to->authId);
}

/* SecurityCheckDeviceAccess
 *
 * Arguments:
 *	client is the client attempting to access a device.
 *	dev is the device being accessed.
 *	fromRequest is TRUE if the device access is a direct result of
 *	  the client executing some request and FALSE if it is a
 *	  result of the server trying to send an event (e.g. KeymapNotify)
 *	  to the client.
 * Returns:
 *	TRUE if the device access should be allowed, else FALSE.
 *
 * Side Effects:
 *	An audit message is generated if access is denied.
 */

static void
SecurityDevice(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceDeviceAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityDeviceMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, stateKey);

    if (rec->dev != inputInfo.keyboard)
	/* this extension only supports the core keyboard */
	allowed = requested;

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
	SecurityAudit("Security denied client %d keyboard access on request "
		      "%s\n", rec->client->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
    }
}

/* SecurityResource
 *
 * This function gets plugged into client->CheckAccess and is called from
 * SecurityLookupIDByType/Class to determine if the client can access the
 * resource.
 *
 * Arguments:
 *	client is the client doing the resource access.
 *	id is the resource id.
 *	rtype is its type or class.
 *	access_mode represents the intended use of the resource; see
 *	  resource.h.
 *	res is a pointer to the resource structure for this resource.
 *
 * Returns:
 *	If access is granted, the value of rval that was passed in, else FALSE.
 *
 * Side Effects:
 *	Disallowed resource accesses are audited.
 */

static void
SecurityResource(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceResourceAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    int cid = CLIENT_ID(rec->id);
    Mask requested = rec->access_mode;
    Mask allowed = SecurityResourceMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);

    /* disable background None for untrusted windows */
    if ((requested & DixCreateAccess) && (rec->rtype == RT_WINDOW))
	if (subj->haveState && subj->trustLevel != XSecurityClientTrusted)
	    ((WindowPtr)rec->res)->forcedBG = TRUE;

    /* additional permissions for specific resource types */
    if (rec->rtype == RT_WINDOW)
	allowed |= SecurityWindowExtraMask;

    /* special checks for server-owned resources */
    if (cid == 0) {
	if (rec->rtype & RC_DRAWABLE)
	    /* additional operations allowed on root windows */
	    allowed |= SecurityRootWindowExtraMask;

	else if (rec->rtype == RT_COLORMAP)
	    /* allow access to default colormaps */
	    allowed = requested;

	else
	    /* allow read access to other server-owned resources */
	    allowed |= DixReadAccess;
    }

    if (clients[cid] != NULL) {
	obj = dixLookupPrivate(&clients[cid]->devPrivates, stateKey);
	if (SecurityDoCheck(subj, obj, requested, allowed) == Success)
	    return;
    }

    SecurityAudit("Security: denied client %d access %x to resource 0x%x "
		  "of client %d on request %s\n", rec->client->index,
		  requested, rec->id, cid,
		  SecurityLookupRequestName(rec->client));
    rec->status = BadAccess; /* deny access */
}


static void
SecurityExtension(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceExtAccessRec *rec = calldata;
    SecurityStateRec *subj;
    int i = 0;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);

    if (subj->haveState && subj->trustLevel == XSecurityClientTrusted)
	return;

    while (SecurityTrustedExtensions[i])
	if (!strcmp(SecurityTrustedExtensions[i++], rec->ext->name))
	    return;

    SecurityAudit("Security: denied client %d access to extension "
		  "%s on request %s\n",
		  rec->client->index, rec->ext->name,
		  SecurityLookupRequestName(rec->client));
    rec->status = BadAccess;
}

static void
SecurityServer(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceServerAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityServerMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, stateKey);
 
    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
	SecurityAudit("Security: denied client %d access to server "
		      "configuration request %s\n", rec->client->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
    }
}

static void
SecurityClient(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceClientAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityClientMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&rec->target->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
	SecurityAudit("Security: denied client %d access to client %d on "
		      "request %s\n", rec->client->index, rec->target->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
    }
}

static void
SecurityProperty(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{    
    XacePropertyAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    ATOM name = (*rec->ppProp)->propertyName;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityResourceMask | DixReadAccess;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
	SecurityAudit("Security: denied client %d access to property %s "
		      "(atom 0x%x) window 0x%x of client %d on request %s\n",
		      rec->client->index, NameForAtom(name), name,
		      rec->pWin->drawable.id, wClient(rec->pWin)->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
    }
}

static void
SecuritySend(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceSendAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;

    if (rec->client) {
	int i;

	subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
	obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

	if (SecurityDoCheck(subj, obj, DixSendAccess, 0) == Success)
	    return;

	for (i = 0; i < rec->count; i++)
	    if (rec->events[i].u.u.type != UnmapNotify &&
		rec->events[i].u.u.type != ConfigureRequest &&
		rec->events[i].u.u.type != ClientMessage) {

		SecurityAudit("Security: denied client %d from sending event "
			      "of type %s to window 0x%x of client %d\n",
			      rec->client->index,
			      LookupEventName(rec->events[i].u.u.type),
			      rec->pWin->drawable.id,
			      wClient(rec->pWin)->index);
		rec->status = BadAccess;
		return;
	    }
    }
}

static void
SecurityReceive(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceReceiveAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, DixReceiveAccess, 0) == Success)
	return;

    SecurityAudit("Security: denied client %d from receiving an event "
		  "sent to window 0x%x of client %d\n",
		  rec->client->index, rec->pWin->drawable.id,
		  wClient(rec->pWin)->index);
    rec->status = BadAccess;
}

/* SecurityClientStateCallback
 *
 * Arguments:
 *	pcbl is &ClientStateCallback.
 *	nullata is NULL.
 *	calldata is a pointer to a NewClientInfoRec (include/dixstruct.h)
 *	which contains information about client state changes.
 *
 * Returns: nothing.
 *
 * Side Effects:
 * 
 * If a new client is connecting, its authorization ID is copied to
 * client->authID.  If this is a generated authorization, its reference
 * count is bumped, its timer is cancelled if it was running, and its
 * trustlevel is copied to TRUSTLEVEL(client).
 * 
 * If a client is disconnecting and the client was using a generated
 * authorization, the authorization's reference count is decremented, and
 * if it is now zero, the timer for this authorization is started.
 */

static void
SecurityClientState(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    NewClientInfoRec *pci = calldata;
    SecurityStateRec *state;
    SecurityAuthorizationPtr pAuth;
    int rc;

    state = dixLookupPrivate(&pci->client->devPrivates, stateKey);

    switch (pci->client->clientState) {
    case ClientStateInitial:
	state->trustLevel = XSecurityClientTrusted;
	state->authId = None;
	state->haveState = TRUE;
	break;

    case ClientStateRunning:
	state->authId = AuthorizationIDOfClient(pci->client);
	rc = dixLookupResourceByType((pointer *)&pAuth, state->authId,
			       SecurityAuthorizationResType, serverClient,
			       DixGetAttrAccess);
	if (rc == Success) {
	    /* it is a generated authorization */
	    pAuth->refcnt++;
	    if (pAuth->refcnt == 1 && pAuth->timer)
		TimerCancel(pAuth->timer);

	    state->trustLevel = pAuth->trustLevel;
	}
	break;

    case ClientStateGone:
    case ClientStateRetained:
	rc = dixLookupResourceByType((pointer *)&pAuth, state->authId,
			       SecurityAuthorizationResType, serverClient,
			       DixGetAttrAccess);
	if (rc == Success) {
	    /* it is a generated authorization */
	    pAuth->refcnt--;
	    if (pAuth->refcnt == 0)
		SecurityStartAuthorizationTimer(pAuth);
	}
	break;

    default:
	break;
    }
}

/* SecurityResetProc
 *
 * Arguments:
 *	extEntry is the extension information for the security extension.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Performs any cleanup needed by Security at server shutdown time.
 */

static void
SecurityResetProc(
    ExtensionEntry *extEntry)
{
    /* Unregister callbacks */
    DeleteCallback(&ClientStateCallback, SecurityClientState, NULL);

    XaceDeleteCallback(XACE_EXT_DISPATCH, SecurityExtension, NULL);
    XaceDeleteCallback(XACE_RESOURCE_ACCESS, SecurityResource, NULL);
    XaceDeleteCallback(XACE_DEVICE_ACCESS, SecurityDevice, NULL);
    XaceDeleteCallback(XACE_PROPERTY_ACCESS, SecurityProperty, NULL);
    XaceDeleteCallback(XACE_SEND_ACCESS, SecuritySend, NULL);
    XaceDeleteCallback(XACE_RECEIVE_ACCESS, SecurityReceive, NULL);
    XaceDeleteCallback(XACE_CLIENT_ACCESS, SecurityClient, NULL);
    XaceDeleteCallback(XACE_EXT_ACCESS, SecurityExtension, NULL);
    XaceDeleteCallback(XACE_SERVER_ACCESS, SecurityServer, NULL);
}


/* SecurityExtensionInit
 *
 * Arguments: none.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Enables the Security extension if possible.
 */

void
SecurityExtensionInit(INITARGS)
{
    ExtensionEntry	*extEntry;
    int ret = TRUE;

    SecurityAuthorizationResType =
	CreateNewResourceType(SecurityDeleteAuthorization,
			      "SecurityAuthorization");

    RTEventClient =
	CreateNewResourceType(SecurityDeleteAuthorizationEventClient,
			      "SecurityEventClient");

    if (!SecurityAuthorizationResType || !RTEventClient)
	return;

    RTEventClient |= RC_NEVERRETAIN;

    /* Allocate the private storage */
    if (!dixRegisterPrivateKey(stateKey, PRIVATE_CLIENT, sizeof(SecurityStateRec)))
	FatalError("SecurityExtensionSetup: Can't allocate client private.\n");

    /* Register callbacks */
    ret &= AddCallback(&ClientStateCallback, SecurityClientState, NULL);

    ret &= XaceRegisterCallback(XACE_EXT_DISPATCH, SecurityExtension, NULL);
    ret &= XaceRegisterCallback(XACE_RESOURCE_ACCESS, SecurityResource, NULL);
    ret &= XaceRegisterCallback(XACE_DEVICE_ACCESS, SecurityDevice, NULL);
    ret &= XaceRegisterCallback(XACE_PROPERTY_ACCESS, SecurityProperty, NULL);
    ret &= XaceRegisterCallback(XACE_SEND_ACCESS, SecuritySend, NULL);
    ret &= XaceRegisterCallback(XACE_RECEIVE_ACCESS, SecurityReceive, NULL);
    ret &= XaceRegisterCallback(XACE_CLIENT_ACCESS, SecurityClient, NULL);
    ret &= XaceRegisterCallback(XACE_EXT_ACCESS, SecurityExtension, NULL);
    ret &= XaceRegisterCallback(XACE_SERVER_ACCESS, SecurityServer, NULL);

    if (!ret)
	FatalError("SecurityExtensionSetup: Failed to register callbacks\n");

    /* Add extension to server */
    extEntry = AddExtension(SECURITY_EXTENSION_NAME,
			    XSecurityNumberEvents, XSecurityNumberErrors,
			    ProcSecurityDispatch, SProcSecurityDispatch,
                            SecurityResetProc, StandardMinorOpcode);

    SecurityErrorBase = extEntry->errorBase;
    SecurityEventBase = extEntry->eventBase;

    EventSwapVector[SecurityEventBase + XSecurityAuthorizationRevoked] =
	(EventSwapPtr)SwapSecurityAuthorizationRevokedEvent;

    SetResourceTypeErrorValue(SecurityAuthorizationResType, SecurityErrorBase + XSecurityBadAuthorization);

    /* Label objects that were created before we could register ourself */
    SecurityLabelInitial();
}
/*
Copyright 1996, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.
*/

/* Xserver internals for Security extension - moved here from
   _SECURITY_SERVER section of <X11/extensions/security.h> */

#ifndef _SECURITY_SRV_H
#define _SECURITY_SRV_H

/* Allow client side portions of <X11/extensions/security.h> to compile */
#ifndef Status
# define Status int
# define NEED_UNDEF_Status
#endif
#ifndef Display
# define Display void
# define NEED_UNDEF_Display
#endif

#include <X11/extensions/secur.h>

#ifdef NEED_UNDEF_Status
# undef Status
# undef NEED_UNDEF_Status
#endif
#ifdef NEED_UNDEF_Display
# undef Display
# undef NEED_UNDEF_Display
#endif


#include "input.h"    /* for DeviceIntPtr */
#include "property.h" /* for PropertyPtr */
#include "pixmap.h"   /* for DrawablePtr */
#include "resource.h" /* for RESTYPE */

/* resource type to pass in LookupIDByType for authorizations */
extern RESTYPE SecurityAuthorizationResType;

/* this is what we store for an authorization */
typedef struct {
    XID id;			/* resource ID */
    CARD32 timeout;	/* how long to live in seconds after refcnt == 0 */
    unsigned int trustLevel;	/* trusted/untrusted */
    XID group;			/* see embedding extension */
    unsigned int refcnt;	/* how many clients connected with this auth */
    unsigned int secondsRemaining; /* overflow time amount for >49 days */
    OsTimerPtr timer;		/* timer for this auth */
    struct _OtherClients *eventClients; /* clients wanting events */
} SecurityAuthorizationRec, *SecurityAuthorizationPtr;

typedef struct {
    XID group;	/* the group that was sent in GenerateAuthorization */
    Bool valid; /* did anyone recognize it? if so, set to TRUE */
} SecurityValidateGroupInfoRec;

/* Give this value or higher to the -audit option to get security messages */
#define SECURITY_AUDIT_LEVEL 4

#endif /* _SECURITY_SRV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/shapeproto.h>
#include "regionstr.h"
#include "gcstruct.h"
#include "modinit.h"
#include "protocol-versions.h"

typedef	RegionPtr (*CreateDftPtr)(
	WindowPtr /* pWin */
	);

static int ShapeFreeClient(
	pointer /* data */,
	XID /* id */
	);
static int ShapeFreeEvents(
	pointer /* data */,
	XID /* id */
	);
static void SShapeNotifyEvent(
	xShapeNotifyEvent * /* from */,
	xShapeNotifyEvent * /* to */
	);

/* SendShapeNotify, CreateBoundingShape and CreateClipShape are used
 * externally by the Xfixes extension and are now defined in window.h
 */


#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

static int ShapeEventBase = 0;
static RESTYPE ClientType, ShapeEventType; /* resource types for event masks */

/*
 * each window has a list of clients requesting
 * ShapeNotify events.  Each client has a resource
 * for each window it selects ShapeNotify input for,
 * this resource is used to delete the ShapeNotifyRec
 * entry from the per-window queue.
 */

typedef struct _ShapeEvent *ShapeEventPtr;

typedef struct _ShapeEvent {
    ShapeEventPtr   next;
    ClientPtr	    client;
    WindowPtr	    window;
    XID		    clientResource;
} ShapeEventRec;

/****************
 * ShapeExtensionInit
 *
 * Called from InitExtensions in main() or from QueryExtension() if the
 * extension is dynamically loaded.
 *
 ****************/

static int
RegionOperate (
	ClientPtr client,
	WindowPtr pWin,
	int kind,
	RegionPtr *destRgnp,
	RegionPtr srcRgn,
	int op,
	int xoff, int yoff,
	CreateDftPtr create)
{
    if (srcRgn && (xoff || yoff))
	RegionTranslate(srcRgn, xoff, yoff);
    if (!pWin->parent)
    {
	if (srcRgn)
	    RegionDestroy(srcRgn);
	return Success;
    }

    /* May/30/2001:
     * The shape.PS specs say if src is None, existing shape is to be
     * removed (and so the op-code has no meaning in such removal);
     * see shape.PS, page 3, ShapeMask.
     */
    if (srcRgn == NULL) {
      if (*destRgnp != NULL) {
	RegionDestroy(*destRgnp);
	*destRgnp = 0;
	/* go on to remove shape and generate ShapeNotify */
      }
      else {
	/* May/30/2001:
	 * The target currently has no shape in effect, so nothing to
	 * do here.  The specs say that ShapeNotify is generated whenever
	 * the client region is "modified"; since no modification is done
	 * here, we do not generate that event.  The specs does not say
	 * "it is an error to request removal when there is no shape in
	 * effect", so we return good status.
	 */
	return Success;
      }
    }
    else switch (op) {
    case ShapeSet:
	if (*destRgnp)
	    RegionDestroy(*destRgnp);
	*destRgnp = srcRgn;
	srcRgn = 0;
	break;
    case ShapeUnion:
	if (*destRgnp)
	    RegionUnion(*destRgnp, *destRgnp, srcRgn);
	break;
    case ShapeIntersect:
	if (*destRgnp)
	    RegionIntersect(*destRgnp, *destRgnp, srcRgn);
	else {
	    *destRgnp = srcRgn;
	    srcRgn = 0;
	}
	break;
    case ShapeSubtract:
	if (!*destRgnp)
	    *destRgnp = (*create)(pWin);
	RegionSubtract(*destRgnp, *destRgnp, srcRgn);
	break;
    case ShapeInvert:
	if (!*destRgnp)
	    *destRgnp = RegionCreate((BoxPtr) 0, 0);
	else
	    RegionSubtract(*destRgnp, srcRgn, *destRgnp);
	break;
    default:
	client->errorValue = op;
	return BadValue;
    }
    if (srcRgn)
	RegionDestroy(srcRgn);
    (*pWin->drawable.pScreen->SetShape) (pWin, kind);
    SendShapeNotify (pWin, kind);
    return Success;
}

RegionPtr
CreateBoundingShape (WindowPtr pWin)
{
    BoxRec	extents;

    extents.x1 = -wBorderWidth (pWin);
    extents.y1 = -wBorderWidth (pWin);
    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
    return RegionCreate(&extents, 1);
}

RegionPtr
CreateClipShape (WindowPtr pWin)
{
    BoxRec	extents;

    extents.x1 = 0;
    extents.y1 = 0;
    extents.x2 = pWin->drawable.width;
    extents.y2 = pWin->drawable.height;
    return RegionCreate(&extents, 1);
}

static int
ProcShapeQueryVersion (ClientPtr client)
{
    xShapeQueryVersionReply	rep;
    int		n;

    REQUEST_SIZE_MATCH (xShapeQueryVersionReq);
    memset(&rep, 0, sizeof(xShapeQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SHAPE_MAJOR_VERSION;
    rep.minorVersion = SERVER_SHAPE_MINOR_VERSION;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof (xShapeQueryVersionReply), (char *)&rep);
    return Success;
}

/*****************
 * ProcShapeRectangles
 *
 *****************/

static int
ProcShapeRectangles (ClientPtr client)
{
    WindowPtr		pWin;
    REQUEST(xShapeRectanglesReq);
    xRectangle		*prects;
    int		        nrects, ctype, rc;
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    CreateDftPtr	createDefault;

    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
	createDefault = CreateBoundingShape;
	break;
    case ShapeClip:
	createDefault = CreateClipShape;
	break;
    case ShapeInput:
	createDefault = CreateBoundingShape;
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }
    if ((stuff->ordering != Unsorted) && (stuff->ordering != YSorted) &&
	(stuff->ordering != YXSorted) && (stuff->ordering != YXBanded))
    {
	client->errorValue = stuff->ordering;
        return BadValue;
    }
    nrects = ((stuff->length  << 2) - sizeof(xShapeRectanglesReq));
    if (nrects & 4)
	return BadLength;
    nrects >>= 3;
    prects = (xRectangle *) &stuff[1];
    ctype = VerifyRectOrder(nrects, prects, (int)stuff->ordering);
    if (ctype < 0)
	return BadMatch;
    srcRgn = RegionFromRects(nrects, prects, ctype);

    if (!pWin->optional)
	MakeWindowOptional (pWin);
    switch (stuff->destKind) {
    case ShapeBounding:
	destRgn = &pWin->optional->boundingShape;
	break;
    case ShapeClip:
	destRgn = &pWin->optional->clipShape;
	break;
    case ShapeInput:
	destRgn = &pWin->optional->inputShape;
	break;
    default:
	return BadValue;
    }

    return RegionOperate (client, pWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
}

#ifdef PANORAMIX
static int
ProcPanoramiXShapeRectangles(
    ClientPtr client)
{
    REQUEST(xShapeRectanglesReq);
    PanoramiXRes	*win;
    int        		j, result;

    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS(j) {
	stuff->dest = win->info[j].id;
	result = ProcShapeRectangles (client);
	if (result != Success) break;
    }
    return result;
}
#endif


/**************
 * ProcShapeMask
 **************/


static int
ProcShapeMask (ClientPtr client)
{
    WindowPtr		pWin;
    ScreenPtr		pScreen;
    REQUEST(xShapeMaskReq);
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    PixmapPtr		pPixmap;
    CreateDftPtr	createDefault;
    int			rc;

    REQUEST_SIZE_MATCH (xShapeMaskReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
	createDefault = CreateBoundingShape;
	break;
    case ShapeClip:
	createDefault = CreateClipShape;
	break;
    case ShapeInput:
	createDefault = CreateBoundingShape;
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }
    pScreen = pWin->drawable.pScreen;
    if (stuff->src == None)
	srcRgn = 0;
    else {
	rc = dixLookupResourceByType((pointer *)&pPixmap, stuff->src, RT_PIXMAP,
			       client, DixReadAccess);
        if (rc != Success)
	    return rc;
	if (pPixmap->drawable.pScreen != pScreen ||
	    pPixmap->drawable.depth != 1)
	    return BadMatch;
	srcRgn = BitmapToRegion(pScreen, pPixmap);
	if (!srcRgn)
	    return BadAlloc;
    }

    if (!pWin->optional)
	MakeWindowOptional (pWin);
    switch (stuff->destKind) {
    case ShapeBounding:
	destRgn = &pWin->optional->boundingShape;
	break;
    case ShapeClip:
	destRgn = &pWin->optional->clipShape;
	break;
    case ShapeInput:
	destRgn = &pWin->optional->inputShape;
	break;
    default:
	return BadValue;
    }

    return RegionOperate (client, pWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
}

#ifdef PANORAMIX
static int
ProcPanoramiXShapeMask(
    ClientPtr client)
{
    REQUEST(xShapeMaskReq);
    PanoramiXRes	*win, *pmap;
    int 		j, result;

    REQUEST_SIZE_MATCH (xShapeMaskReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    if(stuff->src != None) {
	result = dixLookupResourceByType((pointer *)&pmap, stuff->src,
					 XRT_PIXMAP, client, DixReadAccess);
	if (result != Success)
	    return result;
    } else
	pmap = NULL;

    FOR_NSCREENS(j) {
	stuff->dest = win->info[j].id;
	if(pmap)
	    stuff->src  = pmap->info[j].id;
	result = ProcShapeMask (client);
	if (result != Success) break;
    }
    return result;
}
#endif


/************
 * ProcShapeCombine
 ************/

static int
ProcShapeCombine (ClientPtr client)
{
    WindowPtr		pSrcWin, pDestWin;
    REQUEST(xShapeCombineReq);
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    CreateDftPtr	createDefault;
    CreateDftPtr	createSrc;
    RegionPtr		tmp;
    int			rc;

    REQUEST_SIZE_MATCH (xShapeCombineReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pDestWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (!pDestWin->optional)
	MakeWindowOptional (pDestWin);
    switch (stuff->destKind) {
    case ShapeBounding:
	createDefault = CreateBoundingShape;
	break;
    case ShapeClip:
	createDefault = CreateClipShape;
	break;
    case ShapeInput:
	createDefault = CreateBoundingShape;
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }

    rc = dixLookupWindow(&pSrcWin, stuff->src, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->srcKind) {
    case ShapeBounding:
	srcRgn = wBoundingShape (pSrcWin);
	createSrc = CreateBoundingShape;
	break;
    case ShapeClip:
	srcRgn = wClipShape (pSrcWin);
	createSrc = CreateClipShape;
	break;
    case ShapeInput:
	srcRgn = wInputShape (pSrcWin);
	createSrc = CreateBoundingShape;
	break;
    default:
	client->errorValue = stuff->srcKind;
	return BadValue;
    }
    if (pSrcWin->drawable.pScreen != pDestWin->drawable.pScreen)
    {
	return BadMatch;
    }

    if (srcRgn) {
        tmp = RegionCreate((BoxPtr) 0, 0);
        RegionCopy(tmp, srcRgn);
        srcRgn = tmp;
    } else
	srcRgn = (*createSrc) (pSrcWin);

    if (!pDestWin->optional)
	MakeWindowOptional (pDestWin);
    switch (stuff->destKind) {
    case ShapeBounding:
	destRgn = &pDestWin->optional->boundingShape;
	break;
    case ShapeClip:
	destRgn = &pDestWin->optional->clipShape;
	break;
    case ShapeInput:
	destRgn = &pDestWin->optional->inputShape;
	break;
    default:
	return BadValue;
    }

    return RegionOperate (client, pDestWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
}


#ifdef PANORAMIX
static int
ProcPanoramiXShapeCombine(
    ClientPtr client)
{
    REQUEST(xShapeCombineReq);
    PanoramiXRes	*win, *win2;
    int 		j, result;

    REQUEST_AT_LEAST_SIZE (xShapeCombineReq);

    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    result = dixLookupResourceByType((pointer *)&win2, stuff->src, XRT_WINDOW,
				     client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS(j) {
	stuff->dest = win->info[j].id;
	stuff->src =  win2->info[j].id;
	result = ProcShapeCombine (client);
	if (result != Success) break;
    }
    return result;
}
#endif

/*************
 * ProcShapeOffset
 *************/

static int
ProcShapeOffset (ClientPtr client)
{
    WindowPtr		pWin;
    REQUEST(xShapeOffsetReq);
    RegionPtr		srcRgn;
    int			rc;

    REQUEST_SIZE_MATCH (xShapeOffsetReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
	srcRgn = wBoundingShape (pWin);
	break;
    case ShapeClip:
	srcRgn = wClipShape(pWin);
	break;
    case ShapeInput:
	srcRgn = wInputShape (pWin);
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }
    if (srcRgn)
    {
        RegionTranslate(srcRgn, stuff->xOff, stuff->yOff);
        (*pWin->drawable.pScreen->SetShape) (pWin, stuff->destKind);
    }
    SendShapeNotify (pWin, (int)stuff->destKind);
    return Success;
}


#ifdef PANORAMIX
static int
ProcPanoramiXShapeOffset(
    ClientPtr client)
{
    REQUEST(xShapeOffsetReq);
    PanoramiXRes *win;
    int j, result;

    REQUEST_AT_LEAST_SIZE (xShapeOffsetReq);
   
    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS(j) {
	stuff->dest = win->info[j].id;
	result = ProcShapeOffset (client);
	if(result != Success) break;
    }
    return result;
}
#endif


static int
ProcShapeQueryExtents (ClientPtr client)
{
    REQUEST(xShapeQueryExtentsReq);
    WindowPtr		pWin;
    xShapeQueryExtentsReply	rep;
    BoxRec		extents, *pExtents;
    int	n, rc;
    RegionPtr		region;

    REQUEST_SIZE_MATCH (xShapeQueryExtentsReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    memset(&rep, 0, sizeof(xShapeQueryExtentsReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.boundingShaped = (wBoundingShape(pWin) != 0);
    rep.clipShaped = (wClipShape(pWin) != 0);
    if ((region = wBoundingShape(pWin))) {
     /* this is done in two steps because of a compiler bug on SunOS 4.1.3 */
	pExtents = RegionExtents(region);
	extents = *pExtents;
    } else {
	extents.x1 = -wBorderWidth (pWin);
	extents.y1 = -wBorderWidth (pWin);
	extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
    }
    rep.xBoundingShape = extents.x1;
    rep.yBoundingShape = extents.y1;
    rep.widthBoundingShape = extents.x2 - extents.x1;
    rep.heightBoundingShape = extents.y2 - extents.y1;
    if ((region = wClipShape(pWin))) {
     /* this is done in two steps because of a compiler bug on SunOS 4.1.3 */
	pExtents = RegionExtents(region);
	extents = *pExtents;
    } else {
	extents.x1 = 0;
	extents.y1 = 0;
	extents.x2 = pWin->drawable.width;
	extents.y2 = pWin->drawable.height;
    }
    rep.xClipShape = extents.x1;
    rep.yClipShape = extents.y1;
    rep.widthClipShape = extents.x2 - extents.x1;
    rep.heightClipShape = extents.y2 - extents.y1;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.xBoundingShape, n);
	swaps(&rep.yBoundingShape, n);
	swaps(&rep.widthBoundingShape, n);
	swaps(&rep.heightBoundingShape, n);
	swaps(&rep.xClipShape, n);
	swaps(&rep.yClipShape, n);
	swaps(&rep.widthClipShape, n);
	swaps(&rep.heightClipShape, n);
    }
    WriteToClient(client, sizeof (xShapeQueryExtentsReply), (char *)&rep);
    return Success;
}

/*ARGSUSED*/
static int
ShapeFreeClient (pointer data, XID id)
{
    ShapeEventPtr   pShapeEvent;
    WindowPtr	    pWin;
    ShapeEventPtr   *pHead, pCur, pPrev;
    int rc;

    pShapeEvent = (ShapeEventPtr) data;
    pWin = pShapeEvent->window;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, serverClient, DixReadAccess);
    if (rc == Success) {
	pPrev = 0;
	for (pCur = *pHead; pCur && pCur != pShapeEvent; pCur=pCur->next)
	    pPrev = pCur;
	if (pCur)
	{
	    if (pPrev)
	    	pPrev->next = pShapeEvent->next;
	    else
	    	*pHead = pShapeEvent->next;
	}
    }
    free((pointer) pShapeEvent);
    return 1;
}

/*ARGSUSED*/
static int
ShapeFreeEvents (pointer data, XID id)
{
    ShapeEventPtr   *pHead, pCur, pNext;

    pHead = (ShapeEventPtr *) data;
    for (pCur = *pHead; pCur; pCur = pNext) {
	pNext = pCur->next;
	FreeResource (pCur->clientResource, ClientType);
	free((pointer) pCur);
    }
    free((pointer) pHead);
    return 1;
}

static int
ProcShapeSelectInput (ClientPtr client)
{
    REQUEST(xShapeSelectInputReq);
    WindowPtr		pWin;
    ShapeEventPtr	pShapeEvent, pNewShapeEvent, *pHead;
    XID			clientResource;
    int			rc;

    REQUEST_SIZE_MATCH (xShapeSelectInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReceiveAccess);
    if (rc != Success)
	return rc;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, client, DixWriteAccess);
    if (rc != Success && rc != BadValue)
	return rc;

    switch (stuff->enable) {
    case xTrue:
	if (pHead) {

	    /* check for existing entry. */
	    for (pShapeEvent = *pHead;
		 pShapeEvent;
 		 pShapeEvent = pShapeEvent->next)
	    {
		if (pShapeEvent->client == client)
		    return Success;
	    }
	}

	/* build the entry */
	pNewShapeEvent = malloc(sizeof (ShapeEventRec));
    	if (!pNewShapeEvent)
	    return BadAlloc;
    	pNewShapeEvent->next = 0;
    	pNewShapeEvent->client = client;
    	pNewShapeEvent->window = pWin;
    	/*
 	 * add a resource that will be deleted when
     	 * the client goes away
     	 */
   	clientResource = FakeClientID (client->index);
    	pNewShapeEvent->clientResource = clientResource;
    	if (!AddResource (clientResource, ClientType, (pointer)pNewShapeEvent))
	    return BadAlloc;
    	/*
     	 * create a resource to contain a pointer to the list
     	 * of clients selecting input.  This must be indirect as
     	 * the list may be arbitrarily rearranged which cannot be
     	 * done through the resource database.
     	 */
    	if (!pHead)
    	{
	    pHead = malloc(sizeof (ShapeEventPtr));
	    if (!pHead ||
		!AddResource (pWin->drawable.id, ShapeEventType, (pointer)pHead))
	    {
	    	FreeResource (clientResource, RT_NONE);
	    	return BadAlloc;
	    }
	    *pHead = 0;
    	}
    	pNewShapeEvent->next = *pHead;
    	*pHead = pNewShapeEvent;
	break;
    case xFalse:
	/* delete the interest */
	if (pHead) {
	    pNewShapeEvent = 0;
	    for (pShapeEvent = *pHead; pShapeEvent; pShapeEvent = pShapeEvent->next) {
		if (pShapeEvent->client == client)
		    break;
		pNewShapeEvent = pShapeEvent;
	    }
	    if (pShapeEvent) {
		FreeResource (pShapeEvent->clientResource, ClientType);
		if (pNewShapeEvent)
		    pNewShapeEvent->next = pShapeEvent->next;
		else
		    *pHead = pShapeEvent->next;
		free(pShapeEvent);
	    }
	}
	break;
    default:
	client->errorValue = stuff->enable;
	return BadValue;
    }
    return Success;
}

/*
 * deliver the event
 */

void
SendShapeNotify (WindowPtr pWin, int which)
{
    ShapeEventPtr	*pHead, pShapeEvent;
    xShapeNotifyEvent	se;
    BoxRec		extents;
    RegionPtr		region;
    BYTE		shaped;
    int rc;

    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, serverClient, DixReadAccess);
    if (rc != Success)
	return;
    switch (which) {
    case ShapeBounding:
	region = wBoundingShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = -wBorderWidth (pWin);
	    extents.y1 = -wBorderWidth (pWin);
	    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
	    shaped = xFalse;
	}
	break;
    case ShapeClip:
	region = wClipShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = 0;
	    extents.y1 = 0;
	    extents.x2 = pWin->drawable.width;
	    extents.y2 = pWin->drawable.height;
	    shaped = xFalse;
	}
	break;
    case ShapeInput:
	region = wInputShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = -wBorderWidth (pWin);
	    extents.y1 = -wBorderWidth (pWin);
	    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
	    shaped = xFalse;
	}
	break;
    default:
	return;
    }
    for (pShapeEvent = *pHead; pShapeEvent; pShapeEvent = pShapeEvent->next) {
	se.type = ShapeNotify + ShapeEventBase;
	se.kind = which;
	se.window = pWin->drawable.id;
	se.x = extents.x1;
	se.y = extents.y1;
	se.width = extents.x2 - extents.x1;
	se.height = extents.y2 - extents.y1;
	se.time = currentTime.milliseconds;
	se.shaped = shaped;
	WriteEventsToClient (pShapeEvent->client, 1, (xEvent *) &se);
    }
}

static int
ProcShapeInputSelected (ClientPtr client)
{
    REQUEST(xShapeInputSelectedReq);
    WindowPtr		pWin;
    ShapeEventPtr	pShapeEvent, *pHead;
    int			enabled, rc;
    xShapeInputSelectedReply	rep;
    int		n;

    REQUEST_SIZE_MATCH (xShapeInputSelectedReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, client, DixReadAccess);
    if (rc != Success && rc != BadValue)
	return rc;
    enabled = xFalse;
    if (pHead) {
    	for (pShapeEvent = *pHead;
	     pShapeEvent;
	     pShapeEvent = pShapeEvent->next)
    	{
	    if (pShapeEvent->client == client) {
	    	enabled = xTrue;
		break;
	    }
    	}
    }
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.enabled = enabled;
    if (client->swapped) {
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
    }
    WriteToClient (client, sizeof (xShapeInputSelectedReply), (char *) &rep);
    return Success;
}

static int
ProcShapeGetRectangles (ClientPtr client)
{
    REQUEST(xShapeGetRectanglesReq);
    WindowPtr			pWin;
    xShapeGetRectanglesReply	rep;
    xRectangle			*rects;
    int				nrects, i, rc;
    RegionPtr			region;
    int		n;

    REQUEST_SIZE_MATCH(xShapeGetRectanglesReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    switch (stuff->kind) {
    case ShapeBounding:
	region = wBoundingShape(pWin);
	break;
    case ShapeClip:
	region = wClipShape(pWin);
	break;
    case ShapeInput:
	region = wInputShape (pWin);
	break;
    default:
	client->errorValue = stuff->kind;
	return BadValue;
    }
    if (!region) {
	nrects = 1;
	rects = malloc(sizeof (xRectangle));
	if (!rects)
	    return BadAlloc;
	switch (stuff->kind) {
	case ShapeBounding:
	    rects->x = - (int) wBorderWidth (pWin);
	    rects->y = - (int) wBorderWidth (pWin);
	    rects->width = pWin->drawable.width + wBorderWidth (pWin);
	    rects->height = pWin->drawable.height + wBorderWidth (pWin);
	    break;
	case ShapeClip:
	    rects->x = 0;
	    rects->y = 0;
	    rects->width = pWin->drawable.width;
	    rects->height = pWin->drawable.height;
	    break;
	case ShapeInput:
	    rects->x = - (int) wBorderWidth (pWin);
	    rects->y = - (int) wBorderWidth (pWin);
	    rects->width = pWin->drawable.width + wBorderWidth (pWin);
	    rects->height = pWin->drawable.height + wBorderWidth (pWin);
	    break;
	}
    } else {
	BoxPtr box;
	nrects = RegionNumRects(region);
	box = RegionRects(region);
	rects = malloc(nrects * sizeof (xRectangle));
	if (!rects && nrects)
	    return BadAlloc;
	for (i = 0; i < nrects; i++, box++) {
	    rects[i].x = box->x1;
	    rects[i].y = box->y1;
	    rects[i].width = box->x2 - box->x1;
	    rects[i].height = box->y2 - box->y1;
	}
    }
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = bytes_to_int32(nrects * sizeof (xRectangle));
    rep.ordering = YXBanded;
    rep.nrects = nrects;
    if (client->swapped) {
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.nrects, n);
	SwapShorts ((short *)rects, (unsigned long)nrects * 4);
    }
    WriteToClient (client, sizeof (rep), (char *) &rep);
    WriteToClient (client, nrects * sizeof (xRectangle), (char *) rects);
    free(rects);
    return Success;
}

static int
ProcShapeDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_ShapeQueryVersion:
	return ProcShapeQueryVersion (client);
    case X_ShapeRectangles:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
	    return ProcPanoramiXShapeRectangles (client);
        else 
#endif
	return ProcShapeRectangles (client);
    case X_ShapeMask:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeMask (client);
	else
#endif
	return ProcShapeMask (client);
    case X_ShapeCombine:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeCombine (client);
	else
#endif
	return ProcShapeCombine (client);
    case X_ShapeOffset:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeOffset (client);
	else
#endif
	return ProcShapeOffset (client);
    case X_ShapeQueryExtents:
	return ProcShapeQueryExtents (client);
    case X_ShapeSelectInput:
	return ProcShapeSelectInput (client);
    case X_ShapeInputSelected:
	return ProcShapeInputSelected (client);
    case X_ShapeGetRectangles:
	return ProcShapeGetRectangles (client);
    default:
	return BadRequest;
    }
}

static void
SShapeNotifyEvent(xShapeNotifyEvent *from, xShapeNotifyEvent *to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswapl (from->window, to->window);
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswaps (from->x, to->x);
    cpswaps (from->y, to->y);
    cpswaps (from->width, to->width);
    cpswaps (from->height, to->height);
    cpswapl (from->time, to->time);
    to->shaped = from->shaped;
}

static int
SProcShapeQueryVersion (ClientPtr client)
{
    int    n;
    REQUEST (xShapeQueryVersionReq);

    swaps (&stuff->length, n);
    return ProcShapeQueryVersion (client);
}

static int
SProcShapeRectangles (ClientPtr client)
{
    char   n;
    REQUEST (xShapeRectanglesReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    SwapRestS(stuff);
    return ProcShapeRectangles (client);
}

static int
SProcShapeMask (ClientPtr client)
{
    char   n;
    REQUEST (xShapeMaskReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeMaskReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->src, n);
    return ProcShapeMask (client);
}

static int
SProcShapeCombine (ClientPtr client)
{
    char   n;
    REQUEST (xShapeCombineReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeCombineReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->src, n);
    return ProcShapeCombine (client);
}

static int
SProcShapeOffset (ClientPtr client)
{
    char   n;
    REQUEST (xShapeOffsetReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeOffsetReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    return ProcShapeOffset (client);
}

static int
SProcShapeQueryExtents (ClientPtr client)
{
    char   n;
    REQUEST (xShapeQueryExtentsReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeQueryExtentsReq);
    swapl (&stuff->window, n);
    return ProcShapeQueryExtents (client);
}

static int
SProcShapeSelectInput (ClientPtr client)
{
    char   n;
    REQUEST (xShapeSelectInputReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeSelectInputReq);
    swapl (&stuff->window, n);
    return ProcShapeSelectInput (client);
}

static int
SProcShapeInputSelected (ClientPtr client)
{
    int    n;
    REQUEST (xShapeInputSelectedReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeInputSelectedReq);
    swapl (&stuff->window, n);
    return ProcShapeInputSelected (client);
}

static int
SProcShapeGetRectangles (ClientPtr client)
{
    REQUEST(xShapeGetRectanglesReq);
    char   n;

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xShapeGetRectanglesReq);
    swapl (&stuff->window, n);
    return ProcShapeGetRectangles (client);
}

static int
SProcShapeDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_ShapeQueryVersion:
	return SProcShapeQueryVersion (client);
    case X_ShapeRectangles:
	return SProcShapeRectangles (client);
    case X_ShapeMask:
	return SProcShapeMask (client);
    case X_ShapeCombine:
	return SProcShapeCombine (client);
    case X_ShapeOffset:
	return SProcShapeOffset (client);
    case X_ShapeQueryExtents:
	return SProcShapeQueryExtents (client);
    case X_ShapeSelectInput:
	return SProcShapeSelectInput (client);
    case X_ShapeInputSelected:
	return SProcShapeInputSelected (client);
    case X_ShapeGetRectangles:
	return SProcShapeGetRectangles (client);
    default:
	return BadRequest;
    }
}

void
ShapeExtensionInit(void)
{
    ExtensionEntry *extEntry;

    ClientType = CreateNewResourceType(ShapeFreeClient, "ShapeClient");
    ShapeEventType = CreateNewResourceType(ShapeFreeEvents, "ShapeEvent");
    if (ClientType && ShapeEventType &&
	(extEntry = AddExtension(SHAPENAME, ShapeNumberEvents, 0,
				 ProcShapeDispatch, SProcShapeDispatch,
				 NULL, StandardMinorOpcode)))
    {
	ShapeEventBase = extEntry->eventBase;
	EventSwapVector[ShapeEventBase] = (EventSwapPtr) SShapeNotifyEvent;
    }
}
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

********************************************************/

/* THIS IS NOT AN X CONSORTIUM STANDARD OR AN X PROJECT TEAM SPECIFICATION */


#define SHM

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <sys/stat.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "extnsionst.h"
#include "servermd.h"
#include "shmint.h"
#include "xace.h"
#include <X11/extensions/shmproto.h>
#include <X11/Xfuncproto.h>
#include "protocol-versions.h"

/* Needed for Solaris cross-zone shared memory extension */
#ifdef HAVE_SHMCTL64
#include <sys/ipc_impl.h>
#define SHMSTAT(id, buf)	shmctl64(id, IPC_STAT64, buf)
#define SHMSTAT_TYPE 		struct shmid_ds64
#define SHMPERM_TYPE 		struct ipc_perm64
#define SHM_PERM(buf) 		buf.shmx_perm
#define SHM_SEGSZ(buf)		buf.shmx_segsz
#define SHMPERM_UID(p)		p->ipcx_uid
#define SHMPERM_CUID(p)		p->ipcx_cuid
#define SHMPERM_GID(p)		p->ipcx_gid
#define SHMPERM_CGID(p)		p->ipcx_cgid
#define SHMPERM_MODE(p)		p->ipcx_mode
#define SHMPERM_ZONEID(p)	p->ipcx_zoneid
#else
#define SHMSTAT(id, buf) 	shmctl(id, IPC_STAT, buf)
#define SHMSTAT_TYPE 		struct shmid_ds
#define SHMPERM_TYPE 		struct ipc_perm
#define SHM_PERM(buf) 		buf.shm_perm
#define SHM_SEGSZ(buf)		buf.shm_segsz
#define SHMPERM_UID(p)		p->uid
#define SHMPERM_CUID(p)		p->cuid
#define SHMPERM_GID(p)		p->gid
#define SHMPERM_CGID(p)		p->cgid
#define SHMPERM_MODE(p)		p->mode
#endif

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

#include "modinit.h"

typedef struct _ShmDesc {
    struct _ShmDesc *next;
    int shmid;
    int refcnt;
    char *addr;
    Bool writable;
    unsigned long size;
} ShmDescRec, *ShmDescPtr;

typedef struct _ShmScrPrivateRec {
    CloseScreenProcPtr CloseScreen;
    ShmFuncsPtr shmFuncs;
    DestroyPixmapProcPtr destroyPixmap;
} ShmScrPrivateRec;

static PixmapPtr fbShmCreatePixmap(XSHM_CREATE_PIXMAP_ARGS);
static int ShmDetachSegment(
    pointer		/* value */,
    XID			/* shmseg */
    );
static void ShmResetProc(
    ExtensionEntry *	/* extEntry */
    );
static void SShmCompletionEvent(
    xShmCompletionEvent * /* from */,
    xShmCompletionEvent * /* to */
    );

static Bool ShmDestroyPixmap (PixmapPtr pPixmap);


static unsigned char ShmReqCode;
int ShmCompletionCode;
int BadShmSegCode;
RESTYPE ShmSegType;
static ShmDescPtr Shmsegs;
static Bool sharedPixmaps;
static DevPrivateKeyRec shmScrPrivateKeyRec;
#define shmScrPrivateKey (&shmScrPrivateKeyRec)
static DevPrivateKeyRec shmPixmapPrivateKeyRec;
#define shmPixmapPrivateKey (&shmPixmapPrivateKeyRec)
static ShmFuncs miFuncs = {NULL, NULL};
static ShmFuncs fbFuncs = {fbShmCreatePixmap, NULL};

#define ShmGetScreenPriv(s) ((ShmScrPrivateRec *)dixLookupPrivate(&(s)->devPrivates, shmScrPrivateKey))

#define VERIFY_SHMSEG(shmseg,shmdesc,client) \
{ \
    int rc; \
    rc = dixLookupResourceByType((pointer *)&(shmdesc), shmseg, ShmSegType, \
                                 client, DixReadAccess); \
    if (rc != Success) \
	return rc; \
}

#define VERIFY_SHMPTR(shmseg,offset,needwrite,shmdesc,client) \
{ \
    VERIFY_SHMSEG(shmseg, shmdesc, client); \
    if ((offset & 3) || (offset > shmdesc->size)) \
    { \
	client->errorValue = offset; \
	return BadValue; \
    } \
    if (needwrite && !shmdesc->writable) \
	return BadAccess; \
}

#define VERIFY_SHMSIZE(shmdesc,offset,len,client) \
{ \
    if ((offset + len) > shmdesc->size) \
    { \
	return BadAccess; \
    } \
}


#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__) || defined(__DragonFly__)
#include <sys/signal.h>

static Bool badSysCall = FALSE;

static void
SigSysHandler(int signo)
{
    badSysCall = TRUE;
}

static Bool CheckForShmSyscall(void)
{
    void (*oldHandler)();
    int shmid = -1;

    /* If no SHM support in the kernel, the bad syscall will generate SIGSYS */
    oldHandler = signal(SIGSYS, SigSysHandler);

    badSysCall = FALSE;
    shmid = shmget(IPC_PRIVATE, 4096, IPC_CREAT);

    if (shmid != -1)
    {
        /* Successful allocation - clean up */
	shmctl(shmid, IPC_RMID, NULL);
    }
    else
    {
        /* Allocation failed */
        badSysCall = TRUE;
    }
    signal(SIGSYS, oldHandler);
    return !badSysCall;
}

#define MUST_CHECK_FOR_SHM_SYSCALL

#endif

static Bool
ShmCloseScreen(int i, ScreenPtr pScreen)
{
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);
    pScreen->CloseScreen = screen_priv->CloseScreen;
    dixSetPrivate(&pScreen->devPrivates, shmScrPrivateKey, NULL);
    free(screen_priv);
    return (*pScreen->CloseScreen) (i, pScreen);
}

static ShmScrPrivateRec *
ShmInitScreenPriv(ScreenPtr pScreen)
{
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);
    if (!screen_priv)
    {
	screen_priv = calloc(1, sizeof (ShmScrPrivateRec));
	screen_priv->CloseScreen = pScreen->CloseScreen;
	dixSetPrivate(&pScreen->devPrivates, shmScrPrivateKey, screen_priv);
	pScreen->CloseScreen = ShmCloseScreen;
    }
    return screen_priv;
}

static Bool
ShmRegisterPrivates(void)
{
    if (!dixRegisterPrivateKey(&shmScrPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;
    if (!dixRegisterPrivateKey(&shmPixmapPrivateKeyRec, PRIVATE_PIXMAP, 0))
	return FALSE;
    return TRUE;
}

/*ARGSUSED*/
static void
ShmResetProc(ExtensionEntry *extEntry)
{
    int i;
    for (i = 0; i < screenInfo.numScreens; i++)
	ShmRegisterFuncs(screenInfo.screens[i], NULL);
}

void
ShmRegisterFuncs(ScreenPtr pScreen, ShmFuncsPtr funcs)
{
    if (!ShmRegisterPrivates())
	return;
    ShmInitScreenPriv(pScreen)->shmFuncs = funcs;
}

static Bool
ShmDestroyPixmap (PixmapPtr pPixmap)
{
    ScreenPtr	    pScreen = pPixmap->drawable.pScreen;
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);
    Bool	    ret;
    if (pPixmap->refcnt == 1)
    {
	ShmDescPtr  shmdesc;
	shmdesc = (ShmDescPtr)dixLookupPrivate(&pPixmap->devPrivates,
					       shmPixmapPrivateKey);
	if (shmdesc)
	    ShmDetachSegment ((pointer) shmdesc, pPixmap->drawable.id);
    }
    
    pScreen->DestroyPixmap = screen_priv->destroyPixmap;
    ret = (*pScreen->DestroyPixmap) (pPixmap);
    screen_priv->destroyPixmap = pScreen->DestroyPixmap;
    pScreen->DestroyPixmap = ShmDestroyPixmap;
    return ret;
}

void
ShmRegisterFbFuncs(ScreenPtr pScreen)
{
    ShmRegisterFuncs(pScreen, &fbFuncs);
}

static int
ProcShmQueryVersion(ClientPtr client)
{
    xShmQueryVersionReply rep;
    int n;

    REQUEST_SIZE_MATCH(xShmQueryVersionReq);
    memset(&rep, 0, sizeof(xShmQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.sharedPixmaps = sharedPixmaps;
    rep.pixmapFormat = sharedPixmaps ? ZPixmap : 0;
    rep.majorVersion = SERVER_SHM_MAJOR_VERSION;
    rep.minorVersion = SERVER_SHM_MINOR_VERSION;
    rep.uid = geteuid();
    rep.gid = getegid();
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
	swaps(&rep.uid, n);
	swaps(&rep.gid, n);
    }
    WriteToClient(client, sizeof(xShmQueryVersionReply), (char *)&rep);
    return Success;
}

/*
 * Simulate the access() system call for a shared memory segement,
 * using the credentials from the client if available
 */
static int
shm_access(ClientPtr client, SHMPERM_TYPE *perm, int readonly)
{
    int uid, gid;
    mode_t mask;
    int uidset = 0, gidset = 0;
    LocalClientCredRec *lcc;
    
    if (GetLocalClientCreds(client, &lcc) != -1) {

	if (lcc->fieldsSet & LCC_UID_SET) {
	    uid = lcc->euid;
	    uidset = 1;
	}
	if (lcc->fieldsSet & LCC_GID_SET) {
	    gid = lcc->egid;
	    gidset = 1;
	}

#if defined(HAVE_GETZONEID) && defined(SHMPERM_ZONEID)
	if ( ((lcc->fieldsSet & LCC_ZID_SET) == 0) || (lcc->zoneid == -1)
	     || (lcc->zoneid != SHMPERM_ZONEID(perm))) {
		uidset = 0;
		gidset = 0;
	}
#endif
	FreeLocalClientCreds(lcc);
	
	if (uidset) {
	    /* User id 0 always gets access */
	    if (uid == 0) {
		return 0;
	    }
	    /* Check the owner */
	    if (SHMPERM_UID(perm) == uid || SHMPERM_CUID(perm) == uid) {
		mask = S_IRUSR;
		if (!readonly) {
		    mask |= S_IWUSR;
		}
		return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
	    }
	}

	if (gidset) {
	    /* Check the group */
	    if (SHMPERM_GID(perm) == gid || SHMPERM_CGID(perm) == gid) {
		mask = S_IRGRP;
		if (!readonly) {
		    mask |= S_IWGRP;
		}
		return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
	    }
	}
    }
    /* Otherwise, check everyone else */
    mask = S_IROTH;
    if (!readonly) {
	mask |= S_IWOTH;
    }
    return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
}

static int
ProcShmAttach(ClientPtr client)
{
    SHMSTAT_TYPE buf;
    ShmDescPtr shmdesc;
    REQUEST(xShmAttachReq);

    REQUEST_SIZE_MATCH(xShmAttachReq);
    LEGAL_NEW_RESOURCE(stuff->shmseg, client);
    if ((stuff->readOnly != xTrue) && (stuff->readOnly != xFalse))
    {
	client->errorValue = stuff->readOnly;
        return BadValue;
    }
    for (shmdesc = Shmsegs;
	 shmdesc && (shmdesc->shmid != stuff->shmid);
	 shmdesc = shmdesc->next)
	;
    if (shmdesc)
    {
	if (!stuff->readOnly && !shmdesc->writable)
	    return BadAccess;
	shmdesc->refcnt++;
    }
    else
    {
	shmdesc = malloc(sizeof(ShmDescRec));
	if (!shmdesc)
	    return BadAlloc;
	shmdesc->addr = shmat(stuff->shmid, 0,
			      stuff->readOnly ? SHM_RDONLY : 0);
	if ((shmdesc->addr == ((char *)-1)) ||
	    SHMSTAT(stuff->shmid, &buf))
	{
	    free(shmdesc);
	    return BadAccess;
	}

	/* The attach was performed with root privs. We must
	 * do manual checking of access rights for the credentials 
	 * of the client */

	if (shm_access(client, &(SHM_PERM(buf)), stuff->readOnly) == -1) {
	    shmdt(shmdesc->addr);
	    free(shmdesc);
	    return BadAccess;
	}

	shmdesc->shmid = stuff->shmid;
	shmdesc->refcnt = 1;
	shmdesc->writable = !stuff->readOnly;
	shmdesc->size = SHM_SEGSZ(buf);
	shmdesc->next = Shmsegs;
	Shmsegs = shmdesc;
    }
    if (!AddResource(stuff->shmseg, ShmSegType, (pointer)shmdesc))
	return BadAlloc;
    return Success;
}

/*ARGSUSED*/
static int
ShmDetachSegment(pointer value, /* must conform to DeleteType */
		 XID shmseg)
{
    ShmDescPtr shmdesc = (ShmDescPtr)value;
    ShmDescPtr *prev;

    if (--shmdesc->refcnt)
	return TRUE;
    shmdt(shmdesc->addr);
    for (prev = &Shmsegs; *prev != shmdesc; prev = &(*prev)->next)
	;
    *prev = shmdesc->next;
    free(shmdesc);
    return Success;
}

static int
ProcShmDetach(ClientPtr client)
{
    ShmDescPtr shmdesc;
    REQUEST(xShmDetachReq);

    REQUEST_SIZE_MATCH(xShmDetachReq);
    VERIFY_SHMSEG(stuff->shmseg, shmdesc, client);
    FreeResource(stuff->shmseg, RT_NONE);
    return Success;
}

/*
 * If the given request doesn't exactly match PutImage's constraints,
 * wrap the image in a scratch pixmap header and let CopyArea sort it out.
 */
static void
doShmPutImage(DrawablePtr dst, GCPtr pGC,
	      int depth, unsigned int format,
	      int w, int h, int sx, int sy, int sw, int sh, int dx, int dy,
	      char *data)
{
    PixmapPtr pPixmap;

    if (format == ZPixmap || depth == 1) {
	pPixmap = GetScratchPixmapHeader(dst->pScreen, w, h, depth,
					 BitsPerPixel(depth),
					 PixmapBytePad(w, depth),
					 data);
	if (!pPixmap)
	    return;
	pGC->ops->CopyArea((DrawablePtr)pPixmap, dst, pGC, sx, sy, sw, sh, dx, dy);
	FreeScratchPixmapHeader(pPixmap);
    } else {
	GCPtr putGC = GetScratchGC(depth, dst->pScreen);

	if (!putGC)
	    return;

	pPixmap = (*dst->pScreen->CreatePixmap)(dst->pScreen, sw, sh, depth,
						CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pPixmap) {
	    FreeScratchGC(putGC);
	    return;
	}
	ValidateGC(&pPixmap->drawable, putGC);
	(*putGC->ops->PutImage)(&pPixmap->drawable, putGC, depth, -sx, -sy, w, h, 0,
				(format == XYPixmap) ? XYPixmap : ZPixmap, data);
	FreeScratchGC(putGC);
	if (format == XYBitmap)
	    (void)(*pGC->ops->CopyPlane)(&pPixmap->drawable, dst, pGC, 0, 0, sw, sh,
					 dx, dy, 1L);
	else
	    (void)(*pGC->ops->CopyArea)(&pPixmap->drawable, dst, pGC, 0, 0, sw, sh,
					dx, dy);
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
    }
}

static int
ProcShmPutImage(ClientPtr client)
{
    GCPtr pGC;
    DrawablePtr pDraw;
    long length;
    ShmDescPtr shmdesc;
    REQUEST(xShmPutImageReq);

    REQUEST_SIZE_MATCH(xShmPutImageReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, FALSE, shmdesc, client);
    if ((stuff->sendEvent != xTrue) && (stuff->sendEvent != xFalse))
	return BadValue;
    if (stuff->format == XYBitmap)
    {
        if (stuff->depth != 1)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, 1);
    }
    else if (stuff->format == XYPixmap)
    {
        if (pDraw->depth != stuff->depth)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, 1);
	length *= stuff->depth;
    }
    else if (stuff->format == ZPixmap)
    {
        if (pDraw->depth != stuff->depth)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, stuff->depth);
    }
    else
    {
	client->errorValue = stuff->format;
        return BadValue;
    }

    /*
     * There's a potential integer overflow in this check:
     * VERIFY_SHMSIZE(shmdesc, stuff->offset, length * stuff->totalHeight,
     *                client);
     * the version below ought to avoid it
     */
    if (stuff->totalHeight != 0 &&
	length > (shmdesc->size - stuff->offset)/stuff->totalHeight) {
	client->errorValue = stuff->totalWidth;
	return BadValue;
    }
    if (stuff->srcX > stuff->totalWidth)
    {
	client->errorValue = stuff->srcX;
	return BadValue;
    }
    if (stuff->srcY > stuff->totalHeight)
    {
	client->errorValue = stuff->srcY;
	return BadValue;
    }
    if ((stuff->srcX + stuff->srcWidth) > stuff->totalWidth)
    {
	client->errorValue = stuff->srcWidth;
	return BadValue;
    }
    if ((stuff->srcY + stuff->srcHeight) > stuff->totalHeight)
    {
	client->errorValue = stuff->srcHeight;
	return BadValue;
    }

    if ((((stuff->format == ZPixmap) && (stuff->srcX == 0)) ||
	 ((stuff->format != ZPixmap) &&
	  (stuff->srcX < screenInfo.bitmapScanlinePad) &&
	  ((stuff->format == XYBitmap) ||
	   ((stuff->srcY == 0) &&
	    (stuff->srcHeight == stuff->totalHeight))))) &&
	((stuff->srcX + stuff->srcWidth) == stuff->totalWidth))
	(*pGC->ops->PutImage) (pDraw, pGC, stuff->depth,
			       stuff->dstX, stuff->dstY,
			       stuff->totalWidth, stuff->srcHeight,
			       stuff->srcX, stuff->format,
			       shmdesc->addr + stuff->offset +
			       (stuff->srcY * length));
    else
	doShmPutImage(pDraw, pGC, stuff->depth, stuff->format,
		      stuff->totalWidth, stuff->totalHeight,
		      stuff->srcX, stuff->srcY,
		      stuff->srcWidth, stuff->srcHeight,
		      stuff->dstX, stuff->dstY,
                      shmdesc->addr + stuff->offset);

    if (stuff->sendEvent)
    {
	xShmCompletionEvent ev;

	ev.type = ShmCompletionCode;
	ev.drawable = stuff->drawable;
	ev.minorEvent = X_ShmPutImage;
	ev.majorEvent = ShmReqCode;
	ev.shmseg = stuff->shmseg;
	ev.offset = stuff->offset;
	WriteEventsToClient(client, 1, (xEvent *) &ev);
    }

    return Success;
}

static int
ProcShmGetImage(ClientPtr client)
{
    DrawablePtr		pDraw;
    long		lenPer = 0, length;
    Mask		plane = 0;
    xShmGetImageReply	xgi;
    ShmDescPtr		shmdesc;
    int			n, rc;

    REQUEST(xShmGetImageReq);

    REQUEST_SIZE_MATCH(xShmGetImageReq);
    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap))
    {
	client->errorValue = stuff->format;
        return BadValue;
    }
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;
    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);
    if (pDraw->type == DRAWABLE_WINDOW)
    {
      if( /* check for being viewable */
	 !((WindowPtr) pDraw)->realized ||
	  /* check for being on screen */
         pDraw->x + stuff->x < 0 ||
         pDraw->x + stuff->x + (int)stuff->width > pDraw->pScreen->width ||
         pDraw->y + stuff->y < 0 ||
         pDraw->y + stuff->y + (int)stuff->height > pDraw->pScreen->height ||
          /* check for being inside of border */
         stuff->x < - wBorderWidth((WindowPtr)pDraw) ||
         stuff->x + (int)stuff->width >
		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
         stuff->y < -wBorderWidth((WindowPtr)pDraw) ||
         stuff->y + (int)stuff->height >
		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->height
        )
	    return BadMatch;
	xgi.visual = wVisual(((WindowPtr)pDraw));
    }
    else
    {
	if (stuff->x < 0 ||
	    stuff->x+(int)stuff->width > pDraw->width ||
	    stuff->y < 0 ||
	    stuff->y+(int)stuff->height > pDraw->height
	    )
	    return BadMatch;
	xgi.visual = None;
    }
    xgi.type = X_Reply;
    xgi.length = 0;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
    if(stuff->format == ZPixmap)
    {
	length = PixmapBytePad(stuff->width, pDraw->depth) * stuff->height;
    }
    else
    {
	lenPer = PixmapBytePad(stuff->width, 1) * stuff->height;
	plane = ((Mask)1) << (pDraw->depth - 1);
	/* only planes asked for */
	length = lenPer * Ones(stuff->planeMask & (plane | (plane - 1)));
    }

    VERIFY_SHMSIZE(shmdesc, stuff->offset, length, client);
    xgi.size = length;

    if (length == 0)
    {
	/* nothing to do */
    }
    else if (stuff->format == ZPixmap)
    {
	(*pDraw->pScreen->GetImage)(pDraw, stuff->x, stuff->y,
				    stuff->width, stuff->height,
				    stuff->format, stuff->planeMask,
				    shmdesc->addr + stuff->offset);
    }
    else
    {

	length = stuff->offset;
        for (; plane; plane >>= 1)
	{
	    if (stuff->planeMask & plane)
	    {
		(*pDraw->pScreen->GetImage)(pDraw,
					    stuff->x, stuff->y,
					    stuff->width, stuff->height,
					    stuff->format, plane,
					    shmdesc->addr + length);
		length += lenPer;
	    }
	}
    }

    if (client->swapped) {
	swaps(&xgi.sequenceNumber, n);
	swapl(&xgi.length, n);
	swapl(&xgi.visual, n);
	swapl(&xgi.size, n);
    }
    WriteToClient(client, sizeof(xShmGetImageReply), (char *)&xgi);

    return Success;
}

#ifdef PANORAMIX
static int 
ProcPanoramiXShmPutImage(ClientPtr client)
{
    int			 j, result, orig_x, orig_y;
    PanoramiXRes	*draw, *gc;
    Bool		 sendEvent, isRoot;

    REQUEST(xShmPutImageReq);
    REQUEST_SIZE_MATCH(xShmPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    orig_x = stuff->dstX;
    orig_y = stuff->dstY;
    sendEvent = stuff->sendEvent;
    stuff->sendEvent = 0;
    FOR_NSCREENS(j) {
	if(!j) stuff->sendEvent = sendEvent;
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->dstX = orig_x - screenInfo.screens[j]->x;
	    stuff->dstY = orig_y - screenInfo.screens[j]->y;
	}
	result = ProcShmPutImage(client);
	if(result != Success) break;
    }
    return result;
}

static int 
ProcPanoramiXShmGetImage(ClientPtr client)
{
    PanoramiXRes	*draw;
    DrawablePtr 	*drawables;
    DrawablePtr 	pDraw;
    xShmGetImageReply	xgi;
    ShmDescPtr		shmdesc;
    int         	i, x, y, w, h, format, rc;
    Mask		plane = 0, planemask;
    long		lenPer = 0, length, widthBytesLine;
    Bool		isRoot;

    REQUEST(xShmGetImageReq);

    REQUEST_SIZE_MATCH(xShmGetImageReq);

    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap)) {
	client->errorValue = stuff->format;
        return BadValue;
    }

    rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    if (draw->type == XRT_PIXMAP)
	return ProcShmGetImage(client);

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);

    x = stuff->x;
    y = stuff->y;
    w = stuff->width;
    h = stuff->height;
    format = stuff->format;
    planemask = stuff->planeMask;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    if(isRoot) {
      if( /* check for being onscreen */
	x < 0 || x + w > PanoramiXPixWidth ||
	y < 0 || y + h > PanoramiXPixHeight )
	    return BadMatch;
    } else {
      if( /* check for being onscreen */
	screenInfo.screens[0]->x + pDraw->x + x < 0 ||
	screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth ||
	screenInfo.screens[0]->y + pDraw->y + y < 0 ||
	screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight ||
	 /* check for being inside of border */
       	x < - wBorderWidth((WindowPtr)pDraw) ||
	x + w > wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
	y < -wBorderWidth((WindowPtr)pDraw) ||
	y + h > wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height)
	    return BadMatch;
    }

    drawables = calloc(PanoramiXNumScreens, sizeof(DrawablePtr));
    if(!drawables)
	return BadAlloc;

    drawables[0] = pDraw;
    FOR_NSCREENS_FORWARD_SKIP(i) {
	rc = dixLookupDrawable(drawables+i, draw->info[i].id, client, 0, 
			       DixReadAccess);
	if (rc != Success)
	{
	    free(drawables);
	    return rc;
	}
    }

    xgi.visual = wVisual(((WindowPtr)pDraw));
    xgi.type = X_Reply;
    xgi.length = 0;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;

    if(format == ZPixmap) {
	widthBytesLine = PixmapBytePad(w, pDraw->depth);
	length = widthBytesLine * h;
    } else {
	widthBytesLine = PixmapBytePad(w, 1);
	lenPer = widthBytesLine * h;
	plane = ((Mask)1) << (pDraw->depth - 1);
	length = lenPer * Ones(planemask & (plane | (plane - 1)));
    }

    VERIFY_SHMSIZE(shmdesc, stuff->offset, length, client);
    xgi.size = length;

    if (length == 0) {/* nothing to do */ }
    else if (format == ZPixmap) {
	    XineramaGetImageData(drawables, x, y, w, h, format, planemask,
					shmdesc->addr + stuff->offset,
					widthBytesLine, isRoot);
    } else {

	length = stuff->offset;
        for (; plane; plane >>= 1) {
	    if (planemask & plane) {
		XineramaGetImageData(drawables, x, y, w, h, 
				     format, plane, shmdesc->addr + length,
				     widthBytesLine, isRoot);
		length += lenPer;
	    }
	}
    }
    free(drawables);
    
    if (client->swapped) {
	int n;
    	swaps(&xgi.sequenceNumber, n);
    	swapl(&xgi.length, n);
	swapl(&xgi.visual, n);
	swapl(&xgi.size, n);
    }
    WriteToClient(client, sizeof(xShmGetImageReply), (char *)&xgi);

    return Success;
}

static int
ProcPanoramiXShmCreatePixmap(ClientPtr client)
{
    ScreenPtr pScreen = NULL;
    PixmapPtr pMap = NULL;
    DrawablePtr pDraw;
    DepthPtr pDepth;
    int i, j, result, rc;
    ShmDescPtr shmdesc;
    REQUEST(xShmCreatePixmapReq);
    unsigned int width, height, depth;
    unsigned long size;
    PanoramiXRes *newPix;

    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    client->errorValue = stuff->pid;
    if (!sharedPixmaps)
	return BadImplementation;
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);

    width = stuff->width;
    height = stuff->height;
    depth = stuff->depth;
    if (!width || !height || !depth)
    {
	client->errorValue = 0;
        return BadValue;
    }
    if (width > 32767 || height > 32767)
        return BadAlloc;

    if (stuff->depth != 1)
    {
        pDepth = pDraw->pScreen->allowedDepths;
        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)
	   if (pDepth->depth == stuff->depth)
               goto CreatePmap;
	client->errorValue = stuff->depth;
        return BadValue;
    }

CreatePmap:
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {
        if (size < width * height)
            return BadAlloc;
    }
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
	return BadAlloc;

    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);

    if(!(newPix = malloc(sizeof(PanoramiXRes))))
	return BadAlloc;

    newPix->type = XRT_PIXMAP;
    newPix->u.pix.shared = TRUE;
    panoramix_setup_ids(newPix, client, stuff->pid);

    result = Success;

    FOR_NSCREENS(j) {
	ShmScrPrivateRec *screen_priv;
	pScreen = screenInfo.screens[j];

	screen_priv = ShmGetScreenPriv(pScreen);
	pMap = (*screen_priv->shmFuncs->CreatePixmap)(pScreen,
				stuff->width, stuff->height, stuff->depth,
				shmdesc->addr + stuff->offset);

	if (pMap) {
	    dixSetPrivate(&pMap->devPrivates, shmPixmapPrivateKey, shmdesc);
            shmdesc->refcnt++;
	    pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	    pMap->drawable.id = newPix->info[j].id;
	    if (!AddResource(newPix->info[j].id, RT_PIXMAP, (pointer)pMap)) {
		result = BadAlloc;
		break;
	    }
	} else {
	   result = BadAlloc;
	   break;
	}
    }

    if(result == BadAlloc) {
	while(j--)
	    FreeResource(newPix->info[j].id, RT_NONE);
	free(newPix);
    } else 
	AddResource(stuff->pid, XRT_PIXMAP, newPix);

    return result;
}
#endif

static PixmapPtr
fbShmCreatePixmap (ScreenPtr pScreen,
		   int width, int height, int depth, char *addr)
{
    PixmapPtr pPixmap;

    pPixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, pScreen->rootDepth, 0);
    if (!pPixmap)
	return NullPixmap;

    if (!(*pScreen->ModifyPixmapHeader)(pPixmap, width, height, depth,
	    BitsPerPixel(depth), PixmapBytePad(width, depth), (pointer)addr)) {
	(*pScreen->DestroyPixmap)(pPixmap);
	return NullPixmap;
    }
    return pPixmap;
}

static int
ProcShmCreatePixmap(ClientPtr client)
{
    PixmapPtr pMap;
    DrawablePtr pDraw;
    DepthPtr pDepth;
    int i, rc;
    ShmDescPtr shmdesc;
    ShmScrPrivateRec *screen_priv;
    REQUEST(xShmCreatePixmapReq);
    unsigned int width, height, depth;
    unsigned long size;

    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    client->errorValue = stuff->pid;
    if (!sharedPixmaps)
	return BadImplementation;
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);
    
    width = stuff->width;
    height = stuff->height;
    depth = stuff->depth;
    if (!width || !height || !depth)
    {
	client->errorValue = 0;
        return BadValue;
    }
    if (width > 32767 || height > 32767)
	return BadAlloc;

    if (stuff->depth != 1)
    {
        pDepth = pDraw->pScreen->allowedDepths;
        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)
	   if (pDepth->depth == stuff->depth)
               goto CreatePmap;
	client->errorValue = stuff->depth;
        return BadValue;
    }

CreatePmap:
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {
	if (size < width * height)
	    return BadAlloc;
    }
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
	return BadAlloc;

    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);
    screen_priv = ShmGetScreenPriv(pDraw->pScreen);
    pMap = (*screen_priv->shmFuncs->CreatePixmap)(
			    pDraw->pScreen, stuff->width,
			    stuff->height, stuff->depth,
			    shmdesc->addr + stuff->offset);
    if (pMap)
    {
	rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,
		      pMap, RT_NONE, NULL, DixCreateAccess);
	if (rc != Success) {
	    pDraw->pScreen->DestroyPixmap(pMap);
	    return rc;
	}
	dixSetPrivate(&pMap->devPrivates, shmPixmapPrivateKey, shmdesc);
	shmdesc->refcnt++;
	pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	pMap->drawable.id = stuff->pid;
	if (AddResource(stuff->pid, RT_PIXMAP, (pointer)pMap))
	{
	    return Success;
	}
    }
    return BadAlloc;
}

static int
ProcShmDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_ShmQueryVersion:
	return ProcShmQueryVersion(client);
    case X_ShmAttach:
	return ProcShmAttach(client);
    case X_ShmDetach:
	return ProcShmDetach(client);
    case X_ShmPutImage:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmPutImage(client);
#endif
	return ProcShmPutImage(client);
    case X_ShmGetImage:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmGetImage(client);
#endif
	return ProcShmGetImage(client);
    case X_ShmCreatePixmap:
#ifdef PANORAMIX
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmCreatePixmap(client);
#endif
	   return ProcShmCreatePixmap(client);
    default:
	return BadRequest;
    }
}

static void
SShmCompletionEvent(xShmCompletionEvent *from, xShmCompletionEvent *to)
{
    to->type = from->type;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->drawable, to->drawable);
    cpswaps(from->minorEvent, to->minorEvent);
    to->majorEvent = from->majorEvent;
    cpswapl(from->shmseg, to->shmseg);
    cpswapl(from->offset, to->offset);
}

static int
SProcShmQueryVersion(ClientPtr client)
{
    int n;
    REQUEST(xShmQueryVersionReq);

    swaps(&stuff->length, n);
    return ProcShmQueryVersion(client);
}

static int
SProcShmAttach(ClientPtr client)
{
    int n;
    REQUEST(xShmAttachReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmAttachReq);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->shmid, n);
    return ProcShmAttach(client);
}

static int
SProcShmDetach(ClientPtr client)
{
    int n;
    REQUEST(xShmDetachReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmDetachReq);
    swapl(&stuff->shmseg, n);
    return ProcShmDetach(client);
}

static int
SProcShmPutImage(ClientPtr client)
{
    int n;
    REQUEST(xShmPutImageReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmPutImageReq);
    swapl(&stuff->drawable, n);
    swapl(&stuff->gc, n);
    swaps(&stuff->totalWidth, n);
    swaps(&stuff->totalHeight, n);
    swaps(&stuff->srcX, n);
    swaps(&stuff->srcY, n);
    swaps(&stuff->srcWidth, n);
    swaps(&stuff->srcHeight, n);
    swaps(&stuff->dstX, n);
    swaps(&stuff->dstY, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
    return ProcShmPutImage(client);
}

static int
SProcShmGetImage(ClientPtr client)
{
    int n;
    REQUEST(xShmGetImageReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmGetImageReq);
    swapl(&stuff->drawable, n);
    swaps(&stuff->x, n);
    swaps(&stuff->y, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    swapl(&stuff->planeMask, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
    return ProcShmGetImage(client);
}

static int
SProcShmCreatePixmap(ClientPtr client)
{
    int n;
    REQUEST(xShmCreatePixmapReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    swapl(&stuff->pid, n);
    swapl(&stuff->drawable, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
    return ProcShmCreatePixmap(client);
}

static int
SProcShmDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_ShmQueryVersion:
	return SProcShmQueryVersion(client);
    case X_ShmAttach:
	return SProcShmAttach(client);
    case X_ShmDetach:
	return SProcShmDetach(client);
    case X_ShmPutImage:
	return SProcShmPutImage(client);
    case X_ShmGetImage:
	return SProcShmGetImage(client);
    case X_ShmCreatePixmap:
	return SProcShmCreatePixmap(client);
    default:
	return BadRequest;
    }
}

void
ShmExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;
    int i;

#ifdef MUST_CHECK_FOR_SHM_SYSCALL
    if (!CheckForShmSyscall())
    {
	ErrorF("MIT-SHM extension disabled due to lack of kernel support\n");
	return;
    }
#endif

    if (!ShmRegisterPrivates())
	return;

    sharedPixmaps = xFalse;
    {
      sharedPixmaps = xTrue;
      for (i = 0; i < screenInfo.numScreens; i++)
      {
	ShmScrPrivateRec *screen_priv = ShmInitScreenPriv(screenInfo.screens[i]);
	if (!screen_priv->shmFuncs)
	    screen_priv->shmFuncs = &miFuncs;
	if (!screen_priv->shmFuncs->CreatePixmap)
	    sharedPixmaps = xFalse;
      }
      if (sharedPixmaps)
	for (i = 0; i < screenInfo.numScreens; i++)
	{
	    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(screenInfo.screens[i]);
	    screen_priv->destroyPixmap = screenInfo.screens[i]->DestroyPixmap;
	    screenInfo.screens[i]->DestroyPixmap = ShmDestroyPixmap;
	}
    }
    ShmSegType = CreateNewResourceType(ShmDetachSegment, "ShmSeg");
    if (ShmSegType &&
	(extEntry = AddExtension(SHMNAME, ShmNumberEvents, ShmNumberErrors,
				 ProcShmDispatch, SProcShmDispatch,
				 ShmResetProc, StandardMinorOpcode)))
    {
	ShmReqCode = (unsigned char)extEntry->base;
	ShmCompletionCode = extEntry->eventBase;
	BadShmSegCode = extEntry->errorBase;
	SetResourceTypeErrorValue(ShmSegType, BadShmSegCode);
	EventSwapVector[ShmCompletionCode] = (EventSwapPtr) SShmCompletionEvent;
    }
}
/*
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _SHMINT_H_
#define _SHMINT_H_

#include <X11/extensions/shmproto.h>

#include "screenint.h"
#include "pixmap.h"
#include "gc.h"

#define XSHM_PUT_IMAGE_ARGS \
    DrawablePtr		/* dst */, \
    GCPtr		/* pGC */, \
    int			/* depth */, \
    unsigned int	/* format */, \
    int			/* w */, \
    int			/* h */, \
    int			/* sx */, \
    int			/* sy */, \
    int			/* sw */, \
    int			/* sh */, \
    int			/* dx */, \
    int			/* dy */, \
    char *		/* data */

#define XSHM_CREATE_PIXMAP_ARGS \
    ScreenPtr	/* pScreen */, \
    int		/* width */, \
    int		/* height */, \
    int		/* depth */, \
    char *	/* addr */

typedef struct _ShmFuncs {
    PixmapPtr	(* CreatePixmap)(XSHM_CREATE_PIXMAP_ARGS);
    void	(* PutImage)(XSHM_PUT_IMAGE_ARGS);
} ShmFuncs, *ShmFuncsPtr;

extern _X_EXPORT void
ShmRegisterFuncs(ScreenPtr pScreen, ShmFuncsPtr funcs);

extern _X_EXPORT void
ShmRegisterFbFuncs(ScreenPtr pScreen);

extern _X_EXPORT RESTYPE ShmSegType;
extern _X_EXPORT int ShmCompletionCode;
extern _X_EXPORT int BadShmSegCode;

#endif /* _SHMINT_H_ */
/*
 *
Copyright 1992, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
 *
 * Author:  Keith Packard, MIT X Consortium
 */

/* dixsleep.c - implement millisecond timeouts for X clients */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "sleepuntil.h"
#include <X11/X.h>
#include <X11/Xmd.h>
#include "misc.h"
#include "windowstr.h"
#include "dixstruct.h"
#include "pixmapstr.h"
#include "scrnintstr.h"

typedef struct _Sertafied {
    struct _Sertafied	*next;
    TimeStamp		revive;
    ClientPtr		pClient;
    XID			id;
    void		(*notifyFunc)(
			ClientPtr /* client */,
			pointer /* closure */
			);

    pointer		closure;
} SertafiedRec, *SertafiedPtr;

static SertafiedPtr pPending;
static RESTYPE	    SertafiedResType;
static Bool	    BlockHandlerRegistered;
static int	    SertafiedGeneration;

static void	    ClientAwaken(
    ClientPtr /* client */,
    pointer /* closure */
);
static int	    SertafiedDelete(
    pointer /* value */,
    XID /* id */
);
static void	    SertafiedBlockHandler(
    pointer /* data */,
    OSTimePtr /* wt */,
    pointer /* LastSelectMask */
);
static void	    SertafiedWakeupHandler(
    pointer /* data */,
    int /* i */,
    pointer /* LastSelectMask */
);

int
ClientSleepUntil (ClientPtr client,
                  TimeStamp *revive,
                  void (*notifyFunc)(ClientPtr, pointer),
                  pointer closure)
{
    SertafiedPtr	pRequest, pReq, pPrev;

    if (SertafiedGeneration != serverGeneration)
    {
	SertafiedResType = CreateNewResourceType (SertafiedDelete,
						  "ClientSleep");
	if (!SertafiedResType)
	    return FALSE;
	SertafiedGeneration = serverGeneration;
	BlockHandlerRegistered = FALSE;
    }
    pRequest = malloc(sizeof (SertafiedRec));
    if (!pRequest)
	return FALSE;
    pRequest->pClient = client;
    pRequest->revive = *revive;
    pRequest->id = FakeClientID (client->index);
    pRequest->closure = closure;
    if (!BlockHandlerRegistered)
    {
	if (!RegisterBlockAndWakeupHandlers (SertafiedBlockHandler,
					     SertafiedWakeupHandler,
					     (pointer) 0))
	{
	    free(pRequest);
	    return FALSE;
	}
	BlockHandlerRegistered = TRUE;
    }
    pRequest->notifyFunc = 0;
    if (!AddResource (pRequest->id, SertafiedResType, (pointer) pRequest))
	return FALSE;
    if (!notifyFunc)
	notifyFunc = ClientAwaken;
    pRequest->notifyFunc = notifyFunc;
    /* Insert into time-ordered queue, with earliest activation time coming first. */
    pPrev = 0;
    for (pReq = pPending; pReq; pReq = pReq->next)
    {
	if (CompareTimeStamps (pReq->revive, *revive) == LATER)
	    break;
	pPrev = pReq;
    }
    if (pPrev)
	pPrev->next = pRequest;
    else
	pPending = pRequest;
    pRequest->next = pReq;
    IgnoreClient (client);
    return TRUE;
}

static void
ClientAwaken (ClientPtr client, pointer closure)
{
    if (!client->clientGone)
	AttendClient (client);
}


static int
SertafiedDelete (pointer value, XID id)
{
    SertafiedPtr	pRequest = (SertafiedPtr)value;
    SertafiedPtr	pReq, pPrev;

    pPrev = 0;
    for (pReq = pPending; pReq; pPrev = pReq, pReq = pReq->next)
	if (pReq == pRequest)
	{
	    if (pPrev)
		pPrev->next = pReq->next;
	    else
		pPending = pReq->next;
	    break;
	}
    if (pRequest->notifyFunc)
	(*pRequest->notifyFunc) (pRequest->pClient, pRequest->closure);
    free(pRequest);
    return TRUE;
}

static void
SertafiedBlockHandler (pointer data, OSTimePtr wt, pointer LastSelectMask)
{
    SertafiedPtr	    pReq, pNext;
    unsigned long	    delay;
    TimeStamp		    now;

    if (!pPending)
	return;
    now.milliseconds = GetTimeInMillis ();
    now.months = currentTime.months;
    if ((int) (now.milliseconds - currentTime.milliseconds) < 0)
	now.months++;
    for (pReq = pPending; pReq; pReq = pNext)
    {
	pNext = pReq->next;
	if (CompareTimeStamps (pReq->revive, now) == LATER)
	    break;
	FreeResource (pReq->id, RT_NONE);

 	/* AttendClient() may have been called via the resource delete
 	 * function so a client may have input to be processed and so
 	 *  set delay to 0 to prevent blocking in WaitForSomething().
 	 */
 	AdjustWaitForDelay (wt, 0);
    }
    pReq = pPending;
    if (!pReq)
	return;
    delay = pReq->revive.milliseconds - now.milliseconds;
    AdjustWaitForDelay (wt, delay);
}

static void
SertafiedWakeupHandler (pointer data, int i, pointer LastSelectMask)
{
    SertafiedPtr	pReq, pNext;
    TimeStamp		now;

    now.milliseconds = GetTimeInMillis ();
    now.months = currentTime.months;
    if ((int) (now.milliseconds - currentTime.milliseconds) < 0)
	now.months++;
    for (pReq = pPending; pReq; pReq = pNext)
    {
	pNext = pReq->next;
	if (CompareTimeStamps (pReq->revive, now) == LATER)
	    break;
	FreeResource (pReq->id, RT_NONE);
    }
    if (!pPending)
    {
	RemoveBlockAndWakeupHandlers (SertafiedBlockHandler,
				      SertafiedWakeupHandler,
				      (pointer) 0);
	BlockHandlerRegistered = FALSE;
    }
}
/*
 * Copyright (C) 2001 The XFree86 Project, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _SLEEPUNTIL_H_
#define _SLEEPUNTIL_H_ 1

#include "dix.h"

extern int ClientSleepUntil(
    ClientPtr client,
    TimeStamp *revive,
    void (*notifyFunc)(
	ClientPtr /* client */,
	pointer   /* closure */
	),
    pointer Closure
);

#endif
/*

Copyright 1991, 1993, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.


Copyright 1991, 1993 by Digital Equipment Corporation, Maynard, Massachusetts,
and Olivetti Research Limited, Cambridge, England.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or Olivetti
not be used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  Digital and Olivetti
make no representations about the suitability of this software
for any purpose.  It is provided "as is" without express or implied warranty.

DIGITAL AND OLIVETTI DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL THEY BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xmd.h>
#include "scrnintstr.h"
#include "os.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "pixmapstr.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/syncproto.h>
#include "syncsrv.h"
#include "syncsdk.h"
#include "protocol-versions.h"

#include <stdio.h>
#if !defined(WIN32)
#include <sys/time.h>
#endif

#include "modinit.h"

/*
 * Local Global Variables
 */
static int      SyncEventBase;
static int      SyncErrorBase;
static RESTYPE  RTCounter = 0;
static RESTYPE  RTAwait;
static RESTYPE  RTAlarm;
static RESTYPE  RTAlarmClient;
static RESTYPE  RTFence;
static int SyncNumSystemCounters = 0;
static SyncCounter **SysCounterList = NULL;
static int SyncNumInvalidCounterWarnings = 0;
#define MAX_INVALID_COUNTER_WARNINGS	   5

static const char *WARN_INVALID_COUNTER_COMPARE =
"Warning: Non-counter XSync object using Counter-only\n"
"         comparison.  Result will never be true.\n";

static const char *WARN_INVALID_COUNTER_ALARM =
"Warning: Non-counter XSync object used in alarm.  This is\n"
"         the result of a programming error in the X server.\n";

#define IsSystemCounter(pCounter) \
    (pCounter && (pCounter->sync.client == NULL))

/* these are all the alarm attributes that pertain to the alarm's trigger */
#define XSyncCAAllTrigger \
    (XSyncCACounter | XSyncCAValueType | XSyncCAValue | XSyncCATestType)

static void SyncComputeBracketValues(SyncCounter *);

static void SyncInitServerTime(void);

static void SyncInitIdleTime(void);

static Bool
SyncCheckWarnIsCounter(const SyncObject* pSync, const char *warning)
{
    if (pSync && (SYNC_COUNTER != pSync->type))
    {
	if (SyncNumInvalidCounterWarnings++ < MAX_INVALID_COUNTER_WARNINGS)
	{
	    ErrorF("%s", warning);
	    ErrorF("         Counter type: %d\n", pSync->type);
	}

	return FALSE;
    }

    return TRUE;
}

/*  Each counter maintains a simple linked list of triggers that are
 *  interested in the counter.  The two functions below are used to
 *  delete and add triggers on this list.
 */
static void
SyncDeleteTriggerFromSyncObject(SyncTrigger *pTrigger)
{
    SyncTriggerList *pCur;
    SyncTriggerList *pPrev;
    SyncCounter *pCounter;

    /* pSync needs to be stored in pTrigger before calling here. */

    if (!pTrigger->pSync)
	return;

    pPrev = NULL;
    pCur = pTrigger->pSync->pTriglist;

    while (pCur)
    {
	if (pCur->pTrigger == pTrigger)
	{
	    if (pPrev)
		pPrev->next = pCur->next;
	    else
		pTrigger->pSync->pTriglist = pCur->next;

	    free(pCur);
	    break;
	}
	
	pPrev = pCur;
	pCur = pCur->next;
    }

    if (SYNC_COUNTER == pTrigger->pSync->type)
    {
	pCounter = (SyncCounter *)pTrigger->pSync;

	if (IsSystemCounter(pCounter))
	    SyncComputeBracketValues(pCounter);
    } else if (SYNC_FENCE == pTrigger->pSync->type) {
	SyncFence* pFence = (SyncFence*) pTrigger->pSync;
	pFence->funcs.DeleteTrigger(pTrigger);
    }
}


static int
SyncAddTriggerToSyncObject(SyncTrigger *pTrigger)
{
    SyncTriggerList *pCur;
    SyncCounter *pCounter;

    if (!pTrigger->pSync)
	return Success;

    /* don't do anything if it's already there */
    for (pCur = pTrigger->pSync->pTriglist; pCur; pCur = pCur->next)
    {
	if (pCur->pTrigger == pTrigger)
	    return Success;
    }

    if (!(pCur = malloc(sizeof(SyncTriggerList))))
	return BadAlloc;

    pCur->pTrigger = pTrigger;
    pCur->next = pTrigger->pSync->pTriglist;
    pTrigger->pSync->pTriglist = pCur;

    if (SYNC_COUNTER == pTrigger->pSync->type)
    {
	pCounter = (SyncCounter *)pTrigger->pSync;

	if (IsSystemCounter(pCounter))
	    SyncComputeBracketValues(pCounter);
    } else if (SYNC_FENCE == pTrigger->pSync->type) {
	SyncFence* pFence = (SyncFence*) pTrigger->pSync;
	pFence->funcs.AddTrigger(pTrigger);
    }

    return Success;
}


/*  Below are five possible functions that can be plugged into
 *  pTrigger->CheckTrigger for counter sync objects, corresponding to
 *  the four possible test-types, and the one possible function that
 *  can be plugged into pTrigger->CheckTrigger for fence sync objects.
 *  These functions are called after the sync object's state changes
 *  but are also passed the old state so they can inspect both the old
 *  and new values.  (PositiveTransition and NegativeTransition need to
 *  see both pieces of information.)  These functions return the truth
 *  value of the trigger.
 *
 *  All of them include the condition pTrigger->pSync == NULL.
 *  This is because the spec says that a trigger with a sync value
 *  of None is always TRUE.
 */

static Bool
SyncCheckTriggerPositiveComparison(SyncTrigger *pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
	return FALSE;

    pCounter = (SyncCounter *)pTrigger->pSync;

    return (pCounter == NULL ||
	    XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value));
}

static Bool
SyncCheckTriggerNegativeComparison(SyncTrigger *pTrigger,  CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
	return FALSE;

    pCounter = (SyncCounter *)pTrigger->pSync;

    return (pCounter == NULL ||
	    XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value));
}

static Bool
SyncCheckTriggerPositiveTransition(SyncTrigger *pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
	return FALSE;

    pCounter = (SyncCounter *)pTrigger->pSync;

    return (pCounter == NULL ||
	    (XSyncValueLessThan(oldval, pTrigger->test_value) &&
	     XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value)));
}

static Bool
SyncCheckTriggerNegativeTransition(SyncTrigger *pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
	return FALSE;

    pCounter = (SyncCounter *)pTrigger->pSync;

    return (pCounter == NULL ||
	    (XSyncValueGreaterThan(oldval, pTrigger->test_value) &&
	     XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value)));
}

static Bool
SyncCheckTriggerFence(SyncTrigger *pTrigger, CARD64 unused)
{
    SyncFence* pFence = (SyncFence*) pTrigger->pSync;
    (void)unused;

    return (pFence == NULL ||
	    pFence->funcs.CheckTriggered(pFence));
}

static int
SyncInitTrigger(ClientPtr client, SyncTrigger *pTrigger, XID syncObject,
		RESTYPE resType, Mask changes)
{
    SyncObject *pSync = pTrigger->pSync;
    SyncCounter *pCounter = NULL;
    int		rc;
    Bool	newSyncObject = FALSE;

    if (changes & XSyncCACounter)
    {
	if (syncObject == None)
	    pSync = NULL;
	else if (Success != (rc = dixLookupResourceByType ((pointer *)&pSync,
				syncObject, resType, client, DixReadAccess)))
	{
	    client->errorValue = syncObject;
	    return rc;
	}
	if (pSync != pTrigger->pSync)
	{ /* new counter for trigger */
	    SyncDeleteTriggerFromSyncObject(pTrigger);
	    pTrigger->pSync = pSync;
	    newSyncObject = TRUE;
	}
    }

    /* if system counter, ask it what the current value is */

    if (pSync && SYNC_COUNTER == pSync->type)
    {
	pCounter = (SyncCounter *)pSync;

	if (IsSystemCounter(pCounter))
	{
	    (*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
						      &pCounter->value);
	}
    }

    if (changes & XSyncCAValueType)
    {
	if (pTrigger->value_type != XSyncRelative &&
	    pTrigger->value_type != XSyncAbsolute)
	{
	    client->errorValue = pTrigger->value_type;
	    return BadValue;
	}
    }

    if (changes & XSyncCATestType)
    {

	if (pSync && SYNC_FENCE == pSync->type)
	{
	    pTrigger->CheckTrigger = SyncCheckTriggerFence;
	}
	else
	{
	    /* select appropriate CheckTrigger function */

	    switch (pTrigger->test_type)
	    {
	    case XSyncPositiveTransition:
		pTrigger->CheckTrigger = SyncCheckTriggerPositiveTransition;
		break;
	    case XSyncNegativeTransition:
		pTrigger->CheckTrigger = SyncCheckTriggerNegativeTransition;
		break;
	    case XSyncPositiveComparison:
		pTrigger->CheckTrigger = SyncCheckTriggerPositiveComparison;
		break;
	    case XSyncNegativeComparison:
		pTrigger->CheckTrigger = SyncCheckTriggerNegativeComparison;
		break;
	    default:
		client->errorValue = pTrigger->test_type;
		return BadValue;
	    }
	}
    }

    if (changes & (XSyncCAValueType | XSyncCAValue))
    {
	if (pTrigger->value_type == XSyncAbsolute)
	    pTrigger->test_value = pTrigger->wait_value;
	else /* relative */
	{
	    Bool overflow;
	    if (pCounter == NULL)
		return BadMatch;

	    XSyncValueAdd(&pTrigger->test_value, pCounter->value,
			  pTrigger->wait_value, &overflow);
	    if (overflow)
	    {
		client->errorValue = XSyncValueHigh32(pTrigger->wait_value);
		return BadValue;
	    }
	}
    }

    /*  we wait until we're sure there are no errors before registering
     *  a new counter on a trigger
     */
    if (newSyncObject)
    {
	if ((rc = SyncAddTriggerToSyncObject(pTrigger)) != Success)
	    return rc;
    }
    else if (pCounter && IsSystemCounter(pCounter))
    {
	SyncComputeBracketValues(pCounter);
    }

    return Success;
}

/*  AlarmNotify events happen in response to actions taken on an Alarm or
 *  the counter used by the alarm.  AlarmNotify may be sent to multiple
 *  clients.  The alarm maintains a list of clients interested in events.
 */
static void
SyncSendAlarmNotifyEvents(SyncAlarm *pAlarm)
{
    SyncAlarmClientList *pcl;
    xSyncAlarmNotifyEvent ane;
    SyncTrigger *pTrigger = &pAlarm->trigger;
    SyncCounter *pCounter;

    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_ALARM))
	return;

    pCounter = (SyncCounter *)pTrigger->pSync;

    UpdateCurrentTime();

    ane.type = SyncEventBase + XSyncAlarmNotify;
    ane.kind = XSyncAlarmNotify;
    ane.alarm = pAlarm->alarm_id;
    if (pTrigger->pSync && SYNC_COUNTER == pTrigger->pSync->type)
    {
	ane.counter_value_hi = XSyncValueHigh32(pCounter->value);
	ane.counter_value_lo = XSyncValueLow32(pCounter->value);
    }
    else
    { /* XXX what else can we do if there's no counter? */
	ane.counter_value_hi = ane.counter_value_lo = 0;
    }

    ane.alarm_value_hi = XSyncValueHigh32(pTrigger->test_value);
    ane.alarm_value_lo = XSyncValueLow32(pTrigger->test_value);
    ane.time = currentTime.milliseconds;
    ane.state = pAlarm->state;

    /* send to owner */
    if (pAlarm->events)
	WriteEventsToClient(pAlarm->client, 1, (xEvent *) &ane);

    /* send to other interested clients */
    for (pcl = pAlarm->pEventClients; pcl; pcl = pcl->next)
	WriteEventsToClient(pcl->client, 1, (xEvent *) &ane);
}


/*  CounterNotify events only occur in response to an Await.  The events
 *  go only to the Awaiting client.
 */
static void
SyncSendCounterNotifyEvents(ClientPtr client, SyncAwait **ppAwait,
			    int num_events)
{
    xSyncCounterNotifyEvent *pEvents, *pev;
    int i;

    if (client->clientGone)
	return;
    pev = pEvents = malloc(num_events * sizeof(xSyncCounterNotifyEvent));
    if (!pEvents)
	return;
    UpdateCurrentTime();
    for (i = 0; i < num_events; i++, ppAwait++, pev++)
    {
	SyncTrigger *pTrigger = &(*ppAwait)->trigger;
	pev->type = SyncEventBase + XSyncCounterNotify;
	pev->kind = XSyncCounterNotify;
	pev->counter = pTrigger->pSync->id;
	pev->wait_value_lo = XSyncValueLow32(pTrigger->test_value);
	pev->wait_value_hi = XSyncValueHigh32(pTrigger->test_value);
	if (SYNC_COUNTER == pTrigger->pSync->type)
	{
	    SyncCounter *pCounter = (SyncCounter *)pTrigger->pSync;

	    pev->counter_value_lo = XSyncValueLow32(pCounter->value);
	    pev->counter_value_hi = XSyncValueHigh32(pCounter->value);
	}
	else
	{
	    pev->counter_value_lo = 0;
	    pev->counter_value_hi = 0;
	}

	pev->time = currentTime.milliseconds;
	pev->count = num_events - i - 1; /* events remaining */
	pev->destroyed = pTrigger->pSync->beingDestroyed;
    }
    /* swapping will be taken care of by this */
    WriteEventsToClient(client, num_events, (xEvent *)pEvents);
    free(pEvents);
}


/* This function is called when an alarm's counter is destroyed.
 * It is plugged into pTrigger->CounterDestroyed (for alarm triggers).
 */
static void
SyncAlarmCounterDestroyed(SyncTrigger *pTrigger)
{
    SyncAlarm *pAlarm = (SyncAlarm *)pTrigger;

    pAlarm->state = XSyncAlarmInactive;
    SyncSendAlarmNotifyEvents(pAlarm);
    pTrigger->pSync = NULL;
}


/*  This function is called when an alarm "goes off."
 *  It is plugged into pTrigger->TriggerFired (for alarm triggers).
 */
static void
SyncAlarmTriggerFired(SyncTrigger *pTrigger)
{
    SyncAlarm *pAlarm = (SyncAlarm *)pTrigger;
    SyncCounter *pCounter;
    CARD64 new_test_value;

    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_ALARM))
	return;

    pCounter = (SyncCounter *)pTrigger->pSync;

    /* no need to check alarm unless it's active */
    if (pAlarm->state != XSyncAlarmActive)
	return;

    /*  " if the counter value is None, or if the delta is 0 and
     *    the test-type is PositiveComparison or NegativeComparison,
     *    no change is made to value (test-value) and the alarm
     *    state is changed to Inactive before the event is generated."
     */
    if (pCounter == NULL
	|| (XSyncValueIsZero(pAlarm->delta)
	    && (pAlarm->trigger.test_type == XSyncPositiveComparison
		|| pAlarm->trigger.test_type == XSyncNegativeComparison)))
	pAlarm->state = XSyncAlarmInactive;

    new_test_value = pAlarm->trigger.test_value;

    if (pAlarm->state == XSyncAlarmActive)
    {
	Bool overflow;
	CARD64 oldvalue;
	SyncTrigger *paTrigger = &pAlarm->trigger;
	SyncCounter *paCounter;

	if (!SyncCheckWarnIsCounter(paTrigger->pSync,
				    WARN_INVALID_COUNTER_ALARM))
	    return;

	paCounter = (SyncCounter *)pTrigger->pSync;

	/* "The alarm is updated by repeatedly adding delta to the
	 *  value of the trigger and re-initializing it until it
	 *  becomes FALSE."
	 */
	oldvalue = paTrigger->test_value;

	/* XXX really should do something smarter here */

	do
	{
	    XSyncValueAdd(&paTrigger->test_value, paTrigger->test_value,
			  pAlarm->delta, &overflow);
	} while (!overflow &&
	      (*paTrigger->CheckTrigger)(paTrigger,
					paCounter->value));

	new_test_value = paTrigger->test_value;
	paTrigger->test_value = oldvalue;

	/* "If this update would cause value to fall outside the range
	 *  for an INT64...no change is made to value (test-value) and
	 *  the alarm state is changed to Inactive before the event is
	 *  generated."
	 */
	if (overflow)
	{
	    new_test_value = oldvalue;
	    pAlarm->state = XSyncAlarmInactive;
	}
    }
    /*  The AlarmNotify event has to have the "new state of the alarm"
     *  which we can't be sure of until this point.  However, it has
     *  to have the "old" trigger test value.  That's the reason for
     *  all the newvalue/oldvalue shuffling above.  After we send the
     *  events, give the trigger its new test value.
     */
    SyncSendAlarmNotifyEvents(pAlarm);
    pTrigger->test_value = new_test_value;
}


/*  This function is called when an Await unblocks, either as a result
 *  of the trigger firing OR the counter being destroyed.
 *  It goes into pTrigger->TriggerFired AND pTrigger->CounterDestroyed
 *  (for Await triggers).
 */
static void
SyncAwaitTriggerFired(SyncTrigger *pTrigger)
{
    SyncAwait *pAwait = (SyncAwait *)pTrigger;
    int numwaits;
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait **ppAwait;
    int num_events = 0;

    pAwaitUnion = (SyncAwaitUnion *)pAwait->pHeader;
    numwaits = pAwaitUnion->header.num_waitconditions;
    ppAwait = malloc(numwaits * sizeof(SyncAwait *));
    if (!ppAwait)
	goto bail;

    pAwait = &(pAwaitUnion+1)->await;

    /* "When a client is unblocked, all the CounterNotify events for
     *  the Await request are generated contiguously. If count is 0
     *  there are no more events to follow for this request. If
     *  count is n, there are at least n more events to follow."
     *
     *  Thus, it is best to find all the counters for which events
     *  need to be sent first, so that an accurate count field can
     *  be stored in the events.
     */
    for ( ; numwaits; numwaits--, pAwait++)
    {
	CARD64 diff;
	Bool overflow, diffgreater, diffequal;

	/* "A CounterNotify event with the destroyed flag set to TRUE is
	 *  always generated if the counter for one of the triggers is
	 *  destroyed."
	 */
	if (pAwait->trigger.pSync->beingDestroyed)
	{
	    ppAwait[num_events++] = pAwait;
	    continue;
	}
	
	if (SYNC_COUNTER == pAwait->trigger.pSync->type)
	{
	    SyncCounter *pCounter = (SyncCounter *) pAwait->trigger.pSync;

	    /* "The difference between the counter and the test value is
	     *  calculated by subtracting the test value from the value of
	     *  the counter."
	     */
	    XSyncValueSubtract(&diff, pCounter->value,
			       pAwait->trigger.test_value, &overflow);

	    /* "If the difference lies outside the range for an INT64, an
	     *  event is not generated."
	     */
	    if (overflow)
		continue;
	    diffgreater = XSyncValueGreaterThan(diff, pAwait->event_threshold);
	    diffequal   = XSyncValueEqual(diff, pAwait->event_threshold);

	    /* "If the test-type is PositiveTransition or
	     *  PositiveComparison, a CounterNotify event is generated if
	     *  the difference is at least event-threshold. If the test-type
	     *  is NegativeTransition or NegativeComparison, a CounterNotify
	     *  event is generated if the difference is at most
	     *  event-threshold."
	     */

	    if ( ((pAwait->trigger.test_type == XSyncPositiveComparison ||
		   pAwait->trigger.test_type == XSyncPositiveTransition)
		  && (diffgreater || diffequal))
		 ||
		 ((pAwait->trigger.test_type == XSyncNegativeComparison ||
		   pAwait->trigger.test_type == XSyncNegativeTransition)
		  && (!diffgreater) /* less or equal */
		 )
	       )
	    {
		ppAwait[num_events++] = pAwait;
	    }
	}
    }
    if (num_events)
	SyncSendCounterNotifyEvents(pAwaitUnion->header.client, ppAwait,
				    num_events);
    free(ppAwait);

bail:
    /* unblock the client */
    AttendClient(pAwaitUnion->header.client);
    /* delete the await */
    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
}


/*  This function should always be used to change a counter's value so that
 *  any triggers depending on the counter will be checked.
 */
void
SyncChangeCounter(SyncCounter *pCounter, CARD64 newval)
{
    SyncTriggerList       *ptl, *pnext;
    CARD64 oldval;

    oldval = pCounter->value;
    pCounter->value = newval;

    /* run through triggers to see if any become true */
    for (ptl = pCounter->sync.pTriglist; ptl; ptl = pnext)
    {
	pnext = ptl->next;
	if ((*ptl->pTrigger->CheckTrigger)(ptl->pTrigger, oldval))
	    (*ptl->pTrigger->TriggerFired)(ptl->pTrigger);
    }

    if (IsSystemCounter(pCounter))
    {
	SyncComputeBracketValues(pCounter);
    }
}


/* loosely based on dix/events.c/EventSelectForWindow */
static Bool
SyncEventSelectForAlarm(SyncAlarm *pAlarm, ClientPtr client, Bool wantevents)
{
    SyncAlarmClientList *pClients;

    if (client == pAlarm->client) /* alarm owner */
    {
	pAlarm->events = wantevents;
	return Success;
    }

    /* see if the client is already on the list (has events selected) */

    for (pClients = pAlarm->pEventClients; pClients;
	 pClients = pClients->next)
    {
	if (pClients->client == client)
	{
	    /* client's presence on the list indicates desire for
	     * events.  If the client doesn't want events, remove it
	     * from the list.  If the client does want events, do
	     * nothing, since it's already got them.
	     */
	    if (!wantevents)
	    {
		FreeResource(pClients->delete_id, RT_NONE);
	    }
	    return Success;
	}
    }

    /*  if we get here, this client does not currently have
     *  events selected on the alarm
     */

    if (!wantevents)
	/* client doesn't want events, and we just discovered that it
	 * doesn't have them, so there's nothing to do.
	 */
	return Success;

    /* add new client to pAlarm->pEventClients */

    pClients = malloc(sizeof(SyncAlarmClientList));
    if (!pClients)
	return BadAlloc;

    /*  register it as a resource so it will be cleaned up
     *  if the client dies
     */

    pClients->delete_id = FakeClientID(client->index);

    /* link it into list after we know all the allocations succeed */
    pClients->next = pAlarm->pEventClients;
    pAlarm->pEventClients = pClients;
    pClients->client = client;

    if (!AddResource(pClients->delete_id, RTAlarmClient, pAlarm))
	return BadAlloc;

    return Success;
}

/*
 * ** SyncChangeAlarmAttributes ** This is used by CreateAlarm and ChangeAlarm
 */
static int
SyncChangeAlarmAttributes(ClientPtr client, SyncAlarm *pAlarm, Mask mask,
			  CARD32 *values)
{
    int		   status;
    XSyncCounter   counter;
    Mask	   origmask = mask;

    counter =
	pAlarm->trigger.pSync ? pAlarm->trigger.pSync->id : None;

    while (mask)
    {
	int    index2 = lowbit(mask);
	mask &= ~index2;
	switch (index2)
	{
	  case XSyncCACounter:
	    mask &= ~XSyncCACounter;
	    /* sanity check in SyncInitTrigger */
	    counter = *values++;
	    break;

	  case XSyncCAValueType:
	    mask &= ~XSyncCAValueType;
	    /* sanity check in SyncInitTrigger */
	    pAlarm->trigger.value_type = *values++;
	    break;

	  case XSyncCAValue:
	    mask &= ~XSyncCAValue;
	    XSyncIntsToValue(&pAlarm->trigger.wait_value, values[1], values[0]);
	    values += 2;
	    break;

	  case XSyncCATestType:
	    mask &= ~XSyncCATestType;
	    /* sanity check in SyncInitTrigger */
	    pAlarm->trigger.test_type = *values++;
	    break;

	  case XSyncCADelta:
	    mask &= ~XSyncCADelta;
	    XSyncIntsToValue(&pAlarm->delta, values[1], values[0]);
	    values += 2;
	    break;

	  case XSyncCAEvents:
	    mask &= ~XSyncCAEvents;
	    if ((*values != xTrue) && (*values != xFalse))
	    {
		client->errorValue = *values;
		return BadValue;
	    }
	    status = SyncEventSelectForAlarm(pAlarm, client,
					     (Bool)(*values++));
	    if (status != Success)
		return status;
	    break;

	  default:
	    client->errorValue = mask;
	    return BadValue;
	}
    }

    /* "If the test-type is PositiveComparison or PositiveTransition
     *  and delta is less than zero, or if the test-type is
     *  NegativeComparison or NegativeTransition and delta is
     *  greater than zero, a Match error is generated."
     */
    if (origmask & (XSyncCADelta|XSyncCATestType))
    {
	CARD64 zero;
	XSyncIntToValue(&zero, 0);
	if ((((pAlarm->trigger.test_type == XSyncPositiveComparison) ||
	      (pAlarm->trigger.test_type == XSyncPositiveTransition))
	     && XSyncValueLessThan(pAlarm->delta, zero))
	    ||
	    (((pAlarm->trigger.test_type == XSyncNegativeComparison) ||
	      (pAlarm->trigger.test_type == XSyncNegativeTransition))
	     && XSyncValueGreaterThan(pAlarm->delta, zero))
	   )
	{
	    return BadMatch;
	}
    }

    /* postpone this until now, when we're sure nothing else can go wrong */
    if ((status = SyncInitTrigger(client, &pAlarm->trigger, counter, RTCounter,
			     origmask & XSyncCAAllTrigger)) != Success)
	return status;

    /* XXX spec does not really say to do this - needs clarification */
    pAlarm->state = XSyncAlarmActive;
    return Success;
}

static SyncObject *
SyncCreate(ClientPtr client, XID id, unsigned char type)
{
    SyncObject *pSync;

    switch (type) {
    case SYNC_COUNTER:
	pSync = malloc(sizeof(SyncCounter));
	break;
    case SYNC_FENCE:
	pSync = (SyncObject*)dixAllocateObjectWithPrivates(SyncFence,
							   PRIVATE_SYNC_FENCE);
	break;
    default:
	return NULL;
    }

    if (!pSync)
	return NULL;

    pSync->client = client;
    pSync->id = id;
    pSync->pTriglist = NULL;
    pSync->beingDestroyed = FALSE;
    pSync->type = type;

    return pSync;
}


static SyncCounter *
SyncCreateCounter(ClientPtr client, XSyncCounter id, CARD64 initialvalue)
{
    SyncCounter *pCounter;

    if (!(pCounter = (SyncCounter *)SyncCreate(client,
					       id,
					       SYNC_COUNTER)))
	return NULL;

    pCounter->value = initialvalue;
    pCounter->pSysCounterInfo = NULL;

    if (!AddResource(id, RTCounter, (pointer) pCounter))
	return NULL;

    return pCounter;
}

static int FreeCounter(void *, XID);

/*
 * ***** System Counter utilities
 */

pointer
SyncCreateSystemCounter(
	char *name,
	CARD64 initial,
	CARD64 resolution,
	SyncCounterType counterType,
	void (*QueryValue)(pointer /* pCounter */,
	      	           CARD64 * /* pValue_return */),
	void (*BracketValues)(pointer /* pCounter */,
	       	              CARD64 * /* pbracket_less */,
	                      CARD64 * /* pbracket_greater */)
	)
{
    SyncCounter    *pCounter;

    SysCounterList = realloc(SysCounterList,
			    (SyncNumSystemCounters+1)*sizeof(SyncCounter *));
    if (!SysCounterList)
	return NULL;

    /* this function may be called before SYNC has been initialized, so we
     * have to make sure RTCounter is created.
     */
    if (RTCounter == 0)
    {
	RTCounter = CreateNewResourceType(FreeCounter, "SyncCounter");
	if (RTCounter == 0)
	{
	    return NULL;
	}
    }

    pCounter = SyncCreateCounter(NULL, FakeClientID(0), initial);

    if (pCounter)
    {
	SysCounterInfo *psci;

	psci = malloc(sizeof(SysCounterInfo));
	if (!psci)
	{
	    FreeResource(pCounter->sync.id, RT_NONE);
	    return pCounter;
	}
	pCounter->pSysCounterInfo = psci;
	psci->name = name;
	psci->resolution = resolution;
	psci->counterType = counterType;
	psci->QueryValue = QueryValue;
	psci->BracketValues = BracketValues;
	XSyncMaxValue(&psci->bracket_greater);
	XSyncMinValue(&psci->bracket_less);
	SysCounterList[SyncNumSystemCounters++] = pCounter;
    }
    return pCounter;
}

void
SyncDestroySystemCounter(pointer pSysCounter)
{
    SyncCounter *pCounter = (SyncCounter *)pSysCounter;
    FreeResource(pCounter->sync.id, RT_NONE);
}

static void
SyncComputeBracketValues(SyncCounter *pCounter)
{
    SyncTriggerList *pCur;
    SyncTrigger *pTrigger;
    SysCounterInfo *psci;
    CARD64 *pnewgtval = NULL;
    CARD64 *pnewltval = NULL;
    SyncCounterType ct;

    if (!pCounter)
	return;

    psci = pCounter->pSysCounterInfo;
    ct = pCounter->pSysCounterInfo->counterType;
    if (ct == XSyncCounterNeverChanges)
	return;

    XSyncMaxValue(&psci->bracket_greater);
    XSyncMinValue(&psci->bracket_less);

    for (pCur = pCounter->sync.pTriglist; pCur; pCur = pCur->next)
    {
	pTrigger = pCur->pTrigger;
	
        if (pTrigger->test_type == XSyncPositiveComparison &&
	    ct != XSyncCounterNeverIncreases)
	{
	    if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueLessThan(pTrigger->test_value,
				   psci->bracket_greater))
	    {
		psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    }
	}
	else if (pTrigger->test_type == XSyncNegativeComparison &&
		 ct != XSyncCounterNeverDecreases)
	{
	    if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueGreaterThan(pTrigger->test_value,
				      psci->bracket_less))
	    {
		psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    }
	}
	else if (pTrigger->test_type == XSyncNegativeTransition &&
		   ct != XSyncCounterNeverIncreases)
	{
	    if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueGreaterThan(pTrigger->test_value, psci->bracket_less))
	    {
		psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    } else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
		       XSyncValueLessThan(pTrigger->test_value,
					  psci->bracket_greater))
	    {
	        /*
		 * The value is exactly equal to our threshold.  We want one
		 * more event in the positive direction to ensure we pick up
		 * when the value *exceeds* this threshold.
		 */
	        psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    }
	}
        else if (pTrigger->test_type == XSyncPositiveTransition &&
		  ct != XSyncCounterNeverDecreases)
	{
	    if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueLessThan(pTrigger->test_value, psci->bracket_greater))
	    {
		psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    } else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
		       XSyncValueGreaterThan(pTrigger->test_value,
					     psci->bracket_less))
	    {
	        /*
		 * The value is exactly equal to our threshold.  We want one
		 * more event in the negative direction to ensure we pick up
		 * when the value is less than this threshold.
		 */
	        psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    }
	}
    } /* end for each trigger */

    if (pnewgtval || pnewltval)
    {
	(*psci->BracketValues)((pointer)pCounter, pnewltval, pnewgtval);
    }
}

/*
 * *****  Resource delete functions
 */

/* ARGSUSED */
static int
FreeAlarm(void *addr, XID id)
{
    SyncAlarm      *pAlarm = (SyncAlarm *) addr;

    pAlarm->state = XSyncAlarmDestroyed;

    SyncSendAlarmNotifyEvents(pAlarm);

    /* delete event selections */

    while (pAlarm->pEventClients)
	FreeResource(pAlarm->pEventClients->delete_id, RT_NONE);

    SyncDeleteTriggerFromSyncObject(&pAlarm->trigger);

    free(pAlarm);
    return Success;
}


/*
 * ** Cleanup after the destruction of a Counter
 */
/* ARGSUSED */
static int
FreeCounter(void *env, XID id)
{
    SyncCounter     *pCounter = (SyncCounter *) env;
    SyncTriggerList *ptl, *pnext;

    pCounter->sync.beingDestroyed = TRUE;
    /* tell all the counter's triggers that the counter has been destroyed */
    for (ptl = pCounter->sync.pTriglist; ptl; ptl = pnext)
    {
	(*ptl->pTrigger->CounterDestroyed)(ptl->pTrigger);
	pnext = ptl->next;
	free(ptl); /* destroy the trigger list as we go */
    }
    if (IsSystemCounter(pCounter))
    {
	int i, found = 0;

	free(pCounter->pSysCounterInfo);

	/* find the counter in the list of system counters and remove it */

	if (SysCounterList)
	{
	    for (i = 0; i < SyncNumSystemCounters; i++)
	    {
		if (SysCounterList[i] == pCounter)
		{
		    found = i;
		    break;
		}
	    }
	    if (found < (SyncNumSystemCounters-1))
	    {
		for (i = found; i < SyncNumSystemCounters-1; i++)
		{
		    SysCounterList[i] = SysCounterList[i+1];
		}
	    }
	}
	SyncNumSystemCounters--;
    }
    free(pCounter);
    return Success;
}

/*
 * ** Cleanup after Await
 */
/* ARGSUSED */
static int
FreeAwait(void *addr, XID id)
{
    SyncAwaitUnion *pAwaitUnion = (SyncAwaitUnion *) addr;
    SyncAwait *pAwait;
    int numwaits;

    pAwait = &(pAwaitUnion+1)->await; /* first await on list */

    /* remove triggers from counters */

    for (numwaits = pAwaitUnion->header.num_waitconditions; numwaits;
	 numwaits--, pAwait++)
    {
	/* If the counter is being destroyed, FreeCounter will delete
	 * the trigger list itself, so don't do it here.
	 */
	SyncObject *pSync = pAwait->trigger.pSync;
	if (pSync && !pSync->beingDestroyed)
	    SyncDeleteTriggerFromSyncObject(&pAwait->trigger);
    }
    free(pAwaitUnion);
    return Success;
}

/* loosely based on dix/events.c/OtherClientGone */
static int
FreeAlarmClient(void *value, XID id)
{
    SyncAlarm *pAlarm = (SyncAlarm *)value;
    SyncAlarmClientList *pCur, *pPrev;

    for (pPrev = NULL, pCur = pAlarm->pEventClients;
	 pCur;
	 pPrev = pCur, pCur = pCur->next)
    {
	if (pCur->delete_id == id)
	{
	    if (pPrev)
		pPrev->next = pCur->next;
	    else
		pAlarm->pEventClients = pCur->next;
	    free(pCur);
	    return Success;
	}
    }
    FatalError("alarm client not on event list");
    /*NOTREACHED*/
}


/*
 * *****  Proc functions
 */


/*
 * ** Initialize the extension
 */
static int
ProcSyncInitialize(ClientPtr client)
{
    xSyncInitializeReply  rep;
    int   n;

    REQUEST_SIZE_MATCH(xSyncInitializeReq);

    memset(&rep, 0, sizeof(xSyncInitializeReply));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SYNC_MAJOR_VERSION;
    rep.minorVersion = SERVER_SYNC_MINOR_VERSION;
    rep.length = 0;

    if (client->swapped)
    {
	swaps(&rep.sequenceNumber, n);
    }
    WriteToClient(client, sizeof(rep), (char *) &rep);
    return Success;
}

/*
 * ** Get list of system counters available through the extension
 */
static int
ProcSyncListSystemCounters(ClientPtr client)
{
    xSyncListSystemCountersReply  rep;
    int i, len;
    xSyncSystemCounter *list = NULL, *walklist = NULL;

    REQUEST_SIZE_MATCH(xSyncListSystemCountersReq);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.nCounters = SyncNumSystemCounters;

    for (i = len = 0; i < SyncNumSystemCounters; i++)
    {
	char *name = SysCounterList[i]->pSysCounterInfo->name;
	/* pad to 4 byte boundary */
	len += pad_to_int32(sz_xSyncSystemCounter + strlen(name));
    }

    if (len)
    {
	walklist = list = malloc(len);
	if (!list)
	    return BadAlloc;
    }

    rep.length = bytes_to_int32(len);

    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.nCounters, n);
    }

    for (i = 0; i < SyncNumSystemCounters; i++)
    {
	int namelen;
	char *pname_in_reply;
	SysCounterInfo *psci = SysCounterList[i]->pSysCounterInfo;

	walklist->counter = SysCounterList[i]->sync.id;
	walklist->resolution_hi = XSyncValueHigh32(psci->resolution);
	walklist->resolution_lo = XSyncValueLow32(psci->resolution);
	namelen = strlen(psci->name);
	walklist->name_length = namelen;

	if (client->swapped)
	{
	    char n;
	    swapl(&walklist->counter, n);
	    swapl(&walklist->resolution_hi, n);
	    swapl(&walklist->resolution_lo, n);
	    swaps(&walklist->name_length, n);
	}

	pname_in_reply = ((char *)walklist) + sz_xSyncSystemCounter;
	strncpy(pname_in_reply, psci->name, namelen);
	walklist = (xSyncSystemCounter *) (((char *)walklist) +
				pad_to_int32(sz_xSyncSystemCounter + namelen));
    }

    WriteToClient(client, sizeof(rep), (char *) &rep);
    if (len)
    {
	WriteToClient(client, len, (char *) list);
	free(list);
    }

    return Success;
}

/*
 * ** Set client Priority
 */
static int
ProcSyncSetPriority(ClientPtr client)
{
    REQUEST(xSyncSetPriorityReq);
    ClientPtr priorityclient;
    int rc;

    REQUEST_SIZE_MATCH(xSyncSetPriorityReq);

    if (stuff->id == None)
	priorityclient = client;
    else {
	rc = dixLookupClient(&priorityclient, stuff->id, client,
			     DixSetAttrAccess);
	if (rc != Success)
	    return rc;
    }

    if (priorityclient->priority != stuff->priority)
    {
	priorityclient->priority = stuff->priority;

	/*  The following will force the server back into WaitForSomething
	 *  so that the change in this client's priority is immediately
	 *  reflected.
	 */
	isItTimeToYield = TRUE;
	dispatchException |= DE_PRIORITYCHANGE;
    }
    return Success;
}

/*
 * ** Get client Priority
 */
static int
ProcSyncGetPriority(ClientPtr client)
{
    REQUEST(xSyncGetPriorityReq);
    xSyncGetPriorityReply rep;
    ClientPtr priorityclient;
    int rc;

    REQUEST_SIZE_MATCH(xSyncGetPriorityReq);

    if (stuff->id == None)
	priorityclient = client;
    else {
	rc = dixLookupClient(&priorityclient, stuff->id, client,
			     DixGetAttrAccess);
	if (rc != Success)
	    return rc;
    }

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.priority = priorityclient->priority;

    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.priority, n);
    }

    WriteToClient(client, sizeof(xSyncGetPriorityReply), (char *) &rep);

    return Success;
}

/*
 * ** Create a new counter
 */
static int
ProcSyncCreateCounter(ClientPtr client)
{
    REQUEST(xSyncCreateCounterReq);
    CARD64          initial;

    REQUEST_SIZE_MATCH(xSyncCreateCounterReq);

    LEGAL_NEW_RESOURCE(stuff->cid, client);

    XSyncIntsToValue(&initial, stuff->initial_value_lo, stuff->initial_value_hi);
    if (!SyncCreateCounter(client, stuff->cid, initial))
	return BadAlloc;

    return Success;
}

/*
 * ** Set Counter value
 */
static int
ProcSyncSetCounter(ClientPtr client)
{
    REQUEST(xSyncSetCounterReq);
    SyncCounter    *pCounter;
    CARD64	   newvalue;
    int	rc;

    REQUEST_SIZE_MATCH(xSyncSetCounterReq);

    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->cid, RTCounter,
				 client, DixWriteAccess);
    if (rc != Success)
	return rc;

    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->cid;
	return BadAccess;
    }

    XSyncIntsToValue(&newvalue, stuff->value_lo, stuff->value_hi);
    SyncChangeCounter(pCounter, newvalue);
    return Success;
}

/*
 * ** Change Counter value
 */
static int
ProcSyncChangeCounter(ClientPtr client)
{
    REQUEST(xSyncChangeCounterReq);
    SyncCounter    *pCounter;
    CARD64          newvalue;
    Bool	    overflow;
    int	rc;

    REQUEST_SIZE_MATCH(xSyncChangeCounterReq);

    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->cid, RTCounter,
				 client, DixWriteAccess);
    if (rc != Success)
	return rc;

    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->cid;
	return BadAccess;
    }

    XSyncIntsToValue(&newvalue, stuff->value_lo, stuff->value_hi);
    XSyncValueAdd(&newvalue, pCounter->value, newvalue, &overflow);
    if (overflow)
    {
	/* XXX 64 bit value can't fit in 32 bits; do the best we can */
	client->errorValue = stuff->value_hi;
	return BadValue;
    }
    SyncChangeCounter(pCounter, newvalue);
    return Success;
}

/*
 * ** Destroy a counter
 */
static int
ProcSyncDestroyCounter(ClientPtr client)
{
    REQUEST(xSyncDestroyCounterReq);
    SyncCounter    *pCounter;
    int rc;

    REQUEST_SIZE_MATCH(xSyncDestroyCounterReq);

    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->counter, RTCounter,
				 client, DixDestroyAccess);
    if (rc != Success)
	return rc;

    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->counter;
	return BadAccess;
    }
    FreeResource(pCounter->sync.id, RT_NONE);
    return Success;
}

static SyncAwaitUnion*
SyncAwaitPrologue(ClientPtr client, int items)
{
    SyncAwaitUnion *pAwaitUnion;

    /*  all the memory for the entire await list is allocated
     *  here in one chunk
     */
    pAwaitUnion = malloc((items+1) * sizeof(SyncAwaitUnion));
    if (!pAwaitUnion)
	return NULL;

    /* first item is the header, remainder are real wait conditions */

    pAwaitUnion->header.delete_id = FakeClientID(client->index);
    pAwaitUnion->header.client = client;
    pAwaitUnion->header.num_waitconditions = 0;

    if (!AddResource(pAwaitUnion->header.delete_id, RTAwait, pAwaitUnion))
	return NULL;

    return pAwaitUnion;
}

static void
SyncAwaitEpilogue(ClientPtr client, int items, SyncAwaitUnion *pAwaitUnion)
{
    SyncAwait *pAwait;
    int i;

    IgnoreClient(client);

    /* see if any of the triggers are already true */

    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pAwait++)
    {
	CARD64 value;

	/*  don't have to worry about NULL counters because the request
	 *  errors before we get here out if they occur
	 */
	switch (pAwait->trigger.pSync->type) {
	case SYNC_COUNTER:
	    value = ((SyncCounter *)pAwait->trigger.pSync)->value;
	    break;
	default:
	    XSyncIntToValue(&value, 0);
	}

	if ((*pAwait->trigger.CheckTrigger)(&pAwait->trigger, value))
	{
	    (*pAwait->trigger.TriggerFired)(&pAwait->trigger);
	    break; /* once is enough */
	}
    }
}

/*
 * ** Await
 */
static int
ProcSyncAwait(ClientPtr client)
{
    REQUEST(xSyncAwaitReq);
    int             len, items;
    int             i;
    xSyncWaitCondition *pProtocolWaitConds;
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait	   *pAwait;
    int		   status;

    REQUEST_AT_LEAST_SIZE(xSyncAwaitReq);

    len = client->req_len << 2;
    len -= sz_xSyncAwaitReq;
    items = len / sz_xSyncWaitCondition;

    if (items * sz_xSyncWaitCondition != len)
    {
	return BadLength;
    }
    if (items == 0)
    {
	client->errorValue = items; /* XXX protocol change */
	return BadValue;
    }

    if (!(pAwaitUnion = SyncAwaitPrologue(client, items)))
	return BadAlloc;

    /* don't need to do any more memory allocation for this request! */

    pProtocolWaitConds = (xSyncWaitCondition *) & stuff[1];

    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pProtocolWaitConds++, pAwait++)
    {
	if (pProtocolWaitConds->counter == None) /* XXX protocol change */
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    client->errorValue = pProtocolWaitConds->counter;
	    return SyncErrorBase + XSyncBadCounter;
	}

	/* sanity checks are in SyncInitTrigger */
	pAwait->trigger.pSync = NULL;
	pAwait->trigger.value_type = pProtocolWaitConds->value_type;
	XSyncIntsToValue(&pAwait->trigger.wait_value,
			 pProtocolWaitConds->wait_value_lo,
			 pProtocolWaitConds->wait_value_hi);
	pAwait->trigger.test_type = pProtocolWaitConds->test_type;

	status = SyncInitTrigger(client, &pAwait->trigger,
				 pProtocolWaitConds->counter, RTCounter,
				 XSyncCAAllTrigger);
	if (status != Success)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    return status;
	}
	/* this is not a mistake -- same function works for both cases */
	pAwait->trigger.TriggerFired = SyncAwaitTriggerFired;
	pAwait->trigger.CounterDestroyed = SyncAwaitTriggerFired;
	XSyncIntsToValue(&pAwait->event_threshold,
			 pProtocolWaitConds->event_threshold_lo,
			 pProtocolWaitConds->event_threshold_hi);
	pAwait->pHeader = &pAwaitUnion->header;
	pAwaitUnion->header.num_waitconditions++;
    }

    SyncAwaitEpilogue(client, items, pAwaitUnion);

    return Success;
}


/*
 * ** Query a counter
 */
static int
ProcSyncQueryCounter(ClientPtr client)
{
    REQUEST(xSyncQueryCounterReq);
    xSyncQueryCounterReply rep;
    SyncCounter    *pCounter;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryCounterReq);

    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->counter,
				 RTCounter, client, DixReadAccess);
    if (rc != Success)
	return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    /* if system counter, ask it what the current value is */

    if (IsSystemCounter(pCounter))
    {
	(*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
						  &pCounter->value);
    }

    rep.value_hi = XSyncValueHigh32(pCounter->value);
    rep.value_lo = XSyncValueLow32(pCounter->value);
    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.value_hi, n);
	swapl(&rep.value_lo, n);
    }
    WriteToClient(client, sizeof(xSyncQueryCounterReply), (char *) &rep);
    return Success;
}


/*
 * ** Create Alarm
 */
static int
ProcSyncCreateAlarm(ClientPtr client)
{
    REQUEST(xSyncCreateAlarmReq);
    SyncAlarm      *pAlarm;
    int             status;
    unsigned long   len, vmask;
    SyncTrigger	    *pTrigger;

    REQUEST_AT_LEAST_SIZE(xSyncCreateAlarmReq);

    LEGAL_NEW_RESOURCE(stuff->id, client);

    vmask = stuff->valueMask;
    len = client->req_len - bytes_to_int32(sizeof(xSyncCreateAlarmReq));
    /* the "extra" call to Ones accounts for the presence of 64 bit values */
    if (len != (Ones(vmask) + Ones(vmask & (XSyncCAValue|XSyncCADelta))))
	return BadLength;

    if (!(pAlarm = malloc(sizeof(SyncAlarm))))
    {
	return BadAlloc;
    }

    /* set up defaults */

    pTrigger = &pAlarm->trigger;
    pTrigger->pSync = NULL;
    pTrigger->value_type = XSyncAbsolute;
    XSyncIntToValue(&pTrigger->wait_value, 0L);
    pTrigger->test_type = XSyncPositiveComparison;
    pTrigger->TriggerFired = SyncAlarmTriggerFired;
    pTrigger->CounterDestroyed = SyncAlarmCounterDestroyed;
    status = SyncInitTrigger(client, pTrigger, None, RTCounter,
			     XSyncCAAllTrigger);
    if (status != Success)
    {
	free(pAlarm);
	return status;
    }

    pAlarm->client = client;
    pAlarm->alarm_id = stuff->id;
    XSyncIntToValue(&pAlarm->delta, 1L);
    pAlarm->events = TRUE;
    pAlarm->state = XSyncAlarmInactive;
    pAlarm->pEventClients = NULL;
    status = SyncChangeAlarmAttributes(client, pAlarm, vmask,
				       (CARD32 *)&stuff[1]);
    if (status != Success)
    {
	free(pAlarm);
	return status;
    }

    if (!AddResource(stuff->id, RTAlarm, pAlarm))
	return BadAlloc;

    /*  see if alarm already triggered.  NULL counter will not trigger
     *  in CreateAlarm and sets alarm state to Inactive.
     */

    if (!pTrigger->pSync)
    {
	pAlarm->state = XSyncAlarmInactive; /* XXX protocol change */
    }
    else
    {
	SyncCounter *pCounter;

	if (!SyncCheckWarnIsCounter(pTrigger->pSync,
				    WARN_INVALID_COUNTER_ALARM))
	{
	    FreeResource(stuff->id, RT_NONE);
	    return BadAlloc;
	}

	pCounter = (SyncCounter *)pTrigger->pSync;

	if ((*pTrigger->CheckTrigger)(pTrigger, pCounter->value))
	    (*pTrigger->TriggerFired)(pTrigger);
    }

    return Success;
}

/*
 * ** Change Alarm
 */
static int
ProcSyncChangeAlarm(ClientPtr client)
{
    REQUEST(xSyncChangeAlarmReq);
    SyncAlarm   *pAlarm;
    SyncCounter *pCounter = NULL;
    long        vmask;
    int         len, status;

    REQUEST_AT_LEAST_SIZE(xSyncChangeAlarmReq);

    status = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				     client, DixWriteAccess);
    if (status != Success)
	return status;

    vmask = stuff->valueMask;
    len = client->req_len - bytes_to_int32(sizeof(xSyncChangeAlarmReq));
    /* the "extra" call to Ones accounts for the presence of 64 bit values */
    if (len != (Ones(vmask) + Ones(vmask & (XSyncCAValue|XSyncCADelta))))
	return BadLength;

    if ((status = SyncChangeAlarmAttributes(client, pAlarm, vmask,
					    (CARD32 *)&stuff[1])) != Success)
	return status;

    if (SyncCheckWarnIsCounter(pAlarm->trigger.pSync,
			       WARN_INVALID_COUNTER_ALARM))
	pCounter = (SyncCounter *)pAlarm->trigger.pSync;

    /*  see if alarm already triggered.  NULL counter WILL trigger
     *  in ChangeAlarm.
     */

    if (!pCounter ||
	(*pAlarm->trigger.CheckTrigger)(&pAlarm->trigger, pCounter->value))
    {
	(*pAlarm->trigger.TriggerFired)(&pAlarm->trigger);
    }
    return Success;
}

static int
ProcSyncQueryAlarm(ClientPtr client)
{
    REQUEST(xSyncQueryAlarmReq);
    SyncAlarm      *pAlarm;
    xSyncQueryAlarmReply rep;
    SyncTrigger    *pTrigger;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryAlarmReq);

    rc = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				 client, DixReadAccess);
    if (rc != Success)
	return rc;

    rep.type = X_Reply;
    rep.length = bytes_to_int32(sizeof(xSyncQueryAlarmReply) - sizeof(xGenericReply));
    rep.sequenceNumber = client->sequence;

    pTrigger = &pAlarm->trigger;
    rep.counter = (pTrigger->pSync) ? pTrigger->pSync->id : None;

#if 0 /* XXX unclear what to do, depends on whether relative value-types
       * are "consumed" immediately and are considered absolute from then
       * on.
       */
    rep.value_type = pTrigger->value_type;
    rep.wait_value_hi = XSyncValueHigh32(pTrigger->wait_value);
    rep.wait_value_lo = XSyncValueLow32(pTrigger->wait_value);
#else
    rep.value_type = XSyncAbsolute;
    rep.wait_value_hi = XSyncValueHigh32(pTrigger->test_value);
    rep.wait_value_lo = XSyncValueLow32(pTrigger->test_value);
#endif

    rep.test_type = pTrigger->test_type;
    rep.delta_hi = XSyncValueHigh32(pAlarm->delta);
    rep.delta_lo = XSyncValueLow32(pAlarm->delta);
    rep.events = pAlarm->events;
    rep.state = pAlarm->state;

    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.counter, n);
	swapl(&rep.wait_value_hi, n);
	swapl(&rep.wait_value_lo, n);
	swapl(&rep.test_type, n);
	swapl(&rep.delta_hi, n);
	swapl(&rep.delta_lo, n);
    }

    WriteToClient(client, sizeof(xSyncQueryAlarmReply), (char *) &rep);
    return Success;
}

static int
ProcSyncDestroyAlarm(ClientPtr client)
{
    SyncAlarm *pAlarm;
    int rc;
    REQUEST(xSyncDestroyAlarmReq);

    REQUEST_SIZE_MATCH(xSyncDestroyAlarmReq);

    rc = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				 client, DixDestroyAccess);
    if (rc != Success)
	return rc;

    FreeResource(stuff->alarm, RT_NONE);
    return Success;
}

static int
ProcSyncCreateFence(ClientPtr client)
{
    REQUEST(xSyncCreateFenceReq);
    DrawablePtr pDraw;
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncCreateFenceReq);

    rc = dixLookupDrawable(&pDraw, stuff->d, client, M_ANY, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    LEGAL_NEW_RESOURCE(stuff->fid, client);

    if (!(pFence = (SyncFence *)SyncCreate(client,
					   stuff->fid,
					   SYNC_FENCE)))
	return BadAlloc;

    miSyncInitFence(pDraw->pScreen, pFence, stuff->initially_triggered);

    if (!AddResource(stuff->fid, RTFence, (pointer) pFence))
	return BadAlloc;

    return client->noClientException;
}

static int
FreeFence(void *obj, XID id)
{
    SyncFence *pFence = (SyncFence *) obj;

    miSyncDestroyFence(pFence);

    return Success;
}

int SyncVerifyFence(SyncFence **ppSyncFence, XID fid,
		    ClientPtr client, Mask mode)
{
    int rc = dixLookupResourceByType((pointer *)ppSyncFence, fid, RTFence,
				     client, mode);

    if (rc != Success)
	client->errorValue = fid;

    return rc;
}

static int
ProcSyncTriggerFence(ClientPtr client)
{
    REQUEST(xSyncTriggerFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncTriggerFenceReq);

    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixWriteAccess);
    if (rc != Success)
	return rc;

    miSyncTriggerFence(pFence);

    return client->noClientException;
}

static int
ProcSyncResetFence(ClientPtr client)
{
    REQUEST(xSyncResetFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncResetFenceReq);

    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixWriteAccess);
    if (rc != Success)
	return rc;

    if (pFence->funcs.CheckTriggered(pFence) != TRUE)
	return BadMatch;

    pFence->funcs.Reset(pFence);

    return client->noClientException;
}

static int
ProcSyncDestroyFence(ClientPtr client)
{
    REQUEST(xSyncDestroyFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncDestroyFenceReq);

    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixDestroyAccess);
    if (rc != Success)
	return rc;

    FreeResource(stuff->fid, RT_NONE);
    return client->noClientException;
}

static int
ProcSyncQueryFence(ClientPtr client)
{
    REQUEST(xSyncQueryFenceReq);
    xSyncQueryFenceReply rep;
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryFenceReq);

    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid,
				 RTFence, client, DixReadAccess);
    if (rc != Success)
	return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rep.triggered = pFence->funcs.CheckTriggered(pFence);

    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
    }

    WriteToClient(client, sizeof(xSyncQueryFenceReply), (char *) &rep);
    return client->noClientException;
}

static int
ProcSyncAwaitFence(ClientPtr client)
{
    REQUEST(xSyncAwaitFenceReq);
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait *pAwait;
    /* Use CARD32 rather than XSyncFence because XIDs are hard-coded to
     * CARD32 in protocol definitions */
    CARD32 *pProtocolFences;
    int status;
    int len;
    int items;
    int i;

    REQUEST_AT_LEAST_SIZE(xSyncAwaitFenceReq);

    len = client->req_len << 2;
    len -= sz_xSyncAwaitFenceReq;
    items = len / sizeof(CARD32);

    if (items * sizeof(CARD32) != len)
    {
	return BadLength;
    }
    if (items == 0)
    {
	client->errorValue = items;
	return BadValue;
    }

    if (!(pAwaitUnion = SyncAwaitPrologue(client, items)))
	return BadAlloc;

    /* don't need to do any more memory allocation for this request! */

    pProtocolFences = (CARD32 *) & stuff[1];

    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pProtocolFences++, pAwait++)
    {
	if (*pProtocolFences == None)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    client->errorValue = *pProtocolFences;
	    return SyncErrorBase + XSyncBadFence;
	}

	pAwait->trigger.pSync = NULL;
	/* Provide acceptable values for these unused fields to
	 * satisfy SyncInitTrigger's validation logic
	 */
	pAwait->trigger.value_type = XSyncAbsolute;
	XSyncIntToValue(&pAwait->trigger.wait_value, 0);
	pAwait->trigger.test_type = 0;

	status = SyncInitTrigger(client, &pAwait->trigger,
				 *pProtocolFences, RTFence,
				 XSyncCAAllTrigger);
	if (status != Success)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    return status;
	}
	/* this is not a mistake -- same function works for both cases */
	pAwait->trigger.TriggerFired = SyncAwaitTriggerFired;
	pAwait->trigger.CounterDestroyed = SyncAwaitTriggerFired;
	/* event_threshold is unused for fence syncs */
	XSyncIntToValue(&pAwait->event_threshold, 0);
	pAwait->pHeader = &pAwaitUnion->header;
	pAwaitUnion->header.num_waitconditions++;
    }

    SyncAwaitEpilogue(client, items, pAwaitUnion);

    return client->noClientException;
}

/*
 * ** Given an extension request, call the appropriate request procedure
 */
static int
ProcSyncDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
      case X_SyncInitialize:
	return ProcSyncInitialize(client);
      case X_SyncListSystemCounters:
	return ProcSyncListSystemCounters(client);
      case X_SyncCreateCounter:
	return ProcSyncCreateCounter(client);
      case X_SyncSetCounter:
	return ProcSyncSetCounter(client);
      case X_SyncChangeCounter:
	return ProcSyncChangeCounter(client);
      case X_SyncQueryCounter:
	return ProcSyncQueryCounter(client);
      case X_SyncDestroyCounter:
	return ProcSyncDestroyCounter(client);
      case X_SyncAwait:
	return ProcSyncAwait(client);
      case X_SyncCreateAlarm:
	return ProcSyncCreateAlarm(client);
      case X_SyncChangeAlarm:
	return ProcSyncChangeAlarm(client);
      case X_SyncQueryAlarm:
	return ProcSyncQueryAlarm(client);
      case X_SyncDestroyAlarm:
	return ProcSyncDestroyAlarm(client);
      case X_SyncSetPriority:
	return ProcSyncSetPriority(client);
      case X_SyncGetPriority:
	return ProcSyncGetPriority(client);
      case X_SyncCreateFence:
	return ProcSyncCreateFence(client);
      case X_SyncTriggerFence:
	return ProcSyncTriggerFence(client);
      case X_SyncResetFence:
	return ProcSyncResetFence(client);
      case X_SyncDestroyFence:
	return ProcSyncDestroyFence(client);
      case X_SyncQueryFence:
	return ProcSyncQueryFence(client);
      case X_SyncAwaitFence:
	return ProcSyncAwaitFence(client);
      default:
	return BadRequest;
    }
}

/*
 * Boring Swapping stuff ...
 */

static int
SProcSyncInitialize(ClientPtr client)
{
    REQUEST(xSyncInitializeReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncInitializeReq);

    return ProcSyncInitialize(client);
}

static int
SProcSyncListSystemCounters(ClientPtr client)
{
    REQUEST(xSyncListSystemCountersReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncListSystemCountersReq);

    return ProcSyncListSystemCounters(client);
}

static int
SProcSyncCreateCounter(ClientPtr client)
{
    REQUEST(xSyncCreateCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncCreateCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->initial_value_lo, n);
    swapl(&stuff->initial_value_hi, n);

    return ProcSyncCreateCounter(client);
}

static int
SProcSyncSetCounter(ClientPtr client)
{
    REQUEST(xSyncSetCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncSetCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->value_lo, n);
    swapl(&stuff->value_hi, n);

    return ProcSyncSetCounter(client);
}

static int
SProcSyncChangeCounter(ClientPtr client)
{
    REQUEST(xSyncChangeCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncChangeCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->value_lo, n);
    swapl(&stuff->value_hi, n);

    return ProcSyncChangeCounter(client);
}

static int
SProcSyncQueryCounter(ClientPtr client)
{
    REQUEST(xSyncQueryCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryCounterReq);
    swapl(&stuff->counter, n);

    return ProcSyncQueryCounter(client);
}

static int
SProcSyncDestroyCounter(ClientPtr client)
{
    REQUEST(xSyncDestroyCounterReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyCounterReq);
    swapl(&stuff->counter, n);

    return ProcSyncDestroyCounter(client);
}

static int
SProcSyncAwait(ClientPtr client)
{
    REQUEST(xSyncAwaitReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSyncAwaitReq);
    SwapRestL(stuff);

    return ProcSyncAwait(client);
}

static int
SProcSyncCreateAlarm(ClientPtr client)
{
    REQUEST(xSyncCreateAlarmReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSyncCreateAlarmReq);
    swapl(&stuff->id, n);
    swapl(&stuff->valueMask, n);
    SwapRestL(stuff);

    return ProcSyncCreateAlarm(client);
}

static int
SProcSyncChangeAlarm(ClientPtr client)
{
    REQUEST(xSyncChangeAlarmReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSyncChangeAlarmReq);
    swapl(&stuff->alarm, n);
    swapl(&stuff->valueMask, n);
    SwapRestL(stuff);
    return ProcSyncChangeAlarm(client);
}

static int
SProcSyncQueryAlarm(ClientPtr client)
{
    REQUEST(xSyncQueryAlarmReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryAlarmReq);
    swapl(&stuff->alarm, n);

    return ProcSyncQueryAlarm(client);
}

static int
SProcSyncDestroyAlarm(ClientPtr client)
{
    REQUEST(xSyncDestroyAlarmReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyAlarmReq);
    swapl(&stuff->alarm, n);

    return ProcSyncDestroyAlarm(client);
}

static int
SProcSyncSetPriority(ClientPtr client)
{
    REQUEST(xSyncSetPriorityReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncSetPriorityReq);
    swapl(&stuff->id, n);
    swapl(&stuff->priority, n);

    return ProcSyncSetPriority(client);
}

static int
SProcSyncGetPriority(ClientPtr client)
{
    REQUEST(xSyncGetPriorityReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncGetPriorityReq);
    swapl(&stuff->id, n);

    return ProcSyncGetPriority(client);
}

static int
SProcSyncCreateFence(ClientPtr client)
{
    REQUEST(xSyncCreateFenceReq);
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncCreateFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncCreateFence(client);
}

static int
SProcSyncTriggerFence(ClientPtr client)
{
    REQUEST(xSyncTriggerFenceReq);
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncTriggerFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncTriggerFence(client);
}

static int
SProcSyncResetFence(ClientPtr client)
{
    REQUEST(xSyncResetFenceReq);
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncResetFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncResetFence(client);
}

static int
SProcSyncDestroyFence(ClientPtr client)
{
    REQUEST(xSyncDestroyFenceReq);
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncDestroyFence(client);
}

static int
SProcSyncQueryFence(ClientPtr client)
{
    REQUEST(xSyncQueryFenceReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryFenceReq);
    swapl(&stuff->fid, n);

    return ProcSyncQueryFence(client);
}

static int
SProcSyncAwaitFence(ClientPtr client)
{
    REQUEST(xSyncAwaitFenceReq);
    char   n;

    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSyncAwaitFenceReq);
    SwapRestL(stuff);

    return ProcSyncAwaitFence(client);
}

static int
SProcSyncDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data)
    {
      case X_SyncInitialize:
	return SProcSyncInitialize(client);
      case X_SyncListSystemCounters:
	return SProcSyncListSystemCounters(client);
      case X_SyncCreateCounter:
	return SProcSyncCreateCounter(client);
      case X_SyncSetCounter:
	return SProcSyncSetCounter(client);
      case X_SyncChangeCounter:
	return SProcSyncChangeCounter(client);
      case X_SyncQueryCounter:
	return SProcSyncQueryCounter(client);
      case X_SyncDestroyCounter:
	return SProcSyncDestroyCounter(client);
      case X_SyncAwait:
	return SProcSyncAwait(client);
      case X_SyncCreateAlarm:
	return SProcSyncCreateAlarm(client);
      case X_SyncChangeAlarm:
	return SProcSyncChangeAlarm(client);
      case X_SyncQueryAlarm:
	return SProcSyncQueryAlarm(client);
      case X_SyncDestroyAlarm:
	return SProcSyncDestroyAlarm(client);
      case X_SyncSetPriority:
	return SProcSyncSetPriority(client);
      case X_SyncGetPriority:
	return SProcSyncGetPriority(client);
      case X_SyncCreateFence:
	return SProcSyncCreateFence(client);
      case X_SyncTriggerFence:
	return SProcSyncTriggerFence(client);
      case X_SyncResetFence:
	return SProcSyncResetFence(client);
      case X_SyncDestroyFence:
	return SProcSyncDestroyFence(client);
      case X_SyncQueryFence:
	return SProcSyncQueryFence(client);
      case X_SyncAwaitFence:
	return SProcSyncAwaitFence(client);
      default:
	return BadRequest;
    }
}

/*
 * Event Swapping
 */

static void
SCounterNotifyEvent(xSyncCounterNotifyEvent *from, xSyncCounterNotifyEvent *to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->counter, to->counter);
    cpswapl(from->wait_value_lo, to->wait_value_lo);
    cpswapl(from->wait_value_hi, to->wait_value_hi);
    cpswapl(from->counter_value_lo, to->counter_value_lo);
    cpswapl(from->counter_value_hi, to->counter_value_hi);
    cpswapl(from->time, to->time);
    cpswaps(from->count, to->count);
    to->destroyed = from->destroyed;
}


static void
SAlarmNotifyEvent(xSyncAlarmNotifyEvent *from, xSyncAlarmNotifyEvent *to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->alarm, to->alarm);
    cpswapl(from->counter_value_lo, to->counter_value_lo);
    cpswapl(from->counter_value_hi, to->counter_value_hi);
    cpswapl(from->alarm_value_lo, to->alarm_value_lo);
    cpswapl(from->alarm_value_hi, to->alarm_value_hi);
    cpswapl(from->time, to->time);
    to->state = from->state;
}

/*
 * ** Close everything down. ** This is fairly simple for now.
 */
/* ARGSUSED */
static void
SyncResetProc(ExtensionEntry *extEntry)
{
    free(SysCounterList);
    SysCounterList = NULL;
    RTCounter = 0;
}

/*
 * ** Initialise the extension.
 */
void
SyncExtensionInit(void)
{
    ExtensionEntry *extEntry;
    int 	    s;

    for (s = 0; s < screenInfo.numScreens; s++)
	miSyncSetup(screenInfo.screens[s]);

    if (RTCounter == 0)
    {
	RTCounter = CreateNewResourceType(FreeCounter, "SyncCounter");
    }
    RTAlarm = CreateNewResourceType(FreeAlarm, "SyncAlarm");
    RTAwait = CreateNewResourceType(FreeAwait, "SyncAwait");
    RTFence = CreateNewResourceType(FreeFence, "SyncFence");
    if (RTAwait)
	RTAwait |= RC_NEVERRETAIN;
    RTAlarmClient = CreateNewResourceType(FreeAlarmClient, "SyncAlarmClient");
    if (RTAlarmClient)
	RTAlarmClient |= RC_NEVERRETAIN;

    if (RTCounter == 0 || RTAwait == 0 || RTAlarm == 0 ||
	RTAlarmClient == 0 ||
	(extEntry = AddExtension(SYNC_NAME,
				 XSyncNumberEvents, XSyncNumberErrors,
				 ProcSyncDispatch, SProcSyncDispatch,
				 SyncResetProc,
				 StandardMinorOpcode)) == NULL)
    {
	ErrorF("Sync Extension %d.%d failed to Initialise\n",
		SYNC_MAJOR_VERSION, SYNC_MINOR_VERSION);
	return;
    }

    SyncEventBase = extEntry->eventBase;
    SyncErrorBase = extEntry->errorBase;
    EventSwapVector[SyncEventBase + XSyncCounterNotify] = (EventSwapPtr) SCounterNotifyEvent;
    EventSwapVector[SyncEventBase + XSyncAlarmNotify] = (EventSwapPtr) SAlarmNotifyEvent;

    SetResourceTypeErrorValue(RTCounter, SyncErrorBase + XSyncBadCounter);
    SetResourceTypeErrorValue(RTAlarm, SyncErrorBase + XSyncBadAlarm);
    SetResourceTypeErrorValue(RTFence, SyncErrorBase + XSyncBadFence);

    /*
     * Although SERVERTIME is implemented by the OS layer, we initialise it
     * here because doing it in OsInit() is too early. The resource database
     * is not initialised when OsInit() is called. This is just about OK
     * because there is always a servertime counter.
     */
    SyncInitServerTime();
    SyncInitIdleTime();

#ifdef DEBUG
    fprintf(stderr, "Sync Extension %d.%d\n",
	    SYNC_MAJOR_VERSION, SYNC_MINOR_VERSION);
#endif
}


/*
 * ***** SERVERTIME implementation - should go in its own file in OS directory?
 */



static pointer ServertimeCounter;
static XSyncValue Now;
static XSyncValue *pnext_time;

#define GetTime()\
{\
    unsigned long millis = GetTimeInMillis();\
    unsigned long maxis = XSyncValueHigh32(Now);\
    if (millis < XSyncValueLow32(Now)) maxis++;\
    XSyncIntsToValue(&Now, millis, maxis);\
}

/*
*** Server Block Handler
*** code inspired by multibuffer extension (now deprecated)
 */
/*ARGSUSED*/
static void
ServertimeBlockHandler(void *env, struct timeval **wt, void *LastSelectMask)
{
    XSyncValue delay;
    unsigned long timeout;

    if (pnext_time)
    {
        GetTime();

        if (XSyncValueGreaterOrEqual(Now, *pnext_time))
	{
            timeout = 0;
        }
	else
	{
	    Bool overflow;
            XSyncValueSubtract(&delay, *pnext_time, Now, &overflow);
	    (void)overflow;
            timeout = XSyncValueLow32(delay);
        }
        AdjustWaitForDelay(wt, timeout); /* os/utils.c */
    }
}

/*
*** Wakeup Handler
 */
/*ARGSUSED*/
static void
ServertimeWakeupHandler(void *env, int rc, void *LastSelectMask)
{
    if (pnext_time)
    {
        GetTime();

        if (XSyncValueGreaterOrEqual(Now, *pnext_time))
	{
            SyncChangeCounter(ServertimeCounter, Now);
        }
    }
}

static void
ServertimeQueryValue(void *pCounter, CARD64 *pValue_return)
{
    GetTime();
    *pValue_return = Now;
}

static void
ServertimeBracketValues(void *pCounter, CARD64 *pbracket_less,
			CARD64 *pbracket_greater)
{
    if (!pnext_time && pbracket_greater)
    {
	RegisterBlockAndWakeupHandlers(ServertimeBlockHandler,
				       ServertimeWakeupHandler,
				       NULL);
    }
    else if (pnext_time && !pbracket_greater)
    {
	RemoveBlockAndWakeupHandlers(ServertimeBlockHandler,
				     ServertimeWakeupHandler,
				     NULL);
    }
    pnext_time = pbracket_greater;
}

static void
SyncInitServerTime(void)
{
    CARD64 resolution;

    XSyncIntsToValue(&Now, GetTimeInMillis(), 0);
    XSyncIntToValue(&resolution, 4);
    ServertimeCounter = SyncCreateSystemCounter("SERVERTIME", Now, resolution,
			    XSyncCounterNeverDecreases,
			    ServertimeQueryValue, ServertimeBracketValues);
    pnext_time = NULL;
}



/*
 * IDLETIME implementation
 */

static SyncCounter *IdleTimeCounter;
static XSyncValue *pIdleTimeValueLess;
static XSyncValue *pIdleTimeValueGreater;

static void
IdleTimeQueryValue (pointer pCounter, CARD64 *pValue_return)
{
    CARD32 idle = GetTimeInMillis() - lastDeviceEventTime.milliseconds;
    XSyncIntsToValue (pValue_return, idle, 0);
}

static void
IdleTimeBlockHandler(pointer env, struct timeval **wt, pointer LastSelectMask)
{
    XSyncValue idle, old_idle;
    SyncTriggerList *list = IdleTimeCounter->sync.pTriglist;
    SyncTrigger *trig;

    if (!pIdleTimeValueLess && !pIdleTimeValueGreater)
	return;

    old_idle = IdleTimeCounter->value;
    IdleTimeQueryValue (NULL, &idle);
    IdleTimeCounter->value = idle; /* push, so CheckTrigger works */

    if (pIdleTimeValueLess &&
        XSyncValueLessOrEqual (idle, *pIdleTimeValueLess))
    {
	/*
	 * We've been idle for less than the threshold value, and someone
	 * wants to know about that, but now we need to know whether they
	 * want level or edge trigger.  Check the trigger list against the
	 * current idle time, and if any succeed, bomb out of select()
	 * immediately so we can reschedule.
	 */

	for (list = IdleTimeCounter->sync.pTriglist; list; list = list->next) {
	    trig = list->pTrigger;
	    if (trig->CheckTrigger(trig, old_idle)) {
		AdjustWaitForDelay(wt, 0);
		break;
	    }
	}
	/* 
	 * We've been called exactly on the idle time, but we have a
	 * NegativeTransition trigger which requires a transition from an
	 * idle time greater than this.  Schedule a wakeup for the next
	 * millisecond so we won't miss a transition.
	 */
	if (XSyncValueEqual (idle, *pIdleTimeValueLess))
	    AdjustWaitForDelay(wt, 1);
    }
    else if (pIdleTimeValueGreater)
    {
	/*
	 * There's a threshold in the positive direction.  If we've been
	 * idle less than it, schedule a wakeup for sometime in the future.
	 * If we've been idle more than it, and someone wants to know about
	 * that level-triggered, schedule an immediate wakeup.
	 */
	unsigned long timeout = -1;

	if (XSyncValueLessThan (idle, *pIdleTimeValueGreater)) {
	    XSyncValue value;
	    Bool overflow;

	    XSyncValueSubtract (&value, *pIdleTimeValueGreater,
	                        idle, &overflow);
	    timeout = min(timeout, XSyncValueLow32 (value));
	} else {
	    for (list = IdleTimeCounter->sync.pTriglist; list; list = list->next) {
		trig = list->pTrigger;
		if (trig->CheckTrigger(trig, old_idle)) {
		    timeout = min(timeout, 0);
		    break;
		}
	    }
	}

	AdjustWaitForDelay (wt, timeout);
    }

    IdleTimeCounter->value = old_idle; /* pop */
}

static void
IdleTimeWakeupHandler (pointer env, int rc, pointer LastSelectMask)
{
    XSyncValue idle;

    if (!pIdleTimeValueLess && !pIdleTimeValueGreater)
	return;

    IdleTimeQueryValue (NULL, &idle);

    if ((pIdleTimeValueGreater &&
         XSyncValueGreaterOrEqual (idle, *pIdleTimeValueGreater)) ||
        (pIdleTimeValueLess &&
	 XSyncValueLessOrEqual (idle, *pIdleTimeValueLess)))
    {
	SyncChangeCounter (IdleTimeCounter, idle);
    }
}

static void
IdleTimeBracketValues (pointer pCounter, CARD64 *pbracket_less,
                       CARD64 *pbracket_greater)
{
    Bool registered = (pIdleTimeValueLess || pIdleTimeValueGreater);

    if (registered && !pbracket_less && !pbracket_greater)
    {
	RemoveBlockAndWakeupHandlers(IdleTimeBlockHandler,
	                             IdleTimeWakeupHandler,
	                             NULL);
    }
    else if (!registered && (pbracket_less || pbracket_greater))
    {
	RegisterBlockAndWakeupHandlers(IdleTimeBlockHandler,
	                               IdleTimeWakeupHandler,
	                               NULL);
    }

    pIdleTimeValueGreater = pbracket_greater;
    pIdleTimeValueLess    = pbracket_less;
}

static void
SyncInitIdleTime (void)
{
    CARD64 resolution;
    XSyncValue idle;

    IdleTimeQueryValue (NULL, &idle);
    XSyncIntToValue (&resolution, 4);

    IdleTimeCounter = SyncCreateSystemCounter ("IDLETIME", idle, resolution,
                                               XSyncCounterUnrestricted,
                                               IdleTimeQueryValue,
                                               IdleTimeBracketValues);

    pIdleTimeValueLess = pIdleTimeValueGreater = NULL;
}
/*
 * Copyright © 2010 NVIDIA Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef _SYNCSDK_H_
#define _SYNCSDK_H_

#include "misync.h"

extern _X_EXPORT int
SyncVerifyFence(SyncFence **ppFence, XID fid, ClientPtr client, Mask mode);

#define VERIFY_SYNC_FENCE(pFence, fid, client, mode)			\
    do {								\
	int rc;								\
	rc = SyncVerifyFence(&(pFence), (fid), (client), (mode));	\
	if (Success != rc) return rc;					\
    } while (0)

#define VERIFY_SYNC_FENCE_OR_NONE(pFence, fid, client, mode)		\
    do {								\
        pFence = 0;							\
        if (None != fid)						\
	    VERIFY_SYNC_FENCE((pFence), (fid), (client), (mode));	\
    } while (0)

#endif /* _SYNCSDK_H_ */

/*

Copyright 1991, 1993, 1994, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/

/***********************************************************
Copyright 1991,1993 by Digital Equipment Corporation, Maynard, Massachusetts,
and Olivetti Research Limited, Cambridge, England.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or Olivetti
not be used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL AND OLIVETTI DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL THEY BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

******************************************************************/

#ifndef _SYNCSRV_H_
#define _SYNCSRV_H_

#include "misync.h"
#include "misyncstr.h"

/*
 * The System Counter interface
 */

typedef enum {
    XSyncCounterNeverChanges,
    XSyncCounterNeverIncreases,
    XSyncCounterNeverDecreases,
    XSyncCounterUnrestricted
} SyncCounterType;

typedef struct _SysCounterInfo {
    char	*name;
    CARD64	resolution;
    CARD64	bracket_greater;
    CARD64	bracket_less;
    SyncCounterType counterType;  /* how can this counter change */
    void        (*QueryValue)(
			      pointer /*pCounter*/,
			      CARD64 * /*freshvalue*/
);
    void	(*BracketValues)(
				 pointer /*pCounter*/,
				 CARD64 * /*lessthan*/,
				 CARD64 * /*greaterthan*/
);
} SysCounterInfo;



typedef struct _SyncAlarmClientList {
    ClientPtr	client;
    XID		delete_id;
    struct _SyncAlarmClientList *next;
} SyncAlarmClientList;

typedef struct _SyncAlarm {
    SyncTrigger trigger;
    ClientPtr	client;
    XSyncAlarm 	alarm_id;
    CARD64	delta;
    int		events;
    int		state;
    SyncAlarmClientList *pEventClients;
} SyncAlarm;

typedef struct {
    ClientPtr	client;
    CARD32 	delete_id;
    int		num_waitconditions;
} SyncAwaitHeader;

typedef struct {
    SyncTrigger trigger;
    CARD64	event_threshold;
    SyncAwaitHeader *pHeader;
} SyncAwait;

typedef union {
    SyncAwaitHeader header;
    SyncAwait	    await;
} SyncAwaitUnion;

extern pointer SyncCreateSystemCounter(
    char *	/* name */,
    CARD64  	/* inital_value */,
    CARD64  	/* resolution */,
    SyncCounterType /* change characterization */,
    void        (* /*QueryValue*/ ) (
        pointer /* pCounter */,
        CARD64 * /* pValue_return */), /* XXX prototype */
    void        (* /*BracketValues*/) (
        pointer /* pCounter */, 
        CARD64 * /* pbracket_less */,
        CARD64 * /* pbracket_greater */)
);

extern void SyncChangeCounter(
    SyncCounter *	/* pCounter*/,
    CARD64  		/* new_value */
);

extern void SyncDestroySystemCounter(
    pointer pCounter
);

extern void InitServertime(void);

extern void SyncExtensionInit(void);
#endif /* _SYNCSRV_H_ */
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdarg.h>
#include "scrnintstr.h"
#include "extnsionst.h"
#include "pixmapstr.h"
#include "regionstr.h"
#include "gcstruct.h"
#include "xacestr.h"

#define XSERV_t
#define TRANS_SERVER
#include <X11/Xtrans/Xtrans.h>
#include "../os/osdep.h"

_X_EXPORT CallbackListPtr XaceHooks[XACE_NUM_HOOKS] = {0};

/* Special-cased hook functions.  Called by Xserver.
 */
int XaceHookDispatch(ClientPtr client, int major)
{
    /* Call the audit begin callback, there is no return value. */
    XaceAuditRec rec = { client, 0 };
    CallCallbacks(&XaceHooks[XACE_AUDIT_BEGIN], &rec);

    if (major < 128) {
	/* Call the core dispatch hook */
	XaceCoreDispatchRec rec = { client, Success /* default allow */ };
	CallCallbacks(&XaceHooks[XACE_CORE_DISPATCH], &rec);
	return rec.status;
    } else {
	/* Call the extension dispatch hook */
	ExtensionEntry *ext = GetExtensionEntry(major);
	XaceExtAccessRec rec = { client, ext, DixUseAccess, Success };
	if (ext)
	    CallCallbacks(&XaceHooks[XACE_EXT_DISPATCH], &rec);
	/* On error, pretend extension doesn't exist */
	return (rec.status == Success) ? Success : BadRequest;
    }
}

int XaceHookPropertyAccess(ClientPtr client, WindowPtr pWin,
			   PropertyPtr *ppProp, Mask access_mode)
{
    XacePropertyAccessRec rec = { client, pWin, ppProp, access_mode, Success };
    CallCallbacks(&XaceHooks[XACE_PROPERTY_ACCESS], &rec);
    return rec.status;
}

int XaceHookSelectionAccess(ClientPtr client,
			    Selection **ppSel, Mask access_mode)
{
    XaceSelectionAccessRec rec = { client, ppSel, access_mode, Success };
    CallCallbacks(&XaceHooks[XACE_SELECTION_ACCESS], &rec);
    return rec.status;
}

void XaceHookAuditEnd(ClientPtr ptr, int result)
{
    XaceAuditRec rec = { ptr, result };
    /* call callbacks, there is no return value. */
    CallCallbacks(&XaceHooks[XACE_AUDIT_END], &rec);
}

/* Entry point for hook functions.  Called by Xserver.
 */
int XaceHook(int hook, ...)
{
    union {
	XaceResourceAccessRec res;
	XaceDeviceAccessRec dev;
	XaceSendAccessRec send;
	XaceReceiveAccessRec recv;
	XaceClientAccessRec client;
	XaceExtAccessRec ext;
	XaceServerAccessRec server;
	XaceScreenAccessRec screen;
	XaceAuthAvailRec auth;
	XaceKeyAvailRec key;
    } u;
    int *prv = NULL;	/* points to return value from callback */
    va_list ap;		/* argument list */
    va_start(ap, hook);

    /* Marshal arguments for passing to callback.
     * Each callback has its own case, which sets up a structure to hold
     * the arguments and integer return parameter, or in some cases just
     * sets calldata directly to a single argument (with no return result)
     */
    switch (hook)
    {
	case XACE_RESOURCE_ACCESS:
	    u.res.client = va_arg(ap, ClientPtr);
	    u.res.id = va_arg(ap, XID);
	    u.res.rtype = va_arg(ap, RESTYPE);
	    u.res.res = va_arg(ap, pointer);
	    u.res.ptype = va_arg(ap, RESTYPE);
	    u.res.parent = va_arg(ap, pointer);
	    u.res.access_mode = va_arg(ap, Mask);
	    u.res.status = Success; /* default allow */
	    prv = &u.res.status;
	    break;
	case XACE_DEVICE_ACCESS:
	    u.dev.client = va_arg(ap, ClientPtr);
	    u.dev.dev = va_arg(ap, DeviceIntPtr);
	    u.dev.access_mode = va_arg(ap, Mask);
	    u.dev.status = Success; /* default allow */
	    prv = &u.dev.status;
	    break;
	case XACE_SEND_ACCESS:
	    u.send.client = va_arg(ap, ClientPtr);
	    u.send.dev = va_arg(ap, DeviceIntPtr);
	    u.send.pWin = va_arg(ap, WindowPtr);
	    u.send.events = va_arg(ap, xEventPtr);
	    u.send.count = va_arg(ap, int);
	    u.send.status = Success; /* default allow */
	    prv = &u.send.status;
	    break;
	case XACE_RECEIVE_ACCESS:
	    u.recv.client = va_arg(ap, ClientPtr);
	    u.recv.pWin = va_arg(ap, WindowPtr);
	    u.recv.events = va_arg(ap, xEventPtr);
	    u.recv.count = va_arg(ap, int);
	    u.recv.status = Success; /* default allow */
	    prv = &u.recv.status;
	    break;
	case XACE_CLIENT_ACCESS:
	    u.client.client = va_arg(ap, ClientPtr);
	    u.client.target = va_arg(ap, ClientPtr);
	    u.client.access_mode = va_arg(ap, Mask);
	    u.client.status = Success; /* default allow */
	    prv = &u.client.status;
	    break;
	case XACE_EXT_ACCESS:
	    u.ext.client = va_arg(ap, ClientPtr);
	    u.ext.ext = va_arg(ap, ExtensionEntry*);
	    u.ext.access_mode = DixGetAttrAccess;
	    u.ext.status = Success; /* default allow */
	    prv = &u.ext.status;
	    break;
	case XACE_SERVER_ACCESS:
	    u.server.client = va_arg(ap, ClientPtr);
	    u.server.access_mode = va_arg(ap, Mask);
	    u.server.status = Success; /* default allow */
	    prv = &u.server.status;
	    break;
	case XACE_SCREEN_ACCESS:
	case XACE_SCREENSAVER_ACCESS:
	    u.screen.client = va_arg(ap, ClientPtr);
	    u.screen.screen = va_arg(ap, ScreenPtr);
	    u.screen.access_mode = va_arg(ap, Mask);
	    u.screen.status = Success; /* default allow */
	    prv = &u.screen.status;
	    break;
	case XACE_AUTH_AVAIL:
	    u.auth.client = va_arg(ap, ClientPtr);
	    u.auth.authId = va_arg(ap, XID);
	    break;
	case XACE_KEY_AVAIL:
	    u.key.event = va_arg(ap, xEventPtr);
	    u.key.keybd = va_arg(ap, DeviceIntPtr);
	    u.key.count = va_arg(ap, int);
	    break;
	default:
	    va_end(ap);
	    return 0;	/* unimplemented hook number */
    }
    va_end(ap);
 
    /* call callbacks and return result, if any. */
    CallCallbacks(&XaceHooks[hook], &u);
    return prv ? *prv : Success;
}

/* XaceCensorImage
 *
 * Called after pScreen->GetImage to prevent pieces or trusted windows from
 * being returned in image data from an untrusted window.
 *
 * Arguments:
 *	client is the client doing the GetImage.
 *      pVisibleRegion is the visible region of the window.
 *	widthBytesLine is the width in bytes of one horizontal line in pBuf.
 *	pDraw is the source window.
 *	x, y, w, h is the rectangle of image data from pDraw in pBuf.
 *	format is the format of the image data in pBuf: ZPixmap or XYPixmap.
 *	pBuf is the image data.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Any part of the rectangle (x, y, w, h) that is outside the visible
 *	region of the window will be destroyed (overwritten) in pBuf.
 */
void
XaceCensorImage(
	ClientPtr client,
	RegionPtr pVisibleRegion,
	long widthBytesLine,
	DrawablePtr pDraw,
	int x, int y, int w, int h,
	unsigned int format,
	char *pBuf)
{
    RegionRec imageRegion;  /* region representing x,y,w,h */
    RegionRec censorRegion; /* region to obliterate */
    BoxRec imageBox;
    int nRects;

    imageBox.x1 = x;
    imageBox.y1 = y;
    imageBox.x2 = x + w;
    imageBox.y2 = y + h;
    RegionInit(&imageRegion, &imageBox, 1);
    RegionNull(&censorRegion);

    /* censorRegion = imageRegion - visibleRegion */
    RegionSubtract(&censorRegion, &imageRegion, pVisibleRegion);
    nRects = RegionNumRects(&censorRegion);
    if (nRects > 0)
    { /* we have something to censor */
	GCPtr pScratchGC = NULL;
	PixmapPtr pPix = NULL;
	xRectangle *pRects = NULL;
	Bool failed = FALSE;
	int depth = 1;
	int bitsPerPixel = 1;
	int i;
	BoxPtr pBox;

	/* convert region to list-of-rectangles for PolyFillRect */

	pRects = malloc(nRects * sizeof(xRectangle));
	if (!pRects)
	{
	    failed = TRUE;
	    goto failSafe;
	}
	for (pBox = RegionRects(&censorRegion), i = 0;
	     i < nRects;
	     i++, pBox++)
	{
	    pRects[i].x = pBox->x1;
	    pRects[i].y = pBox->y1 - imageBox.y1;
	    pRects[i].width  = pBox->x2 - pBox->x1;
	    pRects[i].height = pBox->y2 - pBox->y1;
	}

	/* use pBuf as a fake pixmap */

	if (format == ZPixmap)
	{
	    depth = pDraw->depth;
	    bitsPerPixel = pDraw->bitsPerPixel;
	}

	pPix = GetScratchPixmapHeader(pDraw->pScreen, w, h,
		    depth, bitsPerPixel,
		    widthBytesLine, (pointer)pBuf);
	if (!pPix)
	{
	    failed = TRUE;
	    goto failSafe;
	}

	pScratchGC = GetScratchGC(depth, pPix->drawable.pScreen);
	if (!pScratchGC)
	{
	    failed = TRUE;
	    goto failSafe;
	}

	ValidateGC(&pPix->drawable, pScratchGC);
	(* pScratchGC->ops->PolyFillRect)(&pPix->drawable,
			    pScratchGC, nRects, pRects);

    failSafe:
	if (failed)
	{
	    /* Censoring was not completed above.  To be safe, wipe out
	     * all the image data so that nothing trusted gets out.
	     */
	    memset(pBuf, 0, (int)(widthBytesLine * h));
	}
	free(pRects);
	if (pScratchGC) FreeScratchGC(pScratchGC);
	if (pPix)       FreeScratchPixmapHeader(pPix);
    }
    RegionUninit(&imageRegion);
    RegionUninit(&censorRegion);
} /* XaceCensorImage */

/*
 * Xtrans wrappers for use by modules
 */
int XaceGetConnectionNumber(ClientPtr client)
{
    XtransConnInfo ci = ((OsCommPtr)client->osPrivate)->trans_conn;
    return _XSERVTransGetConnectionNumber(ci);
}

int XaceIsLocal(ClientPtr client)
{
    XtransConnInfo ci = ((OsCommPtr)client->osPrivate)->trans_conn;
    return _XSERVTransIsLocal(ci);
}
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifndef _XACE_H
#define _XACE_H

#ifdef XACE

#define XACE_MAJOR_VERSION		2
#define XACE_MINOR_VERSION		0

#include "pixmap.h"
#include "region.h"
#include "window.h"
#include "property.h"
#include "selection.h"

/* Default window background */
#define XaceBackgroundNoneState(w) ((w)->forcedBG ? BackgroundPixel : None)

/* security hooks */
/* Constants used to identify the available security hooks
 */
#define XACE_CORE_DISPATCH		0
#define XACE_EXT_DISPATCH		1
#define XACE_RESOURCE_ACCESS		2
#define XACE_DEVICE_ACCESS		3
#define XACE_PROPERTY_ACCESS		4
#define XACE_SEND_ACCESS		5
#define XACE_RECEIVE_ACCESS		6
#define XACE_CLIENT_ACCESS		7
#define XACE_EXT_ACCESS			8
#define XACE_SERVER_ACCESS		9
#define XACE_SELECTION_ACCESS		10
#define XACE_SCREEN_ACCESS		11
#define XACE_SCREENSAVER_ACCESS		12
#define XACE_AUTH_AVAIL			13
#define XACE_KEY_AVAIL			14
#define XACE_AUDIT_BEGIN		15
#define XACE_AUDIT_END			16
#define XACE_NUM_HOOKS			17

extern _X_EXPORT CallbackListPtr XaceHooks[XACE_NUM_HOOKS];

/* Entry point for hook functions.  Called by Xserver.
 * Required by libdbe and libextmod
 */
extern _X_EXPORT int XaceHook(
    int /*hook*/,
    ... /*appropriate args for hook*/
    ); 

/* Special-cased hook functions
 */
extern _X_EXPORT int XaceHookDispatch(ClientPtr ptr, int major);
extern _X_EXPORT int XaceHookPropertyAccess(ClientPtr ptr, WindowPtr pWin,
				   PropertyPtr *ppProp, Mask access_mode);
extern _X_EXPORT int XaceHookSelectionAccess(ClientPtr ptr,
				   Selection **ppSel, Mask access_mode);
extern _X_EXPORT void XaceHookAuditEnd(ClientPtr ptr, int result);

/* Register a callback for a given hook.
 */
#define XaceRegisterCallback(hook,callback,data) \
    AddCallback(XaceHooks+(hook), callback, data)

/* Unregister an existing callback for a given hook.
 */
#define XaceDeleteCallback(hook,callback,data) \
    DeleteCallback(XaceHooks+(hook), callback, data)

/* XTrans wrappers for use by security modules
 */
extern _X_EXPORT int XaceGetConnectionNumber(ClientPtr ptr);
extern _X_EXPORT int XaceIsLocal(ClientPtr ptr);

/* From the original Security extension...
 */

extern _X_EXPORT void XaceCensorImage(
    ClientPtr client,
    RegionPtr pVisibleRegion,
    long widthBytesLine,
    DrawablePtr pDraw,
    int x, int y, int w, int h,
    unsigned int format,
    char * pBuf
    );

#else /* XACE */

/* Default window background */
#define XaceBackgroundNoneState(w)		None

/* Define calls away when XACE is not being built. */

#ifdef __GNUC__
#define XaceHook(args...) Success
#define XaceHookDispatch(args...) Success
#define XaceHookPropertyAccess(args...) Success
#define XaceHookSelectionAccess(args...) Success
#define XaceHookAuditEnd(args...) { ; }
#define XaceCensorImage(args...) { ; }
#else
#define XaceHook(...) Success
#define XaceHookDispatch(...) Success
#define XaceHookPropertyAccess(...) Success
#define XaceHookSelectionAccess(...) Success
#define XaceHookAuditEnd(...) { ; }
#define XaceCensorImage(...) { ; }
#endif

#endif /* XACE */

#endif /* _XACE_H */
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifndef _XACESTR_H
#define _XACESTR_H

#include "dix.h"
#include "resource.h"
#include "extnsionst.h"
#include "window.h"
#include "input.h"
#include "property.h"
#include "selection.h"
#include "xace.h"

/* XACE_CORE_DISPATCH */
typedef struct {
    ClientPtr client;
    int status;
} XaceCoreDispatchRec;

/* XACE_RESOURCE_ACCESS */
typedef struct {
    ClientPtr client;
    XID id;
    RESTYPE rtype;
    pointer res;
    RESTYPE ptype;
    pointer parent;
    Mask access_mode;
    int status;
} XaceResourceAccessRec;

/* XACE_DEVICE_ACCESS */
typedef struct {
    ClientPtr client;
    DeviceIntPtr dev;
    Mask access_mode;
    int status;
} XaceDeviceAccessRec;

/* XACE_PROPERTY_ACCESS */
typedef struct {
    ClientPtr client;
    WindowPtr pWin;
    PropertyPtr *ppProp;
    Mask access_mode;
    int status;
} XacePropertyAccessRec;

/* XACE_SEND_ACCESS */
typedef struct {
    ClientPtr client;
    DeviceIntPtr dev;
    WindowPtr pWin;
    xEventPtr events;
    int count;
    int status;
} XaceSendAccessRec;

/* XACE_RECEIVE_ACCESS */
typedef struct {
    ClientPtr client;
    WindowPtr pWin;
    xEventPtr events;
    int count;
    int status;
} XaceReceiveAccessRec;

/* XACE_CLIENT_ACCESS */
typedef struct {
    ClientPtr client;
    ClientPtr target;
    Mask access_mode;
    int status;
} XaceClientAccessRec;

/* XACE_EXT_DISPATCH */
/* XACE_EXT_ACCESS */
typedef struct {
    ClientPtr client;
    ExtensionEntry *ext;
    Mask access_mode;
    int status;
} XaceExtAccessRec;

/* XACE_SERVER_ACCESS */
typedef struct {
    ClientPtr client;
    Mask access_mode;
    int status;
} XaceServerAccessRec;

/* XACE_SELECTION_ACCESS */
typedef struct {
    ClientPtr client;
    Selection **ppSel;
    Mask access_mode;
    int status;
} XaceSelectionAccessRec;

/* XACE_SCREEN_ACCESS */
/* XACE_SCREENSAVER_ACCESS */
typedef struct {
    ClientPtr client;
    ScreenPtr screen;
    Mask access_mode;
    int status;
} XaceScreenAccessRec;

/* XACE_AUTH_AVAIL */
typedef struct {
    ClientPtr client;
    XID authId;
} XaceAuthAvailRec;

/* XACE_KEY_AVAIL */
typedef struct {
    xEventPtr event;
    DeviceIntPtr keybd;
    int count;
} XaceKeyAvailRec;

/* XACE_AUDIT_BEGIN */
/* XACE_AUDIT_END */
typedef struct {
    ClientPtr client;
    int requestResult;
} XaceAuditRec;

#endif /* _XACESTR_H */
/*

Copyright 1993, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "swaprep.h"
#include <X11/extensions/xcmiscproto.h>
#include "modinit.h"

#if HAVE_STDINT_H
#include <stdint.h>
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif


static int
ProcXCMiscGetVersion(ClientPtr client)
{
    xXCMiscGetVersionReply rep;
    int n;

    REQUEST_SIZE_MATCH(xXCMiscGetVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = XCMiscMajorVersion;
    rep.minorVersion = XCMiscMinorVersion;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xXCMiscGetVersionReply), (char *)&rep);
    return Success;
}

static int
ProcXCMiscGetXIDRange(ClientPtr client)
{
    xXCMiscGetXIDRangeReply rep;
    int n;
    XID min_id, max_id;

    REQUEST_SIZE_MATCH(xXCMiscGetXIDRangeReq);
    GetXIDRange(client->index, FALSE, &min_id, &max_id);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.start_id = min_id;
    rep.count = max_id - min_id + 1;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.start_id, n);
	swapl(&rep.count, n);
    }
    WriteToClient(client, sizeof(xXCMiscGetXIDRangeReply), (char *)&rep);
    return Success;
}

static int
ProcXCMiscGetXIDList(ClientPtr client)
{
    REQUEST(xXCMiscGetXIDListReq);
    xXCMiscGetXIDListReply rep;
    int n;
    XID *pids;
    unsigned int count;

    REQUEST_SIZE_MATCH(xXCMiscGetXIDListReq);

    if (stuff->count > UINT32_MAX / sizeof(XID))
	    return BadAlloc;

    pids = (XID *)malloc(stuff->count * sizeof(XID));
    if (!pids)
    {
	return BadAlloc;
    }
    count = GetXIDList(client, stuff->count, pids);
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = count;
    rep.count = count;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.count, n);
    }
    WriteToClient(client, sizeof(xXCMiscGetXIDListReply), (char *)&rep);
    if (count)
    {
    	client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	WriteSwappedDataToClient(client, count * sizeof(XID), pids);
    }
    free(pids);
    return Success;
}

static int
ProcXCMiscDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_XCMiscGetVersion:
	return ProcXCMiscGetVersion(client);
    case X_XCMiscGetXIDRange:
	return ProcXCMiscGetXIDRange(client);
    case X_XCMiscGetXIDList:
	return ProcXCMiscGetXIDList(client);
    default:
	return BadRequest;
    }
}

static int
SProcXCMiscGetVersion(ClientPtr client)
{
    int n;
    REQUEST(xXCMiscGetVersionReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXCMiscGetVersionReq);
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion, n);
    return ProcXCMiscGetVersion(client);
}

static int
SProcXCMiscGetXIDRange(ClientPtr client)
{
    int n;
    REQUEST(xReq);

    swaps(&stuff->length, n);
    return ProcXCMiscGetXIDRange(client);
}

static int
SProcXCMiscGetXIDList(ClientPtr client)
{
    int n;
    REQUEST(xXCMiscGetXIDListReq);

    swaps(&stuff->length, n);
    swapl(&stuff->count, n);
    return ProcXCMiscGetXIDList(client);
}

static int
SProcXCMiscDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_XCMiscGetVersion:
	return SProcXCMiscGetVersion(client);
    case X_XCMiscGetXIDRange:
	return SProcXCMiscGetXIDRange(client);
    case X_XCMiscGetXIDList:
	return SProcXCMiscGetXIDList(client);
    default:
	return BadRequest;
    }
}

void
XCMiscExtensionInit(INITARGS)
{
    AddExtension(XCMiscExtensionName, 0, 0,
		 ProcXCMiscDispatch, SProcXCMiscDispatch,
		 NULL, StandardMinorOpcode);
}
/*
 * BIGFONT extension for sharing font metrics between clients (if possible)
 * and for transmitting font metrics to clients in a compressed form.
 *
 * Copyright (c) 1999-2000  Bruno Haible
 * Copyright (c) 1999-2000  The XFree86 Project, Inc.
 */

/* THIS IS NOT AN X CONSORTIUM STANDARD */

/*
 * Big fonts suffer from the following: All clients that have opened a
 * font can access the complete glyph metrics array (the XFontStruct member
 * `per_char') directly, without going through a macro. Moreover these
 * glyph metrics are ink metrics, i.e. are not redundant even for a
 * fixed-width font. For a Unicode font, the size of this array is 768 KB.
 *
 * Problems: 1. It eats a lot of memory in each client. 2. All this glyph
 * metrics data is piped through the socket when the font is opened.
 *
 * This extension addresses these two problems for local clients, by using
 * shared memory. It also addresses the second problem for non-local clients,
 * by compressing the data before transmit by a factor of nearly 6.
 *
 * If you use this extension, your OS ought to nicely support shared memory.
 * This means: Shared memory should be swappable to the swap, and the limits
 * should be high enough (SHMMNI at least 64, SHMMAX at least 768 KB,
 * SHMALL at least 48 MB). It is a plus if your OS allows shmat() calls
 * on segments that have already been marked "removed", because it permits
 * these segments to be cleaned up by the OS if the X server is killed with
 * signal SIGKILL.
 *
 * This extension is transparently exploited by Xlib (functions XQueryFont,
 * XLoadQueryFont).
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/types.h>
#ifdef HAS_SHM
#if defined(linux) && (!defined(__GNU_LIBRARY__) || __GNU_LIBRARY__ < 2)
/* libc4 does not define __GNU_LIBRARY__, libc5 defines __GNU_LIBRARY__ as 1 */
/* Linux libc4 and libc5 only (because glibc doesn't include kernel headers):
   Linux 2.0.x and 2.2.x define SHMLBA as PAGE_SIZE, but forget to define
   PAGE_SIZE. It is defined in <asm/page.h>. */
#include <asm/page.h>
#endif
#ifdef SVR4
#include <sys/sysmacros.h>
#endif
#if defined(__CYGWIN__) 
#include <sys/param.h>
#include <sys/sysmacros.h>
#endif
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "dixfontstr.h"
#include "extnsionst.h"
#include "protocol-versions.h"

#include <X11/extensions/xf86bigfproto.h>
#include "xf86bigfontsrv.h"

static void XF86BigfontResetProc(
    ExtensionEntry *	/* extEntry */
    );


#ifdef HAS_SHM

/* A random signature, transmitted to the clients so they can verify that the
   shared memory segment they are attaching to was really established by the
   X server they are talking to. */
static CARD32 signature;

/* Index for additional information stored in a FontRec's devPrivates array. */
static int FontShmdescIndex;

static unsigned int pagesize;

static Bool badSysCall = FALSE;

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__) || defined(__DragonFly__)

#include <sys/signal.h>

static void
SigSysHandler(
     int signo)
{
    badSysCall = TRUE;
}

static Bool
CheckForShmSyscall(void)
{
    void (*oldHandler)(int);
    int shmid = -1;

    /* If no SHM support in the kernel, the bad syscall will generate SIGSYS */
    oldHandler = signal(SIGSYS, SigSysHandler);

    badSysCall = FALSE;
    shmid = shmget(IPC_PRIVATE, 4096, IPC_CREAT);
    if (shmid != -1)
    {
        /* Successful allocation - clean up */
	shmctl(shmid, IPC_RMID, NULL);
    }
    else
    {
        /* Allocation failed */
        badSysCall = TRUE;
    }
    signal(SIGSYS, oldHandler);
    return !badSysCall;
}

#define MUST_CHECK_FOR_SHM_SYSCALL

#endif

#endif

/* ========== Management of shared memory segments ========== */

#ifdef HAS_SHM

#ifdef __linux__
/* On Linux, shared memory marked as "removed" can still be attached.
   Nice feature, because the kernel will automatically free the associated
   storage when the server and all clients are gone. */
#define EARLY_REMOVE
#endif

typedef struct _ShmDesc {
    struct _ShmDesc *next;
    struct _ShmDesc **prev;
    int shmid;
    char *attach_addr;
} ShmDescRec, *ShmDescPtr;

static ShmDescPtr ShmList = (ShmDescPtr) NULL;

static ShmDescPtr
shmalloc(
    unsigned int size)
{
    ShmDescPtr pDesc;
    int shmid;
    char *addr;

#ifdef MUST_CHECK_FOR_SHM_SYSCALL
    if (pagesize == 0)
	return (ShmDescPtr) NULL;
#endif

    /* On some older Linux systems, the number of shared memory segments
       system-wide is 127. In Linux 2.4, it is 4095.
       Therefore there is a tradeoff to be made between allocating a
       shared memory segment on one hand, and allocating memory and piping
       the glyph metrics on the other hand. If the glyph metrics size is
       small, we prefer the traditional way. */
    if (size < 3500)
	return (ShmDescPtr) NULL;

    pDesc = malloc(sizeof(ShmDescRec));
    if (!pDesc)
	return (ShmDescPtr) NULL;

    size = (size + pagesize-1) & -pagesize;
    shmid = shmget(IPC_PRIVATE, size, S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH);
    if (shmid == -1) {
	ErrorF(XF86BIGFONTNAME " extension: shmget() failed, size = %u, %s\n",
	       size, strerror(errno));
	free(pDesc);
	return (ShmDescPtr) NULL;
    }

    if ((addr = shmat(shmid, 0, 0)) == (char *)-1) {
	ErrorF(XF86BIGFONTNAME " extension: shmat() failed, size = %u, %s\n",
	       size, strerror(errno));
	shmctl(shmid, IPC_RMID, (void *) 0);
	free(pDesc);
	return (ShmDescPtr) NULL;
    }

#ifdef EARLY_REMOVE
    shmctl(shmid, IPC_RMID, (void *) 0);
#endif

    pDesc->shmid = shmid;
    pDesc->attach_addr = addr;
    if (ShmList) ShmList->prev = &pDesc->next;
    pDesc->next = ShmList;
    pDesc->prev = &ShmList;
    ShmList = pDesc;

    return pDesc;
}

static void
shmdealloc(
    ShmDescPtr pDesc)
{
#ifndef EARLY_REMOVE
    shmctl(pDesc->shmid, IPC_RMID, (void *) 0);
#endif
    shmdt(pDesc->attach_addr);

    if (pDesc->next) pDesc->next->prev = pDesc->prev;
    *pDesc->prev = pDesc->next;
    free(pDesc);
}

#endif

/* Called when a font is closed. */
void
XF86BigfontFreeFontShm(
    FontPtr pFont)
{
#ifdef HAS_SHM
    ShmDescPtr pDesc;

    /* If during shutdown of the server, XF86BigfontCleanup() has already
     * called shmdealloc() for all segments, we don't need to do it here.
     */
    if (!ShmList)
	return;

    pDesc = (ShmDescPtr) FontGetPrivate(pFont, FontShmdescIndex);
    if (pDesc)
	shmdealloc(pDesc);
#endif
}

/* Called upon fatal signal. */
void
XF86BigfontCleanup(void)
{
#ifdef HAS_SHM
    while (ShmList)
	shmdealloc(ShmList);
#endif
}

/* Called when a server generation dies. */
static void
XF86BigfontResetProc(
    ExtensionEntry* extEntry)
{
    /* This function is normally called from CloseDownExtensions(), called
     * from main(). It will be followed by a call to FreeAllResources(),
     * which will call XF86BigfontFreeFontShm() for each font. Thus it
     * appears that we do not need to do anything in this function. --
     * But I prefer to write robust code, and not keep shared memory lying
     * around when it's not needed any more. (Someone might close down the
     * extension without calling FreeAllResources()...)
     */
    XF86BigfontCleanup();
}


/* ========== Handling of extension specific requests ========== */

static int
ProcXF86BigfontQueryVersion(
    ClientPtr client)
{
    xXF86BigfontQueryVersionReply reply;

    REQUEST_SIZE_MATCH(xXF86BigfontQueryVersionReq);
    reply.type = X_Reply;
    reply.length = 0;
    reply.sequenceNumber = client->sequence;
    reply.majorVersion = SERVER_XF86BIGFONT_MAJOR_VERSION;
    reply.minorVersion = SERVER_XF86BIGFONT_MINOR_VERSION;
    reply.uid = geteuid();
    reply.gid = getegid();
#ifdef HAS_SHM
    reply.signature = signature;
#else
    reply.signature = 0; /* This is redundant. Avoids uninitialized memory. */
#endif
    reply.capabilities =
#ifdef HAS_SHM
	(LocalClient(client) && !client->swapped ? XF86Bigfont_CAP_LocalShm : 0)
#else
	0
#endif
	; /* may add more bits here in future versions */
    if (client->swapped) {
	char tmp;
	swaps(&reply.sequenceNumber, tmp);
	swapl(&reply.length, tmp);
	swaps(&reply.majorVersion, tmp);
	swaps(&reply.minorVersion, tmp);
	swapl(&reply.uid, tmp);
	swapl(&reply.gid, tmp);
	swapl(&reply.signature, tmp);
    }
    WriteToClient(client,
		  sizeof(xXF86BigfontQueryVersionReply), (char *)&reply);
    return Success;
}

static void
swapCharInfo(
    xCharInfo *pCI)
{
    char tmp;

    swaps(&pCI->leftSideBearing, tmp);
    swaps(&pCI->rightSideBearing, tmp);
    swaps(&pCI->characterWidth, tmp);
    swaps(&pCI->ascent, tmp);
    swaps(&pCI->descent, tmp);
    swaps(&pCI->attributes, tmp);
}

/* static CARD32 hashCI (xCharInfo *p); */
#define hashCI(p) \
	(CARD32)(((p->leftSideBearing << 27) + (p->leftSideBearing >> 5) + \
	          (p->rightSideBearing << 23) + (p->rightSideBearing >> 9) + \
	          (p->characterWidth << 16) + \
	          (p->ascent << 11) + (p->descent << 6)) ^ p->attributes)

static int
ProcXF86BigfontQueryFont(
    ClientPtr client)
{
    FontPtr pFont;
    REQUEST(xXF86BigfontQueryFontReq);
    CARD32 stuff_flags;
    xCharInfo* pmax;
    xCharInfo* pmin;
    int nCharInfos;
    int shmid;
#ifdef HAS_SHM
    ShmDescPtr pDesc = NULL;
#else
#define pDesc 0
#endif
    xCharInfo* pCI;
    CARD16* pIndex2UniqIndex;
    CARD16* pUniqIndex2Index;
    CARD32 nUniqCharInfos;

#if 0
    REQUEST_SIZE_MATCH(xXF86BigfontQueryFontReq);
#else
    switch (client->req_len) {
	case 2: /* client with version 1.0 libX11 */
	    stuff_flags = (LocalClient(client) && !client->swapped ? XF86Bigfont_FLAGS_Shm : 0);
	    break;
	case 3: /* client with version 1.1 libX11 */
	    stuff_flags = stuff->flags;
	    break;
	default:
	    return BadLength;
    }
#endif
    if (dixLookupFontable(&pFont, stuff->id, client, DixGetAttrAccess) != Success)
	return BadFont;    /* procotol spec says only error is BadFont */

    pmax = FONTINKMAX(pFont);
    pmin = FONTINKMIN(pFont);
    nCharInfos =
       (pmax->rightSideBearing == pmin->rightSideBearing
        && pmax->leftSideBearing == pmin->leftSideBearing
        && pmax->descent == pmin->descent
        && pmax->ascent == pmin->ascent
        && pmax->characterWidth == pmin->characterWidth)
       ? 0 : N2dChars(pFont);
    shmid = -1;
    pCI = NULL;
    pIndex2UniqIndex = NULL;
    pUniqIndex2Index = NULL;
    nUniqCharInfos = 0;

    if (nCharInfos > 0) {
#ifdef HAS_SHM
	if (!badSysCall)
	    pDesc = (ShmDescPtr) FontGetPrivate(pFont, FontShmdescIndex);
	if (pDesc) {
	    pCI = (xCharInfo *) pDesc->attach_addr;
	    if (stuff_flags & XF86Bigfont_FLAGS_Shm)
		shmid = pDesc->shmid;
	} else {
	    if (stuff_flags & XF86Bigfont_FLAGS_Shm && !badSysCall)
		pDesc = shmalloc(nCharInfos * sizeof(xCharInfo)
				 + sizeof(CARD32));
	    if (pDesc) {
		pCI = (xCharInfo *) pDesc->attach_addr;
		shmid = pDesc->shmid;
	    } else {
#endif
		pCI = malloc(nCharInfos * sizeof(xCharInfo));
		if (!pCI)
		    return BadAlloc;
#ifdef HAS_SHM
	    }
#endif
	    /* Fill nCharInfos starting at pCI. */
	    {
		xCharInfo* prCI = pCI;
		int ninfos = 0;
		int ncols = pFont->info.lastCol - pFont->info.firstCol + 1;
		int row;
		for (row = pFont->info.firstRow;
		     row <= pFont->info.lastRow && ninfos < nCharInfos;
		     row++) {
		    unsigned char chars[512];
		    xCharInfo* tmpCharInfos[256];
		    unsigned long count;
		    int col;
		    unsigned long i;
		    i = 0;
		    for (col = pFont->info.firstCol;
			 col <= pFont->info.lastCol;
			 col++) {
			chars[i++] = row;
			chars[i++] = col;
		    }
		    (*pFont->get_metrics) (pFont, ncols, chars, TwoD16Bit,
					   &count, tmpCharInfos);
		    for (i = 0; i < count && ninfos < nCharInfos; i++) {
			*prCI++ = *tmpCharInfos[i];
			ninfos++;
		    }
		}
	    }
#ifdef HAS_SHM
	    if (pDesc && !badSysCall) {
		*(CARD32 *)(pCI + nCharInfos) = signature;
		if (!FontSetPrivate(pFont, FontShmdescIndex, pDesc)) {
		    shmdealloc(pDesc);
		    return BadAlloc;
		}
	    }
	}
#endif
	if (shmid == -1) {
	    /* Cannot use shared memory, so remove-duplicates the xCharInfos
	       using a temporary hash table. */
	    /* Note that CARD16 is suitable as index type, because
	       nCharInfos <= 0x10000. */
	    CARD32 hashModulus;
	    CARD16* pHash2UniqIndex;
	    CARD16* pUniqIndex2NextUniqIndex;
	    CARD32 NextIndex;
	    CARD32 NextUniqIndex;
	    CARD16* tmp;
	    CARD32 i, j;

	    hashModulus = 67;
	    if (hashModulus > nCharInfos+1)
		hashModulus = nCharInfos+1;

	    tmp = malloc((4*nCharInfos+1) * sizeof(CARD16));
	    if (!tmp) {
		if (!pDesc) free(pCI);
		return BadAlloc;
	    }
	    pIndex2UniqIndex = tmp;
		/* nCharInfos elements */
	    pUniqIndex2Index = tmp + nCharInfos;
		/* max. nCharInfos elements */
	    pUniqIndex2NextUniqIndex = tmp + 2*nCharInfos;
		/* max. nCharInfos elements */
	    pHash2UniqIndex = tmp + 3*nCharInfos;
		/* hashModulus (<= nCharInfos+1) elements */

	    /* Note that we can use 0xffff as end-of-list indicator, because
	       even if nCharInfos = 0x10000, 0xffff can not occur as valid
	       entry before the last element has been inserted. And once the
	       last element has been inserted, we don't need the hash table
	       any more. */
	    for (j = 0; j < hashModulus; j++)
		pHash2UniqIndex[j] = (CARD16)(-1);

	    NextUniqIndex = 0;
	    for (NextIndex = 0; NextIndex < nCharInfos; NextIndex++) {
		xCharInfo* p = &pCI[NextIndex];
		CARD32 hashCode = hashCI(p) % hashModulus;
		for (i = pHash2UniqIndex[hashCode];
		     i != (CARD16)(-1);
		     i = pUniqIndex2NextUniqIndex[i]) {
		    j = pUniqIndex2Index[i];
		    if (pCI[j].leftSideBearing == p->leftSideBearing
			&& pCI[j].rightSideBearing == p->rightSideBearing
			&& pCI[j].characterWidth == p->characterWidth
			&& pCI[j].ascent == p->ascent
			&& pCI[j].descent == p->descent
			&& pCI[j].attributes == p->attributes)
			break;
		}
		if (i != (CARD16)(-1)) {
		    /* Found *p at Index j, UniqIndex i */
		    pIndex2UniqIndex[NextIndex] = i;
		} else {
		    /* Allocate a new entry in the Uniq table */
		    if (hashModulus <= 2*NextUniqIndex
			&& hashModulus < nCharInfos+1) {
			/* Time to increate hash table size */
			hashModulus = 2*hashModulus+1;
			if (hashModulus > nCharInfos+1)
			    hashModulus = nCharInfos+1;
			for (j = 0; j < hashModulus; j++)
			    pHash2UniqIndex[j] = (CARD16)(-1);
			for (i = 0; i < NextUniqIndex; i++)
			    pUniqIndex2NextUniqIndex[i] = (CARD16)(-1);
			for (i = 0; i < NextUniqIndex; i++) {
			    j = pUniqIndex2Index[i];
			    p = &pCI[j];
			    hashCode = hashCI(p) % hashModulus;
			    pUniqIndex2NextUniqIndex[i] = pHash2UniqIndex[hashCode];
			    pHash2UniqIndex[hashCode] = i;
			}
			p = &pCI[NextIndex];
			hashCode = hashCI(p) % hashModulus;
		    }
		    i = NextUniqIndex++;
		    pUniqIndex2NextUniqIndex[i] = pHash2UniqIndex[hashCode];
		    pHash2UniqIndex[hashCode] = i;
		    pUniqIndex2Index[i] = NextIndex;
		    pIndex2UniqIndex[NextIndex] = i;
		}
	    }
	    nUniqCharInfos = NextUniqIndex;
	    /* fprintf(stderr, "font metrics: nCharInfos = %d, nUniqCharInfos = %d, hashModulus = %d\n", nCharInfos, nUniqCharInfos, hashModulus); */
	}
    }

    {
	int nfontprops = pFont->info.nprops;
	int rlength =
	   sizeof(xXF86BigfontQueryFontReply)
	   + nfontprops * sizeof(xFontProp)
	   + (nCharInfos > 0 && shmid == -1
	      ? nUniqCharInfos * sizeof(xCharInfo)
	        + (nCharInfos+1)/2 * 2 * sizeof(CARD16)
	      : 0);
	xXF86BigfontQueryFontReply* reply = malloc(rlength);
	char* p;
	if (!reply) {
	    if (nCharInfos > 0) {
		if (shmid == -1) free(pIndex2UniqIndex);
		if (!pDesc) free(pCI);
	    }
	    return BadAlloc;
	}
	reply->type = X_Reply;
	reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
	reply->sequenceNumber = client->sequence;
	reply->minBounds = pFont->info.ink_minbounds;
	reply->maxBounds = pFont->info.ink_maxbounds;
	reply->minCharOrByte2 = pFont->info.firstCol;
	reply->maxCharOrByte2 = pFont->info.lastCol;
	reply->defaultChar = pFont->info.defaultCh;
	reply->nFontProps = pFont->info.nprops;
	reply->drawDirection = pFont->info.drawDirection;
	reply->minByte1 = pFont->info.firstRow;
	reply->maxByte1 = pFont->info.lastRow;
	reply->allCharsExist = pFont->info.allExist;
	reply->fontAscent = pFont->info.fontAscent;
	reply->fontDescent = pFont->info.fontDescent;
	reply->nCharInfos = nCharInfos;
        reply->nUniqCharInfos = nUniqCharInfos;
	reply->shmid = shmid;
	reply->shmsegoffset = 0;
	if (client->swapped) {
	    char tmp;
	    swaps(&reply->sequenceNumber, tmp);
	    swapl(&reply->length, tmp);
	    swapCharInfo(&reply->minBounds);
	    swapCharInfo(&reply->maxBounds);
	    swaps(&reply->minCharOrByte2, tmp);
	    swaps(&reply->maxCharOrByte2, tmp);
	    swaps(&reply->defaultChar, tmp);
	    swaps(&reply->nFontProps, tmp);
	    swaps(&reply->fontAscent, tmp);
	    swaps(&reply->fontDescent, tmp);
	    swapl(&reply->nCharInfos, tmp);
	    swapl(&reply->nUniqCharInfos, tmp);
	    swapl(&reply->shmid, tmp);
	    swapl(&reply->shmsegoffset, tmp);
	}
	p = (char*) &reply[1];
	{
	    FontPropPtr pFP;
	    xFontProp* prFP;
	    int i;
	    for (i = 0, pFP = pFont->info.props, prFP = (xFontProp *) p;
		 i < nfontprops;
		 i++, pFP++, prFP++) {
		prFP->name = pFP->name;
		prFP->value = pFP->value;
		if (client->swapped) {
		    char tmp;
		    swapl(&prFP->name, tmp);
		    swapl(&prFP->value, tmp);
		}
	    }
	    p = (char*) prFP;
	}
	if (nCharInfos > 0 && shmid == -1) {
	    xCharInfo* pci;
	    CARD16* ps;
	    int i, j;
	    pci = (xCharInfo*) p;
	    for (i = 0; i < nUniqCharInfos; i++, pci++) {
		*pci = pCI[pUniqIndex2Index[i]];
		if (client->swapped)
		    swapCharInfo(pci);
	    }
	    ps = (CARD16*) pci;
	    for (j = 0; j < nCharInfos; j++, ps++) {
		*ps = pIndex2UniqIndex[j];
		if (client->swapped) {
		    char tmp;
		    swaps(ps, tmp);
		}
	    }
	}
	WriteToClient(client, rlength, (char *)reply);
	free(reply);
	if (nCharInfos > 0) {
	    if (shmid == -1) free(pIndex2UniqIndex);
	    if (!pDesc) free(pCI);
	}
	return Success;
    }
}

static int
ProcXF86BigfontDispatch(
    ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
	case X_XF86BigfontQueryVersion:
	    return ProcXF86BigfontQueryVersion(client);
	case X_XF86BigfontQueryFont:
	    return ProcXF86BigfontQueryFont(client);
	default:
	    return BadRequest;
    }
}

static int
SProcXF86BigfontQueryVersion(
    ClientPtr client)
{
    REQUEST(xXF86BigfontQueryVersionReq);
    char tmp;

    swaps(&stuff->length, tmp);
    return ProcXF86BigfontQueryVersion(client);
}

static int
SProcXF86BigfontQueryFont(
    ClientPtr client)
{
    REQUEST(xXF86BigfontQueryFontReq);
    char tmp;

    swaps(&stuff->length, tmp);
    REQUEST_SIZE_MATCH(xXF86BigfontQueryFontReq);
    swapl(&stuff->id, tmp);
    return ProcXF86BigfontQueryFont(client);
}

static int
SProcXF86BigfontDispatch(
    ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
	case X_XF86BigfontQueryVersion:
	    return SProcXF86BigfontQueryVersion(client);
	case X_XF86BigfontQueryFont:
	    return SProcXF86BigfontQueryFont(client);
	default:
	    return BadRequest;
    }
}

void
XFree86BigfontExtensionInit(void)
{
    if (AddExtension(XF86BIGFONTNAME,
		     XF86BigfontNumberEvents,
		     XF86BigfontNumberErrors,
		     ProcXF86BigfontDispatch,
		     SProcXF86BigfontDispatch,
		     XF86BigfontResetProc,
		     StandardMinorOpcode)) {
#ifdef HAS_SHM
#ifdef MUST_CHECK_FOR_SHM_SYSCALL
	/*
	 * Note: Local-clients will not be optimized without shared memory
	 * support. Remote-client optimization does not depend on shared
	 * memory support.  Thus, the extension is still registered even
	 * when shared memory support is not functional.
	 */
	if (!CheckForShmSyscall()) {
	    ErrorF(XF86BIGFONTNAME " extension local-client optimization disabled due to lack of shared memory support in the kernel\n");
	    return;
	}
#endif

	srand((unsigned int) time(NULL));
	signature = ((unsigned int) (65536.0/(RAND_MAX+1.0) * rand()) << 16)
	           + (unsigned int) (65536.0/(RAND_MAX+1.0) * rand());
	/* fprintf(stderr, "signature = 0x%08X\n", signature); */

	FontShmdescIndex = AllocateFontPrivateIndex();

#if !defined(CSRG_BASED) && !defined(__CYGWIN__)
	pagesize = SHMLBA;
#else
# ifdef _SC_PAGESIZE
	pagesize = sysconf(_SC_PAGESIZE);
# else
	pagesize = getpagesize();
# endif
#endif
#endif
    }
}
/*
 * Copyright © 2010 Yaakov Selkowitz
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef _XF86BIGFONTSRV_H_
#define _XF86BIGFONTSRV_H_

#include <X11/fonts/font.h>

extern void XFree86BigfontExtensionInit(void);
extern void XF86BigfontFreeFontShm(FontPtr);
extern void XF86BigfontCleanup(void);

#endif
/*
   Copyright (c) 2002  XFree86 Inc
*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <string.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "swaprep.h"
#include "registry.h"
#include <X11/extensions/XResproto.h>
#include "pixmapstr.h"
#include "windowstr.h"
#include "gcstruct.h"
#include "modinit.h"
#include "protocol-versions.h"

static int
ProcXResQueryVersion (ClientPtr client)
{
    REQUEST(xXResQueryVersionReq);
    xXResQueryVersionReply rep;
    CARD16 client_major, client_minor;  /* not used */

    REQUEST_SIZE_MATCH (xXResQueryVersionReq);

    client_major = stuff->client_major;
    client_minor = stuff->client_minor;
    (void) client_major;
    (void) client_minor;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.server_major = SERVER_XRES_MAJOR_VERSION;
    rep.server_minor = SERVER_XRES_MINOR_VERSION;
    if (client->swapped) { 
        int n;
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);     
        swaps(&rep.server_major, n);
        swaps(&rep.server_minor, n);
    }
    WriteToClient(client, sizeof (xXResQueryVersionReply), (char *)&rep);
    return Success;
}

static int
ProcXResQueryClients (ClientPtr client)
{
    /* REQUEST(xXResQueryClientsReq); */
    xXResQueryClientsReply rep;
    int *current_clients;
    int i, num_clients;

    REQUEST_SIZE_MATCH(xXResQueryClientsReq);

    current_clients = malloc(currentMaxClients * sizeof(int));

    num_clients = 0;
    for(i = 0; i < currentMaxClients; i++) {
       if(clients[i]) {
           current_clients[num_clients] = i;
           num_clients++;   
       }
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num_clients = num_clients;
    rep.length = bytes_to_int32(rep.num_clients * sz_xXResClient);
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.num_clients, n);
    }   
    WriteToClient (client, sizeof (xXResQueryClientsReply), (char *) &rep);

    if(num_clients) {
        xXResClient scratch;

        for(i = 0; i < num_clients; i++) {
            scratch.resource_base = clients[current_clients[i]]->clientAsMask;
            scratch.resource_mask = RESOURCE_ID_MASK;
        
            if(client->swapped) {
                int n;
                swapl (&scratch.resource_base, n);
                swapl (&scratch.resource_mask, n);
            }
            WriteToClient (client, sz_xXResClient, (char *) &scratch);
        }
    }

    free(current_clients);

    return Success;
}


static void
ResFindAllRes (pointer value, XID id, RESTYPE type, pointer cdata)
{
    int *counts = (int *)cdata;

    counts[(type & TypeMask) - 1]++;
}

static int
ProcXResQueryClientResources (ClientPtr client)
{
    REQUEST(xXResQueryClientResourcesReq);
    xXResQueryClientResourcesReply rep;
    int i, clientID, num_types;
    int *counts;

    REQUEST_SIZE_MATCH(xXResQueryClientResourcesReq);

    clientID = CLIENT_ID(stuff->xid);

    if((clientID >= currentMaxClients) || !clients[clientID]) {
        client->errorValue = stuff->xid;
        return BadValue;
    }

    counts = calloc(lastResourceType + 1, sizeof(int));

    FindAllClientResources(clients[clientID], ResFindAllRes, counts);

    num_types = 0;

    for(i = 0; i <= lastResourceType; i++) {
       if(counts[i]) num_types++;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num_types = num_types;
    rep.length = bytes_to_int32(rep.num_types * sz_xXResType);
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.num_types, n);
    }   

    WriteToClient (client,sizeof(xXResQueryClientResourcesReply),(char*)&rep);

    if(num_types) {
        xXResType scratch;
	char *name;

        for(i = 0; i < lastResourceType; i++) {
            if(!counts[i]) continue;

	    name = (char *)LookupResourceName(i + 1);
            if (strcmp(name, XREGISTRY_UNKNOWN))
		scratch.resource_type = MakeAtom(name, strlen(name), TRUE);
	    else {
                char buf[40];
                snprintf(buf, sizeof(buf), "Unregistered resource %i", i + 1);
		scratch.resource_type = MakeAtom(buf, strlen(buf), TRUE);
            }

            scratch.count = counts[i];

            if(client->swapped) {
                int n;
                swapl (&scratch.resource_type, n);
                swapl (&scratch.count, n);
            }
            WriteToClient (client, sz_xXResType, (char *) &scratch);
        }
    }

    free(counts);
    
    return Success;
}

static unsigned long
ResGetApproxPixmapBytes (PixmapPtr pix)
{
   unsigned long nPixels;
   int           bytesPerPixel; 

   bytesPerPixel = pix->drawable.bitsPerPixel>>3;
   nPixels       = pix->drawable.width * pix->drawable.height;

   /* Divide by refcnt as pixmap could be shared between clients,  
    * so total pixmap mem is shared between these. 
   */
   return ( nPixels * bytesPerPixel ) / pix->refcnt;
}

static void 
ResFindPixmaps (pointer value, XID id, pointer cdata)
{
   unsigned long *bytes = (unsigned long *)cdata;
   PixmapPtr pix = (PixmapPtr)value;

   *bytes += ResGetApproxPixmapBytes(pix);
}

static void
ResFindWindowPixmaps (pointer value, XID id, pointer cdata)
{
   unsigned long *bytes = (unsigned long *)cdata;
   WindowPtr pWin = (WindowPtr)value;

   if (pWin->backgroundState == BackgroundPixmap)
     *bytes += ResGetApproxPixmapBytes(pWin->background.pixmap);

   if (pWin->border.pixmap != NULL && !pWin->borderIsPixel)
     *bytes += ResGetApproxPixmapBytes(pWin->border.pixmap);
}

static void
ResFindGCPixmaps (pointer value, XID id, pointer cdata)
{
   unsigned long *bytes = (unsigned long *)cdata;
   GCPtr pGC = (GCPtr)value;

   if (pGC->stipple != NULL)
     *bytes += ResGetApproxPixmapBytes(pGC->stipple);

   if (pGC->tile.pixmap != NULL && !pGC->tileIsPixel)
     *bytes += ResGetApproxPixmapBytes(pGC->tile.pixmap);
}

static int
ProcXResQueryClientPixmapBytes (ClientPtr client)
{
    REQUEST(xXResQueryClientPixmapBytesReq);
    xXResQueryClientPixmapBytesReply rep;
    int clientID;
    unsigned long bytes;

    REQUEST_SIZE_MATCH(xXResQueryClientPixmapBytesReq);

    clientID = CLIENT_ID(stuff->xid);

    if((clientID >= currentMaxClients) || !clients[clientID]) {
        client->errorValue = stuff->xid;
        return BadValue;
    }

    bytes = 0;

    FindClientResourcesByType(clients[clientID], RT_PIXMAP, ResFindPixmaps, 
                              (pointer)(&bytes));

    /* 
     * Make sure win background pixmaps also held to account. 
     */
    FindClientResourcesByType(clients[clientID], RT_WINDOW, 
			      ResFindWindowPixmaps, 
                              (pointer)(&bytes));

    /* 
     * GC Tile & Stipple pixmaps too.
    */
    FindClientResourcesByType(clients[clientID], RT_GC, 
			      ResFindGCPixmaps, 
                              (pointer)(&bytes));

#ifdef COMPOSITE
    /* FIXME: include composite pixmaps too */
#endif

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.bytes = bytes;
#ifdef _XSERVER64
    rep.bytes_overflow = bytes >> 32;
#else
    rep.bytes_overflow = 0;
#endif
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.bytes, n);
        swapl (&rep.bytes_overflow, n);
    }
    WriteToClient (client,sizeof(xXResQueryClientPixmapBytesReply),(char*)&rep);

    return Success;
}

static int
ProcResDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_XResQueryVersion:
        return ProcXResQueryVersion(client);
    case X_XResQueryClients:
        return ProcXResQueryClients(client);
    case X_XResQueryClientResources:
        return ProcXResQueryClientResources(client);
    case X_XResQueryClientPixmapBytes:
        return ProcXResQueryClientPixmapBytes(client);
    default: break;
    }

    return BadRequest;
}

static int
SProcXResQueryVersion (ClientPtr client)
{
    REQUEST(xXResQueryVersionReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryVersionReq);
    swaps(&stuff->client_major,n);
    swaps(&stuff->client_minor,n);
    return ProcXResQueryVersion(client);
}

static int
SProcXResQueryClientResources (ClientPtr client)
{
    REQUEST(xXResQueryClientResourcesReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryClientResourcesReq);
    swaps(&stuff->xid,n);
    return ProcXResQueryClientResources(client);
}

static int
SProcXResQueryClientPixmapBytes (ClientPtr client)
{
    REQUEST(xXResQueryClientPixmapBytesReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryClientPixmapBytesReq);
    swaps(&stuff->xid,n);
    return ProcXResQueryClientPixmapBytes(client);
}

static int
SProcResDispatch (ClientPtr client)
{
    REQUEST(xReq);
    int n;

    swaps(&stuff->length,n);

    switch (stuff->data) {
    case X_XResQueryVersion:
        return SProcXResQueryVersion(client);
    case X_XResQueryClients:  /* nothing to swap */
        return ProcXResQueryClients(client);
    case X_XResQueryClientResources:
        return SProcXResQueryClientResources(client);
    case X_XResQueryClientPixmapBytes:
        return SProcXResQueryClientPixmapBytes(client);
    default: break;
    }

    return BadRequest;
}

void
ResExtensionInit(INITARGS)
{
    (void) AddExtension(XRES_NAME, 0, 0,
                            ProcResDispatch, SProcResDispatch,
                            NULL, StandardMinorOpcode);
}
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifndef _XSELINUX_H
#define _XSELINUX_H

/* Extension info */
#define SELINUX_EXTENSION_NAME		"SELinux"
#define SELINUX_MAJOR_VERSION		1
#define SELINUX_MINOR_VERSION		1
#define SELinuxNumberEvents		0
#define SELinuxNumberErrors		0

/* Extension protocol */
#define X_SELinuxQueryVersion			0
#define X_SELinuxSetDeviceCreateContext		1
#define X_SELinuxGetDeviceCreateContext		2
#define X_SELinuxSetDeviceContext		3
#define X_SELinuxGetDeviceContext		4
#define X_SELinuxSetDrawableCreateContext	5
#define X_SELinuxGetDrawableCreateContext	6
#define X_SELinuxGetDrawableContext		7
#define X_SELinuxSetPropertyCreateContext	8
#define X_SELinuxGetPropertyCreateContext	9
#define X_SELinuxSetPropertyUseContext		10
#define X_SELinuxGetPropertyUseContext		11
#define X_SELinuxGetPropertyContext		12
#define X_SELinuxGetPropertyDataContext		13
#define X_SELinuxListProperties			14
#define X_SELinuxSetSelectionCreateContext	15
#define X_SELinuxGetSelectionCreateContext	16
#define X_SELinuxSetSelectionUseContext		17
#define X_SELinuxGetSelectionUseContext		18
#define X_SELinuxGetSelectionContext		19
#define X_SELinuxGetSelectionDataContext	20
#define X_SELinuxListSelections			21
#define X_SELinuxGetClientContext		22

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD8   client_major;
    CARD8   client_minor;
} SELinuxQueryVersionReq;

typedef struct {
    CARD8   type;
    CARD8   pad1;
    CARD16  sequenceNumber;
    CARD32  length;
    CARD16  server_major;
    CARD16  server_minor;
    CARD32  pad2;
    CARD32  pad3;
    CARD32  pad4;
    CARD32  pad5;
    CARD32  pad6; 
} SELinuxQueryVersionReply;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD32  context_len;
} SELinuxSetCreateContextReq;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
} SELinuxGetCreateContextReq;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD32  id;
    CARD32  context_len;
} SELinuxSetContextReq;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD32  id;
} SELinuxGetContextReq;

typedef struct {
    CARD8   reqType;
    CARD8   SELinuxReqType;
    CARD16  length;
    CARD32  window;
    CARD32  property;
} SELinuxGetPropertyContextReq;

typedef struct {
    CARD8   type;
    CARD8   pad1;
    CARD16  sequenceNumber;
    CARD32  length;
    CARD32  context_len;
    CARD32  pad2;
    CARD32  pad3;
    CARD32  pad4;
    CARD32  pad5;
    CARD32  pad6;
} SELinuxGetContextReply;

typedef struct {
    CARD8   type;
    CARD8   pad1;
    CARD16  sequenceNumber;
    CARD32  length;
    CARD32  count;
    CARD32  pad2;
    CARD32  pad3;
    CARD32  pad4;
    CARD32  pad5;
    CARD32  pad6;
} SELinuxListItemsReply;

#endif /* _XSELINUX_H */
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifndef _XSELINUXINT_H
#define _XSELINUXINT_H

#include <selinux/selinux.h>
#include <selinux/avc.h>

#include "globals.h"
#include "dixaccess.h"
#include "dixstruct.h"
#include "privates.h"
#include "resource.h"
#include "registry.h"
#include "inputstr.h"
#include "xselinux.h"

/*
 * Types
 */

#define COMMAND_LEN 64

/* subject state (clients and devices only) */
typedef struct {
    security_id_t sid;
    security_id_t dev_create_sid;
    security_id_t win_create_sid;
    security_id_t sel_create_sid;
    security_id_t prp_create_sid;
    security_id_t sel_use_sid;
    security_id_t prp_use_sid;
    struct avc_entry_ref aeref;
    char command[COMMAND_LEN];
    int privileged;
} SELinuxSubjectRec;

/* object state */
typedef struct {
    security_id_t sid;
    int poly;
} SELinuxObjectRec;

/*
 * Globals
 */

extern DevPrivateKeyRec subjectKeyRec;
#define subjectKey (&subjectKeyRec)
extern DevPrivateKeyRec objectKeyRec;
#define objectKey (&objectKeyRec)
extern DevPrivateKeyRec dataKeyRec;
#define dataKey (&dataKeyRec)

/*
 * Label functions
 */

int
SELinuxAtomToSID(Atom atom, int prop, SELinuxObjectRec **obj_rtn);

int
SELinuxSelectionToSID(Atom selection, SELinuxSubjectRec *subj,
		      security_id_t *sid_rtn, int *poly_rtn);

int
SELinuxPropertyToSID(Atom property, SELinuxSubjectRec *subj,
		     security_id_t *sid_rtn, int *poly_rtn);

int
SELinuxEventToSID(unsigned type, security_id_t sid_of_window,
		  SELinuxObjectRec *sid_return);

int
SELinuxExtensionToSID(const char *name, security_id_t *sid_rtn);

security_class_t
SELinuxTypeToClass(RESTYPE type);

security_context_t
SELinuxDefaultClientLabel(void);

void
SELinuxLabelInit(void);

void
SELinuxLabelReset(void);

/*
 * Security module functions
 */

void
SELinuxFlaskInit(void);

void
SELinuxFlaskReset(void);


/*
 * Private Flask definitions
 */

/* Security class constants */
#define SECCLASS_X_DRAWABLE		1
#define SECCLASS_X_SCREEN		2
#define SECCLASS_X_GC			3
#define SECCLASS_X_FONT			4
#define SECCLASS_X_COLORMAP		5
#define SECCLASS_X_PROPERTY		6
#define SECCLASS_X_SELECTION		7
#define SECCLASS_X_CURSOR		8
#define SECCLASS_X_CLIENT		9
#define SECCLASS_X_POINTER		10
#define SECCLASS_X_KEYBOARD		11
#define SECCLASS_X_SERVER		12
#define SECCLASS_X_EXTENSION		13
#define SECCLASS_X_EVENT		14
#define SECCLASS_X_FAKEEVENT		15
#define SECCLASS_X_RESOURCE		16

#ifdef _XSELINUX_NEED_FLASK_MAP
/* Mapping from DixAccess bits to Flask permissions */
static struct security_class_mapping map[] = {
    { "x_drawable",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "list_property",	/* DixListPropAccess */
          "get_property",	/* DixGetPropAccess */
          "set_property",	/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "list_child",		/* DixListAccess */
          "add_child",		/* DixAddAccess */
          "remove_child",	/* DixRemoveAccess */
          "hide",		/* DixHideAccess */
          "show",		/* DixShowAccess */
          "blend",		/* DixBlendAccess */
          "override",		/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "send",		/* DixSendAccess */
          "receive",		/* DixReceiveAccess */
          "",			/* DixUseAccess */
          "manage",		/* DixManageAccess */
          NULL }},
    { "x_screen",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "saver_getattr",	/* DixListPropAccess */
          "saver_setattr",	/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "hide_cursor",	/* DixHideAccess */
          "show_cursor",	/* DixShowAccess */
          "saver_hide",		/* DixBlendAccess */
          "saver_show",		/* DixGrabAccess */
          NULL }},
    { "x_gc",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_font",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "add_glyph",		/* DixAddAccess */
          "remove_glyph",	/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_colormap",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "add_color",		/* DixAddAccess */
          "remove_color",	/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "install",		/* DixInstallAccess */
          "uninstall",		/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_property",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "write",		/* DixBlendAccess */
          NULL }},
    { "x_selection",
        { "read",		/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "setattr",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          NULL }},
    { "x_cursor",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_client",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "",			/* DixUseAccess */
          "manage",		/* DixManageAccess */
          NULL }},
    { "x_pointer",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "list_property",	/* DixListPropAccess */
          "get_property",	/* DixGetPropAccess */
          "set_property",	/* DixSetPropAccess */
          "getfocus",		/* DixGetFocusAccess */
          "setfocus",		/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "add",		/* DixAddAccess */
          "remove",		/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "grab",		/* DixGrabAccess */
          "freeze",		/* DixFreezeAccess */
          "force_cursor",	/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          "manage",		/* DixManageAccess */
          "",			/* DixDebugAccess */
          "bell",		/* DixBellAccess */
          NULL }},
    { "x_keyboard",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "destroy",		/* DixDestroyAccess */
          "create",		/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "list_property",	/* DixListPropAccess */
          "get_property",	/* DixGetPropAccess */
          "set_property",	/* DixSetPropAccess */
          "getfocus",		/* DixGetFocusAccess */
          "setfocus",		/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "add",		/* DixAddAccess */
          "remove",		/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "grab",		/* DixGrabAccess */
          "freeze",		/* DixFreezeAccess */
          "force_cursor",	/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          "manage",		/* DixManageAccess */
          "",			/* DixDebugAccess */
          "bell",		/* DixBellAccess */
          NULL }},
    { "x_server",
        { "record",		/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "getattr",		/* DixGetAttrAccess */
          "setattr",		/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "grab",		/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "",			/* DixUseAccess */
          "manage",		/* DixManageAccess */
          "debug",		/* DixDebugAccess */
          NULL }},
    { "x_extension",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "query",		/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "",			/* DixSendAccess */
          "",			/* DixReceiveAccess */
          "use",		/* DixUseAccess */
          NULL }},
    { "x_event",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "",			/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "send",		/* DixSendAccess */
          "receive",		/* DixReceiveAccess */
          NULL }},
    { "x_synthetic_event",
        { "",			/* DixReadAccess */
          "",			/* DixWriteAccess */
          "",			/* DixDestroyAccess */
          "",			/* DixCreateAccess */
          "",			/* DixGetAttrAccess */
          "",			/* DixSetAttrAccess */
          "",			/* DixListPropAccess */
          "",			/* DixGetPropAccess */
          "",			/* DixSetPropAccess */
          "",			/* DixGetFocusAccess */
          "",			/* DixSetFocusAccess */
          "",			/* DixListAccess */
          "",			/* DixAddAccess */
          "",			/* DixRemoveAccess */
          "",			/* DixHideAccess */
          "",			/* DixShowAccess */
          "",			/* DixBlendAccess */
          "",			/* DixGrabAccess */
          "",			/* DixFreezeAccess */
          "",			/* DixForceAccess */
          "",			/* DixInstallAccess */
          "",			/* DixUninstallAccess */
          "send",		/* DixSendAccess */
          "receive",		/* DixReceiveAccess */
          NULL }},
    { "x_resource",
        { "read",		/* DixReadAccess */
          "write",		/* DixWriteAccess */
          "write",		/* DixDestroyAccess */
          "write",		/* DixCreateAccess */
          "read",		/* DixGetAttrAccess */
          "write",		/* DixSetAttrAccess */
          "read",		/* DixListPropAccess */
          "read",		/* DixGetPropAccess */
          "write",		/* DixSetPropAccess */
          "read",		/* DixGetFocusAccess */
          "write",		/* DixSetFocusAccess */
          "read",		/* DixListAccess */
          "write",		/* DixAddAccess */
          "write",		/* DixRemoveAccess */
          "write",		/* DixHideAccess */
          "read",		/* DixShowAccess */
          "read",		/* DixBlendAccess */
          "write",		/* DixGrabAccess */
          "write",		/* DixFreezeAccess */
          "write",		/* DixForceAccess */
          "write",		/* DixInstallAccess */
          "write",		/* DixUninstallAccess */
          "write",		/* DixSendAccess */
          "read",		/* DixReceiveAccess */
          "read",		/* DixUseAccess */
          "write",		/* DixManageAccess */
          "read",		/* DixDebugAccess */
          "write",		/* DixBellAccess */
          NULL }},
    { NULL }
};

/* x_resource "read" bits from the list above */
#define SELinuxReadMask (DixReadAccess|DixGetAttrAccess|DixListPropAccess| \
			 DixGetPropAccess|DixGetFocusAccess|DixListAccess| \
			 DixShowAccess|DixBlendAccess|DixReceiveAccess| \
			 DixUseAccess|DixDebugAccess)

#endif /* _XSELINUX_NEED_FLASK_MAP */
#endif /* _XSELINUXINT_H */
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "selection.h"
#include "inputstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "extnsionst.h"
#include "modinit.h"
#include "xselinuxint.h"

#define CTX_DEV offsetof(SELinuxSubjectRec, dev_create_sid)
#define CTX_WIN offsetof(SELinuxSubjectRec, win_create_sid)
#define CTX_PRP offsetof(SELinuxSubjectRec, prp_create_sid)
#define CTX_SEL offsetof(SELinuxSubjectRec, sel_create_sid)
#define USE_PRP offsetof(SELinuxSubjectRec, prp_use_sid)
#define USE_SEL offsetof(SELinuxSubjectRec, sel_use_sid)

typedef struct {
    security_context_t octx;
    security_context_t dctx;
    CARD32 octx_len;
    CARD32 dctx_len;
    CARD32 id;
} SELinuxListItemRec;


/*
 * Extension Dispatch
 */

static security_context_t
SELinuxCopyContext(char *ptr, unsigned len)
{
    security_context_t copy = malloc(len + 1);
    if (!copy)
	return NULL;
    strncpy(copy, ptr, len);
    copy[len] = '\0';
    return copy;
}

static int
ProcSELinuxQueryVersion(ClientPtr client)
{
    SELinuxQueryVersionReply rep;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.server_major = SELINUX_MAJOR_VERSION;
    rep.server_minor = SELINUX_MINOR_VERSION;
    if (client->swapped) {
	int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swaps(&rep.server_major, n);
	swaps(&rep.server_minor, n);
    }
    WriteToClient(client, sizeof(rep), (char *)&rep);
    return Success;
}

static int
SELinuxSendContextReply(ClientPtr client, security_id_t sid)
{
    SELinuxGetContextReply rep;
    security_context_t ctx = NULL;
    int len = 0;

    if (sid) {
	if (avc_sid_to_context_raw(sid, &ctx) < 0)
	    return BadValue;
	len = strlen(ctx) + 1;
    }

    rep.type = X_Reply;
    rep.length = bytes_to_int32(len);
    rep.sequenceNumber = client->sequence;
    rep.context_len = len;

    if (client->swapped) {
	int n;
	swapl(&rep.length, n);
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.context_len, n);
    }

    WriteToClient(client, sizeof(SELinuxGetContextReply), (char *)&rep);
    WriteToClient(client, len, ctx);
    freecon(ctx);
    return Success;
}

static int
ProcSELinuxSetCreateContext(ClientPtr client, unsigned offset)
{
    PrivateRec **privPtr = &client->devPrivates;
    security_id_t *pSid;
    security_context_t ctx = NULL;
    char *ptr;
    int rc;

    REQUEST(SELinuxSetCreateContextReq);
    REQUEST_FIXED_SIZE(SELinuxSetCreateContextReq, stuff->context_len);

    if (stuff->context_len > 0) {
	ctx = SELinuxCopyContext((char *)(stuff + 1), stuff->context_len);
	if (!ctx)
	    return BadAlloc;
    }

    ptr = dixLookupPrivate(privPtr, subjectKey);
    pSid = (security_id_t *)(ptr + offset);
    *pSid = NULL;

    rc = Success;
    if (stuff->context_len > 0) {
	if (security_check_context_raw(ctx) < 0 ||
	    avc_context_to_sid_raw(ctx, pSid) < 0)
	    rc = BadValue;
    }

    free(ctx);
    return rc;
}

static int
ProcSELinuxGetCreateContext(ClientPtr client, unsigned offset)
{
    security_id_t *pSid;
    char *ptr;

    REQUEST_SIZE_MATCH(SELinuxGetCreateContextReq);

    if (offset == CTX_DEV)
	ptr = dixLookupPrivate(&serverClient->devPrivates, subjectKey);
    else
	ptr = dixLookupPrivate(&client->devPrivates, subjectKey);

    pSid = (security_id_t *)(ptr + offset);
    return SELinuxSendContextReply(client, *pSid);
}

static int
ProcSELinuxSetDeviceContext(ClientPtr client)
{
    security_context_t ctx;
    security_id_t sid;
    DeviceIntPtr dev;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    int rc;

    REQUEST(SELinuxSetContextReq);
    REQUEST_FIXED_SIZE(SELinuxSetContextReq, stuff->context_len);

    if (stuff->context_len < 1)
	return BadLength;
    ctx = SELinuxCopyContext((char *)(stuff + 1), stuff->context_len);
    if (!ctx)
	return BadAlloc;

    rc = dixLookupDevice(&dev, stuff->id, client, DixManageAccess);
    if (rc != Success)
	goto out;

    if (security_check_context_raw(ctx) < 0 ||
	avc_context_to_sid_raw(ctx, &sid) < 0) {
	rc = BadValue;
	goto out;
    }

    subj = dixLookupPrivate(&dev->devPrivates, subjectKey);
    subj->sid = sid;
    obj = dixLookupPrivate(&dev->devPrivates, objectKey);
    obj->sid = sid;

    rc = Success;
out:
    free(ctx);
    return rc;
}

static int
ProcSELinuxGetDeviceContext(ClientPtr client)
{
    DeviceIntPtr dev;
    SELinuxSubjectRec *subj;
    int rc;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupDevice(&dev, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    subj = dixLookupPrivate(&dev->devPrivates, subjectKey);
    return SELinuxSendContextReply(client, subj->sid);
}

static int
ProcSELinuxGetDrawableContext(ClientPtr client)
{
    DrawablePtr pDraw;
    PrivateRec **privatePtr;
    SELinuxObjectRec *obj;
    int rc;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupDrawable(&pDraw, stuff->id, client, 0, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    if (pDraw->type == DRAWABLE_PIXMAP)
	privatePtr = &((PixmapPtr)pDraw)->devPrivates;
    else
	privatePtr = &((WindowPtr)pDraw)->devPrivates;

    obj = dixLookupPrivate(privatePtr, objectKey);
    return SELinuxSendContextReply(client, obj->sid);
}

static int
ProcSELinuxGetPropertyContext(ClientPtr client, pointer privKey)
{
    WindowPtr pWin;
    PropertyPtr pProp;
    SELinuxObjectRec *obj;
    int rc;

    REQUEST(SELinuxGetPropertyContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetPropertyContextReq);

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetPropAccess);
    if (rc != Success)
	return rc;

    rc = dixLookupProperty(&pProp, pWin, stuff->property, client,
			   DixGetAttrAccess);
    if (rc != Success)
	return rc;

    obj = dixLookupPrivate(&pProp->devPrivates, privKey);
    return SELinuxSendContextReply(client, obj->sid);
}

static int
ProcSELinuxGetSelectionContext(ClientPtr client, pointer privKey)
{
    Selection *pSel;
    SELinuxObjectRec *obj;
    int rc;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupSelection(&pSel, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    obj = dixLookupPrivate(&pSel->devPrivates, privKey);
    return SELinuxSendContextReply(client, obj->sid);
}

static int
ProcSELinuxGetClientContext(ClientPtr client)
{
    ClientPtr target;
    SELinuxSubjectRec *subj;
    int rc;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupClient(&target, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    subj = dixLookupPrivate(&target->devPrivates, subjectKey);
    return SELinuxSendContextReply(client, subj->sid);
}

static int
SELinuxPopulateItem(SELinuxListItemRec *i, PrivateRec **privPtr, CARD32 id,
		    int *size)
{
    SELinuxObjectRec *obj = dixLookupPrivate(privPtr, objectKey);
    SELinuxObjectRec *data = dixLookupPrivate(privPtr, dataKey);

    if (avc_sid_to_context_raw(obj->sid, &i->octx) < 0)
	return BadValue;
    if (avc_sid_to_context_raw(data->sid, &i->dctx) < 0)
	return BadValue;

    i->id = id;
    i->octx_len = bytes_to_int32(strlen(i->octx) + 1);
    i->dctx_len = bytes_to_int32(strlen(i->dctx) + 1);

    *size += i->octx_len + i->dctx_len + 3;
    return Success;
}

static void
SELinuxFreeItems(SELinuxListItemRec *items, int count)
{
    int k;
    for (k = 0; k < count; k++) {
	freecon(items[k].octx);
	freecon(items[k].dctx);
    }
    free(items);
}

static int
SELinuxSendItemsToClient(ClientPtr client, SELinuxListItemRec *items,
			 int size, int count)
{
    int rc, k, n, pos = 0;
    SELinuxListItemsReply rep;
    CARD32 *buf;

    buf = calloc(size, sizeof(CARD32));
    if (size && !buf) {
	rc = BadAlloc;
	goto out;
    }

    /* Fill in the buffer */
    for (k = 0; k < count; k++) {
	buf[pos] = items[k].id;
	if (client->swapped)
	    swapl(buf + pos, n);
	pos++;

	buf[pos] = items[k].octx_len * 4;
	if (client->swapped)
	    swapl(buf + pos, n);
	pos++;

	buf[pos] = items[k].dctx_len * 4;
	if (client->swapped)
	    swapl(buf + pos, n);
	pos++;

	memcpy((char *)(buf + pos), items[k].octx, strlen(items[k].octx) + 1);
	pos += items[k].octx_len;
	memcpy((char *)(buf + pos), items[k].dctx, strlen(items[k].dctx) + 1);
	pos += items[k].dctx_len;
    }

    /* Send reply to client */
    rep.type = X_Reply;
    rep.length = size;
    rep.sequenceNumber = client->sequence;
    rep.count = count;

    if (client->swapped) {
	swapl(&rep.length, n);
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.count, n);
    }

    WriteToClient(client, sizeof(SELinuxListItemsReply), (char *)&rep);
    WriteToClient(client, size * 4, (char *)buf);

    /* Free stuff and return */
    rc = Success;
    free(buf);
out:
    SELinuxFreeItems(items, count);
    return rc;
}

static int
ProcSELinuxListProperties(ClientPtr client)
{
    WindowPtr pWin;
    PropertyPtr pProp;
    SELinuxListItemRec *items;
    int rc, count, size, i;
    CARD32 id;

    REQUEST(SELinuxGetContextReq);
    REQUEST_SIZE_MATCH(SELinuxGetContextReq);

    rc = dixLookupWindow(&pWin, stuff->id, client, DixListPropAccess);
    if (rc != Success)
	return rc;

    /* Count the number of properties and allocate items */
    count = 0;
    for (pProp = wUserProps(pWin); pProp; pProp = pProp->next)
	count++;
    items = calloc(count, sizeof(SELinuxListItemRec));
    if (count && !items)
	return BadAlloc;

    /* Fill in the items and calculate size */
    i = 0;
    size = 0;
    for (pProp = wUserProps(pWin); pProp; pProp = pProp->next) {
	id = pProp->propertyName;
	rc = SELinuxPopulateItem(items + i, &pProp->devPrivates, id, &size);
	if (rc != Success) {
	    SELinuxFreeItems(items, count);
	    return rc;
	}
	i++;
    }

    return SELinuxSendItemsToClient(client, items, size, count);
}

static int
ProcSELinuxListSelections(ClientPtr client)
{
    Selection *pSel;
    SELinuxListItemRec *items;
    int rc, count, size, i;
    CARD32 id;

    REQUEST_SIZE_MATCH(SELinuxGetCreateContextReq);

    /* Count the number of selections and allocate items */
    count = 0;
    for (pSel = CurrentSelections; pSel; pSel = pSel->next)
	count++;
    items = calloc(count, sizeof(SELinuxListItemRec));
    if (count && !items)
	return BadAlloc;

    /* Fill in the items and calculate size */
    i = 0;
    size = 0;
    for (pSel = CurrentSelections; pSel; pSel = pSel->next) {
	id = pSel->selection;
	rc = SELinuxPopulateItem(items + i, &pSel->devPrivates, id, &size);
	if (rc != Success) {
	    SELinuxFreeItems(items, count);
	    return rc;
	}
	i++;
    }

    return SELinuxSendItemsToClient(client, items, size, count);
}

static int
ProcSELinuxDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_SELinuxQueryVersion:
	return ProcSELinuxQueryVersion(client);
    case X_SELinuxSetDeviceCreateContext:
	return ProcSELinuxSetCreateContext(client, CTX_DEV);
    case X_SELinuxGetDeviceCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_DEV);
    case X_SELinuxSetDeviceContext:
	return ProcSELinuxSetDeviceContext(client);
    case X_SELinuxGetDeviceContext:
	return ProcSELinuxGetDeviceContext(client);
    case X_SELinuxSetDrawableCreateContext:
	return ProcSELinuxSetCreateContext(client, CTX_WIN);
    case X_SELinuxGetDrawableCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_WIN);
    case X_SELinuxGetDrawableContext:
	return ProcSELinuxGetDrawableContext(client);
    case X_SELinuxSetPropertyCreateContext:
	return ProcSELinuxSetCreateContext(client, CTX_PRP);
    case X_SELinuxGetPropertyCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_PRP);
    case X_SELinuxSetPropertyUseContext:
	return ProcSELinuxSetCreateContext(client, USE_PRP);
    case X_SELinuxGetPropertyUseContext:
	return ProcSELinuxGetCreateContext(client, USE_PRP);
    case X_SELinuxGetPropertyContext:
	return ProcSELinuxGetPropertyContext(client, objectKey);
    case X_SELinuxGetPropertyDataContext:
	return ProcSELinuxGetPropertyContext(client, dataKey);
    case X_SELinuxListProperties:
	return ProcSELinuxListProperties(client);
    case X_SELinuxSetSelectionCreateContext:
	return ProcSELinuxSetCreateContext(client, CTX_SEL);
    case X_SELinuxGetSelectionCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_SEL);
    case X_SELinuxSetSelectionUseContext:
	return ProcSELinuxSetCreateContext(client, USE_SEL);
    case X_SELinuxGetSelectionUseContext:
	return ProcSELinuxGetCreateContext(client, USE_SEL);
    case X_SELinuxGetSelectionContext:
	return ProcSELinuxGetSelectionContext(client, objectKey);
    case X_SELinuxGetSelectionDataContext:
	return ProcSELinuxGetSelectionContext(client, dataKey);
    case X_SELinuxListSelections:
	return ProcSELinuxListSelections(client);
    case X_SELinuxGetClientContext:
	return ProcSELinuxGetClientContext(client);
    default:
	return BadRequest;
    }
}

static int
SProcSELinuxQueryVersion(ClientPtr client)
{
    REQUEST(SELinuxQueryVersionReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxQueryVersionReq);
    swaps(&stuff->client_major, n);
    swaps(&stuff->client_minor, n);
    return ProcSELinuxQueryVersion(client);
}

static int
SProcSELinuxSetCreateContext(ClientPtr client, unsigned offset)
{
    REQUEST(SELinuxSetCreateContextReq);
    int n;

    REQUEST_AT_LEAST_SIZE(SELinuxSetCreateContextReq);
    swapl(&stuff->context_len, n);
    return ProcSELinuxSetCreateContext(client, offset);
}

static int
SProcSELinuxSetDeviceContext(ClientPtr client)
{
    REQUEST(SELinuxSetContextReq);
    int n;

    REQUEST_AT_LEAST_SIZE(SELinuxSetContextReq);
    swapl(&stuff->id, n);
    swapl(&stuff->context_len, n);
    return ProcSELinuxSetDeviceContext(client);
}

static int
SProcSELinuxGetDeviceContext(ClientPtr client)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxGetDeviceContext(client);
}

static int
SProcSELinuxGetDrawableContext(ClientPtr client)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxGetDrawableContext(client);
}

static int
SProcSELinuxGetPropertyContext(ClientPtr client, pointer privKey)
{
    REQUEST(SELinuxGetPropertyContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetPropertyContextReq);
    swapl(&stuff->window, n);
    swapl(&stuff->property, n);
    return ProcSELinuxGetPropertyContext(client, privKey);
}

static int
SProcSELinuxGetSelectionContext(ClientPtr client, pointer privKey)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxGetSelectionContext(client, privKey);
}

static int
SProcSELinuxListProperties(ClientPtr client)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxListProperties(client);
}

static int
SProcSELinuxGetClientContext(ClientPtr client)
{
    REQUEST(SELinuxGetContextReq);
    int n;

    REQUEST_SIZE_MATCH(SELinuxGetContextReq);
    swapl(&stuff->id, n);
    return ProcSELinuxGetClientContext(client);
}

static int
SProcSELinuxDispatch(ClientPtr client)
{
    REQUEST(xReq);
    int n;

    swaps(&stuff->length, n);

    switch (stuff->data) {
    case X_SELinuxQueryVersion:
	return SProcSELinuxQueryVersion(client);
    case X_SELinuxSetDeviceCreateContext:
	return SProcSELinuxSetCreateContext(client, CTX_DEV);
    case X_SELinuxGetDeviceCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_DEV);
    case X_SELinuxSetDeviceContext:
	return SProcSELinuxSetDeviceContext(client);
    case X_SELinuxGetDeviceContext:
	return SProcSELinuxGetDeviceContext(client);
    case X_SELinuxSetDrawableCreateContext:
	return SProcSELinuxSetCreateContext(client, CTX_WIN);
    case X_SELinuxGetDrawableCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_WIN);
    case X_SELinuxGetDrawableContext:
	return SProcSELinuxGetDrawableContext(client);
    case X_SELinuxSetPropertyCreateContext:
	return SProcSELinuxSetCreateContext(client, CTX_PRP);
    case X_SELinuxGetPropertyCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_PRP);
    case X_SELinuxSetPropertyUseContext:
	return SProcSELinuxSetCreateContext(client, USE_PRP);
    case X_SELinuxGetPropertyUseContext:
	return ProcSELinuxGetCreateContext(client, USE_PRP);
    case X_SELinuxGetPropertyContext:
	return SProcSELinuxGetPropertyContext(client, objectKey);
    case X_SELinuxGetPropertyDataContext:
	return SProcSELinuxGetPropertyContext(client, dataKey);
    case X_SELinuxListProperties:
	return SProcSELinuxListProperties(client);
    case X_SELinuxSetSelectionCreateContext:
	return SProcSELinuxSetCreateContext(client, CTX_SEL);
    case X_SELinuxGetSelectionCreateContext:
	return ProcSELinuxGetCreateContext(client, CTX_SEL);
    case X_SELinuxSetSelectionUseContext:
	return SProcSELinuxSetCreateContext(client, USE_SEL);
    case X_SELinuxGetSelectionUseContext:
	return ProcSELinuxGetCreateContext(client, USE_SEL);
    case X_SELinuxGetSelectionContext:
	return SProcSELinuxGetSelectionContext(client, objectKey);
    case X_SELinuxGetSelectionDataContext:
	return SProcSELinuxGetSelectionContext(client, dataKey);
    case X_SELinuxListSelections:
	return ProcSELinuxListSelections(client);
    case X_SELinuxGetClientContext:
	return SProcSELinuxGetClientContext(client);
    default:
	return BadRequest;
    }
}


/*
 * Extension Setup / Teardown
 */

static void
SELinuxResetProc(ExtensionEntry *extEntry)
{
    SELinuxFlaskReset();
    SELinuxLabelReset();
}

void
SELinuxExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;

    /* Check SELinux mode on system, configuration file, and boolean */
    if (!is_selinux_enabled()) {
	LogMessage(X_INFO, "SELinux: Disabled on system\n");
	return;
    }
    if (selinuxEnforcingState == SELINUX_MODE_DISABLED) {
	LogMessage(X_INFO, "SELinux: Disabled in configuration file\n");
	return;
    }
    if (!security_get_boolean_active("xserver_object_manager")) {
	LogMessage(X_INFO, "SELinux: Disabled by boolean\n");
        return;
    }

    /* Set up XACE hooks */
    SELinuxLabelInit();
    SELinuxFlaskInit();

    /* Add extension to server */
    extEntry = AddExtension(SELINUX_EXTENSION_NAME,
			    SELinuxNumberEvents, SELinuxNumberErrors,
			    ProcSELinuxDispatch, SProcSELinuxDispatch,
			    SELinuxResetProc, StandardMinorOpcode);

    AddExtensionAlias("Flask", extEntry);
}
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

/*
 * Portions of this code copyright (c) 2005 by Trusted Computer Solutions, Inc.
 * All rights reserved.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/socket.h>
#include <stdio.h>
#include <stdarg.h>

#include <libaudit.h>

#include <X11/Xatom.h>
#include "selection.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "extnsionst.h"
#include "xacestr.h"
#include "client.h"
#include "../os/osdep.h"
#define _XSELINUX_NEED_FLASK_MAP
#include "xselinuxint.h"


/* structure passed to auditing callback */
typedef struct {
    ClientPtr client;	/* client */
    DeviceIntPtr dev;	/* device */
    char *command;	/* client's executable path */
    unsigned id;	/* resource id, if any */
    int restype;	/* resource type, if any */
    int event;		/* event type, if any */
    Atom property;	/* property name, if any */
    Atom selection;	/* selection name, if any */
    char *extension;	/* extension name, if any */
} SELinuxAuditRec;

/* private state keys */
DevPrivateKeyRec subjectKeyRec;
DevPrivateKeyRec objectKeyRec;
DevPrivateKeyRec dataKeyRec;

/* audit file descriptor */
static int audit_fd;

/* atoms for window label properties */
static Atom atom_ctx;
static Atom atom_client_ctx;

/* The unlabeled SID */
static security_id_t unlabeled_sid;

/* forward declarations */
static void SELinuxScreen(CallbackListPtr *, pointer, pointer);

/* "true" pointer value for use as callback data */
static pointer truep = (pointer)1;


/*
 * Performs an SELinux permission check.
 */
static int
SELinuxDoCheck(SELinuxSubjectRec *subj, SELinuxObjectRec *obj,
	       security_class_t class, Mask mode, SELinuxAuditRec *auditdata)
{
    /* serverClient requests OK */
    if (subj->privileged)
	return Success;

    auditdata->command = subj->command;
    errno = 0;

    if (avc_has_perm(subj->sid, obj->sid, class, mode, &subj->aeref,
		     auditdata) < 0) {
	if (mode == DixUnknownAccess)
	    return Success; /* DixUnknownAccess requests OK ... for now */
	if (errno == EACCES)
	    return BadAccess;
	ErrorF("SELinux: avc_has_perm: unexpected error %d\n", errno);
	return BadValue;
    }

    return Success;
}

/*
 * Labels a newly connected client.
 */
static void
SELinuxLabelClient(ClientPtr client)
{
    int fd = XaceGetConnectionNumber(client);
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    security_context_t ctx;

    subj = dixLookupPrivate(&client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&client->devPrivates, objectKey);

    /* Try to get a context from the socket */
    if (fd < 0 || getpeercon_raw(fd, &ctx) < 0) {
	/* Otherwise, fall back to a default context */
	ctx = SELinuxDefaultClientLabel();
    }

    /* For local clients, try and determine the executable name */
    if (XaceIsLocal(client)) {
	/* Get cached command name if CLIENTIDS is enabled. */
	const char *cmdname = GetClientCmdName(client);
	Bool cached = (cmdname != NULL);
	/* If CLIENTIDS is disabled, figure out the command name from
	 * scratch. */
	if (!cmdname)
	{
	    pid_t pid = DetermineClientPid(client);
	    if (pid != -1)
		DetermineClientCmd(pid, &cmdname, NULL);
	}

	if (!cmdname)
	    goto finish;

	strncpy(subj->command, cmdname, COMMAND_LEN - 1);

	if (!cached)
	    free((void *) cmdname); /* const char * */
    }

finish:
    /* Get a SID from the context */
    if (avc_context_to_sid_raw(ctx, &subj->sid) < 0)
	FatalError("SELinux: client %d: context_to_sid_raw(%s) failed\n",
		   client->index, ctx);

    obj->sid = subj->sid;
    freecon(ctx);
}

/*
 * Labels initial server objects.
 */
static void
SELinuxLabelInitial(void)
{
    int i;
    XaceScreenAccessRec srec;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    security_context_t ctx;
    pointer unused;

    /* Do the serverClient */
    subj = dixLookupPrivate(&serverClient->devPrivates, subjectKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, objectKey);
    subj->privileged = 1;

    /* Use the context of the X server process for the serverClient */
    if (getcon_raw(&ctx) < 0)
	FatalError("SELinux: couldn't get context of X server process\n");

    /* Get a SID from the context */
    if (avc_context_to_sid_raw(ctx, &subj->sid) < 0)
	FatalError("SELinux: serverClient: context_to_sid(%s) failed\n", ctx);

    obj->sid = subj->sid;
    freecon(ctx);

    srec.client = serverClient;
    srec.access_mode = DixCreateAccess;
    srec.status = Success;

    for (i = 0; i < screenInfo.numScreens; i++) {
	/* Do the screen object */
	srec.screen = screenInfo.screens[i];
	SELinuxScreen(NULL, NULL, &srec);

	/* Do the default colormap */
	dixLookupResourceByType(&unused, screenInfo.screens[i]->defColormap,
			  RT_COLORMAP, serverClient, DixCreateAccess);
    }
}

/*
 * Labels new resource objects.
 */
static int
SELinuxLabelResource(XaceResourceAccessRec *rec, SELinuxSubjectRec *subj,
		     SELinuxObjectRec *obj, security_class_t class)
{
    int offset;
    security_id_t tsid;

    /* Check for a create context */
    if (rec->rtype & RC_DRAWABLE && subj->win_create_sid) {
	obj->sid = subj->win_create_sid;
	return Success;
    }

    if (rec->parent)
	offset = dixLookupPrivateOffset(rec->ptype);

    if (rec->parent && offset >= 0) {
	/* Use the SID of the parent object in the labeling operation */
	PrivateRec **privatePtr = DEVPRIV_AT(rec->parent, offset);
	SELinuxObjectRec *pobj = dixLookupPrivate(privatePtr, objectKey);
	tsid = pobj->sid;
    } else {
	/* Use the SID of the subject */
	tsid = subj->sid;
    }

    /* Perform a transition to obtain the final SID */
    if (avc_compute_create(subj->sid, tsid, class, &obj->sid) < 0) {
	ErrorF("SELinux: a compute_create call failed!\n");
	return BadValue;
    }

    return Success;
}


/*
 * Libselinux Callbacks
 */

static int
SELinuxAudit(void *auditdata,
	     security_class_t class,
	     char *msgbuf,
	     size_t msgbufsize)
{
    SELinuxAuditRec *audit = auditdata;
    ClientPtr client = audit->client;
    char idNum[16];
    const char *propertyName, *selectionName;
    int major = -1, minor = -1;

    if (client) {
	REQUEST(xReq);
	if (stuff) {
	    major = stuff->reqType;
	    minor = MinorOpcodeOfRequest(client);
	}
    }
    if (audit->id)
	snprintf(idNum, 16, "%x", audit->id);

    propertyName = audit->property ? NameForAtom(audit->property) : NULL;
    selectionName = audit->selection ? NameForAtom(audit->selection) : NULL;

    return snprintf(msgbuf, msgbufsize,
		    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
		    (major >= 0) ? "request=" : "",
		    (major >= 0) ? LookupRequestName(major, minor) : "",
		    audit->command ? " comm=" : "",
		    audit->command ? audit->command : "",
		    audit->dev ? " xdevice=\"" : "",
		    audit->dev ? audit->dev->name : "",
		    audit->dev ? "\"" : "",
		    audit->id ? " resid=" : "",
		    audit->id ? idNum : "",
		    audit->restype ? " restype=" : "",
		    audit->restype ? LookupResourceName(audit->restype) : "",
		    audit->event ? " event=" : "",
		    audit->event ? LookupEventName(audit->event & 127) : "",
		    audit->property ? " property=" : "",
		    audit->property ? propertyName : "",
		    audit->selection ? " selection=" : "",
		    audit->selection ? selectionName : "",
		    audit->extension ? " extension=" : "",
		    audit->extension ? audit->extension : "");
}

static int
SELinuxLog(int type, const char *fmt, ...)
{
    va_list ap;
    char buf[MAX_AUDIT_MESSAGE_LENGTH];
    int rc, aut;

    switch (type) {
    case SELINUX_INFO:
	aut = AUDIT_USER_MAC_POLICY_LOAD;
	break;
    case SELINUX_AVC:
	aut = AUDIT_USER_AVC;
	break;
    default:
	aut = AUDIT_USER_SELINUX_ERR;
	break;
    }

    va_start(ap, fmt);
    vsnprintf(buf, MAX_AUDIT_MESSAGE_LENGTH, fmt, ap);
    rc = audit_log_user_avc_message(audit_fd, aut, buf, NULL, NULL, NULL, 0);
    va_end(ap);
    LogMessageVerb(X_WARNING, 0, "%s", buf);
    return 0;
}

/*
 * XACE Callbacks
 */

static void
SELinuxDevice(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceDeviceAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client, .dev = rec->dev };
    security_class_t cls;
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->dev->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    if (rec->access_mode & DixCreateAccess) {
	SELinuxSubjectRec *dsubj;
	dsubj = dixLookupPrivate(&rec->dev->devPrivates, subjectKey);

	if (subj->dev_create_sid) {
	    /* Label the device with the create context */
	    obj->sid = subj->dev_create_sid;
	    dsubj->sid = subj->dev_create_sid;
	} else {
	    /* Label the device directly with the process SID */
	    obj->sid = subj->sid;
	    dsubj->sid = subj->sid;
	}
    }

    cls = IsPointerDevice(rec->dev) ? SECCLASS_X_POINTER : SECCLASS_X_KEYBOARD;
    rc = SELinuxDoCheck(subj, obj, cls, rec->access_mode, &auditdata);
    if (rc != Success)
	rec->status = rc;
}

static void
SELinuxSend(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceSendAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj, ev_sid;
    SELinuxAuditRec auditdata = { .client = rec->client, .dev = rec->dev };
    security_class_t class;
    int rc, i, type;

    if (rec->dev)
	subj = dixLookupPrivate(&rec->dev->devPrivates, subjectKey);
    else
	subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);

    obj = dixLookupPrivate(&rec->pWin->devPrivates, objectKey);

    /* Check send permission on window */
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_DRAWABLE, DixSendAccess,
			&auditdata);
    if (rc != Success)
	goto err;

    /* Check send permission on specific event types */
    for (i = 0; i < rec->count; i++) {
	type = rec->events[i].u.u.type;
	class = (type & 128) ? SECCLASS_X_FAKEEVENT : SECCLASS_X_EVENT;

	rc = SELinuxEventToSID(type, obj->sid, &ev_sid);
	if (rc != Success)
	    goto err;

	auditdata.event = type;
	rc = SELinuxDoCheck(subj, &ev_sid, class, DixSendAccess, &auditdata);
	if (rc != Success)
	    goto err;
    }
    return;
err:
    rec->status = rc;
}

static void
SELinuxReceive(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceReceiveAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj, ev_sid;
    SELinuxAuditRec auditdata = { .client = NULL };
    security_class_t class;
    int rc, i, type;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->pWin->devPrivates, objectKey);

    /* Check receive permission on window */
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_DRAWABLE, DixReceiveAccess,
			&auditdata);
    if (rc != Success)
	goto err;

    /* Check receive permission on specific event types */
    for (i = 0; i < rec->count; i++) {
	type = rec->events[i].u.u.type;
	class = (type & 128) ? SECCLASS_X_FAKEEVENT : SECCLASS_X_EVENT;

	rc = SELinuxEventToSID(type, obj->sid, &ev_sid);
	if (rc != Success)
	    goto err;

	auditdata.event = type;
	rc = SELinuxDoCheck(subj, &ev_sid, class, DixReceiveAccess, &auditdata);
	if (rc != Success)
	    goto err;
    }
    return;
err:
    rec->status = rc;
}

static void
SELinuxExtension(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceExtAccessRec *rec = calldata;
    SELinuxSubjectRec *subj, *serv;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->ext->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    /* XXX there should be a separate callback for this */
    if (obj->sid == NULL) {
	security_id_t sid;

	serv = dixLookupPrivate(&serverClient->devPrivates, subjectKey);
	rc = SELinuxExtensionToSID(rec->ext->name, &sid);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}

	/* Perform a transition to obtain the final SID */
	if (avc_compute_create(serv->sid, sid, SECCLASS_X_EXTENSION,
			       &obj->sid) < 0) {
	    ErrorF("SELinux: a SID transition call failed!\n");
	    rec->status = BadValue;
	    return;
	}
    }

    /* Perform the security check */
    auditdata.extension = rec->ext->name;
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_EXTENSION, rec->access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;
}

static void
SELinuxSelection(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceSelectionAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj, *data;
    Selection *pSel = *rec->ppSel;
    Atom name = pSel->selection;
    Mask access_mode = rec->access_mode;
    SELinuxAuditRec auditdata = { .client = rec->client, .selection = name };
    security_id_t tsid;
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&pSel->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    if (access_mode & DixCreateAccess) {
	rc = SELinuxSelectionToSID(name, subj, &obj->sid, &obj->poly);
	if (rc != Success)
	    obj->sid = unlabeled_sid;
	access_mode = DixSetAttrAccess;
    }
    /* If this is a polyinstantiated object, find the right instance */
    else if (obj->poly) {
	rc = SELinuxSelectionToSID(name, subj, &tsid, NULL);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}
	while (pSel->selection != name || obj->sid != tsid) {
	    if ((pSel = pSel->next) == NULL)
		break;
	    obj = dixLookupPrivate(&pSel->devPrivates, objectKey);
	}

	if (pSel)
	    *rec->ppSel = pSel;
	else {
	    rec->status = BadMatch;
	    return;
	}
    }

    /* Perform the security check */
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_SELECTION, access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;

    /* Label the content (advisory only) */
    if (access_mode & DixSetAttrAccess) {
	data = dixLookupPrivate(&pSel->devPrivates, dataKey);
	if (subj->sel_create_sid)
	    data->sid = subj->sel_create_sid;
	else
	    data->sid = obj->sid;
    }
}

static void
SELinuxProperty(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XacePropertyAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj, *data;
    PropertyPtr pProp = *rec->ppProp;
    Atom name = pProp->propertyName;
    SELinuxAuditRec auditdata = { .client = rec->client, .property = name };
    security_id_t tsid;
    int rc;

    /* Don't care about the new content check */
    if (rec->access_mode & DixPostAccess)
	return;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&pProp->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    if (rec->access_mode & DixCreateAccess) {
	rc = SELinuxPropertyToSID(name, subj, &obj->sid, &obj->poly);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}
    }
    /* If this is a polyinstantiated object, find the right instance */
    else if (obj->poly) {
	rc = SELinuxPropertyToSID(name, subj, &tsid, NULL);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}
	while (pProp->propertyName != name || obj->sid != tsid) {
	    if ((pProp = pProp->next) == NULL)
		break;
	    obj = dixLookupPrivate(&pProp->devPrivates, objectKey);
	}

	if (pProp)
	    *rec->ppProp = pProp;
	else {
	    rec->status = BadMatch;
	    return;
	}
    }

    /* Perform the security check */
    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_PROPERTY, rec->access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;

    /* Label the content (advisory only) */
    if (rec->access_mode & DixWriteAccess) {
	data = dixLookupPrivate(&pProp->devPrivates, dataKey);
	if (subj->prp_create_sid)
	    data->sid = subj->prp_create_sid;
	else
	    data->sid = obj->sid;
    }
}

static void
SELinuxResource(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceResourceAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    Mask access_mode = rec->access_mode;
    PrivateRec **privatePtr;
    security_class_t class;
    int rc, offset;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);

    /* Determine if the resource object has a devPrivates field */
    offset = dixLookupPrivateOffset(rec->rtype);
    if (offset < 0) {
	/* No: use the SID of the owning client */
	class = SECCLASS_X_RESOURCE;
	privatePtr = &clients[CLIENT_ID(rec->id)]->devPrivates;
	obj = dixLookupPrivate(privatePtr, objectKey);
    } else {
	/* Yes: use the SID from the resource object itself */
	class = SELinuxTypeToClass(rec->rtype);
	privatePtr = DEVPRIV_AT(rec->res, offset);
	obj = dixLookupPrivate(privatePtr, objectKey);
    }

    /* If this is a new object that needs labeling, do it now */
    if (access_mode & DixCreateAccess && offset >= 0) {
	rc = SELinuxLabelResource(rec, subj, obj, class);
	if (rc != Success) {
	    rec->status = rc;
	    return;
	}
    }

    /* Collapse generic resource permissions down to read/write */
    if (class == SECCLASS_X_RESOURCE) {
	access_mode = !!(rec->access_mode & SELinuxReadMask); /* rd */
	access_mode |= !!(rec->access_mode & ~SELinuxReadMask) << 1; /* wr */
    }

    /* Perform the security check */
    auditdata.restype = rec->rtype;
    auditdata.id = rec->id;
    rc = SELinuxDoCheck(subj, obj, class, access_mode, &auditdata);
    if (rc != Success)
	rec->status = rc;

    /* Perform the background none check on windows */
    if (access_mode & DixCreateAccess && rec->rtype == RT_WINDOW) {
	rc = SELinuxDoCheck(subj, obj, class, DixBlendAccess, &auditdata);
	if (rc != Success)
	    ((WindowPtr)rec->res)->forcedBG = TRUE;
    }
}

static void
SELinuxScreen(CallbackListPtr *pcbl, pointer is_saver, pointer calldata)
{
    XaceScreenAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    Mask access_mode = rec->access_mode;
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->screen->devPrivates, objectKey);

    /* If this is a new object that needs labeling, do it now */
    if (access_mode & DixCreateAccess) {
	/* Perform a transition to obtain the final SID */
	if (avc_compute_create(subj->sid, subj->sid, SECCLASS_X_SCREEN,
			       &obj->sid) < 0) {
	    ErrorF("SELinux: a compute_create call failed!\n");
	    rec->status = BadValue;
	    return;
	}
    }

    if (is_saver)
	access_mode <<= 2;

    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_SCREEN, access_mode, &auditdata);
    if (rc != Success)
	rec->status = rc;
}

static void
SELinuxClient(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceClientAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&rec->target->devPrivates, objectKey);

    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_CLIENT, rec->access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;
}

static void
SELinuxServer(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    XaceServerAccessRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    SELinuxAuditRec auditdata = { .client = rec->client };
    int rc;

    subj = dixLookupPrivate(&rec->client->devPrivates, subjectKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, objectKey);

    rc = SELinuxDoCheck(subj, obj, SECCLASS_X_SERVER, rec->access_mode,
			&auditdata);
    if (rc != Success)
	rec->status = rc;
}


/*
 * DIX Callbacks
 */

static void
SELinuxClientState(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    NewClientInfoRec *pci = calldata;

    switch (pci->client->clientState) {
    case ClientStateInitial:
	SELinuxLabelClient(pci->client);
	break;

    default:
	break;
    }
}

static void
SELinuxResourceState(CallbackListPtr *pcbl, pointer unused, pointer calldata)
{
    ResourceStateInfoRec *rec = calldata;
    SELinuxSubjectRec *subj;
    SELinuxObjectRec *obj;
    WindowPtr pWin;

    if (rec->type != RT_WINDOW)
	return;
    if (rec->state != ResourceStateAdding)
	return;

    pWin = (WindowPtr)rec->value;
    subj = dixLookupPrivate(&wClient(pWin)->devPrivates, subjectKey);

    if (subj->sid) {
	security_context_t ctx;
	int rc = avc_sid_to_context_raw(subj->sid, &ctx);
	if (rc < 0)
	    FatalError("SELinux: Failed to get security context!\n");
	rc = dixChangeWindowProperty(serverClient,
				     pWin, atom_client_ctx, XA_STRING, 8,
				     PropModeReplace, strlen(ctx), ctx, FALSE);
	if (rc != Success)
	    FatalError("SELinux: Failed to set label property on window!\n");
	freecon(ctx);
    } else
	FatalError("SELinux: Unexpected unlabeled client found\n");

    obj = dixLookupPrivate(&pWin->devPrivates, objectKey);

    if (obj->sid) {
	security_context_t ctx;
	int rc = avc_sid_to_context_raw(obj->sid, &ctx);
	if (rc < 0)
	    FatalError("SELinux: Failed to get security context!\n");
	rc = dixChangeWindowProperty(serverClient,
				     pWin, atom_ctx, XA_STRING, 8,
				     PropModeReplace, strlen(ctx), ctx, FALSE);
	if (rc != Success)
	    FatalError("SELinux: Failed to set label property on window!\n");
	freecon(ctx);
    } else
	FatalError("SELinux: Unexpected unlabeled window found\n");
}


static int netlink_fd;

static void
SELinuxBlockHandler(void *data, struct timeval **tv, void *read_mask)
{
}

static void
SELinuxWakeupHandler(void *data, int err, void *read_mask)
{
    if (FD_ISSET(netlink_fd, (fd_set *)read_mask))
        avc_netlink_check_nb();
}

void
SELinuxFlaskReset(void)
{
    /* Unregister callbacks */
    DeleteCallback(&ClientStateCallback, SELinuxClientState, NULL);
    DeleteCallback(&ResourceStateCallback, SELinuxResourceState, NULL);

    XaceDeleteCallback(XACE_EXT_DISPATCH, SELinuxExtension, NULL);
    XaceDeleteCallback(XACE_RESOURCE_ACCESS, SELinuxResource, NULL);
    XaceDeleteCallback(XACE_DEVICE_ACCESS, SELinuxDevice, NULL);
    XaceDeleteCallback(XACE_PROPERTY_ACCESS, SELinuxProperty, NULL);
    XaceDeleteCallback(XACE_SEND_ACCESS, SELinuxSend, NULL);
    XaceDeleteCallback(XACE_RECEIVE_ACCESS, SELinuxReceive, NULL);
    XaceDeleteCallback(XACE_CLIENT_ACCESS, SELinuxClient, NULL);
    XaceDeleteCallback(XACE_EXT_ACCESS, SELinuxExtension, NULL);
    XaceDeleteCallback(XACE_SERVER_ACCESS, SELinuxServer, NULL);
    XaceDeleteCallback(XACE_SELECTION_ACCESS, SELinuxSelection, NULL);
    XaceDeleteCallback(XACE_SCREEN_ACCESS, SELinuxScreen, NULL);
    XaceDeleteCallback(XACE_SCREENSAVER_ACCESS, SELinuxScreen, truep);

    /* Tear down SELinux stuff */
    audit_close(audit_fd);
    avc_netlink_release_fd();
    RemoveBlockAndWakeupHandlers(SELinuxBlockHandler, SELinuxWakeupHandler,
                                 NULL);
    RemoveGeneralSocket(netlink_fd);

    avc_destroy();
}

void
SELinuxFlaskInit(void)
{
    struct selinux_opt avc_option = { AVC_OPT_SETENFORCE, (char *)0 };
    security_context_t ctx;
    int ret = TRUE;

    switch(selinuxEnforcingState) {
    case SELINUX_MODE_ENFORCING:
	LogMessage(X_INFO, "SELinux: Configured in enforcing mode\n");
	avc_option.value = (char *)1;
	break;
    case SELINUX_MODE_PERMISSIVE:
	LogMessage(X_INFO, "SELinux: Configured in permissive mode\n");
	avc_option.value = (char *)0;
	break;
    default:
	avc_option.type = AVC_OPT_UNUSED;
	break;
    }

    /* Set up SELinux stuff */
    selinux_set_callback(SELINUX_CB_LOG, (union selinux_callback)SELinuxLog);
    selinux_set_callback(SELINUX_CB_AUDIT, (union selinux_callback)SELinuxAudit);

    if (selinux_set_mapping(map) < 0) {
	if (errno == EINVAL) {
	    ErrorF("SELinux: Invalid object class mapping, disabling SELinux support.\n");
	    return;
	}
	FatalError("SELinux: Failed to set up security class mapping\n");
    }

    if (avc_open(&avc_option, 1) < 0)
	FatalError("SELinux: Couldn't initialize SELinux userspace AVC\n");

    if (security_get_initial_context_raw("unlabeled", &ctx) < 0)
	FatalError("SELinux: Failed to look up unlabeled context\n");
    if (avc_context_to_sid_raw(ctx, &unlabeled_sid) < 0)
	FatalError("SELinux: a context_to_SID call failed!\n");
    freecon(ctx);

    /* Prepare for auditing */
    audit_fd = audit_open();
    if (audit_fd < 0)
	FatalError("SELinux: Failed to open the system audit log\n");

    /* Allocate private storage */
    if (!dixRegisterPrivateKey(subjectKey, PRIVATE_XSELINUX, sizeof(SELinuxSubjectRec)) ||
	!dixRegisterPrivateKey(objectKey, PRIVATE_XSELINUX, sizeof(SELinuxObjectRec)) ||
	!dixRegisterPrivateKey(dataKey, PRIVATE_XSELINUX, sizeof(SELinuxObjectRec)))
	FatalError("SELinux: Failed to allocate private storage.\n");

    /* Create atoms for doing window labeling */
    atom_ctx = MakeAtom("_SELINUX_CONTEXT", 16, TRUE);
    if (atom_ctx == BAD_RESOURCE)
	FatalError("SELinux: Failed to create atom\n");
    atom_client_ctx = MakeAtom("_SELINUX_CLIENT_CONTEXT", 23, TRUE);
    if (atom_client_ctx == BAD_RESOURCE)
	FatalError("SELinux: Failed to create atom\n");

    netlink_fd = avc_netlink_acquire_fd();
    AddGeneralSocket(netlink_fd);
    RegisterBlockAndWakeupHandlers(SELinuxBlockHandler, SELinuxWakeupHandler,
                                   NULL);

    /* Register callbacks */
    ret &= AddCallback(&ClientStateCallback, SELinuxClientState, NULL);
    ret &= AddCallback(&ResourceStateCallback, SELinuxResourceState, NULL);

    ret &= XaceRegisterCallback(XACE_EXT_DISPATCH, SELinuxExtension, NULL);
    ret &= XaceRegisterCallback(XACE_RESOURCE_ACCESS, SELinuxResource, NULL);
    ret &= XaceRegisterCallback(XACE_DEVICE_ACCESS, SELinuxDevice, NULL);
    ret &= XaceRegisterCallback(XACE_PROPERTY_ACCESS, SELinuxProperty, NULL);
    ret &= XaceRegisterCallback(XACE_SEND_ACCESS, SELinuxSend, NULL);
    ret &= XaceRegisterCallback(XACE_RECEIVE_ACCESS, SELinuxReceive, NULL);
    ret &= XaceRegisterCallback(XACE_CLIENT_ACCESS, SELinuxClient, NULL);
    ret &= XaceRegisterCallback(XACE_EXT_ACCESS, SELinuxExtension, NULL);
    ret &= XaceRegisterCallback(XACE_SERVER_ACCESS, SELinuxServer, NULL);
    ret &= XaceRegisterCallback(XACE_SELECTION_ACCESS, SELinuxSelection, NULL);
    ret &= XaceRegisterCallback(XACE_SCREEN_ACCESS, SELinuxScreen, NULL);
    ret &= XaceRegisterCallback(XACE_SCREENSAVER_ACCESS, SELinuxScreen, truep);
    if (!ret)
	FatalError("SELinux: Failed to register one or more callbacks\n");

    /* Label objects that were created before we could register ourself */
    SELinuxLabelInitial();
}
/************************************************************

Author: Eamon Walsh <ewalsh@tycho.nsa.gov>

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
this permission notice appear in supporting documentation.  This permission
notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <selinux/label.h>

#include "registry.h"
#include "xselinuxint.h"

/* selection and property atom cache */
typedef struct {
    SELinuxObjectRec prp;
    SELinuxObjectRec sel;
} SELinuxAtomRec;

/* dynamic array */
typedef struct {
    unsigned size;
    void **array;
} SELinuxArrayRec;

/* labeling handle */
static struct selabel_handle *label_hnd;

/* Array of object classes indexed by resource type */
SELinuxArrayRec arr_types;
/* Array of event SIDs indexed by event type */
SELinuxArrayRec arr_events;
/* Array of property and selection SID structures */
SELinuxArrayRec arr_atoms;

/*
 * Dynamic array helpers
 */
static void *
SELinuxArrayGet(SELinuxArrayRec *rec, unsigned key)
{
    return (rec->size > key) ? rec->array[key] : 0;
}

static int
SELinuxArraySet(SELinuxArrayRec *rec, unsigned key, void *val)
{
    if (key >= rec->size) {
	/* Need to increase size of array */
	rec->array = realloc(rec->array, (key + 1) * sizeof(val));
	if (!rec->array)
	    return FALSE;
	memset(rec->array + rec->size, 0, (key - rec->size + 1) * sizeof(val));
	rec->size = key + 1;
    }

    rec->array[key] = val;
    return TRUE;
}

static void
SELinuxArrayFree(SELinuxArrayRec *rec, int free_elements)
{
    if (free_elements) {
	unsigned i = rec->size;
	while (i)
	    free(rec->array[--i]);
    }

    free(rec->array);
    rec->size = 0;
    rec->array = NULL;
}

/*
 * Looks up a name in the selection or property mappings
 */
static int
SELinuxAtomToSIDLookup(Atom atom, SELinuxObjectRec *obj, int map, int polymap)
{
    const char *name = NameForAtom(atom);
    security_context_t ctx;
    int rc = Success;

    obj->poly = 1;

    /* Look in the mappings of names to contexts */
    if (selabel_lookup_raw(label_hnd, &ctx, name, map) == 0) {
	obj->poly = 0;
    } else if (errno != ENOENT) {
	ErrorF("SELinux: a property label lookup failed!\n");
	return BadValue;
    } else if (selabel_lookup_raw(label_hnd, &ctx, name, polymap) < 0) {
	ErrorF("SELinux: a property label lookup failed!\n");
	return BadValue;
    }

    /* Get a SID for context */
    if (avc_context_to_sid_raw(ctx, &obj->sid) < 0) {
	ErrorF("SELinux: a context_to_SID_raw call failed!\n");
	rc = BadAlloc;
    }

    freecon(ctx);
    return rc;
}

/*
 * Looks up the SID corresponding to the given property or selection atom
 */
int
SELinuxAtomToSID(Atom atom, int prop, SELinuxObjectRec **obj_rtn)
{
    SELinuxAtomRec *rec;
    SELinuxObjectRec *obj;
    int rc, map, polymap;

    rec = SELinuxArrayGet(&arr_atoms, atom);
    if (!rec) {
	rec = calloc(1, sizeof(SELinuxAtomRec));
	if (!rec || !SELinuxArraySet(&arr_atoms, atom, rec))
	    return BadAlloc;
    }

    if (prop) {
	obj = &rec->prp;
	map = SELABEL_X_PROP;
	polymap = SELABEL_X_POLYPROP;
    } else {
	obj = &rec->sel;
	map = SELABEL_X_SELN;
	polymap = SELABEL_X_POLYSELN;
    }

    if (!obj->sid) {
	rc = SELinuxAtomToSIDLookup(atom, obj, map, polymap);
	if (rc != Success)
	    goto out;
    }

    *obj_rtn = obj;
    rc = Success;
out:
    return rc;
}

/*
 * Looks up a SID for a selection/subject pair
 */
int
SELinuxSelectionToSID(Atom selection, SELinuxSubjectRec *subj,
		      security_id_t *sid_rtn, int *poly_rtn)
{
    int rc;
    SELinuxObjectRec *obj;
    security_id_t tsid;

    /* Get the default context and polyinstantiation bit */
    rc = SELinuxAtomToSID(selection, 0, &obj);
    if (rc != Success)
	return rc;

    /* Check for an override context next */
    if (subj->sel_use_sid) {
	tsid = subj->sel_use_sid;
	goto out;
    }

    tsid = obj->sid;

    /* Polyinstantiate if necessary to obtain the final SID */
    if (obj->poly && avc_compute_member(subj->sid, obj->sid,
					SECCLASS_X_SELECTION, &tsid) < 0) {
	ErrorF("SELinux: a compute_member call failed!\n");
	return BadValue;
    }
out:
    *sid_rtn = tsid;
    if (poly_rtn)
	*poly_rtn = obj->poly;
    return Success;
}

/*
 * Looks up a SID for a property/subject pair
 */
int
SELinuxPropertyToSID(Atom property, SELinuxSubjectRec *subj,
		     security_id_t *sid_rtn, int *poly_rtn)
{
    int rc;
    SELinuxObjectRec *obj;
    security_id_t tsid, tsid2;

    /* Get the default context and polyinstantiation bit */
    rc = SELinuxAtomToSID(property, 1, &obj);
    if (rc != Success)
	return rc;

    /* Check for an override context next */
    if (subj->prp_use_sid) {
	tsid = subj->prp_use_sid;
	goto out;
    }

    /* Perform a transition */
    if (avc_compute_create(subj->sid, obj->sid,
			   SECCLASS_X_PROPERTY, &tsid) < 0) {
	ErrorF("SELinux: a compute_create call failed!\n");
	return BadValue;
    }

    /* Polyinstantiate if necessary to obtain the final SID */
    if (obj->poly) {
	tsid2 = tsid;
	if (avc_compute_member(subj->sid, tsid2,
			       SECCLASS_X_PROPERTY, &tsid) < 0) {
	    ErrorF("SELinux: a compute_member call failed!\n");
	    return BadValue;
	}
    }
out:
    *sid_rtn = tsid;
    if (poly_rtn)
	*poly_rtn = obj->poly;
    return Success;
}

/*
 * Looks up the SID corresponding to the given event type
 */
int
SELinuxEventToSID(unsigned type, security_id_t sid_of_window,
		  SELinuxObjectRec *sid_return)
{
    const char *name = LookupEventName(type);
    security_id_t sid;
    security_context_t ctx;
    type &= 127;

    sid = SELinuxArrayGet(&arr_events, type);
    if (!sid) {
	/* Look in the mappings of event names to contexts */
	if (selabel_lookup_raw(label_hnd, &ctx, name, SELABEL_X_EVENT) < 0) {
	    ErrorF("SELinux: an event label lookup failed!\n");
	    return BadValue;
	}
	/* Get a SID for context */
	if (avc_context_to_sid_raw(ctx, &sid) < 0) {
	    ErrorF("SELinux: a context_to_SID_raw call failed!\n");
	    freecon(ctx);
	    return BadAlloc;
	}
	freecon(ctx);
	/* Cache the SID value */
	if (!SELinuxArraySet(&arr_events, type, sid))
	    return BadAlloc;
    }

    /* Perform a transition to obtain the final SID */
    if (avc_compute_create(sid_of_window, sid, SECCLASS_X_EVENT,
			   &sid_return->sid) < 0) {
	ErrorF("SELinux: a compute_create call failed!\n");
	return BadValue;
    }

    return Success;
}

int
SELinuxExtensionToSID(const char *name, security_id_t *sid_rtn)
{
    security_context_t ctx;

    /* Look in the mappings of extension names to contexts */
    if (selabel_lookup_raw(label_hnd, &ctx, name, SELABEL_X_EXT) < 0) {
	ErrorF("SELinux: a property label lookup failed!\n");
	return BadValue;
    }
    /* Get a SID for context */
    if (avc_context_to_sid_raw(ctx, sid_rtn) < 0) {
	ErrorF("SELinux: a context_to_SID_raw call failed!\n");
	freecon(ctx);
	return BadAlloc;
    }
    freecon(ctx);
    return Success;
}

/*
 * Returns the object class corresponding to the given resource type.
 */
security_class_t
SELinuxTypeToClass(RESTYPE type)
{
    void *tmp;

    tmp = SELinuxArrayGet(&arr_types, type & TypeMask);
    if (!tmp) {
	unsigned long class = SECCLASS_X_RESOURCE;

	if (type & RC_DRAWABLE)
	    class = SECCLASS_X_DRAWABLE;
	else if (type == RT_GC)
	    class = SECCLASS_X_GC;
	else if (type == RT_FONT)
	    class = SECCLASS_X_FONT;
	else if (type == RT_CURSOR)
	    class = SECCLASS_X_CURSOR;
	else if (type == RT_COLORMAP)
	    class = SECCLASS_X_COLORMAP;
	else {
	    /* Need to do a string lookup */
	    const char *str = LookupResourceName(type);
	    if (!strcmp(str, "PICTURE"))
		class = SECCLASS_X_DRAWABLE;
	    else if (!strcmp(str, "GLYPHSET"))
		class = SECCLASS_X_FONT;
	}

	tmp = (void *)class;
	SELinuxArraySet(&arr_types, type & TypeMask, tmp);
    }

    return (security_class_t)(unsigned long)tmp;
}

security_context_t
SELinuxDefaultClientLabel(void)
{
    security_context_t ctx;

    if (selabel_lookup_raw(label_hnd, &ctx, "remote", SELABEL_X_CLIENT) < 0)
	FatalError("SELinux: failed to look up remote-client context\n");

    return ctx;
}

void
SELinuxLabelInit(void)
{
    struct selinux_opt selabel_option = { SELABEL_OPT_VALIDATE, (char *)1 };

    label_hnd = selabel_open(SELABEL_CTX_X, &selabel_option, 1);
    if (!label_hnd)
	FatalError("SELinux: Failed to open x_contexts mapping in policy\n");
}

void
SELinuxLabelReset(void)
{
    selabel_close(label_hnd);
    label_hnd = NULL;

    /* Free local state */
    SELinuxArrayFree(&arr_types, 0);
    SELinuxArrayFree(&arr_events, 0);
    SELinuxArrayFree(&arr_atoms, 1);
}
/*

   Copyright 1992, 1998  The Open Group

   Permission to use, copy, modify, distribute, and sell this software and its
   documentation for any purpose is hereby granted without fee, provided that
   the above copyright notice appear in all copies and that both that
   copyright notice and this permission notice appear in supporting
   documentation.

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.

   Except as contained in this notice, the name of The Open Group shall
   not be used in advertising or otherwise to promote the sale, use or
   other dealings in this Software without prior written authorization
   from The Open Group.

 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "windowstr.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "dixevents.h"
#include "sleepuntil.h"
#include "mi.h"
#include "xkbsrv.h"
#include "xkbstr.h"
#include <X11/extensions/xtestproto.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "mipointer.h"
#include "xserver-properties.h"
#include "exevents.h"
#include "eventstr.h"
#include "inpututils.h"

#include "modinit.h"

extern int DeviceValuator;

/* XTest events are sent during request processing and may be interruped by
 * a SIGIO. We need a separate event list to avoid events overwriting each
 * other's memory */
static InternalEvent* xtest_evlist;

/**
 * xtestpointer
 * is the virtual pointer for XTest. It is the first slave
 * device of the VCP.
 * xtestkeyboard
 * is the virtual keyboard for XTest. It is the first slave
 * device of the VCK
 *
 * Neither of these devices can be deleted.
 */
DeviceIntPtr xtestpointer, xtestkeyboard;

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

static int XTestSwapFakeInput(
        ClientPtr /* client */,
        xReq * /* req */
        );


static int
ProcXTestGetVersion(ClientPtr client)
{
    xXTestGetVersionReply rep;
    int n;

    REQUEST_SIZE_MATCH(xXTestGetVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = XTestMajorVersion;
    rep.minorVersion = XTestMinorVersion;
    if (client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xXTestGetVersionReply), (char *)&rep);
    return Success;
}

static int
ProcXTestCompareCursor(ClientPtr client)
{
    REQUEST(xXTestCompareCursorReq);
    xXTestCompareCursorReply rep;
    WindowPtr pWin;
    CursorPtr pCursor;
    int n, rc;
    DeviceIntPtr ptr = PickPointer(client);

    REQUEST_SIZE_MATCH(xXTestCompareCursorReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->cursor == None)
        pCursor = NullCursor;
    else if (stuff->cursor == XTestCurrentCursor)
        pCursor = GetSpriteCursor(ptr);
    else {
        rc = dixLookupResourceByType((pointer *)&pCursor, stuff->cursor, RT_CURSOR,
				     client, DixReadAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->cursor;
            return rc;
        }
    }
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.same = (wCursor(pWin) == pCursor);
    if (client->swapped) {
        swaps(&rep.sequenceNumber, n);
    }
    WriteToClient(client, sizeof(xXTestCompareCursorReply), (char *)&rep);
    return Success;
}

static int
ProcXTestFakeInput(ClientPtr client)
{
    REQUEST(xXTestFakeInputReq);
    int nev, n, type, rc;
    xEvent *ev;
    DeviceIntPtr dev = NULL;
    WindowPtr root;
    Bool extension = FALSE;
    deviceValuator *dv = NULL;
    ValuatorMask mask;
    int valuators[MAX_VALUATORS] = {0};
    int numValuators = 0;
    int firstValuator = 0;
    int nevents = 0;
    int i;
    int base = 0;
    int flags = 0;
    int need_ptr_update = 1;

    nev = (stuff->length << 2) - sizeof(xReq);
    if ((nev % sizeof(xEvent)) || !nev)
        return BadLength;
    nev /= sizeof(xEvent);
    UpdateCurrentTime();
    ev = (xEvent *)&((xReq *)stuff)[1];
    type = ev->u.u.type & 0177;

    if (type >= EXTENSION_EVENT_BASE)
    {
        extension = TRUE;

        /* check device */
        rc = dixLookupDevice(&dev, stuff->deviceid & 0177, client,
                DixWriteAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->deviceid & 0177;
            return rc;
        }

        /* check type */
        type -= DeviceValuator;
        switch (type) {
            case XI_DeviceKeyPress:
            case XI_DeviceKeyRelease:
                if (!dev->key)
                {
                    client->errorValue = ev->u.u.type;
                    return BadValue;
                }
                break;
            case XI_DeviceButtonPress:
            case XI_DeviceButtonRelease:
                if (!dev->button)
                {
                    client->errorValue = ev->u.u.type;
                    return BadValue;
                }
                break;
            case XI_DeviceMotionNotify:
                if (!dev->valuator)
                {
                    client->errorValue = ev->u.u.type;
                    return BadValue;
                }
                break;
            case XI_ProximityIn:
            case XI_ProximityOut:
                if (!dev->proximity)
                {
                    client->errorValue = ev->u.u.type;
                    return BadValue;
                }
                break;
            default:
                client->errorValue = ev->u.u.type;
                return BadValue;
        }

        /* check validity */
        if (nev == 1 && type == XI_DeviceMotionNotify)
            return BadLength; /* DevMotion must be followed by DevValuator */

        if (type == XI_DeviceMotionNotify)
        {
            firstValuator = ((deviceValuator *)(ev+1))->first_valuator;
            if (firstValuator > dev->valuator->numAxes)
            {
                client->errorValue = ev->u.u.type;
                return BadValue;
            }

            if (ev->u.u.detail == xFalse)
                flags |= POINTER_ABSOLUTE;
        } else
        {
            firstValuator = 0;
            flags |= POINTER_ABSOLUTE;
        }

        if (nev > 1 && !dev->valuator)
        {
            client->errorValue = dv->first_valuator;
            return BadValue;
        }


        /* check validity of valuator events */
        base = firstValuator;
        for (n = 1; n < nev; n++)
        {
            dv = (deviceValuator *)(ev + n);
            if (dv->type != DeviceValuator)
            {
                client->errorValue = dv->type;
                return BadValue;
            }
            if (dv->first_valuator != base)
            {
                client->errorValue = dv->first_valuator;
                return BadValue;
            }
            switch(dv->num_valuators)
            {
                case 6: valuators[base + 5] = dv->valuator5;
                case 5: valuators[base + 4] = dv->valuator4;
                case 4: valuators[base + 3] = dv->valuator3;
                case 3: valuators[base + 2] = dv->valuator2;
                case 2: valuators[base + 1] = dv->valuator1;
                case 1: valuators[base] = dv->valuator0;
                        break;
                default:
                        client->errorValue = dv->num_valuators;
                        return BadValue;
            }

            base += dv->num_valuators;
            numValuators += dv->num_valuators;

            if (firstValuator + numValuators > dev->valuator->numAxes)
            {
                client->errorValue = dv->num_valuators;
                return BadValue;
            }
        }
        type = type - XI_DeviceKeyPress + KeyPress;

    } else
    {
        if (nev != 1)
            return BadLength;
        switch (type)
        {
            case KeyPress:
            case KeyRelease:
                dev = PickKeyboard(client);
                break;
            case ButtonPress:
            case ButtonRelease:
                dev = PickPointer(client);
                break;
            case MotionNotify:
                dev = PickPointer(client);
                valuators[0] = ev->u.keyButtonPointer.rootX;
                valuators[1] = ev->u.keyButtonPointer.rootY;
                numValuators = 2;
                firstValuator = 0;
                if (ev->u.u.detail == xFalse)
                    flags = POINTER_ABSOLUTE | POINTER_SCREEN;
                break;
            default:
                client->errorValue = ev->u.u.type;
                return BadValue;
        }

        dev = GetXTestDevice(dev);
    }

    /* If the event has a time set, wait for it to pass */
    if (ev->u.keyButtonPointer.time)
    {
        TimeStamp activateTime;
        CARD32 ms;

        activateTime = currentTime;
        ms = activateTime.milliseconds + ev->u.keyButtonPointer.time;
        if (ms < activateTime.milliseconds)
            activateTime.months++;
        activateTime.milliseconds = ms;
        ev->u.keyButtonPointer.time = 0;

        /* see mbuf.c:QueueDisplayRequest (from the deprecated Multibuffer
         * extension) for code similar to this */

        if (!ClientSleepUntil(client, &activateTime, NULL, NULL))
        {
            return BadAlloc;
        }
        /* swap the request back so we can simply re-execute it */
        if (client->swapped)
        {
            (void) XTestSwapFakeInput(client, (xReq *)stuff);
            swaps(&stuff->length, n);
        }
        ResetCurrentRequest (client);
        client->sequence--;
        return Success;
    }

    switch (type)
    {
        case KeyPress:
        case KeyRelease:
            if (!dev->key)
                return BadDevice;

            if (ev->u.u.detail < dev->key->xkbInfo->desc->min_key_code ||
                ev->u.u.detail > dev->key->xkbInfo->desc->max_key_code)
            {
                client->errorValue = ev->u.u.detail;
                return BadValue;
            }

            need_ptr_update = 0;
            break;
        case MotionNotify:
            if (!dev->valuator)
                return BadDevice;

            if (!(extension || ev->u.keyButtonPointer.root == None))
            {
                rc = dixLookupWindow(&root, ev->u.keyButtonPointer.root,
                                     client, DixGetAttrAccess);
                if (rc != Success)
                    return rc;
                if (root->parent)
                {
                    client->errorValue = ev->u.keyButtonPointer.root;
                    return BadValue;
                }
            }
            if (ev->u.u.detail != xTrue && ev->u.u.detail != xFalse)
            {
                client->errorValue = ev->u.u.detail;
                return BadValue;
            }

            /* FIXME: Xinerama! */

            break;
        case ButtonPress:
        case ButtonRelease:
            if (!dev->button)
                return BadDevice;

            if (!ev->u.u.detail || ev->u.u.detail > dev->button->numButtons)
            {
                client->errorValue = ev->u.u.detail;
                return BadValue;
            }
            break;
    }
    if (screenIsSaved == SCREEN_SAVER_ON)
        dixSaveScreens(serverClient, SCREEN_SAVER_OFF, ScreenSaverReset);

    switch(type) {
        case MotionNotify:
            valuator_mask_set_range(&mask, firstValuator, numValuators, valuators);
            nevents = GetPointerEvents(xtest_evlist, dev, type, 0, flags, &mask);
            break;
        case ButtonPress:
        case ButtonRelease:
            valuator_mask_set_range(&mask, firstValuator, numValuators, valuators);
            nevents = GetPointerEvents(xtest_evlist, dev, type, ev->u.u.detail,
                                       flags, &mask);
            break;
        case KeyPress:
        case KeyRelease:
            nevents = GetKeyboardEvents(xtest_evlist, dev, type, ev->u.u.detail, NULL);
            break;
    }

    for (i = 0; i < nevents; i++)
        mieqProcessDeviceEvent(dev, &xtest_evlist[i], NULL);

    if (need_ptr_update)
        miPointerUpdateSprite(dev);
    return Success;
}

static int
ProcXTestGrabControl(ClientPtr client)
{
    REQUEST(xXTestGrabControlReq);

    REQUEST_SIZE_MATCH(xXTestGrabControlReq);
    if ((stuff->impervious != xTrue) && (stuff->impervious != xFalse))
    {
        client->errorValue = stuff->impervious;
        return BadValue;
    }
    if (stuff->impervious)
        MakeClientGrabImpervious(client);
    else
        MakeClientGrabPervious(client);
    return Success;
}

static int
ProcXTestDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
        case X_XTestGetVersion:
            return ProcXTestGetVersion(client);
        case X_XTestCompareCursor:
            return ProcXTestCompareCursor(client);
        case X_XTestFakeInput:
            return ProcXTestFakeInput(client);
        case X_XTestGrabControl:
            return ProcXTestGrabControl(client);
        default:
            return BadRequest;
    }
}

static int
SProcXTestGetVersion(ClientPtr client)
{
    int n;
    REQUEST(xXTestGetVersionReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXTestGetVersionReq);
    swaps(&stuff->minorVersion, n);
    return ProcXTestGetVersion(client);
}

static int
SProcXTestCompareCursor(ClientPtr client)
{
    int n;
    REQUEST(xXTestCompareCursorReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXTestCompareCursorReq);
    swapl(&stuff->window, n);
    swapl(&stuff->cursor, n);
    return ProcXTestCompareCursor(client);
}

static int
XTestSwapFakeInput(ClientPtr client, xReq *req)
{
    int nev;
    xEvent *ev;
    xEvent sev;
    EventSwapPtr proc;

    nev = ((req->length << 2) - sizeof(xReq)) / sizeof(xEvent);
    for (ev = (xEvent *)&req[1]; --nev >= 0; ev++)
    {
        /* Swap event */
        proc = EventSwapVector[ev->u.u.type & 0177];
        /* no swapping proc; invalid event type? */
        if (!proc ||  proc ==  NotImplemented) {
            client->errorValue = ev->u.u.type;
            return BadValue;
        }
        (*proc)(ev, &sev);
        *ev = sev;
    }
    return Success;
}

static int
SProcXTestFakeInput(ClientPtr client)
{
    int n;
    REQUEST(xReq);

    swaps(&stuff->length, n);
    n = XTestSwapFakeInput(client, stuff);
    if (n != Success)
        return n;
    return ProcXTestFakeInput(client);
}

static int
SProcXTestGrabControl(ClientPtr client)
{
    int n;
    REQUEST(xXTestGrabControlReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXTestGrabControlReq);
    return ProcXTestGrabControl(client);
}

static int
SProcXTestDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
        case X_XTestGetVersion:
            return SProcXTestGetVersion(client);
        case X_XTestCompareCursor:
            return SProcXTestCompareCursor(client);
        case X_XTestFakeInput:
            return SProcXTestFakeInput(client);
        case X_XTestGrabControl:
            return SProcXTestGrabControl(client);
        default:
            return BadRequest;
    }
}

/**
 * Allocate an virtual slave device for xtest events, this
 * is a slave device to inputInfo master devices
 */
void InitXTestDevices(void)
{
    if(AllocXTestDevice(serverClient, "Virtual core",
                       &xtestpointer, &xtestkeyboard,
                       inputInfo.pointer, inputInfo.keyboard) != Success)
        FatalError("Failed to allocate XTest devices");

    if (ActivateDevice(xtestpointer, TRUE) != Success ||
        ActivateDevice(xtestkeyboard, TRUE) != Success)
        FatalError("Failed to activate XTest core devices.");
    if (!EnableDevice(xtestpointer, TRUE) ||
        !EnableDevice(xtestkeyboard, TRUE))
        FatalError("Failed to enable XTest core devices.");

    AttachDevice(NULL, xtestpointer, inputInfo.pointer);
    AttachDevice(NULL, xtestkeyboard, inputInfo.keyboard);
}

/**
 * Don't allow changing the XTest property.
 */
static int
DeviceSetXTestProperty(DeviceIntPtr dev, Atom property,
                      XIPropertyValuePtr prop, BOOL checkonly)
{
    if (property == XIGetKnownProperty(XI_PROP_XTEST_DEVICE))
        return BadAccess;

    return Success;
}

/**
 * Allocate a device pair that is initialised as a slave
 * device with properties that identify the devices as belonging
 * to XTest subsystem.
 * This only creates the pair, Activate/Enable Device
 * still need to be called.
 */
int AllocXTestDevice (ClientPtr client, char* name,
                     DeviceIntPtr* ptr, DeviceIntPtr* keybd,
                     DeviceIntPtr master_ptr, DeviceIntPtr master_keybd)
{
    int retval;
    int len = strlen(name);
    char *xtestname = calloc(len + 7, 1 );
    char dummy = 1;

    strncpy( xtestname, name, len);
    strncat( xtestname, " XTEST", 6 );

    retval = AllocDevicePair( client, xtestname, ptr, keybd, CorePointerProc, CoreKeyboardProc, FALSE);
    if ( retval == Success ){
	(*ptr)->xtest_master_id = master_ptr->id;
	(*keybd)->xtest_master_id = master_keybd->id;

        XIChangeDeviceProperty(*ptr, XIGetKnownProperty(XI_PROP_XTEST_DEVICE),
                XA_INTEGER, 8, PropModeReplace, 1, &dummy,
                FALSE);
        XISetDevicePropertyDeletable(*ptr, XIGetKnownProperty(XI_PROP_XTEST_DEVICE), FALSE);
        XIRegisterPropertyHandler(*ptr, DeviceSetXTestProperty, NULL, NULL);
        XIChangeDeviceProperty(*keybd, XIGetKnownProperty(XI_PROP_XTEST_DEVICE),
                XA_INTEGER, 8, PropModeReplace, 1, &dummy,
                FALSE);
        XISetDevicePropertyDeletable(*keybd, XIGetKnownProperty(XI_PROP_XTEST_DEVICE), FALSE);
        XIRegisterPropertyHandler(*keybd, DeviceSetXTestProperty, NULL, NULL);
    }

    free( xtestname );

    return retval;
}

/**
 * If master is NULL, return TRUE if the given device is an xtest device or
 * FALSE otherwise.
 * If master is not NULL, return TRUE if the given device is this master's
 * xtest device.
 */
BOOL
IsXTestDevice(DeviceIntPtr dev, DeviceIntPtr master)
{
    if (IsMaster(dev))
        return FALSE;

    /* deviceid 0 is reserved for XIAllDevices, non-zero mid means XTest
     * device */
    if (master)
	return dev->xtest_master_id == master->id;

    return dev->xtest_master_id != 0;
}

/**
 * @return The X Test virtual device for the given master.
 */
DeviceIntPtr
GetXTestDevice(DeviceIntPtr master)
{
    DeviceIntPtr it;

    for (it = inputInfo.devices; it; it = it->next)
    {
        if (IsXTestDevice(it, master))
            return it;
    }

    /* This only happens if master is a slave device. don't do that */
    return NULL;
}

static void
XTestExtensionTearDown(ExtensionEntry *e)
{
    FreeEventList(xtest_evlist, GetMaximumEventsNum());
    xtest_evlist = NULL;
}

void
XTestExtensionInit(INITARGS)
{
    AddExtension(XTestExtensionName, 0, 0,
            ProcXTestDispatch, SProcXTestDispatch,
            XTestExtensionTearDown, StandardMinorOpcode);

    xtest_evlist = InitEventList(GetMaximumEventsNum());
}
/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"

#include <X11/extensions/Xv.h>
#include <X11/extensions/Xvproto.h>
#include "xvdix.h"
#ifdef MITSHM
#include <X11/extensions/shmproto.h>
#endif

#include "xvdisp.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"

unsigned long XvXRTPort;
#endif

static int
SWriteQueryExtensionReply(
   ClientPtr client,
   xvQueryExtensionReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->version, n);
  swaps(&rep->revision, n);
  
  (void)WriteToClient(client, sz_xvQueryExtensionReply, (char *)rep);

  return Success;
}

static int
SWriteQueryAdaptorsReply(
   ClientPtr client,
   xvQueryAdaptorsReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->num_adaptors, n);
  
  (void)WriteToClient(client, sz_xvQueryAdaptorsReply, (char *)rep);

  return Success;
}

static int
SWriteQueryEncodingsReply(
   ClientPtr client,
   xvQueryEncodingsReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->num_encodings, n);
  
  (void)WriteToClient(client, sz_xvQueryEncodingsReply, (char *)rep);

  return Success;
}

static int
SWriteAdaptorInfo(
   ClientPtr client,
   xvAdaptorInfo *pAdaptor
){
  char n;

  swapl(&pAdaptor->base_id, n);
  swaps(&pAdaptor->name_size, n);
  swaps(&pAdaptor->num_ports, n);
  swaps(&pAdaptor->num_formats, n);

  (void)WriteToClient(client, sz_xvAdaptorInfo, (char *)pAdaptor);

  return Success;
}

static int
SWriteEncodingInfo(
   ClientPtr client,
   xvEncodingInfo *pEncoding
){
  char n;
  
  swapl(&pEncoding->encoding, n);
  swaps(&pEncoding->name_size, n);
  swaps(&pEncoding->width, n);
  swaps(&pEncoding->height, n);
  swapl(&pEncoding->rate.numerator, n);
  swapl(&pEncoding->rate.denominator, n);
  (void)WriteToClient(client, sz_xvEncodingInfo, (char *)pEncoding);

  return Success;
}

static int
SWriteFormat(
   ClientPtr client,
   xvFormat *pFormat
){
  char n;

  swapl(&pFormat->visual, n);
  (void)WriteToClient(client, sz_xvFormat, (char *)pFormat);

  return Success;
}

static int
SWriteAttributeInfo(
   ClientPtr client,
   xvAttributeInfo *pAtt
){
  char n;

  swapl(&pAtt->flags, n);
  swapl(&pAtt->size, n);
  swapl(&pAtt->min, n);
  swapl(&pAtt->max, n);
  (void)WriteToClient(client, sz_xvAttributeInfo, (char *)pAtt);

  return Success;
}

static int
SWriteImageFormatInfo(
   ClientPtr client,
   xvImageFormatInfo *pImage
){
  char n;

  swapl(&pImage->id, n);
  swapl(&pImage->red_mask, n);
  swapl(&pImage->green_mask, n);
  swapl(&pImage->blue_mask, n);
  swapl(&pImage->y_sample_bits, n);
  swapl(&pImage->u_sample_bits, n);
  swapl(&pImage->v_sample_bits, n);
  swapl(&pImage->horz_y_period, n);
  swapl(&pImage->horz_u_period, n);
  swapl(&pImage->horz_v_period, n);
  swapl(&pImage->vert_y_period, n);
  swapl(&pImage->vert_u_period, n);
  swapl(&pImage->vert_v_period, n);

  (void)WriteToClient(client, sz_xvImageFormatInfo, (char *)pImage);

  return Success;
}

static int
SWriteGrabPortReply(
   ClientPtr client,
   xvGrabPortReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);

  (void)WriteToClient(client, sz_xvGrabPortReply, (char *)rep);

  return Success;
}

static int
SWriteGetPortAttributeReply(
   ClientPtr client,
   xvGetPortAttributeReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->value, n);

  (void)WriteToClient(client, sz_xvGetPortAttributeReply, (char *)rep);

  return Success;
}

static int
SWriteQueryBestSizeReply(
   ClientPtr client,
   xvQueryBestSizeReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->actual_width, n);
  swaps(&rep->actual_height, n);

  (void)WriteToClient(client, sz_xvQueryBestSizeReply, (char *)rep);

  return Success;
}

static int
SWriteQueryPortAttributesReply(
   ClientPtr client,
   xvQueryPortAttributesReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_attributes, n);
  swapl(&rep->text_size, n);

  (void)WriteToClient(client, sz_xvQueryPortAttributesReply, (char *)rep);

  return Success;
}

static int
SWriteQueryImageAttributesReply(
   ClientPtr client,
   xvQueryImageAttributesReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_planes, n);
  swapl(&rep->data_size, n);
  swaps(&rep->width, n);
  swaps(&rep->height, n);

  (void)WriteToClient(client, sz_xvQueryImageAttributesReply, (char *)rep);

  return Success;
}

static int
SWriteListImageFormatsReply(
   ClientPtr client,
   xvListImageFormatsReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_formats, n);

  (void)WriteToClient(client, sz_xvListImageFormatsReply, (char *)rep);

  return Success;
}

#define _WriteQueryAdaptorsReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryAdaptorsReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryAdaptorsReply, (char*)_d)

#define _WriteQueryExtensionReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryExtensionReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryExtensionReply, (char*)_d)

#define _WriteQueryEncodingsReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryEncodingsReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryEncodingsReply, (char*)_d)

#define _WriteAdaptorInfo(_c,_d) \
  if ((_c)->swapped) SWriteAdaptorInfo(_c, _d); \
  else WriteToClient(_c, sz_xvAdaptorInfo, (char*)_d)

#define _WriteAttributeInfo(_c,_d) \
  if ((_c)->swapped) SWriteAttributeInfo(_c, _d); \
  else WriteToClient(_c, sz_xvAttributeInfo, (char*)_d)

#define _WriteEncodingInfo(_c,_d) \
  if ((_c)->swapped) SWriteEncodingInfo(_c, _d); \
  else WriteToClient(_c, sz_xvEncodingInfo, (char*)_d)

#define _WriteFormat(_c,_d) \
  if ((_c)->swapped) SWriteFormat(_c, _d); \
  else WriteToClient(_c, sz_xvFormat, (char*)_d)

#define _WriteGrabPortReply(_c,_d) \
  if ((_c)->swapped) SWriteGrabPortReply(_c, _d); \
  else WriteToClient(_c, sz_xvGrabPortReply, (char*)_d)

#define _WriteGetPortAttributeReply(_c,_d) \
  if ((_c)->swapped) SWriteGetPortAttributeReply(_c, _d); \
  else WriteToClient(_c, sz_xvGetPortAttributeReply, (char*)_d)

#define _WriteQueryBestSizeReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryBestSizeReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryBestSizeReply,(char*) _d)

#define _WriteQueryPortAttributesReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryPortAttributesReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryPortAttributesReply,(char*) _d)

#define _WriteQueryImageAttributesReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryImageAttributesReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryImageAttributesReply,(char*) _d)

#define _WriteListImageFormatsReply(_c,_d) \
  if ((_c)->swapped) SWriteListImageFormatsReply(_c, _d); \
  else WriteToClient(_c, sz_xvListImageFormatsReply,(char*) _d)

#define _WriteImageFormatInfo(_c,_d) \
  if ((_c)->swapped) SWriteImageFormatInfo(_c, _d); \
  else WriteToClient(_c, sz_xvImageFormatInfo, (char*)_d)

#define _AllocatePort(_i,_p) \
  ((_p)->id != _i) ? (* (_p)->pAdaptor->ddAllocatePort)(_i,_p,&_p) : Success

static int
ProcXvQueryExtension(ClientPtr client)
{
  xvQueryExtensionReply rep;
  /* REQUEST(xvQueryExtensionReq); */
  REQUEST_SIZE_MATCH(xvQueryExtensionReq);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.version = XvVersion;
  rep.revision = XvRevision;

  _WriteQueryExtensionReply(client, &rep);

  return Success;
}

static int
ProcXvQueryAdaptors(ClientPtr client)
{
  xvFormat format;
  xvAdaptorInfo ainfo;
  xvQueryAdaptorsReply rep;
  int totalSize, na, nf, rc;
  int nameSize;
  XvAdaptorPtr pa;
  XvFormatPtr pf;
  WindowPtr pWin;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;

  REQUEST(xvQueryAdaptorsReq);
  REQUEST_SIZE_MATCH(xvQueryAdaptorsReq);

  rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
  if (rc != Success)
      return rc;

  pScreen = pWin->drawable.pScreen;
  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
				       XvGetScreenKey());
  if (!pxvs)
    {
      rep.type = X_Reply;
      rep.sequenceNumber = client->sequence;
      rep.num_adaptors = 0;
      rep.length = 0;

      _WriteQueryAdaptorsReply(client, &rep);

      return Success;
    }

  (* pxvs->ddQueryAdaptors)(pScreen, &pxvs->pAdaptors, &pxvs->nAdaptors);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_adaptors = pxvs->nAdaptors;

  /* CALCULATE THE TOTAL SIZE OF THE REPLY IN BYTES */

  totalSize = pxvs->nAdaptors * sz_xvAdaptorInfo;

  /* FOR EACH ADPATOR ADD UP THE BYTES FOR ENCODINGS AND FORMATS */

  na = pxvs->nAdaptors;
  pa = pxvs->pAdaptors;
  while (na--)
    {
      totalSize += pad_to_int32(strlen(pa->name));
      totalSize += pa->nFormats * sz_xvFormat;
      pa++;
    }

  rep.length = bytes_to_int32(totalSize);

  _WriteQueryAdaptorsReply(client, &rep);

  na = pxvs->nAdaptors;
  pa = pxvs->pAdaptors;
  while (na--)
    {

      ainfo.base_id = pa->base_id;
      ainfo.num_ports = pa->nPorts;
      ainfo.type = pa->type;
      ainfo.name_size = nameSize = strlen(pa->name);
      ainfo.num_formats = pa->nFormats;

      _WriteAdaptorInfo(client, &ainfo);

      WriteToClient(client, nameSize, pa->name);

      nf = pa->nFormats;
      pf = pa->pFormats;
      while (nf--)
	{
	  format.depth = pf->depth;
	  format.visual = pf->visual;
	  _WriteFormat(client, &format);
	  pf++;
	}

      pa++;

    }

  return Success;
}

static int
ProcXvQueryEncodings(ClientPtr client)
{
  xvEncodingInfo einfo;
  xvQueryEncodingsReply rep;
  int totalSize;
  int nameSize;
  XvPortPtr pPort;
  int ne;
  XvEncodingPtr pe;
  int status;

  REQUEST(xvQueryEncodingsReq);
  REQUEST_SIZE_MATCH(xvQueryEncodingsReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_encodings = pPort->pAdaptor->nEncodings;

  /* FOR EACH ENCODING ADD UP THE BYTES FOR ENCODING NAMES */

  ne = pPort->pAdaptor->nEncodings;
  pe = pPort->pAdaptor->pEncodings;
  totalSize = ne * sz_xvEncodingInfo;
  while (ne--)
    {
      totalSize += pad_to_int32(strlen(pe->name));
      pe++;
    }

  rep.length = bytes_to_int32(totalSize);

  _WriteQueryEncodingsReply(client, &rep);

  ne = pPort->pAdaptor->nEncodings;
  pe = pPort->pAdaptor->pEncodings;
  while (ne--) 
    {
      einfo.encoding = pe->id;
      einfo.name_size = nameSize = strlen(pe->name);
      einfo.width = pe->width;
      einfo.height = pe->height;
      einfo.rate.numerator = pe->rate.numerator;
      einfo.rate.denominator = pe->rate.denominator;
      _WriteEncodingInfo(client, &einfo);
      WriteToClient(client, nameSize, pe->name);
      pe++;
    }

  return Success;
}

static int
ProcXvPutVideo(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;

  REQUEST(xvPutVideoReq);
  REQUEST_SIZE_MATCH(xvPutVideoReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvInputMask) ||
	!(pPort->pAdaptor->type & XvVideoMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  return XvdiPutVideo(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
}

static int
ProcXvPutStill(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;

  REQUEST(xvPutStillReq);
  REQUEST_SIZE_MATCH(xvPutStillReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvInputMask) ||
	!(pPort->pAdaptor->type & XvStillMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  return XvdiPutStill(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
}

static int
ProcXvGetVideo(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;

  REQUEST(xvGetVideoReq);
  REQUEST_SIZE_MATCH(xvGetVideoReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixReadAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvOutputMask) ||
	!(pPort->pAdaptor->type & XvVideoMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  return XvdiGetVideo(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
}

static int
ProcXvGetStill(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;

  REQUEST(xvGetStillReq);
  REQUEST_SIZE_MATCH(xvGetStillReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixReadAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvOutputMask) ||
	!(pPort->pAdaptor->type & XvStillMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  return XvdiGetStill(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
}

static int
ProcXvSelectVideoNotify(ClientPtr client)
{
  DrawablePtr pDraw;
  int rc;
  REQUEST(xvSelectVideoNotifyReq);
  REQUEST_SIZE_MATCH(xvSelectVideoNotifyReq);

  rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixReceiveAccess);
  if (rc != Success)
    return rc;

  return XvdiSelectVideoNotify(client, pDraw, stuff->onoff);
}

static int
ProcXvSelectPortNotify(ClientPtr client)
{
  int status;
  XvPortPtr pPort;
  REQUEST(xvSelectPortNotifyReq);
  REQUEST_SIZE_MATCH(xvSelectPortNotifyReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  return XvdiSelectPortNotify(client, pPort, stuff->onoff);
}

static int
ProcXvGrabPort(ClientPtr client)
{
  int result, status;
  XvPortPtr pPort;
  xvGrabPortReply rep;
  REQUEST(xvGrabPortReq);
  REQUEST_SIZE_MATCH(xvGrabPortReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  status = XvdiGrabPort(client, pPort, stuff->time, &result);

  if (status != Success)
    {
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.result = result;

  _WriteGrabPortReply(client, &rep);

  return Success;
}

static int
ProcXvUngrabPort(ClientPtr client)
{
  int status;
  XvPortPtr pPort;
  REQUEST(xvGrabPortReq);
  REQUEST_SIZE_MATCH(xvGrabPortReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  return XvdiUngrabPort(client, pPort, stuff->time);
}

static int
ProcXvStopVideo(ClientPtr client)
{
  int status, rc;
  DrawablePtr pDraw;
  XvPortPtr pPort;
  REQUEST(xvStopVideoReq);
  REQUEST_SIZE_MATCH(xvStopVideoReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixWriteAccess);
  if (rc != Success)
    return rc;

  return XvdiStopVideo(client, pPort, pDraw);
}

static int
ProcXvSetPortAttribute(ClientPtr client)
{
  int status;
  XvPortPtr pPort;
  REQUEST(xvSetPortAttributeReq);
  REQUEST_SIZE_MATCH(xvSetPortAttributeReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixSetAttrAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!ValidAtom(stuff->attribute))
    {
      client->errorValue = stuff->attribute;
      return BadAtom;
    }

  status = XvdiSetPortAttribute(client, pPort, stuff->attribute, stuff->value);

  if (status == BadMatch) 
      client->errorValue = stuff->attribute;
  else
      client->errorValue = stuff->value;

  return status;
}

static int
ProcXvGetPortAttribute(ClientPtr client)
{
  INT32 value;
  int status;
  XvPortPtr pPort;
  xvGetPortAttributeReply rep;
  REQUEST(xvGetPortAttributeReq);
  REQUEST_SIZE_MATCH(xvGetPortAttributeReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixGetAttrAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!ValidAtom(stuff->attribute))
    {
      client->errorValue = stuff->attribute;
      return BadAtom;
    }

  status = XvdiGetPortAttribute(client, pPort, stuff->attribute, &value);
  if (status != Success)
    {
      client->errorValue = stuff->attribute;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.value = value;
 
  _WriteGetPortAttributeReply(client, &rep);

  return Success;
}

static int
ProcXvQueryBestSize(ClientPtr client)
{
  int status;
  unsigned int actual_width, actual_height;
  XvPortPtr pPort;
  xvQueryBestSizeReply rep;
  REQUEST(xvQueryBestSizeReq);
  REQUEST_SIZE_MATCH(xvQueryBestSizeReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;

  (* pPort->pAdaptor->ddQueryBestSize)(client, pPort, stuff->motion,
				       stuff->vid_w, stuff->vid_h, 
				       stuff->drw_w, stuff->drw_h, 
				       &actual_width, &actual_height);

  rep.actual_width = actual_width;
  rep.actual_height = actual_height;
 
  _WriteQueryBestSizeReply(client, &rep);

  return Success;
}


static int
ProcXvQueryPortAttributes(ClientPtr client)
{
  int status, size, i;
  XvPortPtr pPort;
  XvAttributePtr pAtt;
  xvQueryPortAttributesReply rep;
  xvAttributeInfo Info;
  REQUEST(xvQueryPortAttributesReq);
  REQUEST_SIZE_MATCH(xvQueryPortAttributesReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixGetAttrAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_attributes = pPort->pAdaptor->nAttributes;
  rep.text_size = 0;

  for(i = 0, pAtt = pPort->pAdaptor->pAttributes; 
      i < pPort->pAdaptor->nAttributes; i++, pAtt++) 
  {    
      rep.text_size += pad_to_int32(strlen(pAtt->name) + 1);
  }

  rep.length = (pPort->pAdaptor->nAttributes * sz_xvAttributeInfo)
      + rep.text_size;
  rep.length >>= 2;

  _WriteQueryPortAttributesReply(client, &rep);

  for(i = 0, pAtt = pPort->pAdaptor->pAttributes; 
      i < pPort->pAdaptor->nAttributes; i++, pAtt++) 
  {
      size = strlen(pAtt->name) + 1;  /* pass the NULL */
      Info.flags = pAtt->flags;
      Info.min = pAtt->min_value;
      Info.max = pAtt->max_value;
      Info.size = pad_to_int32(size);

      _WriteAttributeInfo(client, &Info);

      WriteToClient(client, size, pAtt->name);
  }

  return Success;
}

static int 
ProcXvPutImage(ClientPtr client)
{
  DrawablePtr pDraw;
  XvPortPtr pPort;
  XvImagePtr pImage = NULL;
  GCPtr pGC;
  int status, i, size;
  CARD16 width, height;

  REQUEST(xvPutImageReq);
  REQUEST_AT_LEAST_SIZE(xvPutImageReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvImageMask) ||
	!(pPort->pAdaptor->type & XvInputMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }

  if(!pImage)
     return BadMatch;

  width = stuff->width;
  height = stuff->height;
  size = (*pPort->pAdaptor->ddQueryImageAttributes)(client, 
			pPort, pImage, &width, &height, NULL, NULL);
  size += sizeof(xvPutImageReq);
  size = bytes_to_int32(size);
  
  if((width < stuff->width) || (height < stuff->height))
     return BadValue;

  if(client->req_len < size)
     return BadLength;

  return XvdiPutImage(client, pDraw, pPort, pGC, stuff->src_x, stuff->src_y,
		      stuff->src_w, stuff->src_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h, pImage,
		      (unsigned char*)(&stuff[1]), FALSE,
		      stuff->width, stuff->height);
}

#ifdef MITSHM
/* redefined here since it's not in any header file */
typedef struct _ShmDesc {
    struct _ShmDesc *next;
    int shmid;
    int refcnt;
    char *addr;
    Bool writable;
    unsigned long size;
} ShmDescRec, *ShmDescPtr;

extern RESTYPE ShmSegType;
extern int ShmCompletionCode;

static int 
ProcXvShmPutImage(ClientPtr client)
{
  ShmDescPtr shmdesc;
  DrawablePtr pDraw;
  XvPortPtr pPort;
  XvImagePtr pImage = NULL;
  GCPtr pGC;
  int status, size_needed, i;
  CARD16 width, height;

  REQUEST(xvShmPutImageReq);
  REQUEST_SIZE_MATCH(xvShmPutImageReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvImageMask) ||
	!(pPort->pAdaptor->type & XvInputMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }

  if(!pImage)
     return BadMatch;

  status = dixLookupResourceByType((pointer *)&shmdesc, stuff->shmseg,
				   ShmSegType, serverClient, DixReadAccess);
  if (status != Success)
      return status;
 
  width = stuff->width;
  height = stuff->height;
  size_needed = (*pPort->pAdaptor->ddQueryImageAttributes)(client, 
			pPort, pImage, &width, &height, NULL, NULL);
  if((size_needed + stuff->offset) > shmdesc->size)
      return BadAccess;

  if((width < stuff->width) || (height < stuff->height))
     return BadValue;
     
  status = XvdiPutImage(client, pDraw, pPort, pGC, stuff->src_x, stuff->src_y,
			stuff->src_w, stuff->src_h, stuff->drw_x, stuff->drw_y,
			stuff->drw_w, stuff->drw_h, pImage,
			(unsigned char *)shmdesc->addr + stuff->offset, 
			stuff->send_event, stuff->width, stuff->height);

  if((status == Success) && stuff->send_event) {
        xShmCompletionEvent ev;

        ev.type = ShmCompletionCode;
        ev.drawable = stuff->drawable;
        ev.minorEvent = xv_ShmPutImage;
        ev.majorEvent = XvReqCode;
        ev.shmseg = stuff->shmseg;
        ev.offset = stuff->offset;
        WriteEventsToClient(client, 1, (xEvent *) &ev);
  }

  return status;
}
#else /* !MITSHM */
static int
ProcXvShmPutImage(ClientPtr client)
{
    SendErrorToClient(client, XvReqCode, xv_ShmPutImage, 0, BadImplementation);
    return BadImplementation;
}
#endif

#ifdef XvMCExtension
#include "xvmcext.h"
#endif

static int 
ProcXvQueryImageAttributes(ClientPtr client)
{
  xvQueryImageAttributesReply rep;
  int size, num_planes, i;
  CARD16 width, height;
  XvImagePtr pImage = NULL;
  XvPortPtr pPort;
  int *offsets;
  int *pitches;
  int planeLength;
  REQUEST(xvQueryImageAttributesReq);

  REQUEST_SIZE_MATCH(xvQueryImageAttributesReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
  
  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }

#ifdef XvMCExtension
  if(!pImage)
     pImage = XvMCFindXvImage(pPort, stuff->id);
#endif

  if(!pImage)
     return BadMatch;

  num_planes = pImage->num_planes;

  if(!(offsets = malloc(num_planes << 3)))
	return BadAlloc;
  pitches = offsets + num_planes;

  width = stuff->width;
  height = stuff->height;

  size = (*pPort->pAdaptor->ddQueryImageAttributes)(client, pPort, pImage,
					&width, &height, offsets, pitches);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = planeLength = num_planes << 1;
  rep.num_planes = num_planes;
  rep.width = width;
  rep.height = height;
  rep.data_size = size;
 
  _WriteQueryImageAttributesReply(client, &rep);
  if(client->swapped)
    SwapLongs((CARD32*)offsets, planeLength);
  WriteToClient(client, planeLength << 2, (char*)offsets);

  free(offsets);

  return Success;
}

static int 
ProcXvListImageFormats(ClientPtr client)
{
  XvPortPtr pPort;
  XvImagePtr pImage;
  int i;
  xvListImageFormatsReply rep;
  xvImageFormatInfo info;
  REQUEST(xvListImageFormatsReq);

  REQUEST_SIZE_MATCH(xvListImageFormatsReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_formats = pPort->pAdaptor->nImages;
  rep.length = bytes_to_int32(pPort->pAdaptor->nImages * sz_xvImageFormatInfo);

  _WriteListImageFormatsReply(client, &rep);

  pImage = pPort->pAdaptor->pImages;
  
  for(i = 0; i < pPort->pAdaptor->nImages; i++, pImage++) {
     info.id = pImage->id; 	
     info.type = pImage->type; 	
     info.byte_order = pImage->byte_order; 
     memcpy(&info.guid, pImage->guid, 16);	
     info.bpp = pImage->bits_per_pixel; 	
     info.num_planes = pImage->num_planes; 	
     info.depth = pImage->depth; 	
     info.red_mask = pImage->red_mask; 	
     info.green_mask = pImage->green_mask; 	
     info.blue_mask = pImage->blue_mask; 	
     info.format = pImage->format; 	
     info.y_sample_bits = pImage->y_sample_bits; 	
     info.u_sample_bits = pImage->u_sample_bits; 	
     info.v_sample_bits = pImage->v_sample_bits; 	
     info.horz_y_period = pImage->horz_y_period; 	
     info.horz_u_period = pImage->horz_u_period; 	
     info.horz_v_period = pImage->horz_v_period; 	
     info.vert_y_period = pImage->vert_y_period; 	
     info.vert_u_period = pImage->vert_u_period; 	
     info.vert_v_period = pImage->vert_v_period; 	
     memcpy(&info.comp_order, pImage->component_order, 32);	
     info.scanline_order = pImage->scanline_order;
     _WriteImageFormatInfo(client, &info);
  }  

  return Success;
}

static int (*XvProcVector[xvNumRequests])(ClientPtr) = {
    ProcXvQueryExtension,
    ProcXvQueryAdaptors,
    ProcXvQueryEncodings,
    ProcXvGrabPort,
    ProcXvUngrabPort,
    ProcXvPutVideo,
    ProcXvPutStill,
    ProcXvGetVideo,
    ProcXvGetStill,
    ProcXvStopVideo,
    ProcXvSelectVideoNotify,
    ProcXvSelectPortNotify,
    ProcXvQueryBestSize,
    ProcXvSetPortAttribute,
    ProcXvGetPortAttribute,
    ProcXvQueryPortAttributes,
    ProcXvListImageFormats,
    ProcXvQueryImageAttributes,
    ProcXvPutImage,
    ProcXvShmPutImage,
};

int
ProcXvDispatch(ClientPtr client)
{
  REQUEST(xReq);

  UpdateCurrentTime();

  if (stuff->data > xvNumRequests) {
    SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
    return BadRequest;
  }

  return XvProcVector[stuff->data](client);
}

/* Swapped Procs */

static int
SProcXvQueryExtension(ClientPtr client)
{
  char n;
  REQUEST(xvQueryExtensionReq);
  swaps(&stuff->length, n);
  return XvProcVector[xv_QueryExtension](client);
}

static int
SProcXvQueryAdaptors(ClientPtr client)
{
  char n;
  REQUEST(xvQueryAdaptorsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->window, n);
  return XvProcVector[xv_QueryAdaptors](client);
}

static int
SProcXvQueryEncodings(ClientPtr client)
{
  char n;
  REQUEST(xvQueryEncodingsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_QueryEncodings](client);
}

static int
SProcXvGrabPort(ClientPtr client)
{
  char n;
  REQUEST(xvGrabPortReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->time, n);
  return XvProcVector[xv_GrabPort](client);
}

static int
SProcXvUngrabPort(ClientPtr client)
{
  char n;
  REQUEST(xvUngrabPortReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->time, n);
  return XvProcVector[xv_UngrabPort](client);
}

static int
SProcXvPutVideo(ClientPtr client)
{
  char n;
  REQUEST(xvPutVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_PutVideo](client);
}

static int
SProcXvPutStill(ClientPtr client)
{
  char n;
  REQUEST(xvPutStillReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_PutStill](client);
}

static int
SProcXvGetVideo(ClientPtr client)
{
  char n;
  REQUEST(xvGetVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_GetVideo](client);
}

static int
SProcXvGetStill(ClientPtr client)
{
  char n;
  REQUEST(xvGetStillReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_GetStill](client);
}

static int
SProcXvPutImage(ClientPtr client)
{
  char n;
  REQUEST(xvPutImageReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swapl(&stuff->id, n);
  swaps(&stuff->src_x, n);
  swaps(&stuff->src_y, n);
  swaps(&stuff->src_w, n);
  swaps(&stuff->src_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_PutImage](client);
}

#ifdef MITSHM
static int
SProcXvShmPutImage(ClientPtr client)
{
  char n;
  REQUEST(xvShmPutImageReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swapl(&stuff->shmseg, n);
  swapl(&stuff->id, n);
  swapl(&stuff->offset, n);
  swaps(&stuff->src_x, n);
  swaps(&stuff->src_y, n);
  swaps(&stuff->src_w, n);
  swaps(&stuff->src_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_ShmPutImage](client);
}
#else /* MITSHM */
#define SProcXvShmPutImage ProcXvShmPutImage
#endif

static int
SProcXvSelectVideoNotify(ClientPtr client)
{
  char n;
  REQUEST(xvSelectVideoNotifyReq);
  swaps(&stuff->length, n);
  swapl(&stuff->drawable, n);
  return XvProcVector[xv_SelectVideoNotify](client);
}

static int
SProcXvSelectPortNotify(ClientPtr client)
{
  char n;
  REQUEST(xvSelectPortNotifyReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_SelectPortNotify](client);
}

static int
SProcXvStopVideo(ClientPtr client)
{
  char n;
  REQUEST(xvStopVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  return XvProcVector[xv_StopVideo](client);
}

static int
SProcXvSetPortAttribute(ClientPtr client)
{
  char n;
  REQUEST(xvSetPortAttributeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->attribute, n);
  swapl(&stuff->value, n);
  return XvProcVector[xv_SetPortAttribute](client);
}

static int
SProcXvGetPortAttribute(ClientPtr client)
{
  char n;
  REQUEST(xvGetPortAttributeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->attribute, n);
  return XvProcVector[xv_GetPortAttribute](client);
}

static int
SProcXvQueryBestSize(ClientPtr client)
{
  char n;
  REQUEST(xvQueryBestSizeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_QueryBestSize](client);
}

static int
SProcXvQueryPortAttributes(ClientPtr client)
{
  char n;
  REQUEST(xvQueryPortAttributesReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_QueryPortAttributes](client);
}

static int
SProcXvQueryImageAttributes(ClientPtr client)
{
  char n;
  REQUEST(xvQueryImageAttributesReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->id, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_QueryImageAttributes](client);
}

static int
SProcXvListImageFormats(ClientPtr client)
{
  char n;
  REQUEST(xvListImageFormatsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_ListImageFormats](client);
}

static int (*SXvProcVector[xvNumRequests])(ClientPtr) = {
    SProcXvQueryExtension,
    SProcXvQueryAdaptors,
    SProcXvQueryEncodings,
    SProcXvGrabPort,
    SProcXvUngrabPort,
    SProcXvPutVideo,
    SProcXvPutStill,
    SProcXvGetVideo,
    SProcXvGetStill,
    SProcXvStopVideo,
    SProcXvSelectVideoNotify,
    SProcXvSelectPortNotify,
    SProcXvQueryBestSize,
    SProcXvSetPortAttribute,
    SProcXvGetPortAttribute,
    SProcXvQueryPortAttributes,
    SProcXvListImageFormats,
    SProcXvQueryImageAttributes,
    SProcXvPutImage,
    SProcXvShmPutImage,
};

int
SProcXvDispatch(ClientPtr client)
{
  REQUEST(xReq);

  UpdateCurrentTime();

  if (stuff->data > xvNumRequests) {
    SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
    return BadRequest;
  }

  return SXvProcVector[stuff->data](client);
}

#ifdef PANORAMIX
static int
XineramaXvStopVideo(ClientPtr client)
{
   int result, i;
   PanoramiXRes *draw, *port;
   REQUEST(xvStopVideoReq);
   REQUEST_SIZE_MATCH(xvStopVideoReq);

   result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				     XRC_DRAWABLE, client, DixWriteAccess);
   if (result != Success)
       return (result == BadValue) ? BadDrawable : result;

   result = dixLookupResourceByType((pointer *)&port, stuff->port,
				    XvXRTPort, client, DixReadAccess);
   if (result != Success)
       return result;

   FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   result = ProcXvStopVideo(client);
     	}
   }

   return result;
}

static int
XineramaXvSetPortAttribute(ClientPtr client)
{
    REQUEST(xvSetPortAttributeReq);
    PanoramiXRes *port;
    int result, i;

    REQUEST_SIZE_MATCH(xvSetPortAttributeReq);

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;

    FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->port = port->info[i].id;
	   result = ProcXvSetPortAttribute(client);
	}
    }
    return result;
}

#ifdef MITSHM
static int 
XineramaXvShmPutImage(ClientPtr client)
{
    REQUEST(xvShmPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool send_event = stuff->send_event;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_SIZE_MATCH(xvShmPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;
 
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   stuff->gc = gc->info[i].id;
	   stuff->drw_x = x;
	   stuff->drw_y = y;
	   if(isRoot) {
		stuff->drw_x -= screenInfo.screens[i]->x;
		stuff->drw_y -= screenInfo.screens[i]->y;
	   }
	   stuff->send_event = (send_event && !i) ? 1 : 0;

	   result = ProcXvShmPutImage(client);
	}
    }
    return result;
}
#else
#define XineramaXvShmPutImage ProcXvShmPutImage
#endif

static int 
XineramaXvPutImage(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;
 
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   stuff->gc = gc->info[i].id;
	   stuff->drw_x = x;
	   stuff->drw_y = y;
	   if(isRoot) {
		stuff->drw_x -= screenInfo.screens[i]->x;
		stuff->drw_y -= screenInfo.screens[i]->y;
	   }

	   result = ProcXvPutImage(client);
	}
    }
    return result;
}

static int
XineramaXvPutVideo(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutVideoReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
        if(port->info[i].id) {
           stuff->drawable = draw->info[i].id;
           stuff->port = port->info[i].id;
           stuff->gc = gc->info[i].id;
           stuff->drw_x = x;
           stuff->drw_y = y;
           if(isRoot) {
                stuff->drw_x -= screenInfo.screens[i]->x;
                stuff->drw_y -= screenInfo.screens[i]->y;
           }

           result = ProcXvPutVideo(client);
        }
    }
    return result;
}

static int
XineramaXvPutStill(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutImageReq);

    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
	return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
    if (result != Success)
	return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
        if(port->info[i].id) {
           stuff->drawable = draw->info[i].id;
           stuff->port = port->info[i].id;
           stuff->gc = gc->info[i].id;
           stuff->drw_x = x;
           stuff->drw_y = y;
           if(isRoot) {
                stuff->drw_x -= screenInfo.screens[i]->x;
                stuff->drw_y -= screenInfo.screens[i]->y;
           }

           result = ProcXvPutStill(client);
        }
    }
    return result;
}

static Bool
isImageAdaptor(XvAdaptorPtr pAdapt)
{
    return (pAdapt->type & XvImageMask) && (pAdapt->nImages > 0);
}

static Bool
hasOverlay(XvAdaptorPtr pAdapt)
{
    int i;
    for(i = 0; i < pAdapt->nAttributes; i++)
	if(!strcmp(pAdapt->pAttributes[i].name, "XV_COLORKEY"))
	    return TRUE;
    return FALSE;
}

static XvAdaptorPtr
matchAdaptor(ScreenPtr pScreen, XvAdaptorPtr refAdapt, Bool isOverlay)
{
    int i;
    XvScreenPtr xvsp = dixLookupPrivate(&pScreen->devPrivates, XvGetScreenKey());
    /* Do not try to go on if xv is not supported on this screen */
    if(xvsp == NULL)
	return NULL;

    /* if the adaptor has the same name it's a perfect match */
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(!strcmp(refAdapt->name, pAdapt->name))
	    return pAdapt;
    }

    /* otherwise we only look for XvImage adaptors */
    if(!isImageAdaptor(refAdapt))
	return NULL;

    /* prefer overlay/overlay non-overlay/non-overlay pairing */
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(isImageAdaptor(pAdapt) && isOverlay == hasOverlay(pAdapt))
	    return pAdapt;
    }

    /* but we'll take any XvImage pairing if we can get it */
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(isImageAdaptor(pAdapt))
	    return pAdapt;
    }
    return NULL;
}

void XineramifyXv(void)
{
   XvScreenPtr xvsp0 = dixLookupPrivate(&screenInfo.screens[0]->devPrivates, XvGetScreenKey());
   XvAdaptorPtr MatchingAdaptors[MAXSCREENS];
   int i, j, k;

   XvXRTPort = CreateNewResourceType(XineramaDeleteResource, "XvXRTPort");

   if (!xvsp0 || !XvXRTPort) return;
   SetResourceTypeErrorValue(XvXRTPort, _XvBadPort);

   for(i = 0; i < xvsp0->nAdaptors; i++) {
      Bool isOverlay;
      XvAdaptorPtr refAdapt = xvsp0->pAdaptors + i;
      if(!(refAdapt->type & XvInputMask)) continue;

      MatchingAdaptors[0] = refAdapt;
      isOverlay = hasOverlay(refAdapt);
      FOR_NSCREENS_FORWARD_SKIP(j)
	 MatchingAdaptors[j] = matchAdaptor(screenInfo.screens[j], refAdapt, isOverlay);

      /* now create a resource for each port */
      for(j = 0; j < refAdapt->nPorts; j++) {
	 PanoramiXRes *port = malloc(sizeof(PanoramiXRes));
	 if(!port)
	    break;

	 FOR_NSCREENS(k) {
	    if(MatchingAdaptors[k] && (MatchingAdaptors[k]->nPorts > j)) 
		port->info[k].id = MatchingAdaptors[k]->base_id + j;
	    else
		port->info[k].id = 0;
	 } 
	 AddResource(port->info[0].id, XvXRTPort, port);
      }
   }

   /* munge the dispatch vector */
   XvProcVector[xv_PutVideo]		= XineramaXvPutVideo;
   XvProcVector[xv_PutStill]		= XineramaXvPutStill;
   XvProcVector[xv_StopVideo]		= XineramaXvStopVideo;
   XvProcVector[xv_SetPortAttribute]	= XineramaXvSetPortAttribute;
   XvProcVector[xv_PutImage]		= XineramaXvPutImage;
   XvProcVector[xv_ShmPutImage]		= XineramaXvShmPutImage;
}
#endif /* PANORAMIX */

void
XvResetProcVector(void)
{
#ifdef PANORAMIX
   XvProcVector[xv_PutVideo]		= ProcXvPutVideo;
   XvProcVector[xv_PutStill]		= ProcXvPutStill;
   XvProcVector[xv_StopVideo]		= ProcXvStopVideo;
   XvProcVector[xv_SetPortAttribute]	= ProcXvSetPortAttribute;
   XvProcVector[xv_PutImage]		= ProcXvPutImage;
   XvProcVector[xv_ShmPutImage]		= ProcXvShmPutImage;
#endif
}
extern void XineramifyXv(void);
extern void XvResetProcVector(void);
/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef XVDIX_H
#define XVDIX_H
/*
** File: 
**
**   xvdix.h --- Xv device independent header file
**
** Author: 
**
**   David Carver (Digital Workstation Engineering/Project Athena)
**
** Revisions:
**
**   29.08.91 Carver
**     - removed UnrealizeWindow wrapper unrealizing windows no longer 
**       preempts video
**
**   11.06.91 Carver
**     - changed SetPortControl to SetPortAttribute
**     - changed GetPortControl to GetPortAttribute
**     - changed QueryBestSize
**
**   15.05.91 Carver
**     - version 2.0 upgrade
**
**   24.01.91 Carver
**     - version 1.4 upgrade
**
*/

#include "scrnintstr.h"
#include <X11/extensions/Xvproto.h>

#ifndef XorgLoader
extern _X_EXPORT unsigned long XvExtensionGeneration;
extern _X_EXPORT unsigned long XvScreenGeneration;
extern _X_EXPORT unsigned long XvResourceGeneration;

extern _X_EXPORT int XvReqCode;
extern _X_EXPORT int XvEventBase;
extern _X_EXPORT int XvErrorBase;

extern _X_EXPORT RESTYPE XvRTPort;
extern _X_EXPORT RESTYPE XvRTEncoding;
extern _X_EXPORT RESTYPE XvRTGrab;
extern _X_EXPORT RESTYPE XvRTVideoNotify;
extern _X_EXPORT RESTYPE XvRTVideoNotifyList;
extern _X_EXPORT RESTYPE XvRTPortNotify;
#endif

typedef struct {
  int numerator;
  int denominator;
} XvRationalRec, *XvRationalPtr;

typedef struct {
  char depth;
  unsigned long visual;
} XvFormatRec, *XvFormatPtr;

typedef struct {
  unsigned long id;
  ClientPtr client;
} XvGrabRec, *XvGrabPtr;

typedef struct _XvVideoNotifyRec {
  struct _XvVideoNotifyRec *next;
  ClientPtr client;
  unsigned long id;
  unsigned long mask;
} XvVideoNotifyRec, *XvVideoNotifyPtr;

typedef struct _XvPortNotifyRec {
  struct _XvPortNotifyRec *next;
  ClientPtr client;
  unsigned long id;
} XvPortNotifyRec, *XvPortNotifyPtr;

typedef struct {
  int id;
  ScreenPtr pScreen;
  char *name;
  unsigned short width, height;
  XvRationalRec rate;
} XvEncodingRec, *XvEncodingPtr;

typedef struct _XvAttributeRec {
  int flags;
  int min_value;
  int max_value;
  char *name;
} XvAttributeRec, *XvAttributePtr;

typedef struct {
  int id;
  int type;
  int byte_order;
  char guid[16];
  int bits_per_pixel;
  int format;
  int num_planes;

  /* for RGB formats only */
  int depth;
  unsigned int red_mask;       
  unsigned int green_mask;   
  unsigned int blue_mask;   

  /* for YUV formats only */
  unsigned int y_sample_bits;
  unsigned int u_sample_bits;
  unsigned int v_sample_bits;   
  unsigned int horz_y_period;
  unsigned int horz_u_period;
  unsigned int horz_v_period;
  unsigned int vert_y_period;
  unsigned int vert_u_period;
  unsigned int vert_v_period;
  char component_order[32];
  int scanline_order;
} XvImageRec, *XvImagePtr; 

typedef struct {
  unsigned long base_id;
  unsigned char type; 
  char *name;
  int nEncodings;
  XvEncodingPtr pEncodings;  
  int nFormats;
  XvFormatPtr pFormats; 
  int nAttributes;
  XvAttributePtr pAttributes;
  int nImages;
  XvImagePtr pImages;
  int nPorts;
  struct _XvPortRec *pPorts;
  ScreenPtr pScreen; 
  int (* ddAllocatePort)(unsigned long, struct _XvPortRec*, 
				struct _XvPortRec**);
  int (* ddFreePort)(struct _XvPortRec*);
  int (* ddPutVideo)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16); 
  int (* ddPutStill)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
  int (* ddGetVideo)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
  int (* ddGetStill)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
  int (* ddStopVideo)(ClientPtr, struct _XvPortRec*, DrawablePtr);
  int (* ddSetPortAttribute)(ClientPtr, struct _XvPortRec*, Atom, INT32);
  int (* ddGetPortAttribute)(ClientPtr, struct _XvPortRec*, Atom, INT32*);
  int (* ddQueryBestSize)(ClientPtr, struct _XvPortRec*, CARD8,
   				CARD16, CARD16,CARD16, CARD16, 
				unsigned int*, unsigned int*);
  int (* ddPutImage)(ClientPtr, DrawablePtr, struct _XvPortRec*, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16,
				XvImagePtr, unsigned char*, Bool,
				CARD16, CARD16);
  int (* ddQueryImageAttributes)(ClientPtr, struct _XvPortRec*, XvImagePtr, 
				CARD16*, CARD16*, int*, int*);
  DevUnion devPriv;
} XvAdaptorRec, *XvAdaptorPtr;

typedef struct _XvPortRec {
  unsigned long id;
  XvAdaptorPtr pAdaptor;
  XvPortNotifyPtr pNotify;
  DrawablePtr pDraw;
  ClientPtr client;
  XvGrabRec grab;
  TimeStamp time;
  DevUnion devPriv;
} XvPortRec, *XvPortPtr;

#define VALIDATE_XV_PORT(portID, pPort, mode)\
    {\
	int rc = dixLookupResourceByType((pointer *)&(pPort), portID,\
	                                 XvRTPort, client, mode);\
	if (rc != Success)\
	    return rc;\
    }

typedef struct {
  int version, revision;
  int nAdaptors;
  XvAdaptorPtr pAdaptors;
  DestroyWindowProcPtr DestroyWindow;
  DestroyPixmapProcPtr DestroyPixmap;
  CloseScreenProcPtr CloseScreen;
  Bool (* ddCloseScreen)(int, ScreenPtr);
  int (* ddQueryAdaptors)(ScreenPtr, XvAdaptorPtr*, int*);
  DevUnion devPriv;
} XvScreenRec, *XvScreenPtr;

#define SCREEN_PROLOGUE(pScreen, field) ((pScreen)->field = ((XvScreenPtr) \
    dixLookupPrivate(&(pScreen)->devPrivates, XvScreenKey))->field)

#define SCREEN_EPILOGUE(pScreen, field, wrapper)\
    ((pScreen)->field = wrapper)

/* Errors */

#define _XvBadPort (XvBadPort+XvErrorBase)
#define _XvBadEncoding (XvBadEncoding+XvErrorBase)

#ifndef XorgLoader
extern _X_EXPORT int ProcXvDispatch(ClientPtr);
extern _X_EXPORT int SProcXvDispatch(ClientPtr);

extern _X_EXPORT void XvExtensionInit(void);
extern _X_EXPORT int XvScreenInit(ScreenPtr);
extern _X_EXPORT DevPrivateKey XvGetScreenKey(void);
extern _X_EXPORT unsigned long XvGetRTPort(void);
extern _X_EXPORT int XvdiSendPortNotify(XvPortPtr, Atom, INT32);
extern _X_EXPORT int XvdiVideoStopped(XvPortPtr, int);

extern _X_EXPORT int XvdiPutVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
extern _X_EXPORT int XvdiPutStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
extern _X_EXPORT int XvdiGetVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
extern _X_EXPORT int XvdiGetStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16);
extern _X_EXPORT int XvdiPutImage(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16, 
				INT16, INT16, CARD16, CARD16,
				XvImagePtr, unsigned char*, Bool,
				CARD16, CARD16);
extern _X_EXPORT int XvdiSelectVideoNotify(ClientPtr, DrawablePtr, BOOL);
extern _X_EXPORT int XvdiSelectPortNotify(ClientPtr, XvPortPtr, BOOL);
extern _X_EXPORT int XvdiSetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32);
extern _X_EXPORT int XvdiGetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32*);
extern _X_EXPORT int XvdiStopVideo(ClientPtr, XvPortPtr, DrawablePtr);
extern _X_EXPORT int XvdiPreemptVideo(ClientPtr, XvPortPtr, DrawablePtr);
extern _X_EXPORT int XvdiMatchPort(XvPortPtr, DrawablePtr);
extern _X_EXPORT int XvdiGrabPort(ClientPtr, XvPortPtr, Time, int *);
extern _X_EXPORT int XvdiUngrabPort( ClientPtr, XvPortPtr, Time);
#endif /* XorgLoader */

#endif /* XVDIX_H */

/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
** File: 
**
**   xvmain.c --- Xv server extension main device independent module.
**   
** Author: 
**
**   David Carver (Digital Workstation Engineering/Project Athena)
**
** Revisions:
**
**   04.09.91 Carver
**     - change: stop video always generates an event even when video
**       wasn't active
**
**   29.08.91 Carver
**     - change: unrealizing windows no longer preempts video
**
**   11.06.91 Carver
**     - changed SetPortControl to SetPortAttribute
**     - changed GetPortControl to GetPortAttribute
**     - changed QueryBestSize
**
**   28.05.91 Carver
**     - fixed Put and Get requests to not preempt operations to same drawable
**
**   15.05.91 Carver
**     - version 2.0 upgrade
**
**   19.03.91 Carver
**     - fixed Put and Get requests to honor grabbed ports.
**     - fixed Video requests to update di structure with new drawable, and
**       client after calling ddx.
**
**   24.01.91 Carver
**     - version 1.4 upgrade
**       
** Notes:
**
**   Port structures reference client structures in a two different
**   ways: when grabs, or video is active.  Each reference is encoded
**   as fake client resources and thus when the client is goes away so
**   does the reference (it is zeroed).  No other action is taken, so
**   video doesn't necessarily stop.  It probably will as a result of
**   other resources going away, but if a client starts video using
**   none of its own resources, then the video will continue to play
**   after the client disappears.
**
**
*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gc.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include "input.h"

#define GLOBAL

#include <X11/extensions/Xv.h>
#include <X11/extensions/Xvproto.h>
#include "xvdix.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
#include "xvdisp.h"

static DevPrivateKeyRec XvScreenKeyRec;
#define XvScreenKey (&XvScreenKeyRec)
unsigned long XvExtensionGeneration = 0;
unsigned long XvScreenGeneration = 0;
unsigned long XvResourceGeneration = 0;

int XvReqCode;
int XvEventBase;
int XvErrorBase;

RESTYPE XvRTPort;
RESTYPE XvRTEncoding;
RESTYPE XvRTGrab;
RESTYPE XvRTVideoNotify;
RESTYPE XvRTVideoNotifyList;
RESTYPE XvRTPortNotify;

/* EXTERNAL */

static void WriteSwappedVideoNotifyEvent(xvEvent *, xvEvent *);
static void WriteSwappedPortNotifyEvent(xvEvent *, xvEvent *);
static Bool CreateResourceTypes(void);

static Bool XvCloseScreen(int, ScreenPtr);
static Bool XvDestroyPixmap(PixmapPtr);
static Bool XvDestroyWindow(WindowPtr);
static void XvResetProc(ExtensionEntry*);
static int XvdiDestroyGrab(pointer, XID);
static int XvdiDestroyEncoding(pointer, XID);
static int XvdiDestroyVideoNotify(pointer, XID);
static int XvdiDestroyPortNotify(pointer, XID);
static int XvdiDestroyVideoNotifyList(pointer, XID);
static int XvdiDestroyPort(pointer, XID);
static int XvdiSendVideoNotify(XvPortPtr, DrawablePtr, int);




/*
** XvExtensionInit
**
**
*/

void
XvExtensionInit(void)
{
  ExtensionEntry *extEntry;

  if (!dixRegisterPrivateKey(&XvScreenKeyRec, PRIVATE_SCREEN, 0))
      return;

  /* LOOK TO SEE IF ANY SCREENS WERE INITIALIZED; IF NOT THEN
     INIT GLOBAL VARIABLES SO THE EXTENSION CAN FUNCTION */
  if (XvScreenGeneration != serverGeneration)
    {
      if (!CreateResourceTypes())
	{
	  ErrorF("XvExtensionInit: Unable to allocate resource types\n");
	  return;
	}
#ifdef PANORAMIX
        XineramaRegisterConnectionBlockCallback(XineramifyXv);
#endif
      XvScreenGeneration = serverGeneration;
    }

  if (XvExtensionGeneration != serverGeneration)
    {
      XvExtensionGeneration = serverGeneration;

      extEntry = AddExtension(XvName, XvNumEvents, XvNumErrors, 
			      ProcXvDispatch, SProcXvDispatch,
			      XvResetProc, StandardMinorOpcode);
      if (!extEntry) 
	{
	  FatalError("XvExtensionInit: AddExtensions failed\n");
	}

      XvReqCode = extEntry->base;
      XvEventBase = extEntry->eventBase;
      XvErrorBase = extEntry->errorBase;

      EventSwapVector[XvEventBase+XvVideoNotify] = 
	(EventSwapPtr)WriteSwappedVideoNotifyEvent;
      EventSwapVector[XvEventBase+XvPortNotify] = 
	(EventSwapPtr)WriteSwappedPortNotifyEvent;

      SetResourceTypeErrorValue(XvRTPort, _XvBadPort);
      (void)MakeAtom(XvName, strlen(XvName), xTrue);

    }
}

static Bool
CreateResourceTypes(void)

{
  
  if (XvResourceGeneration == serverGeneration) return TRUE;

  XvResourceGeneration = serverGeneration;

  if (!(XvRTPort = CreateNewResourceType(XvdiDestroyPort, "XvRTPort")))
    {
      ErrorF("CreateResourceTypes: failed to allocate port resource.\n");
      return FALSE;
    }

  if (!(XvRTGrab = CreateNewResourceType(XvdiDestroyGrab, "XvRTGrab")))
    {
      ErrorF("CreateResourceTypes: failed to allocate grab resource.\n");
      return FALSE;
    }

  if (!(XvRTEncoding = CreateNewResourceType(XvdiDestroyEncoding,
					     "XvRTEncoding")))
    {
      ErrorF("CreateResourceTypes: failed to allocate encoding resource.\n");
      return FALSE;
    }

  if (!(XvRTVideoNotify = CreateNewResourceType(XvdiDestroyVideoNotify,
						"XvRTVideoNotify")))
    {
      ErrorF("CreateResourceTypes: failed to allocate video notify resource.\n");
      return FALSE;
    }

  if (!(XvRTVideoNotifyList = CreateNewResourceType(XvdiDestroyVideoNotifyList,
						    "XvRTVideoNotifyList")))
    {
      ErrorF("CreateResourceTypes: failed to allocate video notify list resource.\n");
      return FALSE;
    }

  if (!(XvRTPortNotify = CreateNewResourceType(XvdiDestroyPortNotify,
					       "XvRTPortNotify")))
    {
      ErrorF("CreateResourceTypes: failed to allocate port notify resource.\n");
      return FALSE;
    }

  return TRUE;

}

int
XvScreenInit(ScreenPtr pScreen)
{
  XvScreenPtr pxvs;

  if (XvScreenGeneration != serverGeneration)
    {
      if (!CreateResourceTypes())
	{
	  ErrorF("XvScreenInit: Unable to allocate resource types\n");
	  return BadAlloc;
	}
#ifdef PANORAMIX
        XineramaRegisterConnectionBlockCallback(XineramifyXv);
#endif
      XvScreenGeneration = serverGeneration; 
    }

  if (!dixRegisterPrivateKey(&XvScreenKeyRec, PRIVATE_SCREEN, 0))
      return BadAlloc;

  if (dixLookupPrivate(&pScreen->devPrivates, XvScreenKey))
    {
      ErrorF("XvScreenInit: screen devPrivates ptr non-NULL before init\n");
    }

  /* ALLOCATE SCREEN PRIVATE RECORD */
  
  pxvs = malloc(sizeof (XvScreenRec));
  if (!pxvs)
    {
      ErrorF("XvScreenInit: Unable to allocate screen private structure\n");
      return BadAlloc;
    }

  dixSetPrivate(&pScreen->devPrivates, XvScreenKey, pxvs);
  
  pxvs->DestroyPixmap = pScreen->DestroyPixmap;
  pxvs->DestroyWindow = pScreen->DestroyWindow;
  pxvs->CloseScreen = pScreen->CloseScreen;
  
  pScreen->DestroyPixmap = XvDestroyPixmap;
  pScreen->DestroyWindow = XvDestroyWindow;
  pScreen->CloseScreen = XvCloseScreen;

  return Success;
}

static Bool
XvCloseScreen(
  int ii,
  ScreenPtr pScreen
){

  XvScreenPtr pxvs;

  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

  pScreen->DestroyPixmap = pxvs->DestroyPixmap;
  pScreen->DestroyWindow = pxvs->DestroyWindow;
  pScreen->CloseScreen = pxvs->CloseScreen;

  (* pxvs->ddCloseScreen)(ii, pScreen); 

  free(pxvs);

  dixSetPrivate(&pScreen->devPrivates, XvScreenKey, NULL);

  return (*pScreen->CloseScreen)(ii, pScreen);
}

static void
XvResetProc(ExtensionEntry* extEntry)
{
    XvResetProcVector();
}

DevPrivateKey
XvGetScreenKey(void)
{
    return XvScreenKey;
}

unsigned long
XvGetRTPort(void)
{
  return XvRTPort;
}

static Bool
XvDestroyPixmap(PixmapPtr pPix)
{
  Bool status;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;
  XvAdaptorPtr pa;
  int na;
  XvPortPtr pp;
  int np;

  pScreen = pPix->drawable.pScreen;

  SCREEN_PROLOGUE(pScreen, DestroyPixmap);

  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

  /* CHECK TO SEE IF THIS PORT IS IN USE */

  pa = pxvs->pAdaptors;
  na = pxvs->nAdaptors;
  while (na--)
    {
      np = pa->nPorts;
      pp = pa->pPorts;

      while (np--)
	{
	  if (pp->pDraw == (DrawablePtr)pPix)
	    {
	      XvdiSendVideoNotify(pp, pp->pDraw, XvPreempted);

	      (void)(* pp->pAdaptor->ddStopVideo)(NULL, pp, pp->pDraw);

	      pp->pDraw = NULL;
	      pp->client = NULL;
	      pp->time = currentTime;
	    }
	  pp++;
	}
      pa++;
    }
  
  status = (* pScreen->DestroyPixmap)(pPix);

  SCREEN_EPILOGUE(pScreen, DestroyPixmap, XvDestroyPixmap);

  return status;

}

static Bool
XvDestroyWindow(WindowPtr pWin)
{
  Bool status;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;
  XvAdaptorPtr pa;
  int na;
  XvPortPtr pp;
  int np;

  pScreen = pWin->drawable.pScreen;

  SCREEN_PROLOGUE(pScreen, DestroyWindow);

  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

  /* CHECK TO SEE IF THIS PORT IS IN USE */

  pa = pxvs->pAdaptors;
  na = pxvs->nAdaptors;
  while (na--)
    {
      np = pa->nPorts;
      pp = pa->pPorts;

      while (np--)
	{
	  if (pp->pDraw == (DrawablePtr)pWin)
	    {
	      XvdiSendVideoNotify(pp, pp->pDraw, XvPreempted);

	      (void)(* pp->pAdaptor->ddStopVideo)(NULL, pp, pp->pDraw);

	      pp->pDraw = NULL;
	      pp->client = NULL;
	      pp->time = currentTime;
	    }
	  pp++;
	}
      pa++;
    }

  
  status = (* pScreen->DestroyWindow)(pWin);

  SCREEN_EPILOGUE(pScreen, DestroyWindow, XvDestroyWindow);

  return status;

}

/* The XvdiVideoStopped procedure is a hook for the device dependent layer.
   It provides a way for the dd layer to inform the di layer that video has
   stopped in a port for reasons that the di layer had no control over; note
   that it doesn't call back into the dd layer */

int
XvdiVideoStopped(XvPortPtr pPort, int reason)
{
  
  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

  if (!pPort->pDraw) return Success;

  XvdiSendVideoNotify(pPort, pPort->pDraw, reason);

  pPort->pDraw = NULL;
  pPort->client = NULL;
  pPort->time = currentTime;

  return Success;

}

static int 
XvdiDestroyPort(pointer pPort, XID id)
{
  return (* ((XvPortPtr)pPort)->pAdaptor->ddFreePort)(pPort);
}

static int
XvdiDestroyGrab(pointer pGrab, XID id)
{
  ((XvGrabPtr)pGrab)->client = NULL;
  return Success;
}

static int
XvdiDestroyVideoNotify(pointer pn, XID id)
{
  /* JUST CLEAR OUT THE client POINTER FIELD */

  ((XvVideoNotifyPtr)pn)->client = NULL;
  return Success;
}

static int
XvdiDestroyPortNotify(pointer pn, XID id)
{
  /* JUST CLEAR OUT THE client POINTER FIELD */

  ((XvPortNotifyPtr)pn)->client = NULL;
  return Success;
}

static int
XvdiDestroyVideoNotifyList(pointer pn, XID id)
{
  XvVideoNotifyPtr npn,cpn;

  /* ACTUALLY DESTROY THE NOTITY LIST */

  cpn = (XvVideoNotifyPtr)pn;

  while (cpn)
    {
      npn = cpn->next;
      if (cpn->client) FreeResource(cpn->id, XvRTVideoNotify);
      free(cpn);
      cpn = npn;
    }
  return Success;
}

static int
XvdiDestroyEncoding(pointer value, XID id)
{
  return Success;
}

static int
XvdiSendVideoNotify(XvPortPtr pPort, DrawablePtr pDraw, int reason)
{
  xvEvent event;
  XvVideoNotifyPtr pn;

  dixLookupResourceByType((pointer *)&pn, pDraw->id, XvRTVideoNotifyList,
			  serverClient, DixReadAccess);

  while (pn) 
    {
      event.u.u.type = XvEventBase + XvVideoNotify;
      event.u.videoNotify.time = currentTime.milliseconds;
      event.u.videoNotify.drawable = pDraw->id;
      event.u.videoNotify.port = pPort->id;
      event.u.videoNotify.reason = reason;
      WriteEventsToClient(pn->client, 1, (xEventPtr)&event);
      pn = pn->next;
    }

  return Success;

}


int
XvdiSendPortNotify(
  XvPortPtr pPort,
  Atom attribute,
  INT32 value
){
  xvEvent event;
  XvPortNotifyPtr pn;

  pn = pPort->pNotify;

  while (pn) 
    {
      event.u.u.type = XvEventBase + XvPortNotify;
      event.u.portNotify.time = currentTime.milliseconds;
      event.u.portNotify.port = pPort->id;
      event.u.portNotify.attribute = attribute;
      event.u.portNotify.value = value;
      WriteEventsToClient(pn->client, 1, (xEventPtr)&event);
      pn = pn->next;
    }

  return Success;

}


#define CHECK_SIZE(dw, dh, sw, sh) {                                  \
  if(!dw || !dh || !sw || !sh)  return Success;                       \
  /* The region code will break these if they are too large */        \
  if((dw > 32767) || (dh > 32767) || (sw > 32767) || (sh > 32767))    \
        return BadValue;                                              \
}


int
XvdiPutVideo(   
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  DrawablePtr pOldDraw;

  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  /* CHECK TO SEE IF PORT IS IN USE; IF SO THEN WE MUST DELIVER INTERRUPTED
     EVENTS TO ANY CLIENTS WHO WANT THEM */

  pOldDraw = pPort->pDraw;
  if ((pOldDraw) && (pOldDraw != pDraw))
    {
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
    }

  (void) (* pPort->pAdaptor->ddPutVideo)(client, pDraw, pPort, pGC,
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);

  if ((pPort->pDraw) && (pOldDraw != pDraw))
    {
      pPort->client = client;
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvStarted);
    }

  pPort->time = currentTime;

  return Success;

}

int
XvdiPutStill(   
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  int status;

  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  pPort->time = currentTime;

  status = (* pPort->pAdaptor->ddPutStill)(client, pDraw, pPort, pGC, 
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);

  return status;

}

int
XvdiPutImage(   
   ClientPtr client, 
   DrawablePtr pDraw, 
   XvPortPtr pPort, 
   GCPtr pGC,
   INT16 src_x, INT16 src_y, 
   CARD16 src_w, CARD16 src_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h,
   XvImagePtr image,
   unsigned char* data,
   Bool sync,
   CARD16 width, CARD16 height
){
  CHECK_SIZE(drw_w, drw_h, src_w, src_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  pPort->time = currentTime;

  return (* pPort->pAdaptor->ddPutImage)(client, pDraw, pPort, pGC, 
					   src_x, src_y, src_w, src_h, 
					   drw_x, drw_y, drw_w, drw_h,
					   image, data, sync, width, height);
}


int
XvdiGetVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  DrawablePtr pOldDraw;

  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  /* CHECK TO SEE IF PORT IS IN USE; IF SO THEN WE MUST DELIVER INTERRUPTED
     EVENTS TO ANY CLIENTS WHO WANT THEM */

  pOldDraw = pPort->pDraw;
  if ((pOldDraw) && (pOldDraw != pDraw))
    {
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
    }

  (void) (* pPort->pAdaptor->ddGetVideo)(client, pDraw, pPort, pGC,
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);

  if ((pPort->pDraw) && (pOldDraw != pDraw))
    {
      pPort->client = client;
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvStarted);
    }

  pPort->time = currentTime;

  return Success;

}

int
XvdiGetStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  int status;

  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  status = (* pPort->pAdaptor->ddGetStill)(client, pDraw, pPort, pGC, 
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);

  pPort->time = currentTime;

  return status;

}

int
XvdiGrabPort(
   ClientPtr client,
   XvPortPtr pPort,
   Time ctime,
   int *p_result
){
  unsigned long id;
  TimeStamp time;

  UpdateCurrentTime();
  time = ClientTimeToServerTime(ctime);

  if (pPort->grab.client && (client != pPort->grab.client))
    {
      *p_result = XvAlreadyGrabbed;
      return Success;
    }

  if ((CompareTimeStamps(time, currentTime) == LATER) ||
      (CompareTimeStamps(time, pPort->time) == EARLIER))
    {
      *p_result = XvInvalidTime;
      return Success;
    }

  if (client == pPort->grab.client)
    {
      *p_result = Success;
      return Success;
    }

  id = FakeClientID(client->index);

  if (!AddResource(id, XvRTGrab, &pPort->grab))
    {
      return BadAlloc;
    }

  /* IF THERE IS ACTIVE VIDEO THEN STOP IT */

  if ((pPort->pDraw) && (client != pPort->client))
    {
      XvdiStopVideo(NULL, pPort, pPort->pDraw);
    }

  pPort->grab.client = client;
  pPort->grab.id = id;

  pPort->time = currentTime;

  *p_result = Success;

  return Success;

}

int
XvdiUngrabPort(
  ClientPtr client,
  XvPortPtr pPort,
  Time ctime
){
  TimeStamp time;

  UpdateCurrentTime();
  time = ClientTimeToServerTime(ctime);

  if ((!pPort->grab.client) || (client != pPort->grab.client))
    {
      return Success;
    }

  if ((CompareTimeStamps(time, currentTime) == LATER) ||
      (CompareTimeStamps(time, pPort->time) == EARLIER))
    {
      return Success;
    }

  /* FREE THE GRAB RESOURCE; AND SET THE GRAB CLIENT TO NULL */

  FreeResource(pPort->grab.id, XvRTGrab);
  pPort->grab.client = NULL;

  pPort->time = currentTime;

  return Success;

}


int
XvdiSelectVideoNotify(
  ClientPtr client,
  DrawablePtr pDraw,
  BOOL onoff
){
  XvVideoNotifyPtr pn,tpn,fpn;
  int rc;

  /* FIND VideoNotify LIST */

  rc = dixLookupResourceByType((pointer *)&pn, pDraw->id, XvRTVideoNotifyList,
			       client, DixWriteAccess);
  if (rc != Success && rc != BadValue)
      return rc;

  /* IF ONE DONES'T EXIST AND NO MASK, THEN JUST RETURN */

  if (!onoff && !pn) return Success;

  /* IF ONE DOESN'T EXIST CREATE IT AND ADD A RESOURCE SO THAT THE LIST
     WILL BE DELETED WHEN THE DRAWABLE IS DESTROYED */

  if (!pn) 
    {
      if (!(tpn = malloc(sizeof(XvVideoNotifyRec))))
	return BadAlloc;
      tpn->next = NULL;
      if (!AddResource(pDraw->id, XvRTVideoNotifyList, tpn))
	{
	  free(tpn);
	  return BadAlloc;
	}
    }
  else
    {
      /* LOOK TO SEE IF ENTRY ALREADY EXISTS */

      fpn = NULL;
      tpn = pn;
      while (tpn)
	{
	  if (tpn->client == client) 
	    {
	      if (!onoff) tpn->client = NULL;
	      return Success;
	    }
	  if (!tpn->client) fpn = tpn; /* TAKE NOTE OF FREE ENTRY */
	  tpn = tpn->next;
	}

      /* IF TUNNING OFF, THEN JUST RETURN */

      if (!onoff) return Success;

      /* IF ONE ISN'T FOUND THEN ALLOCATE ONE AND LINK IT INTO THE LIST */

      if (fpn)
	{
	  tpn = fpn;
	}
      else
	{
	  if (!(tpn = malloc(sizeof(XvVideoNotifyRec))))
	    return BadAlloc;
	  tpn->next = pn->next;
	  pn->next = tpn;
	}
    }

  /* INIT CLIENT PTR IN CASE WE CAN'T ADD RESOURCE */
  /* ADD RESOURCE SO THAT IF CLIENT EXITS THE CLIENT PTR WILL BE CLEARED */

  tpn->client = NULL;
  tpn->id = FakeClientID(client->index);
  AddResource(tpn->id, XvRTVideoNotify, tpn);

  tpn->client = client;
  return Success;

}

int
XvdiSelectPortNotify(
   ClientPtr client,
   XvPortPtr pPort,
   BOOL onoff
){
  XvPortNotifyPtr pn,tpn;

  /* SEE IF CLIENT IS ALREADY IN LIST */

  tpn = NULL;
  pn = pPort->pNotify;
  while (pn)
    {
      if (!pn->client) tpn = pn; /* TAKE NOTE OF FREE ENTRY */
      if (pn->client == client) break;
      pn = pn->next;
    }

  /* IS THE CLIENT ALREADY ON THE LIST? */

  if (pn)
    {
      /* REMOVE IT? */

      if (!onoff)
	{
	  pn->client = NULL;
	  FreeResource(pn->id, XvRTPortNotify);
	}

      return Success;
    }

  /* DIDN'T FIND IT; SO REUSE LIST ELEMENT IF ONE IS FREE OTHERWISE 
     CREATE A NEW ONE AND ADD IT TO THE BEGINNING OF THE LIST */

  if (!tpn)
    {
      if (!(tpn = malloc(sizeof(XvPortNotifyRec))))
	return BadAlloc;
      tpn->next = pPort->pNotify;
      pPort->pNotify = tpn;
    }

  tpn->client = client;
  tpn->id = FakeClientID(client->index);
  AddResource(tpn->id, XvRTPortNotify, tpn);

  return Success;

}

int
XvdiStopVideo(
  ClientPtr client,
  XvPortPtr pPort,
  DrawablePtr pDraw
){
  int status;

  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

  if (!pPort->pDraw || (pPort->pDraw != pDraw)) 
    {
      XvdiSendVideoNotify(pPort, pDraw, XvStopped);
      return Success;
    }

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if ((client) && (pPort->grab.client) && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  XvdiSendVideoNotify(pPort, pDraw, XvStopped);

  status = (* pPort->pAdaptor->ddStopVideo)(client, pPort, pDraw);

  pPort->pDraw = NULL;
  pPort->client = (ClientPtr)client;
  pPort->time = currentTime;

  return status;

}

int
XvdiPreemptVideo(
  ClientPtr client,
  XvPortPtr pPort,
  DrawablePtr pDraw
){
  int status;

  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

  if (!pPort->pDraw || (pPort->pDraw != pDraw)) return Success;

  XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);

  status = (* pPort->pAdaptor->ddStopVideo)(client, pPort, pPort->pDraw);

  pPort->pDraw = NULL;
  pPort->client = (ClientPtr)client;
  pPort->time = currentTime;

  return status;

}

int
XvdiMatchPort(
  XvPortPtr pPort,
  DrawablePtr pDraw
){

  XvAdaptorPtr pa;
  XvFormatPtr pf;
  int nf;

  pa = pPort->pAdaptor;

  if (pa->pScreen != pDraw->pScreen) return BadMatch;

  nf = pa->nFormats;
  pf = pa->pFormats;

  while (nf--)
    {
      if (pf->depth == pDraw->depth)
	return Success;
      pf++;
    }

  return BadMatch;

}

int
XvdiSetPortAttribute(
  ClientPtr client,
  XvPortPtr pPort,
  Atom attribute,
  INT32 value
){
  int status;

  status = (* pPort->pAdaptor->ddSetPortAttribute)(client, pPort, attribute, value);
  if (status == Success)
    XvdiSendPortNotify(pPort, attribute, value);

  return status;
}

int
XvdiGetPortAttribute(
  ClientPtr client,
  XvPortPtr pPort,
  Atom attribute,
  INT32 *p_value
){

  return 
    (* pPort->pAdaptor->ddGetPortAttribute)(client, pPort, attribute, p_value);

}

static void
WriteSwappedVideoNotifyEvent(xvEvent *from, xvEvent *to)

{

  to->u.u.type = from->u.u.type;
  to->u.u.detail = from->u.u.detail;
  cpswaps(from->u.videoNotify.sequenceNumber, 
	  to->u.videoNotify.sequenceNumber);
  cpswapl(from->u.videoNotify.time, to->u.videoNotify.time);
  cpswapl(from->u.videoNotify.drawable, to->u.videoNotify.drawable);
  cpswapl(from->u.videoNotify.port, to->u.videoNotify.port);

}

static void
WriteSwappedPortNotifyEvent(xvEvent *from, xvEvent *to)

{

  to->u.u.type = from->u.u.type;
  to->u.u.detail = from->u.u.detail;
  cpswaps(from->u.portNotify.sequenceNumber, to->u.portNotify.sequenceNumber);
  cpswapl(from->u.portNotify.time, to->u.portNotify.time);
  cpswapl(from->u.portNotify.port, to->u.portNotify.port);
  cpswapl(from->u.portNotify.value, to->u.portNotify.value);

}

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "extnsionst.h"
#include "servermd.h"
#include <X11/Xfuncproto.h>
#include "xvdix.h"
#include <X11/extensions/XvMC.h>
#include <X11/extensions/Xvproto.h>
#include <X11/extensions/XvMCproto.h>
#include "xvmcext.h"
#include "protocol-versions.h"

#ifdef HAS_XVMCSHM
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/shm.h>
#endif /* HAS_XVMCSHM */
   


#define DR_CLIENT_DRIVER_NAME_SIZE 48
#define DR_BUSID_SIZE 48

static DevPrivateKeyRec XvMCScreenKeyRec;
#define XvMCScreenKey (&XvMCScreenKeyRec)
static Bool XvMCInUse;

unsigned long XvMCGeneration = 0;

int XvMCReqCode;
int XvMCEventBase;

static RESTYPE XvMCRTContext;
static RESTYPE XvMCRTSurface;
static RESTYPE XvMCRTSubpicture;

typedef struct {
   int num_adaptors;
   XvMCAdaptorPtr adaptors;
   CloseScreenProcPtr	CloseScreen;
   char clientDriverName[DR_CLIENT_DRIVER_NAME_SIZE];
   char busID[DR_BUSID_SIZE];
   int major;
   int minor;
   int patchLevel;
} XvMCScreenRec, *XvMCScreenPtr; 

#define XVMC_GET_PRIVATE(pScreen) \
    (XvMCScreenPtr)(dixLookupPrivate(&(pScreen)->devPrivates, XvMCScreenKey))


static int
XvMCDestroyContextRes(pointer data, XID id)
{
   XvMCContextPtr pContext = (XvMCContextPtr)data;
   
   pContext->refcnt--;

   if(!pContext->refcnt) {
  	 XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);
	(*pScreenPriv->adaptors[pContext->adapt_num].DestroyContext)(pContext);
	free(pContext);
   }	   

   return Success;
}

static int
XvMCDestroySurfaceRes(pointer data, XID id)
{
   XvMCSurfacePtr pSurface = (XvMCSurfacePtr)data;
   XvMCContextPtr pContext = pSurface->context;
   XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

   (*pScreenPriv->adaptors[pContext->adapt_num].DestroySurface)(pSurface); 
   free(pSurface);

   XvMCDestroyContextRes((pointer)pContext, pContext->context_id);

   return Success;
}


static int
XvMCDestroySubpictureRes(pointer data, XID id)
{
   XvMCSubpicturePtr pSubpict = (XvMCSubpicturePtr)data;
   XvMCContextPtr pContext = pSubpict->context;
   XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

   (*pScreenPriv->adaptors[pContext->adapt_num].DestroySubpicture)(pSubpict); 
   free(pSubpict);

   XvMCDestroyContextRes((pointer)pContext, pContext->context_id);

   return Success;
}

static int 
ProcXvMCQueryVersion(ClientPtr client)
{
    xvmcQueryVersionReply rep;
    /* REQUEST(xvmcQueryVersionReq); */
    REQUEST_SIZE_MATCH(xvmcQueryVersionReq);
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.major = SERVER_XVMC_MAJOR_VERSION;
    rep.minor = SERVER_XVMC_MINOR_VERSION;
    WriteToClient(client, sizeof(xvmcQueryVersionReply), (char*)&rep);
    return Success;
}


static int 
ProcXvMCListSurfaceTypes(ClientPtr client)
{
    XvPortPtr pPort;
    int i;
    XvMCScreenPtr pScreenPriv;
    xvmcListSurfaceTypesReply rep;
    xvmcSurfaceInfo info;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface;
    REQUEST(xvmcListSurfaceTypesReq);
    REQUEST_SIZE_MATCH(xvmcListSurfaceTypesReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if(XvMCInUse) { /* any adaptors at all */
       ScreenPtr pScreen = pPort->pAdaptor->pScreen;
       if((pScreenPriv = XVMC_GET_PRIVATE(pScreen))) {  /* any this screen */
          for(i = 0; i < pScreenPriv->num_adaptors; i++) {
             if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
               adaptor = &(pScreenPriv->adaptors[i]);
               break;
             }
          }
       }
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num = (adaptor) ? adaptor->num_surfaces : 0;
    rep.length = bytes_to_int32(rep.num * sizeof(xvmcSurfaceInfo));
 
    WriteToClient(client, sizeof(xvmcListSurfaceTypesReply), (char*)&rep);

    for(i = 0; i < rep.num; i++) {
	surface = adaptor->surfaces[i];
	info.surface_type_id = surface->surface_type_id;
	info.chroma_format = surface->chroma_format;
	info.max_width = surface->max_width;
	info.max_height = surface->max_height;
	info.subpicture_max_width = surface->subpicture_max_width;
	info.subpicture_max_height = surface->subpicture_max_height;
	info.mc_type = surface->mc_type;
	info.flags = surface->flags;
	WriteToClient(client, sizeof(xvmcSurfaceInfo), (char*)&info);
    }

    return Success;
}

static int 
ProcXvMCCreateContext(ClientPtr client)
{
    XvPortPtr pPort;
    CARD32 *data = NULL;
    int dwords = 0; 
    int i, result, adapt_num = -1;
    ScreenPtr pScreen;
    XvMCContextPtr pContext;
    XvMCScreenPtr pScreenPriv;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface = NULL;
    xvmcCreateContextReply rep;
    REQUEST(xvmcCreateContextReq);
    REQUEST_SIZE_MATCH(xvmcCreateContextReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;

    if(!XvMCInUse) /* no XvMC adaptors */
       return BadMatch;
 
    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen))) /* none this screen */
       return BadMatch;

    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
	if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
	    adaptor = &(pScreenPriv->adaptors[i]);
	    adapt_num = i; 
	    break;
	}
    }

    if(adapt_num < 0) /* none this port */
	return BadMatch;	

    for(i = 0; i < adaptor->num_surfaces; i++) {
        if(adaptor->surfaces[i]->surface_type_id == stuff->surface_type_id) {
            surface = adaptor->surfaces[i];
            break;
        }
    }

    /* adaptor doesn't support this suface_type_id */
    if(!surface) return BadMatch;


    if((stuff->width > surface->max_width) ||
       (stuff->height > surface->max_height))
        return BadValue;

    if(!(pContext = malloc(sizeof(XvMCContextRec)))) {
	return BadAlloc;
    }


    pContext->pScreen = pScreen;
    pContext->adapt_num = adapt_num;
    pContext->context_id = stuff->context_id;
    pContext->surface_type_id = stuff->surface_type_id;
    pContext->width = stuff->width;
    pContext->height = stuff->height;
    pContext->flags = stuff->flags;
    pContext->refcnt = 1;

    result = (*adaptor->CreateContext)(pPort, pContext, &dwords, &data);

    if(result != Success) {
	free(pContext);
	return result;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.width_actual = pContext->width; 
    rep.height_actual = pContext->height; 
    rep.flags_return = pContext->flags; 
    rep.length = dwords;

    WriteToClient(client, sizeof(xvmcCreateContextReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data); 
    AddResource(pContext->context_id, XvMCRTContext, pContext);

    free(data);

    return Success;
}

static int 
ProcXvMCDestroyContext(ClientPtr client)
{
    pointer val;
    int rc;
    REQUEST(xvmcDestroyContextReq);
    REQUEST_SIZE_MATCH(xvmcDestroyContextReq);

    rc = dixLookupResourceByType(&val, stuff->context_id, XvMCRTContext,
				 client, DixDestroyAccess);
    if (rc != Success)
	return rc;

    FreeResource(stuff->context_id, RT_NONE); 

    return Success;
}

static int 
ProcXvMCCreateSurface(ClientPtr client)
{
    CARD32 *data = NULL;
    int dwords = 0;
    int result;
    XvMCContextPtr pContext;
    XvMCSurfacePtr pSurface;
    XvMCScreenPtr pScreenPriv;
    xvmcCreateSurfaceReply rep;
    REQUEST(xvmcCreateSurfaceReq);
    REQUEST_SIZE_MATCH(xvmcCreateSurfaceReq);

    result = dixLookupResourceByType((pointer *)&pContext, stuff->context_id,
				     XvMCRTContext, client, DixUseAccess);
    if (result != Success)
        return result;

    pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

    if(!(pSurface = malloc(sizeof(XvMCSurfaceRec)))) 
        return BadAlloc;

    pSurface->surface_id = stuff->surface_id;
    pSurface->surface_type_id = pContext->surface_type_id;
    pSurface->context = pContext;

    result = (*pScreenPriv->adaptors[pContext->adapt_num].CreateSurface)(
                pSurface, &dwords, &data);

    if(result != Success) {
        free(pSurface);
        return result;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = dwords;

    WriteToClient(client, sizeof(xvmcCreateSurfaceReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data);
    AddResource(pSurface->surface_id, XvMCRTSurface, pSurface);

    free(data);

    pContext->refcnt++;

    return Success;
}

static int 
ProcXvMCDestroySurface(ClientPtr client)
{
    pointer val;
    int rc;
    REQUEST(xvmcDestroySurfaceReq);
    REQUEST_SIZE_MATCH(xvmcDestroySurfaceReq);

    rc = dixLookupResourceByType(&val, stuff->surface_id, XvMCRTSurface,
				 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->surface_id, RT_NONE);

    return Success;
}

static int 
ProcXvMCCreateSubpicture(ClientPtr client)
{
    Bool image_supported = FALSE;
    CARD32 *data = NULL;
    int i, result, dwords = 0;
    XvMCContextPtr pContext;
    XvMCSubpicturePtr pSubpicture;
    XvMCScreenPtr pScreenPriv;
    xvmcCreateSubpictureReply rep;
    XvMCAdaptorPtr adaptor;
    XvMCSurfaceInfoPtr surface = NULL;
    REQUEST(xvmcCreateSubpictureReq);
    REQUEST_SIZE_MATCH(xvmcCreateSubpictureReq);

    result = dixLookupResourceByType((pointer *)&pContext, stuff->context_id,
				     XvMCRTContext, client, DixUseAccess);
    if (result != Success)
        return result;

    pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

    adaptor = &(pScreenPriv->adaptors[pContext->adapt_num]); 

    /* find which surface this context supports */
    for(i = 0; i < adaptor->num_surfaces; i++) {
	if(adaptor->surfaces[i]->surface_type_id == pContext->surface_type_id){
	   surface = adaptor->surfaces[i];
	   break;
	}
    } 

    if(!surface) return BadMatch;

    /* make sure this surface supports that xvimage format */
    if(!surface->compatible_subpictures) return BadMatch;

    for(i = 0; i < surface->compatible_subpictures->num_xvimages; i++) {
      if(surface->compatible_subpictures->xvimage_ids[i] == stuff->xvimage_id) {
	   image_supported = TRUE;
	   break;
      }
    }

    if(!image_supported) return BadMatch;

    /* make sure the size is OK */
    if((stuff->width > surface->subpicture_max_width) ||
       (stuff->height > surface->subpicture_max_height))
	return BadValue;

    if(!(pSubpicture = malloc(sizeof(XvMCSubpictureRec))))
        return BadAlloc;

    pSubpicture->subpicture_id = stuff->subpicture_id;
    pSubpicture->xvimage_id = stuff->xvimage_id;
    pSubpicture->width = stuff->width;
    pSubpicture->height = stuff->height;
    pSubpicture->num_palette_entries = 0; /* overwritten by DDX */
    pSubpicture->entry_bytes = 0;         /* overwritten by DDX */
    pSubpicture->component_order[0] = 0;  /* overwritten by DDX */
    pSubpicture->component_order[1] = 0;
    pSubpicture->component_order[2] = 0;
    pSubpicture->component_order[3] = 0;
    pSubpicture->context = pContext;
   
    result = (*pScreenPriv->adaptors[pContext->adapt_num].CreateSubpicture)(
                pSubpicture, &dwords, &data);

    if(result != Success) {
        free(pSubpicture);
        return result;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.width_actual = pSubpicture->width;
    rep.height_actual = pSubpicture->height;
    rep.num_palette_entries = pSubpicture->num_palette_entries;
    rep.entry_bytes = pSubpicture->entry_bytes;
    rep.component_order[0] = pSubpicture->component_order[0];
    rep.component_order[1] = pSubpicture->component_order[1];
    rep.component_order[2] = pSubpicture->component_order[2];
    rep.component_order[3] = pSubpicture->component_order[3];
    rep.length = dwords;

    WriteToClient(client, sizeof(xvmcCreateSubpictureReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data);
    AddResource(pSubpicture->subpicture_id, XvMCRTSubpicture, pSubpicture);

    free(data);

    pContext->refcnt++;

    return Success;
}

static int 
ProcXvMCDestroySubpicture(ClientPtr client)
{
    pointer val;
    int rc;
    REQUEST(xvmcDestroySubpictureReq);
    REQUEST_SIZE_MATCH(xvmcDestroySubpictureReq);

    rc = dixLookupResourceByType(&val, stuff->subpicture_id, XvMCRTSubpicture,
				 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->subpicture_id, RT_NONE);

    return Success;
}


static int
ProcXvMCListSubpictureTypes(ClientPtr client)
{
    XvPortPtr pPort;
    xvmcListSubpictureTypesReply rep;
    XvMCScreenPtr pScreenPriv;
    ScreenPtr pScreen;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface = NULL;
    xvImageFormatInfo info;
    XvImagePtr pImage;
    int i, j;
    REQUEST(xvmcListSubpictureTypesReq);
    REQUEST_SIZE_MATCH(xvmcListSubpictureTypesReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;

    if (!dixPrivateKeyRegistered(XvMCScreenKey))
        return BadMatch;   /* No XvMC adaptors */

    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen)))
        return BadMatch;   /* None this screen */

    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
        if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
            adaptor = &(pScreenPriv->adaptors[i]);
            break;
        }
    }

    if(!adaptor) return BadMatch;

    for(i = 0; i < adaptor->num_surfaces; i++) {
        if(adaptor->surfaces[i]->surface_type_id == stuff->surface_type_id) {
            surface = adaptor->surfaces[i];
            break;
        }
    }

    if(!surface) return BadMatch;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num = 0;
    if(surface->compatible_subpictures) 
	rep.num = surface->compatible_subpictures->num_xvimages;

    rep.length = bytes_to_int32(rep.num * sizeof(xvImageFormatInfo));

    WriteToClient(client, sizeof(xvmcListSubpictureTypesReply), (char*)&rep);

    for(i = 0; i < rep.num; i++) {
	pImage = NULL;
	for(j = 0; j < adaptor->num_subpictures; j++) {
	    if(surface->compatible_subpictures->xvimage_ids[i] ==
	       adaptor->subpictures[j]->id)
	    {
		pImage = adaptor->subpictures[j];
	        break;
	    }
	}
	if(!pImage) return BadImplementation;

        info.id = pImage->id;      
	info.type = pImage->type;  
        info.byte_order = pImage->byte_order; 
        memcpy(&info.guid, pImage->guid, 16);      
        info.bpp = pImage->bits_per_pixel;         
        info.num_planes = pImage->num_planes;      
        info.depth = pImage->depth;        
        info.red_mask = pImage->red_mask;  
        info.green_mask = pImage->green_mask;      
        info.blue_mask = pImage->blue_mask;        
        info.format = pImage->format;      
        info.y_sample_bits = pImage->y_sample_bits;        
        info.u_sample_bits = pImage->u_sample_bits;        
        info.v_sample_bits = pImage->v_sample_bits;        
        info.horz_y_period = pImage->horz_y_period;        
        info.horz_u_period = pImage->horz_u_period;        
        info.horz_v_period = pImage->horz_v_period;        
        info.vert_y_period = pImage->vert_y_period;        
        info.vert_u_period = pImage->vert_u_period;        
        info.vert_v_period = pImage->vert_v_period;        
        memcpy(&info.comp_order, pImage->component_order, 32);     
        info.scanline_order = pImage->scanline_order;
	WriteToClient(client, sizeof(xvImageFormatInfo), (char*)&info);
    }

    return Success;
}

static int
ProcXvMCGetDRInfo(ClientPtr client)
{
    xvmcGetDRInfoReply rep;
    XvPortPtr pPort;
    ScreenPtr pScreen;
    XvMCScreenPtr pScreenPriv;

#ifdef HAS_XVMCSHM
    volatile CARD32 *patternP;
#endif

    REQUEST(xvmcGetDRInfoReq);
    REQUEST_SIZE_MATCH(xvmcGetDRInfoReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;
    pScreenPriv = XVMC_GET_PRIVATE(pScreen);
    
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.major = pScreenPriv->major;
    rep.minor = pScreenPriv->minor;
    rep.patchLevel = pScreenPriv->patchLevel;
    rep.nameLen = bytes_to_int32(strlen(pScreenPriv->clientDriverName) + 1);
    rep.busIDLen = bytes_to_int32(strlen(pScreenPriv->busID) + 1);

    rep.length = rep.nameLen + rep.busIDLen;
    rep.nameLen <<=2;
    rep.busIDLen <<=2;

    /*
     * Read back to the client what she has put in the shared memory
     * segment she prepared for us.
     */

    rep.isLocal = 1;
#ifdef HAS_XVMCSHM
    patternP = (CARD32 *)shmat( stuff->shmKey, NULL, SHM_RDONLY );
    if ( -1 != (long) patternP) {
        volatile CARD32 *patternC = patternP;
	int i;
	CARD32 magic = stuff->magic;
	
	rep.isLocal = 1;
	i = 1024 / sizeof(CARD32);
	
	while ( i-- ) {
	    if (*patternC++ != magic) {
		rep.isLocal = 0;
		break;
	    }
	    magic = ~magic;
	}
	shmdt( (char *)patternP ); 
    }
#endif /* HAS_XVMCSHM */
    
    WriteToClient(client, sizeof(xvmcGetDRInfoReply), 
		  (char*)&rep);
    if (rep.length) {      
	WriteToClient(client, rep.nameLen, 
		      pScreenPriv->clientDriverName);
	WriteToClient(client, rep.busIDLen, 
		      pScreenPriv->busID);
    }	
    return Success;
}


int (*ProcXvMCVector[xvmcNumRequest])(ClientPtr) = {
  ProcXvMCQueryVersion,
  ProcXvMCListSurfaceTypes,
  ProcXvMCCreateContext,
  ProcXvMCDestroyContext,
  ProcXvMCCreateSurface,
  ProcXvMCDestroySurface,
  ProcXvMCCreateSubpicture,
  ProcXvMCDestroySubpicture,
  ProcXvMCListSubpictureTypes,
  ProcXvMCGetDRInfo
};

static int
ProcXvMCDispatch (ClientPtr client)
{
    REQUEST(xReq);
    
    if(stuff->data < xvmcNumRequest)
	return (*ProcXvMCVector[stuff->data])(client);
    else
	return BadRequest;
}

static int
SProcXvMCDispatch (ClientPtr client)
{
    /* We only support local */
    return BadImplementation;
}

void
XvMCExtensionInit(void)
{
   ExtensionEntry *extEntry;

   if (!dixPrivateKeyRegistered(XvMCScreenKey))
	return;

   if(!(XvMCRTContext = CreateNewResourceType(XvMCDestroyContextRes,
					      "XvMCRTContext")))
	return;

   if(!(XvMCRTSurface = CreateNewResourceType(XvMCDestroySurfaceRes,
					      "XvMCRTSurface")))
	return;

   if(!(XvMCRTSubpicture = CreateNewResourceType(XvMCDestroySubpictureRes,
						 "XvMCRTSubpicture")))
	return;

   extEntry = AddExtension(XvMCName, XvMCNumEvents, XvMCNumErrors, 
                              ProcXvMCDispatch, SProcXvMCDispatch,
                              NULL, StandardMinorOpcode);

   if(!extEntry) return;
  
   XvMCReqCode = extEntry->base;
   XvMCEventBase = extEntry->eventBase;
   SetResourceTypeErrorValue(XvMCRTContext, extEntry->errorBase + XvMCBadContext);
   SetResourceTypeErrorValue(XvMCRTSurface, extEntry->errorBase + XvMCBadSurface);
   SetResourceTypeErrorValue(XvMCRTSubpicture, extEntry->errorBase + XvMCBadSubpicture);
}

static Bool
XvMCCloseScreen (int i, ScreenPtr pScreen)
{
    XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;

    free(pScreenPriv);

    return (*pScreen->CloseScreen)(i, pScreen);
}


int
XvMCScreenInit(ScreenPtr pScreen, int num, XvMCAdaptorPtr pAdapt)
{
   XvMCScreenPtr pScreenPriv;

   if (!dixRegisterPrivateKey(&XvMCScreenKeyRec, PRIVATE_SCREEN, 0))
       return BadAlloc;

   if(!(pScreenPriv = malloc(sizeof(XvMCScreenRec))))
	return BadAlloc;

   dixSetPrivate(&pScreen->devPrivates, XvMCScreenKey, pScreenPriv);

   pScreenPriv->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = XvMCCloseScreen;

   pScreenPriv->num_adaptors = num;
   pScreenPriv->adaptors = pAdapt;
   pScreenPriv->clientDriverName[0] = 0;
   pScreenPriv->busID[0] = 0;
   pScreenPriv->major = 0;
   pScreenPriv->minor = 0;
   pScreenPriv->patchLevel = 0;

   XvMCInUse = TRUE;

   return Success;
}

XvImagePtr XvMCFindXvImage(XvPortPtr pPort, CARD32 id)
{
    XvImagePtr pImage = NULL;
    ScreenPtr pScreen = pPort->pAdaptor->pScreen;
    XvMCScreenPtr pScreenPriv;
    XvMCAdaptorPtr adaptor = NULL;
    int i;

    if (!dixPrivateKeyRegistered(XvMCScreenKey))
        return NULL;

    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen))) 
        return NULL;

    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
       if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
          adaptor = &(pScreenPriv->adaptors[i]);
          break;
       }
    }

    if(!adaptor) return NULL;

    for(i = 0; i < adaptor->num_subpictures; i++) {
        if(adaptor->subpictures[i]->id == id) {
            pImage = adaptor->subpictures[i];
            break;
        }
    }

    return pImage;
}

int
xf86XvMCRegisterDRInfo(ScreenPtr pScreen, char *name,
		       char *busID, int major, int minor,
		       int patchLevel)
{
    XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pScreen);
    strncpy(pScreenPriv->clientDriverName, name,
	    DR_CLIENT_DRIVER_NAME_SIZE);
    strncpy(pScreenPriv->busID, busID, DR_BUSID_SIZE);
    pScreenPriv->major = major;
    pScreenPriv->minor = minor;
    pScreenPriv->patchLevel = patchLevel;
    pScreenPriv->clientDriverName[DR_CLIENT_DRIVER_NAME_SIZE-1] = 0;
    pScreenPriv->busID[DR_BUSID_SIZE-1] = 0;
    return Success;
}


#ifndef _XVMC_H
#define _XVMC_H
#include <X11/extensions/Xv.h>
#include "xvdix.h"

typedef struct {
  int num_xvimages;
  int *xvimage_ids;
} XvMCImageIDList;

typedef struct {
  int surface_type_id;
  int chroma_format;
  int color_description;
  unsigned short max_width;
  unsigned short max_height;
  unsigned short subpicture_max_width;
  unsigned short subpicture_max_height;
  int mc_type;
  int flags;
  XvMCImageIDList *compatible_subpictures;
} XvMCSurfaceInfoRec, *XvMCSurfaceInfoPtr;

typedef struct {
  XID context_id;
  ScreenPtr pScreen;
  int adapt_num;
  int surface_type_id;
  unsigned short width;
  unsigned short height;
  CARD32 flags;
  int refcnt;
  pointer port_priv;
  pointer driver_priv;
} XvMCContextRec, *XvMCContextPtr;

typedef struct {
  XID surface_id;
  int surface_type_id;
  XvMCContextPtr context;
  pointer driver_priv;
} XvMCSurfaceRec, *XvMCSurfacePtr;


typedef struct {
  XID subpicture_id;
  int xvimage_id;
  unsigned short width;
  unsigned short height;
  int num_palette_entries;
  int entry_bytes;
  char component_order[4];
  XvMCContextPtr context;
  pointer driver_priv;
} XvMCSubpictureRec, *XvMCSubpicturePtr;

typedef int (*XvMCCreateContextProcPtr) (
  XvPortPtr port,
  XvMCContextPtr context,
  int *num_priv,
  CARD32 **priv 
);

typedef void (*XvMCDestroyContextProcPtr) (
  XvMCContextPtr context
);

typedef int (*XvMCCreateSurfaceProcPtr) (
  XvMCSurfacePtr surface,
  int *num_priv,
  CARD32 **priv
);

typedef void (*XvMCDestroySurfaceProcPtr) (
  XvMCSurfacePtr surface
);

typedef int (*XvMCCreateSubpictureProcPtr) (
  XvMCSubpicturePtr subpicture,
  int *num_priv,
  CARD32 **priv
);

typedef void (*XvMCDestroySubpictureProcPtr) (
  XvMCSubpicturePtr subpicture
);


typedef struct {
  XvAdaptorPtr			    xv_adaptor;
  int				    num_surfaces;
  XvMCSurfaceInfoPtr		    *surfaces;
  int				    num_subpictures;
  XvImagePtr			    *subpictures;
  XvMCCreateContextProcPtr          CreateContext; 
  XvMCDestroyContextProcPtr         DestroyContext; 
  XvMCCreateSurfaceProcPtr          CreateSurface;  
  XvMCDestroySurfaceProcPtr         DestroySurface; 
  XvMCCreateSubpictureProcPtr       CreateSubpicture; 
  XvMCDestroySubpictureProcPtr      DestroySubpicture;
} XvMCAdaptorRec, *XvMCAdaptorPtr;

#ifndef XorgLoader
extern _X_EXPORT void XvMCExtensionInit(void);

extern _X_EXPORT int XvMCScreenInit(ScreenPtr pScreen,
				    int num,
				    XvMCAdaptorPtr adapt);

extern _X_EXPORT XvImagePtr XvMCFindXvImage(XvPortPtr pPort, CARD32 id);

extern _X_EXPORT int xf86XvMCRegisterDRInfo(ScreenPtr pScreen, char *name,
			   char *busID, int major, int minor, 
			   int patchLevel);
#endif

#endif /* _XVMC_H */
/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "scrnintstr.h"
#include "cursorstr.h"
#include "dixevents.h"
#include "servermd.h"
#include "mipointer.h"
#include "inputstr.h"
#include "windowstr.h"
#include "xace.h"
#include "list.h"

static RESTYPE		CursorClientType;
static RESTYPE		CursorHideCountType;
static RESTYPE		CursorWindowType;
RESTYPE			PointerBarrierType;
static CursorPtr	CursorCurrent[MAXDEVICES];

static DevPrivateKeyRec CursorScreenPrivateKeyRec;
#define CursorScreenPrivateKey (&CursorScreenPrivateKeyRec)

static void deleteCursorHideCountsForScreen (ScreenPtr pScreen);

#define VERIFY_CURSOR(pCursor, cursor, client, access)			\
    do {								\
	int err;							\
	err = dixLookupResourceByType((pointer *) &pCursor, cursor,	\
				      RT_CURSOR, client, access);	\
	if (err != Success) {						\
	    client->errorValue = cursor;				\
	    return err;							\
	}								\
    } while (0)

/*
 * There is a global list of windows selecting for cursor events
 */

typedef struct _CursorEvent *CursorEventPtr;

typedef struct _CursorEvent {
    CursorEventPtr	next;
    CARD32		eventMask;
    ClientPtr		pClient;
    WindowPtr		pWindow;
    XID			clientResource;
} CursorEventRec;

static CursorEventPtr	    cursorEvents;

/*
 * Each screen has a list of clients which have requested
 * that the cursor be hid, and the number of times each
 * client has requested.
*/

typedef struct _CursorHideCountRec *CursorHideCountPtr;

typedef struct _CursorHideCountRec {
    CursorHideCountPtr   pNext;  
    ClientPtr            pClient;
    ScreenPtr            pScreen;
    int                  hideCount;
    XID			 resource;
} CursorHideCountRec;

typedef struct PointerBarrierClient *PointerBarrierClientPtr;

struct PointerBarrierClient {
    ScreenPtr screen;
    struct PointerBarrier barrier;
    struct list entry;
};

/*
 * Wrap DisplayCursor to catch cursor change events
 */

typedef struct _CursorScreen {
    DisplayCursorProcPtr	DisplayCursor;
    CloseScreenProcPtr		CloseScreen;
    ConstrainCursorHarderProcPtr ConstrainCursorHarder;
    CursorHideCountPtr          pCursorHideCounts;
    struct list                 barriers;
} CursorScreenRec, *CursorScreenPtr;

#define GetCursorScreen(s) ((CursorScreenPtr)dixLookupPrivate(&(s)->devPrivates, CursorScreenPrivateKey))
#define GetCursorScreenIfSet(s) GetCursorScreen(s)
#define SetCursorScreen(s,p) dixSetPrivate(&(s)->devPrivates, CursorScreenPrivateKey, p)
#define Wrap(as,s,elt,func)	(((as)->elt = (s)->elt), (s)->elt = func)
#define Unwrap(as,s,elt,backup)	(((backup) = (s)->elt), (s)->elt = (as)->elt)

/* The cursor doesn't show up until the first XDefineCursor() */
static Bool CursorVisible = FALSE;

Bool EnableCursor = TRUE;

static Bool
CursorDisplayCursor (DeviceIntPtr pDev,
                     ScreenPtr pScreen,
		     CursorPtr pCursor)
{
    CursorScreenPtr	cs = GetCursorScreen(pScreen);
    Bool		ret;
    DisplayCursorProcPtr backupProc;

    Unwrap (cs, pScreen, DisplayCursor, backupProc);

    /*
     * Have to check ConnectionInfo to distinguish client requests from
     * initial root window setup.  Not a great way to do it, I admit.
     */
    if (ConnectionInfo)
	CursorVisible = EnableCursor;

    if (cs->pCursorHideCounts != NULL || !CursorVisible) {
	ret = (*pScreen->DisplayCursor) (pDev, pScreen, NullCursor);
    } else {
	ret = (*pScreen->DisplayCursor) (pDev, pScreen, pCursor);
    }

    if (pCursor != CursorCurrent[pDev->id])
    {
	CursorEventPtr	e;

	CursorCurrent[pDev->id] = pCursor;
	for (e = cursorEvents; e; e = e->next)
	{
	    if ((e->eventMask & XFixesDisplayCursorNotifyMask))
	    {
		xXFixesCursorNotifyEvent	ev;
		ev.type = XFixesEventBase + XFixesCursorNotify;
		ev.subtype = XFixesDisplayCursorNotify;
		ev.window = e->pWindow->drawable.id;
		ev.cursorSerial = pCursor->serialNumber;
		ev.timestamp = currentTime.milliseconds;
		ev.name = pCursor->name;
		WriteEventsToClient (e->pClient, 1, (xEvent *) &ev);
	    }
	}
    }
    Wrap (cs, pScreen, DisplayCursor, backupProc);

    return ret;
}

static Bool
CursorCloseScreen (int index, ScreenPtr pScreen)
{
    CursorScreenPtr	cs = GetCursorScreen (pScreen);
    Bool		ret;
    _X_UNUSED CloseScreenProcPtr	close_proc;
    _X_UNUSED DisplayCursorProcPtr	display_proc;
    ConstrainCursorHarderProcPtr constrain_proc;

    Unwrap (cs, pScreen, CloseScreen, close_proc);
    Unwrap (cs, pScreen, DisplayCursor, display_proc);
    Unwrap (cs, pScreen, ConstrainCursorHarder, constrain_proc);
    deleteCursorHideCountsForScreen(pScreen);
    ret = (*pScreen->CloseScreen) (index, pScreen);
    free(cs);
    return ret;
}

#define CursorAllEvents (XFixesDisplayCursorNotifyMask)

static int
XFixesSelectCursorInput (ClientPtr	pClient,
			 WindowPtr	pWindow,
			 CARD32		eventMask)
{
    CursorEventPtr	*prev, e;
    pointer val;
    int rc;

    for (prev = &cursorEvents; (e = *prev); prev = &e->next)
    {
	if (e->pClient == pClient &&
	    e->pWindow == pWindow)
	{
	    break;
	}
    }
    if (!eventMask)
    {
	if (e)
	{
	    FreeResource (e->clientResource, 0);
	}
	return Success;
    }
    if (!e)
    {
	e = (CursorEventPtr) malloc(sizeof (CursorEventRec));
	if (!e)
	    return BadAlloc;

	e->next = 0;
	e->pClient = pClient;
	e->pWindow = pWindow;
	e->clientResource = FakeClientID(pClient->index);

	/*
	 * Add a resource hanging from the window to
	 * catch window destroy
	 */
	rc = dixLookupResourceByType( &val, pWindow->drawable.id,
				      CursorWindowType, serverClient,
				      DixGetAttrAccess);
	if (rc != Success)
	    if (!AddResource (pWindow->drawable.id, CursorWindowType,
			      (pointer) pWindow))
	    {
		free(e);
		return BadAlloc;
	    }

	if (!AddResource (e->clientResource, CursorClientType, (pointer) e))
	    return BadAlloc;

	*prev = e;
    }
    e->eventMask = eventMask;
    return Success;
}

int
ProcXFixesSelectCursorInput (ClientPtr client)
{
    REQUEST (xXFixesSelectCursorInputReq);
    WindowPtr	pWin;
    int		rc;

    REQUEST_SIZE_MATCH (xXFixesSelectCursorInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->eventMask & ~CursorAllEvents)
    {
	client->errorValue = stuff->eventMask;
	return BadValue;
    }
    return XFixesSelectCursorInput (client, pWin, stuff->eventMask);
}

static int
GetBit (unsigned char *line, int x)
{
    unsigned char   mask;
    
    if (screenInfo.bitmapBitOrder == LSBFirst)
	mask = (1 << (x & 7));
    else
	mask = (0x80 >> (x & 7));
    /* XXX assumes byte order is host byte order */
    line += (x >> 3);
    if (*line & mask)
	return 1;
    return 0;
}

int
SProcXFixesSelectCursorInput (ClientPtr client)
{
    register int n;
    REQUEST(xXFixesSelectCursorInputReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    swapl(&stuff->eventMask, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}
    
void
SXFixesCursorNotifyEvent (xXFixesCursorNotifyEvent *from,
			  xXFixesCursorNotifyEvent *to)
{
    to->type = from->type;
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->window, to->window);
    cpswapl (from->cursorSerial, to->cursorSerial);
    cpswapl (from->timestamp, to->timestamp);
    cpswapl (from->name, to->name);
}

static void
CopyCursorToImage (CursorPtr pCursor, CARD32 *image)
{
    int width = pCursor->bits->width;
    int height = pCursor->bits->height;
    int npixels = width * height;
    
#ifdef ARGB_CURSOR
    if (pCursor->bits->argb)
	memcpy (image, pCursor->bits->argb, npixels * sizeof (CARD32));
    else
#endif
    {
	unsigned char	*srcLine = pCursor->bits->source;
	unsigned char	*mskLine = pCursor->bits->mask;
	int		stride = BitmapBytePad (width);
	int		x, y;
	CARD32		fg, bg;
	
	fg = (0xff000000 | 
	      ((pCursor->foreRed & 0xff00) << 8) |
	      (pCursor->foreGreen & 0xff00) |
	      (pCursor->foreBlue >> 8));
	bg = (0xff000000 | 
	      ((pCursor->backRed & 0xff00) << 8) |
	      (pCursor->backGreen & 0xff00) |
	      (pCursor->backBlue >> 8));
	for (y = 0; y < height; y++)
	{
	    for (x = 0; x < width; x++)
	    {
		if (GetBit (mskLine, x))
		{
		    if (GetBit (srcLine, x))
			*image++ = fg;
		    else
			*image++ = bg;
		}
		else
		    *image++ = 0;
	    }
	    srcLine += stride;
	    mskLine += stride;
	}
    }
}

int
ProcXFixesGetCursorImage (ClientPtr client)
{
/*    REQUEST(xXFixesGetCursorImageReq); */
    xXFixesGetCursorImageReply	*rep;
    CursorPtr			pCursor;
    CARD32			*image;
    int				npixels, width, height, rc, x, y;

    REQUEST_SIZE_MATCH(xXFixesGetCursorImageReq);
    pCursor = CursorCurrent[PickPointer(client)->id];
    if (!pCursor)
	return BadCursor;
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, pCursor->id, RT_CURSOR,
		  pCursor, RT_NONE, NULL, DixReadAccess);
    if (rc != Success)
	return rc;
    GetSpritePosition (PickPointer(client), &x, &y);
    width = pCursor->bits->width;
    height = pCursor->bits->height;
    npixels = width * height;
    rep = malloc(sizeof (xXFixesGetCursorImageReply) +
		  npixels * sizeof (CARD32));
    if (!rep)
	return BadAlloc;

    rep->type = X_Reply;
    rep->sequenceNumber = client->sequence;
    rep->length = npixels;
    rep->width = width;
    rep->height = height;
    rep->x = x;
    rep->y = y;
    rep->xhot = pCursor->bits->xhot;
    rep->yhot = pCursor->bits->yhot; 
    rep->cursorSerial = pCursor->serialNumber;

    image = (CARD32 *) (rep + 1);
    CopyCursorToImage (pCursor, image);
    if (client->swapped)
    {
	int n;
	swaps (&rep->sequenceNumber, n);
	swapl (&rep->length, n);
	swaps (&rep->x, n);
	swaps (&rep->y, n);
	swaps (&rep->width, n);
	swaps (&rep->height, n);
	swaps (&rep->xhot, n);
	swaps (&rep->yhot, n);
	swapl (&rep->cursorSerial, n);
	SwapLongs (image, npixels);
    }
    WriteToClient(client, sizeof (xXFixesGetCursorImageReply) +
			 (npixels << 2), (char *) rep);
    free(rep);
    return Success;
}

int
SProcXFixesGetCursorImage (ClientPtr client)
{
    int n;
    REQUEST(xXFixesGetCursorImageReq);
    swaps (&stuff->length, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetCursorName (ClientPtr client)
{
    CursorPtr pCursor;
    char *tchar;
    REQUEST(xXFixesSetCursorNameReq);
    Atom atom;

    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
    tchar = (char *) &stuff[1];
    atom = MakeAtom (tchar, stuff->nbytes, TRUE);
    if (atom == BAD_RESOURCE)
	return BadAlloc;
    
    pCursor->name = atom;
    return Success;
}

int
SProcXFixesSetCursorName (ClientPtr client)
{
    int n;
    REQUEST(xXFixesSetCursorNameReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
    swapl (&stuff->cursor, n);
    swaps (&stuff->nbytes, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesGetCursorName (ClientPtr client)
{
    CursorPtr			pCursor;
    xXFixesGetCursorNameReply	reply;
    REQUEST(xXFixesGetCursorNameReq);
    const char *str;
    int len;

    REQUEST_SIZE_MATCH(xXFixesGetCursorNameReq);
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixGetAttrAccess);
    if (pCursor->name)
	str = NameForAtom (pCursor->name);
    else
	str = "";
    len = strlen (str);
    
    reply.type = X_Reply;
    reply.length = bytes_to_int32(len);
    reply.sequenceNumber = client->sequence;
    reply.atom = pCursor->name;
    reply.nbytes = len;
    if (client->swapped)
    {
	int n;
	swaps (&reply.sequenceNumber, n);
	swapl (&reply.length, n);
	swapl (&reply.atom, n);
	swaps (&reply.nbytes, n);
    }
    WriteReplyToClient(client, sizeof(xXFixesGetCursorNameReply), &reply);
    WriteToClient(client, len, str);
    
    return Success;
}

int
SProcXFixesGetCursorName (ClientPtr client)
{
    int n;
    REQUEST(xXFixesGetCursorNameReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesGetCursorNameReq);
    swapl (&stuff->cursor, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesGetCursorImageAndName (ClientPtr client)
{
/*    REQUEST(xXFixesGetCursorImageAndNameReq); */
    xXFixesGetCursorImageAndNameReply	*rep;
    CursorPtr			pCursor;
    CARD32			*image;
    int				npixels;
    const char			*name;
    int				nbytes, nbytesRound;
    int				width, height;
    int				rc, x, y;

    REQUEST_SIZE_MATCH(xXFixesGetCursorImageAndNameReq);
    pCursor = CursorCurrent[PickPointer(client)->id];
    if (!pCursor)
	return BadCursor;
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, pCursor->id, RT_CURSOR,
		  pCursor, RT_NONE, NULL, DixReadAccess|DixGetAttrAccess);
    if (rc != Success)
	return rc;
    GetSpritePosition (PickPointer(client), &x, &y);
    width = pCursor->bits->width;
    height = pCursor->bits->height;
    npixels = width * height;
    name = pCursor->name ? NameForAtom (pCursor->name) : "";
    nbytes = strlen (name);
    nbytesRound = pad_to_int32(nbytes);
    rep = malloc(sizeof (xXFixesGetCursorImageAndNameReply) +
		  npixels * sizeof (CARD32) + nbytesRound);
    if (!rep)
	return BadAlloc;

    rep->type = X_Reply;
    rep->sequenceNumber = client->sequence;
    rep->length = npixels + bytes_to_int32(nbytesRound);
    rep->width = width;
    rep->height = height;
    rep->x = x;
    rep->y = y;
    rep->xhot = pCursor->bits->xhot;
    rep->yhot = pCursor->bits->yhot; 
    rep->cursorSerial = pCursor->serialNumber;
    rep->cursorName = pCursor->name;
    rep->nbytes = nbytes;

    image = (CARD32 *) (rep + 1);
    CopyCursorToImage (pCursor, image);
    memcpy ((image + npixels), name, nbytes);
    if (client->swapped)
    {
	int n;
	swaps (&rep->sequenceNumber, n);
	swapl (&rep->length, n);
	swaps (&rep->x, n);
	swaps (&rep->y, n);
	swaps (&rep->width, n);
	swaps (&rep->height, n);
	swaps (&rep->xhot, n);
	swaps (&rep->yhot, n);
	swapl (&rep->cursorSerial, n);
	swapl (&rep->cursorName, n);
	swaps (&rep->nbytes, n);
	SwapLongs (image, npixels);
    }
    WriteToClient(client, sizeof (xXFixesGetCursorImageAndNameReply) +
			 (npixels << 2) + nbytesRound, (char *) rep);
    free(rep);
    return Success;
}

int
SProcXFixesGetCursorImageAndName (ClientPtr client)
{
    int n;
    REQUEST(xXFixesGetCursorImageAndNameReq);
    swaps (&stuff->length, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

/*
 * Find every cursor reference in the system, ask testCursor
 * whether it should be replaced with a reference to pCursor.
 */

typedef Bool (*TestCursorFunc) (CursorPtr pOld, pointer closure);

typedef struct {
    RESTYPE type;
    TestCursorFunc testCursor;
    CursorPtr pNew;
    pointer closure;
} ReplaceCursorLookupRec, *ReplaceCursorLookupPtr;

static const RESTYPE    CursorRestypes[] = {
    RT_WINDOW, RT_PASSIVEGRAB, RT_CURSOR
};

#define NUM_CURSOR_RESTYPES (sizeof (CursorRestypes) / sizeof (CursorRestypes[0]))

static Bool
ReplaceCursorLookup (pointer value, XID id, pointer closure)
{
    ReplaceCursorLookupPtr  rcl = (ReplaceCursorLookupPtr) closure;
    WindowPtr		    pWin;
    GrabPtr		    pGrab;
    CursorPtr		    pCursor = 0, *pCursorRef = 0;
    XID			    cursor = 0;

    switch (rcl->type) {
    case RT_WINDOW:
	pWin = (WindowPtr) value;
	if (pWin->optional)
	{
	    pCursorRef = &pWin->optional->cursor;
	    pCursor = *pCursorRef;
	}
	break;
    case RT_PASSIVEGRAB:
	pGrab = (GrabPtr) value;
	pCursorRef = &pGrab->cursor;
	pCursor = *pCursorRef;
	break;
    case RT_CURSOR:
	pCursorRef = 0;
	pCursor = (CursorPtr) value;
	cursor = id;
	break;
    }
    if (pCursor && pCursor != rcl->pNew)
    {
	if ((*rcl->testCursor) (pCursor, rcl->closure))
	{
	    rcl->pNew->refcnt++;
	    /* either redirect reference or update resource database */
	    if (pCursorRef)
		*pCursorRef = rcl->pNew;
	    else
		ChangeResourceValue (id, RT_CURSOR, rcl->pNew);
	    FreeCursor (pCursor, cursor);
	}
    }
    return FALSE;   /* keep walking */
}

static void
ReplaceCursor (CursorPtr pCursor,
	       TestCursorFunc testCursor,
	       pointer closure)
{
    int	clientIndex;
    int resIndex;
    ReplaceCursorLookupRec  rcl;
    
    /* 
     * Cursors exist only in the resource database, windows and grabs.
     * All of these are always pointed at by the resource database.  Walk
     * the whole thing looking for cursors
     */
    rcl.testCursor = testCursor;
    rcl.pNew = pCursor;
    rcl.closure = closure;

    /* for each client */
    for (clientIndex = 0; clientIndex < currentMaxClients; clientIndex++)
    {
	if (!clients[clientIndex])
	    continue;
	for (resIndex = 0; resIndex < NUM_CURSOR_RESTYPES; resIndex++)
	{
	    rcl.type = CursorRestypes[resIndex];
	    /*
	     * This function walks the entire client resource database
	     */
	    LookupClientResourceComplex (clients[clientIndex], 
					 rcl.type, 
					 ReplaceCursorLookup,
					 (pointer) &rcl);
	}
    }
    /* this "knows" that WindowHasNewCursor doesn't depend on it's argument */
    WindowHasNewCursor (screenInfo.screens[0]->root);
}

static Bool 
TestForCursor (CursorPtr pCursor, pointer closure)
{
    return (pCursor == (CursorPtr) closure);
}

int
ProcXFixesChangeCursor (ClientPtr client)
{
    CursorPtr	pSource, pDestination;
    REQUEST(xXFixesChangeCursorReq);

    REQUEST_SIZE_MATCH(xXFixesChangeCursorReq);
    VERIFY_CURSOR (pSource, stuff->source, client,
		   DixReadAccess|DixGetAttrAccess);
    VERIFY_CURSOR (pDestination, stuff->destination, client,
		   DixWriteAccess|DixSetAttrAccess);

    ReplaceCursor (pSource, TestForCursor, (pointer) pDestination);
    return Success;
}

int
SProcXFixesChangeCursor (ClientPtr client)
{
    int n;
    REQUEST(xXFixesChangeCursorReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesChangeCursorReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static Bool
TestForCursorName (CursorPtr pCursor, pointer closure)
{
    Atom *pName = closure;
    return pCursor->name == *pName;
}

int
ProcXFixesChangeCursorByName (ClientPtr client)
{
    CursorPtr	pSource;
    Atom	name;
    char	*tchar;
    REQUEST(xXFixesChangeCursorByNameReq);

    REQUEST_FIXED_SIZE(xXFixesChangeCursorByNameReq, stuff->nbytes);
    VERIFY_CURSOR(pSource, stuff->source, client,
		  DixReadAccess|DixGetAttrAccess);
    tchar = (char *) &stuff[1];
    name = MakeAtom (tchar, stuff->nbytes, FALSE);
    if (name)
	ReplaceCursor (pSource, TestForCursorName, &name);
    return Success;
}

int
SProcXFixesChangeCursorByName (ClientPtr client)
{
    int n;
    REQUEST(xXFixesChangeCursorByNameReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE (xXFixesChangeCursorByNameReq);
    swapl (&stuff->source, n);
    swaps (&stuff->nbytes, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

/*
 * Routines for manipulating the per-screen hide counts list.
 * This list indicates which clients have requested cursor hiding 
 * for that screen.
 */

/* Return the screen's hide-counts list element for the given client */
static CursorHideCountPtr
findCursorHideCount (ClientPtr pClient, ScreenPtr pScreen) 
{
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc;

    for (pChc = cs->pCursorHideCounts; pChc != NULL; pChc = pChc->pNext) {
	if (pChc->pClient == pClient) {
	    return pChc;
	}
    }

    return NULL;           
}

static int
createCursorHideCount (ClientPtr pClient, ScreenPtr pScreen)
{
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc;

    pChc = (CursorHideCountPtr) malloc(sizeof(CursorHideCountRec));
    if (pChc == NULL) {
	return BadAlloc;
    }
    pChc->pClient = pClient;
    pChc->pScreen = pScreen;
    pChc->hideCount = 1;
    pChc->resource = FakeClientID(pClient->index);
    pChc->pNext = cs->pCursorHideCounts;
    cs->pCursorHideCounts = pChc;
    
    /* 
     * Create a resource for this element so it can be deleted
     * when the client goes away.
     */
    if (!AddResource (pChc->resource, CursorHideCountType, 
		      (pointer) pChc)) {
	free(pChc);
	return BadAlloc;
    }

    return Success;
}

/* 
 * Delete the given hide-counts list element from its screen list.
 */
static void
deleteCursorHideCount (CursorHideCountPtr pChcToDel, ScreenPtr pScreen)
{
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc, pNext;
    CursorHideCountPtr pChcLast = NULL;

    pChc = cs->pCursorHideCounts;
    while (pChc != NULL) {
	pNext = pChc->pNext;
	if (pChc == pChcToDel) {
	    free(pChc);
	    if (pChcLast == NULL) {
		cs->pCursorHideCounts = pNext;
	    } else {
		pChcLast->pNext = pNext;
	    }
	    return;
	}
	pChcLast = pChc;
	pChc = pNext;
    }
}

/* 
 * Delete all the hide-counts list elements for this screen.
 */
static void
deleteCursorHideCountsForScreen (ScreenPtr pScreen)
{
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc, pTmp;

    pChc = cs->pCursorHideCounts;
    while (pChc != NULL) {
	pTmp = pChc->pNext;
	FreeResource(pChc->resource, 0);
	pChc = pTmp;
    }
    cs->pCursorHideCounts = NULL;   
}

int 
ProcXFixesHideCursor (ClientPtr client) 
{
    WindowPtr pWin;
    CursorHideCountPtr pChc;
    REQUEST(xXFixesHideCursorReq);
    int ret;

    REQUEST_SIZE_MATCH (xXFixesHideCursorReq);

    ret = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			    client, DixGetAttrAccess);
    if (ret != Success) {
	client->errorValue = stuff->window;
	return ret;
    }

    /* 
     * Has client hidden the cursor before on this screen? 
     * If so, just increment the count. 
     */

    pChc = findCursorHideCount(client, pWin->drawable.pScreen);
    if (pChc != NULL) {
	pChc->hideCount++;
	return Success;
    }

    /* 
     * This is the first time this client has hid the cursor 
     * for this screen.
     */
    ret = XaceHook(XACE_SCREEN_ACCESS, client, pWin->drawable.pScreen,
		   DixHideAccess);
    if (ret != Success)
	return ret;

    ret = createCursorHideCount(client, pWin->drawable.pScreen);

    if (ret == Success) {
	DeviceIntPtr dev;
	for (dev = inputInfo.devices; dev; dev = dev->next)
	{
	    if (IsMaster(dev) && IsPointerDevice(dev))
		CursorDisplayCursor(dev, pWin->drawable.pScreen, CursorCurrent[dev->id]);
	}
    }

    return ret;
}

int 
SProcXFixesHideCursor (ClientPtr client) 
{
    int n;
    REQUEST(xXFixesHideCursorReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesHideCursorReq);
    swapl (&stuff->window, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int 
ProcXFixesShowCursor (ClientPtr client) 
{
    WindowPtr pWin;
    CursorHideCountPtr pChc;
    int rc;
    REQUEST(xXFixesShowCursorReq);

    REQUEST_SIZE_MATCH (xXFixesShowCursorReq);

    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			   client, DixGetAttrAccess);
    if (rc != Success) {
	client->errorValue = stuff->window;
	return rc;
    }

    /* 
     * Has client hidden the cursor on this screen?
     * If not, generate an error.
     */
    pChc = findCursorHideCount(client, pWin->drawable.pScreen);
    if (pChc == NULL) {
	return BadMatch;
    }

    rc = XaceHook(XACE_SCREEN_ACCESS, client, pWin->drawable.pScreen,
		  DixShowAccess);
    if (rc != Success)
	return rc;

    pChc->hideCount--;
    if (pChc->hideCount <= 0) {
	FreeResource(pChc->resource, 0);
    }

    return Success;
}

int 
SProcXFixesShowCursor (ClientPtr client) 
{
    int n;
    REQUEST(xXFixesShowCursorReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesShowCursorReq);
    swapl (&stuff->window, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int
CursorFreeClient (pointer data, XID id)
{
    CursorEventPtr	old = (CursorEventPtr) data;
    CursorEventPtr	*prev, e;
    
    for (prev = &cursorEvents; (e = *prev); prev = &e->next)
    {
	if (e == old)
	{
	    *prev = e->next;
	    free(e);
	    break;
	}
    }
    return 1;
}

static int
CursorFreeHideCount (pointer data, XID id)
{
    CursorHideCountPtr pChc = (CursorHideCountPtr) data;
    ScreenPtr pScreen = pChc->pScreen;
    DeviceIntPtr dev;

    deleteCursorHideCount(pChc, pChc->pScreen);
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
        if (IsMaster(dev) && IsPointerDevice(dev))
            CursorDisplayCursor(dev, pScreen, CursorCurrent[dev->id]);
    }

    return 1;
}

static int
CursorFreeWindow (pointer data, XID id)
{
    WindowPtr		pWindow = (WindowPtr) data;
    CursorEventPtr	e, next;

    for (e = cursorEvents; e; e = next)
    {
	next = e->next;
	if (e->pWindow == pWindow)
	{
	    FreeResource (e->clientResource, 0);
	}
    }
    return 1;
}

static BOOL
barrier_is_horizontal(const struct PointerBarrier *barrier)
{
    return barrier->y1 == barrier->y2;
}

static BOOL
barrier_is_vertical(const struct PointerBarrier *barrier)
{
    return barrier->x1 == barrier->x2;
}

/**
 * @return The set of barrier movement directions the movement vector
 * x1/y1 → x2/y2 represents.
 */
int
barrier_get_direction(int x1, int y1, int x2, int y2)
{
    int direction = 0;

    /* which way are we trying to go */
    if (x2 > x1)
	direction |= BarrierPositiveX;
    if (x2 < x1)
	direction |= BarrierNegativeX;
    if (y2 > y1)
	direction |= BarrierPositiveY;
    if (y2 < y1)
	direction |= BarrierNegativeY;

    return direction;
}

/**
 * Test if the barrier may block movement in the direction defined by
 * x1/y1 → x2/y2. This function only tests whether the directions could be
 * blocked, it does not test if the barrier actually blocks the movement.
 *
 * @return TRUE if the barrier blocks the direction of movement or FALSE
 * otherwise.
 */
BOOL
barrier_is_blocking_direction(const struct PointerBarrier *barrier, int direction)
{
    /* Barriers define which way is ok, not which way is blocking */
    return (barrier->directions & direction) != direction;
}

/**
 * Test if the movement vector x1/y1 → x2/y2 is intersecting with the
 * barrier. A movement vector with the startpoint or endpoint adjacent to
 * the barrier itself counts as intersecting.
 *
 * @param x1 X start coordinate of movement vector
 * @param y1 Y start coordinate of movement vector
 * @param x2 X end coordinate of movement vector
 * @param y2 Y end coordinate of movement vector
 * @param[out] distance The distance between the start point and the
 * intersection with the barrier (if applicable).
 * @return TRUE if the barrier intersects with the given vector
 */
BOOL
barrier_is_blocking(const struct PointerBarrier *barrier,
		    int x1, int y1, int x2, int y2,
		    double *distance)
{
    BOOL rc = FALSE;
    float ua, ub, ud;
    int dir = barrier_get_direction(x1, y1, x2, y2);

    /* Algorithm below doesn't handle edge cases well, hence the extra
     * checks. */
    if (barrier_is_vertical(barrier)) {
	/* handle immediate barrier adjacency, moving away */
	if (dir & BarrierPositiveX && x1 == barrier->x1)
	    return FALSE;
	if (dir & BarrierNegativeX && x1 == (barrier->x1 - 1))
	    return FALSE;
	/* startpoint adjacent to barrier, moving towards -> block */
	if (x1 == barrier->x1 && y1 >= barrier->y1 && y1 <= barrier->y2) {
	    *distance = 0;
	    return TRUE;
	}
    } else {
	/* handle immediate barrier adjacency, moving away */
	if (dir & BarrierPositiveY && y1 == barrier->y1)
	    return FALSE;
	if (dir & BarrierNegativeY && y1 == (barrier->y1 - 1))
	    return FALSE;
	/* startpoint adjacent to barrier, moving towards -> block */
	if (y1 == barrier->y1 && x1 >= barrier->x1 && x1 <= barrier->x2) {
	    *distance = 0;
	    return TRUE;
        }
    }

    /* not an edge case, compute distance */
    ua = 0;
    ud = (barrier->y2 - barrier->y1) * (x2 - x1) - (barrier->x2 - barrier->x1) * (y2 - y1);
    if (ud != 0) {
	ua = ((barrier->x2 - barrier->x1) * (y1 - barrier->y1) -
	     (barrier->y2 - barrier->y1) * (x1 - barrier->x1)) / ud;
	ub = ((x2 - x1) * (y1 - barrier->y1) -
	     (y2 - y1) * (x1 - barrier->x1)) / ud;
	if (ua < 0 || ua > 1 || ub < 0 || ub > 1)
	    ua = 0;
    }

    if (ua > 0 && ua <= 1)
    {
	double ix = barrier->x1 + ua * (barrier->x2 - barrier->x1);
	double iy = barrier->y1 + ua * (barrier->y2 - barrier->y1);

	*distance = sqrt(pow(x1 - ix, 2) + pow(y1 - iy, 2));
	rc = TRUE;
    }

    return rc;
}

/**
 * Find the nearest barrier that is blocking movement from x1/y1 to x2/y2.
 *
 * @param dir Only barriers blocking movement in direction dir are checked
 * @param x1 X start coordinate of movement vector
 * @param y1 Y start coordinate of movement vector
 * @param x2 X end coordinate of movement vector
 * @param y2 Y end coordinate of movement vector
 * @return The barrier nearest to the movement origin that blocks this movement.
 */
static struct PointerBarrier*
barrier_find_nearest(CursorScreenPtr cs, int dir,
		     int x1, int y1, int x2, int y2)
{
    struct PointerBarrierClient *c;
    struct PointerBarrier *nearest = NULL;
    double min_distance = INT_MAX; /* can't get higher than that in X anyway */

    list_for_each_entry(c, &cs->barriers, entry) {
	struct PointerBarrier *b = &c->barrier;
	double distance;

	if (!barrier_is_blocking_direction(b, dir))
	    continue;

	if (barrier_is_blocking(b, x1, y1, x2, y2, &distance))
	{
	    if (min_distance > distance)
	    {
		min_distance = distance;
		nearest = b;
	    }
	}
    }

    return nearest;
}

/**
 * Clamp to the given barrier given the movement direction specified in dir.
 *
 * @param barrier The barrier to clamp to
 * @param dir The movement direction
 * @param[out] x The clamped x coordinate.
 * @param[out] y The clamped x coordinate.
 */
void
barrier_clamp_to_barrier(struct PointerBarrier *barrier, int dir, int *x, int *y)
{
    if (barrier_is_vertical(barrier))
    {
	if ((dir & BarrierNegativeX) & ~barrier->directions)
	    *x = barrier->x1;
	if ((dir & BarrierPositiveX) & ~barrier->directions)
	    *x = barrier->x1 - 1;
    }
    if (barrier_is_horizontal(barrier))
    {
	if ((dir & BarrierNegativeY) & ~barrier->directions)
	    *y = barrier->y1;
	if ((dir & BarrierPositiveY) & ~barrier->directions)
	    *y = barrier->y1 - 1;
    }
}

static void
CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode, int *x, int *y)
{
    CursorScreenPtr cs = GetCursorScreen(screen);

    if (!list_is_empty(&cs->barriers) && !IsFloating(dev) && mode == Relative) {
	int ox, oy;
	int dir;
	struct PointerBarrier *nearest = NULL;

	/* where are we coming from */
	miPointerGetPosition(dev, &ox, &oy);

	/* How this works:
	 * Given the origin and the movement vector, get the nearest barrier
	 * to the origin that is blocking the movement.
	 * Clamp to that barrier.
	 * Then, check from the clamped intersection to the original
	 * destination, again finding the nearest barrier and clamping.
	 */
	dir = barrier_get_direction(ox, oy, *x, *y);

	nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
	if (nearest) {
	    barrier_clamp_to_barrier(nearest, dir, x, y);

	    if (barrier_is_vertical(nearest)) {
		dir &= ~(BarrierNegativeX | BarrierPositiveX);
		ox = *x;
	    } else if (barrier_is_horizontal(nearest)) {
		dir &= ~(BarrierNegativeY | BarrierPositiveY);
		oy = *y;
	    }

	    nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
	    if (nearest) {
		barrier_clamp_to_barrier(nearest, dir, x, y);
	    }
	}
    }

    if (cs->ConstrainCursorHarder) {
	screen->ConstrainCursorHarder = cs->ConstrainCursorHarder;
	screen->ConstrainCursorHarder(dev, screen, mode, x, y);
	screen->ConstrainCursorHarder = CursorConstrainCursorHarder;
    }
}

static struct PointerBarrierClient *
CreatePointerBarrierClient(ScreenPtr screen, ClientPtr client,
			   xXFixesCreatePointerBarrierReq *stuff)
{
    CursorScreenPtr cs = GetCursorScreen(screen);
    struct PointerBarrierClient *ret = malloc(sizeof(*ret));

    if (ret) {
	ret->screen = screen;
	ret->barrier.x1 = min(stuff->x1, stuff->x2);
	ret->barrier.x2 = max(stuff->x1, stuff->x2);
	ret->barrier.y1 = min(stuff->y1, stuff->y2);
	ret->barrier.y2 = max(stuff->y1, stuff->y2);
	ret->barrier.directions = stuff->directions & 0x0f;
	if (barrier_is_horizontal(&ret->barrier))
	    ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
	if (barrier_is_vertical(&ret->barrier))
	    ret->barrier.directions &= ~(BarrierPositiveY | BarrierNegativeY);
	list_add(&ret->entry, &cs->barriers);
    }

    return ret;
}

int
ProcXFixesCreatePointerBarrier (ClientPtr client)
{
    int err;
    WindowPtr pWin;
    struct PointerBarrierClient *barrier;
    struct PointerBarrier b;
    REQUEST (xXFixesCreatePointerBarrierReq);

    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
    LEGAL_NEW_RESOURCE(stuff->barrier, client);

    err = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (err != Success) {
	client->errorValue = stuff->window;
	return err;
    }

    /* This sure does need fixing. */
    if (stuff->num_devices)
	return BadImplementation;

    b.x1 = stuff->x1;
    b.x2 = stuff->x2;
    b.y1 = stuff->y1;
    b.y2 = stuff->y2;

    if (!barrier_is_horizontal(&b) && !barrier_is_vertical(&b))
	return BadValue;

    /* no 0-sized barriers */
    if (barrier_is_horizontal(&b) && barrier_is_vertical(&b))
	return BadValue;

    if (!(barrier = CreatePointerBarrierClient(pWin->drawable.pScreen,
					       client, stuff)))
	return BadAlloc;

    if (!AddResource(stuff->barrier, PointerBarrierType, &barrier->barrier))
	return BadAlloc;

    return Success;
}

int
SProcXFixesCreatePointerBarrier (ClientPtr client)
{
    int n;
    REQUEST(xXFixesCreatePointerBarrierReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
    swapl(&stuff->barrier, n);
    swapl(&stuff->window, n);
    swaps(&stuff->x1, n);
    swaps(&stuff->y1, n);
    swaps(&stuff->x2, n);
    swaps(&stuff->y2, n);
    swapl(&stuff->directions, n);
    return ProcXFixesVector[stuff->xfixesReqType](client);
}

static int
CursorFreeBarrier(void *data, XID id)
{
    struct PointerBarrierClient *b = NULL, *barrier;
    ScreenPtr screen;
    CursorScreenPtr cs;

    barrier = container_of(data, struct PointerBarrierClient, barrier);
    screen = barrier->screen;
    cs = GetCursorScreen(screen);

    /* find and unlink from the screen private */
    list_for_each_entry(b, &cs->barriers, entry) {
	if (b == barrier) {
	    list_del(&b->entry);
	    break;
	}
    }

    free(barrier);
    return Success;
}

int
ProcXFixesDestroyPointerBarrier (ClientPtr client)
{
    int err;
    void *barrier;
    REQUEST (xXFixesDestroyPointerBarrierReq);

    REQUEST_SIZE_MATCH(xXFixesDestroyPointerBarrierReq);

    err = dixLookupResourceByType((void **)&barrier, stuff->barrier,
				  PointerBarrierType, client,
				  DixDestroyAccess);
    if (err != Success) {
	client->errorValue = stuff->barrier;
	return err;
    }

    FreeResource(stuff->barrier, RT_NONE);
    return Success;
}

int
SProcXFixesDestroyPointerBarrier (ClientPtr client)
{
    int n;
    REQUEST(xXFixesDestroyPointerBarrierReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesDestroyPointerBarrierReq);
    swapl(&stuff->barrier, n);
    return ProcXFixesVector[stuff->xfixesReqType](client);
}

Bool
XFixesCursorInit (void)
{
    int	i;

    if (party_like_its_1989)
	CursorVisible = EnableCursor;
    
    if (!dixRegisterPrivateKey(&CursorScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ScreenPtr	pScreen = screenInfo.screens[i];
	CursorScreenPtr	cs;

	cs = (CursorScreenPtr) calloc(1, sizeof (CursorScreenRec));
	if (!cs)
	    return FALSE;
	list_init(&cs->barriers);
	Wrap (cs, pScreen, CloseScreen, CursorCloseScreen);
	Wrap (cs, pScreen, DisplayCursor, CursorDisplayCursor);
	Wrap (cs, pScreen, ConstrainCursorHarder, CursorConstrainCursorHarder);
	cs->pCursorHideCounts = NULL;
	SetCursorScreen (pScreen, cs);
    }
    CursorClientType = CreateNewResourceType(CursorFreeClient,
					     "XFixesCursorClient");
    CursorHideCountType = CreateNewResourceType(CursorFreeHideCount,
						"XFixesCursorHideCount");
    CursorWindowType = CreateNewResourceType(CursorFreeWindow,
					     "XFixesCursorWindow");
    PointerBarrierType = CreateNewResourceType(CursorFreeBarrier,
					      "XFixesPointerBarrier");

    return CursorClientType && CursorHideCountType && CursorWindowType &&
	   PointerBarrierType;
}

noinst_LTLIBRARIES = libxfixes.la

AM_CFLAGS = $(DIX_CFLAGS)

if XORG
sdk_HEADERS = xfixes.h
endif

libxfixes_la_SOURCES = 	\
	cursor.c	\
	region.c	\
	saveset.c	\
	select.c	\
	xfixes.c	\
	xfixes.h	\
	xfixesint.h
/*
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "scrnintstr.h"
#include <picturestr.h>
extern int RenderErrBase;
#include <regionstr.h>
#include <gcstruct.h>
#include <window.h>

RESTYPE RegionResType;

static int
RegionResFree (pointer data, XID id)
{
    RegionPtr    pRegion = (RegionPtr) data;

    RegionDestroy(pRegion);
    return Success;
}

RegionPtr
XFixesRegionCopy (RegionPtr pRegion)
{
    RegionPtr   pNew = RegionCreate(RegionExtents(pRegion),
				      RegionNumRects(pRegion));
    if (!pNew)
	return 0;
    if (!RegionCopy(pNew, pRegion))
    {
	RegionDestroy(pNew);
	return 0;
    }
    return pNew;
}

Bool
XFixesRegionInit (void)
{
    RegionResType = CreateNewResourceType(RegionResFree, "XFixesRegion");

    return RegionResType != 0;
}

int
ProcXFixesCreateRegion (ClientPtr client)
{
    int		things;
    RegionPtr	pRegion;
    REQUEST (xXFixesCreateRegionReq);
    
    REQUEST_AT_LEAST_SIZE(xXFixesCreateRegionReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);
    
    things = (client->req_len << 2) - sizeof (xXFixesCreateRegionReq);
    if (things & 4)
	return BadLength;
    things >>= 3;

    pRegion = RegionFromRects(things, (xRectangle *) (stuff + 1), CT_UNSORTED);
    if (!pRegion)
	return BadAlloc;
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegion (ClientPtr client)
{
    register int n;
    REQUEST(xXFixesCreateRegionReq);
    
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXFixesCreateRegionReq);
    swapl(&stuff->region, n);
    SwapRestS(stuff);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromBitmap (ClientPtr client)
{
    RegionPtr	pRegion;
    PixmapPtr	pPixmap;
    int rc;
    REQUEST (xXFixesCreateRegionFromBitmapReq);

    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromBitmapReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);

    rc = dixLookupResourceByType((pointer *)&pPixmap, stuff->bitmap, RT_PIXMAP,
			   client, DixReadAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->bitmap;
	return rc;
    }
    if (pPixmap->drawable.depth != 1)
	return BadMatch;

    pRegion = BitmapToRegion(pPixmap->drawable.pScreen, pPixmap);

    if (!pRegion)
	return BadAlloc;
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegionFromBitmap (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCreateRegionFromBitmapReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromBitmapReq);
    swapl(&stuff->region, n);
    swapl(&stuff->bitmap, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromWindow (ClientPtr client)
{
    RegionPtr	pRegion;
    Bool	copy = TRUE;
    WindowPtr	pWin;
    int rc;
    REQUEST (xXFixesCreateRegionFromWindowReq);
    
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromWindowReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			   client, DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->window;
	return rc;
    }
    switch (stuff->kind) {
    case WindowRegionBounding:
	pRegion = wBoundingShape(pWin);
	if (!pRegion)
	{
	    pRegion = CreateBoundingShape (pWin);
	    copy = FALSE;
	}
	break;
    case WindowRegionClip:
	pRegion = wClipShape(pWin);
	if (!pRegion)
	{
	    pRegion = CreateClipShape (pWin);
	    copy = FALSE;
	}
	break;
    default:
	client->errorValue = stuff->kind;
	return BadValue;
    }
    if (copy && pRegion)
	pRegion = XFixesRegionCopy (pRegion);
    if (!pRegion)
	return BadAlloc;
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegionFromWindow (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCreateRegionFromWindowReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromWindowReq);
    swapl(&stuff->region, n);
    swapl(&stuff->window, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromGC (ClientPtr client)
{
    RegionPtr	pRegion, pClip;
    GCPtr	pGC;
    int 	rc;
    REQUEST (xXFixesCreateRegionFromGCReq);

    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromGCReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);

    rc = dixLookupGC(&pGC, stuff->gc, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    
    switch (pGC->clientClipType) {
    case CT_PIXMAP:
	pRegion = BitmapToRegion(pGC->pScreen, (PixmapPtr) pGC->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
    case CT_REGION:
	pClip = (RegionPtr) pGC->clientClip;
	pRegion = XFixesRegionCopy (pClip);
	if (!pRegion)
	    return BadAlloc;
	break;
    default:
	return BadImplementation;   /* assume sane server bits */
    }
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegionFromGC (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCreateRegionFromGCReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromGCReq);
    swapl(&stuff->region, n);
    swapl(&stuff->gc, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromPicture (ClientPtr client)
{
    RegionPtr	pRegion;
    PicturePtr	pPicture;
    REQUEST (xXFixesCreateRegionFromPictureReq);

    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromPictureReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);

    VERIFY_PICTURE(pPicture, stuff->picture, client, DixGetAttrAccess);
    
    switch (pPicture->clientClipType) {
    case CT_PIXMAP:
	pRegion = BitmapToRegion(pPicture->pDrawable->pScreen,
				   (PixmapPtr) pPicture->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
    case CT_REGION:
	pRegion = XFixesRegionCopy ((RegionPtr) pPicture->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
    default:
	return BadImplementation;   /* assume sane server bits */
    }
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
    return Success;
}

int
SProcXFixesCreateRegionFromPicture (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCreateRegionFromPictureReq);

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromPictureReq);
    swapl(&stuff->region, n);
    swapl(&stuff->picture, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesDestroyRegion (ClientPtr client)
{
    REQUEST (xXFixesDestroyRegionReq);
    RegionPtr	pRegion;

    REQUEST_SIZE_MATCH(xXFixesDestroyRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
    FreeResource (stuff->region, RT_NONE);
    return Success;
}

int
SProcXFixesDestroyRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesDestroyRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesDestroyRegionReq);
    swapl (&stuff->region, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetRegion (ClientPtr client)
{
    int		things;
    RegionPtr	pRegion, pNew;
    REQUEST (xXFixesSetRegionReq);

    REQUEST_AT_LEAST_SIZE(xXFixesSetRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
    
    things = (client->req_len << 2) - sizeof (xXFixesCreateRegionReq);
    if (things & 4)
	return BadLength;
    things >>= 3;

    pNew = RegionFromRects(things, (xRectangle *) (stuff + 1), CT_UNSORTED);
    if (!pNew)
	return BadAlloc;
    if (!RegionCopy(pRegion, pNew))
    {
	RegionDestroy(pNew);
	return BadAlloc;
    }
    RegionDestroy(pNew);
    return Success;
}

int
SProcXFixesSetRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesSetRegionReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXFixesSetRegionReq);
    swapl (&stuff->region, n);
    SwapRestS(stuff);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCopyRegion (ClientPtr client)
{
    RegionPtr	pSource, pDestination;
    REQUEST (xXFixesCopyRegionReq);
    
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
    
    if (!RegionCopy(pDestination, pSource))
	return BadAlloc;

    return Success;
}

int
SProcXFixesCopyRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCopyRegionReq);

    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXFixesCopyRegionReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCombineRegion (ClientPtr client)
{
    RegionPtr	pSource1, pSource2, pDestination;
    REQUEST (xXFixesCombineRegionReq);

    REQUEST_SIZE_MATCH (xXFixesCombineRegionReq);
    VERIFY_REGION(pSource1, stuff->source1, client, DixReadAccess);
    VERIFY_REGION(pSource2, stuff->source2, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
    
    switch (stuff->xfixesReqType) {
    case X_XFixesUnionRegion:
	if (!RegionUnion(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
    case X_XFixesIntersectRegion:
	if (!RegionIntersect(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
    case X_XFixesSubtractRegion:
	if (!RegionSubtract(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
    }
    
    return Success;
}

int
SProcXFixesCombineRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesCombineRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCombineRegionReq);
    swapl (&stuff->source1, n);
    swapl (&stuff->source2, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesInvertRegion (ClientPtr client)
{
    RegionPtr	pSource, pDestination;
    BoxRec	bounds;
    REQUEST(xXFixesInvertRegionReq);

    REQUEST_SIZE_MATCH(xXFixesInvertRegionReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    /* Compute bounds, limit to 16 bits */
    bounds.x1 = stuff->x;
    bounds.y1 = stuff->y;
    if ((int) stuff->x + (int) stuff->width > MAXSHORT)
	bounds.x2 = MAXSHORT;
    else
	bounds.x2 = stuff->x + stuff->width;
    
    if ((int) stuff->y + (int) stuff->height > MAXSHORT)
	bounds.y2 = MAXSHORT;
    else
	bounds.y2 = stuff->y + stuff->height;

    if (!RegionInverse(pDestination, pSource, &bounds))
	return BadAlloc;

    return Success;
}

int
SProcXFixesInvertRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesInvertRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesInvertRegionReq);
    swapl (&stuff->source, n);
    swaps (&stuff->x, n);
    swaps (&stuff->y, n);
    swaps (&stuff->width, n);
    swaps (&stuff->height, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesTranslateRegion (ClientPtr client)
{
    RegionPtr	pRegion;
    REQUEST(xXFixesTranslateRegionReq);

    REQUEST_SIZE_MATCH(xXFixesTranslateRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);

    RegionTranslate(pRegion, stuff->dx, stuff->dy);
    return Success;
}

int
SProcXFixesTranslateRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesTranslateRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesTranslateRegionReq);
    swapl (&stuff->region, n);
    swaps (&stuff->dx, n);
    swaps (&stuff->dy, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesRegionExtents (ClientPtr client)
{
    RegionPtr	pSource, pDestination;
    REQUEST(xXFixesRegionExtentsReq);

    REQUEST_SIZE_MATCH(xXFixesRegionExtentsReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    RegionReset(pDestination, RegionExtents(pSource));

    return Success;
}

int
SProcXFixesRegionExtents (ClientPtr client)
{
    int n;
    REQUEST(xXFixesRegionExtentsReq);
    
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesRegionExtentsReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesFetchRegion (ClientPtr client)
{
    RegionPtr		    pRegion;
    xXFixesFetchRegionReply *reply;
    xRectangle		    *pRect;
    BoxPtr		    pExtent;
    BoxPtr		    pBox;
    int			    i, nBox;
    REQUEST(xXFixesFetchRegionReq);

    REQUEST_SIZE_MATCH(xXFixesFetchRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixReadAccess);

    pExtent = RegionExtents(pRegion);
    pBox = RegionRects (pRegion);
    nBox = RegionNumRects (pRegion);
    
    reply = malloc(sizeof (xXFixesFetchRegionReply) +
		    nBox * sizeof (xRectangle));
    if (!reply)
	return BadAlloc;
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = nBox << 1;
    reply->x = pExtent->x1;
    reply->y = pExtent->y1;
    reply->width = pExtent->x2 - pExtent->x1;
    reply->height = pExtent->y2 - pExtent->y1;

    pRect = (xRectangle *) (reply + 1);
    for (i = 0; i < nBox; i++)
    {
	pRect[i].x = pBox[i].x1;
	pRect[i].y = pBox[i].y1;
	pRect[i].width = pBox[i].x2 - pBox[i].x1;
	pRect[i].height = pBox[i].y2 - pBox[i].y1;
    }
    if (client->swapped)
    {
	int n;
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swaps (&reply->x, n);
	swaps (&reply->y, n);
	swaps (&reply->width, n);
	swaps (&reply->height, n);
	SwapShorts ((INT16 *) pRect, nBox * 4);
    }
    (void) WriteToClient(client, sizeof (xXFixesFetchRegionReply) +
			 nBox * sizeof (xRectangle), (char *) reply);
    free(reply);
    return Success;
}

int
SProcXFixesFetchRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesFetchRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesFetchRegionReq);
    swapl (&stuff->region, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetGCClipRegion (ClientPtr client)
{
    GCPtr	pGC;
    RegionPtr	pRegion;
    ChangeGCVal	vals[2];
    int		rc;
    REQUEST(xXFixesSetGCClipRegionReq);
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);

    rc = dixLookupGC(&pGC, stuff->gc, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    VERIFY_REGION_OR_NONE (pRegion, stuff->region, client, DixReadAccess);

    if (pRegion)
    {
	pRegion = XFixesRegionCopy (pRegion);
	if (!pRegion)
	    return BadAlloc;
    }
    
    vals[0].val = stuff->xOrigin;
    vals[1].val = stuff->yOrigin;
    ChangeGC (NullClient, pGC, GCClipXOrigin|GCClipYOrigin, vals);
    (*pGC->funcs->ChangeClip)(pGC, pRegion ? CT_REGION : CT_NONE, (pointer)pRegion, 0);

    return Success;
}

int
SProcXFixesSetGCClipRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesSetGCClipRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);
    swapl (&stuff->gc, n);
    swapl (&stuff->region, n);
    swaps (&stuff->xOrigin, n);
    swaps (&stuff->yOrigin, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

typedef	RegionPtr (*CreateDftPtr)(WindowPtr pWin);

int
ProcXFixesSetWindowShapeRegion (ClientPtr client)
{
    WindowPtr	    pWin;
    RegionPtr	    pRegion;
    RegionPtr	    *pDestRegion;
    int rc;
    REQUEST(xXFixesSetWindowShapeRegionReq);

    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->dest, RT_WINDOW,
			   client, DixSetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->dest;
	return rc;
    }
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixWriteAccess);
    switch (stuff->destKind) {
    case ShapeBounding:
    case ShapeClip:
    case ShapeInput:
	break;
    default:
	client->errorValue = stuff->destKind;
	return BadValue;
    }
    if (pRegion)
    {
	pRegion = XFixesRegionCopy (pRegion);
	if (!pRegion)
	    return BadAlloc;
	if (!pWin->optional)
	    MakeWindowOptional (pWin);
	switch (stuff->destKind) {
	default:
	case ShapeBounding:
	    pDestRegion = &pWin->optional->boundingShape;
	    break;
	case ShapeClip:
	    pDestRegion = &pWin->optional->clipShape;
	    break;
	case ShapeInput:
	    pDestRegion = &pWin->optional->inputShape;
	    break;
	}
	if (stuff->xOff || stuff->yOff)
	    RegionTranslate(pRegion, stuff->xOff, stuff->yOff);
    }
    else
    {
	if (pWin->optional)
	{
	    switch (stuff->destKind) {
	    default:
	    case ShapeBounding:
		pDestRegion = &pWin->optional->boundingShape;
		break;
	    case ShapeClip:
		pDestRegion = &pWin->optional->clipShape;
		break;
	    case ShapeInput:
		pDestRegion = &pWin->optional->inputShape;
		break;
	    }
	}
	else
	    pDestRegion = &pRegion; /* a NULL region pointer */
    }
    if (*pDestRegion)
	RegionDestroy(*pDestRegion);
    *pDestRegion = pRegion;
    (*pWin->drawable.pScreen->SetShape) (pWin, stuff->destKind);
    SendShapeNotify (pWin, stuff->destKind);
    return Success;
}

int
SProcXFixesSetWindowShapeRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesSetWindowShapeRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->region, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetPictureClipRegion (ClientPtr client)
{
    PicturePtr		pPicture;
    RegionPtr		pRegion;
    REQUEST(xXFixesSetPictureClipRegionReq);
    
    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixReadAccess);
    
    return SetPictureClipRegion (pPicture, stuff->xOrigin, stuff->yOrigin,
				 pRegion);
}

int
SProcXFixesSetPictureClipRegion (ClientPtr client)
{
    int n;
    REQUEST(xXFixesSetPictureClipRegionReq);
    
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);
    swapl (&stuff->picture, n);
    swapl (&stuff->region, n);
    swaps (&stuff->xOrigin, n);
    swaps (&stuff->yOrigin, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesExpandRegion (ClientPtr client)
{
    RegionPtr	pSource, pDestination;
    REQUEST (xXFixesExpandRegionReq);
    BoxPtr	pTmp;
    BoxPtr	pSrc;
    int		nBoxes;
    int		i;

    REQUEST_SIZE_MATCH (xXFixesExpandRegionReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
    
    nBoxes = RegionNumRects(pSource);
    pSrc = RegionRects(pSource);
    if (nBoxes)
    {
	pTmp = malloc(nBoxes * sizeof (BoxRec));
	if (!pTmp)
	    return BadAlloc;
	for (i = 0; i < nBoxes; i++)
	{
	    pTmp[i].x1 = pSrc[i].x1 - stuff->left;
	    pTmp[i].x2 = pSrc[i].x2 + stuff->right;
	    pTmp[i].y1 = pSrc[i].y1 - stuff->top;
	    pTmp[i].y2 = pSrc[i].y2 + stuff->bottom;
	}
	RegionEmpty(pDestination);
	for (i = 0; i < nBoxes; i++)
	{
	    RegionRec	r;
	    RegionInit(&r, &pTmp[i], 0);
	    RegionUnion(pDestination, pDestination, &r);
	}
	free(pTmp);
    }
    return Success;
}

int
SProcXFixesExpandRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesExpandRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesExpandRegionReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    swaps (&stuff->left, n);
    swaps (&stuff->right, n);
    swaps (&stuff->top, n);
    swaps (&stuff->bottom, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"

int
PanoramiXFixesSetGCClipRegion (ClientPtr client)
{
    REQUEST(xXFixesSetGCClipRegionReq);
    int		    result = Success, j;
    PanoramiXRes    *gc;
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);

    if ((result = dixLookupResourceByType((void **)&gc, stuff->gc, XRT_GC,
					  client, DixWriteAccess))) {
	client->errorValue = stuff->gc;
	return result;
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = gc->info[j].id;
        result = (*PanoramiXSaveXFixesVector[X_XFixesSetGCClipRegion]) (client);
        if(result != Success) break;
    }

    return result;
}

int
PanoramiXFixesSetWindowShapeRegion (ClientPtr client)
{
    int		    result = Success, j;
    PanoramiXRes    *win;
    REQUEST(xXFixesSetWindowShapeRegionReq);

    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);

    if ((result = dixLookupResourceByType((void **)&win, stuff->dest,
					  XRT_WINDOW, client,
					  DixWriteAccess))) {
	client->errorValue = stuff->dest;
	return result;
    }

    FOR_NSCREENS_FORWARD(j) {
	stuff->dest = win->info[j].id;
	result = (*PanoramiXSaveXFixesVector[X_XFixesSetWindowShapeRegion]) (client);
        if(result != Success) break;
    }

    return result;
}

int
PanoramiXFixesSetPictureClipRegion (ClientPtr client)
{
    REQUEST(xXFixesSetPictureClipRegionReq);
    int		    result = Success, j;
    PanoramiXRes    *pict;

    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);

    if ((result = dixLookupResourceByType((void **)&pict, stuff->picture,
					  XRT_PICTURE, client,
					  DixWriteAccess))) {
	client->errorValue = stuff->picture;
	return result;
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
	result = (*PanoramiXSaveXFixesVector[X_XFixesSetPictureClipRegion]) (client);
        if(result != Success) break;
    }

    return result;
}

#endif
/*
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"

int
ProcXFixesChangeSaveSet(ClientPtr client)
{
    Bool	toRoot, map;
    int		result;
    WindowPtr	pWin;
    REQUEST(xXFixesChangeSaveSetReq);
		  
    REQUEST_SIZE_MATCH(xXFixesChangeSaveSetReq);
    result = dixLookupWindow(&pWin, stuff->window, client, DixManageAccess);
    if (result != Success)
        return result;
    if (client->clientAsMask == (CLIENT_BITS(pWin->drawable.id)))
        return BadMatch;
    if ((stuff->mode != SetModeInsert) && (stuff->mode != SetModeDelete))
    {
	client->errorValue = stuff->mode;
	return BadValue;
    }
    if ((stuff->target != SaveSetNearest) && (stuff->target != SaveSetRoot))
    {
	client->errorValue = stuff->target;
	return BadValue;
    }
    if ((stuff->map != SaveSetMap) && (stuff->map != SaveSetUnmap))
    {
	client->errorValue = stuff->map;
	return BadValue;
    }
    toRoot = (stuff->target == SaveSetRoot);
    map = (stuff->map == SaveSetMap);
    return AlterSaveSetForClient(client, pWin, stuff->mode, toRoot, map);
}

int
SProcXFixesChangeSaveSet(ClientPtr client)
{
    register int n;
    REQUEST(xXFixesChangeSaveSetReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    return (*ProcXFixesVector[stuff->xfixesReqType])(client);
}
/*
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "xace.h"

static RESTYPE		SelectionClientType, SelectionWindowType;
static Bool		SelectionCallbackRegistered = FALSE;

/*
 * There is a global list of windows selecting for selection events
 * on every selection.  This should be plenty efficient for the
 * expected usage, if it does become a problem, it should be easily
 * replaced with a hash table of some kind keyed off the selection atom
 */

typedef struct _SelectionEvent *SelectionEventPtr;

typedef struct _SelectionEvent {
    SelectionEventPtr	next;
    Atom		selection;
    CARD32		eventMask;
    ClientPtr		pClient;
    WindowPtr		pWindow;
    XID			clientResource;
} SelectionEventRec;

static SelectionEventPtr	selectionEvents;

static void
XFixesSelectionCallback (CallbackListPtr *callbacks, pointer data, pointer args)
{
    SelectionEventPtr	e;
    SelectionInfoRec	*info = (SelectionInfoRec *) args;
    Selection		*selection = info->selection;
    int			subtype;
    CARD32		eventMask;
    
    switch (info->kind) {
    case SelectionSetOwner:
	subtype = XFixesSetSelectionOwnerNotify;
	eventMask = XFixesSetSelectionOwnerNotifyMask;
	break;
    case SelectionWindowDestroy:
	subtype = XFixesSelectionWindowDestroyNotify;
	eventMask = XFixesSelectionWindowDestroyNotifyMask;
	break;
    case SelectionClientClose:
	subtype = XFixesSelectionClientCloseNotify;
	eventMask = XFixesSelectionClientCloseNotifyMask;
	break;
    default:
	return;
    }
    for (e = selectionEvents; e; e = e->next)
    {
	if (e->selection == selection->selection && 
	    (e->eventMask & eventMask))
	{
	    xXFixesSelectionNotifyEvent	ev;

	    memset(&ev, 0, sizeof(xXFixesSelectionNotifyEvent));
	    ev.type = XFixesEventBase + XFixesSelectionNotify;
	    ev.subtype = subtype;
	    ev.window = e->pWindow->drawable.id;
	    if (subtype == XFixesSetSelectionOwnerNotify)
		ev.owner = selection->window;
	    else
		ev.owner = 0;
	    ev.selection = e->selection;
	    ev.timestamp = currentTime.milliseconds;
	    ev.selectionTimestamp = selection->lastTimeChanged.milliseconds;
	    WriteEventsToClient (e->pClient, 1, (xEvent *) &ev);
	}
    }
}

static Bool
CheckSelectionCallback (void)
{
    if (selectionEvents)
    {
	if (!SelectionCallbackRegistered)
	{
	    if (!AddCallback (&SelectionCallback, XFixesSelectionCallback, NULL))
		return FALSE;
	    SelectionCallbackRegistered = TRUE;
	}
    }
    else
    {
	if (SelectionCallbackRegistered)
	{
	    DeleteCallback (&SelectionCallback, XFixesSelectionCallback, NULL);
	    SelectionCallbackRegistered = FALSE;
	}
    }
    return TRUE;
}

#define SelectionAllEvents (XFixesSetSelectionOwnerNotifyMask |\
			    XFixesSelectionWindowDestroyNotifyMask |\
			    XFixesSelectionClientCloseNotifyMask)

static int
XFixesSelectSelectionInput (ClientPtr	pClient,
			    Atom	selection,
			    WindowPtr	pWindow,
			    CARD32	eventMask)
{
    pointer val;
    int rc;
    SelectionEventPtr	*prev, e;

    rc = XaceHook(XACE_SELECTION_ACCESS, pClient, selection, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    for (prev = &selectionEvents; (e = *prev); prev = &e->next)
    {
	if (e->selection == selection &&
	    e->pClient == pClient &&
	    e->pWindow == pWindow)
	{
	    break;
	}
    }
    if (!eventMask)
    {
	if (e)
	{
	    FreeResource (e->clientResource, 0);
	}
	return Success;
    }
    if (!e)
    {
	e = (SelectionEventPtr) malloc(sizeof (SelectionEventRec));
	if (!e)
	    return BadAlloc;

	e->next = 0;
	e->selection = selection;
	e->pClient = pClient;
	e->pWindow = pWindow;
	e->clientResource = FakeClientID(pClient->index);

	/*
	 * Add a resource hanging from the window to
	 * catch window destroy
	 */
	rc = dixLookupResourceByType (&val, pWindow->drawable.id,
				      SelectionWindowType, serverClient,
				      DixGetAttrAccess);
	if (rc != Success)
	    if (!AddResource (pWindow->drawable.id, SelectionWindowType,
			      (pointer) pWindow))
	    {
		free(e);
		return BadAlloc;
	    }

	if (!AddResource (e->clientResource, SelectionClientType, (pointer) e))
	    return BadAlloc;

	*prev = e;
	if (!CheckSelectionCallback ())
	{
	    FreeResource (e->clientResource, 0);
	    return BadAlloc;
	}
    }
    e->eventMask = eventMask;
    return Success;
}

int
ProcXFixesSelectSelectionInput (ClientPtr client)
{
    REQUEST (xXFixesSelectSelectionInputReq);
    WindowPtr	pWin;
    int		rc;

    REQUEST_SIZE_MATCH (xXFixesSelectSelectionInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->eventMask & ~SelectionAllEvents)
    {
	client->errorValue = stuff->eventMask;
	return BadValue;
    }
    return XFixesSelectSelectionInput (client, stuff->selection,
				       pWin, stuff->eventMask);
}

int
SProcXFixesSelectSelectionInput (ClientPtr client)
{
    register int n;
    REQUEST(xXFixesSelectSelectionInputReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    swapl(&stuff->selection, n);
    swapl(&stuff->eventMask, n);
    return (*ProcXFixesVector[stuff->xfixesReqType])(client);
}
    
void
SXFixesSelectionNotifyEvent (xXFixesSelectionNotifyEvent *from,
			     xXFixesSelectionNotifyEvent *to)
{
    to->type = from->type;
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->window, to->window);
    cpswapl (from->owner, to->owner);
    cpswapl (from->selection, to->selection);
    cpswapl (from->timestamp, to->timestamp);
    cpswapl (from->selectionTimestamp, to->selectionTimestamp);
}

static int
SelectionFreeClient (pointer data, XID id)
{
    SelectionEventPtr	old = (SelectionEventPtr) data;
    SelectionEventPtr	*prev, e;
    
    for (prev = &selectionEvents; (e = *prev); prev = &e->next)
    {
	if (e == old)
	{
	    *prev = e->next;
	    free(e);
	    CheckSelectionCallback ();
	    break;
	}
    }
    return 1;
}

static int
SelectionFreeWindow (pointer data, XID id)
{
    WindowPtr		pWindow = (WindowPtr) data;
    SelectionEventPtr	e, next;

    for (e = selectionEvents; e; e = next)
    {
	next = e->next;
	if (e->pWindow == pWindow)
	{
	    FreeResource (e->clientResource, 0);
	}
    }
    return 1;
}

Bool
XFixesSelectionInit (void)
{
    SelectionClientType = CreateNewResourceType(SelectionFreeClient,
						"XFixesSelectionClient");
    SelectionWindowType = CreateNewResourceType(SelectionFreeWindow,
						"XFixesSelectionWindow");
    return SelectionClientType && SelectionWindowType;
}
/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "protocol-versions.h"

static unsigned char	XFixesReqCode;
int		XFixesEventBase;
int		XFixesErrorBase;

static DevPrivateKeyRec XFixesClientPrivateKeyRec;
#define XFixesClientPrivateKey (&XFixesClientPrivateKeyRec)

static int
ProcXFixesQueryVersion(ClientPtr client)
{
    XFixesClientPtr pXFixesClient = GetXFixesClient (client);
    xXFixesQueryVersionReply rep;
    register int n;
    REQUEST(xXFixesQueryVersionReq);

    REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);
    memset(&rep, 0, sizeof(xXFixesQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (version_compare(stuff->majorVersion, stuff->minorVersion,
                        SERVER_XFIXES_MAJOR_VERSION, SERVER_XFIXES_MAJOR_VERSION) < 0)
    {
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else {
	rep.majorVersion = SERVER_XFIXES_MAJOR_VERSION;
        rep.minorVersion = SERVER_XFIXES_MINOR_VERSION;
    }

    pXFixesClient->major_version = rep.majorVersion;
    pXFixesClient->minor_version = rep.minorVersion;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xXFixesQueryVersionReply), (char *)&rep);
    return Success;
}

/* Major version controls available requests */
static const int version_requests[] = {
    X_XFixesQueryVersion,	    /* before client sends QueryVersion */
    X_XFixesGetCursorImage,	    /* Version 1 */
    X_XFixesChangeCursorByName,	    /* Version 2 */
    X_XFixesExpandRegion,	    /* Version 3 */
    X_XFixesShowCursor,		    /* Version 4 */
    X_XFixesDestroyPointerBarrier,  /* Version 5 */
};

#define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))
    
int	(*ProcXFixesVector[XFixesNumberRequests])(ClientPtr) = {
/*************** Version 1 ******************/
    ProcXFixesQueryVersion,
    ProcXFixesChangeSaveSet,
    ProcXFixesSelectSelectionInput,
    ProcXFixesSelectCursorInput,
    ProcXFixesGetCursorImage,
/*************** Version 2 ******************/
    ProcXFixesCreateRegion,
    ProcXFixesCreateRegionFromBitmap,
    ProcXFixesCreateRegionFromWindow,
    ProcXFixesCreateRegionFromGC,
    ProcXFixesCreateRegionFromPicture,
    ProcXFixesDestroyRegion,
    ProcXFixesSetRegion,
    ProcXFixesCopyRegion,
    ProcXFixesCombineRegion,
    ProcXFixesCombineRegion,
    ProcXFixesCombineRegion,
    ProcXFixesInvertRegion,
    ProcXFixesTranslateRegion,
    ProcXFixesRegionExtents,
    ProcXFixesFetchRegion,
    ProcXFixesSetGCClipRegion,
    ProcXFixesSetWindowShapeRegion,
    ProcXFixesSetPictureClipRegion,
    ProcXFixesSetCursorName,
    ProcXFixesGetCursorName,
    ProcXFixesGetCursorImageAndName,
    ProcXFixesChangeCursor,
    ProcXFixesChangeCursorByName,
/*************** Version 3 ******************/
    ProcXFixesExpandRegion,
/*************** Version 4 ****************/
    ProcXFixesHideCursor,
    ProcXFixesShowCursor,
/*************** Version 5 ****************/
    ProcXFixesCreatePointerBarrier,
    ProcXFixesDestroyPointerBarrier,
};

static int
ProcXFixesDispatch (ClientPtr client)
{
    REQUEST(xXFixesReq);
    XFixesClientPtr pXFixesClient = GetXFixesClient (client);

    if (pXFixesClient->major_version >= NUM_VERSION_REQUESTS)
	return BadRequest;
    if (stuff->xfixesReqType > version_requests[pXFixesClient->major_version])
	return BadRequest;
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int
SProcXFixesQueryVersion(ClientPtr client)
{
    register int n;
    REQUEST(xXFixesQueryVersionReq);

    swaps(&stuff->length, n);
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int (*SProcXFixesVector[XFixesNumberRequests])(ClientPtr) = {
/*************** Version 1 ******************/
    SProcXFixesQueryVersion,
    SProcXFixesChangeSaveSet,
    SProcXFixesSelectSelectionInput,
    SProcXFixesSelectCursorInput,
    SProcXFixesGetCursorImage,
/*************** Version 2 ******************/
    SProcXFixesCreateRegion,
    SProcXFixesCreateRegionFromBitmap,
    SProcXFixesCreateRegionFromWindow,
    SProcXFixesCreateRegionFromGC,
    SProcXFixesCreateRegionFromPicture,
    SProcXFixesDestroyRegion,
    SProcXFixesSetRegion,
    SProcXFixesCopyRegion,
    SProcXFixesCombineRegion,
    SProcXFixesCombineRegion,
    SProcXFixesCombineRegion,
    SProcXFixesInvertRegion,
    SProcXFixesTranslateRegion,
    SProcXFixesRegionExtents,
    SProcXFixesFetchRegion,
    SProcXFixesSetGCClipRegion,
    SProcXFixesSetWindowShapeRegion,
    SProcXFixesSetPictureClipRegion,
    SProcXFixesSetCursorName,
    SProcXFixesGetCursorName,
    SProcXFixesGetCursorImageAndName,
    SProcXFixesChangeCursor,
    SProcXFixesChangeCursorByName,
/*************** Version 3 ******************/
    SProcXFixesExpandRegion,
/*************** Version 4 ****************/
    SProcXFixesHideCursor,
    SProcXFixesShowCursor,
/*************** Version 5 ****************/
    SProcXFixesCreatePointerBarrier,
    SProcXFixesDestroyPointerBarrier,
};

static int
SProcXFixesDispatch (ClientPtr client)
{
    REQUEST(xXFixesReq);
    if (stuff->xfixesReqType >= XFixesNumberRequests)
	return BadRequest;
    return (*SProcXFixesVector[stuff->xfixesReqType]) (client);
}

static void
XFixesClientCallback (CallbackListPtr	*list,
		      pointer		closure,
		      pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    XFixesClientPtr	pXFixesClient = GetXFixesClient (pClient);

    pXFixesClient->major_version = 0;
    pXFixesClient->minor_version = 0;
}

/*ARGSUSED*/
static void
XFixesResetProc (ExtensionEntry *extEntry)
{
    DeleteCallback (&ClientStateCallback, XFixesClientCallback, 0);
}

void
XFixesExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!dixRegisterPrivateKey(&XFixesClientPrivateKeyRec, PRIVATE_CLIENT, sizeof (XFixesClientRec)))
	return;
    if (!AddCallback (&ClientStateCallback, XFixesClientCallback, 0))
	return;

    if (XFixesSelectionInit() && XFixesCursorInit () && XFixesRegionInit () &&
	(extEntry = AddExtension(XFIXES_NAME, XFixesNumberEvents, 
				 XFixesNumberErrors,
				 ProcXFixesDispatch, SProcXFixesDispatch,
				 XFixesResetProc, StandardMinorOpcode)) != 0)
    {
	XFixesReqCode = (unsigned char)extEntry->base;
	XFixesEventBase = extEntry->eventBase;
	XFixesErrorBase = extEntry->errorBase;
	EventSwapVector[XFixesEventBase + XFixesSelectionNotify] =
	    (EventSwapPtr) SXFixesSelectionNotifyEvent;
	EventSwapVector[XFixesEventBase + XFixesCursorNotify] =
	    (EventSwapPtr) SXFixesCursorNotifyEvent;
	SetResourceTypeErrorValue(RegionResType, XFixesErrorBase + BadRegion);
	SetResourceTypeErrorValue(PointerBarrierType,
				  XFixesErrorBase + BadBarrier);
    }
}

#ifdef PANORAMIX

int (*PanoramiXSaveXFixesVector[XFixesNumberRequests])(ClientPtr);

void
PanoramiXFixesInit (void)
{
    int i;

    for (i = 0; i < XFixesNumberRequests; i++)
	PanoramiXSaveXFixesVector[i] = ProcXFixesVector[i];
    /*
     * Stuff in Xinerama aware request processing hooks
     */
    ProcXFixesVector[X_XFixesSetGCClipRegion] = PanoramiXFixesSetGCClipRegion;
    ProcXFixesVector[X_XFixesSetWindowShapeRegion] = PanoramiXFixesSetWindowShapeRegion;
    ProcXFixesVector[X_XFixesSetPictureClipRegion] = PanoramiXFixesSetPictureClipRegion;
}

void
PanoramiXFixesReset (void)
{
    int i;

    for (i = 0; i < XFixesNumberRequests; i++)
	ProcXFixesVector[i] = PanoramiXSaveXFixesVector[i];
}

#endif
/*
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _XFIXES_H_
#define _XFIXES_H_

#include "resource.h"

extern _X_EXPORT RESTYPE RegionResType;
extern _X_EXPORT RESTYPE PointerBarrierType;
extern _X_EXPORT int XFixesErrorBase;

#define VERIFY_REGION(pRegion, rid, client, mode)			\
    do {								\
	int err;							\
	err = dixLookupResourceByType((pointer *) &pRegion, rid,	\
				      RegionResType, client, mode);	\
	if (err != Success) {						\
	    client->errorValue = rid;					\
	    return err;							\
	}								\
    } while (0)

#define VERIFY_REGION_OR_NONE(pRegion, rid, client, mode) { \
    pRegion = 0; \
    if (rid) VERIFY_REGION(pRegion, rid, client, mode); \
}

extern _X_EXPORT RegionPtr
XFixesRegionCopy (RegionPtr pRegion);

struct PointerBarrier {
    CARD16 x1, x2, y1, y2;
    CARD32 directions;
};


extern int
barrier_get_direction(int, int, int, int);
extern BOOL
barrier_is_blocking(const struct PointerBarrier*, int, int, int, int, double*);
extern BOOL
barrier_is_blocking_direction(const struct PointerBarrier*, int);
extern void
barrier_clamp_to_barrier(struct PointerBarrier *barrier, int dir, int *x, int *y);



#endif /* _XFIXES_H_ */
/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _XFIXESINT_H_
#define _XFIXESINT_H_

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include <X11/extensions/xfixesproto.h>
#include "windowstr.h"
#include "selection.h"
#include "xfixes.h"

extern int		XFixesEventBase;

typedef struct _XFixesClient {
    CARD32	major_version;
    CARD32	minor_version;
} XFixesClientRec, *XFixesClientPtr;

#define GetXFixesClient(pClient) ((XFixesClientPtr)dixLookupPrivate(&(pClient)->devPrivates, XFixesClientPrivateKey))

extern int	(*ProcXFixesVector[XFixesNumberRequests])(ClientPtr);

/* Initialize extension at server startup time */

void
XFixesExtensionInit(void);

/* Save set */
int
ProcXFixesChangeSaveSet(ClientPtr client);
    
int
SProcXFixesChangeSaveSet(ClientPtr client);
    
/* Selection events */
int
ProcXFixesSelectSelectionInput (ClientPtr client);

int
SProcXFixesSelectSelectionInput (ClientPtr client);

void
SXFixesSelectionNotifyEvent (xXFixesSelectionNotifyEvent *from,
			     xXFixesSelectionNotifyEvent *to);
Bool
XFixesSelectionInit (void);

/* Cursor notification */
Bool
XFixesCursorInit (void);
    
int
ProcXFixesSelectCursorInput (ClientPtr client);

int
SProcXFixesSelectCursorInput (ClientPtr client);

void
SXFixesCursorNotifyEvent (xXFixesCursorNotifyEvent *from,
			  xXFixesCursorNotifyEvent *to);

int
ProcXFixesGetCursorImage (ClientPtr client);

int
SProcXFixesGetCursorImage (ClientPtr client);

/* Cursor names (Version 2) */

int
ProcXFixesSetCursorName (ClientPtr client);

int
SProcXFixesSetCursorName (ClientPtr client);

int
ProcXFixesGetCursorName (ClientPtr client);

int
SProcXFixesGetCursorName (ClientPtr client);

int
ProcXFixesGetCursorImageAndName (ClientPtr client);

int
SProcXFixesGetCursorImageAndName (ClientPtr client);

/* Cursor replacement (Version 2) */

int
ProcXFixesChangeCursor (ClientPtr client);

int
SProcXFixesChangeCursor (ClientPtr client);

int
ProcXFixesChangeCursorByName (ClientPtr client);

int
SProcXFixesChangeCursorByName (ClientPtr client);

/* Region objects (Version 2* */
Bool
XFixesRegionInit (void);

int
ProcXFixesCreateRegion (ClientPtr client);

int
SProcXFixesCreateRegion (ClientPtr client);

int
ProcXFixesCreateRegionFromBitmap (ClientPtr client);

int
SProcXFixesCreateRegionFromBitmap (ClientPtr client);

int
ProcXFixesCreateRegionFromWindow (ClientPtr client);

int
SProcXFixesCreateRegionFromWindow (ClientPtr client);

int
ProcXFixesCreateRegionFromGC (ClientPtr client);

int
SProcXFixesCreateRegionFromGC (ClientPtr client);

int
ProcXFixesCreateRegionFromPicture (ClientPtr client);

int
SProcXFixesCreateRegionFromPicture (ClientPtr client);

int
ProcXFixesDestroyRegion (ClientPtr client);

int
SProcXFixesDestroyRegion (ClientPtr client);

int
ProcXFixesSetRegion (ClientPtr client);

int
SProcXFixesSetRegion (ClientPtr client);

int
ProcXFixesCopyRegion (ClientPtr client);

int
SProcXFixesCopyRegion (ClientPtr client);

int
ProcXFixesCombineRegion (ClientPtr client);

int
SProcXFixesCombineRegion (ClientPtr client);

int
ProcXFixesInvertRegion (ClientPtr client);

int
SProcXFixesInvertRegion (ClientPtr client);

int
ProcXFixesTranslateRegion (ClientPtr client);

int
SProcXFixesTranslateRegion (ClientPtr client);

int
ProcXFixesRegionExtents (ClientPtr client);

int
SProcXFixesRegionExtents (ClientPtr client);

int
ProcXFixesFetchRegion (ClientPtr client);

int
SProcXFixesFetchRegion (ClientPtr client);

int
ProcXFixesSetGCClipRegion (ClientPtr client);

int
SProcXFixesSetGCClipRegion (ClientPtr client);

int
ProcXFixesSetWindowShapeRegion (ClientPtr client);

int
SProcXFixesSetWindowShapeRegion (ClientPtr client);

int
ProcXFixesSetPictureClipRegion (ClientPtr client);

int
SProcXFixesSetPictureClipRegion (ClientPtr client);

int
ProcXFixesExpandRegion (ClientPtr client);

int
SProcXFixesExpandRegion (ClientPtr client);

int
PanoramiXFixesSetGCClipRegion (ClientPtr client);

int
PanoramiXFixesSetWindowShapeRegion (ClientPtr client);

int
PanoramiXFixesSetPictureClipRegion (ClientPtr client);

/* Cursor Visibility (Version 4) */

int 
ProcXFixesHideCursor (ClientPtr client);

int 
SProcXFixesHideCursor (ClientPtr client);

int 
ProcXFixesShowCursor (ClientPtr client);

int 
SProcXFixesShowCursor (ClientPtr client);

/* Version 5 */

int
ProcXFixesCreatePointerBarrier (ClientPtr client);

int
SProcXFixesCreatePointerBarrier (ClientPtr client);

int
ProcXFixesDestroyPointerBarrier (ClientPtr client);

int
SProcXFixesDestroyPointerBarrier (ClientPtr client);

/* Xinerama */
extern int (*PanoramiXSaveXFixesVector[XFixesNumberRequests])(ClientPtr);
void PanoramiXFixesInit (void);
void PanoramiXFixesReset (void);

#endif /* _XFIXESINT_H_ */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Function to allow frozen events to be routed from extension input devices.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>

#include "exglobals.h"

#include "allowev.h"
#include "dixevents.h"

/***********************************************************************
 *
 * This procedure allows frozen events to be routed.
 *
 */

int
SProcXAllowDeviceEvents(ClientPtr client)
{
    char n;

    REQUEST(xAllowDeviceEventsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xAllowDeviceEventsReq);
    swapl(&stuff->time, n);
    return (ProcXAllowDeviceEvents(client));
}

/***********************************************************************
 *
 * This procedure allows frozen events to be routed.
 *
 */

int
ProcXAllowDeviceEvents(ClientPtr client)
{
    TimeStamp time;
    DeviceIntPtr thisdev;
    int rc;

    REQUEST(xAllowDeviceEventsReq);
    REQUEST_SIZE_MATCH(xAllowDeviceEventsReq);

    rc = dixLookupDevice(&thisdev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    time = ClientTimeToServerTime(stuff->time);

    switch (stuff->mode) {
    case ReplayThisDevice:
	AllowSome(client, time, thisdev, NOT_GRABBED);
	break;
    case SyncThisDevice:
	AllowSome(client, time, thisdev, FREEZE_NEXT_EVENT);
	break;
    case AsyncThisDevice:
	AllowSome(client, time, thisdev, THAWED);
	break;
    case AsyncOtherDevices:
	AllowSome(client, time, thisdev, THAW_OTHERS);
	break;
    case SyncAll:
	AllowSome(client, time, thisdev, FREEZE_BOTH_NEXT_EVENT);
	break;
    case AsyncAll:
	AllowSome(client, time, thisdev, THAWED_BOTH);
	break;
    default:
	client->errorValue = stuff->mode;
	return BadValue;
    }
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef ALLOWEV_H
#define ALLOWEV_H 1

int SProcXAllowDeviceEvents(ClientPtr	/* client */
    );

int ProcXAllowDeviceEvents(ClientPtr	/* client */
    );

#endif /* ALLOWEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Change Device control attributes for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>	/* control constants */
#include "XIstubs.h"

#include "exglobals.h"
#include "exevents.h"

#include "chgdctl.h"

/***********************************************************************
 *
 * This procedure changes the control attributes for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXChangeDeviceControl(ClientPtr client)
{
    char n;
    xDeviceCtl *ctl;

    REQUEST(xChangeDeviceControlReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceControlReq);
    swaps(&stuff->control, n);
    ctl = (xDeviceCtl*)&stuff[1];
    swaps(&ctl->control, n);
    swaps(&ctl->length, n);
    switch(stuff->control) {
        case DEVICE_ABS_CALIB:
        case DEVICE_ABS_AREA:
        case DEVICE_CORE:
        case DEVICE_ENABLE:
        case DEVICE_RESOLUTION:
            /* hmm. beer. *drool* */
            break;

    }
    return (ProcXChangeDeviceControl(client));
}

/***********************************************************************
 *
 * Change the control attributes.
 *
 */

int
ProcXChangeDeviceControl(ClientPtr client)
{
    unsigned len;
    int i, status, ret = BadValue;
    DeviceIntPtr dev;
    xDeviceResolutionCtl *r;
    xChangeDeviceControlReply rep;
    AxisInfoPtr a;
    CARD32 *resolution;
    xDeviceEnableCtl *e;
    devicePresenceNotify dpn;

    REQUEST(xChangeDeviceControlReq);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceControlReq);

    len = stuff->length - bytes_to_int32(sizeof(xChangeDeviceControlReq));
    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (ret != Success)
        goto out;

    rep.repType = X_Reply;
    rep.RepType = X_ChangeDeviceControl;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    switch (stuff->control) {
    case DEVICE_RESOLUTION:
	r = (xDeviceResolutionCtl *) & stuff[1];
	if ((len < bytes_to_int32(sizeof(xDeviceResolutionCtl))) ||
	    (len != bytes_to_int32(sizeof(xDeviceResolutionCtl)) + r->num_valuators)) {
            ret = BadLength;
            goto out;
	}
	if (!dev->valuator) {
            ret = BadMatch;
            goto out;
	}
	if ((dev->deviceGrab.grab) && !SameClient(dev->deviceGrab.grab, client)) {
	    rep.status = AlreadyGrabbed;
            ret = Success;
            goto out;
	}
	resolution = (CARD32 *) (r + 1);
	if (r->first_valuator + r->num_valuators > dev->valuator->numAxes) {
            ret = BadValue;
            goto out;
	}
	status = ChangeDeviceControl(client, dev, (xDeviceCtl *) r);
	if (status == Success) {
	    a = &dev->valuator->axes[r->first_valuator];
	    for (i = 0; i < r->num_valuators; i++)
		if (*(resolution + i) < (a + i)->min_resolution ||
		    *(resolution + i) > (a + i)->max_resolution)
		    return BadValue;
	    for (i = 0; i < r->num_valuators; i++)
		(a++)->resolution = *resolution++;

            ret = Success;
	} else if (status == DeviceBusy) {
	    rep.status = DeviceBusy;
            ret = Success;
	} else {
            ret = BadMatch;
	}
	break;
    case DEVICE_ABS_CALIB:
    case DEVICE_ABS_AREA:
        /* Calibration is now done through properties, and never had any effect
         * on anything (in the open-source world). Thus, be honest. */
        ret = BadMatch;
        break;
    case DEVICE_CORE:
        /* Sorry, no device core switching no more. If you want a device to
         * send core events, attach it to a master device */
        ret = BadMatch;
        break;
    case DEVICE_ENABLE:
        e = (xDeviceEnableCtl *)&stuff[1];

        status = ChangeDeviceControl(client, dev, (xDeviceCtl *) e);

        if (status == Success) {
            if (e->enable)
                EnableDevice(dev, TRUE);
            else
                DisableDevice(dev, TRUE);
            ret = Success;
        } else if (status == DeviceBusy) {
            rep.status = DeviceBusy;
            ret = Success;
        } else {
            ret = BadMatch;
        }

        break;
    default:
        ret = BadValue;
    }

out:
    if (ret == Success) {
        dpn.type = DevicePresenceNotify;
        dpn.time = currentTime.milliseconds;
        dpn.devchange = DeviceControlChanged;
        dpn.deviceid = dev->id;
        dpn.control = stuff->control;
        SendEventToAllWindows(dev, DevicePresenceNotifyMask,
                              (xEvent *) &dpn, 1);

        WriteReplyToClient(client, sizeof(xChangeDeviceControlReply), &rep);
    }

    return ret;
}

/***********************************************************************
 *
 * This procedure writes the reply for the xChangeDeviceControl function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXChangeDeviceControl(ClientPtr client, int size,
			 xChangeDeviceControlReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGDCTL_H
#define CHGDCTL_H 1

int SProcXChangeDeviceControl(ClientPtr	/* client */
    );

int ProcXChangeDeviceControl(ClientPtr	/* client */
    );

void SRepXChangeDeviceControl(ClientPtr /* client */ ,
			      int /* size */ ,
			      xChangeDeviceControlReply *	/* rep */
    );

#endif /* CHGDCTL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Change feedback control attributes for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>	/* control constants */

#include "exglobals.h"

#include "chgfctl.h"

#define DO_ALL    (-1)

/***********************************************************************
 *
 * This procedure changes the control attributes for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXChangeFeedbackControl(ClientPtr client)
{
    char n;

    REQUEST(xChangeFeedbackControlReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xChangeFeedbackControlReq);
    swapl(&stuff->mask, n);
    return (ProcXChangeFeedbackControl(client));
}

/******************************************************************************
 *
 * This procedure changes KbdFeedbackClass data.
 *
 */

static int
ChangeKbdFeedback(ClientPtr client, DeviceIntPtr dev, long unsigned int mask,
		  KbdFeedbackPtr k, xKbdFeedbackCtl * f)
{
    char n;
    KeybdCtrl kctrl;
    int t;
    int key = DO_ALL;

    if (client->swapped) {
	swaps(&f->length, n);
	swaps(&f->pitch, n);
	swaps(&f->duration, n);
	swapl(&f->led_mask, n);
	swapl(&f->led_values, n);
    }

    kctrl = k->ctrl;
    if (mask & DvKeyClickPercent) {
	t = f->click;
	if (t == -1)
	    t = defaultKeyboardControl.click;
	else if (t < 0 || t > 100) {
	    client->errorValue = t;
	    return BadValue;
	}
	kctrl.click = t;
    }

    if (mask & DvPercent) {
	t = f->percent;
	if (t == -1)
	    t = defaultKeyboardControl.bell;
	else if (t < 0 || t > 100) {
	    client->errorValue = t;
	    return BadValue;
	}
	kctrl.bell = t;
    }

    if (mask & DvPitch) {
	t = f->pitch;
	if (t == -1)
	    t = defaultKeyboardControl.bell_pitch;
	else if (t < 0) {
	    client->errorValue = t;
	    return BadValue;
	}
	kctrl.bell_pitch = t;
    }

    if (mask & DvDuration) {
	t = f->duration;
	if (t == -1)
	    t = defaultKeyboardControl.bell_duration;
	else if (t < 0) {
	    client->errorValue = t;
	    return BadValue;
	}
	kctrl.bell_duration = t;
    }

    if (mask & DvLed) {
	kctrl.leds &= ~(f->led_mask);
	kctrl.leds |= (f->led_mask & f->led_values);
    }

    if (mask & DvKey) {
	key = (KeyCode) f->key;
	if (key < 8 || key > 255) {
	    client->errorValue = key;
	    return BadValue;
	}
	if (!(mask & DvAutoRepeatMode))
	    return BadMatch;
    }

    if (mask & DvAutoRepeatMode) {
	int inx = (key >> 3);
	int kmask = (1 << (key & 7));

	t = (CARD8) f->auto_repeat_mode;
	if (t == AutoRepeatModeOff) {
	    if (key == DO_ALL)
		kctrl.autoRepeat = FALSE;
	    else
		kctrl.autoRepeats[inx] &= ~kmask;
	} else if (t == AutoRepeatModeOn) {
	    if (key == DO_ALL)
		kctrl.autoRepeat = TRUE;
	    else
		kctrl.autoRepeats[inx] |= kmask;
	} else if (t == AutoRepeatModeDefault) {
	    if (key == DO_ALL)
		kctrl.autoRepeat = defaultKeyboardControl.autoRepeat;
	    else
		kctrl.autoRepeats[inx] &= ~kmask;
	    kctrl.autoRepeats[inx] =
		(kctrl.autoRepeats[inx] & ~kmask) |
		(defaultKeyboardControl.autoRepeats[inx] & kmask);
	} else {
	    client->errorValue = t;
	    return BadValue;
	}
    }

    k->ctrl = kctrl;
    (*k->CtrlProc) (dev, &k->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes PtrFeedbackClass data.
 *
 */

static int
ChangePtrFeedback(ClientPtr client, DeviceIntPtr dev, long unsigned int mask,
		  PtrFeedbackPtr p, xPtrFeedbackCtl * f)
{
    char n;
    PtrCtrl pctrl;	/* might get BadValue part way through */

    if (client->swapped) {
	swaps(&f->length, n);
	swaps(&f->num, n);
	swaps(&f->denom, n);
	swaps(&f->thresh, n);
    }

    pctrl = p->ctrl;
    if (mask & DvAccelNum) {
	int accelNum;

	accelNum = f->num;
	if (accelNum == -1)
	    pctrl.num = defaultPointerControl.num;
	else if (accelNum < 0) {
	    client->errorValue = accelNum;
	    return BadValue;
	} else
	    pctrl.num = accelNum;
    }

    if (mask & DvAccelDenom) {
	int accelDenom;

	accelDenom = f->denom;
	if (accelDenom == -1)
	    pctrl.den = defaultPointerControl.den;
	else if (accelDenom <= 0) {
	    client->errorValue = accelDenom;
	    return BadValue;
	} else
	    pctrl.den = accelDenom;
    }

    if (mask & DvThreshold) {
	int threshold;

	threshold = f->thresh;
	if (threshold == -1)
	    pctrl.threshold = defaultPointerControl.threshold;
	else if (threshold < 0) {
	    client->errorValue = threshold;
	    return BadValue;
	} else
	    pctrl.threshold = threshold;
    }

    p->ctrl = pctrl;
    (*p->CtrlProc) (dev, &p->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes IntegerFeedbackClass data.
 *
 */

static int
ChangeIntegerFeedback(ClientPtr client, DeviceIntPtr dev,
		      long unsigned int mask, IntegerFeedbackPtr i,
		      xIntegerFeedbackCtl * f)
{
    char n;

    if (client->swapped) {
	swaps(&f->length, n);
	swapl(&f->int_to_display, n);
    }

    i->ctrl.integer_displayed = f->int_to_display;
    (*i->CtrlProc) (dev, &i->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes StringFeedbackClass data.
 *
 */

static int
ChangeStringFeedback(ClientPtr client, DeviceIntPtr dev,
		     long unsigned int mask, StringFeedbackPtr s,
		     xStringFeedbackCtl * f)
{
    char n;
    int i, j;
    KeySym *syms, *sup_syms;

    syms = (KeySym *) (f + 1);
    if (client->swapped) {
	swaps(&f->length, n);	/* swapped num_keysyms in calling proc */
	SwapLongs((CARD32 *) syms, f->num_keysyms);
    }

    if (f->num_keysyms > s->ctrl.max_symbols)
	return BadValue;

    sup_syms = s->ctrl.symbols_supported;
    for (i = 0; i < f->num_keysyms; i++) {
	for (j = 0; j < s->ctrl.num_symbols_supported; j++)
	    if (*(syms + i) == *(sup_syms + j))
		break;
	if (j == s->ctrl.num_symbols_supported)
	    return BadMatch;
    }

    s->ctrl.num_symbols_displayed = f->num_keysyms;
    for (i = 0; i < f->num_keysyms; i++)
	*(s->ctrl.symbols_displayed + i) = *(syms + i);
    (*s->CtrlProc) (dev, &s->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes BellFeedbackClass data.
 *
 */

static int
ChangeBellFeedback(ClientPtr client, DeviceIntPtr dev,
		   long unsigned int mask, BellFeedbackPtr b,
		   xBellFeedbackCtl * f)
{
    char n;
    int t;
    BellCtrl bctrl;	/* might get BadValue part way through */

    if (client->swapped) {
	swaps(&f->length, n);
	swaps(&f->pitch, n);
	swaps(&f->duration, n);
    }

    bctrl = b->ctrl;
    if (mask & DvPercent) {
	t = f->percent;
	if (t == -1)
	    t = defaultKeyboardControl.bell;
	else if (t < 0 || t > 100) {
	    client->errorValue = t;
	    return BadValue;
	}
	bctrl.percent = t;
    }

    if (mask & DvPitch) {
	t = f->pitch;
	if (t == -1)
	    t = defaultKeyboardControl.bell_pitch;
	else if (t < 0) {
	    client->errorValue = t;
	    return BadValue;
	}
	bctrl.pitch = t;
    }

    if (mask & DvDuration) {
	t = f->duration;
	if (t == -1)
	    t = defaultKeyboardControl.bell_duration;
	else if (t < 0) {
	    client->errorValue = t;
	    return BadValue;
	}
	bctrl.duration = t;
    }
    b->ctrl = bctrl;
    (*b->CtrlProc) (dev, &b->ctrl);
    return Success;
}

/******************************************************************************
 *
 * This procedure changes LedFeedbackClass data.
 *
 */

static int
ChangeLedFeedback(ClientPtr client, DeviceIntPtr dev, long unsigned int mask,
		  LedFeedbackPtr l, xLedFeedbackCtl * f)
{
    char n;
    LedCtrl lctrl;	/* might get BadValue part way through */

    if (client->swapped) {
	swaps(&f->length, n);
	swapl(&f->led_values, n);
	swapl(&f->led_mask, n);
    }

    f->led_mask &= l->ctrl.led_mask;	/* set only supported leds */
    f->led_values &= l->ctrl.led_mask;	/* set only supported leds */
    if (mask & DvLed) {
	lctrl.led_mask = f->led_mask;
	lctrl.led_values = f->led_values;
	(*l->CtrlProc) (dev, &lctrl);
	l->ctrl.led_values &= ~(f->led_mask);	/* zero changed leds */
	l->ctrl.led_values |= (f->led_mask & f->led_values);	/* OR in set leds */
    }

    return Success;
}

/***********************************************************************
 *
 * Change the control attributes.
 *
 */

int
ProcXChangeFeedbackControl(ClientPtr client)
{
    unsigned len;
    DeviceIntPtr dev;
    KbdFeedbackPtr k;
    PtrFeedbackPtr p;
    IntegerFeedbackPtr i;
    StringFeedbackPtr s;
    BellFeedbackPtr b;
    LedFeedbackPtr l;
    int rc;

    REQUEST(xChangeFeedbackControlReq);
    REQUEST_AT_LEAST_SIZE(xChangeFeedbackControlReq);

    len = stuff->length - bytes_to_int32(sizeof(xChangeFeedbackControlReq));
    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (rc != Success)
	return rc;

    switch (stuff->feedbackid) {
    case KbdFeedbackClass:
	if (len != bytes_to_int32(sizeof(xKbdFeedbackCtl)))
	    return BadLength;

	for (k = dev->kbdfeed; k; k = k->next)
	    if (k->ctrl.id == ((xKbdFeedbackCtl *) & stuff[1])->id)
		return ChangeKbdFeedback(client, dev, stuff->mask, k,
					 (xKbdFeedbackCtl *) & stuff[1]);
	break;
    case PtrFeedbackClass:
	if (len != bytes_to_int32(sizeof(xPtrFeedbackCtl)))
	    return BadLength;

	for (p = dev->ptrfeed; p; p = p->next)
	    if (p->ctrl.id == ((xPtrFeedbackCtl *) & stuff[1])->id)
		return ChangePtrFeedback(client, dev, stuff->mask, p,
					 (xPtrFeedbackCtl *) & stuff[1]);
	break;
    case StringFeedbackClass:
    {
	char n;
	xStringFeedbackCtl *f = ((xStringFeedbackCtl *) & stuff[1]);

	if (client->swapped) {
	    swaps(&f->num_keysyms, n);
	}
	if (len != (bytes_to_int32(sizeof(xStringFeedbackCtl)) + f->num_keysyms))
	    return BadLength;

	for (s = dev->stringfeed; s; s = s->next)
	    if (s->ctrl.id == ((xStringFeedbackCtl *) & stuff[1])->id)
		return ChangeStringFeedback(client, dev, stuff->mask, s,
					    (xStringFeedbackCtl *) & stuff[1]);
	break;
    }
    case IntegerFeedbackClass:
	if (len != bytes_to_int32(sizeof(xIntegerFeedbackCtl)))
	    return BadLength;

	for (i = dev->intfeed; i; i = i->next)
	    if (i->ctrl.id == ((xIntegerFeedbackCtl *) & stuff[1])->id)
		return ChangeIntegerFeedback(client, dev, stuff->mask, i,
					     (xIntegerFeedbackCtl *)&stuff[1]);
	break;
    case LedFeedbackClass:
	if (len != bytes_to_int32(sizeof(xLedFeedbackCtl)))
	    return BadLength;

	for (l = dev->leds; l; l = l->next)
	    if (l->ctrl.id == ((xLedFeedbackCtl *) & stuff[1])->id)
		return ChangeLedFeedback(client, dev, stuff->mask, l,
					 (xLedFeedbackCtl *) & stuff[1]);
	break;
    case BellFeedbackClass:
	if (len != bytes_to_int32(sizeof(xBellFeedbackCtl)))
	    return BadLength;

	for (b = dev->bell; b; b = b->next)
	    if (b->ctrl.id == ((xBellFeedbackCtl *) & stuff[1])->id)
		return ChangeBellFeedback(client, dev, stuff->mask, b,
					  (xBellFeedbackCtl *) & stuff[1]);
	break;
    default:
	break;
    }

    return BadMatch;
}

/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGFCTL_H
#define CHGFCTL_H 1

int SProcXChangeFeedbackControl(ClientPtr	/* client */
    );

int ProcXChangeFeedbackControl(ClientPtr	/* client */
    );

#endif /* CHGFCTL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to change the keyboard device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "globals.h"

#include "exevents.h"
#include "exglobals.h"

#include "chgkbd.h"
#include "chgptr.h"

/***********************************************************************
 *
 * This procedure changes the keyboard device.
 *
 */

int
SProcXChangeKeyboardDevice(ClientPtr client)
{
    char n;

    REQUEST(xChangeKeyboardDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xChangeKeyboardDeviceReq);
    return (ProcXChangeKeyboardDevice(client));
}

/***********************************************************************
 *
 * This procedure is invoked to swap the request bytes if the server and
 * client have a different byte order.
 *
 */

int
ProcXChangeKeyboardDevice(ClientPtr client)
{
    /* REQUEST(xChangeKeyboardDeviceReq); */
    REQUEST_SIZE_MATCH(xChangeKeyboardDeviceReq);

    return BadDevice;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGKBD_H
#define CHGKBD_H 1

int SProcXChangeKeyboardDevice(ClientPtr	/* client */
    );

int ProcXChangeKeyboardDevice(ClientPtr	/* client */
    );

#endif /* CHGKBD_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Change key mapping for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "chgkmap.h"

/***********************************************************************
 *
 * This procedure swaps the request when the client and
 * server have different byte orderings.
 *
 */

int
SProcXChangeDeviceKeyMapping(ClientPtr client)
{
    char n;
    unsigned int count;

    REQUEST(xChangeDeviceKeyMappingReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceKeyMappingReq);
    count = stuff->keyCodes * stuff->keySymsPerKeyCode;
    REQUEST_FIXED_SIZE(xChangeDeviceKeyMappingReq, count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), count);
    return (ProcXChangeDeviceKeyMapping(client));
}

/***********************************************************************
 *
 * Change the device key mapping.
 *
 */

int
ProcXChangeDeviceKeyMapping(ClientPtr client)
{
    int ret;
    unsigned len;
    DeviceIntPtr dev;
    unsigned int count;

    REQUEST(xChangeDeviceKeyMappingReq);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceKeyMappingReq);

    count = stuff->keyCodes * stuff->keySymsPerKeyCode;
    REQUEST_FIXED_SIZE(xChangeDeviceKeyMappingReq, count * sizeof(CARD32));

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (ret != Success)
	return ret;
    len = stuff->length - bytes_to_int32(sizeof(xChangeDeviceKeyMappingReq));

    ret = ChangeKeyMapping(client, dev, len, DeviceMappingNotify,
			   stuff->firstKeyCode, stuff->keyCodes,
			   stuff->keySymsPerKeyCode, (KeySym *) & stuff[1]);

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGKMAP_H
#define CHGKMAP_H 1

int SProcXChangeDeviceKeyMapping(ClientPtr	/* client */
    );

int ProcXChangeDeviceKeyMapping(ClientPtr	/* client */
    );

#endif /* CHGKMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Function to modify the dont-propagate-list for an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>

#include "exevents.h"
#include "exglobals.h"

#include "chgprop.h"
#include "grabdev.h"

/***********************************************************************
 *
 * This procedure returns the extension version.
 *
 */

int
SProcXChangeDeviceDontPropagateList(ClientPtr client)
{
    char n;

    REQUEST(xChangeDeviceDontPropagateListReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceDontPropagateListReq);
    swapl(&stuff->window, n);
    swaps(&stuff->count, n);
    REQUEST_FIXED_SIZE(xChangeDeviceDontPropagateListReq,
                      stuff->count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), stuff->count);
    return (ProcXChangeDeviceDontPropagateList(client));
}

/***********************************************************************
 *
 * This procedure changes the dont-propagate list for the specified window.
 *
 */

int
ProcXChangeDeviceDontPropagateList(ClientPtr client)
{
    int i, rc;
    WindowPtr pWin;
    struct tmask tmp[EMASKSIZE];
    OtherInputMasks *others;

    REQUEST(xChangeDeviceDontPropagateListReq);
    REQUEST_AT_LEAST_SIZE(xChangeDeviceDontPropagateListReq);

    if (stuff->length != bytes_to_int32(sizeof(xChangeDeviceDontPropagateListReq)) +
	stuff->count)
	return BadLength;

    rc = dixLookupWindow(&pWin, stuff->window, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if (stuff->mode != AddToList && stuff->mode != DeleteFromList) {
	client->errorValue = stuff->window;
	return BadMode;
    }

    if ((rc = CreateMaskFromList(client, (XEventClass *) & stuff[1],
				 stuff->count, tmp, NULL,
				 X_ChangeDeviceDontPropagateList)) != Success)
	return rc;

    others = wOtherInputMasks(pWin);
    if (!others && stuff->mode == DeleteFromList)
	return Success;
    for (i = 0; i < EMASKSIZE; i++) {
	if (tmp[i].mask == 0)
	    continue;

	if (stuff->mode == DeleteFromList)
	    tmp[i].mask = (others->dontPropagateMask[i] & ~tmp[i].mask);
	else if (others)
	    tmp[i].mask |= others->dontPropagateMask[i];

	if (DeviceEventSuppressForWindow(pWin, client, tmp[i].mask, i) !=
	    Success)
	    return BadClass;
    }

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGPROP_H
#define CHGPROP_H 1

int SProcXChangeDeviceDontPropagateList(ClientPtr	/* client */
    );

int ProcXChangeDeviceDontPropagateList(ClientPtr	/* client */
    );

#endif /* CHGPROP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to change the pointer device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */

#include "dixevents.h"
#include "exevents.h"
#include "exglobals.h"

#include "chgptr.h"

/***********************************************************************
 *
 * This procedure is invoked to swap the request bytes if the server and
 * client have a different byte order.
 *
 */

int
SProcXChangePointerDevice(ClientPtr client)
{
    char n;

    REQUEST(xChangePointerDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xChangePointerDeviceReq);
    return (ProcXChangePointerDevice(client));
}

/***********************************************************************
 *
 * This procedure changes the device used as the X pointer.
 *
 */

int
ProcXChangePointerDevice(ClientPtr client)
{
    /* REQUEST(xChangePointerDeviceReq); */
    REQUEST_SIZE_MATCH(xChangePointerDeviceReq);

    return BadDevice;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHGPTR_H
#define CHGPTR_H 1

int SProcXChangePointerDevice(ClientPtr	/* client */
    );

int ProcXChangePointerDevice(ClientPtr	/* client */
    );

void DeleteFocusClassDeviceStruct(DeviceIntPtr	/* dev */
    );

void SendEventToAllWindows(DeviceIntPtr /* dev */ ,
			   Mask /* mask */ ,
			   xEvent * /* ev */ ,
			   int	/* count */
    );

#endif /* CHGPTR_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to close an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "exglobals.h"

#include "closedev.h"

/***********************************************************************
 *
 * This procedure closes an input device.
 *
 */

int
SProcXCloseDevice(ClientPtr client)
{
    char n;

    REQUEST(xCloseDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xCloseDeviceReq);
    return (ProcXCloseDevice(client));
}

/***********************************************************************
 *
 * Clear out event selections and passive grabs from a window for the
 * specified device.
 *
 */

static void
DeleteDeviceEvents(DeviceIntPtr dev, WindowPtr pWin, ClientPtr client)
{
    InputClientsPtr others;
    OtherInputMasks *pOthers;
    GrabPtr grab, next;

    if ((pOthers = wOtherInputMasks(pWin)) != 0)
	for (others = pOthers->inputClients; others; others = others->next)
	    if (SameClient(others, client))
		others->mask[dev->id] = NoEventMask;

    for (grab = wPassiveGrabs(pWin); grab; grab = next) {
	next = grab->next;
	if ((grab->device == dev) &&
	    (client->clientAsMask == CLIENT_BITS(grab->resource)))
	    FreeResource(grab->resource, RT_NONE);
    }
}

/***********************************************************************
 *
 * Walk througth the window tree, deleting event selections for this client
 * from this device from all windows.
 *
 */

static void
DeleteEventsFromChildren(DeviceIntPtr dev, WindowPtr p1, ClientPtr client)
{
    WindowPtr p2;

    while (p1) {
	p2 = p1->firstChild;
	DeleteDeviceEvents(dev, p1, client);
	DeleteEventsFromChildren(dev, p2, client);
	p1 = p1->nextSib;
    }
}

/***********************************************************************
 *
 * This procedure closes an input device.
 *
 */

int
ProcXCloseDevice(ClientPtr client)
{
    int rc, i;
    WindowPtr pWin, p1;
    DeviceIntPtr d;

    REQUEST(xCloseDeviceReq);
    REQUEST_SIZE_MATCH(xCloseDeviceReq);

    rc = dixLookupDevice(&d, stuff->deviceid, client, DixUseAccess);
    if (rc != Success)
	return rc;

    if (d->deviceGrab.grab && SameClient(d->deviceGrab.grab, client))
	(*d->deviceGrab.DeactivateGrab) (d);	/* release active grab */

    /* Remove event selections from all windows for events from this device
     * and selected by this client.
     * Delete passive grabs from all windows for this device.      */

    for (i = 0; i < screenInfo.numScreens; i++) {
	pWin = screenInfo.screens[i]->root;
	DeleteDeviceEvents(d, pWin, client);
	p1 = pWin->firstChild;
	DeleteEventsFromChildren(d, p1, client);
    }

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CLOSEDEV_H
#define CLOSEDEV_H 1

int SProcXCloseDevice(ClientPtr	/* client */
    );

int ProcXCloseDevice(ClientPtr	/* client */
    );

#endif /* CLOSEDEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to change the keyboard device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "devbell.h"

/***********************************************************************
 *
 * This procedure is invoked to swap the request bytes if the server and
 * client have a different byte order.
 *
 */

int
SProcXDeviceBell(ClientPtr client)
{
    char n;

    REQUEST(xDeviceBellReq);
    swaps(&stuff->length, n);
    return (ProcXDeviceBell(client));
}

/***********************************************************************
 *
 * This procedure rings a bell on an extension device.
 *
 */

int
ProcXDeviceBell(ClientPtr client)
{
    DeviceIntPtr dev;
    KbdFeedbackPtr k;
    BellFeedbackPtr b;
    int rc, base;
    int newpercent;
    CARD8 class;
    pointer ctrl;
    BellProcPtr proc;

    REQUEST(xDeviceBellReq);
    REQUEST_SIZE_MATCH(xDeviceBellReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixBellAccess);
    if (rc != Success) {
	client->errorValue = stuff->deviceid;
	return rc;
    }

    if (stuff->percent < -100 || stuff->percent > 100) {
	client->errorValue = stuff->percent;
	return BadValue;
    }
    if (stuff->feedbackclass == KbdFeedbackClass) {
	for (k = dev->kbdfeed; k; k = k->next)
	    if (k->ctrl.id == stuff->feedbackid)
		break;
	if (!k) {
	    client->errorValue = stuff->feedbackid;
	    return BadValue;
	}
	base = k->ctrl.bell;
	proc = k->BellProc;
	ctrl = (pointer) & (k->ctrl);
	class = KbdFeedbackClass;
    } else if (stuff->feedbackclass == BellFeedbackClass) {
	for (b = dev->bell; b; b = b->next)
	    if (b->ctrl.id == stuff->feedbackid)
		break;
	if (!b) {
	    client->errorValue = stuff->feedbackid;
	    return BadValue;
	}
	base = b->ctrl.percent;
	proc = b->BellProc;
	ctrl = (pointer) & (b->ctrl);
	class = BellFeedbackClass;
    } else {
	client->errorValue = stuff->feedbackclass;
	return BadValue;
    }
    newpercent = (base * stuff->percent) / 100;
    if (stuff->percent < 0)
	newpercent = base + newpercent;
    else
	newpercent = base - newpercent + stuff->percent;
    (*proc) (newpercent, dev, ctrl, class);

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef DEVBELL_H
#define DEVBELL_H 1

int SProcXDeviceBell(ClientPtr	/* client */
    );

int ProcXDeviceBell(ClientPtr	/* client */
    );

#endif /* DEVBELL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Routines to register and initialize extension input devices.
 *  This also contains ProcessOtherEvent, the routine called from DDX
 *  to route extension events.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/geproto.h>
#include "windowstr.h"
#include "miscstruct.h"
#include "region.h"
#include "exevents.h"
#include "extnsionst.h"
#include "exglobals.h"
#include "dixevents.h"	/* DeliverFocusedEvent */
#include "dixgrabs.h"	/* CreateGrab() */
#include "scrnintstr.h"
#include "listdev.h" /* for CopySwapXXXClass */
#include "xace.h"
#include "xiquerydevice.h" /* For List*Info */
#include "eventconvert.h"
#include "eventstr.h"
#include "inpututils.h"

#include <X11/extensions/XKBproto.h>
#include "xkbsrv.h"

#define WID(w) ((w) ? ((w)->drawable.id) : 0)
#define AllModifiersMask ( \
	ShiftMask | LockMask | ControlMask | Mod1Mask | Mod2Mask | \
	Mod3Mask | Mod4Mask | Mod5Mask )
#define AllButtonsMask ( \
	Button1Mask | Button2Mask | Button3Mask | Button4Mask | Button5Mask )

Bool ShouldFreeInputMasks(WindowPtr /* pWin */ ,
				 Bool	/* ignoreSelectedEvents */
    );
static Bool MakeInputMasks(WindowPtr	/* pWin */
    );

/*
 * Only let the given client know of core events which will affect its
 * interpretation of input events, if the client's ClientPointer (or the
 * paired keyboard) is the current device.
 */
int
XIShouldNotify(ClientPtr client, DeviceIntPtr dev)
{
    DeviceIntPtr current_ptr = PickPointer(client);
    DeviceIntPtr current_kbd = GetPairedDevice(current_ptr);

    if (dev == current_kbd || dev == current_ptr)
        return 1;

    return 0;
}

Bool
IsPointerEvent(InternalEvent* event)
{
    switch(event->any.type)
    {
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_Motion:
            /* XXX: enter/leave ?? */
            return TRUE;
        default:
            break;
    }
    return FALSE;
}

/**
 * @return the device matching the deviceid of the device set in the event, or
 * NULL if the event is not an XInput event.
 */
DeviceIntPtr
XIGetDevice(xEvent* xE)
{
    DeviceIntPtr pDev = NULL;

    if (xE->u.u.type == DeviceButtonPress ||
        xE->u.u.type == DeviceButtonRelease ||
        xE->u.u.type == DeviceMotionNotify ||
        xE->u.u.type == ProximityIn ||
        xE->u.u.type == ProximityOut ||
        xE->u.u.type == DevicePropertyNotify)
    {
        int rc;
        int id;

        id = ((deviceKeyButtonPointer*)xE)->deviceid & ~MORE_EVENTS;

        rc = dixLookupDevice(&pDev, id, serverClient, DixUnknownAccess);
        if (rc != Success)
            ErrorF("[dix] XIGetDevice failed on XACE restrictions (%d)\n", rc);
    }
    return pDev;
}


/**
 * Copy the device->key into master->key and send a mapping notify to the
 * clients if appropriate.
 * master->key needs to be allocated by the caller.
 *
 * Device is the slave device. If it is attached to a master device, we may
 * need to send a mapping notify to the client because it causes the MD
 * to change state.
 *
 * Mapping notify needs to be sent in the following cases:
 *      - different slave device on same master
 *      - different master
 *
 * XXX: They way how the code is we also send a map notify if the slave device
 * stays the same, but the master changes. This isn't really necessary though.
 *
 * XXX: this gives you funny behaviour with the ClientPointer. When a
 * MappingNotify is sent to the client, the client usually responds with a
 * GetKeyboardMapping. This will retrieve the ClientPointer's keyboard
 * mapping, regardless of which keyboard sent the last mapping notify request.
 * So depending on the CP setting, your keyboard may change layout in each
 * app...
 *
 * This code is basically the old SwitchCoreKeyboard.
 */

void
CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master)
{
    KeyClassPtr mk = master->key;

    if (device == master)
        return;

    mk->sourceid = device->id;


    if (!XkbCopyDeviceKeymap(master, device))
        FatalError("Couldn't pivot keymap from device to core!\n");
}

/**
 * Copies the feedback classes from device "from" into device "to". Classes
 * are duplicated (not just flipping the pointers). All feedback classes are
 * linked lists, the full list is duplicated.
 */
static void
DeepCopyFeedbackClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;


    if (from->intfeed)
    {
        IntegerFeedbackPtr *i, it;

        if (!to->intfeed)
        {
            classes = to->unused_classes;
            to->intfeed = classes->intfeed;
            classes->intfeed = NULL;
        }

        i = &to->intfeed;
        for (it = from->intfeed; it; it = it->next)
        {
            if (!(*i))
            {
                *i = calloc(1, sizeof(IntegerFeedbackClassRec));
                if (!(*i))
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*i)->CtrlProc = it->CtrlProc;
            (*i)->ctrl     = it->ctrl;

            i = &(*i)->next;
        }
    } else if (to->intfeed && !from->intfeed)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->intfeed = to->intfeed;
        to->intfeed      = NULL;
    }

    if (from->stringfeed)
    {
        StringFeedbackPtr *s, it;

        if (!to->stringfeed)
        {
            classes = to->unused_classes;
            to->stringfeed = classes->stringfeed;
            classes->stringfeed = NULL;
        }

        s = &to->stringfeed;
        for (it = from->stringfeed; it; it = it->next)
        {
            if (!(*s))
            {
                *s = calloc(1, sizeof(StringFeedbackClassRec));
                if (!(*s))
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*s)->CtrlProc = it->CtrlProc;
            (*s)->ctrl     = it->ctrl;

            s = &(*s)->next;
        }
    } else if (to->stringfeed && !from->stringfeed)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->stringfeed = to->stringfeed;
        to->stringfeed      = NULL;
    }

    if (from->bell)
    {
        BellFeedbackPtr *b, it;

        if (!to->bell)
        {
            classes = to->unused_classes;
            to->bell = classes->bell;
            classes->bell = NULL;
        }

        b = &to->bell;
        for (it = from->bell; it; it = it->next)
        {
            if (!(*b))
            {
                *b = calloc(1, sizeof(BellFeedbackClassRec));
                if (!(*b))
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*b)->BellProc = it->BellProc;
            (*b)->CtrlProc = it->CtrlProc;
            (*b)->ctrl     = it->ctrl;

            b = &(*b)->next;
        }
    } else if (to->bell && !from->bell)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->bell = to->bell;
        to->bell      = NULL;
    }

    if (from->leds)
    {
        LedFeedbackPtr *l, it;

        if (!to->leds)
        {
            classes = to->unused_classes;
            to->leds = classes->leds;
            classes->leds = NULL;
        }

        l = &to->leds;
        for (it = from->leds; it; it = it->next)
        {
            if (!(*l))
            {
                *l = calloc(1, sizeof(LedFeedbackClassRec));
                if (!(*l))
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*l)->CtrlProc = it->CtrlProc;
            (*l)->ctrl     = it->ctrl;
            if ((*l)->xkb_sli)
                XkbFreeSrvLedInfo((*l)->xkb_sli);
            (*l)->xkb_sli = XkbCopySrvLedInfo(from, it->xkb_sli, NULL, *l);

            l = &(*l)->next;
        }
    } else if (to->leds && !from->leds)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->leds = to->leds;
        to->leds      = NULL;
    }
}

static void
DeepCopyKeyboardClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;

    /* XkbInitDevice (->XkbInitIndicatorMap->XkbFindSrvLedInfo) relies on the
     * kbdfeed to be set up properly, so let's do the feedback classes first.
     */
    if (from->kbdfeed)
    {
        KbdFeedbackPtr *k, it;

        if (!to->kbdfeed)
        {
            classes = to->unused_classes;

            to->kbdfeed = classes->kbdfeed;
            if (!to->kbdfeed)
                InitKeyboardDeviceStruct(to, NULL, NULL, NULL);
            classes->kbdfeed = NULL;
        }

        k = &to->kbdfeed;
        for(it = from->kbdfeed; it; it = it->next)
        {
            if (!(*k))
            {
                *k = calloc(1, sizeof(KbdFeedbackClassRec));
                if (!*k)
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*k)->BellProc = it->BellProc;
            (*k)->CtrlProc = it->CtrlProc;
            (*k)->ctrl     = it->ctrl;
            if ((*k)->xkb_sli)
                XkbFreeSrvLedInfo((*k)->xkb_sli);
            (*k)->xkb_sli = XkbCopySrvLedInfo(from, it->xkb_sli, *k, NULL);

            k = &(*k)->next;
        }
    } else if (to->kbdfeed && !from->kbdfeed)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->kbdfeed = to->kbdfeed;
        to->kbdfeed      = NULL;
    }

    if (from->key)
    {
        if (!to->key)
        {
            classes = to->unused_classes;
            to->key = classes->key;
            if (!to->key)
                InitKeyboardDeviceStruct(to, NULL, NULL, NULL);
            else
                classes->key = NULL;
        }

        CopyKeyClass(from, to);
    } else if (to->key && !from->key)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->key = to->key;
        to->key      = NULL;
    }

    /* If a SrvLedInfoPtr's flags are XkbSLI_IsDefault, the names and maps
     * pointer point into the xkbInfo->desc struct.  XkbCopySrvLedInfo
     * didn't update the pointers so we need to do it manually here.
     */
    if (to->kbdfeed)
    {
        KbdFeedbackPtr k;

        for (k = to->kbdfeed; k; k = k->next)
        {
            if (!k->xkb_sli)
                continue;
            if (k->xkb_sli->flags & XkbSLI_IsDefault)
            {
                k->xkb_sli->names = to->key->xkbInfo->desc->names->indicators;
                k->xkb_sli->maps = to->key->xkbInfo->desc->indicators->maps;
            }
        }
    }

    /* We can't just copy over the focus class. When an app sets the focus,
     * it'll do so on the master device. Copying the SDs focus means losing
     * the focus.
     * So we only copy the focus class if the device didn't have one,
     * otherwise we leave it as it is.
     */
    if (from->focus)
    {
        if (!to->focus)
        {
            WindowPtr *oldTrace;

            classes = to->unused_classes;
            to->focus = classes->focus;
            if (!to->focus)
            {
                to->focus = calloc(1, sizeof(FocusClassRec));
                if (!to->focus)
                    FatalError("[Xi] no memory for class shift.\n");
            } else
                classes->focus = NULL;

            oldTrace = to->focus->trace;
            memcpy(to->focus, from->focus, sizeof(FocusClassRec));
            to->focus->trace = realloc(oldTrace,
                                  to->focus->traceSize * sizeof(WindowPtr));
            if (!to->focus->trace && to->focus->traceSize)
                FatalError("[Xi] no memory for trace.\n");
            memcpy(to->focus->trace, from->focus->trace,
                    from->focus->traceSize * sizeof(WindowPtr));
            to->focus->sourceid = from->id;
        }
    } else if (to->focus)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->focus = to->focus;
        to->focus      = NULL;
    }

}

static void
DeepCopyPointerClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;

    /* Feedback classes must be copied first */
    if (from->ptrfeed)
    {
        PtrFeedbackPtr *p, it;
        if (!to->ptrfeed)
        {
            classes = to->unused_classes;
            to->ptrfeed = classes->ptrfeed;
            classes->ptrfeed = NULL;
        }

        p = &to->ptrfeed;
        for (it = from->ptrfeed; it; it = it->next)
        {
            if (!(*p))
            {
                *p = calloc(1, sizeof(PtrFeedbackClassRec));
                if (!*p)
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*p)->CtrlProc = it->CtrlProc;
            (*p)->ctrl     = it->ctrl;

            p = &(*p)->next;
        }
    } else if (to->ptrfeed && !from->ptrfeed)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->ptrfeed = to->ptrfeed;
        to->ptrfeed      = NULL;
    }

    if (from->valuator)
    {
        ValuatorClassPtr v;

        if (!to->valuator)
        {
            classes = to->unused_classes;
            to->valuator = classes->valuator;
            if (to->valuator)
                classes->valuator = NULL;
        }

        v = AllocValuatorClass(to->valuator, from->valuator->numAxes);

        if (!v)
            FatalError("[Xi] no memory for class shift.\n");

        to->valuator = v;
        memcpy(v->axes, from->valuator->axes, v->numAxes * sizeof(AxisInfo));

        v->sourceid = from->id;
    } else if (to->valuator && !from->valuator)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->valuator = to->valuator;
        to->valuator      = NULL;
    }

    if (from->button)
    {
        if (!to->button)
        {
            classes = to->unused_classes;
            to->button = classes->button;
            if (!to->button)
            {
                to->button = calloc(1, sizeof(ButtonClassRec));
                if (!to->button)
                    FatalError("[Xi] no memory for class shift.\n");
            } else
                classes->button = NULL;
        }

        if (from->button->xkb_acts)
        {
            if (!to->button->xkb_acts)
            {
                to->button->xkb_acts = calloc(1, sizeof(XkbAction));
                if (!to->button->xkb_acts)
                    FatalError("[Xi] not enough memory for xkb_acts.\n");
            }
            memcpy(to->button->xkb_acts, from->button->xkb_acts,
                    sizeof(XkbAction));
        } else
            free(to->button->xkb_acts);

         memcpy(to->button->labels, from->button->labels,
                from->button->numButtons * sizeof(Atom));
        to->button->sourceid = from->id;
    } else if (to->button && !from->button)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->button = to->button;
        to->button      = NULL;
    }

    if (from->proximity)
    {
        if (!to->proximity)
        {
            classes = to->unused_classes;
            to->proximity = classes->proximity;
            if (!to->proximity)
            {
                to->proximity = calloc(1, sizeof(ProximityClassRec));
                if (!to->proximity)
                    FatalError("[Xi] no memory for class shift.\n");
            } else
                classes->proximity = NULL;
        }
        memcpy(to->proximity, from->proximity, sizeof(ProximityClassRec));
        to->proximity->sourceid = from->id;
    } else if (to->proximity)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->proximity = to->proximity;
        to->proximity      = NULL;
    }
}

/**
 * Copies the CONTENT of the classes of device from into the classes in device
 * to. From and to are identical after finishing.
 *
 * If to does not have classes from currenly has, the classes are stored in
 * to's devPrivates system. Later, we recover it again from there if needed.
 * Saves a few memory allocations.
 */
void
DeepCopyDeviceClasses(DeviceIntPtr from, DeviceIntPtr to, DeviceChangedEvent *dce)
{
    /* generic feedback classes, not tied to pointer and/or keyboard */
    DeepCopyFeedbackClasses(from, to);

    if ((dce->flags & DEVCHANGE_KEYBOARD_EVENT))
        DeepCopyKeyboardClasses(from, to);
    if ((dce->flags & DEVCHANGE_POINTER_EVENT))
        DeepCopyPointerClasses(from, to);
}


/**
 * Send an XI2 DeviceChangedEvent to all interested clients.
 */
void
XISendDeviceChangedEvent(DeviceIntPtr device, DeviceIntPtr master, DeviceChangedEvent *dce)
{
    xXIDeviceChangedEvent *dcce;
    int rc;

    rc = EventToXI2((InternalEvent*)dce, (xEvent**)&dcce);
    if (rc != Success)
    {
        ErrorF("[Xi] event conversion from DCE failed with code %d\n", rc);
        return;
    }

    /* we don't actually swap if there's a NullClient, swapping is done
     * later when event is delivered. */
    SendEventToAllWindows(master, XI_DeviceChangedMask, (xEvent*)dcce, 1);
    free(dcce);
}

static void
ChangeMasterDeviceClasses(DeviceIntPtr device, DeviceChangedEvent *dce)
{
    DeviceIntPtr slave;
    int rc;

    /* For now, we don't have devices that change physically. */
    if (!IsMaster(device))
        return;

    rc = dixLookupDevice(&slave, dce->sourceid, serverClient, DixReadAccess);

    if (rc != Success)
        return; /* Device has disappeared */

    if (IsMaster(slave))
        return;

    if (IsFloating(slave))
        return; /* set floating since the event */

    if (GetMaster(slave, MASTER_ATTACHED)->id != dce->masterid)
        return; /* not our slave anymore, don't care */

    /* FIXME: we probably need to send a DCE for the new slave now */

    device->public.devicePrivate = slave->public.devicePrivate;

    /* FIXME: the classes may have changed since we generated the event. */
    DeepCopyDeviceClasses(slave, device, dce);
    XISendDeviceChangedEvent(slave, device, dce);
}

/**
 * Update the device state according to the data in the event.
 *
 * return values are
 *   DEFAULT ... process as normal
 *   DONT_PROCESS ... return immediately from caller
 */
#define DEFAULT 0
#define DONT_PROCESS 1
int
UpdateDeviceState(DeviceIntPtr device, DeviceEvent* event)
{
    int i;
    int key = 0,
        bit = 0,
        last_valuator;

    KeyClassPtr k       = NULL;
    ButtonClassPtr b    = NULL;
    ValuatorClassPtr v  = NULL;

    /* This event is always the first we get, before the actual events with
     * the data. However, the way how the DDX is set up, "device" will
     * actually be the slave device that caused the event.
     */
    switch(event->type)
    {
        case ET_DeviceChanged:
            ChangeMasterDeviceClasses(device, (DeviceChangedEvent*)event);
            return DONT_PROCESS; /* event has been sent already */
        case ET_Motion:
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ProximityIn:
        case ET_ProximityOut:
            break;
        default:
            /* other events don't update the device */
            return DEFAULT;
    }

    k = device->key;
    v = device->valuator;
    b = device->button;

    key = event->detail.key;
    bit = 1 << (key & 7);

    /* Update device axis */
    /* Check valuators first */
    last_valuator = -1;
    for (i = 0; i < MAX_VALUATORS; i++)
    {
        if (BitIsOn(&event->valuators.mask, i))
        {
            if (!v)
            {
                ErrorF("[Xi] Valuators reported for non-valuator device '%s'. "
                        "Ignoring event.\n", device->name);
                return DONT_PROCESS;
            } else if (v->numAxes < i)
            {
                ErrorF("[Xi] Too many valuators reported for device '%s'. "
                        "Ignoring event.\n", device->name);
                return DONT_PROCESS;
            }
            last_valuator = i;
        }
    }

    for (i = 0; i <= last_valuator && i < v->numAxes; i++)
    {
        if (BitIsOn(&event->valuators.mask, i))
        {
            /* XXX: Relative/Absolute mode */
            v->axisVal[i] = event->valuators.data[i];
            v->axisVal[i] += (event->valuators.data_frac[i] * 1.0f / (1 << 16) / (1 << 16));
        }
    }

    if (event->type == ET_KeyPress) {
        if (!k)
            return DONT_PROCESS;

	/* don't allow ddx to generate multiple downs, but repeats are okay */
	if (key_is_down(device, key, KEY_PROCESSED) && !event->key_repeat)
	    return DONT_PROCESS;

	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
	set_key_down(device, key, KEY_PROCESSED);
    } else if (event->type == ET_KeyRelease) {
        if (!k)
            return DONT_PROCESS;

	if (!key_is_down(device, key, KEY_PROCESSED))	/* guard against duplicates */
	    return DONT_PROCESS;
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
	set_key_up(device, key, KEY_PROCESSED);
    } else if (event->type == ET_ButtonPress) {
        Mask mask;
        if (!b)
            return DONT_PROCESS;

        if (button_is_down(device, key, BUTTON_PROCESSED))
            return DONT_PROCESS;

        set_button_down(device, key, BUTTON_PROCESSED);
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
        if (!b->map[key])
            return DONT_PROCESS;
        b->buttonsDown++;
	b->motionMask = DeviceButtonMotionMask;
        if (b->map[key] <= 5)
	    b->state |= (Button1Mask >> 1) << b->map[key];

        /* Add state and motionMask to the filter for this event */
        mask = DevicePointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, DeviceMotionNotify);
        mask = PointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, MotionNotify);
    } else if (event->type == ET_ButtonRelease) {
        Mask mask;
        if (!b)
            return DONT_PROCESS;

        if (!button_is_down(device, key, BUTTON_PROCESSED))
            return DONT_PROCESS;
        if (IsMaster(device)) {
            DeviceIntPtr sd;

            /*
             * Leave the button down if any slave has the
             * button still down. Note that this depends on the
             * event being delivered through the slave first
             */
            for (sd = inputInfo.devices; sd; sd = sd->next) {
                if (IsMaster(sd) || GetMaster(sd, MASTER_POINTER) != device)
                    continue;
                if (!sd->button)
                    continue;
                for (i = 1; i <= sd->button->numButtons; i++)
                    if (sd->button->map[i] == key &&
                        button_is_down(sd, i, BUTTON_PROCESSED))
                        return DONT_PROCESS;
            }
        }
        set_button_up(device, key, BUTTON_PROCESSED);
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
        if (!b->map[key])
            return DONT_PROCESS;
        if (b->buttonsDown >= 1 && !--b->buttonsDown)
	    b->motionMask = 0;
	if (b->map[key] <= 5)
	    b->state &= ~((Button1Mask >> 1) << b->map[key]);

        /* Add state and motionMask to the filter for this event */
        mask = DevicePointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, DeviceMotionNotify);
        mask = PointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, MotionNotify);
    } else if (event->type == ET_ProximityIn)
	device->proximity->in_proximity = TRUE;
    else if (event->type == ET_ProximityOut)
	device->proximity->in_proximity = FALSE;

    return DEFAULT;
}

/**
 * Main device event processing function.
 * Called from when processing the events from the event queue.
 *
 */
void
ProcessOtherEvent(InternalEvent *ev, DeviceIntPtr device)
{
    GrabPtr grab;
    Bool deactivateDeviceGrab = FALSE;
    int key = 0, rootX, rootY;
    ButtonClassPtr b;
    KeyClassPtr k;
    ValuatorClassPtr v;
    int ret = 0;
    int state, i;
    DeviceIntPtr mouse = NULL, kbd = NULL;
    DeviceEvent *event = &ev->device_event;

    verify_internal_event(ev);

    if (ev->any.type == ET_RawKeyPress ||
        ev->any.type == ET_RawKeyRelease ||
        ev->any.type == ET_RawButtonPress ||
        ev->any.type == ET_RawButtonRelease ||
        ev->any.type == ET_RawMotion)
    {
        DeliverRawEvent(&ev->raw_event, device);
        return;
    }

    if (IsPointerDevice(device))
    {
        kbd = GetPairedDevice(device);
        mouse = device;
        if (!kbd->key) /* can happen with floating SDs */
            kbd = NULL;
    } else
    {
        mouse = GetPairedDevice(device);
        kbd = device;
        if (!mouse->valuator || !mouse->button) /* may be float. SDs */
            mouse = NULL;
    }

    /* State needs to be assembled BEFORE the device is updated. */
    state = (kbd && kbd->key) ? XkbStateFieldFromRec(&kbd->key->xkbInfo->state) : 0;
    state |= (mouse && mouse->button) ? (mouse->button->state) : 0;

    for (i = 0; mouse && mouse->button && i < mouse->button->numButtons; i++)
        if (BitIsOn(mouse->button->down, i))
            SetBit(event->buttons, i);

    if (kbd && kbd->key)
    {
        XkbStatePtr state;
        /* we need the state before the event happens */
        if (event->type == ET_KeyPress || event->type == ET_KeyRelease)
            state = &kbd->key->xkbInfo->prev_state;
        else
            state = &kbd->key->xkbInfo->state;

        event->mods.base = state->base_mods;
        event->mods.latched = state->latched_mods;
        event->mods.locked = state->locked_mods;
        event->mods.effective = state->mods;

        event->group.base = state->base_group;
        event->group.latched = state->latched_group;
        event->group.locked = state->locked_group;
        event->group.effective = state->group;
    }

    ret = UpdateDeviceState(device, event);
    if (ret == DONT_PROCESS)
        return;

    v = device->valuator;
    b = device->button;
    k = device->key;

    if (IsMaster(device) || IsFloating(device))
        CheckMotion(event, device);

    switch (event->type)
    {
        case ET_Motion:
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ProximityIn:
        case ET_ProximityOut:
            GetSpritePosition(device, &rootX, &rootY);
            event->root_x = rootX;
            event->root_y = rootY;
            NoticeEventTime((InternalEvent*)event);
            event->corestate = state;
            key = event->detail.key;
            break;
        default:
            break;
    }

    if (DeviceEventCallback && !syncEvents.playingEvents) {
	DeviceEventInfoRec eventinfo;
	SpritePtr pSprite = device->spriteInfo->sprite;

	/* see comment in EnqueueEvents regarding the next three lines */
	if (ev->any.type == ET_Motion)
	    ev->device_event.root = pSprite->hotPhys.pScreen->root->drawable.id;

	eventinfo.device = device;
	eventinfo.event = ev;
	CallCallbacks(&DeviceEventCallback, (pointer) & eventinfo);
    }

    grab = device->deviceGrab.grab;

    switch(event->type)
    {
        case ET_KeyPress:
            if (!grab && CheckDeviceGrabs(device, event, 0))
                return;
            break;
        case ET_KeyRelease:
            if (grab && device->deviceGrab.fromPassiveGrab &&
                (key == device->deviceGrab.activatingKey) &&
                (device->deviceGrab.grab->type == KeyPress ||
                 device->deviceGrab.grab->type == DeviceKeyPress ||
                 device->deviceGrab.grab->type == XI_KeyPress))
                deactivateDeviceGrab = TRUE;
            break;
        case ET_ButtonPress:
            event->detail.button = b->map[key];
            if (!event->detail.button) { /* there's no button 0 */
                event->detail.button = key;
                return;
            }
            if (!grab && CheckDeviceGrabs(device, event, 0))
            {
                /* if a passive grab was activated, the event has been sent
                 * already */
                return;
            }
            break;
        case ET_ButtonRelease:
            event->detail.button = b->map[key];
            if (!event->detail.button) { /* there's no button 0 */
                event->detail.button = key;
                return;
            }
            if (grab && !b->buttonsDown &&
                device->deviceGrab.fromPassiveGrab &&
                (device->deviceGrab.grab->type == ButtonPress ||
                 device->deviceGrab.grab->type == DeviceButtonPress ||
                 device->deviceGrab.grab->type == XI_ButtonPress))
                deactivateDeviceGrab = TRUE;
        default:
            break;
    }


    if (grab)
        DeliverGrabbedEvent((InternalEvent*)event, device, deactivateDeviceGrab);
    else if (device->focus && !IsPointerEvent((InternalEvent*)ev))
        DeliverFocusedEvent(device, (InternalEvent*)event,
                            GetSpriteWindow(device));
    else
        DeliverDeviceEvents(GetSpriteWindow(device), (InternalEvent*)event,
                            NullGrab, NullWindow, device);

    if (deactivateDeviceGrab == TRUE)
	(*device->deviceGrab.DeactivateGrab) (device);
    event->detail.key = key;
}

int
InitProximityClassDeviceStruct(DeviceIntPtr dev)
{
    ProximityClassPtr proxc;

    proxc = (ProximityClassPtr) malloc(sizeof(ProximityClassRec));
    if (!proxc)
	return FALSE;
    proxc->sourceid = dev->id;
    proxc->in_proximity = TRUE;
    dev->proximity = proxc;
    return TRUE;
}

/**
 * Initialise the device's valuators. The memory must already be allocated,
 * this function merely inits the matching axis (specified through axnum) to
 * sane values.
 *
 * It is a condition that (minval < maxval).
 *
 * @see InitValuatorClassDeviceStruct
 */
void
InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval, int maxval,
		       int resolution, int min_res, int max_res, int mode)
{
    AxisInfoPtr ax;

    if (!dev || !dev->valuator || minval > maxval)
        return;
    if (axnum >= dev->valuator->numAxes)
        return;

    ax = dev->valuator->axes + axnum;

    ax->min_value = minval;
    ax->max_value = maxval;
    ax->resolution = resolution;
    ax->min_resolution = min_res;
    ax->max_resolution = max_res;
    ax->label = label;
    ax->mode = mode;

    if (mode & OutOfProximity)
        dev->proximity->in_proximity = FALSE;
}

static void
FixDeviceStateNotify(DeviceIntPtr dev, deviceStateNotify * ev, KeyClassPtr k,
		     ButtonClassPtr b, ValuatorClassPtr v, int first)
{
    ev->type = DeviceStateNotify;
    ev->deviceid = dev->id;
    ev->time = currentTime.milliseconds;
    ev->classes_reported = 0;
    ev->num_keys = 0;
    ev->num_buttons = 0;
    ev->num_valuators = 0;

    if (b) {
	ev->classes_reported |= (1 << ButtonClass);
	ev->num_buttons = b->numButtons;
	memcpy((char*)ev->buttons, (char*)b->down, 4);
    } else if (k) {
	ev->classes_reported |= (1 << KeyClass);
	ev->num_keys = k->xkbInfo->desc->max_key_code -
                       k->xkbInfo->desc->min_key_code;
	memmove((char *)&ev->keys[0], (char *)k->down, 4);
    }
    if (v) {
	int nval = v->numAxes - first;

	ev->classes_reported |= (1 << ValuatorClass);
	ev->classes_reported |= valuator_get_mode(dev, 0) << ModeBitsShift;
	ev->num_valuators = nval < 3 ? nval : 3;
	switch (ev->num_valuators) {
	case 3:
	    ev->valuator2 = v->axisVal[first + 2];
	case 2:
	    ev->valuator1 = v->axisVal[first + 1];
	case 1:
	    ev->valuator0 = v->axisVal[first];
	    break;
	}
    }
}

static void
FixDeviceValuator(DeviceIntPtr dev, deviceValuator * ev, ValuatorClassPtr v,
		  int first)
{
    int nval = v->numAxes - first;

    ev->type = DeviceValuator;
    ev->deviceid = dev->id;
    ev->num_valuators = nval < 3 ? nval : 3;
    ev->first_valuator = first;
    switch (ev->num_valuators) {
    case 3:
	ev->valuator2 = v->axisVal[first + 2];
    case 2:
	ev->valuator1 = v->axisVal[first + 1];
    case 1:
	ev->valuator0 = v->axisVal[first];
	break;
    }
    first += ev->num_valuators;
}

static void
DeliverStateNotifyEvent(DeviceIntPtr dev, WindowPtr win)
{
    int evcount = 1;
    deviceStateNotify *ev, *sev;
    deviceKeyStateNotify *kev;
    deviceButtonStateNotify *bev;

    KeyClassPtr k;
    ButtonClassPtr b;
    ValuatorClassPtr v;
    int nval = 0, nkeys = 0, nbuttons = 0, first = 0;

    if (!(wOtherInputMasks(win)) ||
        !(wOtherInputMasks(win)->inputEvents[dev->id] & DeviceStateNotifyMask))
        return;

    if ((b = dev->button) != NULL) {
        nbuttons = b->numButtons;
        if (nbuttons > 32)
            evcount++;
    }
    if ((k = dev->key) != NULL) {
        nkeys = k->xkbInfo->desc->max_key_code -
            k->xkbInfo->desc->min_key_code;
        if (nkeys > 32)
            evcount++;
        if (nbuttons > 0) {
            evcount++;
        }
    }
    if ((v = dev->valuator) != NULL) {
        nval = v->numAxes;

        if (nval > 3)
            evcount++;
        if (nval > 6) {
            if (!(k && b))
                evcount++;
            if (nval > 9)
                evcount += ((nval - 7) / 3);
        }
    }

    sev = ev = (deviceStateNotify *) malloc(evcount * sizeof(xEvent));
    FixDeviceStateNotify(dev, ev, NULL, NULL, NULL, first);

    if (b != NULL) {
        FixDeviceStateNotify(dev, ev++, NULL, b, v, first);
        first += 3;
        nval -= 3;
        if (nbuttons > 32) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            bev = (deviceButtonStateNotify *) ev++;
            bev->type = DeviceButtonStateNotify;
            bev->deviceid = dev->id;
            memcpy((char*)&bev->buttons[4], (char*)&b->down[4], DOWN_LENGTH - 4);
        }
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    if (k != NULL) {
        FixDeviceStateNotify(dev, ev++, k, NULL, v, first);
        first += 3;
        nval -= 3;
        if (nkeys > 32) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            kev = (deviceKeyStateNotify *) ev++;
            kev->type = DeviceKeyStateNotify;
            kev->deviceid = dev->id;
            memmove((char *)&kev->keys[0], (char *)&k->down[4], 28);
        }
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    while (nval > 0) {
        FixDeviceStateNotify(dev, ev++, NULL, NULL, v, first);
        first += 3;
        nval -= 3;
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    DeliverEventsToWindow(dev, win, (xEvent *) sev, evcount,
                          DeviceStateNotifyMask, NullGrab);
    free(sev);
}

void
DeviceFocusEvent(DeviceIntPtr dev, int type, int mode, int detail,
		 WindowPtr pWin)
{
    deviceFocus event;
    xXIFocusInEvent *xi2event;
    DeviceIntPtr mouse;
    int btlen, len, i;

    mouse = IsFloating(dev) ? dev : GetMaster(dev, MASTER_POINTER);

    /* XI 2 event */
    btlen = (mouse->button) ? bits_to_bytes(mouse->button->numButtons) : 0;
    btlen = bytes_to_int32(btlen);
    len = sizeof(xXIFocusInEvent) + btlen * 4;

    xi2event = calloc(1, len);
    xi2event->type         = GenericEvent;
    xi2event->extension    = IReqCode;
    xi2event->evtype       = type;
    xi2event->length       = bytes_to_int32(len - sizeof(xEvent));
    xi2event->buttons_len  = btlen;
    xi2event->detail       = detail;
    xi2event->time         = currentTime.milliseconds;
    xi2event->deviceid     = dev->id;
    xi2event->sourceid     = dev->id; /* a device doesn't change focus by itself */
    xi2event->mode         = mode;
    xi2event->root_x       = FP1616(mouse->spriteInfo->sprite->hot.x, 0);
    xi2event->root_y       = FP1616(mouse->spriteInfo->sprite->hot.y, 0);

    for (i = 0; mouse && mouse->button && i < mouse->button->numButtons; i++)
        if (BitIsOn(mouse->button->down, i))
            SetBit(&xi2event[1], i);

    if (dev->key)
    {
        xi2event->mods.base_mods = dev->key->xkbInfo->state.base_mods;
        xi2event->mods.latched_mods = dev->key->xkbInfo->state.latched_mods;
        xi2event->mods.locked_mods = dev->key->xkbInfo->state.locked_mods;
        xi2event->mods.effective_mods = dev->key->xkbInfo->state.mods;

        xi2event->group.base_group = dev->key->xkbInfo->state.base_group;
        xi2event->group.latched_group = dev->key->xkbInfo->state.latched_group;
        xi2event->group.locked_group = dev->key->xkbInfo->state.locked_group;
        xi2event->group.effective_group = dev->key->xkbInfo->state.group;
    }

    FixUpEventFromWindow(dev->spriteInfo->sprite, (xEvent*)xi2event, pWin,
                         None, FALSE);

    DeliverEventsToWindow(dev, pWin, (xEvent*)xi2event, 1,
                          GetEventFilter(dev, (xEvent*)xi2event), NullGrab);

    free(xi2event);

    /* XI 1.x event */
    event.deviceid = dev->id;
    event.mode = mode;
    event.type = (type == XI_FocusIn) ? DeviceFocusIn : DeviceFocusOut;
    event.detail = detail;
    event.window = pWin->drawable.id;
    event.time = currentTime.milliseconds;

    DeliverEventsToWindow(dev, pWin, (xEvent *) & event, 1,
				DeviceFocusChangeMask, NullGrab);

    if (event.type == DeviceFocusIn)
        DeliverStateNotifyEvent(dev, pWin);
}

int
CheckGrabValues(ClientPtr client, GrabParameters* param)
{
    if (param->grabtype != GRABTYPE_CORE &&
        param->grabtype != GRABTYPE_XI &&
        param->grabtype != GRABTYPE_XI2)
    {
        ErrorF("[Xi] grabtype is invalid. This is a bug.\n");
        return BadImplementation;
    }

    if ((param->this_device_mode != GrabModeSync) &&
	(param->this_device_mode != GrabModeAsync)) {
	client->errorValue = param->this_device_mode;
	return BadValue;
    }
    if ((param->other_devices_mode != GrabModeSync) &&
	(param->other_devices_mode != GrabModeAsync)) {
	client->errorValue = param->other_devices_mode;
	return BadValue;
    }

    if (param->grabtype != GRABTYPE_XI2 && (param->modifiers != AnyModifier) &&
        (param->modifiers & ~AllModifiersMask)) {
	client->errorValue = param->modifiers;
	return BadValue;
    }

    if ((param->ownerEvents != xFalse) && (param->ownerEvents != xTrue)) {
	client->errorValue = param->ownerEvents;
	return BadValue;
    }
    return Success;
}

int
GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
           int button, GrabParameters *param, GrabType grabtype,
	   GrabMask *mask)
{
    WindowPtr pWin, confineTo;
    CursorPtr cursor;
    GrabPtr grab;
    int rc, type = -1;
    Mask access_mode = DixGrabAccess;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
	return rc;
    if (param->confineTo == None)
	confineTo = NullWindow;
    else {
	rc = dixLookupWindow(&confineTo, param->confineTo, client, DixSetAttrAccess);
	if (rc != Success)
	    return rc;
    }
    if (param->cursor == None)
	cursor = NullCursor;
    else {
	rc = dixLookupResourceByType((pointer *)&cursor, param->cursor,
				     RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = param->cursor;
	    return rc;
	}
	access_mode |= DixForceAccess;
    }
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
	return rc;
    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if (grabtype == GRABTYPE_XI)
        type = DeviceButtonPress;
    else if (grabtype == GRABTYPE_XI2)
        type = XI_ButtonPress;

    grab = CreateGrab(client->index, dev, modifier_device, pWin, grabtype,
                      mask, param, type, button, confineTo, cursor);
    if (!grab)
	return BadAlloc;
    return AddPassiveGrabToList(client, grab);
}

/**
 * Grab the given key. If grabtype is GRABTYPE_XI, the key is a keycode. If
 * grabtype is GRABTYPE_XI2, the key is a keysym.
 */
int
GrabKey(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
        int key, GrabParameters *param, GrabType grabtype, GrabMask *mask)
{
    WindowPtr pWin;
    GrabPtr grab;
    KeyClassPtr k = dev->key;
    Mask access_mode = DixGrabAccess;
    int rc, type = -1;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
        return rc;
    if (k == NULL)
	return BadMatch;
    if (grabtype == GRABTYPE_XI)
    {
        if ((key > k->xkbInfo->desc->max_key_code ||
                    key < k->xkbInfo->desc->min_key_code)
                && (key != AnyKey)) {
            client->errorValue = key;
            return BadValue;
        }
        type = DeviceKeyPress;
    } else if (grabtype == GRABTYPE_XI2)
        type = XI_KeyPress;

    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
	return rc;

    grab = CreateGrab(client->index, dev, modifier_device, pWin, grabtype,
                      mask, param, type, key, NULL, NULL);
    if (!grab)
	return BadAlloc;
    return AddPassiveGrabToList(client, grab);
}

/* Enter/FocusIn grab */
int
GrabWindow(ClientPtr client, DeviceIntPtr dev, int type,
           GrabParameters *param, GrabMask *mask)
{
    WindowPtr pWin;
    CursorPtr cursor;
    GrabPtr grab;
    Mask access_mode = DixGrabAccess;
    int rc;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
        return rc;

    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (param->cursor == None)
	cursor = NullCursor;
    else {
	rc = dixLookupResourceByType((pointer *)&cursor, param->cursor,
				     RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = param->cursor;
	    return rc;
	}
	access_mode |= DixForceAccess;
    }
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
	return rc;

    grab = CreateGrab(client->index, dev, dev, pWin, GRABTYPE_XI2,
                      mask, param, (type == XIGrabtypeEnter) ? XI_Enter : XI_FocusIn,
                      0, NULL, cursor);

    if (!grab)
        return BadAlloc;

    return AddPassiveGrabToList(client, grab);
}

int
SelectForWindow(DeviceIntPtr dev, WindowPtr pWin, ClientPtr client,
		Mask mask, Mask exclusivemasks)
{
    int mskidx = dev->id;
    int i, ret;
    Mask check;
    InputClientsPtr others;

    check = (mask & exclusivemasks);
    if (wOtherInputMasks(pWin)) {
	if (check & wOtherInputMasks(pWin)->inputEvents[mskidx]) {	/* It is illegal for two different
									 * clients to select on any of the
									 * events for maskcheck. However,
									 * it is OK, for some client to
									 * continue selecting on one of those
									 * events.  */
	    for (others = wOtherInputMasks(pWin)->inputClients; others;
		 others = others->next) {
		if (!SameClient(others, client) && (check &
						    others->mask[mskidx]))
		    return BadAccess;
	    }
	}
	for (others = wOtherInputMasks(pWin)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
		check = others->mask[mskidx];
		others->mask[mskidx] = mask;
		if (mask == 0) {
		    for (i = 0; i < EMASKSIZE; i++)
			if (i != mskidx && others->mask[i] != 0)
			    break;
		    if (i == EMASKSIZE) {
			RecalculateDeviceDeliverableEvents(pWin);
			if (ShouldFreeInputMasks(pWin, FALSE))
			    FreeResource(others->resource, RT_NONE);
			return Success;
		    }
		}
		goto maskSet;
	    }
	}
    }
    check = 0;
    if ((ret = AddExtensionClient(pWin, client, mask, mskidx)) != Success)
	return ret;
  maskSet:
    if (dev->valuator)
	if ((dev->valuator->motionHintWindow == pWin) &&
	    (mask & DevicePointerMotionHintMask) &&
	    !(check & DevicePointerMotionHintMask) && !dev->deviceGrab.grab)
	    dev->valuator->motionHintWindow = NullWindow;
    RecalculateDeviceDeliverableEvents(pWin);
    return Success;
}

int
AddExtensionClient(WindowPtr pWin, ClientPtr client, Mask mask, int mskidx)
{
    InputClientsPtr others;

    if (!pWin->optional && !MakeWindowOptional(pWin))
	return BadAlloc;
    others = calloc(1, sizeof(InputClients));
    if (!others)
	return BadAlloc;
    if (!pWin->optional->inputMasks && !MakeInputMasks(pWin))
	goto bail;
    others->mask[mskidx] = mask;
    others->resource = FakeClientID(client->index);
    others->next = pWin->optional->inputMasks->inputClients;
    pWin->optional->inputMasks->inputClients = others;
    if (!AddResource(others->resource, RT_INPUTCLIENT, (pointer) pWin))
	goto bail;
    return Success;

bail:
    free(others);
    return BadAlloc;
}

static Bool
MakeInputMasks(WindowPtr pWin)
{
    struct _OtherInputMasks *imasks;

    imasks = calloc(1, sizeof(struct _OtherInputMasks));
    if (!imasks)
	return FALSE;
    pWin->optional->inputMasks = imasks;
    return TRUE;
}

void
RecalculateDeviceDeliverableEvents(WindowPtr pWin)
{
    InputClientsPtr others;
    struct _OtherInputMasks *inputMasks;	/* default: NULL */
    WindowPtr pChild, tmp;
    int i, j;

    pChild = pWin;
    while (1) {
	if ((inputMasks = wOtherInputMasks(pChild)) != 0) {
            for (i = 0; i < EMASKSIZE; i++)
                memset(inputMasks->xi2mask[i], 0, sizeof(inputMasks->xi2mask[i]));
	    for (others = inputMasks->inputClients; others;
		 others = others->next) {
		for (i = 0; i < EMASKSIZE; i++)
		    inputMasks->inputEvents[i] |= others->mask[i];
                for (i = 0; i < EMASKSIZE; i++)
                    for (j = 0; j < XI2MASKSIZE; j++)
                        inputMasks->xi2mask[i][j] |= others->xi2mask[i][j];
	    }
	    for (i = 0; i < EMASKSIZE; i++)
		inputMasks->deliverableEvents[i] = inputMasks->inputEvents[i];
	    for (tmp = pChild->parent; tmp; tmp = tmp->parent)
		if (wOtherInputMasks(tmp))
		    for (i = 0; i < EMASKSIZE; i++)
			inputMasks->deliverableEvents[i] |=
			    (wOtherInputMasks(tmp)->deliverableEvents[i]
			     & ~inputMasks->
			     dontPropagateMask[i] & PropagateMask[i]);
	}
	if (pChild->firstChild) {
	    pChild = pChild->firstChild;
	    continue;
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    break;
	pChild = pChild->nextSib;
    }
}

int
InputClientGone(WindowPtr pWin, XID id)
{
    InputClientsPtr other, prev;

    if (!wOtherInputMasks(pWin))
	return Success;
    prev = 0;
    for (other = wOtherInputMasks(pWin)->inputClients; other;
	 other = other->next) {
	if (other->resource == id) {
	    if (prev) {
		prev->next = other->next;
		free(other);
	    } else if (!(other->next)) {
		if (ShouldFreeInputMasks(pWin, TRUE)) {
		    wOtherInputMasks(pWin)->inputClients = other->next;
		    free(wOtherInputMasks(pWin));
		    pWin->optional->inputMasks = (OtherInputMasks *) NULL;
		    CheckWindowOptionalNeed(pWin);
		    free(other);
		} else {
		    other->resource = FakeClientID(0);
		    if (!AddResource(other->resource, RT_INPUTCLIENT,
				     (pointer) pWin))
			return BadAlloc;
		}
	    } else {
		wOtherInputMasks(pWin)->inputClients = other->next;
		free(other);
	    }
	    RecalculateDeviceDeliverableEvents(pWin);
	    return Success;
	}
	prev = other;
    }
    FatalError("client not on device event list");
}

int
SendEvent(ClientPtr client, DeviceIntPtr d, Window dest, Bool propagate,
	  xEvent * ev, Mask mask, int count)
{
    WindowPtr pWin;
    WindowPtr effectiveFocus = NullWindow;	/* only set if dest==InputFocus */
    WindowPtr spriteWin = GetSpriteWindow(d);

    if (dest == PointerWindow)
	pWin = spriteWin;
    else if (dest == InputFocus) {
	WindowPtr inputFocus;

	if (!d->focus)
	    inputFocus = spriteWin;
	else
	    inputFocus = d->focus->win;

	if (inputFocus == FollowKeyboardWin)
	    inputFocus = inputInfo.keyboard->focus->win;

	if (inputFocus == NoneWin)
	    return Success;

	/* If the input focus is PointerRootWin, send the event to where
	 * the pointer is if possible, then perhaps propogate up to root. */
	if (inputFocus == PointerRootWin)
	    inputFocus = GetCurrentRootWindow(d);

	if (IsParent(inputFocus, spriteWin)) {
	    effectiveFocus = inputFocus;
	    pWin = spriteWin;
	} else
	    effectiveFocus = pWin = inputFocus;
    } else
	dixLookupWindow(&pWin, dest, client, DixSendAccess);
    if (!pWin)
	return BadWindow;
    if ((propagate != xFalse) && (propagate != xTrue)) {
	client->errorValue = propagate;
	return BadValue;
    }
    ev->u.u.type |= 0x80;
    if (propagate) {
	for (; pWin; pWin = pWin->parent) {
	    if (DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab))
		return Success;
	    if (pWin == effectiveFocus)
		return Success;
	    if (wOtherInputMasks(pWin))
		mask &= ~wOtherInputMasks(pWin)->dontPropagateMask[d->id];
	    if (!mask)
		break;
	}
    } else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, ev, count))
	DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab);
    return Success;
}

int
SetButtonMapping(ClientPtr client, DeviceIntPtr dev, int nElts, BYTE * map)
{
    int i;
    ButtonClassPtr b = dev->button;

    if (b == NULL)
	return BadMatch;

    if (nElts != b->numButtons) {
	client->errorValue = nElts;
	return BadValue;
    }
    if (BadDeviceMap(&map[0], nElts, 1, 255, &client->errorValue))
	return BadValue;
    for (i = 0; i < nElts; i++)
	if ((b->map[i + 1] != map[i]) && BitIsOn(b->down, i + 1))
	    return MappingBusy;
    for (i = 0; i < nElts; i++)
	b->map[i + 1] = map[i];
    return Success;
}

int
ChangeKeyMapping(ClientPtr client,
		 DeviceIntPtr dev,
		 unsigned len,
		 int type,
		 KeyCode firstKeyCode,
		 CARD8 keyCodes, CARD8 keySymsPerKeyCode, KeySym * map)
{
    KeySymsRec keysyms;
    KeyClassPtr k = dev->key;

    if (k == NULL)
	return BadMatch;

    if (len != (keyCodes * keySymsPerKeyCode))
	return BadLength;

    if ((firstKeyCode < k->xkbInfo->desc->min_key_code) ||
	(firstKeyCode + keyCodes - 1 > k->xkbInfo->desc->max_key_code)) {
	client->errorValue = firstKeyCode;
	return BadValue;
    }
    if (keySymsPerKeyCode == 0) {
	client->errorValue = 0;
	return BadValue;
    }
    keysyms.minKeyCode = firstKeyCode;
    keysyms.maxKeyCode = firstKeyCode + keyCodes - 1;
    keysyms.mapWidth = keySymsPerKeyCode;
    keysyms.map = map;

    XkbApplyMappingChange(dev, &keysyms, firstKeyCode, keyCodes, NULL,
                          serverClient);

    return Success;
}

static void
DeleteDeviceFromAnyExtEvents(WindowPtr pWin, DeviceIntPtr dev)
{
    WindowPtr parent;

    /* Deactivate any grabs performed on this window, before making
     * any input focus changes.
     * Deactivating a device grab should cause focus events. */

    if (dev->deviceGrab.grab && (dev->deviceGrab.grab->window == pWin))
	(*dev->deviceGrab.DeactivateGrab) (dev);

    /* If the focus window is a root window (ie. has no parent)
     * then don't delete the focus from it. */

    if (dev->focus && (pWin == dev->focus->win) && (pWin->parent != NullWindow)) {
	int focusEventMode = NotifyNormal;

	/* If a grab is in progress, then alter the mode of focus events. */

	if (dev->deviceGrab.grab)
	    focusEventMode = NotifyWhileGrabbed;

	switch (dev->focus->revert) {
	case RevertToNone:
	    if (!ActivateFocusInGrab(dev, pWin, NoneWin))
		DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
	    dev->focus->win = NoneWin;
	    dev->focus->traceGood = 0;
	    break;
	case RevertToParent:
	    parent = pWin;
	    do {
		parent = parent->parent;
		dev->focus->traceGood--;
	    }
	    while (!parent->realized);
	    if (!ActivateFocusInGrab(dev, pWin, parent))
		DoFocusEvents(dev, pWin, parent, focusEventMode);
	    dev->focus->win = parent;
	    dev->focus->revert = RevertToNone;
	    break;
	case RevertToPointerRoot:
	    if (!ActivateFocusInGrab(dev, pWin, PointerRootWin))
		DoFocusEvents(dev, pWin, PointerRootWin, focusEventMode);
	    dev->focus->win = PointerRootWin;
	    dev->focus->traceGood = 0;
	    break;
	case RevertToFollowKeyboard:
            {
                DeviceIntPtr kbd = GetMaster(dev, MASTER_KEYBOARD);
                if (!kbd || (kbd == dev && kbd != inputInfo.keyboard))
                    kbd = inputInfo.keyboard;
	    if (kbd->focus->win) {
		if (!ActivateFocusInGrab(dev, pWin, kbd->focus->win))
		    DoFocusEvents(dev, pWin, kbd->focus->win, focusEventMode);
		dev->focus->win = FollowKeyboardWin;
		dev->focus->traceGood = 0;
	    } else {
                if (!ActivateFocusInGrab(dev, pWin, NoneWin))
                    DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
		dev->focus->win = NoneWin;
		dev->focus->traceGood = 0;
	    }
            }
	    break;
	}
    }

    if (dev->valuator)
	if (dev->valuator->motionHintWindow == pWin)
	    dev->valuator->motionHintWindow = NullWindow;
}

void
DeleteWindowFromAnyExtEvents(WindowPtr pWin, Bool freeResources)
{
    int i;
    DeviceIntPtr dev;
    InputClientsPtr ic;
    struct _OtherInputMasks *inputMasks;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
	DeleteDeviceFromAnyExtEvents(pWin, dev);
    }

    for (dev = inputInfo.off_devices; dev; dev = dev->next)
	DeleteDeviceFromAnyExtEvents(pWin, dev);

    if (freeResources)
	while ((inputMasks = wOtherInputMasks(pWin)) != 0) {
	    ic = inputMasks->inputClients;
	    for (i = 0; i < EMASKSIZE; i++)
		inputMasks->dontPropagateMask[i] = 0;
	    FreeResource(ic->resource, RT_NONE);
	}
}

int
MaybeSendDeviceMotionNotifyHint(deviceKeyButtonPointer * pEvents, Mask mask)
{
    DeviceIntPtr dev;

    dixLookupDevice(&dev, pEvents->deviceid & DEVICE_BITS, serverClient,
		    DixReadAccess);
    if (!dev)
        return 0;

    if (pEvents->type == DeviceMotionNotify) {
	if (mask & DevicePointerMotionHintMask) {
	    if (WID(dev->valuator->motionHintWindow) == pEvents->event) {
		return 1;	/* don't send, but pretend we did */
	    }
	    pEvents->detail = NotifyHint;
	} else {
	    pEvents->detail = NotifyNormal;
	}
    }
    return 0;
}

void
CheckDeviceGrabAndHintWindow(WindowPtr pWin, int type,
			     deviceKeyButtonPointer * xE, GrabPtr grab,
			     ClientPtr client, Mask deliveryMask)
{
    DeviceIntPtr dev;

    dixLookupDevice(&dev, xE->deviceid & DEVICE_BITS, serverClient,
		    DixGrabAccess);
    if (!dev)
        return;

    if (type == DeviceMotionNotify)
	dev->valuator->motionHintWindow = pWin;
    else if ((type == DeviceButtonPress) && (!grab) &&
	     (deliveryMask & DeviceButtonGrabMask)) {
	GrabRec tempGrab;

	tempGrab.device = dev;
	tempGrab.resource = client->clientAsMask;
	tempGrab.window = pWin;
	tempGrab.ownerEvents =
	    (deliveryMask & DeviceOwnerGrabButtonMask) ? TRUE : FALSE;
	tempGrab.eventMask = deliveryMask;
	tempGrab.keyboardMode = GrabModeAsync;
	tempGrab.pointerMode = GrabModeAsync;
	tempGrab.confineTo = NullWindow;
	tempGrab.cursor = NullCursor;
        tempGrab.next = NULL;
	(*dev->deviceGrab.ActivateGrab) (dev, &tempGrab, currentTime, TRUE);
    }
}

static Mask
DeviceEventMaskForClient(DeviceIntPtr dev, WindowPtr pWin, ClientPtr client)
{
    InputClientsPtr other;

    if (!wOtherInputMasks(pWin))
	return 0;
    for (other = wOtherInputMasks(pWin)->inputClients; other;
	 other = other->next) {
	if (SameClient(other, client))
	    return other->mask[dev->id];
    }
    return 0;
}

void
MaybeStopDeviceHint(DeviceIntPtr dev, ClientPtr client)
{
    WindowPtr pWin;
    GrabPtr grab = dev->deviceGrab.grab;

    pWin = dev->valuator->motionHintWindow;

    if ((grab && SameClient(grab, client) &&
	 ((grab->eventMask & DevicePointerMotionHintMask) ||
	  (grab->ownerEvents &&
	   (DeviceEventMaskForClient(dev, pWin, client) &
	    DevicePointerMotionHintMask)))) ||
	(!grab &&
	 (DeviceEventMaskForClient(dev, pWin, client) &
	  DevicePointerMotionHintMask)))
	dev->valuator->motionHintWindow = NullWindow;
}

int
DeviceEventSuppressForWindow(WindowPtr pWin, ClientPtr client, Mask mask,
			     int maskndx)
{
    struct _OtherInputMasks *inputMasks = wOtherInputMasks(pWin);

    if (mask & ~PropagateMask[maskndx]) {
	client->errorValue = mask;
	return BadValue;
    }

    if (mask == 0) {
	if (inputMasks)
	    inputMasks->dontPropagateMask[maskndx] = mask;
    } else {
	if (!inputMasks)
	    AddExtensionClient(pWin, client, 0, 0);
	inputMasks = wOtherInputMasks(pWin);
	inputMasks->dontPropagateMask[maskndx] = mask;
    }
    RecalculateDeviceDeliverableEvents(pWin);
    if (ShouldFreeInputMasks(pWin, FALSE))
	FreeResource(inputMasks->inputClients->resource, RT_NONE);
    return Success;
}

Bool
ShouldFreeInputMasks(WindowPtr pWin, Bool ignoreSelectedEvents)
{
    int i;
    Mask allInputEventMasks = 0;
    struct _OtherInputMasks *inputMasks = wOtherInputMasks(pWin);

    for (i = 0; i < EMASKSIZE; i++)
	allInputEventMasks |= inputMasks->dontPropagateMask[i];
    if (!ignoreSelectedEvents)
	for (i = 0; i < EMASKSIZE; i++)
	    allInputEventMasks |= inputMasks->inputEvents[i];
    if (allInputEventMasks == 0)
	return TRUE;
    else
	return FALSE;
}

/***********************************************************************
 *
 * Walk through the window tree, finding all clients that want to know
 * about the Event.
 *
 */

static void
FindInterestedChildren(DeviceIntPtr dev, WindowPtr p1, Mask mask,
                       xEvent * ev, int count)
{
    WindowPtr p2;

    while (p1) {
        p2 = p1->firstChild;
        DeliverEventsToWindow(dev, p1, ev, count, mask, NullGrab);
        FindInterestedChildren(dev, p2, mask, ev, count);
        p1 = p1->nextSib;
    }
}

/***********************************************************************
 *
 * Send an event to interested clients in all windows on all screens.
 *
 */

void
SendEventToAllWindows(DeviceIntPtr dev, Mask mask, xEvent * ev, int count)
{
    int i;
    WindowPtr pWin, p1;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pWin = screenInfo.screens[i]->root;
        if (!pWin)
            continue;
        DeliverEventsToWindow(dev, pWin, ev, count, mask, NullGrab);
        p1 = pWin->firstChild;
        FindInterestedChildren(dev, p1, mask, ev, count);
    }
}

/**
 * Set the XI2 mask for the given client on the given window.
 * @param dev The device to set the mask for.
 * @param win The window to set the mask on.
 * @param client The client setting the mask.
 * @param len Number of bytes in mask.
 * @param mask Event mask in the form of (1 << eventtype)
 */
int
XISetEventMask(DeviceIntPtr dev, WindowPtr win, ClientPtr client,
               unsigned int len, unsigned char* mask)
{
    OtherInputMasks *masks;
    InputClientsPtr others = NULL;

    masks = wOtherInputMasks(win);
    if (masks)
    {
	for (others = wOtherInputMasks(win)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
                memset(others->xi2mask[dev->id], 0,
                       sizeof(others->xi2mask[dev->id]));
                break;
            }
        }
    }

    len = min(len, sizeof(others->xi2mask[dev->id]));

    if (len && !others)
    {
        if (AddExtensionClient(win, client, 0, 0) != Success)
            return BadAlloc;
        others= wOtherInputMasks(win)->inputClients;
    }

    if (others)
        memset(others->xi2mask[dev->id], 0, sizeof(others->xi2mask[dev->id]));

    if (len)
        memcpy(others->xi2mask[dev->id], mask, len);

    RecalculateDeviceDeliverableEvents(win);

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

/*****************************************************************
 *
 * Globals referenced elsewhere in the server.
 *
 */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif
#include "privates.h"

#ifndef EXGLOBALS_H
#define EXGLOBALS_H 1

extern int IReqCode;
extern int IEventBase;
extern int BadDevice;
extern int BadMode;
extern int DeviceBusy;
extern int BadClass;

/* Note: only the ones needed in files other than extinit.c are declared */
extern const Mask DevicePointerMotionMask;
extern const Mask DevicePointerMotionHintMask;
extern const Mask DeviceFocusChangeMask;
extern const Mask DeviceStateNotifyMask;
extern const Mask DeviceMappingNotifyMask;
extern const Mask DeviceOwnerGrabButtonMask;
extern const Mask DeviceButtonGrabMask;
extern const Mask DeviceButtonMotionMask;
extern const Mask DevicePresenceNotifyMask;
extern const Mask DevicePropertyNotifyMask;
extern const Mask XIAllMasks;

extern Mask PropagateMask[];

extern int DeviceValuator;
extern int DeviceKeyPress;
extern int DeviceKeyRelease;
extern int DeviceButtonPress;
extern int DeviceButtonRelease;
extern int DeviceMotionNotify;
extern int DeviceFocusIn;
extern int DeviceFocusOut;
extern int ProximityIn;
extern int ProximityOut;
extern int DeviceStateNotify;
extern int DeviceKeyStateNotify;
extern int DeviceButtonStateNotify;
extern int DeviceMappingNotify;
extern int ChangeDeviceNotify;
extern int DevicePresenceNotify;
extern int DevicePropertyNotify;

extern RESTYPE RT_INPUTCLIENT;

extern DevPrivateKeyRec XIClientPrivateKeyRec;
#define XIClientPrivateKey (&XIClientPrivateKeyRec)

#endif /* EXGLOBALS_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Dispatch routines and initialization routines for the X input extension.
 *
 */
#define ARRAY_SIZE(_a)        (sizeof((_a)) / sizeof((_a)[0]))

#define	 NUMTYPES 15

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"
#include "gcstruct.h"	/* pointer for extnsionst.h */
#include "extnsionst.h"	/* extension entry   */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/geproto.h>
#include "geext.h" /* extension interfaces for ge */

#include "dixevents.h"
#include "exevents.h"
#include "extinit.h"
#include "exglobals.h"
#include "swaprep.h"
#include "privates.h"
#include "protocol-versions.h"

/* modules local to Xi */
#include "allowev.h"
#include "chgdctl.h"
#include "chgfctl.h"
#include "chgkbd.h"
#include "chgprop.h"
#include "chgptr.h"
#include "closedev.h"
#include "devbell.h"
#include "getbmap.h"
#include "getdctl.h"
#include "getfctl.h"
#include "getfocus.h"
#include "getkmap.h"
#include "getmmap.h"
#include "getprop.h"
#include "getselev.h"
#include "getvers.h"
#include "grabdev.h"
#include "grabdevb.h"
#include "grabdevk.h"
#include "gtmotion.h"
#include "listdev.h"
#include "opendev.h"
#include "queryst.h"
#include "selectev.h"
#include "sendexev.h"
#include "chgkmap.h"
#include "setbmap.h"
#include "setdval.h"
#include "setfocus.h"
#include "setmmap.h"
#include "setmode.h"
#include "ungrdev.h"
#include "ungrdevb.h"
#include "ungrdevk.h"
#include "xiallowev.h"
#include "xiselectev.h"
#include "xigrabdev.h"
#include "xipassivegrab.h"
#include "xisetdevfocus.h"
#include "xiproperty.h"
#include "xichangecursor.h"
#include "xichangehierarchy.h"
#include "xigetclientpointer.h"
#include "xiquerydevice.h"
#include "xiquerypointer.h"
#include "xiqueryversion.h"
#include "xisetclientpointer.h"
#include "xiwarppointer.h"


/* Masks for XI events have to be aligned with core event (partially anyway).
 * If DeviceButtonMotionMask is != ButtonMotionMask, event delivery
 * breaks down. The device needs the dev->button->motionMask. If DBMM is
 * the same as BMM, we can ensure that both core and device events can be
 * delivered, without the need for extra structures in the DeviceIntRec. */
const Mask DeviceKeyPressMask             = KeyPressMask;
const Mask DeviceKeyReleaseMask           = KeyReleaseMask;
const Mask DeviceButtonPressMask          = ButtonPressMask;
const Mask DeviceButtonReleaseMask        = ButtonReleaseMask;
const Mask DeviceProximityMask            = (1L << 4);
const Mask DeviceStateNotifyMask          = (1L << 5);
const Mask DevicePointerMotionMask        = PointerMotionMask;
const Mask DevicePointerMotionHintMask    = PointerMotionHintMask;
const Mask DeviceButton1MotionMask        = Button1MotionMask;
const Mask DeviceButton2MotionMask        = Button2MotionMask;
const Mask DeviceButton3MotionMask        = Button3MotionMask;
const Mask DeviceButton4MotionMask        = Button4MotionMask;
const Mask DeviceButton5MotionMask        = Button5MotionMask;
const Mask DeviceButtonMotionMask         = ButtonMotionMask;
const Mask DeviceFocusChangeMask          = (1L << 14);
const Mask DeviceMappingNotifyMask        = (1L << 15);
const Mask ChangeDeviceNotifyMask         = (1L << 16);
const Mask DeviceButtonGrabMask           = (1L << 17);
const Mask DeviceOwnerGrabButtonMask      = (1L << 17);
const Mask DevicePresenceNotifyMask       = (1L << 18);
const Mask DeviceEnterWindowMask          = (1L << 18);
const Mask DeviceLeaveWindowMask          = (1L << 19);
const Mask DevicePropertyNotifyMask       = (1L << 20);
const Mask XIAllMasks                     = (1L << 21) - 1;

int ExtEventIndex;
Mask ExtExclusiveMasks[EMASKSIZE];

static struct dev_type
{
    Atom type;
    char *name;
} dev_type[] = {
    {
    0, XI_KEYBOARD}, {
    0, XI_MOUSE}, {
    0, XI_TABLET}, {
    0, XI_TOUCHSCREEN}, {
    0, XI_TOUCHPAD}, {
    0, XI_BARCODE}, {
    0, XI_BUTTONBOX}, {
    0, XI_KNOB_BOX}, {
    0, XI_ONE_KNOB}, {
    0, XI_NINE_KNOB}, {
    0, XI_TRACKBALL}, {
    0, XI_QUADRATURE}, {
    0, XI_ID_MODULE}, {
    0, XI_SPACEBALL}, {
    0, XI_DATAGLOVE}, {
    0, XI_EYETRACKER}, {
    0, XI_CURSORKEYS}, {
0, XI_FOOTMOUSE}};

CARD8 event_base[numInputClasses];
XExtEventInfo EventInfo[32];

static DeviceIntRec xi_all_devices;
static DeviceIntRec xi_all_master_devices;

/**
 * Dispatch vector. Functions defined in here will be called when the matching
 * request arrives.
 */
static int (*ProcIVector[])(ClientPtr) = {
        NULL,                                   /*  0 */
	ProcXGetExtensionVersion,               /*  1 */
	ProcXListInputDevices,                  /*  2 */
	ProcXOpenDevice,                        /*  3 */
	ProcXCloseDevice,                       /*  4 */
	ProcXSetDeviceMode,                     /*  5 */
	ProcXSelectExtensionEvent,              /*  6 */
	ProcXGetSelectedExtensionEvents,        /*  7 */
	ProcXChangeDeviceDontPropagateList,     /*  8 */
	ProcXGetDeviceDontPropagateList,        /*  9 */
	ProcXGetDeviceMotionEvents,             /* 10 */
	ProcXChangeKeyboardDevice,              /* 11 */
	ProcXChangePointerDevice,               /* 12 */
	ProcXGrabDevice,                        /* 13 */
	ProcXUngrabDevice,                      /* 14 */
	ProcXGrabDeviceKey,                     /* 15 */
	ProcXUngrabDeviceKey,                   /* 16 */
	ProcXGrabDeviceButton,                  /* 17 */
	ProcXUngrabDeviceButton,                /* 18 */
	ProcXAllowDeviceEvents,                 /* 19 */
	ProcXGetDeviceFocus,                    /* 20 */
	ProcXSetDeviceFocus,                    /* 21 */
	ProcXGetFeedbackControl,                /* 22 */
	ProcXChangeFeedbackControl,             /* 23 */
	ProcXGetDeviceKeyMapping,               /* 24 */
	ProcXChangeDeviceKeyMapping,            /* 25 */
	ProcXGetDeviceModifierMapping,          /* 26 */
	ProcXSetDeviceModifierMapping,          /* 27 */
	ProcXGetDeviceButtonMapping,            /* 28 */
	ProcXSetDeviceButtonMapping,            /* 29 */
	ProcXQueryDeviceState,                  /* 30 */
	ProcXSendExtensionEvent,                /* 31 */
	ProcXDeviceBell,                        /* 32 */
	ProcXSetDeviceValuators,                /* 33 */
	ProcXGetDeviceControl,                  /* 34 */
	ProcXChangeDeviceControl,               /* 35 */
        /* XI 1.5 */
        ProcXListDeviceProperties,              /* 36 */
        ProcXChangeDeviceProperty,              /* 37 */
        ProcXDeleteDeviceProperty,              /* 38 */
        ProcXGetDeviceProperty,                 /* 39 */
        /* XI 2 */
        ProcXIQueryPointer,                     /* 40 */
        ProcXIWarpPointer,                      /* 41 */
        ProcXIChangeCursor,                     /* 42 */
        ProcXIChangeHierarchy,                  /* 43 */
        ProcXISetClientPointer,                 /* 44 */
        ProcXIGetClientPointer,                 /* 45 */
        ProcXISelectEvents,                     /* 46 */
        ProcXIQueryVersion,                     /* 47 */
        ProcXIQueryDevice,                      /* 48 */
        ProcXISetFocus,                         /* 49 */
        ProcXIGetFocus,                         /* 50 */
        ProcXIGrabDevice,                       /* 51 */
        ProcXIUngrabDevice,                     /* 52 */
        ProcXIAllowEvents,                      /* 53 */
        ProcXIPassiveGrabDevice,                /* 54 */
        ProcXIPassiveUngrabDevice,              /* 55 */
        ProcXIListProperties,                   /* 56 */
        ProcXIChangeProperty,                   /* 57 */
        ProcXIDeleteProperty,                   /* 58 */
        ProcXIGetProperty,                      /* 59 */
        ProcXIGetSelectedEvents                 /* 60 */
};

/* For swapped clients */
static int (*SProcIVector[])(ClientPtr) = {
        NULL,                                    /*  0 */
	SProcXGetExtensionVersion,               /*  1 */
	SProcXListInputDevices,                  /*  2 */
	SProcXOpenDevice,                        /*  3 */
	SProcXCloseDevice,                       /*  4 */
	SProcXSetDeviceMode,                     /*  5 */
	SProcXSelectExtensionEvent,              /*  6 */
	SProcXGetSelectedExtensionEvents,        /*  7 */
	SProcXChangeDeviceDontPropagateList,     /*  8 */
	SProcXGetDeviceDontPropagateList,        /*  9 */
	SProcXGetDeviceMotionEvents,             /* 10 */
	SProcXChangeKeyboardDevice,              /* 11 */
	SProcXChangePointerDevice,               /* 12 */
	SProcXGrabDevice,                        /* 13 */
	SProcXUngrabDevice,                      /* 14 */
	SProcXGrabDeviceKey,                     /* 15 */
	SProcXUngrabDeviceKey,                   /* 16 */
	SProcXGrabDeviceButton,                  /* 17 */
	SProcXUngrabDeviceButton,                /* 18 */
	SProcXAllowDeviceEvents,                 /* 19 */
	SProcXGetDeviceFocus,                    /* 20 */
	SProcXSetDeviceFocus,                    /* 21 */
	SProcXGetFeedbackControl,                /* 22 */
	SProcXChangeFeedbackControl,             /* 23 */
	SProcXGetDeviceKeyMapping,               /* 24 */
	SProcXChangeDeviceKeyMapping,            /* 25 */
	SProcXGetDeviceModifierMapping,          /* 26 */
	SProcXSetDeviceModifierMapping,          /* 27 */
	SProcXGetDeviceButtonMapping,            /* 28 */
	SProcXSetDeviceButtonMapping,            /* 29 */
	SProcXQueryDeviceState,                  /* 30 */
	SProcXSendExtensionEvent,                /* 31 */
	SProcXDeviceBell,                        /* 32 */
	SProcXSetDeviceValuators,                /* 33 */
	SProcXGetDeviceControl,                  /* 34 */
	SProcXChangeDeviceControl,               /* 35 */
        SProcXListDeviceProperties,              /* 36 */
        SProcXChangeDeviceProperty,              /* 37 */
        SProcXDeleteDeviceProperty,              /* 38 */
        SProcXGetDeviceProperty,                 /* 39 */
        SProcXIQueryPointer,                     /* 40 */
        SProcXIWarpPointer,                      /* 41 */
        SProcXIChangeCursor,                     /* 42 */
        SProcXIChangeHierarchy,                  /* 43 */
        SProcXISetClientPointer,                 /* 44 */
        SProcXIGetClientPointer,                 /* 45 */
        SProcXISelectEvents,                     /* 46 */
        SProcXIQueryVersion,                     /* 47 */
        SProcXIQueryDevice,                      /* 48 */
        SProcXISetFocus,                         /* 49 */
        SProcXIGetFocus,                         /* 50 */
        SProcXIGrabDevice,                       /* 51 */
        SProcXIUngrabDevice,                     /* 52 */
        SProcXIAllowEvents,                      /* 53 */
        SProcXIPassiveGrabDevice,                /* 54 */
        SProcXIPassiveUngrabDevice,              /* 55 */
        SProcXIListProperties,                   /* 56 */
        SProcXIChangeProperty,                   /* 57 */
        SProcXIDeleteProperty,                   /* 58 */
        SProcXIGetProperty,                      /* 59 */
        SProcXIGetSelectedEvents                 /* 60 */
};

/*****************************************************************
 *
 * Globals referenced elsewhere in the server.
 *
 */

int IReqCode = 0;
int IEventBase = 0;
int BadDevice = 0;
static int BadEvent = 1;
int BadMode = 2;
int DeviceBusy = 3;
int BadClass = 4;

int DeviceValuator;
int DeviceKeyPress;
int DeviceKeyRelease;
int DeviceButtonPress;
int DeviceButtonRelease;
int DeviceMotionNotify;
int DeviceFocusIn;
int DeviceFocusOut;
int ProximityIn;
int ProximityOut;
int DeviceStateNotify;
int DeviceKeyStateNotify;
int DeviceButtonStateNotify;
int DeviceMappingNotify;
int ChangeDeviceNotify;
int DevicePresenceNotify;
int DevicePropertyNotify;

RESTYPE RT_INPUTCLIENT;

/*****************************************************************
 *
 * Externs defined elsewhere in the X server.
 *
 */

extern XExtensionVersion XIVersion;


Mask PropagateMask[MAXDEVICES];

/*****************************************************************
 *
 * Versioning support
 *
 */

DevPrivateKeyRec XIClientPrivateKeyRec;

/*****************************************************************
 *
 * Declarations of local routines.
 *
 */

static void
XIClientCallback(CallbackListPtr        *list,
                 pointer                closure,
                 pointer                data)
{
    NewClientInfoRec *clientinfo = (NewClientInfoRec*)data;
    ClientPtr pClient = clientinfo->client;
    XIClientPtr pXIClient;

    pXIClient = dixLookupPrivate(&pClient->devPrivates, XIClientPrivateKey);
    pXIClient->major_version = 0;
    pXIClient->minor_version = 0;
}

/*************************************************************************
 *
 * ProcIDispatch - main dispatch routine for requests to this extension.
 * This routine is used if server and client have the same byte ordering.
 *
 */

static int
ProcIDispatch(ClientPtr client)
{
    REQUEST(xReq);
    if (stuff->data > ARRAY_SIZE(ProcIVector) || !ProcIVector[stuff->data])
        return BadRequest;

    return (*ProcIVector[stuff->data])(client);
}

/*******************************************************************************
 *
 * SProcXDispatch
 *
 * Main swapped dispatch routine for requests to this extension.
 * This routine is used if server and client do not have the same byte ordering.
 *
 */

static int
SProcIDispatch(ClientPtr client)
{
    REQUEST(xReq);
    if (stuff->data > ARRAY_SIZE(SProcIVector) || !SProcIVector[stuff->data])
        return BadRequest;

    return (*SProcIVector[stuff->data])(client);
}

/**********************************************************************
 *
 * SReplyIDispatch
 * Swap any replies defined in this extension.
 *
 */

static void
SReplyIDispatch(ClientPtr client, int len, xGrabDeviceReply * rep)
					/* All we look at is the type field */
{	/* This is common to all replies    */
    if (rep->RepType == X_GetExtensionVersion)
	SRepXGetExtensionVersion(client, len,
				 (xGetExtensionVersionReply *) rep);
    else if (rep->RepType == X_ListInputDevices)
	SRepXListInputDevices(client, len, (xListInputDevicesReply *) rep);
    else if (rep->RepType == X_OpenDevice)
	SRepXOpenDevice(client, len, (xOpenDeviceReply *) rep);
    else if (rep->RepType == X_SetDeviceMode)
	SRepXSetDeviceMode(client, len, (xSetDeviceModeReply *) rep);
    else if (rep->RepType == X_GetSelectedExtensionEvents)
	SRepXGetSelectedExtensionEvents(client, len,
					(xGetSelectedExtensionEventsReply *)
					rep);
    else if (rep->RepType == X_GetDeviceDontPropagateList)
	SRepXGetDeviceDontPropagateList(client, len,
					(xGetDeviceDontPropagateListReply *)
					rep);
    else if (rep->RepType == X_GetDeviceMotionEvents)
	SRepXGetDeviceMotionEvents(client, len,
				   (xGetDeviceMotionEventsReply *) rep);
    else if (rep->RepType == X_GrabDevice)
	SRepXGrabDevice(client, len, (xGrabDeviceReply *) rep);
    else if (rep->RepType == X_GetDeviceFocus)
	SRepXGetDeviceFocus(client, len, (xGetDeviceFocusReply *) rep);
    else if (rep->RepType == X_GetFeedbackControl)
	SRepXGetFeedbackControl(client, len, (xGetFeedbackControlReply *) rep);
    else if (rep->RepType == X_GetDeviceKeyMapping)
	SRepXGetDeviceKeyMapping(client, len,
				 (xGetDeviceKeyMappingReply *) rep);
    else if (rep->RepType == X_GetDeviceModifierMapping)
	SRepXGetDeviceModifierMapping(client, len,
				      (xGetDeviceModifierMappingReply *) rep);
    else if (rep->RepType == X_SetDeviceModifierMapping)
	SRepXSetDeviceModifierMapping(client, len,
				      (xSetDeviceModifierMappingReply *) rep);
    else if (rep->RepType == X_GetDeviceButtonMapping)
	SRepXGetDeviceButtonMapping(client, len,
				    (xGetDeviceButtonMappingReply *) rep);
    else if (rep->RepType == X_SetDeviceButtonMapping)
	SRepXSetDeviceButtonMapping(client, len,
				    (xSetDeviceButtonMappingReply *) rep);
    else if (rep->RepType == X_QueryDeviceState)
	SRepXQueryDeviceState(client, len, (xQueryDeviceStateReply *) rep);
    else if (rep->RepType == X_SetDeviceValuators)
	SRepXSetDeviceValuators(client, len, (xSetDeviceValuatorsReply *) rep);
    else if (rep->RepType == X_GetDeviceControl)
	SRepXGetDeviceControl(client, len, (xGetDeviceControlReply *) rep);
    else if (rep->RepType == X_ChangeDeviceControl)
	SRepXChangeDeviceControl(client, len,
				 (xChangeDeviceControlReply *) rep);
    else if (rep->RepType == X_ListDeviceProperties)
        SRepXListDeviceProperties(client, len, (xListDevicePropertiesReply*)rep);
    else if (rep->RepType == X_GetDeviceProperty)
	SRepXGetDeviceProperty(client, len, (xGetDevicePropertyReply *) rep);
    else if (rep->RepType == X_XIQueryPointer)
	SRepXIQueryPointer(client, len, (xXIQueryPointerReply *) rep);
    else if (rep->RepType == X_XIGetClientPointer)
        SRepXIGetClientPointer(client, len, (xXIGetClientPointerReply*) rep);
    else if (rep->RepType == X_XIQueryVersion)
        SRepXIQueryVersion(client, len, (xXIQueryVersionReply*)rep);
    else if (rep->RepType == X_XIQueryDevice)
        SRepXIQueryDevice(client, len, (xXIQueryDeviceReply*)rep);
    else if (rep->RepType == X_XIGrabDevice)
	SRepXIGrabDevice(client, len, (xXIGrabDeviceReply *) rep);
    else if (rep->RepType == X_XIPassiveGrabDevice)
	SRepXIPassiveGrabDevice(client, len, (xXIPassiveGrabDeviceReply *) rep);
    else if (rep->RepType == X_XIListProperties)
	SRepXIListProperties(client, len, (xXIListPropertiesReply *) rep);
    else if (rep->RepType == X_XIGetProperty)
	SRepXIGetProperty(client, len, (xXIGetPropertyReply *) rep);
    else if (rep->RepType == X_XIGetSelectedEvents)
	SRepXIGetSelectedEvents(client, len, (xXIGetSelectedEventsReply *) rep);
    else if (rep->RepType == X_XIGetFocus)
	SRepXIGetFocus(client, len, (xXIGetFocusReply *) rep);
    else {
	FatalError("XINPUT confused sending swapped reply");
    }
}

/************************************************************************
 *
 * This function swaps the DeviceValuator event.
 *
 */

static void
SEventDeviceValuator(deviceValuator * from, deviceValuator * to)
{
    char n;
    int i;
    INT32 *ip B32;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swaps(&to->device_state, n);
    ip = &to->valuator0;
    for (i = 0; i < 6; i++) {
	swapl((ip + i), n);	/* macro - braces are required      */
    }
}

static void
SEventFocus(deviceFocus * from, deviceFocus * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->time, n);
    swapl(&to->window, n);
}

static void
SDeviceStateNotifyEvent(deviceStateNotify * from, deviceStateNotify * to)
{
    int i;
    char n;
    INT32 *ip B32;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->time, n);
    ip = &to->valuator0;
    for (i = 0; i < 3; i++) {
	swapl((ip + i), n);	/* macro - braces are required      */
    }
}

static void
SDeviceKeyStateNotifyEvent(deviceKeyStateNotify * from,
			   deviceKeyStateNotify * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
}

static void
SDeviceButtonStateNotifyEvent(deviceButtonStateNotify * from,
			      deviceButtonStateNotify * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
}

static void
SChangeDeviceNotifyEvent(changeDeviceNotify * from, changeDeviceNotify * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->time, n);
}

static void
SDeviceMappingNotifyEvent(deviceMappingNotify * from, deviceMappingNotify * to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->time, n);
}

static void
SDevicePresenceNotifyEvent (devicePresenceNotify *from, devicePresenceNotify *to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber,n);
    swapl(&to->time, n);
    swaps(&to->control, n);
}

static void
SDevicePropertyNotifyEvent (devicePropertyNotify *from, devicePropertyNotify *to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber,n);
    swapl(&to->time, n);
    swapl(&to->atom, n);
}

static void
SDeviceLeaveNotifyEvent (xXILeaveEvent *from, xXILeaveEvent *to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber,n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swapl(&to->root, n);
    swapl(&to->event, n);
    swapl(&to->child, n);
    swapl(&to->root_x, n);
    swapl(&to->root_y, n);
    swapl(&to->event_x, n);
    swapl(&to->event_y, n);
    swaps(&to->sourceid, n);
    swaps(&to->buttons_len, n);
    swapl(&to->mods.base_mods, n);
    swapl(&to->mods.latched_mods, n);
    swapl(&to->mods.locked_mods, n);
}

static void
SDeviceChangedEvent(xXIDeviceChangedEvent* from, xXIDeviceChangedEvent* to)
{
    char n;
    int i, j;
    xXIAnyInfo *any;

    *to = *from;
    memcpy(&to[1], &from[1], from->length * 4);

    any = (xXIAnyInfo*)&to[1];
    for (i = 0; i < to->num_classes; i++)
    {
        int length = any->length;

        switch(any->type)
        {
            case KeyClass:
                {
                    xXIKeyInfo *ki = (xXIKeyInfo*)any;
                    uint32_t *key = (uint32_t*)&ki[1];
                    for (j = 0; j < ki->num_keycodes; j++, key++)
                        swapl(key, n);
                    swaps(&ki->num_keycodes, n);
                }
                break;
            case ButtonClass:
                {
                    xXIButtonInfo *bi = (xXIButtonInfo*)any;
                    Atom *labels = (Atom*)((char*)bi + sizeof(xXIButtonInfo) +
                                           pad_to_int32(bits_to_bytes(bi->num_buttons)));
                    for (j = 0; j < bi->num_buttons; j++)
                        swapl(&labels[j], n);
                    swaps(&bi->num_buttons, n);
                }
                break;
            case ValuatorClass:
                {
                    xXIValuatorInfo* ai = (xXIValuatorInfo*)any;
                    swapl(&ai->label, n);
                    swapl(&ai->min.integral, n);
                    swapl(&ai->min.frac, n);
                    swapl(&ai->max.integral, n);
                    swapl(&ai->max.frac, n);
                    swapl(&ai->resolution, n);
                    swaps(&ai->number, n);
                }
                break;
        }

        swaps(&any->type, n);
        swaps(&any->length, n);
        swaps(&any->sourceid, n);

        any = (xXIAnyInfo*)((char*)any + length * 4);
    }

    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swaps(&to->num_classes, n);
    swaps(&to->sourceid, n);

}

static void SDeviceEvent(xXIDeviceEvent *from, xXIDeviceEvent *to)
{
    int i;
    char n;
    char *ptr;
    char *vmask;

    memcpy(to, from, sizeof(xEvent) + from->length * 4);

    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swapl(&to->detail, n);
    swapl(&to->root, n);
    swapl(&to->event, n);
    swapl(&to->child, n);
    swapl(&to->root_x, n);
    swapl(&to->root_y, n);
    swapl(&to->event_x, n);
    swapl(&to->event_y, n);
    swaps(&to->buttons_len, n);
    swaps(&to->valuators_len, n);
    swaps(&to->sourceid, n);
    swapl(&to->mods.base_mods, n);
    swapl(&to->mods.latched_mods, n);
    swapl(&to->mods.locked_mods, n);
    swapl(&to->mods.effective_mods, n);
    swapl(&to->flags, n);

    ptr = (char*)(&to[1]);
    ptr += from->buttons_len * 4;
    vmask = ptr; /* valuator mask */
    ptr += from->valuators_len * 4;
    for (i = 0; i < from->valuators_len * 32; i++)
    {
        if (BitIsOn(vmask, i))
        {
            swapl(((uint32_t*)ptr), n);
            ptr += 4;
            swapl(((uint32_t*)ptr), n);
            ptr += 4;
        }
    }
}

static void SDeviceHierarchyEvent(xXIHierarchyEvent *from,
                                  xXIHierarchyEvent *to)
{
    int i;
    char n;
    xXIHierarchyInfo *info;

    *to = *from;
    memcpy(&to[1], &from[1], from->length * 4);
    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swapl(&to->flags, n);
    swaps(&to->num_info, n);

    info = (xXIHierarchyInfo*)&to[1];
    for (i = 0; i< from->num_info; i++)
    {
        swaps(&info->deviceid, n);
        swaps(&info->attachment, n);
        info++;
    }
}

static void SXIPropertyEvent(xXIPropertyEvent *from, xXIPropertyEvent *to)
{
    char n;

    *to = *from;
    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->property, n);
}

static void SRawEvent(xXIRawEvent *from, xXIRawEvent *to)
{
    char n;
    int i;
    FP3232 *values;
    unsigned char *mask;

    memcpy(to, from, sizeof(xEvent) + from->length * 4);

    swaps(&to->sequenceNumber, n);
    swapl(&to->length, n);
    swaps(&to->evtype, n);
    swaps(&to->deviceid, n);
    swapl(&to->time, n);
    swapl(&to->detail, n);


    mask = (unsigned char*)&to[1];
    values = (FP3232*)(mask + from->valuators_len * 4);

    for (i = 0; i < from->valuators_len * 4 * 8; i++)
    {
        if (BitIsOn(mask, i))
        {
            /* for each bit set there are two FP3232 values on the wire, in
             * the order abcABC for data and data_raw. Here we swap as if
             * they were in aAbBcC order because it's easier and really
             * doesn't matter.
             */
            swapl(&values->integral, n);
            swapl(&values->frac, n);
            values++;
            swapl(&values->integral, n);
            swapl(&values->frac, n);
            values++;
        }
    }

    swaps(&to->valuators_len, n);
}


/** Event swapping function for XI2 events. */
void
XI2EventSwap(xGenericEvent *from, xGenericEvent *to)
{
    switch(from->evtype)
    {
        case XI_Enter:
        case XI_Leave:
        case XI_FocusIn:
        case XI_FocusOut:
            SDeviceLeaveNotifyEvent((xXILeaveEvent*)from, (xXILeaveEvent*)to);
            break;
        case XI_DeviceChanged:
            SDeviceChangedEvent((xXIDeviceChangedEvent*)from,
                                (xXIDeviceChangedEvent*)to);
            break;
        case XI_HierarchyChanged:
            SDeviceHierarchyEvent((xXIHierarchyEvent*)from, (xXIHierarchyEvent*)to);
            break;
        case XI_PropertyEvent:
            SXIPropertyEvent((xXIPropertyEvent*)from,
                           (xXIPropertyEvent*)to);
            break;
        case XI_Motion:
        case XI_KeyPress:
        case XI_KeyRelease:
        case XI_ButtonPress:
        case XI_ButtonRelease:
            SDeviceEvent((xXIDeviceEvent*)from, (xXIDeviceEvent*)to);
            break;
        case XI_RawMotion:
        case XI_RawKeyPress:
        case XI_RawKeyRelease:
        case XI_RawButtonPress:
        case XI_RawButtonRelease:
            SRawEvent((xXIRawEvent*)from, (xXIRawEvent*)to);
            break;
        default:
            ErrorF("[Xi] Unknown event type to swap. This is a bug.\n");
            break;
    }
}

/**************************************************************************
 *
 * Allow the specified event to have its propagation suppressed.
 * The default is to not allow suppression of propagation.
 *
 */

static void
AllowPropagateSuppress(Mask mask)
{
    int i;

    for (i = 0; i < MAXDEVICES; i++)
	PropagateMask[i] |= mask;
}

/**************************************************************************
 *
 * Record an event mask where there is no unique corresponding event type.
 * We can't call SetMaskForEvent, since that would clobber the existing
 * mask for that event.  MotionHint and ButtonMotion are examples.
 *
 * Since extension event types will never be less than 64, we can use
 * 0-63 in the EventInfo array as the "type" to be used to look up this
 * mask.  This means that the corresponding macros such as
 * DevicePointerMotionHint must have access to the same constants.
 *
 */

static void
SetEventInfo(Mask mask, int constant)
{
    EventInfo[ExtEventIndex].mask = mask;
    EventInfo[ExtEventIndex++].type = constant;
}

/**************************************************************************
 *
 * Allow the specified event to be restricted to being selected by one
 * client at a time.
 * The default is to allow more than one client to select the event.
 *
 */

static void
SetExclusiveAccess(Mask mask)
{
    int i;

    for (i = 0; i < MAXDEVICES; i++)
	ExtExclusiveMasks[i] |= mask;
}

/**************************************************************************
 *
 * Assign the specified mask to the specified event.
 *
 */

static void
SetMaskForExtEvent(Mask mask, int event)
{
    int i;

    EventInfo[ExtEventIndex].mask = mask;
    EventInfo[ExtEventIndex++].type = event;

    if ((event < LASTEvent) || (event >= 128))
	FatalError("MaskForExtensionEvent: bogus event number");

    for (i = 0; i < MAXDEVICES; i++)
        SetMaskForEvent(i, mask, event);
}

/************************************************************************
 *
 * This function sets up extension event types and masks.
 *
 */

static void
FixExtensionEvents(ExtensionEntry * extEntry)
{
    DeviceValuator = extEntry->eventBase;
    DeviceKeyPress = DeviceValuator + 1;
    DeviceKeyRelease = DeviceKeyPress + 1;
    DeviceButtonPress = DeviceKeyRelease + 1;
    DeviceButtonRelease = DeviceButtonPress + 1;
    DeviceMotionNotify = DeviceButtonRelease + 1;
    DeviceFocusIn = DeviceMotionNotify + 1;
    DeviceFocusOut = DeviceFocusIn + 1;
    ProximityIn = DeviceFocusOut + 1;
    ProximityOut = ProximityIn + 1;
    DeviceStateNotify = ProximityOut + 1;
    DeviceMappingNotify = DeviceStateNotify + 1;
    ChangeDeviceNotify = DeviceMappingNotify + 1;
    DeviceKeyStateNotify = ChangeDeviceNotify + 1;
    DeviceButtonStateNotify = DeviceKeyStateNotify + 1;
    DevicePresenceNotify = DeviceButtonStateNotify + 1;
    DevicePropertyNotify = DevicePresenceNotify + 1;

    event_base[KeyClass] = DeviceKeyPress;
    event_base[ButtonClass] = DeviceButtonPress;
    event_base[ValuatorClass] = DeviceMotionNotify;
    event_base[ProximityClass] = ProximityIn;
    event_base[FocusClass] = DeviceFocusIn;
    event_base[OtherClass] = DeviceStateNotify;

    BadDevice += extEntry->errorBase;
    BadEvent += extEntry->errorBase;
    BadMode += extEntry->errorBase;
    DeviceBusy += extEntry->errorBase;
    BadClass += extEntry->errorBase;

    SetMaskForExtEvent(DeviceKeyPressMask, DeviceKeyPress);
    AllowPropagateSuppress(DeviceKeyPressMask);
    SetCriticalEvent(DeviceKeyPress);

    SetMaskForExtEvent(DeviceKeyReleaseMask, DeviceKeyRelease);
    AllowPropagateSuppress(DeviceKeyReleaseMask);
    SetCriticalEvent(DeviceKeyRelease);

    SetMaskForExtEvent(DeviceButtonPressMask, DeviceButtonPress);
    AllowPropagateSuppress(DeviceButtonPressMask);
    SetCriticalEvent(DeviceButtonPress);

    SetMaskForExtEvent(DeviceButtonReleaseMask, DeviceButtonRelease);
    AllowPropagateSuppress(DeviceButtonReleaseMask);
    SetCriticalEvent(DeviceButtonRelease);

    SetMaskForExtEvent(DeviceProximityMask, ProximityIn);
    SetMaskForExtEvent(DeviceProximityMask, ProximityOut);

    SetMaskForExtEvent(DeviceStateNotifyMask, DeviceStateNotify);

    SetMaskForExtEvent(DevicePointerMotionMask, DeviceMotionNotify);
    AllowPropagateSuppress(DevicePointerMotionMask);
    SetCriticalEvent(DeviceMotionNotify);

    SetEventInfo(DevicePointerMotionHintMask, _devicePointerMotionHint);
    SetEventInfo(DeviceButton1MotionMask, _deviceButton1Motion);
    SetEventInfo(DeviceButton2MotionMask, _deviceButton2Motion);
    SetEventInfo(DeviceButton3MotionMask, _deviceButton3Motion);
    SetEventInfo(DeviceButton4MotionMask, _deviceButton4Motion);
    SetEventInfo(DeviceButton5MotionMask, _deviceButton5Motion);
    SetEventInfo(DeviceButtonMotionMask, _deviceButtonMotion);

    SetMaskForExtEvent(DeviceFocusChangeMask, DeviceFocusIn);
    SetMaskForExtEvent(DeviceFocusChangeMask, DeviceFocusOut);

    SetMaskForExtEvent(DeviceMappingNotifyMask, DeviceMappingNotify);
    SetMaskForExtEvent(ChangeDeviceNotifyMask, ChangeDeviceNotify);

    SetEventInfo(DeviceButtonGrabMask, _deviceButtonGrab);
    SetExclusiveAccess(DeviceButtonGrabMask);

    SetEventInfo(DeviceOwnerGrabButtonMask, _deviceOwnerGrabButton);
    SetEventInfo(DevicePresenceNotifyMask, _devicePresence);
    SetMaskForExtEvent(DevicePropertyNotifyMask, DevicePropertyNotify);

    SetEventInfo(0, _noExtensionEvent);
}

/************************************************************************
 *
 * This function restores extension event types and masks to their
 * initial state.
 *
 */

static void
RestoreExtensionEvents(void)
{
    int i, j;

    IReqCode = 0;
    IEventBase = 0;

    for (i = 0; i < ExtEventIndex - 1; i++) {
	if ((EventInfo[i].type >= LASTEvent) && (EventInfo[i].type < 128))
        {
            for (j = 0; j < MAXDEVICES; j++)
                SetMaskForEvent(j, 0, EventInfo[i].type);
        }
	EventInfo[i].mask = 0;
	EventInfo[i].type = 0;
    }
    ExtEventIndex = 0;
    DeviceValuator = 0;
    DeviceKeyPress = 1;
    DeviceKeyRelease = 2;
    DeviceButtonPress = 3;
    DeviceButtonRelease = 4;
    DeviceMotionNotify = 5;
    DeviceFocusIn = 6;
    DeviceFocusOut = 7;
    ProximityIn = 8;
    ProximityOut = 9;
    DeviceStateNotify = 10;
    DeviceMappingNotify = 11;
    ChangeDeviceNotify = 12;
    DeviceKeyStateNotify = 13;
    DeviceButtonStateNotify = 13;
    DevicePresenceNotify = 14;
    DevicePropertyNotify = 15;

    BadDevice = 0;
    BadEvent = 1;
    BadMode = 2;
    DeviceBusy = 3;
    BadClass = 4;

}

/***********************************************************************
 *
 * IResetProc.
 * Remove reply-swapping routine.
 * Remove event-swapping routine.
 *
 */

static void
IResetProc(ExtensionEntry * unused)
{
    ReplySwapVector[IReqCode] = ReplyNotSwappd;
    EventSwapVector[DeviceValuator] = NotImplemented;
    EventSwapVector[DeviceKeyPress] = NotImplemented;
    EventSwapVector[DeviceKeyRelease] = NotImplemented;
    EventSwapVector[DeviceButtonPress] = NotImplemented;
    EventSwapVector[DeviceButtonRelease] = NotImplemented;
    EventSwapVector[DeviceMotionNotify] = NotImplemented;
    EventSwapVector[DeviceFocusIn] = NotImplemented;
    EventSwapVector[DeviceFocusOut] = NotImplemented;
    EventSwapVector[ProximityIn] = NotImplemented;
    EventSwapVector[ProximityOut] = NotImplemented;
    EventSwapVector[DeviceStateNotify] = NotImplemented;
    EventSwapVector[DeviceKeyStateNotify] = NotImplemented;
    EventSwapVector[DeviceButtonStateNotify] = NotImplemented;
    EventSwapVector[DeviceMappingNotify] = NotImplemented;
    EventSwapVector[ChangeDeviceNotify] = NotImplemented;
    EventSwapVector[DevicePresenceNotify] = NotImplemented;
    EventSwapVector[DevicePropertyNotify] = NotImplemented;
    RestoreExtensionEvents();
}


/***********************************************************************
 *
 * Assign an id and type to an input device.
 *
 */

void
AssignTypeAndName(DeviceIntPtr dev, Atom type, char *name)
{
    dev->xinput_type = type;
    dev->name = strdup(name);
}

/***********************************************************************
 *
 * Make device type atoms.
 *
 */

static void
MakeDeviceTypeAtoms(void)
{
    int i;

    for (i = 0; i < NUMTYPES; i++)
	dev_type[i].type =
	    MakeAtom(dev_type[i].name, strlen(dev_type[i].name), 1);
}

/*****************************************************************************
 *
 *	SEventIDispatch
 *
 *	Swap any events defined in this extension.
 */
#define DO_SWAP(func,type) func ((type *)from, (type *)to)

static void
SEventIDispatch(xEvent * from, xEvent * to)
{
    int type = from->u.u.type & 0177;

    if (type == DeviceValuator)
	DO_SWAP(SEventDeviceValuator, deviceValuator);
    else if (type == DeviceKeyPress) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceKeyRelease) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceButtonPress) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceButtonRelease) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceMotionNotify) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceFocusIn)
	DO_SWAP(SEventFocus, deviceFocus);
    else if (type == DeviceFocusOut)
	DO_SWAP(SEventFocus, deviceFocus);
    else if (type == ProximityIn) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == ProximityOut) {
	SKeyButtonPtrEvent(from, to);
	to->u.keyButtonPointer.pad1 = from->u.keyButtonPointer.pad1;
    } else if (type == DeviceStateNotify)
	DO_SWAP(SDeviceStateNotifyEvent, deviceStateNotify);
    else if (type == DeviceKeyStateNotify)
	DO_SWAP(SDeviceKeyStateNotifyEvent, deviceKeyStateNotify);
    else if (type == DeviceButtonStateNotify)
	DO_SWAP(SDeviceButtonStateNotifyEvent, deviceButtonStateNotify);
    else if (type == DeviceMappingNotify)
	DO_SWAP(SDeviceMappingNotifyEvent, deviceMappingNotify);
    else if (type == ChangeDeviceNotify)
	DO_SWAP(SChangeDeviceNotifyEvent, changeDeviceNotify);
    else if (type == DevicePresenceNotify)
	DO_SWAP(SDevicePresenceNotifyEvent, devicePresenceNotify);
    else if (type == DevicePropertyNotify)
	DO_SWAP(SDevicePropertyNotifyEvent, devicePropertyNotify);
    else {
	FatalError("XInputExtension: Impossible event!\n");
    }
}

/**********************************************************************
 *
 * IExtensionInit - initialize the input extension.
 *
 * Called from InitExtensions in main() or from QueryExtension() if the
 * extension is dynamically loaded.
 *
 * This extension has several events and errors.
 *
 * XI is mandatory nowadays, so if we fail to init XI, we die.
 */

void
XInputExtensionInit(void)
{
    ExtensionEntry *extEntry;
    XExtensionVersion thisversion = { XI_Present,
        SERVER_XI_MAJOR_VERSION,
        SERVER_XI_MINOR_VERSION,
    };

    if (!dixRegisterPrivateKey(&XIClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(XIClientRec)))
        FatalError("Cannot request private for XI.\n");

    if (!AddCallback(&ClientStateCallback, XIClientCallback, 0))
        FatalError("Failed to add callback to XI.\n");

    extEntry = AddExtension(INAME, IEVENTS, IERRORS, ProcIDispatch,
			    SProcIDispatch, IResetProc, StandardMinorOpcode);
    if (extEntry) {
	IReqCode = extEntry->base;
	IEventBase = extEntry->eventBase;
	XIVersion = thisversion;
	MakeDeviceTypeAtoms();
	RT_INPUTCLIENT = CreateNewResourceType((DeleteType) InputClientGone,
					       "INPUTCLIENT");
	if (!RT_INPUTCLIENT)
	    FatalError("Failed to add resource type for XI.\n");
	FixExtensionEvents(extEntry);
	ReplySwapVector[IReqCode] = (ReplySwapPtr) SReplyIDispatch;
	EventSwapVector[DeviceValuator] = SEventIDispatch;
	EventSwapVector[DeviceKeyPress] = SEventIDispatch;
	EventSwapVector[DeviceKeyRelease] = SEventIDispatch;
	EventSwapVector[DeviceButtonPress] = SEventIDispatch;
	EventSwapVector[DeviceButtonRelease] = SEventIDispatch;
	EventSwapVector[DeviceMotionNotify] = SEventIDispatch;
	EventSwapVector[DeviceFocusIn] = SEventIDispatch;
	EventSwapVector[DeviceFocusOut] = SEventIDispatch;
	EventSwapVector[ProximityIn] = SEventIDispatch;
	EventSwapVector[ProximityOut] = SEventIDispatch;
	EventSwapVector[DeviceStateNotify] = SEventIDispatch;
	EventSwapVector[DeviceKeyStateNotify] = SEventIDispatch;
	EventSwapVector[DeviceButtonStateNotify] = SEventIDispatch;
	EventSwapVector[DeviceMappingNotify] = SEventIDispatch;
	EventSwapVector[ChangeDeviceNotify] = SEventIDispatch;
	EventSwapVector[DevicePresenceNotify] = SEventIDispatch;

	GERegisterExtension(IReqCode, XI2EventSwap);


	memset(&xi_all_devices, 0, sizeof(xi_all_devices));
	memset(&xi_all_master_devices, 0, sizeof(xi_all_master_devices));
	xi_all_devices.id = XIAllDevices;
	xi_all_devices.name = "XIAllDevices";
	xi_all_master_devices.id = XIAllMasterDevices;
	xi_all_master_devices.name = "XIAllMasterDevices";

	inputInfo.all_devices = &xi_all_devices;
	inputInfo.all_master_devices = &xi_all_master_devices;

	XIResetProperties();
    } else {
	FatalError("IExtensionInit: AddExtensions failed\n");
    }
}

/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to return the version of the extension.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "getbmap.h"

/***********************************************************************
 *
 * This procedure gets the button mapping for the specified device.
 *
 */

int
SProcXGetDeviceButtonMapping(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceButtonMappingReq);
    swaps(&stuff->length, n);
    return (ProcXGetDeviceButtonMapping(client));
}

/***********************************************************************
 *
 * This procedure gets the button mapping for the specified device.
 *
 */

int
ProcXGetDeviceButtonMapping(ClientPtr client)
{
    DeviceIntPtr dev;
    xGetDeviceButtonMappingReply rep;
    ButtonClassPtr b;
    int rc;

    REQUEST(xGetDeviceButtonMappingReq);
    REQUEST_SIZE_MATCH(xGetDeviceButtonMappingReq);

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceButtonMapping;
    rep.nElts = 0;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    b = dev->button;
    if (b == NULL)
	return BadMatch;

    rep.nElts = b->numButtons;
    rep.length = bytes_to_int32(rep.nElts);
    WriteReplyToClient(client, sizeof(xGetDeviceButtonMappingReply), &rep);
    (void)WriteToClient(client, rep.nElts, (char *)&b->map[1]);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceButtonMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceButtonMapping(ClientPtr client, int size,
			    xGetDeviceButtonMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETBMAP_H
#define GETBMAP_H 1

int SProcXGetDeviceButtonMapping(ClientPtr	/* client */
    );

int ProcXGetDeviceButtonMapping(ClientPtr	/* client */
    );

void SRepXGetDeviceButtonMapping(ClientPtr /* client */ ,
				 int /* size */ ,
				 xGetDeviceButtonMappingReply *	/* rep */
    );

#endif /* GETBMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Get Device control attributes for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "getdctl.h"

/***********************************************************************
 *
 * This procedure gets the control attributes for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXGetDeviceControl(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceControlReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGetDeviceControlReq);
    swaps(&stuff->control, n);
    return (ProcXGetDeviceControl(client));
}

/***********************************************************************
 *
 * This procedure copies DeviceResolution data, swapping if necessary.
 *
 */

static void
CopySwapDeviceResolution(ClientPtr client, ValuatorClassPtr v, char *buf,
			 int length)
{
    char n;
    AxisInfoPtr a;
    xDeviceResolutionState *r;
    int i, *iptr;

    r = (xDeviceResolutionState *) buf;
    r->control = DEVICE_RESOLUTION;
    r->length = length;
    r->num_valuators = v->numAxes;
    buf += sizeof(xDeviceResolutionState);
    iptr = (int *)buf;
    for (i = 0, a = v->axes; i < v->numAxes; i++, a++)
	*iptr++ = a->resolution;
    for (i = 0, a = v->axes; i < v->numAxes; i++, a++)
	*iptr++ = a->min_resolution;
    for (i = 0, a = v->axes; i < v->numAxes; i++, a++)
	*iptr++ = a->max_resolution;
    if (client->swapped) {
	swaps(&r->control, n);
	swaps(&r->length, n);
	swapl(&r->num_valuators, n);
	iptr = (int *)buf;
	for (i = 0; i < (3 * v->numAxes); i++, iptr++) {
	    swapl(iptr, n);
	}
    }
}

static void CopySwapDeviceCore (ClientPtr client, DeviceIntPtr dev, char *buf)
{
    char n;
    xDeviceCoreState *c = (xDeviceCoreState *) buf;

    c->control = DEVICE_CORE;
    c->length = sizeof(xDeviceCoreState);
    c->status = dev->coreEvents;
    c->iscore = (dev == inputInfo.keyboard || dev == inputInfo.pointer);

    if (client->swapped) {
        swaps(&c->control, n);
        swaps(&c->length, n);
        swaps(&c->status, n);
    }
}

static void CopySwapDeviceEnable (ClientPtr client, DeviceIntPtr dev, char *buf)
{
    char n;
    xDeviceEnableState *e = (xDeviceEnableState *) buf;

    e->control = DEVICE_ENABLE;
    e->length = sizeof(xDeviceEnableState);
    e->enable = dev->enabled;

    if (client->swapped) {
        swaps(&e->control, n);
        swaps(&e->length, n);
        swaps(&e->enable, n);
    }
}

/***********************************************************************
 *
 * This procedure writes the reply for the xGetDeviceControl function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceControl(ClientPtr client, int size, xGetDeviceControlReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}

/***********************************************************************
 *
 * Get the state of the specified device control.
 *
 */

int
ProcXGetDeviceControl(ClientPtr client)
{
    int rc, total_length = 0;
    char *buf, *savbuf;
    DeviceIntPtr dev;
    xGetDeviceControlReply rep;

    REQUEST(xGetDeviceControlReq);
    REQUEST_SIZE_MATCH(xGetDeviceControlReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceControl;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    switch (stuff->control) {
    case DEVICE_RESOLUTION:
	if (!dev->valuator)
	    return BadMatch;
	total_length = sizeof(xDeviceResolutionState) +
	    (3 * sizeof(int) * dev->valuator->numAxes);
	break;
    case DEVICE_ABS_CALIB:
    case DEVICE_ABS_AREA:
        return BadMatch;
    case DEVICE_CORE:
        total_length = sizeof(xDeviceCoreState);
        break;
    case DEVICE_ENABLE:
        total_length = sizeof(xDeviceEnableState);
        break;
    default:
	return BadValue;
    }

    buf = (char *)malloc(total_length);
    if (!buf)
	return BadAlloc;
    savbuf = buf;

    switch (stuff->control) {
    case DEVICE_RESOLUTION:
	CopySwapDeviceResolution(client, dev->valuator, buf, total_length);
	break;
    case DEVICE_CORE:
        CopySwapDeviceCore(client, dev, buf);
        break;
    case DEVICE_ENABLE:
        CopySwapDeviceEnable(client, dev, buf);
        break;
    default:
	break;
    }

    rep.length = bytes_to_int32(total_length);
    WriteReplyToClient(client, sizeof(xGetDeviceControlReply), &rep);
    WriteToClient(client, total_length, savbuf);
    free(savbuf);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETDCTL_H
#define GETDCTL_H 1

int SProcXGetDeviceControl(ClientPtr	/* client */
    );

int ProcXGetDeviceControl(ClientPtr	/* client */
    );

void SRepXGetDeviceControl(ClientPtr /* client */ ,
			   int /* size */ ,
			   xGetDeviceControlReply *	/* rep */
    );

#endif /* GETDCTL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Get feedback control attributes for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "getfctl.h"

/***********************************************************************
 *
 * This procedure gets the control attributes for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXGetFeedbackControl(ClientPtr client)
{
    char n;

    REQUEST(xGetFeedbackControlReq);
    swaps(&stuff->length, n);
    return (ProcXGetFeedbackControl(client));
}

/***********************************************************************
 *
 * This procedure copies KbdFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapKbdFeedback(ClientPtr client, KbdFeedbackPtr k, char **buf)
{
    int i;
    char n;
    xKbdFeedbackState *k2;

    k2 = (xKbdFeedbackState *) * buf;
    k2->class = KbdFeedbackClass;
    k2->length = sizeof(xKbdFeedbackState);
    k2->id = k->ctrl.id;
    k2->click = k->ctrl.click;
    k2->percent = k->ctrl.bell;
    k2->pitch = k->ctrl.bell_pitch;
    k2->duration = k->ctrl.bell_duration;
    k2->led_mask = k->ctrl.leds;
    k2->global_auto_repeat = k->ctrl.autoRepeat;
    for (i = 0; i < 32; i++)
	k2->auto_repeats[i] = k->ctrl.autoRepeats[i];
    if (client->swapped) {
	swaps(&k2->length, n);
	swaps(&k2->pitch, n);
	swaps(&k2->duration, n);
	swapl(&k2->led_mask, n);
	swapl(&k2->led_values, n);
    }
    *buf += sizeof(xKbdFeedbackState);
}

/***********************************************************************
 *
 * This procedure copies PtrFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapPtrFeedback(ClientPtr client, PtrFeedbackPtr p, char **buf)
{
    char n;
    xPtrFeedbackState *p2;

    p2 = (xPtrFeedbackState *) * buf;
    p2->class = PtrFeedbackClass;
    p2->length = sizeof(xPtrFeedbackState);
    p2->id = p->ctrl.id;
    p2->accelNum = p->ctrl.num;
    p2->accelDenom = p->ctrl.den;
    p2->threshold = p->ctrl.threshold;
    if (client->swapped) {
	swaps(&p2->length, n);
	swaps(&p2->accelNum, n);
	swaps(&p2->accelDenom, n);
	swaps(&p2->threshold, n);
    }
    *buf += sizeof(xPtrFeedbackState);
}

/***********************************************************************
 *
 * This procedure copies IntegerFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapIntegerFeedback(ClientPtr client, IntegerFeedbackPtr i, char **buf)
{
    char n;
    xIntegerFeedbackState *i2;

    i2 = (xIntegerFeedbackState *) * buf;
    i2->class = IntegerFeedbackClass;
    i2->length = sizeof(xIntegerFeedbackState);
    i2->id = i->ctrl.id;
    i2->resolution = i->ctrl.resolution;
    i2->min_value = i->ctrl.min_value;
    i2->max_value = i->ctrl.max_value;
    if (client->swapped) {
	swaps(&i2->length, n);
	swapl(&i2->resolution, n);
	swapl(&i2->min_value, n);
	swapl(&i2->max_value, n);
    }
    *buf += sizeof(xIntegerFeedbackState);
}

/***********************************************************************
 *
 * This procedure copies StringFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapStringFeedback(ClientPtr client, StringFeedbackPtr s, char **buf)
{
    int i;
    char n;
    xStringFeedbackState *s2;
    KeySym *kptr;

    s2 = (xStringFeedbackState *) * buf;
    s2->class = StringFeedbackClass;
    s2->length = sizeof(xStringFeedbackState) +
	s->ctrl.num_symbols_supported * sizeof(KeySym);
    s2->id = s->ctrl.id;
    s2->max_symbols = s->ctrl.max_symbols;
    s2->num_syms_supported = s->ctrl.num_symbols_supported;
    *buf += sizeof(xStringFeedbackState);
    kptr = (KeySym *) (*buf);
    for (i = 0; i < s->ctrl.num_symbols_supported; i++)
	*kptr++ = *(s->ctrl.symbols_supported + i);
    if (client->swapped) {
	swaps(&s2->length, n);
	swaps(&s2->max_symbols, n);
	swaps(&s2->num_syms_supported, n);
	kptr = (KeySym *) (*buf);
	for (i = 0; i < s->ctrl.num_symbols_supported; i++, kptr++) {
	    swapl(kptr, n);
	}
    }
    *buf += (s->ctrl.num_symbols_supported * sizeof(KeySym));
}

/***********************************************************************
 *
 * This procedure copies LedFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapLedFeedback(ClientPtr client, LedFeedbackPtr l, char **buf)
{
    char n;
    xLedFeedbackState *l2;

    l2 = (xLedFeedbackState *) * buf;
    l2->class = LedFeedbackClass;
    l2->length = sizeof(xLedFeedbackState);
    l2->id = l->ctrl.id;
    l2->led_values = l->ctrl.led_values;
    l2->led_mask = l->ctrl.led_mask;
    if (client->swapped) {
	swaps(&l2->length, n);
	swapl(&l2->led_values, n);
	swapl(&l2->led_mask, n);
    }
    *buf += sizeof(xLedFeedbackState);
}

/***********************************************************************
 *
 * This procedure copies BellFeedbackClass data, swapping if necessary.
 *
 */

static void
CopySwapBellFeedback(ClientPtr client, BellFeedbackPtr b, char **buf)
{
    char n;
    xBellFeedbackState *b2;

    b2 = (xBellFeedbackState *) * buf;
    b2->class = BellFeedbackClass;
    b2->length = sizeof(xBellFeedbackState);
    b2->id = b->ctrl.id;
    b2->percent = b->ctrl.percent;
    b2->pitch = b->ctrl.pitch;
    b2->duration = b->ctrl.duration;
    if (client->swapped) {
	swaps(&b2->length, n);
	swaps(&b2->pitch, n);
	swaps(&b2->duration, n);
    }
    *buf += sizeof(xBellFeedbackState);
}

/***********************************************************************
 *
 * This procedure writes the reply for the xGetFeedbackControl function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetFeedbackControl(ClientPtr client, int size,
			xGetFeedbackControlReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_feedbacks, n);
    WriteToClient(client, size, (char *)rep);
}

/***********************************************************************
 *
 * Get the feedback control state.
 *
 */

int
ProcXGetFeedbackControl(ClientPtr client)
{
    int rc, total_length = 0;
    char *buf, *savbuf;
    DeviceIntPtr dev;
    KbdFeedbackPtr k;
    PtrFeedbackPtr p;
    IntegerFeedbackPtr i;
    StringFeedbackPtr s;
    BellFeedbackPtr b;
    LedFeedbackPtr l;
    xGetFeedbackControlReply rep;

    REQUEST(xGetFeedbackControlReq);
    REQUEST_SIZE_MATCH(xGetFeedbackControlReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    rep.repType = X_Reply;
    rep.RepType = X_GetFeedbackControl;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.num_feedbacks = 0;

    for (k = dev->kbdfeed; k; k = k->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xKbdFeedbackState);
    }
    for (p = dev->ptrfeed; p; p = p->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xPtrFeedbackState);
    }
    for (s = dev->stringfeed; s; s = s->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xStringFeedbackState) +
	    (s->ctrl.num_symbols_supported * sizeof(KeySym));
    }
    for (i = dev->intfeed; i; i = i->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xIntegerFeedbackState);
    }
    for (l = dev->leds; l; l = l->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xLedFeedbackState);
    }
    for (b = dev->bell; b; b = b->next) {
	rep.num_feedbacks++;
	total_length += sizeof(xBellFeedbackState);
    }

    if (total_length == 0)
	return BadMatch;

    buf = (char *)malloc(total_length);
    if (!buf)
	return BadAlloc;
    savbuf = buf;

    for (k = dev->kbdfeed; k; k = k->next)
	CopySwapKbdFeedback(client, k, &buf);
    for (p = dev->ptrfeed; p; p = p->next)
	CopySwapPtrFeedback(client, p, &buf);
    for (s = dev->stringfeed; s; s = s->next)
	CopySwapStringFeedback(client, s, &buf);
    for (i = dev->intfeed; i; i = i->next)
	CopySwapIntegerFeedback(client, i, &buf);
    for (l = dev->leds; l; l = l->next)
	CopySwapLedFeedback(client, l, &buf);
    for (b = dev->bell; b; b = b->next)
	CopySwapBellFeedback(client, b, &buf);

    rep.length = bytes_to_int32(total_length);
    WriteReplyToClient(client, sizeof(xGetFeedbackControlReply), &rep);
    WriteToClient(client, total_length, savbuf);
    free(savbuf);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETFCTL_H
#define GETFCTL_H 1

int SProcXGetFeedbackControl(ClientPtr	/* client */
    );

int ProcXGetFeedbackControl(ClientPtr	/* client */
    );

void SRepXGetFeedbackControl(ClientPtr /* client */ ,
			     int /* size */ ,
			     xGetFeedbackControlReply *	/* rep */
    );

#endif /* GETFCTL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to get the focus for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "windowstr.h"	/* focus struct      */
#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "getfocus.h"

/***********************************************************************
 *
 * This procedure gets the focus for a device.
 *
 */

int
SProcXGetDeviceFocus(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceFocusReq);
    swaps(&stuff->length, n);
    return (ProcXGetDeviceFocus(client));
}

/***********************************************************************
 *
 * This procedure gets the focus for a device.
 *
 */

int
ProcXGetDeviceFocus(ClientPtr client)
{
    DeviceIntPtr dev;
    FocusClassPtr focus;
    xGetDeviceFocusReply rep;
    int rc;

    REQUEST(xGetDeviceFocusReq);
    REQUEST_SIZE_MATCH(xGetDeviceFocusReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetFocusAccess);
    if (rc != Success)
	return rc;
    if (!dev->focus)
	return BadDevice;

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceFocus;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    focus = dev->focus;

    if (focus->win == NoneWin)
	rep.focus = None;
    else if (focus->win == PointerRootWin)
	rep.focus = PointerRoot;
    else if (focus->win == FollowKeyboardWin)
	rep.focus = FollowKeyboard;
    else
	rep.focus = focus->win->drawable.id;

    rep.time = focus->time.milliseconds;
    rep.revertTo = focus->revert;
    WriteReplyToClient(client, sizeof(xGetDeviceFocusReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the GetDeviceFocus function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceFocus(ClientPtr client, int size, xGetDeviceFocusReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->focus, n);
    swapl(&rep->time, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETFOCUS_H
#define GETFOCUS_H 1

int SProcXGetDeviceFocus(ClientPtr	/* client */
    );

int ProcXGetDeviceFocus(ClientPtr	/* client */
    );

void SRepXGetDeviceFocus(ClientPtr /* client */ ,
			 int /* size */ ,
			 xGetDeviceFocusReply *	/* rep */
    );

#endif /* GETFOCUS_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Get the key mapping for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "swaprep.h"
#include "xkbsrv.h"
#include "xkbstr.h"

#include "getkmap.h"

/***********************************************************************
 *
 * This procedure gets the key mapping for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXGetDeviceKeyMapping(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceKeyMappingReq);
    swaps(&stuff->length, n);
    return (ProcXGetDeviceKeyMapping(client));
}

/***********************************************************************
 *
 * Get the device key mapping.
 *
 */

int
ProcXGetDeviceKeyMapping(ClientPtr client)
{
    xGetDeviceKeyMappingReply rep;
    DeviceIntPtr dev;
    XkbDescPtr xkb;
    KeySymsPtr syms;
    int rc;

    REQUEST(xGetDeviceKeyMappingReq);
    REQUEST_SIZE_MATCH(xGetDeviceKeyMappingReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    if (dev->key == NULL)
	return BadMatch;
    xkb = dev->key->xkbInfo->desc;

    if (stuff->firstKeyCode < xkb->min_key_code ||
	stuff->firstKeyCode > xkb->max_key_code) {
	client->errorValue = stuff->firstKeyCode;
	return BadValue;
    }

    if (stuff->firstKeyCode + stuff->count > xkb->max_key_code + 1) {
	client->errorValue = stuff->count;
	return BadValue;
    }

    syms = XkbGetCoreMap(dev);
    if (!syms)
        return BadAlloc;

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceKeyMapping;
    rep.sequenceNumber = client->sequence;
    rep.keySymsPerKeyCode = syms->mapWidth;
    rep.length = (syms->mapWidth * stuff->count);	/* KeySyms are 4 bytes */
    WriteReplyToClient(client, sizeof(xGetDeviceKeyMappingReply), &rep);

    client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
    WriteSwappedDataToClient(client,
                             syms->mapWidth * stuff->count * sizeof(KeySym),
                             &syms->map[syms->mapWidth * (stuff->firstKeyCode -
                                                          syms->minKeyCode)]);
    free(syms->map);
    free(syms);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceKeyMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceKeyMapping(ClientPtr client, int size,
			 xGetDeviceKeyMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETKMAP_H
#define GETKMAP_H 1

int SProcXGetDeviceKeyMapping(ClientPtr	/* client */
    );

int ProcXGetDeviceKeyMapping(ClientPtr	/* client */
    );

void SRepXGetDeviceKeyMapping(ClientPtr /* client */ ,
			      int /* size */ ,
			      xGetDeviceKeyMappingReply *	/* rep */
    );

#endif /* GETKMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Get the modifier mapping for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>	/* Request macro     */
#include "exglobals.h"

#include "getmmap.h"

/***********************************************************************
 *
 * This procedure gets the modifier mapping for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXGetDeviceModifierMapping(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceModifierMappingReq);
    swaps(&stuff->length, n);
    return (ProcXGetDeviceModifierMapping(client));
}

/***********************************************************************
 *
 * Get the device Modifier mapping.
 *
 */

int
ProcXGetDeviceModifierMapping(ClientPtr client)
{
    DeviceIntPtr dev;
    xGetDeviceModifierMappingReply rep;
    KeyCode *modkeymap = NULL;
    int ret, max_keys_per_mod;

    REQUEST(xGetDeviceModifierMappingReq);
    REQUEST_SIZE_MATCH(xGetDeviceModifierMappingReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (ret != Success)
	return ret;

    ret = generate_modkeymap(client, dev, &modkeymap, &max_keys_per_mod);
    if (ret != Success)
        return ret;

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceModifierMapping;
    rep.numKeyPerModifier = max_keys_per_mod;
    rep.sequenceNumber = client->sequence;
    /* length counts 4 byte quantities - there are 8 modifiers 1 byte big */
    rep.length = max_keys_per_mod << 1;

    WriteReplyToClient(client, sizeof(xGetDeviceModifierMappingReply), &rep);
    WriteToClient(client, max_keys_per_mod * 8, (char *) modkeymap);

    free(modkeymap);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceModifierMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceModifierMapping(ClientPtr client, int size,
			      xGetDeviceModifierMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETMMAP_H
#define GETMMAP_H 1

int SProcXGetDeviceModifierMapping(ClientPtr	/* client */
    );

int ProcXGetDeviceModifierMapping(ClientPtr	/* client */
    );

void SRepXGetDeviceModifierMapping(ClientPtr /* client */ ,
				   int /* size */ ,
				   xGetDeviceModifierMappingReply *	/* rep */
    );

#endif /* GETMMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Function to return the dont-propagate-list for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structs    */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "swaprep.h"

#include "getprop.h"

extern XExtEventInfo EventInfo[];
extern int ExtEventIndex;

/***********************************************************************
 *
 * Handle a request from a client with a different byte order.
 *
 */

int
SProcXGetDeviceDontPropagateList(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceDontPropagateListReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGetDeviceDontPropagateListReq);
    swapl(&stuff->window, n);
    return (ProcXGetDeviceDontPropagateList(client));
}

/***********************************************************************
 *
 * This procedure lists the input devices available to the server.
 *
 */

int
ProcXGetDeviceDontPropagateList(ClientPtr client)
{
    CARD16 count = 0;
    int i, rc;
    XEventClass *buf = NULL, *tbuf;
    WindowPtr pWin;
    xGetDeviceDontPropagateListReply rep;
    OtherInputMasks *others;

    REQUEST(xGetDeviceDontPropagateListReq);
    REQUEST_SIZE_MATCH(xGetDeviceDontPropagateListReq);

    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceDontPropagateList;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.count = 0;

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    if ((others = wOtherInputMasks(pWin)) != 0) {
	for (i = 0; i < EMASKSIZE; i++)
	    ClassFromMask(NULL, others->dontPropagateMask[i], i,
				 &count, COUNT);
	if (count) {
	    rep.count = count;
	    buf = (XEventClass *) malloc(rep.count * sizeof(XEventClass));
	    rep.length = bytes_to_int32(rep.count * sizeof(XEventClass));

	    tbuf = buf;
	    for (i = 0; i < EMASKSIZE; i++)
		tbuf = ClassFromMask(tbuf, others->dontPropagateMask[i], i,
				     NULL, CREATE);
	}
    }

    WriteReplyToClient(client, sizeof(xGetDeviceDontPropagateListReply), &rep);

    if (count) {
	client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	WriteSwappedDataToClient(client, count * sizeof(XEventClass), buf);
	free(buf);
    }
    return Success;
}

/***********************************************************************
 *
 * This procedure gets a list of event classes from a mask word.
 * A single mask may translate to more than one event class.
 *
 */

XEventClass
    * ClassFromMask(XEventClass * buf, Mask mask, int maskndx, CARD16 * count,
		    int mode)
{
    int i, j;
    int id = maskndx;
    Mask tmask = 0x80000000;

    for (i = 0; i < 32; i++, tmask >>= 1)
	if (tmask & mask) {
	    for (j = 0; j < ExtEventIndex; j++)
		if (EventInfo[j].mask == tmask) {
		    if (mode == COUNT)
			(*count)++;
		    else
			*buf++ = (id << 8) | EventInfo[j].type;
		}
	}
    return buf;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceDontPropagateList function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceDontPropagateList(ClientPtr client, int size,
				xGetDeviceDontPropagateListReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->count, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETPROP_H
#define GETPROP_H 1

int SProcXGetDeviceDontPropagateList(ClientPtr	/* client */
    );

int ProcXGetDeviceDontPropagateList(ClientPtr	/* client */
    );

XEventClass *ClassFromMask(XEventClass * /* buf */ ,
			   Mask /* mask */ ,
			   int /* maskndx */ ,
			   CARD16 * /* count */ ,
			   int	/* mode */
    );

void SRepXGetDeviceDontPropagateList(ClientPtr /* client */ ,
				     int /* size */ ,
				     xGetDeviceDontPropagateListReply *	/* rep */
    );

#endif /* GETPROP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to get the current selected events for a given window.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window struct     */
#include "exglobals.h"
#include "swaprep.h"

#include "getprop.h"
#include "getselev.h"

/***********************************************************************
 *
 * This procedure gets the current selected extension events.
 *
 */

int
SProcXGetSelectedExtensionEvents(ClientPtr client)
{
    char n;

    REQUEST(xGetSelectedExtensionEventsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGetSelectedExtensionEventsReq);
    swapl(&stuff->window, n);
    return (ProcXGetSelectedExtensionEvents(client));
}

/***********************************************************************
 *
 * This procedure gets the current device select mask,
 * if the client and server have a different byte ordering.
 *
 */

int
ProcXGetSelectedExtensionEvents(ClientPtr client)
{
    int i, rc, total_length = 0;
    xGetSelectedExtensionEventsReply rep;
    WindowPtr pWin;
    XEventClass *buf = NULL;
    XEventClass *tclient;
    XEventClass *aclient;
    OtherInputMasks *pOthers;
    InputClientsPtr others;

    REQUEST(xGetSelectedExtensionEventsReq);
    REQUEST_SIZE_MATCH(xGetSelectedExtensionEventsReq);

    rep.repType = X_Reply;
    rep.RepType = X_GetSelectedExtensionEvents;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.this_client_count = 0;
    rep.all_clients_count = 0;

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;

    if ((pOthers = wOtherInputMasks(pWin)) != 0) {
	for (others = pOthers->inputClients; others; others = others->next)
	    for (i = 0; i < EMASKSIZE; i++)
		ClassFromMask(NULL, others->mask[i], i,
					&rep.all_clients_count, COUNT);

	for (others = pOthers->inputClients; others; others = others->next)
	    if (SameClient(others, client)) {
		for (i = 0; i < EMASKSIZE; i++)
		    ClassFromMask(NULL, others->mask[i], i,
					    &rep.this_client_count, COUNT);
		break;
	    }

	total_length = (rep.all_clients_count + rep.this_client_count) *
	    sizeof(XEventClass);
	rep.length = bytes_to_int32(total_length);
	buf = (XEventClass *) malloc(total_length);

	tclient = buf;
	aclient = buf + rep.this_client_count;
	if (others)
	    for (i = 0; i < EMASKSIZE; i++)
		tclient =
		    ClassFromMask(tclient, others->mask[i], i, NULL, CREATE);

	for (others = pOthers->inputClients; others; others = others->next)
	    for (i = 0; i < EMASKSIZE; i++)
		aclient =
		    ClassFromMask(aclient, others->mask[i], i, NULL, CREATE);
    }

    WriteReplyToClient(client, sizeof(xGetSelectedExtensionEventsReply), &rep);

    if (total_length) {
	client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	WriteSwappedDataToClient(client, total_length, buf);
    }
    free(buf);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetSelectedExtensionEvents function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetSelectedExtensionEvents(ClientPtr client, int size,
				xGetSelectedExtensionEventsReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->this_client_count, n);
    swaps(&rep->all_clients_count, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETSELEV_H
#define GETSELEV_H 1

int SProcXGetSelectedExtensionEvents(ClientPtr	/* client */
    );

int ProcXGetSelectedExtensionEvents(ClientPtr	/* client */
    );

void SRepXGetSelectedExtensionEvents(ClientPtr /* client */ ,
				     int /* size */ ,
				     xGetSelectedExtensionEventsReply *	/* rep */
    );

#endif /* GETSELEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to return the version of the extension.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "getvers.h"

XExtensionVersion XIVersion;

/***********************************************************************
 *
 * Handle a request from a client with a different byte order than us.
 *
 */

int
SProcXGetExtensionVersion(ClientPtr client)
{
    char n;

    REQUEST(xGetExtensionVersionReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xGetExtensionVersionReq);
    swaps(&stuff->nbytes, n);
    return (ProcXGetExtensionVersion(client));
}

/***********************************************************************
 *
 * This procedure returns the major/minor version of the X Input extension.
 *
 */

int
ProcXGetExtensionVersion(ClientPtr client)
{
    xGetExtensionVersionReply rep;

    REQUEST(xGetExtensionVersionReq);
    REQUEST_AT_LEAST_SIZE(xGetExtensionVersionReq);

    if (stuff->length != bytes_to_int32(sizeof(xGetExtensionVersionReq) +
			  stuff->nbytes))
	return BadLength;

    memset(&rep, 0, sizeof(xGetExtensionVersionReply));
    rep.repType = X_Reply;
    rep.RepType = X_GetExtensionVersion;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.present = TRUE;
    rep.major_version = XIVersion.major_version;
    rep.minor_version = XIVersion.minor_version;

    WriteReplyToClient(client, sizeof(xGetExtensionVersionReply), &rep);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetExtensionVersion function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetExtensionVersion(ClientPtr client, int size,
			 xGetExtensionVersionReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->major_version, n);
    swaps(&rep->minor_version, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETVERS_H
#define GETVERS_H 1

int SProcXGetExtensionVersion(ClientPtr	/* client */
    );

int ProcXGetExtensionVersion(ClientPtr	/* client */
    );

void SRepXGetExtensionVersion(ClientPtr /* client */ ,
			      int /* size */ ,
			      xGetExtensionVersionReply *	/* rep */
    );

#endif /* GETVERS_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to grab an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "dixevents.h"	/* GrabDevice */

#include "grabdev.h"

extern XExtEventInfo EventInfo[];
extern int ExtEventIndex;

/***********************************************************************
 *
 * Swap the request if the requestor has a different byte order than us.
 *
 */

int
SProcXGrabDevice(ClientPtr client)
{
    char n;

    REQUEST(xGrabDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceReq);
    swapl(&stuff->grabWindow, n);
    swapl(&stuff->time, n);
    swaps(&stuff->event_count, n);

    if (stuff->length != bytes_to_int32(sizeof(xGrabDeviceReq)) + stuff->event_count)
       return BadLength;
    
    SwapLongs((CARD32 *) (&stuff[1]), stuff->event_count);

    return (ProcXGrabDevice(client));
}

/***********************************************************************
 *
 * Grab an extension device.
 *
 */

int
ProcXGrabDevice(ClientPtr client)
{
    int rc;
    xGrabDeviceReply rep;
    DeviceIntPtr dev;
    GrabMask mask;
    struct tmask tmp[EMASKSIZE];

    REQUEST(xGrabDeviceReq);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceReq);

    if (stuff->length != bytes_to_int32(sizeof(xGrabDeviceReq)) + stuff->event_count)
	return BadLength;

    rep.repType = X_Reply;
    rep.RepType = X_GrabDevice;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
    if (rc != Success)
	return rc;

    if ((rc = CreateMaskFromList(client, (XEventClass *) & stuff[1],
				 stuff->event_count, tmp, dev,
				 X_GrabDevice)) != Success)
	return rc;

    mask.xi = tmp[stuff->deviceid].mask;

    rc = GrabDevice(client, dev, stuff->other_devices_mode,
                    stuff->this_device_mode, stuff->grabWindow,
		    stuff->ownerEvents, stuff->time,
		    &mask, GRABTYPE_XI, None, None,
		    &rep.status);

    if (rc != Success)
	return rc;

    WriteReplyToClient(client, sizeof(xGrabDeviceReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure creates an event mask from a list of XEventClasses.
 *
 * Procedure is as follows:
 * An XEventClass is (deviceid << 8 | eventtype). For each entry in the list,
 * get the device. Then run through all available event indices (those are
 * set when XI starts up) and binary OR's the device's mask to whatever the
 * event mask for the given event type was.
 * If an error occurs, it is sent to the client. Errors are generated if
 *  - if the device given in the event classs is invalid
 *  - if the device in the class list is not the device given as parameter (no
 *  error if parameter is NULL)
 *
 * mask has to be size EMASKSIZE and pre-allocated.
 *
 * @param client The client to send the error to (if one occurs)
 * @param list List of event classes as sent from the client.
 * @param count Number of elements in list.
 * @param mask Preallocated mask (size EMASKSIZE).
 * @param dev The device we're creating masks for.
 * @param req The request we're processing. Used to fill in error fields.
 */

int
CreateMaskFromList(ClientPtr client, XEventClass * list, int count,
		   struct tmask *mask, DeviceIntPtr dev, int req)
{
    int rc, i, j;
    int device;
    DeviceIntPtr tdev;

    for (i = 0; i < EMASKSIZE; i++) {
	mask[i].mask = 0;
	mask[i].dev = NULL;
    }

    for (i = 0; i < count; i++, list++) {
	device = *list >> 8;
	if (device > 255)
	    return BadClass;

	rc = dixLookupDevice(&tdev, device, client, DixUseAccess);
	if (rc != BadDevice && rc != Success)
	    return rc;
	if (rc == BadDevice || (dev != NULL && tdev != dev))
	    return BadClass;

	for (j = 0; j < ExtEventIndex; j++)
	    if (EventInfo[j].type == (*list & 0xff)) {
		mask[device].mask |= EventInfo[j].mask;
		mask[device].dev = (Pointer) tdev;
		break;
	    }
    }
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGrabDevice function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGrabDevice(ClientPtr client, int size, xGrabDeviceReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GRABDEV_H
#define GRABDEV_H 1

int SProcXGrabDevice(ClientPtr	/* client */
    );

int ProcXGrabDevice(ClientPtr	/* client */
    );

int CreateMaskFromList(ClientPtr /* client */ ,
		       XEventClass * /* list */ ,
		       int /* count */ ,
		       struct tmask /* mask */ [],
		       DeviceIntPtr /* dev */ ,
		       int	/* req */
    );

void SRepXGrabDevice(ClientPtr /* client */ ,
		     int /* size */ ,
		     xGrabDeviceReply *	/* rep */
    );

#endif /* GRABDEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to grab a button on an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"
#include "xace.h"

#include "grabdev.h"
#include "grabdevb.h"

/***********************************************************************
 *
 * Handle requests from clients with a different byte order.
 *
 */

int
SProcXGrabDeviceButton(ClientPtr client)
{
    char n;

    REQUEST(xGrabDeviceButtonReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceButtonReq);
    swapl(&stuff->grabWindow, n);
    swaps(&stuff->modifiers, n);
    swaps(&stuff->event_count, n);
    REQUEST_FIXED_SIZE(xGrabDeviceButtonReq,
                      stuff->event_count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), stuff->event_count);

    return (ProcXGrabDeviceButton(client));
}

/***********************************************************************
 *
 * Grab a button on an extension device.
 *
 */

int
ProcXGrabDeviceButton(ClientPtr client)
{
    int ret;
    DeviceIntPtr dev;
    DeviceIntPtr mdev;
    XEventClass *class;
    struct tmask tmp[EMASKSIZE];
    GrabParameters param;
    GrabMask mask;

    REQUEST(xGrabDeviceButtonReq);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceButtonReq);

    if (stuff->length !=
	bytes_to_int32(sizeof(xGrabDeviceButtonReq)) + stuff->event_count)
	return BadLength;

    ret = dixLookupDevice(&dev, stuff->grabbed_device, client, DixGrabAccess);
    if (ret != Success)
	return ret;

    if (stuff->modifier_device != UseXKeyboard) {
	ret = dixLookupDevice(&mdev, stuff->modifier_device, client,
			      DixUseAccess);
	if (ret != Success)
	    return ret;
	if (mdev->key == NULL)
	    return BadMatch;
    } else {
	mdev = PickKeyboard(client);
	ret = XaceHook(XACE_DEVICE_ACCESS, client, mdev, DixUseAccess);
	if (ret != Success)
	    return ret;
    }

    class = (XEventClass *) (&stuff[1]);	/* first word of values */

    if ((ret = CreateMaskFromList(client, class,
				  stuff->event_count, tmp, dev,
				  X_GrabDeviceButton)) != Success)
	return ret;

    memset(&param, 0, sizeof(param));
    param.grabtype = GRABTYPE_XI;
    param.ownerEvents = stuff->ownerEvents;
    param.this_device_mode = stuff->this_device_mode;
    param.other_devices_mode = stuff->other_devices_mode;
    param.grabWindow = stuff->grabWindow;
    param.modifiers = stuff->modifiers;
    mask.xi = tmp[stuff->grabbed_device].mask;

    ret = GrabButton(client, dev, mdev, stuff->button, &param,
                     GRABTYPE_XI, &mask);

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GRABDEVB_H
#define GRABDEVB_H 1

int SProcXGrabDeviceButton(ClientPtr	/* client */
    );

int ProcXGrabDeviceButton(ClientPtr	/* client */
    );

#endif /* GRABDEVB_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to grab a key on an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"
#include "xace.h"

#include "grabdev.h"
#include "grabdevk.h"

/***********************************************************************
 *
 * Handle requests from clients with a different byte order.
 *
 */

int
SProcXGrabDeviceKey(ClientPtr client)
{
    char n;

    REQUEST(xGrabDeviceKeyReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceKeyReq);
    swapl(&stuff->grabWindow, n);
    swaps(&stuff->modifiers, n);
    swaps(&stuff->event_count, n);
    REQUEST_FIXED_SIZE(xGrabDeviceKeyReq, stuff->event_count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), stuff->event_count);
    return (ProcXGrabDeviceKey(client));
}

/***********************************************************************
 *
 * Grab a key on an extension device.
 *
 */

int
ProcXGrabDeviceKey(ClientPtr client)
{
    int ret;
    DeviceIntPtr dev;
    DeviceIntPtr mdev;
    XEventClass *class;
    struct tmask tmp[EMASKSIZE];
    GrabParameters param;
    GrabMask mask;

    REQUEST(xGrabDeviceKeyReq);
    REQUEST_AT_LEAST_SIZE(xGrabDeviceKeyReq);

    if (stuff->length != bytes_to_int32(sizeof(xGrabDeviceKeyReq)) + stuff->event_count)
	return BadLength;

    ret = dixLookupDevice(&dev, stuff->grabbed_device, client, DixGrabAccess);
    if (ret != Success)
	return ret;

    if (stuff->modifier_device != UseXKeyboard) {
	ret = dixLookupDevice(&mdev, stuff->modifier_device, client,
			      DixUseAccess);
	if (ret != Success)
	    return ret;
	if (mdev->key == NULL)
	    return BadMatch;
    } else {
	mdev = PickKeyboard(client);
	ret = XaceHook(XACE_DEVICE_ACCESS, client, mdev, DixUseAccess);
	if (ret != Success)
	    return ret;
    }

    class = (XEventClass *) (&stuff[1]);	/* first word of values */

    if ((ret = CreateMaskFromList(client, class,
				  stuff->event_count, tmp, dev,
				  X_GrabDeviceKey)) != Success)
	return ret;


    memset(&param, 0, sizeof(param));
    param.grabtype = GRABTYPE_XI;
    param.ownerEvents = stuff->ownerEvents;
    param.this_device_mode = stuff->this_device_mode;
    param.other_devices_mode = stuff->other_devices_mode;
    param.grabWindow = stuff->grabWindow;
    param.modifiers = stuff->modifiers;
    mask.xi = tmp[stuff->grabbed_device].mask;

    ret = GrabKey(client, dev, mdev, stuff->key, &param, GRABTYPE_XI, &mask);

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GRABDEVK_H
#define GRABDEVK_H 1

int SProcXGrabDeviceKey(ClientPtr	/* client */
    );

int ProcXGrabDeviceKey(ClientPtr	/* client */
    );

#endif /* GRABDEVK_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to get the motion history from an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "gtmotion.h"

/***********************************************************************
 *
 * Swap the request if server and client have different byte ordering.
 *
 */

int
SProcXGetDeviceMotionEvents(ClientPtr client)
{
    char n;

    REQUEST(xGetDeviceMotionEventsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xGetDeviceMotionEventsReq);
    swapl(&stuff->start, n);
    swapl(&stuff->stop, n);
    return (ProcXGetDeviceMotionEvents(client));
}

/****************************************************************************
 *
 * Get the motion history for an extension pointer devices.
 *
 */

int
ProcXGetDeviceMotionEvents(ClientPtr client)
{
    INT32 *coords = NULL, *bufptr;
    xGetDeviceMotionEventsReply rep;
    unsigned long i;
    int rc, num_events, axes, size = 0;
    unsigned long nEvents;
    DeviceIntPtr dev;
    TimeStamp start, stop;
    int length = 0;
    ValuatorClassPtr v;

    REQUEST(xGetDeviceMotionEventsReq);

    REQUEST_SIZE_MATCH(xGetDeviceMotionEventsReq);
    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixReadAccess);
    if (rc != Success)
	return rc;
    v = dev->valuator;
    if (v == NULL || v->numAxes == 0)
	return BadMatch;
    if (dev->valuator->motionHintWindow)
	MaybeStopDeviceHint(dev, client);
    axes = v->numAxes;
    rep.repType = X_Reply;
    rep.RepType = X_GetDeviceMotionEvents;
    rep.sequenceNumber = client->sequence;
    rep.nEvents = 0;
    rep.axes = axes;
    rep.mode = Absolute; /* XXX we don't do relative at the moment */
    rep.length = 0;
    start = ClientTimeToServerTime(stuff->start);
    stop = ClientTimeToServerTime(stuff->stop);
    if (CompareTimeStamps(start, stop) == LATER ||
	CompareTimeStamps(start, currentTime) == LATER) {
	WriteReplyToClient(client, sizeof(xGetDeviceMotionEventsReply), &rep);
	return Success;
    }
    if (CompareTimeStamps(stop, currentTime) == LATER)
	stop = currentTime;
    num_events = v->numMotionEvents;
    if (num_events) {
        size = sizeof(Time) + (axes * sizeof(INT32));
	rep.nEvents = GetMotionHistory(dev, (xTimecoord **) &coords,/* XXX */
					start.milliseconds, stop.milliseconds,
					(ScreenPtr) NULL, FALSE);
    }
    if (rep.nEvents > 0) {
	length = bytes_to_int32(rep.nEvents * size);
	rep.length = length;
    }
    nEvents = rep.nEvents;
    WriteReplyToClient(client, sizeof(xGetDeviceMotionEventsReply), &rep);
    if (nEvents) {
	if (client->swapped) {
	    char n;

	    bufptr = coords;
	    for (i = 0; i < nEvents * (axes + 1); i++) {
		swapl(bufptr, n);
		bufptr++;
	    }
	}
	WriteToClient(client, length * 4, (char *)coords);
    }
    free(coords);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetDeviceMotionEvents function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXGetDeviceMotionEvents(ClientPtr client, int size,
			   xGetDeviceMotionEventsReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->nEvents, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GTMOTION_H
#define GTMOTION_H 1

int SProcXGetDeviceMotionEvents(ClientPtr	/* client */
    );

int ProcXGetDeviceMotionEvents(ClientPtr	/* client */
    );

void SRepXGetDeviceMotionEvents(ClientPtr /* client */ ,
				int /* size */ ,
				xGetDeviceMotionEventsReply *	/* rep */
    );

#endif /* GTMOTION_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Extension function to list the available input devices.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "extnsionst.h"
#include "exevents.h"
#include "xace.h"
#include "xkbsrv.h"
#include "xkbstr.h"

#include "listdev.h"


/***********************************************************************
 *
 * This procedure lists the input devices available to the server.
 *
 */

int
SProcXListInputDevices(ClientPtr client)
{
    char n;

    REQUEST(xListInputDevicesReq);
    swaps(&stuff->length, n);
    return (ProcXListInputDevices(client));
}

/***********************************************************************
 *
 * This procedure calculates the size of the information to be returned
 * for an input device.
 *
 */

static void
SizeDeviceInfo(DeviceIntPtr d, int *namesize, int *size)
{
    int chunks;

    *namesize += 1;
    if (d->name)
	*namesize += strlen(d->name);
    if (d->key != NULL)
	*size += sizeof(xKeyInfo);
    if (d->button != NULL)
	*size += sizeof(xButtonInfo);
    if (d->valuator != NULL) {
	chunks = ((int)d->valuator->numAxes + 19) / VPC;
	*size += (chunks * sizeof(xValuatorInfo) +
		  d->valuator->numAxes * sizeof(xAxisInfo));
    }
}

/***********************************************************************
 *
 * This procedure copies data to the DeviceInfo struct, swapping if necessary.
 *
 * We need the extra byte in the allocated buffer, because the trailing null
 * hammers one extra byte, which is overwritten by the next name except for
 * the last name copied.
 *
 */

static void
CopyDeviceName(char **namebuf, char *name)
{
    char *nameptr = (char *)*namebuf;

    if (name) {
	*nameptr++ = strlen(name);
	strcpy(nameptr, name);
	*namebuf += (strlen(name) + 1);
    } else {
	*nameptr++ = 0;
	*namebuf += 1;
    }
}

/***********************************************************************
 *
 * This procedure copies ButtonClass information, swapping if necessary.
 *
 */

static void
CopySwapButtonClass(ClientPtr client, ButtonClassPtr b, char **buf)
{
    char n;
    xButtonInfoPtr b2;

    b2 = (xButtonInfoPtr) * buf;
    b2->class = ButtonClass;
    b2->length = sizeof(xButtonInfo);
    b2->num_buttons = b->numButtons;
    if (client && client->swapped) {
	swaps(&b2->num_buttons, n);	/* macro - braces are required */
    }
    *buf += sizeof(xButtonInfo);
}

/***********************************************************************
 *
 * This procedure copies data to the DeviceInfo struct, swapping if necessary.
 *
 */

static void
CopySwapDevice(ClientPtr client, DeviceIntPtr d, int num_classes,
	       char **buf)
{
    char n;
    xDeviceInfoPtr dev;

    dev = (xDeviceInfoPtr) * buf;

    dev->id = d->id;
    dev->type = d->xinput_type;
    dev->num_classes = num_classes;
    if (IsMaster(d) && IsKeyboardDevice(d))
	dev->use = IsXKeyboard;
    else if (IsMaster(d) && IsPointerDevice(d))
	dev->use = IsXPointer;
    else if (d->valuator && d->button)
        dev->use = IsXExtensionPointer;
    else if (d->key && d->kbdfeed)
        dev->use = IsXExtensionKeyboard;
    else
	dev->use = IsXExtensionDevice;

    if (client->swapped) {
	swapl(&dev->type, n);	/* macro - braces are required */
    }
    *buf += sizeof(xDeviceInfo);
}

/***********************************************************************
 *
 * This procedure copies KeyClass information, swapping if necessary.
 *
 */

static void
CopySwapKeyClass(ClientPtr client, KeyClassPtr k, char **buf)
{
    char n;
    xKeyInfoPtr k2;

    k2 = (xKeyInfoPtr) * buf;
    k2->class = KeyClass;
    k2->length = sizeof(xKeyInfo);
    k2->min_keycode = k->xkbInfo->desc->min_key_code;
    k2->max_keycode = k->xkbInfo->desc->max_key_code;
    k2->num_keys = k2->max_keycode - k2->min_keycode + 1;
    if (client && client->swapped) {
	swaps(&k2->num_keys, n);
    }
    *buf += sizeof(xKeyInfo);
}

/***********************************************************************
 *
 * This procedure copies ValuatorClass information, swapping if necessary.
 *
 * Devices may have up to 255 valuators.  The length of a ValuatorClass is
 * defined to be sizeof(ValuatorClassInfo) + num_axes * sizeof (xAxisInfo).
 * The maximum length is therefore (8 + 255 * 12) = 3068.  However, the
 * length field is one byte.  If a device has more than 20 valuators, we
 * must therefore return multiple valuator classes to the client.
 *
 */

static int
CopySwapValuatorClass(ClientPtr client, DeviceIntPtr dev, char **buf)
{
    int i, j, axes, t_axes;
    char n;
    ValuatorClassPtr v = dev->valuator;
    xValuatorInfoPtr v2;
    AxisInfo *a;
    xAxisInfoPtr a2;

    for (i = 0, axes = v->numAxes; i < ((v->numAxes + 19) / VPC);
	 i++, axes -= VPC) {
	t_axes = axes < VPC ? axes : VPC;
	if (t_axes < 0)
	    t_axes = v->numAxes % VPC;
	v2 = (xValuatorInfoPtr) * buf;
	v2->class = ValuatorClass;
	v2->length = sizeof(xValuatorInfo) + t_axes * sizeof(xAxisInfo);
	v2->num_axes = t_axes;
	v2->mode = valuator_get_mode(dev, 0);
	v2->motion_buffer_size = v->numMotionEvents;
	if (client && client->swapped) {
	    swapl(&v2->motion_buffer_size, n);
	}
	*buf += sizeof(xValuatorInfo);
	a = v->axes + (VPC * i);
	a2 = (xAxisInfoPtr) * buf;
	for (j = 0; j < t_axes; j++) {
	    a2->min_value = a->min_value;
	    a2->max_value = a->max_value;
	    a2->resolution = a->resolution;
	    if (client && client->swapped) {
		swapl(&a2->min_value, n);
		swapl(&a2->max_value, n);
		swapl(&a2->resolution, n);
	    }
	    a2++;
	    a++;
	    *buf += sizeof(xAxisInfo);
	}
    }
    return i;
}

static void
CopySwapClasses(ClientPtr client, DeviceIntPtr dev, CARD8 *num_classes,
                char** classbuf)
{
    if (dev->key != NULL) {
	CopySwapKeyClass(client, dev->key, classbuf);
	(*num_classes)++;
    }
    if (dev->button != NULL) {
	CopySwapButtonClass(client, dev->button, classbuf);
	(*num_classes)++;
    }
    if (dev->valuator != NULL) {
	(*num_classes) +=
	    CopySwapValuatorClass(client, dev, classbuf);
    }
}

/***********************************************************************
 *
 * This procedure lists information to be returned for an input device.
 *
 */

static void
ListDeviceInfo(ClientPtr client, DeviceIntPtr d, xDeviceInfoPtr dev,
	       char **devbuf, char **classbuf, char **namebuf)
{
    CopyDeviceName(namebuf, d->name);
    CopySwapDevice(client, d, 0, devbuf);
    CopySwapClasses(client, d, &dev->num_classes, classbuf);
}

/***********************************************************************
 *
 * This procedure checks if a device should be left off the list.
 *
 */

static Bool
ShouldSkipDevice(ClientPtr client, DeviceIntPtr d)
{
    /* don't send master devices other than VCP/VCK */
    if (!IsMaster(d) || d == inputInfo.pointer || d == inputInfo.keyboard)
    {
        int rc = XaceHook(XACE_DEVICE_ACCESS, client, d, DixGetAttrAccess);
        if (rc == Success)
            return FALSE;
    }
    return TRUE;
}


/***********************************************************************
 *
 * This procedure lists the input devices available to the server.
 *
 * If this request is called by a client that has not issued a
 * GetExtensionVersion request with major/minor version set, we don't send the
 * complete device list. Instead, we only send the VCP, the VCK and floating
 * SDs. This resembles the setup found on XI 1.x machines.
 */

int
ProcXListInputDevices(ClientPtr client)
{
    xListInputDevicesReply rep;
    int numdevs = 0;
    int namesize = 1;	/* need 1 extra byte for strcpy */
    int i = 0, size = 0;
    int total_length;
    char *devbuf, *classbuf, *namebuf, *savbuf;
    Bool *skip;
    xDeviceInfo *dev;
    DeviceIntPtr d;

    REQUEST_SIZE_MATCH(xListInputDevicesReq);

    memset(&rep, 0, sizeof(xListInputDevicesReply));
    rep.repType = X_Reply;
    rep.RepType = X_ListInputDevices;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    /* allocate space for saving skip value */
    skip = calloc(sizeof(Bool), inputInfo.numDevices);
    if (!skip)
        return BadAlloc;

    /* figure out which devices to skip */
    numdevs = 0;
    for (d = inputInfo.devices; d; d = d->next, i++) {
        skip[i] = ShouldSkipDevice(client, d);
        if (skip[i])
            continue;

        SizeDeviceInfo(d, &namesize, &size);
        numdevs++;
    }

    for (d = inputInfo.off_devices; d; d = d->next, i++) {
        skip[i] = ShouldSkipDevice(client, d);
        if (skip[i])
            continue;

        SizeDeviceInfo(d, &namesize, &size);
        numdevs++;
    }

    /* allocate space for reply */
    total_length = numdevs * sizeof(xDeviceInfo) + size + namesize;
    devbuf = (char *)calloc(1, total_length);
    classbuf = devbuf + (numdevs * sizeof(xDeviceInfo));
    namebuf = classbuf + size;
    savbuf = devbuf;

    /* fill in and send reply */
    i = 0;
    dev = (xDeviceInfoPtr) devbuf;
    for (d = inputInfo.devices; d; d = d->next, i++) {
        if (skip[i])
            continue;

        ListDeviceInfo(client, d, dev++, &devbuf, &classbuf, &namebuf);
    }

    for (d = inputInfo.off_devices; d; d = d->next, i++) {
        if (skip[i])
            continue;

        ListDeviceInfo(client, d, dev++, &devbuf, &classbuf, &namebuf);
    }
    rep.ndevices = numdevs;
    rep.length = bytes_to_int32(total_length);
    WriteReplyToClient(client, sizeof(xListInputDevicesReply), &rep);
    WriteToClient(client, total_length, savbuf);
    free(savbuf);
    free(skip);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XListInputDevices function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXListInputDevices(ClientPtr client, int size, xListInputDevicesReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef LISTDEV_H
#define LISTDEV_H 1

#define VPC	20	/* Max # valuators per chunk */

int SProcXListInputDevices(ClientPtr	/* client */
    );

int ProcXListInputDevices(ClientPtr	/* client */
    );

void SRepXListInputDevices(ClientPtr /* client */ ,
			   int /* size */ ,
			   xListInputDevicesReply *	/* rep */
    );

#endif /* LISTDEV_H */
noinst_LTLIBRARIES = libXi.la

AM_CFLAGS = $(DIX_CFLAGS)

libXi_la_SOURCES =	\
	allowev.c \
	allowev.h \
	chgdctl.c \
	chgdctl.h \
	chgfctl.c \
	chgfctl.h \
	chgkbd.c \
	chgkbd.h \
	chgkmap.c \
	chgkmap.h \
	chgprop.c \
	chgprop.h \
	chgptr.c \
	chgptr.h \
	closedev.c \
	closedev.h \
	devbell.c \
	devbell.h \
	exevents.c \
	exglobals.h \
	extinit.c \
	getbmap.c \
	getbmap.h \
	getdctl.c \
	getdctl.h \
	getfctl.c \
	getfctl.h \
	getfocus.c \
	getfocus.h \
	getkmap.c \
	getkmap.h \
	getmmap.c \
	getmmap.h \
	getprop.c \
	getprop.h \
	getselev.c \
	getselev.h \
	getvers.c \
	getvers.h \
	grabdev.c \
	grabdev.h \
	grabdevb.c \
	grabdevb.h \
	grabdevk.c \
	grabdevk.h \
	gtmotion.c \
	gtmotion.h \
	listdev.c \
	listdev.h \
	opendev.c \
	opendev.h \
	queryst.c \
	queryst.h \
	selectev.c \
	selectev.h \
	sendexev.c \
	sendexev.h \
	setbmap.c \
	setbmap.h \
	setdval.c \
	setdval.h \
	setfocus.c \
	setfocus.h \
	setmmap.c \
	setmmap.h \
	setmode.c \
	setmode.h \
	ungrdev.c \
	ungrdev.h \
	ungrdevb.c \
	ungrdevb.h \
	ungrdevk.c \
	ungrdevk.h \
	xiallowev.c \
	xiallowev.h \
	xichangecursor.c \
	xichangecursor.h \
	xichangehierarchy.c \
	xichangehierarchy.h \
	xigetclientpointer.c \
	xigetclientpointer.h \
	xigrabdev.c \
	xigrabdev.h \
	xipassivegrab.h \
	xipassivegrab.c \
	xiproperty.c \
	xiproperty.h \
	xiquerydevice.c \
	xiquerydevice.h \
	xiquerypointer.c \
	xiquerypointer.h \
	xiqueryversion.c \
	xiqueryversion.h \
	xiselectev.c \
	xiselectev.h \
	xisetclientpointer.c \
	xisetclientpointer.h \
	xisetdevfocus.c \
	xisetdevfocus.h \
	xiwarppointer.c \
	xiwarppointer.h

EXTRA_DIST = stubs.c
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to open an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "windowstr.h"	/* window structure  */
#include "exglobals.h"
#include "exevents.h"

#include "opendev.h"

extern CARD8 event_base[];

/***********************************************************************
 *
 * This procedure swaps the request if the server and client have different
 * byte orderings.
 *
 */

int
SProcXOpenDevice(ClientPtr client)
{
    char n;

    REQUEST(xOpenDeviceReq);
    swaps(&stuff->length, n);
    return (ProcXOpenDevice(client));
}

/***********************************************************************
 *
 * This procedure causes the server to open an input device.
 *
 */

int
ProcXOpenDevice(ClientPtr client)
{
    xInputClassInfo evbase[numInputClasses];
    int j = 0;
    int status = Success;
    xOpenDeviceReply rep;
    DeviceIntPtr dev;

    REQUEST(xOpenDeviceReq);
    REQUEST_SIZE_MATCH(xOpenDeviceReq);

    status = dixLookupDevice(&dev, stuff->deviceid, client, DixUseAccess);

    if (status == BadDevice) {  /* not open */
	for (dev = inputInfo.off_devices; dev; dev = dev->next)
	    if (dev->id == stuff->deviceid)
		break;
	if (dev == NULL)
	    return BadDevice;
    } else if (status != Success)
	return status;

    if (IsMaster(dev))
            return BadDevice;

    if (status != Success)
	return status;

    memset(&rep, 0, sizeof(xOpenDeviceReply));
    rep.repType = X_Reply;
    rep.RepType = X_OpenDevice;
    rep.sequenceNumber = client->sequence;
    if (dev->key != NULL) {
	evbase[j].class = KeyClass;
	evbase[j++].event_type_base = event_base[KeyClass];
    }
    if (dev->button != NULL) {
	evbase[j].class = ButtonClass;
	evbase[j++].event_type_base = event_base[ButtonClass];
    }
    if (dev->valuator != NULL) {
	evbase[j].class = ValuatorClass;
	evbase[j++].event_type_base = event_base[ValuatorClass];
    }
    if (dev->kbdfeed != NULL || dev->ptrfeed != NULL || dev->leds != NULL ||
	dev->intfeed != NULL || dev->bell != NULL || dev->stringfeed != NULL) {
	evbase[j].class = FeedbackClass;
	evbase[j++].event_type_base = event_base[FeedbackClass];
    }
    if (dev->focus != NULL) {
	evbase[j].class = FocusClass;
	evbase[j++].event_type_base = event_base[FocusClass];
    }
    if (dev->proximity != NULL) {
	evbase[j].class = ProximityClass;
	evbase[j++].event_type_base = event_base[ProximityClass];
    }
    evbase[j].class = OtherClass;
    evbase[j++].event_type_base = event_base[OtherClass];
    rep.length = bytes_to_int32(j * sizeof(xInputClassInfo));
    rep.num_classes = j;
    WriteReplyToClient(client, sizeof(xOpenDeviceReply), &rep);
    WriteToClient(client, j * sizeof(xInputClassInfo), (char *)evbase);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XOpenDevice function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXOpenDevice(ClientPtr client, int size, xOpenDeviceReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef OPENDEV_H
#define OPENDEV_H 1

int SProcXOpenDevice(ClientPtr	/* client */
    );

int ProcXOpenDevice(ClientPtr	/* client */
    );

void SRepXOpenDevice(ClientPtr /* client */ ,
		     int /* size */ ,
		     xOpenDeviceReply *	/* rep */
    );

#endif /* OPENDEV_H */
/*

Copyright 1998, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/***********************************************************************
 *
 * Request to query the state of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"
#include "xkbsrv.h"
#include "xkbstr.h"

#include "queryst.h"

/***********************************************************************
 *
 * This procedure allows a client to query the state of a device.
 *
 */

int
SProcXQueryDeviceState(ClientPtr client)
{
    char n;

    REQUEST(xQueryDeviceStateReq);
    swaps(&stuff->length, n);
    return (ProcXQueryDeviceState(client));
}

/***********************************************************************
 *
 * This procedure allows frozen events to be routed.
 *
 */

int
ProcXQueryDeviceState(ClientPtr client)
{
    char n;
    int rc, i;
    int num_classes = 0;
    int total_length = 0;
    char *buf, *savbuf;
    KeyClassPtr k;
    xKeyState *tk;
    ButtonClassPtr b;
    xButtonState *tb;
    ValuatorClassPtr v;
    xValuatorState *tv;
    xQueryDeviceStateReply rep;
    DeviceIntPtr dev;
    double *values;

    REQUEST(xQueryDeviceStateReq);
    REQUEST_SIZE_MATCH(xQueryDeviceStateReq);

    rep.repType = X_Reply;
    rep.RepType = X_QueryDeviceState;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixReadAccess);
    if (rc != Success && rc != BadAccess)
	return rc;

    v = dev->valuator;
    if (v != NULL && v->motionHintWindow != NULL)
	MaybeStopDeviceHint(dev, client);

    k = dev->key;
    if (k != NULL) {
	total_length += sizeof(xKeyState);
	num_classes++;
    }

    b = dev->button;
    if (b != NULL) {
	total_length += sizeof(xButtonState);
	num_classes++;
    }

    if (v != NULL) {
	total_length += (sizeof(xValuatorState) + (v->numAxes * sizeof(int)));
	num_classes++;
    }
    buf = (char *)calloc(total_length, 1);
    if (!buf)
	return BadAlloc;
    savbuf = buf;

    if (k != NULL) {
	tk = (xKeyState *) buf;
	tk->class = KeyClass;
	tk->length = sizeof(xKeyState);
	tk->num_keys = k->xkbInfo->desc->max_key_code -
                       k->xkbInfo->desc->min_key_code + 1;
	if (rc != BadAccess)
	    for (i = 0; i < 32; i++)
		tk->keys[i] = k->down[i];
	buf += sizeof(xKeyState);
    }

    if (b != NULL) {
	tb = (xButtonState *) buf;
	tb->class = ButtonClass;
	tb->length = sizeof(xButtonState);
	tb->num_buttons = b->numButtons;
	if (rc != BadAccess)
	    memcpy(tb->buttons, b->down, sizeof(b->down));
	buf += sizeof(xButtonState);
    }

    if (v != NULL) {
	tv = (xValuatorState *) buf;
	tv->class = ValuatorClass;
	tv->length = sizeof(xValuatorState) + v->numAxes * 4;
	tv->num_valuators = v->numAxes;
	tv->mode = valuator_get_mode(dev, 0);
	tv->mode |= (dev->proximity && !dev->proximity->in_proximity) ? OutOfProximity : 0;
	buf += sizeof(xValuatorState);
	for (i = 0, values = v->axisVal; i < v->numAxes; i++) {
	    if (rc != BadAccess)
		*((int *)buf) = *values;
	    values++;
	    if (client->swapped) {
		swapl((int *)buf, n);	/* macro - braces needed */
	    }
	    buf += sizeof(int);
	}
    }

    rep.num_classes = num_classes;
    rep.length = bytes_to_int32(total_length);
    WriteReplyToClient(client, sizeof(xQueryDeviceStateReply), &rep);
    if (total_length > 0)
	WriteToClient(client, total_length, savbuf);
    free(savbuf);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XQueryDeviceState function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXQueryDeviceState(ClientPtr client, int size, xQueryDeviceStateReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef QUERYST_H
#define QUERYST_H 1

int SProcXQueryDeviceState(ClientPtr	/* client */
    );

int ProcXQueryDeviceState(ClientPtr	/* client */
    );

void SRepXQueryDeviceState(ClientPtr /* client */ ,
			   int /* size */ ,
			   xQueryDeviceStateReply *	/* rep */
    );

#endif /* QUERYST_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to select input from an extension device.
 *
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "grabdev.h"
#include "selectev.h"

extern Mask ExtExclusiveMasks[];

static int
HandleDevicePresenceMask(ClientPtr client, WindowPtr win,
                         XEventClass *cls, CARD16 *count)
{
    int i, j;
    Mask mask;

    /* We use the device ID 256 to select events that aren't bound to
     * any device.  For now we only handle the device presence event,
     * but this could be extended to other events that aren't bound to
     * a device.
     *
     * In order not to break in CreateMaskFromList() we remove the
     * entries with device ID 256 from the XEventClass array.
     */

    mask = 0;
    for (i = 0, j = 0; i < *count; i++) {
        if (cls[i] >> 8 != 256) {
            cls[j] = cls[i];
            j++;
            continue;
        }

        switch (cls[i] & 0xff) {
        case _devicePresence:
            mask |= DevicePresenceNotifyMask;
            break;
        }
    }

    *count = j;

    if (mask == 0)
        return Success;

    /* We always only use mksidx = AllDevices for events not bound to
     * devices */
    if (AddExtensionClient (win, client, mask, XIAllDevices) != Success)
        return BadAlloc;

    RecalculateDeviceDeliverableEvents(win);

    return Success;
}

/***********************************************************************
 *
 * Handle requests from clients with a different byte order.
 *
 */

int
SProcXSelectExtensionEvent(ClientPtr client)
{
    char n;

    REQUEST(xSelectExtensionEventReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSelectExtensionEventReq);
    swapl(&stuff->window, n);
    swaps(&stuff->count, n);
    REQUEST_FIXED_SIZE(xSelectExtensionEventReq,
                      stuff->count * sizeof(CARD32));
    SwapLongs((CARD32 *) (&stuff[1]), stuff->count);

    return (ProcXSelectExtensionEvent(client));
}

/***********************************************************************
 *
 * This procedure selects input from an extension device.
 *
 */

int
ProcXSelectExtensionEvent(ClientPtr client)
{
    int ret;
    int i;
    WindowPtr pWin;
    struct tmask tmp[EMASKSIZE];

    REQUEST(xSelectExtensionEventReq);
    REQUEST_AT_LEAST_SIZE(xSelectExtensionEventReq);

    if (stuff->length != bytes_to_int32(sizeof(xSelectExtensionEventReq)) + stuff->count)
	return BadLength;

    ret = dixLookupWindow(&pWin, stuff->window, client, DixReceiveAccess);
    if (ret != Success)
	return ret;

    if (HandleDevicePresenceMask(client, pWin, (XEventClass *) & stuff[1],
                                &stuff->count) != Success)
	return BadAlloc;

    if ((ret = CreateMaskFromList(client, (XEventClass *) & stuff[1],
				  stuff->count, tmp, NULL,
				  X_SelectExtensionEvent)) != Success)
	return ret;

    for (i = 0; i < EMASKSIZE; i++)
	if (tmp[i].dev != NULL) {
            if (tmp[i].mask & ~XIAllMasks) {
                client->errorValue = tmp[i].mask;
                return BadValue;
            }
	    if ((ret =
		 SelectForWindow((DeviceIntPtr) tmp[i].dev, pWin, client,
				 tmp[i].mask, ExtExclusiveMasks[i]))!= Success)
		return ret;
	}

    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SELECTEV_H
#define SELECTEV_H 1

int SProcXSelectExtensionEvent(ClientPtr	/* client */
    );

int ProcXSelectExtensionEvent(ClientPtr	/* client */
    );

#endif /* SELECTEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to send an extension event.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* Window            */
#include "extnsionst.h" /* EventSwapPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "grabdev.h"
#include "sendexev.h"

extern int lastEvent;	/* Defined in extension.c */

/***********************************************************************
 *
 * Handle requests from clients with a different byte order than us.
 *
 */

int
SProcXSendExtensionEvent(ClientPtr client)
{
    char n;
    CARD32 *p;
    int i;
    xEvent eventT;
    xEvent *eventP;
    EventSwapPtr proc;

    REQUEST(xSendExtensionEventReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);
    swapl(&stuff->destination, n);
    swaps(&stuff->count, n);

    if (stuff->length != bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +
       bytes_to_int32(stuff->num_events * sizeof(xEvent)))
       return BadLength;

    eventP = (xEvent *) & stuff[1];
    for (i = 0; i < stuff->num_events; i++, eventP++) {
	proc = EventSwapVector[eventP->u.u.type & 0177];
	if (proc == NotImplemented)	/* no swapping proc; invalid event type? */
	    return BadValue;
	(*proc) (eventP, &eventT);
	*eventP = eventT;
    }

    p = (CARD32 *)(((xEvent *) & stuff[1]) + stuff->num_events);
    SwapLongs(p, stuff->count);
    return (ProcXSendExtensionEvent(client));
}

/***********************************************************************
 *
 * Send an event to some client, as if it had come from an extension input
 * device.
 *
 */

int
ProcXSendExtensionEvent(ClientPtr client)
{
    int ret;
    DeviceIntPtr dev;
    xEvent *first;
    XEventClass *list;
    struct tmask tmp[EMASKSIZE];

    REQUEST(xSendExtensionEventReq);
    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);

    if (stuff->length != bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +
	(stuff->num_events * bytes_to_int32(sizeof(xEvent))))
	return BadLength;

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);
    if (ret != Success)
	return ret;

    /* The client's event type must be one defined by an extension. */

    first = ((xEvent *) & stuff[1]);
    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&
	  (first->u.u.type < lastEvent))) {
	client->errorValue = first->u.u.type;
	return BadValue;
    }

    list = (XEventClass *) (first + stuff->num_events);
    if ((ret = CreateMaskFromList(client, list, stuff->count, tmp, dev,
				  X_SendExtensionEvent)) != Success)
	return ret;

    ret = (SendEvent(client, dev, stuff->destination,
		     stuff->propagate, (xEvent *) & stuff[1],
		     tmp[stuff->deviceid].mask, stuff->num_events));

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SENDEXEV_H
#define SENDEXEV_H 1

int SProcXSendExtensionEvent(ClientPtr	/* client */
    );

int ProcXSendExtensionEvent(ClientPtr	/* client */
    );

#endif /* SENDEXEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to change the button mapping of an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "setbmap.h"

/***********************************************************************
 *
 * This procedure changes the button mapping.
 *
 */

int
SProcXSetDeviceButtonMapping(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceButtonMappingReq);
    swaps(&stuff->length, n);
    return (ProcXSetDeviceButtonMapping(client));
}

/***********************************************************************
 *
 * This procedure lists the input devices available to the server.
 *
 */

int
ProcXSetDeviceButtonMapping(ClientPtr client)
{
    int ret;
    xSetDeviceButtonMappingReply rep;
    DeviceIntPtr dev;

    REQUEST(xSetDeviceButtonMappingReq);
    REQUEST_AT_LEAST_SIZE(xSetDeviceButtonMappingReq);

    if (stuff->length !=
        bytes_to_int32(sizeof(xSetDeviceButtonMappingReq) + stuff->map_length))
	return BadLength;

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (ret != Success)
        return ret;

    rep.repType = X_Reply;
    rep.RepType = X_SetDeviceButtonMapping;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.status = MappingSuccess;

    ret = ApplyPointerMapping(dev, (CARD8 *) &stuff[1], stuff->map_length, client);
    if (ret == -1)
        return BadValue;
    else if (ret == MappingBusy)
        rep.status = ret;
    else if (ret != Success)
        return ret;

    WriteReplyToClient(client, sizeof(xSetDeviceButtonMappingReply), &rep);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XSetDeviceButtonMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXSetDeviceButtonMapping(ClientPtr client, int size,
			    xSetDeviceButtonMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETBMAP_H
#define SETBMAP_H 1

int SProcXSetDeviceButtonMapping(ClientPtr	/* client */
    );

int ProcXSetDeviceButtonMapping(ClientPtr	/* client */
    );

void SRepXSetDeviceButtonMapping(ClientPtr /* client */ ,
				 int /* size */ ,
				 xSetDeviceButtonMappingReply *	/* rep */
    );

#endif /* SETBMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to change the mode of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "exglobals.h"

#include "setdval.h"

/***********************************************************************
 *
 * Handle a request from a client with a different byte order.
 *
 */

int
SProcXSetDeviceValuators(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceValuatorsReq);
    swaps(&stuff->length, n);
    return (ProcXSetDeviceValuators(client));
}

/***********************************************************************
 *
 * This procedure sets the value of valuators on an extension input device.
 *
 */

int
ProcXSetDeviceValuators(ClientPtr client)
{
    DeviceIntPtr dev;
    xSetDeviceValuatorsReply rep;
    int rc;

    REQUEST(xSetDeviceValuatorsReq);
    REQUEST_AT_LEAST_SIZE(xSetDeviceValuatorsReq);

    rep.repType = X_Reply;
    rep.RepType = X_SetDeviceValuators;
    rep.length = 0;
    rep.status = Success;
    rep.sequenceNumber = client->sequence;

    if (stuff->length != bytes_to_int32(sizeof(xSetDeviceValuatorsReq)) +
	stuff->num_valuators)
	return BadLength;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (dev->valuator == NULL)
	return BadMatch;

    if (stuff->first_valuator + stuff->num_valuators > dev->valuator->numAxes)
	return BadValue;

    if ((dev->deviceGrab.grab) && !SameClient(dev->deviceGrab.grab, client))
	rep.status = AlreadyGrabbed;
    else
	rep.status = SetDeviceValuators(client, dev, (int *)&stuff[1],
					stuff->first_valuator,
					stuff->num_valuators);

    if (rep.status != Success && rep.status != AlreadyGrabbed)
	return rep.status;

    WriteReplyToClient(client, sizeof(xSetDeviceValuatorsReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XSetDeviceValuators function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXSetDeviceValuators(ClientPtr client, int size,
			xSetDeviceValuatorsReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETDVAL_H
#define SETDVAL_H 1

int SProcXSetDeviceValuators(ClientPtr	/* client */
    );

int ProcXSetDeviceValuators(ClientPtr	/* client */
    );

void SRepXSetDeviceValuators(ClientPtr /* client */ ,
			     int /* size */ ,
			     xSetDeviceValuatorsReply *	/* rep */
    );

#endif /* SETDVAL_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to set the focus for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "windowstr.h"	/* focus struct      */
#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>

#include "dixevents.h"

#include "exglobals.h"

#include "setfocus.h"

/***********************************************************************
 *
 * This procedure sets the focus for a device.
 *
 */

int
SProcXSetDeviceFocus(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceFocusReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xSetDeviceFocusReq);
    swapl(&stuff->focus, n);
    swapl(&stuff->time, n);
    return (ProcXSetDeviceFocus(client));
}

/***********************************************************************
 *
 * This procedure sets the focus for a device.
 *
 */

int
ProcXSetDeviceFocus(ClientPtr client)
{
    int ret;
    DeviceIntPtr dev;

    REQUEST(xSetDeviceFocusReq);
    REQUEST_SIZE_MATCH(xSetDeviceFocusReq);

    ret = dixLookupDevice(&dev, stuff->device, client, DixSetFocusAccess);
    if (ret != Success)
	return ret;
    if (!dev->focus)
	return BadDevice;

    ret = SetInputFocus(client, dev, stuff->focus, stuff->revertTo,
			stuff->time, TRUE);

    return ret;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETFOCUS_H
#define SETFOCUS_H 1

int SProcXSetDeviceFocus(ClientPtr	/* client */
    );

int ProcXSetDeviceFocus(ClientPtr	/* client */
    );

#endif /* SETFOCUS_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/********************************************************************
 *
 *  Set modifier mapping for an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "exglobals.h"

#include "setmmap.h"

/***********************************************************************
 *
 * This procedure sets the modifier mapping for an extension device,
 * for clients on machines with a different byte ordering than the server.
 *
 */

int
SProcXSetDeviceModifierMapping(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceModifierMappingReq);
    swaps(&stuff->length, n);
    return (ProcXSetDeviceModifierMapping(client));
}

/***********************************************************************
 *
 * Set the device Modifier mapping.
 *
 */

int
ProcXSetDeviceModifierMapping(ClientPtr client)
{
    int ret;
    xSetDeviceModifierMappingReply rep;
    DeviceIntPtr dev;

    REQUEST(xSetDeviceModifierMappingReq);
    REQUEST_AT_LEAST_SIZE(xSetDeviceModifierMappingReq);

    if (stuff->length != bytes_to_int32(sizeof(xSetDeviceModifierMappingReq)) +
                          (stuff->numKeyPerModifier << 1))
        return BadLength;

    rep.repType = X_Reply;
    rep.RepType = X_SetDeviceModifierMapping;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
    if (ret != Success)
        return ret;

    ret = change_modmap(client, dev, (KeyCode *) &stuff[1],
                        stuff->numKeyPerModifier);
    if (ret == Success)
        ret = MappingSuccess;

    if (ret == MappingSuccess || ret == MappingBusy || ret == MappingFailed) {
	rep.success = ret;
	WriteReplyToClient(client, sizeof(xSetDeviceModifierMappingReply),
			   &rep);
    }
    else if (ret == -1) {
        return BadValue;
    }
    else {
        return ret;
    }

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XSetDeviceModifierMapping function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXSetDeviceModifierMapping(ClientPtr client, int size,
			      xSetDeviceModifierMappingReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETMMAP_H
#define SETMMAP_H 1

int SProcXSetDeviceModifierMapping(ClientPtr	/* client */
    );

int ProcXSetDeviceModifierMapping(ClientPtr	/* client */
    );

void SRepXSetDeviceModifierMapping(ClientPtr /* client */ ,
				   int /* size */ ,
				   xSetDeviceModifierMappingReply *	/* rep */
    );

#endif /* SETMMAP_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to change the mode of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "exglobals.h"

#include "setmode.h"

/***********************************************************************
 *
 * Handle a request from a client with a different byte order.
 *
 */

int
SProcXSetDeviceMode(ClientPtr client)
{
    char n;

    REQUEST(xSetDeviceModeReq);
    swaps(&stuff->length, n);
    return (ProcXSetDeviceMode(client));
}

/***********************************************************************
 *
 * This procedure sets the mode of a device.
 *
 */

int
ProcXSetDeviceMode(ClientPtr client)
{
    DeviceIntPtr dev;
    xSetDeviceModeReply rep;
    int rc;

    REQUEST(xSetDeviceModeReq);
    REQUEST_SIZE_MATCH(xSetDeviceModeReq);

    rep.repType = X_Reply;
    rep.RepType = X_SetDeviceMode;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
    if (dev->valuator == NULL)
	return BadMatch;
    if ((dev->deviceGrab.grab) && !SameClient(dev->deviceGrab.grab, client))
	rep.status = AlreadyGrabbed;
    else
	rep.status = SetDeviceMode(client, dev, stuff->mode);

    if (rep.status == Success)
        valuator_set_mode(dev, VALUATOR_MODE_ALL_AXES, stuff->mode);
    else if (rep.status != AlreadyGrabbed)
    {
	switch(rep.status) {
	    case BadMatch:
	    case BadImplementation:
	    case BadAlloc:
		break;
	    default:
		rep.status = BadMode;
	}
	return rep.status;
    }

    WriteReplyToClient(client, sizeof(xSetDeviceModeReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XSetDeviceMode function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXSetDeviceMode(ClientPtr client, int size, xSetDeviceModeReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETMODE_H
#define SETMODE_H 1

int SProcXSetDeviceMode(ClientPtr	/* client */
    );

int ProcXSetDeviceMode(ClientPtr	/* client */
    );

void SRepXSetDeviceMode(ClientPtr /* client */ ,
			int /* size */ ,
			xSetDeviceModeReply *	/* rep */
    );

#endif /* SETMODE_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/*
 * stubs.c -- stub routines for the X server side of the XINPUT
 * extension.  This file is mainly to be used only as documentation.
 * There is not much code here, and you can't get a working XINPUT
 * server just using this.
 * The Xvfb server uses this file so it will compile with the same
 * object files as the real X server for a platform that has XINPUT.
 * Xnest could do the same thing.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "inputstr.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"
#include "xace.h"

/****************************************************************************
 *
 * Caller:	ProcXSetDeviceMode
 *
 * Change the mode of an extension device.
 * This function is used to change the mode of a device from reporting
 * relative motion to reporting absolute positional information, and
 * vice versa.
 * The default implementation below is that no such devices are supported.
 *
 */

int
SetDeviceMode(ClientPtr client, DeviceIntPtr dev, int mode)
{
    return BadMatch;
}

/****************************************************************************
 *
 * Caller:	ProcXSetDeviceValuators
 *
 * Set the value of valuators on an extension input device.
 * This function is used to set the initial value of valuators on
 * those input devices that are capable of reporting either relative
 * motion or an absolute position, and allow an initial position to be set.
 * The default implementation below is that no such devices are supported.
 *
 */

int
SetDeviceValuators(ClientPtr client, DeviceIntPtr dev,
		   int *valuators, int first_valuator, int num_valuators)
{
    return BadMatch;
}

/****************************************************************************
 *
 * Caller:	ProcXChangeDeviceControl
 *
 * Change the specified device controls on an extension input device.
 *
 */

int
ChangeDeviceControl(ClientPtr client, DeviceIntPtr dev,
		    xDeviceCtl * control)
{
    return BadMatch;
}


/****************************************************************************
 *
 * Caller: configAddDevice (and others)
 *
 * Add a new device with the specified options.
 *
 */
int
NewInputDeviceRequest(InputOption *options, InputAttributes *attrs,
                      DeviceIntPtr *pdev)
{
    return BadValue;
}

/****************************************************************************
 *
 * Caller: configRemoveDevice (and others)
 *
 * Remove the specified device previously added.
 *
 */
void
DeleteInputDeviceRequest(DeviceIntPtr dev)
{
}
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to release a grab of an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XIproto.h>
#include "exglobals.h"

#include "ungrdev.h"

/***********************************************************************
 *
 * Handle requests from a client with a different byte order.
 *
 */

int
SProcXUngrabDevice(ClientPtr client)
{
    char n;

    REQUEST(xUngrabDeviceReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xUngrabDeviceReq);
    swapl(&stuff->time, n);
    return (ProcXUngrabDevice(client));
}

/***********************************************************************
 *
 * Release a grab of an extension device.
 *
 */

int
ProcXUngrabDevice(ClientPtr client)
{
    DeviceIntPtr dev;
    GrabPtr grab;
    TimeStamp time;
    int rc;

    REQUEST(xUngrabDeviceReq);
    REQUEST_SIZE_MATCH(xUngrabDeviceReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (rc != Success)
	return rc;
    grab = dev->deviceGrab.grab;

    time = ClientTimeToServerTime(stuff->time);
    if ((CompareTimeStamps(time, currentTime) != LATER) &&
	(CompareTimeStamps(time, dev->deviceGrab.grabTime) != EARLIER) &&
	(grab) && SameClient(grab, client) && grab->grabtype == GRABTYPE_XI)
	(*dev->deviceGrab.DeactivateGrab) (dev);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef UNGRDEV_H
#define UNGRDEV_H 1

int SProcXUngrabDevice(ClientPtr	/* client */
    );

int ProcXUngrabDevice(ClientPtr	/* client */
    );

#endif /* UNGRDEV_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to release a grab of a button on an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "dixgrabs.h"

#include "ungrdevb.h"

#define AllModifiersMask ( \
	ShiftMask | LockMask | ControlMask | Mod1Mask | Mod2Mask | \
	Mod3Mask | Mod4Mask | Mod5Mask )

/***********************************************************************
 *
 * Handle requests from a client with a different byte order.
 *
 */

int
SProcXUngrabDeviceButton(ClientPtr client)
{
    char n;

    REQUEST(xUngrabDeviceButtonReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xUngrabDeviceButtonReq);
    swapl(&stuff->grabWindow, n);
    swaps(&stuff->modifiers, n);
    return (ProcXUngrabDeviceButton(client));
}

/***********************************************************************
 *
 * Release a grab of a button on an extension device.
 *
 */

int
ProcXUngrabDeviceButton(ClientPtr client)
{
    DeviceIntPtr dev;
    DeviceIntPtr mdev;
    WindowPtr pWin;
    GrabRec temporaryGrab;
    int rc;

    REQUEST(xUngrabDeviceButtonReq);
    REQUEST_SIZE_MATCH(xUngrabDeviceButtonReq);

    rc = dixLookupDevice(&dev, stuff->grabbed_device, client, DixGrabAccess);
    if (rc != Success)
	return rc;
    if (dev->button == NULL)
	return BadMatch;

    if (stuff->modifier_device != UseXKeyboard) {
	rc = dixLookupDevice(&mdev, stuff->modifier_device, client,
			     DixReadAccess);
	if (rc != Success)
	    return BadDevice;
	if (mdev->key == NULL)
	    return BadMatch;
    } else
	mdev = PickKeyboard(client);

    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if ((stuff->modifiers != AnyModifier) &&
	(stuff->modifiers & ~AllModifiersMask))
	return BadValue;

    temporaryGrab.resource = client->clientAsMask;
    temporaryGrab.device = dev;
    temporaryGrab.window = pWin;
    temporaryGrab.type = DeviceButtonPress;
    temporaryGrab.grabtype = GRABTYPE_XI;
    temporaryGrab.modifierDevice = mdev;
    temporaryGrab.modifiersDetail.exact = stuff->modifiers;
    temporaryGrab.modifiersDetail.pMask = NULL;
    temporaryGrab.detail.exact = stuff->button;
    temporaryGrab.detail.pMask = NULL;

    DeletePassiveGrabFromList(&temporaryGrab);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef UNGRDEVB_H
#define UNGRDEVB_H 1

int SProcXUngrabDeviceButton(ClientPtr	/* client */
    );

int ProcXUngrabDeviceButton(ClientPtr	/* client */
    );

#endif /* UNGRDEVB_H */
/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Request to release a grab of a key on an extension device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "dixgrabs.h"
#include "xkbsrv.h"
#include "xkbstr.h"

#include "ungrdevk.h"

#define AllModifiersMask ( \
	ShiftMask | LockMask | ControlMask | Mod1Mask | Mod2Mask | \
	Mod3Mask | Mod4Mask | Mod5Mask )

/***********************************************************************
 *
 * Handle requests from a client with a different byte order.
 *
 */

int
SProcXUngrabDeviceKey(ClientPtr client)
{
    char n;

    REQUEST(xUngrabDeviceKeyReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xUngrabDeviceKeyReq);
    swapl(&stuff->grabWindow, n);
    swaps(&stuff->modifiers, n);
    return (ProcXUngrabDeviceKey(client));
}

/***********************************************************************
 *
 * Release a grab of a key on an extension device.
 *
 */

int
ProcXUngrabDeviceKey(ClientPtr client)
{
    DeviceIntPtr dev;
    DeviceIntPtr mdev;
    WindowPtr pWin;
    GrabRec temporaryGrab;
    int rc;

    REQUEST(xUngrabDeviceKeyReq);
    REQUEST_SIZE_MATCH(xUngrabDeviceKeyReq);

    rc = dixLookupDevice(&dev, stuff->grabbed_device, client, DixGrabAccess);
    if (rc != Success)
	return rc;
    if (dev->key == NULL)
	return BadMatch;

    if (stuff->modifier_device != UseXKeyboard) {
	rc = dixLookupDevice(&mdev, stuff->modifier_device, client,
			     DixReadAccess);
	if (rc != Success)
	    return BadDevice;
	if (mdev->key == NULL)
	    return BadMatch;
    } else
	mdev = PickKeyboard(client);

    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;

    if (((stuff->key > dev->key->xkbInfo->desc->max_key_code) ||
	 (stuff->key < dev->key->xkbInfo->desc->min_key_code))
	&& (stuff->key != AnyKey))
	return BadValue;

    if ((stuff->modifiers != AnyModifier) &&
	(stuff->modifiers & ~AllModifiersMask))
	return BadValue;

    temporaryGrab.resource = client->clientAsMask;
    temporaryGrab.device = dev;
    temporaryGrab.window = pWin;
    temporaryGrab.type = DeviceKeyPress;
    temporaryGrab.grabtype = GRABTYPE_XI;
    temporaryGrab.modifierDevice = mdev;
    temporaryGrab.modifiersDetail.exact = stuff->modifiers;
    temporaryGrab.modifiersDetail.pMask = NULL;
    temporaryGrab.detail.exact = stuff->key;
    temporaryGrab.detail.pMask = NULL;

    DeletePassiveGrabFromList(&temporaryGrab);
    return Success;
}
/************************************************************

Copyright 1996 by Thomas E. Dickey <dickey@clark.net>

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef UNGRDEVK_H
#define UNGRDEVK_H 1

int SProcXUngrabDeviceKey(ClientPtr	/* client */
    );

int ProcXUngrabDeviceKey(ClientPtr	/* client */
    );

#endif /* UNGRDEVK_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

/***********************************************************************
 *
 * Request to allow some device events.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI2.h>
#include <X11/extensions/XI2proto.h>

#include "exglobals.h" /* BadDevice */
#include "xiallowev.h"

int
SProcXIAllowEvents(ClientPtr client)
{
    char n;

    REQUEST(xXIAllowEventsReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->time, n);

    return ProcXIAllowEvents(client);
}

int
ProcXIAllowEvents(ClientPtr client)
{
    TimeStamp time;
    DeviceIntPtr dev;
    int ret = Success;

    REQUEST(xXIAllowEventsReq);
    REQUEST_SIZE_MATCH(xXIAllowEventsReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (ret != Success)
	return ret;

    time = ClientTimeToServerTime(stuff->time);

    switch (stuff->mode) {
    case XIReplayDevice:
	AllowSome(client, time, dev, NOT_GRABBED);
	break;
    case XISyncDevice:
	AllowSome(client, time, dev, FREEZE_NEXT_EVENT);
	break;
    case XIAsyncDevice:
	AllowSome(client, time, dev, THAWED);
	break;
    case XIAsyncPairedDevice:
        if (IsMaster(dev))
            AllowSome(client, time, dev, THAW_OTHERS);
	break;
    case XISyncPair:
        if (IsMaster(dev))
            AllowSome(client, time, dev, FREEZE_BOTH_NEXT_EVENT);
	break;
    case XIAsyncPair:
        if (IsMaster(dev))
            AllowSome(client, time, dev, THAWED_BOTH);
	break;
    default:
	client->errorValue = stuff->mode;
	ret = BadValue;
    }

    return ret;
}

/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XIALLOWEV_H
#define XIALLOWEV_H 1

int ProcXIAllowEvents(ClientPtr client);
int SProcXIAllowEvents(ClientPtr client);

#endif /* XIALLOWEV_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request to change a given device pointer's cursor.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "input.h"

#include "xichangecursor.h"

/***********************************************************************
 *
 * This procedure allows a client to set one pointer's cursor.
 *
 */

int
SProcXIChangeCursor(ClientPtr client)
{
    char n;

    REQUEST(xXIChangeCursorReq);
    swaps(&stuff->length, n);
    swapl(&stuff->win, n);
    swapl(&stuff->cursor, n);
    swaps(&stuff->deviceid, n);
    REQUEST_SIZE_MATCH(xXIChangeCursorReq);
    return (ProcXIChangeCursor(client));
}

int ProcXIChangeCursor(ClientPtr client)
{
    int rc;
    WindowPtr pWin    = NULL;
    DeviceIntPtr pDev = NULL;
    CursorPtr pCursor = NULL;

    REQUEST(xXIChangeCursorReq);
    REQUEST_SIZE_MATCH(xXIChangeCursorReq);

    rc = dixLookupDevice(&pDev, stuff->deviceid, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;

    if (!IsMaster(pDev) || !IsPointerDevice(pDev))
        return BadDevice;

    if (stuff->win != None)
    {
        rc = dixLookupWindow(&pWin, stuff->win, client, DixSetAttrAccess);
        if (rc != Success)
            return rc;
    }

    if (stuff->cursor == None)
    {
        if (pWin == pWin->drawable.pScreen->root)
            pCursor = rootCursor;
        else
            pCursor = (CursorPtr)None;
    }
    else
    {
	rc = dixLookupResourceByType((pointer *)&pCursor, stuff->cursor,
				     RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	    return rc;
    }

    ChangeWindowDeviceCursor(pWin, pDev, pCursor);

    return Success;
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHDEVCUR_H
#define CHDEVCUR_H 1

int SProcXIChangeCursor(ClientPtr /* client */);
int ProcXIChangeCursor(ClientPtr /* client */);

#endif /* CHDEVCUR_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 * Copyright 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request change in the device hierarchy.
 *
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/geproto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "geext.h"
#include "xace.h"
#include "xiquerydevice.h" /* for GetDeviceUse */

#include "xkbsrv.h"

#include "xichangehierarchy.h"

/**
 * Send the current state of the device hierarchy to all clients.
 */
void XISendDeviceHierarchyEvent(int flags[MAXDEVICES])
{
    xXIHierarchyEvent *ev;
    xXIHierarchyInfo *info;
    DeviceIntRec dummyDev;
    DeviceIntPtr dev;
    int i;

    if (!flags)
        return;

    ev = calloc(1, sizeof(xXIHierarchyEvent) +
                 MAXDEVICES * sizeof(xXIHierarchyInfo));
    if (!ev)
        return;
    ev->type = GenericEvent;
    ev->extension = IReqCode;
    ev->evtype = XI_HierarchyChanged;
    ev->time = GetTimeInMillis();
    ev->flags = 0;
    ev->num_info = inputInfo.numDevices;

    info = (xXIHierarchyInfo*)&ev[1];
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
        info->deviceid = dev->id;
        info->enabled = dev->enabled;
        info->use = GetDeviceUse(dev, &info->attachment);
        info->flags = flags[dev->id];
        ev->flags |= info->flags;
        info++;
    }
    for (dev = inputInfo.off_devices; dev; dev = dev->next)
    {
        info->deviceid = dev->id;
        info->enabled = dev->enabled;
        info->use = GetDeviceUse(dev, &info->attachment);
        info->flags = flags[dev->id];
        ev->flags |= info->flags;
        info++;
    }


    for (i = 0; i < MAXDEVICES; i++)
    {
        if (flags[i] & (XIMasterRemoved | XISlaveRemoved))
        {
            info->deviceid = i;
            info->enabled = FALSE;
            info->flags = flags[i];
            info->use = 0;
            ev->flags |= info->flags;
            ev->num_info++;
            info++;
        }
    }

    ev->length = bytes_to_int32(ev->num_info * sizeof(xXIHierarchyInfo));

    memset(&dummyDev, 0, sizeof(dummyDev));
    dummyDev.id = XIAllDevices;
    dummyDev.type = SLAVE;
    SendEventToAllWindows(&dummyDev, (XI_HierarchyChangedMask >> 8), (xEvent*)ev, 1);
    free(ev);
}


/***********************************************************************
 *
 * This procedure allows a client to change the device hierarchy through
 * adding new master devices, removing them, etc.
 *
 */

int SProcXIChangeHierarchy(ClientPtr client)
{
    char n;

    REQUEST(xXIChangeHierarchyReq);
    swaps(&stuff->length, n);
    return (ProcXIChangeHierarchy(client));
}

static int
add_master(ClientPtr client, xXIAddMasterInfo *c, int flags[MAXDEVICES])
{
    DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
    char* name;
    int rc;

    name = calloc(c->name_len + 1, sizeof(char));
    strncpy(name, (char*)&c[1], c->name_len);

    rc = AllocDevicePair(client, name, &ptr, &keybd,
                         CorePointerProc, CoreKeyboardProc, TRUE);
    if (rc != Success)
        goto unwind;

    if (!c->send_core)
        ptr->coreEvents = keybd->coreEvents =  FALSE;

    /* Allocate virtual slave devices for xtest events */
    rc = AllocXTestDevice(client, name, &XTestptr, &XTestkeybd, ptr, keybd);
    if (rc != Success)
    {
        DeleteInputDeviceRequest(ptr);
        DeleteInputDeviceRequest(keybd);
        goto unwind;
    }

    ActivateDevice(ptr, FALSE);
    ActivateDevice(keybd, FALSE);
    flags[ptr->id] |= XIMasterAdded;
    flags[keybd->id] |= XIMasterAdded;

    ActivateDevice(XTestptr, FALSE);
    ActivateDevice(XTestkeybd, FALSE);
    flags[XTestptr->id] |= XISlaveAdded;
    flags[XTestkeybd->id] |= XISlaveAdded;

    if (c->enable)
    {
        EnableDevice(ptr, FALSE);
        EnableDevice(keybd, FALSE);
        flags[ptr->id] |= XIDeviceEnabled;
        flags[keybd->id] |= XIDeviceEnabled;

        EnableDevice(XTestptr, FALSE);
        EnableDevice(XTestkeybd, FALSE);
        flags[XTestptr->id] |= XIDeviceEnabled;
        flags[XTestkeybd->id] |= XIDeviceEnabled;
    }

    /* Attach the XTest virtual devices to the newly
       created master device */
    AttachDevice(NULL, XTestptr, ptr);
    AttachDevice(NULL, XTestkeybd, keybd);
    flags[XTestptr->id] |= XISlaveAttached;
    flags[XTestkeybd->id] |= XISlaveAttached;

unwind:
    free(name);
    return rc;
}

static int
remove_master(ClientPtr client, xXIRemoveMasterInfo *r,
              int flags[MAXDEVICES])
{
    DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
    int rc = Success;

    if (r->return_mode != XIAttachToMaster &&
        r->return_mode != XIFloating)
        return BadValue;

    rc = dixLookupDevice(&ptr, r->deviceid, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    if (!IsMaster(ptr))
    {
        client->errorValue = r->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* XXX: For now, don't allow removal of VCP, VCK */
    if (ptr == inputInfo.pointer || ptr == inputInfo.keyboard)
    {
        rc = BadDevice;
        goto unwind;
    }


    ptr = GetMaster(ptr, MASTER_POINTER);
    rc = dixLookupDevice(&ptr, ptr->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;
    keybd = GetMaster(ptr, MASTER_KEYBOARD);
    rc = dixLookupDevice(&keybd, keybd->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    XTestptr = GetXTestDevice(ptr);
    rc = dixLookupDevice(&XTestptr, XTestptr->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    XTestkeybd = GetXTestDevice(keybd);
    rc = dixLookupDevice(&XTestkeybd, XTestkeybd->id, client,
                         DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    /* Disabling sends the devices floating, reattach them if
     * desired. */
    if (r->return_mode == XIAttachToMaster)
    {
        DeviceIntPtr attached,
                     newptr,
                     newkeybd;

        rc = dixLookupDevice(&newptr, r->return_pointer, client, DixAddAccess);
        if (rc != Success)
            goto unwind;

        if (!IsMaster(newptr))
        {
            client->errorValue = r->return_pointer;
            rc = BadDevice;
            goto unwind;
        }

        rc = dixLookupDevice(&newkeybd, r->return_keyboard,
                             client, DixAddAccess);
        if (rc != Success)
            goto unwind;

        if (!IsMaster(newkeybd))
        {
            client->errorValue = r->return_keyboard;
            rc = BadDevice;
            goto unwind;
        }

        for (attached = inputInfo.devices; attached; attached = attached->next)
        {
            if (!IsMaster(attached)) {
                if (GetMaster(attached, MASTER_ATTACHED) == ptr)
                {
                    AttachDevice(client, attached, newptr);
                    flags[attached->id] |= XISlaveAttached;
                }
                if (GetMaster(attached, MASTER_ATTACHED) == keybd)
                {
                    AttachDevice(client, attached, newkeybd);
                    flags[attached->id] |= XISlaveAttached;
                }
            }
        }
    }

    /* can't disable until we removed pairing */
    keybd->spriteInfo->paired = NULL;
    ptr->spriteInfo->paired = NULL;
    XTestptr->spriteInfo->paired = NULL;
    XTestkeybd->spriteInfo->paired = NULL;

    /* disable the remove the devices, XTest devices must be done first
       else the sprites they rely on will be destroyed  */
    DisableDevice(XTestptr, FALSE);
    DisableDevice(XTestkeybd, FALSE);
    DisableDevice(keybd, FALSE);
    DisableDevice(ptr, FALSE);
    flags[XTestptr->id] |= XIDeviceDisabled | XISlaveDetached;
    flags[XTestkeybd->id] |= XIDeviceDisabled | XISlaveDetached;
    flags[keybd->id] |= XIDeviceDisabled;
    flags[ptr->id] |= XIDeviceDisabled;

    RemoveDevice(XTestptr, FALSE);
    RemoveDevice(XTestkeybd, FALSE);
    RemoveDevice(keybd, FALSE);
    RemoveDevice(ptr, FALSE);
    flags[XTestptr->id] |= XISlaveRemoved;
    flags[XTestkeybd->id] |= XISlaveRemoved;
    flags[keybd->id] |= XIMasterRemoved;
    flags[ptr->id] |= XIMasterRemoved;

unwind:
    return rc;
}

static int
detach_slave(ClientPtr client, xXIDetachSlaveInfo *c, int flags[MAXDEVICES])
{
    DeviceIntPtr dev;
    int rc;

    rc = dixLookupDevice(&dev, c->deviceid, client, DixManageAccess);
    if (rc != Success)
        goto unwind;

    if (IsMaster(dev))
    {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* Don't allow changes to XTest Devices, these are fixed */
    if (IsXTestDevice(dev, NULL))
    {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    ReleaseButtonsAndKeys(dev);
    AttachDevice(client, dev, NULL);
    flags[dev->id] |= XISlaveDetached;

unwind:
    return rc;
}

static int
attach_slave(ClientPtr client, xXIAttachSlaveInfo *c,
             int flags[MAXDEVICES])
{
    DeviceIntPtr dev;
    DeviceIntPtr newmaster;
    int rc;

    rc = dixLookupDevice(&dev, c->deviceid, client, DixManageAccess);
    if (rc != Success)
        goto unwind;

    if (IsMaster(dev))
    {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* Don't allow changes to XTest Devices, these are fixed */
    if (IsXTestDevice(dev, NULL))
    {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    rc = dixLookupDevice(&newmaster, c->new_master, client, DixAddAccess);
    if (rc != Success)
        goto unwind;
    if (!IsMaster(newmaster))
    {
        client->errorValue = c->new_master;
        rc = BadDevice;
        goto unwind;
    }

    if (!((IsPointerDevice(newmaster) && IsPointerDevice(dev)) ||
        (IsKeyboardDevice(newmaster) && IsKeyboardDevice(dev))))
    {
        rc = BadDevice;
        goto unwind;
    }

    ReleaseButtonsAndKeys(dev);
    AttachDevice(client, dev, newmaster);
    flags[dev->id] |= XISlaveAttached;

unwind:
    return rc;
}



#define SWAPIF(cmd) if (client->swapped) { cmd; }

int
ProcXIChangeHierarchy(ClientPtr client)
{
    xXIAnyHierarchyChangeInfo *any;
    int required_len = sizeof(xXIChangeHierarchyReq);
    char n;
    int rc = Success;
    int flags[MAXDEVICES] = {0};

    REQUEST(xXIChangeHierarchyReq);
    REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);

    if (!stuff->num_changes)
        return rc;

    any = (xXIAnyHierarchyChangeInfo*)&stuff[1];
    while(stuff->num_changes--)
    {
        SWAPIF(swapl(&any->type, n));
        SWAPIF(swaps(&any->length, n));

        required_len += any->length;
        if ((stuff->length * 4) < required_len)
            return BadLength;

        switch(any->type)
        {
            case XIAddMaster:
                {
                    xXIAddMasterInfo* c = (xXIAddMasterInfo*)any;
                    SWAPIF(swaps(&c->name_len, n));

                    rc = add_master(client, c, flags);
                    if (rc != Success)
                        goto unwind;
                }
                break;
            case XIRemoveMaster:
                {
                    xXIRemoveMasterInfo* r = (xXIRemoveMasterInfo*)any;

                    rc = remove_master(client, r, flags);
                    if (rc != Success)
                        goto unwind;
                }
                break;
            case XIDetachSlave:
                {
                    xXIDetachSlaveInfo* c = (xXIDetachSlaveInfo*)any;

                    rc = detach_slave(client, c, flags);
                    if (rc != Success)
                       goto unwind;
                }
                break;
            case XIAttachSlave:
                {
                    xXIAttachSlaveInfo* c = (xXIAttachSlaveInfo*)any;

                    rc = attach_slave(client, c, flags);
                    if (rc != Success)
                       goto unwind;
                }
                break;
        }

        any = (xXIAnyHierarchyChangeInfo*)((char*)any + any->length * 4);
    }

unwind:

    XISendDeviceHierarchyEvent(flags);
    return rc;
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request change in the device hierarchy.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef CHDEVHIER_H
#define CHDEVHIER_H 1

int SProcXIChangeHierarchy(ClientPtr /* client */);
int ProcXIChangeHierarchy(ClientPtr /* client */);

void XISendDeviceHierarchyEvent(int flags[]);

#endif /* CHDEVHIER_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "extinit.h"	/* LookupDeviceIntRec */
#include "exevents.h"
#include "exglobals.h"

#include "xigetclientpointer.h"

/***********************************************************************
 * This procedure allows a client to query another client's client pointer
 * setting.
 */

int
SProcXIGetClientPointer(ClientPtr client)
{
    char n;
    REQUEST(xXIGetClientPointerReq);

    swaps(&stuff->length, n);
    swapl(&stuff->win, n);
    return ProcXIGetClientPointer(client);
}

int ProcXIGetClientPointer(ClientPtr client)
{
    int rc;
    ClientPtr winclient;
    xXIGetClientPointerReply rep;
    REQUEST(xXIGetClientPointerReq);
    REQUEST_SIZE_MATCH(xXIGetClientPointerReq);

    if (stuff->win != None)
    {
        rc = dixLookupClient(&winclient, stuff->win, client,
                DixGetAttrAccess);

        if (rc != Success)
            return BadWindow;
    } else
        winclient = client;

    rep.repType = X_Reply;
    rep.RepType = X_XIGetClientPointer;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.set = (winclient->clientPtr != NULL);
    rep.deviceid = (winclient->clientPtr) ? winclient->clientPtr->id : 0;

    WriteReplyToClient(client, sizeof(xXIGetClientPointerReply), &rep);
    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XGetClientPointer function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXIGetClientPointer(ClientPtr client, int size,
        xXIGetClientPointerReply* rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->deviceid, n);
    WriteToClient(client, size, (char *)rep);
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef GETCPTR_H
#define GETCPTR_H 1
int SProcXIGetClientPointer(ClientPtr /* client */);
int ProcXIGetClientPointer(ClientPtr /* client */);
void SRepXIGetClientPointer(ClientPtr /* client */,
        int /* size */,
        xXIGetClientPointerReply* /* rep */);

#endif /* GETCPTR_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

/***********************************************************************
 *
 * Request to grab or ungrab input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI2.h>
#include <X11/extensions/XI2proto.h>

#include "exglobals.h" /* BadDevice */
#include "exevents.h"
#include "xigrabdev.h"

int
SProcXIGrabDevice(ClientPtr client)
{
    char n;

    REQUEST(xXIGrabDeviceReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->grab_window, n);
    swapl(&stuff->cursor, n);
    swapl(&stuff->time, n);
    swaps(&stuff->mask_len, n);

    return ProcXIGrabDevice(client);
}

int
ProcXIGrabDevice(ClientPtr client)
{
    DeviceIntPtr dev;
    xXIGrabDeviceReply rep;
    int ret = Success;
    uint8_t status;
    GrabMask mask;
    int mask_len;

    REQUEST(xXIGrabDeviceReq);
    REQUEST_AT_LEAST_SIZE(xXIGrabDeviceReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
    if (ret != Success)
	return ret;

    if (!IsMaster(dev))
        stuff->paired_device_mode = GrabModeAsync;

    if (XICheckInvalidMaskBits(client, (unsigned char*)&stuff[1],
                               stuff->mask_len * 4) != Success)
        return BadValue;

    mask_len = min(sizeof(mask.xi2mask[stuff->deviceid]), stuff->mask_len * 4);
    memset(mask.xi2mask, 0, sizeof(mask.xi2mask));
    memcpy(mask.xi2mask, (char*)&stuff[1], mask_len);

    ret = GrabDevice(client, dev, stuff->grab_mode,
                     stuff->paired_device_mode,
                     stuff->grab_window,
                     stuff->owner_events,
                     stuff->time,
                     &mask,
                     GRABTYPE_XI2,
                     stuff->cursor,
                     None /* confineTo */,
                     &status);

    if (ret != Success)
        return ret;

    rep.repType = X_Reply;
    rep.RepType = X_XIGrabDevice;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.status = status;


    WriteReplyToClient(client, sizeof(rep), &rep);
    return ret;
}

int
SProcXIUngrabDevice(ClientPtr client)
{
    char n;

    REQUEST(xXIUngrabDeviceReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->time, n);

    return ProcXIUngrabDevice(client);
}

int
ProcXIUngrabDevice(ClientPtr client)
{
    DeviceIntPtr dev;
    GrabPtr grab;
    int ret = Success;
    TimeStamp time;

    REQUEST(xXIUngrabDeviceReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
    if (ret != Success)
	return ret;

    grab = dev->deviceGrab.grab;

    time = ClientTimeToServerTime(stuff->time);
    if ((CompareTimeStamps(time, currentTime) != LATER) &&
	(CompareTimeStamps(time, dev->deviceGrab.grabTime) != EARLIER) &&
	(grab) && SameClient(grab, client) && grab->grabtype == GRABTYPE_XI2)
	(*dev->deviceGrab.DeactivateGrab) (dev);

    return Success;
}

void SRepXIGrabDevice(ClientPtr client, int size, xXIGrabDeviceReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    WriteToClient(client, size, (char *)rep);
}
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XIGRABDEV_H
#define XIGRABDEV_H 1

int ProcXIGrabDevice(ClientPtr client);
int SProcXIGrabDevice(ClientPtr client);

int ProcXIUngrabDevice(ClientPtr client);
int SProcXIUngrabDevice(ClientPtr client);

void SRepXIGrabDevice(ClientPtr client, int size, xXIGrabDeviceReply * rep);

#endif /* XIGRABDEV_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

/***********************************************************************
 *
 * Request to grab or ungrab input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI2.h>
#include <X11/extensions/XI2proto.h>
#include "swaprep.h"

#include "exglobals.h" /* BadDevice */
#include "exevents.h"
#include "xipassivegrab.h"
#include "dixgrabs.h"
#include "misc.h"

int
SProcXIPassiveGrabDevice(ClientPtr client)
{
    int i;
    char n;
    xXIModifierInfo *mods;

    REQUEST(xXIPassiveGrabDeviceReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->grab_window, n);
    swapl(&stuff->cursor, n);
    swapl(&stuff->time, n);
    swapl(&stuff->detail, n);
    swaps(&stuff->mask_len, n);
    swaps(&stuff->num_modifiers, n);

    mods = (xXIModifierInfo*)&stuff[1];

    for (i = 0; i < stuff->num_modifiers; i++, mods++)
    {
        swapl(&mods->base_mods, n);
        swapl(&mods->latched_mods, n);
        swapl(&mods->locked_mods, n);
    }

    return ProcXIPassiveGrabDevice(client);
}

int
ProcXIPassiveGrabDevice(ClientPtr client)
{
    DeviceIntPtr dev, mod_dev;
    xXIPassiveGrabDeviceReply rep;
    int i, ret = Success;
    uint8_t status;
    uint32_t *modifiers;
    xXIGrabModifierInfo *modifiers_failed;
    GrabMask mask;
    GrabParameters param;
    void *tmp;
    int mask_len;
    int n;

    REQUEST(xXIPassiveGrabDeviceReq);
    REQUEST_AT_LEAST_SIZE(xXIPassiveGrabDeviceReq);

    if (stuff->deviceid == XIAllDevices)
        dev = inputInfo.all_devices;
    else if (stuff->deviceid == XIAllMasterDevices)
        dev = inputInfo.all_master_devices;
    else
    {
        ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
        if (ret != Success)
        {
            client->errorValue = stuff->deviceid;
            return ret;
        }
    }

    if (stuff->grab_type != XIGrabtypeButton &&
        stuff->grab_type != XIGrabtypeKeycode &&
        stuff->grab_type != XIGrabtypeEnter &&
        stuff->grab_type != XIGrabtypeFocusIn)
    {
        client->errorValue = stuff->grab_type;
        return BadValue;
    }

    if ((stuff->grab_type == XIGrabtypeEnter ||
         stuff->grab_type == XIGrabtypeFocusIn) && stuff->detail != 0)
    {
        client->errorValue = stuff->detail;
        return BadValue;
    }

    if (XICheckInvalidMaskBits(client, (unsigned char*)&stuff[1],
                               stuff->mask_len * 4) != Success)
        return BadValue;

    mask_len = min(sizeof(mask.xi2mask[stuff->deviceid]), stuff->mask_len * 4);
    memset(mask.xi2mask, 0, sizeof(mask.xi2mask));
    memcpy(mask.xi2mask[stuff->deviceid], &stuff[1], mask_len * 4);

    rep.repType = X_Reply;
    rep.RepType = X_XIPassiveGrabDevice;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.num_modifiers = 0;

    memset(&param, 0, sizeof(param));
    param.grabtype = GRABTYPE_XI2;
    param.ownerEvents = stuff->owner_events;
    param.this_device_mode = stuff->grab_mode;
    param.other_devices_mode = stuff->paired_device_mode;
    param.grabWindow = stuff->grab_window;
    param.cursor = stuff->cursor;

    if (stuff->cursor != None)
    {
        status = dixLookupResourceByType(&tmp, stuff->cursor,
                                         RT_CURSOR, client, DixUseAccess);
	if (status != Success)
	{
	    client->errorValue = stuff->cursor;
	    return status;
	}
    }

    status = dixLookupWindow((WindowPtr*)&tmp, stuff->grab_window, client, DixSetAttrAccess);
    if (status != Success)
	return status;

    status = CheckGrabValues(client, &param);
    if (status != Success)
        return status;

    modifiers = (uint32_t*)&stuff[1] + stuff->mask_len;
    modifiers_failed = calloc(stuff->num_modifiers, sizeof(xXIGrabModifierInfo));
    if (!modifiers_failed)
        return BadAlloc;

    mod_dev = (IsFloating(dev)) ? dev : GetMaster(dev, MASTER_KEYBOARD);

    for (i = 0; i < stuff->num_modifiers; i++, modifiers++)
    {
        param.modifiers = *modifiers;
        switch(stuff->grab_type)
        {
            case XIGrabtypeButton:
                status = GrabButton(client, dev, mod_dev, stuff->detail,
                                    &param, GRABTYPE_XI2, &mask);
                break;
            case XIGrabtypeKeycode:
                status = GrabKey(client, dev, mod_dev, stuff->detail,
                                 &param, GRABTYPE_XI2, &mask);
                break;
            case XIGrabtypeEnter:
            case XIGrabtypeFocusIn:
                status = GrabWindow(client, dev, stuff->grab_type,
                                    &param, &mask);
                break;
        }

        if (status != GrabSuccess)
        {
            xXIGrabModifierInfo *info = modifiers_failed + rep.num_modifiers;

            info->status = status;
            info->modifiers = *modifiers;
            if (client->swapped)
                swapl(&info->modifiers, n);

            rep.num_modifiers++;
            rep.length += bytes_to_int32(sizeof(xXIGrabModifierInfo));
        }
    }

    WriteReplyToClient(client, sizeof(rep), &rep);
    if (rep.num_modifiers)
        WriteToClient(client, rep.length * 4, (char*)modifiers_failed);

    free(modifiers_failed);
    return ret;
}

void
SRepXIPassiveGrabDevice(ClientPtr client, int size,
                        xXIPassiveGrabDeviceReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_modifiers, n);

    WriteToClient(client, size, (char *)rep);
}

int
SProcXIPassiveUngrabDevice(ClientPtr client)
{
    char n;
    int i;
    uint32_t *modifiers;

    REQUEST(xXIPassiveUngrabDeviceReq);

    swaps(&stuff->length, n);
    swapl(&stuff->grab_window, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->detail, n);
    swaps(&stuff->num_modifiers, n);

    modifiers = (uint32_t*)&stuff[1];

    for (i = 0; i < stuff->num_modifiers; i++, modifiers++)
        swapl(modifiers, n);

    return ProcXIPassiveUngrabDevice(client);
}

int
ProcXIPassiveUngrabDevice(ClientPtr client)
{
    DeviceIntPtr dev, mod_dev;
    WindowPtr win;
    GrabRec tempGrab;
    uint32_t* modifiers;
    int i, rc;

    REQUEST(xXIPassiveUngrabDeviceReq);
    REQUEST_AT_LEAST_SIZE(xXIPassiveUngrabDeviceReq);

    if (stuff->deviceid == XIAllDevices)
        dev = inputInfo.all_devices;
    else if (stuff->deviceid == XIAllMasterDevices)
        dev = inputInfo.all_master_devices;
    else
    {
        rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
        if (rc != Success)
	    return rc;
    }

    if (stuff->grab_type != XIGrabtypeButton &&
        stuff->grab_type != XIGrabtypeKeycode &&
        stuff->grab_type != XIGrabtypeEnter &&
        stuff->grab_type != XIGrabtypeFocusIn)
    {
        client->errorValue = stuff->grab_type;
        return BadValue;
    }

    if ((stuff->grab_type == XIGrabtypeEnter ||
         stuff->grab_type == XIGrabtypeFocusIn) && stuff->detail != 0)
    {
        client->errorValue = stuff->detail;
        return BadValue;
    }

    rc = dixLookupWindow(&win, stuff->grab_window, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;

    mod_dev = (IsFloating(dev)) ? dev : GetMaster(dev, MASTER_KEYBOARD);

    tempGrab.resource = client->clientAsMask;
    tempGrab.device = dev;
    tempGrab.window = win;
    switch(stuff->grab_type)
    {
        case XIGrabtypeButton:  tempGrab.type = XI_ButtonPress; break;
        case XIGrabtypeKeycode:  tempGrab.type = XI_KeyPress;    break;
        case XIGrabtypeEnter:   tempGrab.type = XI_Enter;       break;
        case XIGrabtypeFocusIn: tempGrab.type = XI_FocusIn;     break;
    }
    tempGrab.grabtype = GRABTYPE_XI2;
    tempGrab.modifierDevice = mod_dev;
    tempGrab.modifiersDetail.pMask = NULL;
    tempGrab.detail.exact = stuff->detail;
    tempGrab.detail.pMask = NULL;

    modifiers = (uint32_t*)&stuff[1];

    for (i = 0; i < stuff->num_modifiers; i++, modifiers++)
    {
        tempGrab.modifiersDetail.exact = *modifiers;
        DeletePassiveGrabFromList(&tempGrab);
    }

    return Success;
}
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XIPASSIVEGRAB_H
#define XIPASSIVEGRAB_H 1

int SProcXIPassiveUngrabDevice(ClientPtr client);
int ProcXIPassiveUngrabDevice(ClientPtr client);
void SRepXIPassiveGrabDevice(ClientPtr client, int size, xXIPassiveGrabDeviceReply * rep);
int ProcXIPassiveGrabDevice(ClientPtr client);
int SProcXIPassiveGrabDevice(ClientPtr client);

#endif /* XIPASSIVEGRAB_H */
/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WAXIANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WAXIANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/* This code is a modified version of randr/rrproperty.c */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "dix.h"
#include "inputstr.h"
#include <X11/extensions/XI.h>
#include <X11/Xatom.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include "exglobals.h"
#include "exevents.h"
#include "swaprep.h"

#include "xiproperty.h"
#include "xserver-properties.h"

/**
 * Properties used or alloced from inside the server.
 */
static struct dev_properties
{
    Atom type;
    char *name;
} dev_properties[] = {
    {0, XI_PROP_ENABLED},
    {0, XI_PROP_XTEST_DEVICE},
    {0, XATOM_FLOAT},
    {0, ACCEL_PROP_PROFILE_NUMBER},
    {0, ACCEL_PROP_CONSTANT_DECELERATION},
    {0, ACCEL_PROP_ADAPTIVE_DECELERATION},
    {0, ACCEL_PROP_VELOCITY_SCALING},
    {0, AXIS_LABEL_PROP},
    {0, AXIS_LABEL_PROP_REL_X},
    {0, AXIS_LABEL_PROP_REL_Y},
    {0, AXIS_LABEL_PROP_REL_Z},
    {0, AXIS_LABEL_PROP_REL_RX},
    {0, AXIS_LABEL_PROP_REL_RY},
    {0, AXIS_LABEL_PROP_REL_RZ},
    {0, AXIS_LABEL_PROP_REL_HWHEEL},
    {0, AXIS_LABEL_PROP_REL_DIAL},
    {0, AXIS_LABEL_PROP_REL_WHEEL},
    {0, AXIS_LABEL_PROP_REL_MISC},
    {0, AXIS_LABEL_PROP_ABS_X},
    {0, AXIS_LABEL_PROP_ABS_Y},
    {0, AXIS_LABEL_PROP_ABS_Z},
    {0, AXIS_LABEL_PROP_ABS_RX},
    {0, AXIS_LABEL_PROP_ABS_RY},
    {0, AXIS_LABEL_PROP_ABS_RZ},
    {0, AXIS_LABEL_PROP_ABS_THROTTLE},
    {0, AXIS_LABEL_PROP_ABS_RUDDER},
    {0, AXIS_LABEL_PROP_ABS_WHEEL},
    {0, AXIS_LABEL_PROP_ABS_GAS},
    {0, AXIS_LABEL_PROP_ABS_BRAKE},
    {0, AXIS_LABEL_PROP_ABS_HAT0X},
    {0, AXIS_LABEL_PROP_ABS_HAT0Y},
    {0, AXIS_LABEL_PROP_ABS_HAT1X},
    {0, AXIS_LABEL_PROP_ABS_HAT1Y},
    {0, AXIS_LABEL_PROP_ABS_HAT2X},
    {0, AXIS_LABEL_PROP_ABS_HAT2Y},
    {0, AXIS_LABEL_PROP_ABS_HAT3X},
    {0, AXIS_LABEL_PROP_ABS_HAT3Y},
    {0, AXIS_LABEL_PROP_ABS_PRESSURE},
    {0, AXIS_LABEL_PROP_ABS_DISTANCE},
    {0, AXIS_LABEL_PROP_ABS_TILT_X},
    {0, AXIS_LABEL_PROP_ABS_TILT_Y},
    {0, AXIS_LABEL_PROP_ABS_TOOL_WIDTH},
    {0, AXIS_LABEL_PROP_ABS_VOLUME},
    {0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MAJOR},
    {0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MINOR},
    {0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MAJOR},
    {0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MINOR},
    {0, AXIS_LABEL_PROP_ABS_MT_ORIENTATION},
    {0, AXIS_LABEL_PROP_ABS_MT_POSITION_X},
    {0, AXIS_LABEL_PROP_ABS_MT_POSITION_Y},
    {0, AXIS_LABEL_PROP_ABS_MT_TOOL_TYPE},
    {0, AXIS_LABEL_PROP_ABS_MT_BLOB_ID},
    {0, AXIS_LABEL_PROP_ABS_MT_TRACKING_ID},
    {0, AXIS_LABEL_PROP_ABS_MT_PRESSURE},
    {0, AXIS_LABEL_PROP_ABS_MISC},

    {0, BTN_LABEL_PROP},
    {0, BTN_LABEL_PROP_BTN_UNKNOWN},
    {0, BTN_LABEL_PROP_BTN_WHEEL_UP},
    {0, BTN_LABEL_PROP_BTN_WHEEL_DOWN},
    {0, BTN_LABEL_PROP_BTN_HWHEEL_LEFT},
    {0, BTN_LABEL_PROP_BTN_HWHEEL_RIGHT},
    {0, BTN_LABEL_PROP_BTN_0},
    {0, BTN_LABEL_PROP_BTN_1},
    {0, BTN_LABEL_PROP_BTN_2},
    {0, BTN_LABEL_PROP_BTN_3},
    {0, BTN_LABEL_PROP_BTN_4},
    {0, BTN_LABEL_PROP_BTN_5},
    {0, BTN_LABEL_PROP_BTN_6},
    {0, BTN_LABEL_PROP_BTN_7},
    {0, BTN_LABEL_PROP_BTN_8},
    {0, BTN_LABEL_PROP_BTN_9},

    {0, BTN_LABEL_PROP_BTN_LEFT},
    {0, BTN_LABEL_PROP_BTN_RIGHT},
    {0, BTN_LABEL_PROP_BTN_MIDDLE},
    {0, BTN_LABEL_PROP_BTN_SIDE},
    {0, BTN_LABEL_PROP_BTN_EXTRA},
    {0, BTN_LABEL_PROP_BTN_FORWARD},
    {0, BTN_LABEL_PROP_BTN_BACK},
    {0, BTN_LABEL_PROP_BTN_TASK},

    {0, BTN_LABEL_PROP_BTN_TRIGGER},
    {0, BTN_LABEL_PROP_BTN_THUMB},
    {0, BTN_LABEL_PROP_BTN_THUMB2},
    {0, BTN_LABEL_PROP_BTN_TOP},
    {0, BTN_LABEL_PROP_BTN_TOP2},
    {0, BTN_LABEL_PROP_BTN_PINKIE},
    {0, BTN_LABEL_PROP_BTN_BASE},
    {0, BTN_LABEL_PROP_BTN_BASE2},
    {0, BTN_LABEL_PROP_BTN_BASE3},
    {0, BTN_LABEL_PROP_BTN_BASE4},
    {0, BTN_LABEL_PROP_BTN_BASE5},
    {0, BTN_LABEL_PROP_BTN_BASE6},
    {0, BTN_LABEL_PROP_BTN_DEAD},

    {0, BTN_LABEL_PROP_BTN_A},
    {0, BTN_LABEL_PROP_BTN_B},
    {0, BTN_LABEL_PROP_BTN_C},
    {0, BTN_LABEL_PROP_BTN_X},
    {0, BTN_LABEL_PROP_BTN_Y},
    {0, BTN_LABEL_PROP_BTN_Z},
    {0, BTN_LABEL_PROP_BTN_TL},
    {0, BTN_LABEL_PROP_BTN_TR},
    {0, BTN_LABEL_PROP_BTN_TL2},
    {0, BTN_LABEL_PROP_BTN_TR2},
    {0, BTN_LABEL_PROP_BTN_SELECT},
    {0, BTN_LABEL_PROP_BTN_START},
    {0, BTN_LABEL_PROP_BTN_MODE},
    {0, BTN_LABEL_PROP_BTN_THUMBL},
    {0, BTN_LABEL_PROP_BTN_THUMBR},

    {0, BTN_LABEL_PROP_BTN_TOOL_PEN},
    {0, BTN_LABEL_PROP_BTN_TOOL_RUBBER},
    {0, BTN_LABEL_PROP_BTN_TOOL_BRUSH},
    {0, BTN_LABEL_PROP_BTN_TOOL_PENCIL},
    {0, BTN_LABEL_PROP_BTN_TOOL_AIRBRUSH},
    {0, BTN_LABEL_PROP_BTN_TOOL_FINGER},
    {0, BTN_LABEL_PROP_BTN_TOOL_MOUSE},
    {0, BTN_LABEL_PROP_BTN_TOOL_LENS},
    {0, BTN_LABEL_PROP_BTN_TOUCH},
    {0, BTN_LABEL_PROP_BTN_STYLUS},
    {0, BTN_LABEL_PROP_BTN_STYLUS2},
    {0, BTN_LABEL_PROP_BTN_TOOL_DOUBLETAP},
    {0, BTN_LABEL_PROP_BTN_TOOL_TRIPLETAP},

    {0, BTN_LABEL_PROP_BTN_GEAR_DOWN},
    {0, BTN_LABEL_PROP_BTN_GEAR_UP},

    {0, XI_PROP_TRANSFORM}
};

static long XIPropHandlerID = 1;

static void send_property_event(DeviceIntPtr dev, Atom property, int what)
{
        devicePropertyNotify    event;
        xXIPropertyEvent        xi2;
        int state;

        if (what == XIPropertyDeleted)
            state = PropertyDelete;
        else
            state = PropertyNewValue;

        event.type      = DevicePropertyNotify;
        event.deviceid  = dev->id;
        event.state     = state;
        event.atom      = property;
        event.time      = currentTime.milliseconds;
        SendEventToAllWindows(dev, DevicePropertyNotifyMask,
                              (xEvent*)&event, 1);

        xi2.type        = GenericEvent;
        xi2.extension   = IReqCode;
        xi2.length      = 0;
        xi2.evtype      = XI_PropertyEvent;
        xi2.deviceid    = dev->id;
        xi2.time        = currentTime.milliseconds;
        xi2.property    = property;
        xi2.what        = what;
        SendEventToAllWindows(dev, GetEventFilter(dev, (xEvent*)&xi2),
                              (xEvent*)&xi2, 1);
}

static int list_atoms(DeviceIntPtr dev, int *natoms, Atom **atoms_return)
{
    XIPropertyPtr prop;
    Atom *atoms         = NULL;
    int nprops          = 0;

    for (prop = dev->properties.properties; prop; prop = prop->next)
        nprops++;
    if (nprops)
    {
        Atom *a;

        atoms = malloc(nprops * sizeof(Atom));
        if(!atoms)
            return BadAlloc;
        a = atoms;
        for (prop = dev->properties.properties; prop; prop = prop->next, a++)
            *a = prop->propertyName;
    }

    *natoms = nprops;
    *atoms_return = atoms;
    return Success;
}

static int
get_property(ClientPtr client, DeviceIntPtr dev, Atom property, Atom type,
             BOOL delete, int offset, int length,
             int *bytes_after, Atom *type_return, int *format, int *nitems,
             int *length_return, char **data)
{
    unsigned long n, len, ind;
    int rc;
    XIPropertyPtr prop;
    XIPropertyValuePtr prop_value;

    if (!ValidAtom(property))
    {
        client->errorValue = property;
        return BadAtom;
    }
    if ((delete != xTrue) && (delete != xFalse))
    {
        client->errorValue = delete;
        return BadValue;
    }

    if ((type != AnyPropertyType) && !ValidAtom(type))
    {
        client->errorValue = type;
        return BadAtom;
    }

    for (prop = dev->properties.properties; prop; prop = prop->next)
        if (prop->propertyName == property)
            break;

    if (!prop)
    {
        *bytes_after = 0;
        *type_return = None;
        *format = 0;
        *nitems = 0;
        *length_return = 0;
        return Success;
    }

    rc = XIGetDeviceProperty(dev, property, &prop_value);
    if (rc != Success)
    {
        client->errorValue = property;
        return rc;
    }

    /* If the request type and actual type don't match. Return the
    property information, but not the data. */

    if (((type != prop_value->type) && (type != AnyPropertyType)))
    {
        *bytes_after = prop_value->size;
        *format = prop_value->format;
        *length_return = 0;
        *nitems = 0;
        *type_return = prop_value->type;
        return Success;
    }

    /* Return type, format, value to client */
    n = (prop_value->format/8) * prop_value->size; /* size (bytes) of prop */
    ind = offset << 2;

   /* If offset is invalid such that it causes "len" to
            be negative, it's a value error. */

    if (n < ind)
    {
        client->errorValue = offset;
        return BadValue;
    }

    len = min(n - ind, 4 * length);

    *bytes_after = n - (ind + len);
    *format = prop_value->format;
    *length_return = len;
    if (prop_value->format)
        *nitems = len / (prop_value->format / 8);
    else
        *nitems = 0;
    *type_return = prop_value->type;

    *data = (char*)prop_value->data + ind;

    return Success;
}

static int
check_change_property(ClientPtr client, Atom property, Atom type, int format,
                      int mode, int nitems)
{
    if ((mode != PropModeReplace) && (mode != PropModeAppend) &&
        (mode != PropModePrepend))
    {
        client->errorValue = mode;
        return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32))
    {
        client->errorValue = format;
        return BadValue;
    }

    if (!ValidAtom(property))
    {
        client->errorValue = property;
        return BadAtom;
    }
    if (!ValidAtom(type))
    {
        client->errorValue = type;
        return BadAtom;
    }

    return Success;
}

static int
change_property(ClientPtr client, DeviceIntPtr dev, Atom property, Atom type,
                int format, int mode, int len, void *data)
{
    int rc = Success;

    rc = XIChangeDeviceProperty(dev, property, type, format, mode, len, data, TRUE);
    if (rc != Success)
        client->errorValue = property;

    return rc;
}

/**
 * Return the atom assigned to the specified string or 0 if the atom isn't known
 * to the DIX.
 *
 * If name is NULL, None is returned.
 */
Atom
XIGetKnownProperty(char *name)
{
    int i;

    if (!name)
        return None;

    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
    {
        if (strcmp(name, dev_properties[i].name) == 0){
            if (dev_properties[i].type == None){
		dev_properties[i].type =
			    MakeAtom(dev_properties[i].name,
			             strlen(dev_properties[i].name),
			             TRUE);
            }

            return dev_properties[i].type;
        }
    }

    return 0;
}

void
XIResetProperties(void)
{
    int i;

    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
        dev_properties[i].type = None;
}

/**
 * Convert the given property's value(s) into @nelem_return integer values and
 * store them in @buf_return. If @nelem_return is larger than the number of
 * values in the property, @nelem_return is set to the number of values in the
 * property.
 *
 * If *@buf_return is NULL and @nelem_return is 0, memory is allocated
 * automatically and must be freed by the caller.
 *
 * Possible return codes.
 * Success ... No error.
 * BadMatch ... Wrong atom type, atom is not XA_INTEGER
 * BadAlloc ... NULL passed as buffer and allocation failed.
 * BadLength ... @buff is NULL but @nelem_return is non-zero.
 *
 * @param val The property value
 * @param nelem_return The maximum number of elements to return.
 * @param buf_return Pointer to an array of at least @nelem_return values.
 * @return Success or the error code if an error occured.
 */
_X_EXPORT int
XIPropToInt(XIPropertyValuePtr val, int *nelem_return, int **buf_return)
{
    int i;
    int *buf;

    if (val->type != XA_INTEGER)
        return BadMatch;
    if (!*buf_return && *nelem_return)
        return BadLength;

    switch(val->format)
    {
        case 8:
        case 16:
        case 32:
            break;
        default:
            return BadValue;
    }

    buf = *buf_return;

    if (!buf && !(*nelem_return))
    {
        buf = calloc(val->size, sizeof(int));
        if (!buf)
            return BadAlloc;
        *buf_return = buf;
        *nelem_return = val->size;
    } else if (val->size < *nelem_return)
        *nelem_return = val->size;

    for (i = 0; i < val->size && i < *nelem_return; i++)
    {
        switch(val->format)
        {
            case 8:  buf[i] = ((CARD8*)val->data)[i]; break;
            case 16: buf[i] = ((CARD16*)val->data)[i]; break;
            case 32: buf[i] = ((CARD32*)val->data)[i]; break;
        }
    }

    return Success;
}

/**
 * Convert the given property's value(s) into @nelem_return float values and
 * store them in @buf_return. If @nelem_return is larger than the number of
 * values in the property, @nelem_return is set to the number of values in the
 * property.
 *
 * If *@buf_return is NULL and @nelem_return is 0, memory is allocated
 * automatically and must be freed by the caller.
 *
 * Possible errors returned:
 * Success
 * BadMatch ... Wrong atom type, atom is not XA_FLOAT
 * BadValue ... Wrong format, format is not 32
 * BadAlloc ... NULL passed as buffer and allocation failed.
 * BadLength ... @buff is NULL but @nelem_return is non-zero.
 *
 * @param val The property value
 * @param nelem_return The maximum number of elements to return.
 * @param buf_return Pointer to an array of at least @nelem_return values.
 * @return Success or the error code if an error occured.
 */
_X_EXPORT int
XIPropToFloat(XIPropertyValuePtr val, int *nelem_return, float **buf_return)
{
    int i;
    float *buf;

    if (!val->type || val->type != XIGetKnownProperty(XATOM_FLOAT))
        return BadMatch;

    if (val->format != 32)
        return BadValue;
    if (!*buf_return && *nelem_return)
        return BadLength;

    buf = *buf_return;

    if (!buf && !(*nelem_return))
    {
        buf = calloc(val->size, sizeof(float));
        if (!buf)
            return BadAlloc;
        *buf_return = buf;
        *nelem_return = val->size;
    } else if (val->size < *nelem_return)
        *nelem_return = val->size;

    for (i = 0; i < val->size && i < *nelem_return; i++)
           buf[i] = ((float*)val->data)[i];

    return Success;
}

/* Registers a new property handler on the given device and returns a unique
 * identifier for this handler. This identifier is required to unregister the
 * property handler again.
 * @return The handler's identifier or 0 if an error occured.
 */
long
XIRegisterPropertyHandler(DeviceIntPtr         dev,
                          int (*SetProperty) (DeviceIntPtr dev,
                                              Atom property,
                                              XIPropertyValuePtr prop,
                                              BOOL checkonly),
                          int (*GetProperty) (DeviceIntPtr dev,
                                              Atom property),
                          int (*DeleteProperty) (DeviceIntPtr dev,
                                                 Atom property))
{
    XIPropertyHandlerPtr new_handler;

    new_handler = calloc(1, sizeof(XIPropertyHandler));
    if (!new_handler)
        return 0;

    new_handler->id = XIPropHandlerID++;
    new_handler->SetProperty = SetProperty;
    new_handler->GetProperty = GetProperty;
    new_handler->DeleteProperty = DeleteProperty;
    new_handler->next = dev->properties.handlers;
    dev->properties.handlers = new_handler;

    return new_handler->id;
}

void
XIUnregisterPropertyHandler(DeviceIntPtr dev, long id)
{
    XIPropertyHandlerPtr curr, prev = NULL;

    curr = dev->properties.handlers;
    while(curr && curr->id != id)
    {
        prev = curr;
        curr = curr->next;
    }

    if (!curr)
        return;

    if (!prev) /* first one */
        dev->properties.handlers = curr->next;
    else
        prev->next = curr->next;

    free(curr);
}

static XIPropertyPtr
XICreateDeviceProperty (Atom property)
{
    XIPropertyPtr   prop;

    prop = (XIPropertyPtr)malloc(sizeof(XIPropertyRec));
    if (!prop)
        return NULL;

    prop->next          = NULL;
    prop->propertyName  = property;
    prop->value.type   = None;
    prop->value.format = 0;
    prop->value.size   = 0;
    prop->value.data   = NULL;
    prop->deletable    = TRUE;

    return prop;
}

static XIPropertyPtr
XIFetchDeviceProperty(DeviceIntPtr dev, Atom property)
{
    XIPropertyPtr   prop;

    for (prop = dev->properties.properties; prop; prop = prop->next)
        if (prop->propertyName == property)
            return prop;
    return NULL;
}

static void
XIDestroyDeviceProperty (XIPropertyPtr prop)
{
    free(prop->value.data);
    free(prop);
}

/* This function destroys all of the device's property-related stuff,
 * including removing all device handlers.
 * DO NOT CALL FROM THE DRIVER.
 */
void
XIDeleteAllDeviceProperties (DeviceIntPtr device)
{
    XIPropertyPtr               prop, next;
    XIPropertyHandlerPtr        curr_handler, next_handler;

    for (prop = device->properties.properties; prop; prop = next)
    {
        next = prop->next;
        send_property_event(device, prop->propertyName, XIPropertyDeleted);
        XIDestroyDeviceProperty(prop);
    }

    device->properties.properties = NULL;

    /* Now free all handlers */
    curr_handler = device->properties.handlers;
    while(curr_handler)
    {
        next_handler = curr_handler->next;
        free(curr_handler);
        curr_handler = next_handler;
    }

    device->properties.handlers = NULL;
}


int
XIDeleteDeviceProperty (DeviceIntPtr device, Atom property, Bool fromClient)
{
    XIPropertyPtr               prop, *prev;
    int                         rc = Success;

    for (prev = &device->properties.properties; (prop = *prev); prev = &(prop->next))
        if (prop->propertyName == property)
            break;

    if (!prop)
        return Success;

    if (fromClient && !prop->deletable)
        return BadAccess;

    /* Ask handlers if we may delete the property */
    if (device->properties.handlers)
    {
        XIPropertyHandlerPtr handler = device->properties.handlers;
        while(handler)
        {
            if (handler->DeleteProperty)
                rc = handler->DeleteProperty(device, prop->propertyName);
            if (rc != Success)
                return rc;
            handler = handler->next;
        }
    }

    if (prop)
    {
        *prev = prop->next;
        send_property_event(device, prop->propertyName, XIPropertyDeleted);
        XIDestroyDeviceProperty (prop);
    }

    return Success;
}

int
XIChangeDeviceProperty (DeviceIntPtr dev, Atom property, Atom type,
                        int format, int mode, unsigned long len,
                        const pointer value, Bool sendevent)
{
    XIPropertyPtr               prop;
    int                         size_in_bytes;
    int                         total_size;
    unsigned long               total_len;
    XIPropertyValuePtr          prop_value;
    XIPropertyValueRec          new_value;
    Bool                        add = FALSE;
    int                         rc;

    size_in_bytes = format >> 3;

    /* first see if property already exists */
    prop = XIFetchDeviceProperty (dev, property);
    if (!prop)   /* just add to list */
    {
        prop = XICreateDeviceProperty (property);
        if (!prop)
            return BadAlloc;
        add = TRUE;
        mode = PropModeReplace;
    }
    prop_value = &prop->value;

    /* To append or prepend to a property the request format and type
     must match those of the already defined property.  The
     existing format and type are irrelevant when using the mode
     "PropModeReplace" since they will be written over. */

    if ((format != prop_value->format) && (mode != PropModeReplace))
        return BadMatch;
    if ((prop_value->type != type) && (mode != PropModeReplace))
        return BadMatch;
    new_value = *prop_value;
    if (mode == PropModeReplace)
        total_len = len;
    else
        total_len = prop_value->size + len;

    if (mode == PropModeReplace || len > 0)
    {
        pointer            new_data = NULL, old_data = NULL;

        total_size = total_len * size_in_bytes;
        new_value.data = (pointer)malloc(total_size);
        if (!new_value.data && total_size)
        {
            if (add)
                XIDestroyDeviceProperty (prop);
            return BadAlloc;
        }
        new_value.size = len;
        new_value.type = type;
        new_value.format = format;

        switch (mode) {
        case PropModeReplace:
            new_data = new_value.data;
            old_data = NULL;
            break;
        case PropModeAppend:
            new_data = (pointer) (((char *) new_value.data) +
                                  (prop_value->size * size_in_bytes));
            old_data = new_value.data;
            break;
        case PropModePrepend:
            new_data = new_value.data;
            old_data = (pointer) (((char *) new_value.data) +
                                  (prop_value->size * size_in_bytes));
            break;
        }
        if (new_data)
            memcpy ((char *) new_data, (char *) value, len * size_in_bytes);
        if (old_data)
            memcpy ((char *) old_data, (char *) prop_value->data,
                    prop_value->size * size_in_bytes);

        if (dev->properties.handlers)
        {
            XIPropertyHandlerPtr handler;
            BOOL checkonly = TRUE;
            /* run through all handlers with checkonly TRUE, then again with
             * checkonly FALSE. Handlers MUST return error codes on the
             * checkonly run, errors on the second run are ignored */
            do
            {
                handler = dev->properties.handlers;
                while(handler)
                {
                    if (handler->SetProperty)
                    {
                        rc = handler->SetProperty(dev, prop->propertyName,
                                &new_value, checkonly);
                        if (checkonly && rc != Success)
                        {
                            free(new_value.data);
                            return rc;
                        }
                    }
                    handler = handler->next;
                }
                checkonly = !checkonly;
            } while (!checkonly);
        }
        free(prop_value->data);
        *prop_value = new_value;
    } else if (len == 0)
    {
        /* do nothing */
    }

    if (add)
    {
        prop->next = dev->properties.properties;
        dev->properties.properties = prop;
    }

    if (sendevent)
        send_property_event(dev, prop->propertyName,
                            (add) ?  XIPropertyCreated : XIPropertyModified);

    return Success;
}

int
XIGetDeviceProperty (DeviceIntPtr dev, Atom property, XIPropertyValuePtr *value)
{
    XIPropertyPtr   prop = XIFetchDeviceProperty (dev, property);
    int rc;

    if (!prop)
    {
        *value = NULL;
        return BadAtom;
    }

    /* If we can, try to update the property value first */
    if (dev->properties.handlers)
    {
        XIPropertyHandlerPtr handler = dev->properties.handlers;
        while(handler)
        {
            if (handler->GetProperty)
            {
                rc = handler->GetProperty(dev, prop->propertyName);
                if (rc != Success)
                {
                    *value = NULL;
                    return rc;
                }
            }
            handler = handler->next;
        }
    }

    *value = &prop->value;
    return Success;
}

int
XISetDevicePropertyDeletable(DeviceIntPtr dev, Atom property, Bool deletable)
{
    XIPropertyPtr prop = XIFetchDeviceProperty(dev, property);

    if (!prop)
        return BadAtom;

    prop->deletable = deletable;
    return Success;
}

int
ProcXListDeviceProperties (ClientPtr client)
{
    Atom                        *atoms;
    xListDevicePropertiesReply  rep;
    int                         natoms;
    DeviceIntPtr                dev;
    int                         rc = Success;

    REQUEST(xListDevicePropertiesReq);
    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);

    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixListPropAccess);
    if (rc != Success)
        return rc;

    rc = list_atoms(dev, &natoms, &atoms);
    if (rc != Success)
        return rc;

    rep.repType = X_Reply;
    rep.RepType = X_ListDeviceProperties;
    rep.length = natoms;
    rep.sequenceNumber = client->sequence;
    rep.nAtoms = natoms;

    WriteReplyToClient(client, sizeof(xListDevicePropertiesReply), &rep);
    if (natoms)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
        WriteSwappedDataToClient(client, natoms * sizeof(Atom), atoms);
        free(atoms);
    }
    return rc;
}

int
ProcXChangeDeviceProperty (ClientPtr client)
{
    REQUEST(xChangeDevicePropertyReq);
    DeviceIntPtr        dev;
    unsigned long       len;
    int                 totalSize;
    int                 rc;

    REQUEST_AT_LEAST_SIZE(xChangeDevicePropertyReq);
    UpdateCurrentTime();

    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    rc = check_change_property(client, stuff->property, stuff->type,
                               stuff->format, stuff->mode, stuff->nUnits);

    len = stuff->nUnits;
    if (len > (bytes_to_int32(0xffffffff - sizeof(xChangeDevicePropertyReq))))
        return BadLength;

    totalSize = len * (stuff->format/8);
    REQUEST_FIXED_SIZE(xChangeDevicePropertyReq, totalSize);

    rc = change_property(client, dev, stuff->property, stuff->type,
                         stuff->format, stuff->mode, len, (void*)&stuff[1]);
    return rc;
}

int
ProcXDeleteDeviceProperty (ClientPtr client)
{
    REQUEST(xDeleteDevicePropertyReq);
    DeviceIntPtr        dev;
    int                 rc;

    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
    UpdateCurrentTime();
    rc =  dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    if (!ValidAtom(stuff->property))
    {
        client->errorValue = stuff->property;
        return BadAtom;
    }

    rc = XIDeleteDeviceProperty(dev, stuff->property, TRUE);
    return rc;
}

int
ProcXGetDeviceProperty (ClientPtr client)
{
    REQUEST(xGetDevicePropertyReq);
    DeviceIntPtr                dev;
    int                         length;
    int                         rc, format, nitems, bytes_after;
    char                        *data;
    Atom                        type;
    xGetDevicePropertyReply     reply;

    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
    if (stuff->delete)
        UpdateCurrentTime();
    rc = dixLookupDevice (&dev, stuff->deviceid, client,
                           stuff->delete ? DixSetPropAccess :
                           DixGetPropAccess);
    if (rc != Success)
        return rc;

    rc = get_property(client, dev, stuff->property, stuff->type,
            stuff->delete, stuff->longOffset, stuff->longLength,
            &bytes_after, &type, &format, &nitems, &length, &data);

    if (rc != Success)
        return rc;

    reply.repType = X_Reply;
    reply.RepType = X_GetDeviceProperty;
    reply.sequenceNumber = client->sequence;
    reply.deviceid = dev->id;
    reply.nItems = nitems;
    reply.format = format;
    reply.bytesAfter = bytes_after;
    reply.propertyType = type;
    reply.length = bytes_to_int32(length);

    if (stuff->delete && (reply.bytesAfter == 0))
        send_property_event(dev, stuff->property, XIPropertyDeleted);

    WriteReplyToClient(client, sizeof(xGenericReply), &reply);

    if (length)
    {
        switch (reply.format) {
            case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
            case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
            default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
        }
        WriteSwappedDataToClient(client, length, data);
    }

    /* delete the Property */
    if (stuff->delete && (reply.bytesAfter == 0))
    {
        XIPropertyPtr prop, *prev;
        for (prev = &dev->properties.properties; (prop = *prev); prev = &prop->next)
        {
            if (prop->propertyName == stuff->property)
            {
                *prev = prop->next;
                XIDestroyDeviceProperty(prop);
                break;
            }
        }
    }
    return Success;
}


int
SProcXListDeviceProperties (ClientPtr client)
{
    char n;
    REQUEST(xListDevicePropertiesReq);

    swaps(&stuff->length, n);

    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);
    return (ProcXListDeviceProperties(client));
}

int
SProcXChangeDeviceProperty (ClientPtr client)
{
    char n;
    REQUEST(xChangeDevicePropertyReq);

    REQUEST_AT_LEAST_SIZE(xChangeDevicePropertyReq);
    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->nUnits, n);
    return (ProcXChangeDeviceProperty(client));
}

int
SProcXDeleteDeviceProperty (ClientPtr client)
{
    char n;
    REQUEST(xDeleteDevicePropertyReq);

    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
    return (ProcXDeleteDeviceProperty(client));
}

int
SProcXGetDeviceProperty (ClientPtr client)
{
    char n;
    REQUEST(xGetDevicePropertyReq);

    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->longOffset, n);
    swapl(&stuff->longLength, n);
    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
    return (ProcXGetDeviceProperty(client));
}


/* Reply swapping */

void
SRepXListDeviceProperties(ClientPtr client, int size,
                          xListDevicePropertiesReply *rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->nAtoms, n);
    /* properties will be swapped later, see ProcXListDeviceProperties */
    WriteToClient(client, size, (char*)rep);
}

void
SRepXGetDeviceProperty(ClientPtr client, int size,
                       xGetDevicePropertyReply *rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->propertyType, n);
    swapl(&rep->bytesAfter, n);
    swapl(&rep->nItems, n);
    /* data will be swapped, see ProcXGetDeviceProperty */
    WriteToClient(client, size, (char*)rep);
}

/* XI2 Request/reply handling */
int
ProcXIListProperties(ClientPtr client)
{
    Atom                        *atoms;
    xXIListPropertiesReply      rep;
    int                         natoms;
    DeviceIntPtr                dev;
    int                         rc = Success;

    REQUEST(xXIListPropertiesReq);
    REQUEST_SIZE_MATCH(xXIListPropertiesReq);

    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixListPropAccess);
    if (rc != Success)
        return rc;

    rc = list_atoms(dev, &natoms, &atoms);
    if (rc != Success)
        return rc;

    rep.repType = X_Reply;
    rep.RepType = X_XIListProperties;
    rep.length = natoms;
    rep.sequenceNumber = client->sequence;
    rep.num_properties = natoms;

    WriteReplyToClient(client, sizeof(xXIListPropertiesReply), &rep);
    if (natoms)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
        WriteSwappedDataToClient(client, natoms * sizeof(Atom), atoms);
        free(atoms);
    }
    return rc;
}

int
ProcXIChangeProperty(ClientPtr client)
{
    int                 rc;
    DeviceIntPtr        dev;
    int                 totalSize;
    unsigned long       len;

    REQUEST(xXIChangePropertyReq);
    REQUEST_AT_LEAST_SIZE(xXIChangePropertyReq);
    UpdateCurrentTime();

    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    rc = check_change_property(client, stuff->property, stuff->type,
                               stuff->format, stuff->mode, stuff->num_items);
    len = stuff->num_items;
    if (len > bytes_to_int32(0xffffffff - sizeof(xXIChangePropertyReq)))
        return BadLength;

    totalSize = len * (stuff->format/8);
    REQUEST_FIXED_SIZE(xXIChangePropertyReq, totalSize);

    rc = change_property(client, dev, stuff->property, stuff->type,
                         stuff->format, stuff->mode, len, (void*)&stuff[1]);
    return rc;
}

int
ProcXIDeleteProperty(ClientPtr client)
{
    DeviceIntPtr        dev;
    int                 rc;
    REQUEST(xXIDeletePropertyReq);

    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);
    UpdateCurrentTime();
    rc =  dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    if (!ValidAtom(stuff->property))
    {
        client->errorValue = stuff->property;
        return BadAtom;
    }

    rc = XIDeleteDeviceProperty(dev, stuff->property, TRUE);
    return rc;
}


int
ProcXIGetProperty(ClientPtr client)
{
    REQUEST(xXIGetPropertyReq);
    DeviceIntPtr                dev;
    xXIGetPropertyReply         reply;
    int                         length;
    int                         rc, format, nitems, bytes_after;
    char                        *data;
    Atom                        type;

    REQUEST_SIZE_MATCH(xXIGetPropertyReq);
    if (stuff->delete)
        UpdateCurrentTime();
    rc = dixLookupDevice (&dev, stuff->deviceid, client,
                           stuff->delete ? DixSetPropAccess :
                           DixGetPropAccess);
    if (rc != Success)
        return rc;

    rc = get_property(client, dev, stuff->property, stuff->type,
            stuff->delete, stuff->offset, stuff->len,
            &bytes_after, &type, &format, &nitems, &length, &data);

    if (rc != Success)
        return rc;

    reply.repType = X_Reply;
    reply.RepType = X_XIGetProperty;
    reply.sequenceNumber = client->sequence;
    reply.num_items = nitems;
    reply.format = format;
    reply.bytes_after = bytes_after;
    reply.type = type;
    reply.length = bytes_to_int32(length);

    if (length && stuff->delete && (reply.bytes_after == 0))
        send_property_event(dev, stuff->property, XIPropertyDeleted);

    WriteReplyToClient(client, sizeof(xXIGetPropertyReply), &reply);

    if (length)
    {
        switch (reply.format) {
            case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
            case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
            default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
        }
        WriteSwappedDataToClient(client, length, data);
    }

    /* delete the Property */
    if (stuff->delete && (reply.bytes_after == 0))
    {
        XIPropertyPtr prop, *prev;
        for (prev = &dev->properties.properties; (prop = *prev); prev = &prop->next)
        {
            if (prop->propertyName == stuff->property)
            {
                *prev = prop->next;
                XIDestroyDeviceProperty(prop);
                break;
            }
        }
    }

    return Success;
}

int
SProcXIListProperties(ClientPtr client)
{
    char n;
    REQUEST(xXIListPropertiesReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);

    REQUEST_SIZE_MATCH(xXIListPropertiesReq);
    return (ProcXIListProperties(client));
}

int
SProcXIChangeProperty(ClientPtr client)
{
    char n;
    REQUEST(xXIChangePropertyReq);

    REQUEST_AT_LEAST_SIZE(xXIChangePropertyReq);
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->num_items, n);
    return (ProcXIChangeProperty(client));
}

int
SProcXIDeleteProperty(ClientPtr client)
{
    char n;
    REQUEST(xXIDeletePropertyReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);
    return (ProcXIDeleteProperty(client));
}

int
SProcXIGetProperty(ClientPtr client)
{
    char n;
    REQUEST(xXIGetPropertyReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->offset, n);
    swapl(&stuff->len, n);
    REQUEST_SIZE_MATCH(xXIGetPropertyReq);
    return (ProcXIGetProperty(client));
}


void
SRepXIListProperties(ClientPtr client, int size,
                     xXIListPropertiesReply *rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_properties, n);
    /* properties will be swapped later, see ProcXIListProperties */
    WriteToClient(client, size, (char*)rep);
}

void
SRepXIGetProperty(ClientPtr client, int size,
                  xXIGetPropertyReply *rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->type, n);
    swapl(&rep->bytes_after, n);
    swapl(&rep->num_items, n);
    /* data will be swapped, see ProcXIGetProperty */
    WriteToClient(client, size, (char*)rep);
}
/*
 * Copyright © 2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XIPROPERTY_H
#define XIPROPERTY_H 1

int ProcXListDeviceProperties     (ClientPtr client);
int ProcXChangeDeviceProperty     (ClientPtr client);
int ProcXDeleteDeviceProperty     (ClientPtr client);
int ProcXGetDeviceProperty        (ClientPtr client);

/* request swapping */
int SProcXListDeviceProperties    (ClientPtr client);
int SProcXChangeDeviceProperty    (ClientPtr client);
int SProcXDeleteDeviceProperty    (ClientPtr client);
int SProcXGetDeviceProperty       (ClientPtr client);

/* reply swapping */
void SRepXListDeviceProperties(ClientPtr client, int size,
                               xListDevicePropertiesReply *rep);
void SRepXGetDeviceProperty(ClientPtr client, int size,
                            xGetDevicePropertyReply *rep);

/* XI2 request/reply handling  */
int ProcXIListProperties        (ClientPtr client);
int ProcXIChangeProperty        (ClientPtr client);
int ProcXIDeleteProperty        (ClientPtr client);
int ProcXIGetProperty           (ClientPtr client);

int SProcXIListProperties       (ClientPtr client);
int SProcXIChangeProperty       (ClientPtr client);
int SProcXIDeleteProperty       (ClientPtr client);
int SProcXIGetProperty          (ClientPtr client);

void SRepXIListProperties(ClientPtr client, int size,
                          xXIListPropertiesReply *rep);
void SRepXIGetProperty(ClientPtr client, int size,
                       xXIGetPropertyReply *rep);

void XIResetProperties(void);

#endif /* XIPROPERTY_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

/**
 * @file Protocol handling for the XIQueryDevice request/reply.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"
#include <X11/X.h>
#include <X11/Xatom.h>
#include <X11/extensions/XI2proto.h>
#include "xkbstr.h"
#include "xkbsrv.h"
#include "xserver-properties.h"
#include "exevents.h"
#include "xace.h"

#include "xiquerydevice.h"

static Bool ShouldSkipDevice(ClientPtr client, int deviceid, DeviceIntPtr d);
static int
ListDeviceInfo(ClientPtr client, DeviceIntPtr dev, xXIDeviceInfo* info);
static int SizeDeviceInfo(DeviceIntPtr dev);
static void SwapDeviceInfo(DeviceIntPtr dev, xXIDeviceInfo* info);
int
SProcXIQueryDevice(ClientPtr client)
{
    char n;

    REQUEST(xXIQueryDeviceReq);

    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);

    return ProcXIQueryDevice(client);
}

int
ProcXIQueryDevice(ClientPtr client)
{
    xXIQueryDeviceReply rep;
    DeviceIntPtr dev = NULL;
    int rc = Success;
    int i = 0, len = 0;
    char *info, *ptr;
    Bool *skip = NULL;

    REQUEST(xXIQueryDeviceReq);
    REQUEST_SIZE_MATCH(xXIQueryDeviceReq);

    if (stuff->deviceid != XIAllDevices && stuff->deviceid != XIAllMasterDevices)
    {
        rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->deviceid;
            return rc;
        }
        len += SizeDeviceInfo(dev);
    }
    else
    {
        skip = calloc(sizeof(Bool), inputInfo.numDevices);
        if (!skip)
            return BadAlloc;

        for (dev = inputInfo.devices; dev; dev = dev->next, i++)
        {
            skip[i] = ShouldSkipDevice(client, stuff->deviceid, dev);
            if (!skip[i])
                len += SizeDeviceInfo(dev);
        }

        for (dev = inputInfo.off_devices; dev; dev = dev->next, i++)
        {
            skip[i] = ShouldSkipDevice(client, stuff->deviceid, dev);
            if (!skip[i])
                len += SizeDeviceInfo(dev);
        }
    }

    info = calloc(1, len);
    if (!info) {
        free(skip);
        return BadAlloc;
    }

    memset(&rep, 0, sizeof(xXIQueryDeviceReply));
    rep.repType = X_Reply;
    rep.RepType = X_XIQueryDevice;
    rep.sequenceNumber = client->sequence;
    rep.length = len/4;
    rep.num_devices = 0;

    ptr = info;
    if (dev)
    {
        len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
        if (client->swapped)
            SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
        info += len;
        rep.num_devices = 1;
    } else
    {
        i = 0;
        for (dev = inputInfo.devices; dev; dev = dev->next, i++)
        {
            if (!skip[i])
            {
                len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
                if (client->swapped)
                    SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
                info += len;
                rep.num_devices++;
            }
        }

        for (dev = inputInfo.off_devices; dev; dev = dev->next, i++)
        {
            if (!skip[i])
            {
                len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
                if (client->swapped)
                    SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
                info += len;
                rep.num_devices++;
            }
        }
    }

    len = rep.length * 4;
    WriteReplyToClient(client, sizeof(xXIQueryDeviceReply), &rep);
    WriteToClient(client, len, ptr);
    free(ptr);
    free(skip);
    return rc;
}

void
SRepXIQueryDevice(ClientPtr client, int size, xXIQueryDeviceReply *rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_devices, n);

    /* Device info is already swapped, see ProcXIQueryDevice */

    WriteToClient(client, size, (char *)rep);
}


/**
 * @return Whether the device should be included in the returned list.
 */
static Bool
ShouldSkipDevice(ClientPtr client, int deviceid, DeviceIntPtr dev)
{
    /* if all devices are not being queried, only master devices are */
    if (deviceid == XIAllDevices || IsMaster(dev))
    {
        int rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixGetAttrAccess);
        if (rc == Success)
            return FALSE;
    }
    return TRUE;
}

/**
 * @return The number of bytes needed to store this device's xXIDeviceInfo
 * (and its classes).
 */
static int
SizeDeviceInfo(DeviceIntPtr dev)
{
    int len = sizeof(xXIDeviceInfo);

    /* 4-padded name */
    len += pad_to_int32(strlen(dev->name));

    return len + SizeDeviceClasses(dev);

}

/*
 * @return The number of bytes needed to store this device's classes.
 */
int
SizeDeviceClasses(DeviceIntPtr dev)
{
    int len = 0;

    if (dev->button)
    {
        len += sizeof(xXIButtonInfo);
        len += dev->button->numButtons * sizeof(Atom);
        len += pad_to_int32(bits_to_bytes(dev->button->numButtons));
    }

    if (dev->key)
    {
        XkbDescPtr xkb = dev->key->xkbInfo->desc;
        len += sizeof(xXIKeyInfo);
        len += (xkb->max_key_code - xkb->min_key_code + 1) * sizeof(uint32_t);
    }

    if (dev->valuator)
        len += sizeof(xXIValuatorInfo) * dev->valuator->numAxes;

    return len;
}


/**
 * Write button information into info.
 * @return Number of bytes written into info.
 */
int
ListButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info, Bool reportState)
{
    unsigned char *bits;
    int mask_len;
    int i;

    if (!dev || !dev->button)
	return 0;

    mask_len = bytes_to_int32(bits_to_bytes(dev->button->numButtons));

    info->type = ButtonClass;
    info->num_buttons = dev->button->numButtons;
    info->length = bytes_to_int32(sizeof(xXIButtonInfo)) +
                   info->num_buttons + mask_len;
    info->sourceid = dev->button->sourceid;

    bits = (unsigned char*)&info[1];
    memset(bits, 0, mask_len * 4);

    if (reportState)
	for (i = 0; i < dev->button->numButtons; i++)
	    if (BitIsOn(dev->button->down, i))
		SetBit(bits, i);

    bits += mask_len * 4;
    memcpy(bits, dev->button->labels, dev->button->numButtons * sizeof(Atom));

    return info->length * 4;
}

static void
SwapButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info)
{
    char n;
    Atom *btn;
    int i;
    swaps(&info->type, n);
    swaps(&info->length, n);
    swaps(&info->sourceid, n);

    for (i = 0, btn = (Atom*)&info[1]; i < info->num_buttons; i++, btn++)
        swaps(btn, n);

    swaps(&info->num_buttons, n);
}

/**
 * Write key information into info.
 * @return Number of bytes written into info.
 */
int
ListKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info)
{
    int i;
    XkbDescPtr xkb = dev->key->xkbInfo->desc;
    uint32_t *kc;

    info->type = KeyClass;
    info->num_keycodes = xkb->max_key_code - xkb->min_key_code + 1;
    info->length = sizeof(xXIKeyInfo)/4 + info->num_keycodes;
    info->sourceid = dev->key->sourceid;

    kc = (uint32_t*)&info[1];
    for (i = xkb->min_key_code; i <= xkb->max_key_code; i++, kc++)
        *kc = i;

    return info->length * 4;
}

static void
SwapKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info)
{
    char n;
    uint32_t *key;
    int i;
    swaps(&info->type, n);
    swaps(&info->length, n);
    swaps(&info->sourceid, n);

    for (i = 0, key = (uint32_t*)&info[1]; i < info->num_keycodes; i++, key++)
        swapl(key, n);

    swaps(&info->num_keycodes, n);
}

/**
 * List axis information for the given axis.
 *
 * @return The number of bytes written into info.
 */
int
ListValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info, int axisnumber,
		 Bool reportState)
{
    ValuatorClassPtr v = dev->valuator;

    info->type = ValuatorClass;
    info->length = sizeof(xXIValuatorInfo)/4;
    info->label = v->axes[axisnumber].label;
    info->min.integral = v->axes[axisnumber].min_value;
    info->min.frac = 0;
    info->max.integral = v->axes[axisnumber].max_value;
    info->max.frac = 0;
    info->value.integral = (int)v->axisVal[axisnumber];
    info->value.frac = (int)(v->axisVal[axisnumber] * (1 << 16) * (1 << 16));
    info->resolution = v->axes[axisnumber].resolution;
    info->number = axisnumber;
    info->mode = valuator_get_mode(dev, axisnumber);
    info->sourceid = v->sourceid;

    if (!reportState)
	info->value = info->min;

    return info->length * 4;
}

static void
SwapValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info)
{
    char n;
    swaps(&info->type, n);
    swaps(&info->length, n);
    swapl(&info->label, n);
    swapl(&info->min.integral, n);
    swapl(&info->min.frac, n);
    swapl(&info->max.integral, n);
    swapl(&info->max.frac, n);
    swaps(&info->number, n);
    swaps(&info->sourceid, n);
}

int GetDeviceUse(DeviceIntPtr dev, uint16_t *attachment)
{
    DeviceIntPtr master = GetMaster(dev, MASTER_ATTACHED);
    int use;

    if (IsMaster(dev))
    {
        DeviceIntPtr paired = GetPairedDevice(dev);
        use = IsPointerDevice(dev) ? XIMasterPointer : XIMasterKeyboard;
        *attachment = (paired ? paired->id : 0);
    } else if (!IsFloating(dev))
    {
        use = IsPointerDevice(master) ? XISlavePointer : XISlaveKeyboard;
        *attachment = master->id;
    } else
        use = XIFloatingSlave;

    return use;
}

/**
 * Write the info for device dev into the buffer pointed to by info.
 *
 * @return The number of bytes used.
 */
static int
ListDeviceInfo(ClientPtr client, DeviceIntPtr dev, xXIDeviceInfo* info)
{
    char *any = (char*)&info[1];
    int len = 0, total_len = 0;

    info->deviceid = dev->id;
    info->use = GetDeviceUse(dev, &info->attachment);
    info->num_classes = 0;
    info->name_len = strlen(dev->name);
    info->enabled = dev->enabled;
    total_len = sizeof(xXIDeviceInfo);

    len = pad_to_int32(info->name_len);
    memset(any, 0, len);
    strncpy(any, dev->name, info->name_len);
    any += len;
    total_len += len;

    total_len += ListDeviceClasses(client, dev, any, &info->num_classes);
    return total_len;
}

/**
 * Write the class info of the device into the memory pointed to by any, set
 * nclasses to the number of classes in total and return the number of bytes
 * written.
 */
int
ListDeviceClasses(ClientPtr client, DeviceIntPtr dev,
		  char *any, uint16_t *nclasses)
{
    int total_len = 0;
    int len;
    int i;
    int rc;

    /* Check if the current device state should be suppressed */
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixReadAccess);

    if (dev->button)
    {
        (*nclasses)++;
        len = ListButtonInfo(dev, (xXIButtonInfo*)any, rc == Success);
        any += len;
        total_len += len;
    }

    if (dev->key)
    {
        (*nclasses)++;
        len = ListKeyInfo(dev, (xXIKeyInfo*)any);
        any += len;
        total_len += len;
    }

    for (i = 0; dev->valuator && i < dev->valuator->numAxes; i++)
    {
        (*nclasses)++;
        len = ListValuatorInfo(dev, (xXIValuatorInfo*)any, i, rc == Success);
        any += len;
        total_len += len;
    }

    return total_len;
}

static void
SwapDeviceInfo(DeviceIntPtr dev, xXIDeviceInfo* info)
{
    char n;
    char *any = (char*)&info[1];
    int i;

    /* Skip over name */
    any += pad_to_int32(info->name_len);

    for (i = 0; i < info->num_classes; i++)
    {
        int len = ((xXIAnyInfo*)any)->length;
        switch(((xXIAnyInfo*)any)->type)
        {
            case XIButtonClass:
                SwapButtonInfo(dev, (xXIButtonInfo*)any);
                break;
            case XIKeyClass:
                SwapKeyInfo(dev, (xXIKeyInfo*)any);
                break;
            case XIValuatorClass:
                SwapValuatorInfo(dev, (xXIValuatorInfo*)any);
                break;
        }

        any += len * 4;
    }

    swaps(&info->deviceid, n);
    swaps(&info->use, n);
    swaps(&info->attachment, n);
    swaps(&info->num_classes, n);
    swaps(&info->name_len, n);

}
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef QUERYDEV_H
#define QUERYDEV_H 1

#include <X11/extensions/XI2proto.h>

int SProcXIQueryDevice(ClientPtr client);
int ProcXIQueryDevice(ClientPtr client);
void SRepXIQueryDevice(ClientPtr client, int size, xXIQueryDeviceReply *rep);
int SizeDeviceClasses(DeviceIntPtr dev);
int ListDeviceClasses(ClientPtr client, DeviceIntPtr dev,
		      char* any, uint16_t* nclasses);
int GetDeviceUse(DeviceIntPtr dev, uint16_t *attachment);
int ListButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info, Bool reportState);
int ListKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info);
int ListValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info,
		     int axisnumber, Bool reportState);
#endif /* QUERYDEV_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request to query the pointer location of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "eventconvert.h"
#include "scrnintstr.h"
#include "xkbsrv.h"

#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

#include "xiquerypointer.h"

/***********************************************************************
 *
 * This procedure allows a client to query the pointer of a device.
 *
 */

int
SProcXIQueryPointer(ClientPtr client)
{
    char n;

    REQUEST(xXIQueryPointerReq);
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->win, n);
    return (ProcXIQueryPointer(client));
}

int
ProcXIQueryPointer(ClientPtr client)
{
    int rc;
    xXIQueryPointerReply rep;
    DeviceIntPtr pDev, kbd;
    WindowPtr pWin, t;
    SpritePtr pSprite;
    XkbStatePtr state;
    char *buttons = NULL;
    int buttons_size = 0; /* size of buttons array */

    REQUEST(xXIQueryPointerReq);
    REQUEST_SIZE_MATCH(xXIQueryPointerReq);

    rc = dixLookupDevice(&pDev, stuff->deviceid, client, DixReadAccess);
    if (rc != Success)
    {
        client->errorValue = stuff->deviceid;
        return rc;
    }

    if (pDev->valuator == NULL || IsKeyboardDevice(pDev) ||
        (!IsMaster(pDev) && !IsFloating(pDev))) /* no attached devices */
    {
        client->errorValue = stuff->deviceid;
        return BadDevice;
    }

    rc = dixLookupWindow(&pWin, stuff->win, client, DixGetAttrAccess);
    if (rc != Success)
    {
        SendErrorToClient(client, IReqCode, X_XIQueryPointer,
                stuff->win, rc);
        return Success;
    }

    if (pDev->valuator->motionHintWindow)
        MaybeStopHint(pDev, client);

    if (IsMaster(pDev))
        kbd = GetPairedDevice(pDev);
    else
        kbd = (pDev->key) ? pDev : NULL;

    pSprite = pDev->spriteInfo->sprite;

    memset(&rep, 0, sizeof(rep));
    rep.repType = X_Reply;
    rep.RepType = X_XIQueryPointer;
    rep.length = 6;
    rep.sequenceNumber = client->sequence;
    rep.root = (GetCurrentRootWindow(pDev))->drawable.id;
    rep.root_x = FP1616(pSprite->hot.x, 0);
    rep.root_y = FP1616(pSprite->hot.y, 0);
    rep.child = None;

    if (kbd)
    {
        state = &kbd->key->xkbInfo->state;
        rep.mods.base_mods = state->base_mods;
        rep.mods.latched_mods = state->latched_mods;
        rep.mods.locked_mods = state->locked_mods;

        rep.group.base_group = state->base_group;
        rep.group.latched_group = state->latched_group;
        rep.group.locked_group = state->locked_group;
    }

    if (pDev->button)
    {
        int i, down;
        rep.buttons_len = bytes_to_int32(bits_to_bytes(pDev->button->numButtons));
        rep.length += rep.buttons_len;
        buttons_size = rep.buttons_len * 4;
        buttons = calloc(1, buttons_size);
        if (!buttons)
            return BadAlloc;

        down = pDev->button->buttonsDown;

        for (i = 0; i < pDev->button->numButtons && down; i++)
        {
            if (BitIsOn(pDev->button->down, i))
            {
                SetBit(buttons, i);
                down--;
            }
        }
    } else
        rep.buttons_len = 0;

    if (pSprite->hot.pScreen == pWin->drawable.pScreen)
    {
        rep.same_screen = xTrue;
        rep.win_x = FP1616(pSprite->hot.x - pWin->drawable.x, 0);
        rep.win_y = FP1616(pSprite->hot.y - pWin->drawable.y, 0);
        for (t = pSprite->win; t; t = t->parent)
            if (t->parent == pWin)
            {
                rep.child = t->drawable.id;
                break;
            }
    } else
    {
        rep.same_screen = xFalse;
        rep.win_x = 0;
        rep.win_y = 0;
    }

#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
        rep.root_x += FP1616(screenInfo.screens[0]->x, 0);
        rep.root_y += FP1616(screenInfo.screens[0]->y, 0);
        if (stuff->win == rep.root)
        {
            rep.win_x += FP1616(screenInfo.screens[0]->x, 0);
            rep.win_y += FP1616(screenInfo.screens[0]->y, 0);
        }
    }
#endif

    WriteReplyToClient(client, sizeof(xXIQueryPointerReply), &rep);
    if (buttons)
        WriteToClient(client, buttons_size, buttons);

    free(buttons);

    return Success;
}

/***********************************************************************
 *
 * This procedure writes the reply for the XIQueryPointer function,
 * if the client and server have a different byte ordering.
 *
 */

void
SRepXIQueryPointer(ClientPtr client, int size,
                   xXIQueryPointerReply * rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->root, n);
    swapl(&rep->child, n);
    swapl(&rep->root_x, n);
    swapl(&rep->root_y, n);
    swapl(&rep->win_x, n);
    swapl(&rep->win_y, n);
    swaps(&rep->buttons_len, n);

    WriteToClient(client, size, (char *)rep);
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef QUERYDP_H
#define QUERYDP_H 1

int SProcXIQueryPointer(ClientPtr /* client */);
int ProcXIQueryPointer(ClientPtr /* client */);
void SRepXIQueryPointer(ClientPtr /* client */ ,
			int /* size */ ,
			xXIQueryPointerReply *	/* rep */);

#endif /* QUERYDP_H */
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

/**
 * @file xiqueryversion.c
 * Protocol handling for the XIQueryVersion request/reply.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif


#include "inputstr.h"

#include <X11/Xmd.h>
#include <X11/X.h>
#include <X11/extensions/XI2proto.h>

#include "exglobals.h"
#include "exevents.h"
#include "xiqueryversion.h"
#include "misc.h"

extern XExtensionVersion XIVersion; /* defined in getvers.c */
/**
 * Return the supported XI version.
 *
 * Saves the version the client claims to support as well, for future
 * reference.
 */
int
ProcXIQueryVersion(ClientPtr client)
{
    xXIQueryVersionReply rep;
    XIClientPtr pXIClient;
    int major, minor;

    REQUEST(xXIQueryVersionReq);
    REQUEST_SIZE_MATCH(xXIQueryVersionReq);

    /* This request only exists after XI2 */
    if (stuff->major_version < 2)
    {
        client->errorValue = stuff->major_version;
        return BadValue;
    }

    pXIClient = dixLookupPrivate(&client->devPrivates, XIClientPrivateKey);

    if (version_compare(XIVersion.major_version, XIVersion.minor_version,
                        stuff->major_version, stuff->minor_version) > 0)
    {
        major = stuff->major_version;
        minor = stuff->minor_version;
    } else
    {
        major = XIVersion.major_version;
        minor = XIVersion.minor_version;
    }

    pXIClient->major_version = major;
    pXIClient->minor_version = minor;

    memset(&rep, 0, sizeof(xXIQueryVersionReply));
    rep.repType = X_Reply;
    rep.RepType = X_XIQueryVersion;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.major_version = major;
    rep.minor_version = minor;

    WriteReplyToClient(client, sizeof(xXIQueryVersionReply), &rep);

    return Success;
}

/* Swapping routines */

int
SProcXIQueryVersion(ClientPtr client)
{
    char n;

    REQUEST(xXIQueryVersionReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXIQueryVersionReq);
    swaps(&stuff->major_version, n);
    swaps(&stuff->minor_version, n);
    return (ProcXIQueryVersion(client));
}

void
SRepXIQueryVersion(ClientPtr client, int size, xXIQueryVersionReply *rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->major_version, n);
    swaps(&rep->minor_version, n);
    WriteToClient(client, size, (char *)rep);
}
/*
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/extensions/XI2proto.h>

#ifndef QUERYVERSION_H
#define QUERYVERSION_H 1

int SProcXIQueryVersion(ClientPtr client);
int ProcXIQueryVersion(ClientPtr client);
void SRepXIQueryVersion(ClientPtr client, int size, xXIQueryVersionReply* rep);

#endif /* QUERYVERSION_H */
/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif


#include "dixstruct.h"
#include "windowstr.h"
#include "exglobals.h"
#include "exevents.h"
#include <X11/extensions/XI2proto.h>

#include "xiselectev.h"

/**
 * Check the given mask (in len bytes) for invalid mask bits.
 * Invalid mask bits are any bits above XI2LastEvent.
 *
 * @return BadValue if at least one invalid bit is set or Success otherwise.
 */
int XICheckInvalidMaskBits(ClientPtr client, unsigned char *mask, int len)
{
    if (len >= XIMaskLen(XI2LASTEVENT))
    {
        int i;
        for (i = XI2LASTEVENT + 1; i < len * 8; i++)
        {
            if (BitIsOn(mask, i))
            {
                client->errorValue = i;
                return BadValue;
            }
        }
    }

    return Success;
}

int
SProcXISelectEvents(ClientPtr client)
{
    char n;
    int i;
    xXIEventMask* evmask;

    REQUEST(xXISelectEventsReq);
    swaps(&stuff->length, n);
    REQUEST_AT_LEAST_SIZE(xXISelectEventsReq);
    swapl(&stuff->win, n);
    swaps(&stuff->num_masks, n);

    evmask = (xXIEventMask*)&stuff[1];
    for (i = 0; i < stuff->num_masks; i++)
    {
        swaps(&evmask->deviceid, n);
        swaps(&evmask->mask_len, n);
        evmask = (xXIEventMask*)(((char*)&evmask[1]) + evmask->mask_len * 4);
    }

    return (ProcXISelectEvents(client));
}

int
ProcXISelectEvents(ClientPtr client)
{
    int rc, num_masks;
    WindowPtr win;
    DeviceIntPtr dev;
    DeviceIntRec dummy;
    xXIEventMask *evmask;
    int *types = NULL;
    int len;

    REQUEST(xXISelectEventsReq);
    REQUEST_AT_LEAST_SIZE(xXISelectEventsReq);

    if (stuff->num_masks == 0)
        return BadValue;

    rc = dixLookupWindow(&win, stuff->win, client, DixReceiveAccess);
    if (rc != Success)
        return rc;

    len = sz_xXISelectEventsReq;

    /* check request validity */
    evmask = (xXIEventMask*)&stuff[1];
    num_masks = stuff->num_masks;
    while(num_masks--)
    {
        len += sizeof(xXIEventMask) + evmask->mask_len * 4;

        if (bytes_to_int32(len) > stuff->length)
            return BadLength;

        if (evmask->deviceid != XIAllDevices &&
            evmask->deviceid != XIAllMasterDevices)
            rc = dixLookupDevice(&dev, evmask->deviceid, client, DixUseAccess);
        else {
            /* XXX: XACE here? */
        }
        if (rc != Success)
            return rc;

        /* hierarchy event mask is not allowed on devices */
        if (evmask->deviceid != XIAllDevices && evmask->mask_len >= 1)
        {
            unsigned char *bits = (unsigned char*)&evmask[1];
            if (BitIsOn(bits, XI_HierarchyChanged))
            {
                client->errorValue = XI_HierarchyChanged;
                return BadValue;
            }
        }

        /* Raw events may only be selected on root windows */
        if (win->parent && evmask->mask_len >= 1)
        {
            unsigned char *bits = (unsigned char*)&evmask[1];
            if (BitIsOn(bits, XI_RawKeyPress) ||
                BitIsOn(bits, XI_RawKeyRelease) ||
                BitIsOn(bits, XI_RawButtonPress) ||
                BitIsOn(bits, XI_RawButtonRelease) ||
                BitIsOn(bits, XI_RawMotion))
            {
                client->errorValue = XI_RawKeyPress;
                return BadValue;
            }
        }

        if (XICheckInvalidMaskBits(client, (unsigned char*)&evmask[1],
                                   evmask->mask_len * 4) != Success)
            return BadValue;

        evmask = (xXIEventMask*)(((unsigned char*)evmask) + evmask->mask_len * 4);
        evmask++;
    }

    if (bytes_to_int32(len) != stuff->length)
        return BadLength;

    /* Set masks on window */
    evmask = (xXIEventMask*)&stuff[1];
    num_masks = stuff->num_masks;
    while(num_masks--)
    {
        if (evmask->deviceid == XIAllDevices ||
            evmask->deviceid == XIAllMasterDevices)
        {
            dummy.id = evmask->deviceid;
            dev = &dummy;
        } else
            dixLookupDevice(&dev, evmask->deviceid, client, DixUseAccess);
        if (XISetEventMask(dev, win, client, evmask->mask_len * 4,
                           (unsigned char*)&evmask[1]) != Success)
            return BadAlloc;
        evmask = (xXIEventMask*)(((unsigned char*)evmask) + evmask->mask_len * 4);
        evmask++;
    }

    RecalculateDeliverableEvents(win);

    free(types);
    return Success;
}


int
SProcXIGetSelectedEvents(ClientPtr client)
{
    char n;

    REQUEST(xXIGetSelectedEventsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXIGetSelectedEventsReq);
    swapl(&stuff->win, n);

    return (ProcXIGetSelectedEvents(client));
}

int
ProcXIGetSelectedEvents(ClientPtr client)
{
    int rc, i;
    WindowPtr win;
    char n;
    char *buffer = NULL;
    xXIGetSelectedEventsReply reply;
    OtherInputMasks *masks;
    InputClientsPtr others = NULL;
    xXIEventMask *evmask = NULL;
    DeviceIntPtr dev;

    REQUEST(xXIGetSelectedEventsReq);
    REQUEST_SIZE_MATCH(xXIGetSelectedEventsReq);

    rc = dixLookupWindow(&win, stuff->win, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    reply.repType = X_Reply;
    reply.RepType = X_XIGetSelectedEvents;
    reply.length = 0;
    reply.sequenceNumber = client->sequence;
    reply.num_masks = 0;

    masks = wOtherInputMasks(win);
    if (masks)
    {
	for (others = wOtherInputMasks(win)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
                break;
            }
        }
    }

    if (!others)
    {
        WriteReplyToClient(client, sizeof(xXIGetSelectedEventsReply), &reply);
        return Success;
    }

    buffer = calloc(MAXDEVICES, sizeof(xXIEventMask) + pad_to_int32(XI2MASKSIZE));
    if (!buffer)
        return BadAlloc;

    evmask = (xXIEventMask*)buffer;
    for (i = 0; i < MAXDEVICES; i++)
    {
        int j;
        unsigned char *devmask = others->xi2mask[i];

        if (i > 2)
        {
            rc = dixLookupDevice(&dev, i, client, DixGetAttrAccess);
            if (rc != Success)
                continue;
        }


        for (j = XI2MASKSIZE - 1; j >= 0; j--)
        {
            if (devmask[j] != 0)
            {
                int mask_len = (j + 4)/4; /* j is an index, hence + 4, not + 3 */
                evmask->deviceid = i;
                evmask->mask_len = mask_len;
                reply.num_masks++;
                reply.length += sizeof(xXIEventMask)/4 + evmask->mask_len;

                if (client->swapped)
                {
                    swaps(&evmask->deviceid, n);
                    swaps(&evmask->mask_len, n);
                }

                memcpy(&evmask[1], devmask, j + 1);
                evmask = (xXIEventMask*)((char*)evmask +
                           sizeof(xXIEventMask) + mask_len * 4);
                break;
            }
        }
    }

    WriteReplyToClient(client, sizeof(xXIGetSelectedEventsReply), &reply);

    if (reply.num_masks)
        WriteToClient(client, reply.length * 4, buffer);

    free(buffer);
    return Success;
}

void SRepXIGetSelectedEvents(ClientPtr client,
                            int len, xXIGetSelectedEventsReply *rep)
{
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_masks, n);
    WriteToClient(client, len, (char *)rep);
}


/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XISELECTEVENTS_H
#define XISELECTEVENTS_H 1

int SProcXISelectEvents(ClientPtr client);
int ProcXISelectEvents(ClientPtr client);
int SProcXIGetSelectedEvents(ClientPtr client);
int ProcXIGetSelectedEvents(ClientPtr client);
void SRepXIGetSelectedEvents(ClientPtr client,
                             int len, xXIGetSelectedEventsReply *rep);

#endif /* _XISELECTEVENTS_H_ */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request to set the client pointer for the owner of the given window.
 * All subsequent calls that are ambiguous will choose the client pointer as
 * default value.
 */


#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"

#include "xisetclientpointer.h"

int
SProcXISetClientPointer(ClientPtr client)
{
    char n;

    REQUEST(xXISetClientPointerReq);
    swaps(&stuff->length, n);
    swapl(&stuff->win, n);
    swaps(&stuff->deviceid, n);
    REQUEST_SIZE_MATCH(xXISetClientPointerReq);
    return (ProcXISetClientPointer(client));
}

int
ProcXISetClientPointer(ClientPtr client)
{
    DeviceIntPtr pDev;
    ClientPtr targetClient;
    int rc;

    REQUEST(xXISetClientPointerReq);
    REQUEST_SIZE_MATCH(xXISetClientPointerReq);


    rc = dixLookupDevice(&pDev, stuff->deviceid, client, DixManageAccess);
    if (rc != Success)
    {
        client->errorValue = stuff->deviceid;
        return rc;
    }

    if (!IsMaster(pDev))
    {
        client->errorValue = stuff->deviceid;
        return BadDevice;
    }

    pDev = GetMaster(pDev, MASTER_POINTER);

    if (stuff->win != None)
    {
        rc = dixLookupClient(&targetClient, stuff->win, client,
                DixManageAccess);

        if (rc != Success)
            return BadWindow;

    } else
        targetClient = client;

    rc = SetClientPointer(targetClient, pDev);
    if (rc != Success)
    {
        client->errorValue = stuff->deviceid;
        return rc;
    }

    return Success;
}
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef SETCPTR_H
#define SETCPTR_H 1

int SProcXISetClientPointer(ClientPtr /* client */);
int ProcXISetClientPointer(ClientPtr /* client */);

#endif /* SETCPTR_H */
/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */
/***********************************************************************
 *
 * Request to set and get an input device's focus.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include <X11/extensions/XI2.h>
#include <X11/extensions/XI2proto.h>

#include "exglobals.h" /* BadDevice */
#include "xisetdevfocus.h"

int
SProcXISetFocus(ClientPtr client)
{
    char n;

    REQUEST(xXISetFocusReq);
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->focus, n);
    swapl(&stuff->time, n);

    return ProcXISetFocus(client);
}

int
SProcXIGetFocus(ClientPtr client)
{
    char n;

    REQUEST(xXIGetFocusReq);
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);

    return ProcXIGetFocus(client);
}

int
ProcXISetFocus(ClientPtr client)
{
    DeviceIntPtr dev;
    int ret;

    REQUEST(xXISetFocusReq);
    REQUEST_AT_LEAST_SIZE(xXISetFocusReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixSetFocusAccess);
    if (ret != Success)
	return ret;
    if (!dev->focus)
	return BadDevice;

    return SetInputFocus(client, dev, stuff->focus, RevertToParent,
                        stuff->time, TRUE);
}

int
ProcXIGetFocus(ClientPtr client)
{
    xXIGetFocusReply rep;
    DeviceIntPtr dev;
    int ret;

    REQUEST(xXIGetFocusReq);
    REQUEST_AT_LEAST_SIZE(xXIGetFocusReq);

    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixGetFocusAccess);
    if (ret != Success)
	return ret;
    if (!dev->focus)
	return BadDevice;

    rep.repType = X_Reply;
    rep.RepType = X_XIGetFocus;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (dev->focus->win == NoneWin)
	rep.focus = None;
    else if (dev->focus->win == PointerRootWin)
	rep.focus = PointerRoot;
    else if (dev->focus->win == FollowKeyboardWin)
	rep.focus = FollowKeyboard;
    else
	rep.focus = dev->focus->win->drawable.id;

    WriteReplyToClient(client, sizeof(xXIGetFocusReply), &rep);
    return Success;
}

void
SRepXIGetFocus(ClientPtr client, int len, xXIGetFocusReply *rep)
{
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->focus, n);
    WriteToClient(client, len, (char *)rep);
}
/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef XISETDEVFOCUS_H
#define XISETDEVFOCUS_H 1

int SProcXISetFocus(ClientPtr client);
int ProcXISetFocus(ClientPtr client);

int SProcXIGetFocus(ClientPtr client);
int ProcXIGetFocus(ClientPtr client);

void SRepXIGetFocus(ClientPtr client, int len, xXIGetFocusReply* rep);
#endif /* XISETDEVFOCUS_H */
/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request to Warp the pointer location of an extension input device.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "mipointer.h" /* for miPointerUpdateSprite */


#include "xiwarppointer.h"
/***********************************************************************
 *
 * This procedure allows a client to warp the pointer of a device.
 *
 */

int
SProcXIWarpPointer(ClientPtr client)
{
    char n;

    REQUEST(xXIWarpPointerReq);
    swaps(&stuff->length, n);
    swapl(&stuff->src_win, n);
    swapl(&stuff->dst_win, n);
    swapl(&stuff->src_x, n);
    swapl(&stuff->src_y, n);
    swaps(&stuff->src_width, n);
    swaps(&stuff->src_height, n);
    swapl(&stuff->dst_x, n);
    swapl(&stuff->dst_y, n);
    swaps(&stuff->deviceid, n);
    return (ProcXIWarpPointer(client));
}

int
ProcXIWarpPointer(ClientPtr client)
{
    int rc;
    int x, y;
    WindowPtr dest = NULL;
    DeviceIntPtr pDev;
    SpritePtr pSprite;
    ScreenPtr newScreen;
    int src_x, src_y;
    int dst_x, dst_y;

    REQUEST(xXIWarpPointerReq);
    REQUEST_SIZE_MATCH(xXIWarpPointerReq);

    /* FIXME: panoramix stuff is missing, look at ProcWarpPointer */

    rc = dixLookupDevice(&pDev, stuff->deviceid, client, DixWriteAccess);

    if (rc != Success)
    {
        client->errorValue = stuff->deviceid;
        return rc;
    }

    if ((!IsMaster(pDev) && !IsFloating(pDev)) ||
        (IsMaster(pDev) && !IsPointerDevice(pDev)))
    {
        client->errorValue = stuff->deviceid;
        return BadDevice;
    }

    if (stuff->dst_win != None)
    {
        rc = dixLookupWindow(&dest, stuff->dst_win, client, DixGetAttrAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->dst_win;
            return rc;
        }
    }

    pSprite = pDev->spriteInfo->sprite;
    x = pSprite->hotPhys.x;
    y = pSprite->hotPhys.y;

    src_x = stuff->src_x / (double)(1 << 16);
    src_y = stuff->src_y / (double)(1 << 16);
    dst_x = stuff->dst_x / (double)(1 << 16);
    dst_y = stuff->dst_y / (double)(1 << 16);

    if (stuff->src_win != None)
    {
        int winX, winY;
        WindowPtr src;

        rc = dixLookupWindow(&src, stuff->src_win, client, DixGetAttrAccess);
        if (rc != Success)
        {
            client->errorValue = stuff->src_win;
            return rc;
        }

        winX = src->drawable.x;
        winY = src->drawable.y;
        if (src->drawable.pScreen != pSprite->hotPhys.pScreen ||
                x < winX + src_x ||
                y < winY + src_y ||
                (stuff->src_width != 0 &&
                 winX + src_x + (int)stuff->src_width < 0) ||
                (stuff->src_height != 0 &&
                 winY + src_y + (int)stuff->src_height < y) ||
                !PointInWindowIsVisible(src, x, y))
            return Success;
    }

    if (dest)
    {
        x = dest->drawable.x;
        y = dest->drawable.y;
        newScreen = dest->drawable.pScreen;
    } else
        newScreen = pSprite->hotPhys.pScreen;

    x += dst_x;
    y += dst_y;

    if (x < 0)
        x = 0;
    else if (x > newScreen->width)
        x = newScreen->width - 1;

    if (y < 0)
        y = 0;
    else if (y > newScreen->height)
        y = newScreen->height - 1;

    if (newScreen == pSprite->hotPhys.pScreen)
    {
        if (x < pSprite->physLimits.x1)
            x = pSprite->physLimits.x1;
        else if (x >= pSprite->physLimits.x2)
            x = pSprite->physLimits.x2 - 1;

        if (y < pSprite->physLimits.y1)
            y = pSprite->physLimits.y1;
        else if (y >= pSprite->physLimits.y2)
            y = pSprite->physLimits.y2 - 1;

        if (pSprite->hotShape)
            ConfineToShape(pDev, pSprite->hotShape, &x, &y);
        (*newScreen->SetCursorPosition)(pDev, newScreen, x, y, TRUE);
    } else if (!PointerConfinedToScreen(pDev))
    {
        NewCurrentScreen(pDev, newScreen, x, y);
    }

    /* if we don't update the device, we get a jump next time it moves */
    pDev->last.valuators[0] = x;
    pDev->last.valuators[1] = y;
    pDev->last.remainder[0] = 0;
    pDev->last.remainder[1] = 0;
    miPointerUpdateSprite(pDev);

    /* FIXME: XWarpPointer is supposed to generate an event. It doesn't do it
       here though. */
    return Success;
}

/*
 * Copyright 2007-2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef WARPDEVP_H
#define WARPDEVP_H 1

int SProcXIWarpPointer(ClientPtr /* client */);
int ProcXIWarpPointer(ClientPtr	/* client */);

#endif /* WARPDEVP_H */
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include <X11/extensions/XI.h>

/*#define FALLING_TONE	1*/
/*#define RISING_TONE	1*/
#define FALLING_TONE	10
#define RISING_TONE	10
#define	SHORT_TONE	50
#define	SHORT_DELAY	60
#define	LONG_TONE	75
#define	VERY_LONG_TONE	100
#define	LONG_DELAY	85
#define CLICK_DURATION	1

#define	DEEP_PITCH	250
#define	LOW_PITCH	500
#define	MID_PITCH	1000
#define	HIGH_PITCH	2000
#define CLICK_PITCH	1500

static	unsigned long	atomGeneration= 0;
static	Atom	featureOn;
static	Atom	featureOff;
static	Atom	featureChange;
static	Atom	ledOn;
static	Atom	ledOff;
static	Atom	ledChange;
static	Atom	slowWarn;
static	Atom	slowPress;
static	Atom	slowReject;
static	Atom	slowAccept;
static	Atom	slowRelease;
static	Atom	stickyLatch;
static	Atom	stickyLock;
static	Atom	stickyUnlock;
static	Atom	bounceReject;
static  char 	doesPitch = 1;

#define	FEATURE_ON	"AX_FeatureOn"
#define	FEATURE_OFF	"AX_FeatureOff"
#define	FEATURE_CHANGE	"AX_FeatureChange"
#define	LED_ON		"AX_IndicatorOn"
#define	LED_OFF		"AX_IndicatorOff"
#define	LED_CHANGE	"AX_IndicatorChange"
#define	SLOW_WARN	"AX_SlowKeysWarning"
#define	SLOW_PRESS	"AX_SlowKeyPress"
#define	SLOW_REJECT	"AX_SlowKeyReject"
#define	SLOW_ACCEPT	"AX_SlowKeyAccept"
#define	SLOW_RELEASE	"AX_SlowKeyRelease"
#define	STICKY_LATCH	"AX_StickyLatch"
#define	STICKY_LOCK	"AX_StickyLock"
#define	STICKY_UNLOCK	"AX_StickyUnlock"
#define	BOUNCE_REJECT	"AX_BounceKeyReject"

#define	MAKE_ATOM(a)	MakeAtom(a,sizeof(a)-1,TRUE)

static void
_XkbDDXBeepInitAtoms(void)
{
    featureOn= 		MAKE_ATOM(FEATURE_ON);
    featureOff= 	MAKE_ATOM(FEATURE_OFF);
    featureChange= 	MAKE_ATOM(FEATURE_CHANGE);
    ledOn= 		MAKE_ATOM(LED_ON);
    ledOff= 		MAKE_ATOM(LED_OFF);
    ledChange= 		MAKE_ATOM(LED_CHANGE);
    slowWarn= 		MAKE_ATOM(SLOW_WARN);
    slowPress= 		MAKE_ATOM(SLOW_PRESS);
    slowReject= 	MAKE_ATOM(SLOW_REJECT);
    slowAccept= 	MAKE_ATOM(SLOW_ACCEPT);
    slowRelease= 	MAKE_ATOM(SLOW_RELEASE);
    stickyLatch= 	MAKE_ATOM(STICKY_LATCH);
    stickyLock=		MAKE_ATOM(STICKY_LOCK);
    stickyUnlock= 	MAKE_ATOM(STICKY_UNLOCK);
    bounceReject= 	MAKE_ATOM(BOUNCE_REJECT);
    return;
}

static CARD32
_XkbDDXBeepExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
DeviceIntPtr	dev= (DeviceIntPtr)arg;
KbdFeedbackPtr	feed;
KeybdCtrl *	ctrl;
XkbSrvInfoPtr	xkbInfo;
CARD32		next;
int		pitch,duration;
int		oldPitch,oldDuration;
Atom		name;

    if ((dev==NULL)||(dev->key==NULL)||(dev->key->xkbInfo==NULL)||
	(dev->kbdfeed==NULL))
	return 0;
    if (atomGeneration!=serverGeneration) {
	_XkbDDXBeepInitAtoms();
	atomGeneration= serverGeneration;
    }

    feed= dev->kbdfeed;
    ctrl= &feed->ctrl;
    xkbInfo= dev->key->xkbInfo;
    next= 0;
    pitch= oldPitch= ctrl->bell_pitch;
    duration= oldDuration= ctrl->bell_duration;
    name= None;
    switch (xkbInfo->beepType) {
	default:
	    ErrorF("[xkb] Unknown beep type %d\n",xkbInfo->beepType);
	case _BEEP_NONE:
	    duration= 0;
	    break;

	/* When an LED is turned on, we want a high-pitched beep.
	 * When the LED it turned off, we want a low-pitched beep.
	 * If we cannot do pitch, we want a single beep for on and two
	 * beeps for off.
         */
	case _BEEP_LED_ON:
	    if (name==None)	name= ledOn;
	    duration= SHORT_TONE;
	    pitch= HIGH_PITCH;
	    break;
	case _BEEP_LED_OFF:
	    if (name==None)	name= ledOff;
	    duration= SHORT_TONE;
	    pitch= LOW_PITCH;
	    if (!doesPitch && xkbInfo->beepCount<1)
		next = SHORT_DELAY;	    
	    break;

	/* When a Feature is turned on, we want an up-siren.
	 * When a Feature is turned off, we want a down-siren.
	 * If we cannot do pitch, we want a single beep for on and two
	 * beeps for off.
         */
	case _BEEP_FEATURE_ON:
	    if (name==None)	name= featureOn;
	    if (xkbInfo->beepCount<1) {
		pitch= LOW_PITCH;
		duration= VERY_LONG_TONE;
		if (doesPitch)
		    next= SHORT_DELAY;
	    }
	    else {
		pitch= MID_PITCH;
		duration= SHORT_TONE;
	    }
	    break;

	case _BEEP_FEATURE_OFF:
	    if (name==None)	name= featureOff;
	    if (xkbInfo->beepCount<1) {
		pitch= MID_PITCH;
		if (doesPitch)
		     duration= VERY_LONG_TONE;
		else duration= SHORT_TONE;
		next= SHORT_DELAY;
	    }
	    else {
		pitch= LOW_PITCH;
		duration= SHORT_TONE;
	    }
	    break;

	/* Two high beeps indicate an LED or Feature changed
	 * state, but that another LED or Feature is also on.
	 * [[[WDW - This is not in AccessDOS ]]]
	 */
	case _BEEP_LED_CHANGE:
            if (name==None)	name= ledChange;
	case _BEEP_FEATURE_CHANGE:
	    if (name==None)	name= featureChange;
	    duration= SHORT_TONE;
	    pitch= HIGH_PITCH;
	    if (xkbInfo->beepCount<1) {
		next= SHORT_DELAY;
	    }
            break;

	/* Three high-pitched beeps are the warning that SlowKeys
	 * is going to be turned on or off.
	 */	  
	case _BEEP_SLOW_WARN:
	    if (name==None)	name= slowWarn;
	    duration= SHORT_TONE;
	    pitch= HIGH_PITCH;
	    if (xkbInfo->beepCount<2)
		next= SHORT_DELAY;
	    break;

	/* Click on SlowKeys press and accept.
	 * Deep pitch when a SlowKey or BounceKey is rejected.
	 * [[[WDW - Rejects are not in AccessDOS ]]]
	 * If we cannot do pitch, we want single beeps.
	 */	  
        case _BEEP_SLOW_PRESS:
	    if (name==None)	name= slowPress;
	case _BEEP_SLOW_ACCEPT:
	    if (name==None)	name= slowAccept;
	case _BEEP_SLOW_RELEASE:
	    if (name==None)	name= slowRelease;
	    duration= CLICK_DURATION;
	    pitch= CLICK_PITCH;
	    break;
	case _BEEP_BOUNCE_REJECT:
	    if (name==None)	name= bounceReject;
	case _BEEP_SLOW_REJECT:
	    if (name==None)	name= slowReject;
	    duration= SHORT_TONE;
	    pitch= DEEP_PITCH;
	    break;

	/* Low followed by high pitch when a StickyKey is latched.
	 * High pitch when a StickyKey is locked.
	 * Low pitch when unlocked.
         * If we cannot do pitch, two beeps for latch, nothing for
	 * lock, and two for unlock.
	 */	  
	case _BEEP_STICKY_LATCH:
	    if (name==None)	name= stickyLatch;
	    duration= SHORT_TONE;
	    if (xkbInfo->beepCount<1) {
		next= SHORT_DELAY;
		pitch= LOW_PITCH;
	    }
	    else pitch= HIGH_PITCH;
	    break;
	case _BEEP_STICKY_LOCK:
	    if (name==None)	name= stickyLock;
	    if (doesPitch) {
		duration= SHORT_TONE;
		pitch= HIGH_PITCH;
            }
	    break;
	case _BEEP_STICKY_UNLOCK:
	    if (name==None)	name= stickyUnlock;
	    duration= SHORT_TONE;
	    pitch= LOW_PITCH;
	    if (!doesPitch && xkbInfo->beepCount<1)
		next = SHORT_DELAY;	    
	    break;
    }
    if (timer == NULL && duration>0) {
	CARD32		starttime = GetTimeInMillis();
	CARD32		elapsedtime;

	ctrl->bell_duration= duration;
	ctrl->bell_pitch= pitch;
	if (xkbInfo->beepCount==0) {
	     XkbHandleBell(0,0,dev,ctrl->bell,(pointer)ctrl,KbdFeedbackClass,name,None,
									NULL);
	}
	else if (xkbInfo->desc->ctrls->enabled_ctrls&XkbAudibleBellMask) {
	    (*dev->kbdfeed->BellProc)(ctrl->bell,dev,(pointer)ctrl,KbdFeedbackClass);
	}
	ctrl->bell_duration= oldDuration;
	ctrl->bell_pitch= oldPitch;
	xkbInfo->beepCount++;

	/* Some DDX schedule the beep and return immediately, others don't
	   return until the beep is completed.  We measure the time and if
	   it's less than the beep duration, make sure not to schedule the
	   next beep until after the current one finishes. */

	elapsedtime = GetTimeInMillis();
	if (elapsedtime > starttime) { /* watch out for millisecond counter
					  overflow! */
	    elapsedtime -= starttime;
	} else {
	    elapsedtime = 0;
	}
	if (elapsedtime < duration) {
	    next += duration - elapsedtime;
	}

    }
    return next;
}

int
XkbDDXAccessXBeep(DeviceIntPtr dev,unsigned what,unsigned which)
{
XkbSrvInfoRec	*xkbInfo= dev->key->xkbInfo;
CARD32		 next;

    xkbInfo->beepType= what;
    xkbInfo->beepCount= 0;
    next= _XkbDDXBeepExpire(NULL,0,(pointer)dev);
    if (next>0) {
	xkbInfo->beepTimer= TimerSet(xkbInfo->beepTimer,
					0, next,
					_XkbDDXBeepExpire, (pointer)dev);
    }
    return 1;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include <X11/extensions/XI.h>

void
XkbDDXKeybdCtrlProc(DeviceIntPtr dev,KeybdCtrl *ctrl)
{
int realRepeat;

    realRepeat= ctrl->autoRepeat;
    if ((dev->kbdfeed)&&(XkbDDXUsesSoftRepeat(dev)))
	ctrl->autoRepeat= 0;
    if (dev->key && dev->key->xkbInfo && dev->key->xkbInfo->kbdProc)
	(*dev->key->xkbInfo->kbdProc)(dev,ctrl);
    ctrl->autoRepeat= realRepeat;
    return;
}


int
XkbDDXUsesSoftRepeat(DeviceIntPtr pXDev)
{
    return 1;
}

void
XkbDDXChangeControls(DeviceIntPtr dev,XkbControlsPtr old,XkbControlsPtr new)
{
unsigned	changed, i;
unsigned 	char *rep_old, *rep_new, *rep_fb;

    changed= new->enabled_ctrls^old->enabled_ctrls;
    for (rep_old = old->per_key_repeat,
         rep_new = new->per_key_repeat,
	 rep_fb  = dev->kbdfeed->ctrl.autoRepeats,
         i = 0; i < XkbPerKeyBitArraySize; i++) {
        if (rep_old[i] != rep_new[i]) {
            rep_fb[i] = rep_new[i];
            changed &= XkbPerKeyRepeatMask;
        }
    }

    if (changed&XkbPerKeyRepeatMask) {
	if (dev->kbdfeed->CtrlProc)
	    (*dev->kbdfeed->CtrlProc)(dev,&dev->kbdfeed->ctrl);
    }
    return;
}

/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>

int
XkbDDXTerminateServer(DeviceIntPtr dev,KeyCode key,XkbAction *act)
{
    if (dev != inputInfo.keyboard)
        GiveUp(1);

    return 0;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include <X11/extensions/XI.h>

static void
XkbDDXUpdateIndicators(DeviceIntPtr dev,CARD32 new)
{
    dev->kbdfeed->ctrl.leds= new;
    (*dev->kbdfeed->CtrlProc)(dev,&dev->kbdfeed->ctrl);
    return;
}

void
XkbDDXUpdateDeviceIndicators(	DeviceIntPtr		dev,
				XkbSrvLedInfoPtr 	sli,
				CARD32 			new)
{
    if (sli->fb.kf==dev->kbdfeed)
	XkbDDXUpdateIndicators(dev,new);
    else if (sli->class==KbdFeedbackClass) {
	KbdFeedbackPtr	kf;
	kf= sli->fb.kf;
	if (kf && kf->CtrlProc) {
	    (*kf->CtrlProc)(dev,&kf->ctrl);
	}
    }
    else if (sli->class==LedFeedbackClass) {
	LedFeedbackPtr	lf;
	lf= sli->fb.lf;
	if (lf && lf->CtrlProc) {
	    (*lf->CtrlProc)(dev,&lf->ctrl);
	}
    }
    return;
}
/************************************************************
Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XKM.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include <X11/extensions/XI.h>

#ifdef WIN32
/* from ddxLoad.c */
extern const char* Win32TempDir();
extern int Win32System(const char *cmdline);
#undef System
#define System Win32System

#define W32_tmparg " '%s'"
#define W32_tmpfile ,tmpname
#define W32_tmplen strlen(tmpname)+3
#else
#define W32_tmparg
#define W32_tmpfile 
#define W32_tmplen 0
#endif 

/***====================================================================***/

static char *componentDirs[_XkbListNumComponents] = {
	"keycodes", "types", "compat", "symbols", "geometry"
};

/***====================================================================***/

static Status
_AddListComponent(	XkbSrvListInfoPtr	list,
			int			what,
			unsigned		flags,
			char *			str,
			ClientPtr		client)
{
int		slen,wlen;
unsigned char *	wire8;
unsigned short *wire16;
char *		tmp;

    if (list->nTotal>=list->maxRtrn) {
	list->nTotal++;
	return Success;
    }
    tmp= strchr(str,')');
    if ((tmp==NULL)&&((tmp=strchr(str,'('))==NULL)) {
	slen= strlen(str);
	while ((slen>0) && isspace(str[slen-1])) {
	    slen--;
	}
    }
    else {
	slen= (tmp-str+1);
    }
    wlen= (((slen+1)/2)*2)+4;	/* four bytes for flags and length, pad to */
				/* 2-byte boundary */
    if ((list->szPool-list->nPool)<wlen) {
	if (wlen>1024)	list->szPool+= XkbPaddedSize(wlen*2);
	else		list->szPool+= 1024;
	list->pool= realloc(list->pool, list->szPool * sizeof(char));
	if (!list->pool)
	    return BadAlloc;
    }
    wire16= (unsigned short *)&list->pool[list->nPool];
    wire8= (unsigned char *)&wire16[2];
    wire16[0]= flags;
    wire16[1]= slen;
    memcpy(wire8,str,slen);
    if (client->swapped) {
	register int n;
	swaps(&wire16[0],n);
	swaps(&wire16[1],n);
    }
    list->nPool+= wlen;
    list->nFound[what]++;
    list->nTotal++;
    return Success;
}

/***====================================================================***/
static Status
XkbDDXListComponent(	DeviceIntPtr 		dev,
			int			what,
			XkbSrvListInfoPtr	list,
			ClientPtr		client)
{
char 	*file,*map,*tmp,*buf=NULL;
FILE 	*in;
Status	status;
int	rval;
Bool	haveDir;
#ifdef WIN32
char	tmpname[PATH_MAX];
#endif

    if ((list->pattern[what]==NULL)||(list->pattern[what][0]=='\0'))
	return Success;
    file= list->pattern[what];
    map= strrchr(file,'(');
    if (map!=NULL) {
	char *tmp;
	map++;
	tmp= strrchr(map,')');
	if ((tmp==NULL)||(tmp[1]!='\0')) {
	    /* illegal pattern.  No error, but no match */
	    return Success;
	}
    }

    in= NULL;
    haveDir= TRUE;
#ifdef WIN32
    strcpy(tmpname, Win32TempDir());
    strcat(tmpname, "\\xkb_XXXXXX");
    (void) mktemp(tmpname);
#endif
    if (XkbBaseDirectory!=NULL) {
	if ((list->pattern[what][0]=='*')&&(list->pattern[what][1]=='\0')) {
	    if (asprintf(&buf, "%s/%s.dir", XkbBaseDirectory,
			 componentDirs[what]) == -1)
		buf = NULL;
	    else
		in = fopen(buf,"r");
	}
	if (!in) {
	    haveDir= FALSE;
	    free(buf);
	    if (asprintf
		(&buf,
		 "'%s/xkbcomp' '-R%s/%s' -w %ld -l -vlfhpR '%s'" W32_tmparg,
		 XkbBinDirectory, XkbBaseDirectory, componentDirs[what],
		 (long) ((xkbDebugFlags < 2) ? 1 :
			 ((xkbDebugFlags > 10) ? 10 : xkbDebugFlags)),
		 file W32_tmpfile
		    ) == -1)
		buf = NULL;
	}
    }
    else {
	if ((list->pattern[what][0]=='*')&&(list->pattern[what][1]=='\0')) {
	    if (asprintf(&buf, "%s.dir", componentDirs[what]) == -1)
		buf = NULL;
	    else
		in = fopen(buf,"r");
	}
	if (!in) {
	    haveDir= FALSE;
	    free(buf);
	    if (asprintf
		(&buf,
		 "xkbcomp -R%s -w %ld -l -vlfhpR '%s'" W32_tmparg,
		 componentDirs[what],
		 (long)	((xkbDebugFlags < 2) ? 1 :
			 ((xkbDebugFlags > 10) ? 10 : xkbDebugFlags)),
		 file W32_tmpfile
		    ) == -1)
		buf = NULL;
	}
    }
    status= Success;
    if (!haveDir)
    {  
#ifndef WIN32
	in= Popen(buf,"r");
#else
        if (xkbDebugFlags)
            DebugF("[xkb] xkbList executes: %s\n",buf);
	if (System(buf) < 0)
	    ErrorF("[xkb] Could not invoke keymap compiler\n");
	else
	    in= fopen(tmpname, "r");
#endif
    }
    if (!in)
    {
	free(buf);
#ifdef WIN32
	unlink(tmpname);
#endif
	return BadImplementation;
    }
    list->nFound[what]= 0;
    free(buf);
    buf = malloc(PATH_MAX * sizeof(char));
    if (!buf) {
        fclose(in);
        return BadAlloc;
    }
    while ((status==Success)&&((tmp=fgets(buf,PATH_MAX,in))!=NULL)) {
	unsigned flags;
	register unsigned int i;
	if (*tmp=='#') /* comment, skip it */
	    continue;
	if (!strncmp(tmp, "Warning:", 8) || !strncmp(tmp, "        ", 8))
	    /* skip warnings too */
	    continue;
	flags= 0;
	/* each line in the listing is supposed to start with two */
	/* groups of eight characters, which specify the general  */
	/* flags and the flags that are specific to the component */
	/* if they're missing, fail with BadImplementation	  */
	for (i=0;(i<8)&&(status==Success);i++) { /* read the general flags */
	   if (isalpha(*tmp))	flags|= (1L<<i);
	   else if (*tmp!='-')	status= BadImplementation;
	   tmp++;
	}
	if (status != Success)  break;
	if (!isspace(*tmp)) {
	     status= BadImplementation;
	     break;
	}
	else tmp++;
	for (i=0;(i<8)&&(status==Success);i++) { /* read the component flags */
	   if (isalpha(*tmp))	flags|= (1L<<(i+8));
	   else if (*tmp!='-')	status= BadImplementation;
	   tmp++;
	}
	if (status != Success)  break;
	if (isspace(*tmp)) {
	    while (isspace(*tmp)) {
		tmp++;
	    }
	}
	else {
	    status= BadImplementation;
	    break;
	}
	status= _AddListComponent(list,what,flags,tmp,client);
    }
#ifndef WIN32
    if (haveDir)
	fclose(in);
    else if ((rval=Pclose(in))!=0) {
	if (xkbDebugFlags)
	    ErrorF("[xkb] xkbcomp returned exit code %d\n",rval);
    }
#else
    fclose(in);
    unlink(tmpname);
#endif
    free(buf);
    return status;
}

/***====================================================================***/

/* ARGSUSED */
Status
XkbDDXList(DeviceIntPtr	dev,XkbSrvListInfoPtr list,ClientPtr client)
{
Status	status;

    status= XkbDDXListComponent(dev,_XkbListKeycodes,list,client);
    if (status==Success)
	status= XkbDDXListComponent(dev,_XkbListTypes,list,client);
    if (status==Success)
	status= XkbDDXListComponent(dev,_XkbListCompat,list,client);
    if (status==Success)
	status= XkbDDXListComponent(dev,_XkbListSymbols,list,client);
    if (status==Success)
	status= XkbDDXListComponent(dev,_XkbListGeometry,list,client);
    return status;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <ctype.h>
#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XKM.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include <X11/extensions/XI.h>
#include "xkb.h"

	/*
	 * If XKM_OUTPUT_DIR specifies a path without a leading slash, it is
	 * relative to the top-level XKB configuration directory.
	 * Making the server write to a subdirectory of that directory
	 * requires some work in the general case (install procedure
	 * has to create links to /var or somesuch on many machines),
	 * so we just compile into /usr/tmp for now.
	 */
#ifndef XKM_OUTPUT_DIR
#define	XKM_OUTPUT_DIR	"compiled/"
#endif

#define	PRE_ERROR_MSG "\"The XKEYBOARD keymap compiler (xkbcomp) reports:\""
#define	ERROR_PREFIX	"\"> \""
#define	POST_ERROR_MSG1 "\"Errors from xkbcomp are not fatal to the X server\""
#define	POST_ERROR_MSG2 "\"End of messages from xkbcomp\""

#if defined(WIN32)
#define PATHSEPARATOR "\\"
#else
#define PATHSEPARATOR "/"
#endif

#ifdef WIN32

#include <X11/Xwindows.h>
const char* 
Win32TempDir()
{
    static char buffer[PATH_MAX];
    if (GetTempPath(sizeof(buffer), buffer))
    {
        int len;
        buffer[sizeof(buffer)-1] = 0;
        len = strlen(buffer);
        if (len > 0)
            if (buffer[len-1] == '\\')
                buffer[len-1] = 0;
        return buffer;
    }
    if (getenv("TEMP") != NULL)
        return getenv("TEMP");
    else if (getenv("TMP") != NULL)
        return getenv("TEMP");
    else
        return "/tmp";
}

int 
Win32System(const char *cmdline)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwExitCode;
    char *cmd = strdup(cmdline);

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) 
    {
	LPVOID buffer;
	if (!FormatMessage( 
		    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		    FORMAT_MESSAGE_FROM_SYSTEM | 
		    FORMAT_MESSAGE_IGNORE_INSERTS,
		    NULL,
		    GetLastError(),
		    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		    (LPTSTR) &buffer,
		    0,
		    NULL ))
	{
	    ErrorF("[xkb] Starting '%s' failed!\n", cmdline); 
	}
	else
	{
	    ErrorF("[xkb] Starting '%s' failed: %s", cmdline, (char *)buffer); 
	    LocalFree(buffer);
	}

	free(cmd);
	return -1;
    }
    /* Wait until child process exits. */
    WaitForSingleObject( pi.hProcess, INFINITE );

    GetExitCodeProcess( pi.hProcess, &dwExitCode);
    
    /* Close process and thread handles. */
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
    free(cmd);

    return dwExitCode;
}
#undef System
#define System(x) Win32System(x)
#endif

static void
OutputDirectory(
    char* outdir,
    size_t size)
{
#ifndef WIN32
    /* Can we write an xkm and then open it too? */
    if (access(XKM_OUTPUT_DIR, W_OK | X_OK) == 0 && (strlen(XKM_OUTPUT_DIR) < size))
    {
	(void) strcpy (outdir, XKM_OUTPUT_DIR);
    } else
#else
    if (strlen(Win32TempDir()) + 1 < size)
    {
	(void) strcpy(outdir, Win32TempDir());
	(void) strcat(outdir, "\\");
    } else 
#endif
    if (strlen("/tmp/") < size)
    {
	(void) strcpy (outdir, "/tmp/");
    }
}

static Bool
XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
				XkbComponentNamesPtr	names,
				unsigned		want,
				unsigned		need,
				char *			nameRtrn,
				int			nameRtrnLen)
{
    FILE *	out;
    char	*buf = NULL, keymap[PATH_MAX], xkm_output_dir[PATH_MAX];

    const char	*emptystring = "";
    char *xkbbasedirflag = NULL;
    const char	*xkbbindir = emptystring;
    const char	*xkbbindirsep = emptystring;

#ifdef WIN32
    /* WIN32 has no popen. The input must be stored in a file which is
       used as input for xkbcomp. xkbcomp does not read from stdin. */
    char tmpname[PATH_MAX];
    const char *xkmfile = tmpname;
#else
    const char *xkmfile = "-";
#endif

    snprintf(keymap, sizeof(keymap), "server-%s", display);

    OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));

#ifdef WIN32
    strcpy(tmpname, Win32TempDir());
    strcat(tmpname, "\\xkb_XXXXXX");
    (void) mktemp(tmpname);
#endif

    if (XkbBaseDirectory != NULL) {
	if (asprintf(&xkbbasedirflag, "\"-R%s\"", XkbBaseDirectory) == -1)
	    xkbbasedirflag = NULL;
    }

    if (XkbBinDirectory != NULL) {
	int ld = strlen(XkbBinDirectory);
	int lps = strlen(PATHSEPARATOR);

	xkbbindir = XkbBinDirectory;

	if ((ld >= lps) &&
	    (strcmp(xkbbindir + ld - lps, PATHSEPARATOR) != 0)) {
	    xkbbindirsep = PATHSEPARATOR;
	}
    }

    if (asprintf(&buf,
		 "\"%s%sxkbcomp\" -w %d %s -xkm \"%s\" "
		  "-em1 %s -emp %s -eml %s \"%s%s.xkm\"",
		 xkbbindir, xkbbindirsep,
		 ((xkbDebugFlags < 2) ? 1 :
		  ((xkbDebugFlags > 10) ? 10 : (int) xkbDebugFlags)),
		 xkbbasedirflag ? xkbbasedirflag : "", xkmfile,
		 PRE_ERROR_MSG, ERROR_PREFIX, POST_ERROR_MSG1,
		 xkm_output_dir, keymap) == -1)
	buf = NULL;
	DebugF("[xkb] xkb buf: %s\n",buf);
    free(xkbbasedirflag);

    if (!buf) {
        LogMessage(X_ERROR, "XKB: Could not invoke xkbcomp: not enough memory\n");
        return FALSE;
    }
    
#ifndef WIN32
    out= Popen(buf,"w");
#else
    out= fopen(tmpname, "w");
#endif
    
    if (out!=NULL) {
#ifdef DEBUG
    if (xkbDebugFlags) {
       ErrorF("[xkb] XkbDDXCompileKeymapByNames compiling keymap:\n");
       XkbWriteXKBKeymapForNames(stderr,names,xkb,want,need);
    }
#endif
	XkbWriteXKBKeymapForNames(out,names,xkb,want,need);
#ifndef WIN32
	if (Pclose(out)==0)
#else
	if (fclose(out)==0 && System(buf) >= 0)
#endif
	{
            if (xkbDebugFlags)
                DebugF("[xkb] xkb executes: %s\n",buf);
	    if (nameRtrn) {
		strncpy(nameRtrn,keymap,nameRtrnLen);
		nameRtrn[nameRtrnLen-1]= '\0';
	    }
            free(buf);
	    return TRUE;
	}
	else
	    LogMessage(X_ERROR, "Error compiling keymap (%s)\n", keymap);
#ifdef WIN32
        /* remove the temporary file */
        unlink(tmpname);
#endif
    }
    else {
#ifndef WIN32
	LogMessage(X_ERROR, "XKB: Could not invoke xkbcomp\n");
#else
	LogMessage(X_ERROR, "Could not open file %s\n", tmpname);
#endif
    }
    if (nameRtrn)
	nameRtrn[0]= '\0';
    free(buf);
    return FALSE;
}

static FILE *
XkbDDXOpenConfigFile(char *mapName,char *fileNameRtrn,int fileNameRtrnLen)
{
char	buf[PATH_MAX],xkm_output_dir[PATH_MAX];
FILE *	file;

    buf[0]= '\0';
    if (mapName!=NULL) {
	OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));
	if ((XkbBaseDirectory!=NULL)&&(xkm_output_dir[0]!='/')
#ifdef WIN32
                &&(!isalpha(xkm_output_dir[0]) || xkm_output_dir[1]!=':')
#endif
                ) {
            if (snprintf(buf, PATH_MAX, "%s/%s%s.xkm", XkbBaseDirectory,
                         xkm_output_dir, mapName) >= PATH_MAX)
                buf[0] = '\0';
	}
	else
	{
            if (snprintf(buf, PATH_MAX, "%s%s.xkm", xkm_output_dir, mapName)
                >= PATH_MAX)
                buf[0] = '\0';
	}
	if (buf[0] != '\0')
	    file= fopen(buf,"rb");
	else file= NULL;
    }
    else file= NULL;
    if ((fileNameRtrn!=NULL)&&(fileNameRtrnLen>0)) {
	strncpy(fileNameRtrn,buf,fileNameRtrnLen);
	buf[fileNameRtrnLen-1]= '\0';
    }
    return file;
}

unsigned
XkbDDXLoadKeymapByNames(	DeviceIntPtr		keybd,
				XkbComponentNamesPtr	names,
				unsigned		want,
				unsigned		need,
				XkbDescPtr *		xkbRtrn,
				char *			nameRtrn,
				int 			nameRtrnLen)
{
XkbDescPtr      xkb;
FILE	*	file;
char		fileName[PATH_MAX];
unsigned	missing;

    *xkbRtrn = NULL;
    if ((keybd==NULL)||(keybd->key==NULL)||(keybd->key->xkbInfo==NULL))
	 xkb= NULL;
    else xkb= keybd->key->xkbInfo->desc;
    if ((names->keycodes==NULL)&&(names->types==NULL)&&
	(names->compat==NULL)&&(names->symbols==NULL)&&
	(names->geometry==NULL)) {
        LogMessage(X_ERROR, "XKB: No components provided for device %s\n",
                   keybd->name ? keybd->name : "(unnamed keyboard)");
        return 0;
    }
    else if (!XkbDDXCompileKeymapByNames(xkb,names,want,need,
                                         nameRtrn,nameRtrnLen)){
	LogMessage(X_ERROR, "XKB: Couldn't compile keymap\n");
	return 0;
    }
    file= XkbDDXOpenConfigFile(nameRtrn,fileName,PATH_MAX);
    if (file==NULL) {
	LogMessage(X_ERROR, "Couldn't open compiled keymap file %s\n",fileName);
	return 0;
    }
    missing= XkmReadFile(file,need,want,xkbRtrn);
    if (*xkbRtrn==NULL) {
	LogMessage(X_ERROR, "Error loading keymap %s\n",fileName);
	fclose(file);
	(void) unlink (fileName);
	return 0;
    }
    else {
	DebugF("Loaded XKB keymap %s, defined=0x%x\n",fileName,(*xkbRtrn)->defined);
    }
    fclose(file);
    (void) unlink (fileName);
    return (need|want)&(~missing);
}

Bool
XkbDDXNamesFromRules(	DeviceIntPtr		keybd,
			char *			rules_name,
			XkbRF_VarDefsPtr	defs,
			XkbComponentNamesPtr	names)
{
char 		buf[PATH_MAX];
FILE *		file;
Bool		complete;
XkbRF_RulesPtr	rules;

    if (!rules_name)
	return FALSE;

    if (snprintf(buf, PATH_MAX, "%s/rules/%s", XkbBaseDirectory, rules_name)
        >= PATH_MAX) {
        LogMessage(X_ERROR, "XKB: Rules name is too long\n");
        return FALSE;
    }

    file = fopen(buf, "r");
    if (!file) {
        LogMessage(X_ERROR, "XKB: Couldn't open rules file %s\n", buf);
	return FALSE;
    }

    rules = XkbRF_Create();
    if (!rules) {
        LogMessage(X_ERROR, "XKB: Couldn't create rules struct\n");
	fclose(file);
	return FALSE;
    }

    if (!XkbRF_LoadRules(file, rules)) {
        LogMessage(X_ERROR, "XKB: Couldn't parse rules file %s\n", rules_name);
	fclose(file);
	XkbRF_Free(rules,TRUE);
	return FALSE;
    }

    memset(names, 0, sizeof(*names));
    complete = XkbRF_GetComponents(rules,defs,names);
    fclose(file);
    XkbRF_Free(rules, TRUE);

    if (!complete)
        LogMessage(X_ERROR, "XKB: Rules returned no components\n");

    return complete;
}

static Bool
XkbRMLVOtoKcCGST(DeviceIntPtr dev, XkbRMLVOSet *rmlvo, XkbComponentNamesPtr kccgst)
{
    XkbRF_VarDefsRec mlvo;

    mlvo.model = rmlvo->model;
    mlvo.layout = rmlvo->layout;
    mlvo.variant = rmlvo->variant;
    mlvo.options = rmlvo->options;

    return XkbDDXNamesFromRules(dev, rmlvo->rules, &mlvo, kccgst);
}

/**
 * Compile the given RMLVO keymap and return it. Returns the XkbDescPtr on
 * success or NULL on failure. If the components compiled are not a superset
 * or equal to need, the compiliation is treated as failure.
 */
static XkbDescPtr
XkbCompileKeymapForDevice(DeviceIntPtr dev, XkbRMLVOSet *rmlvo, int need)
{
    XkbDescPtr xkb = NULL;
    unsigned int provided;
    XkbComponentNamesRec kccgst = {0};
    char name[PATH_MAX];

    if (XkbRMLVOtoKcCGST(dev, rmlvo, &kccgst)) {
        provided = XkbDDXLoadKeymapByNames(dev, &kccgst, XkmAllIndicesMask, need,
                                           &xkb, name, PATH_MAX);
        if ((need & provided) != need) {
            if (xkb) {
                XkbFreeKeyboard(xkb, 0, TRUE);
                xkb = NULL;
            }
        }
    }

    XkbFreeComponentNames(&kccgst, FALSE);
    return xkb;
}

XkbDescPtr
XkbCompileKeymap(DeviceIntPtr dev, XkbRMLVOSet *rmlvo)
{
    XkbDescPtr xkb;
    unsigned int need;

    if (!dev || !rmlvo) {
        LogMessage(X_ERROR, "XKB: No device or RMLVO specified\n");
        return NULL;
    }

    /* These are the components we really really need */
    need = XkmSymbolsMask | XkmCompatMapMask | XkmTypesMask |
           XkmKeyNamesMask | XkmVirtualModsMask;


    xkb = XkbCompileKeymapForDevice(dev, rmlvo, need);

    if (!xkb) {
        XkbRMLVOSet dflts;

        /* we didn't get what we really needed. And that will likely leave
         * us with a keyboard that doesn't work. Use the defaults instead */
        LogMessage(X_ERROR, "XKB: Failed to load keymap. Loading default "
                   "keymap instead.\n");

        XkbGetRulesDflts(&dflts);

        xkb = XkbCompileKeymapForDevice(dev, &dflts, 0);

        XkbFreeRMLVOSet(&dflts, FALSE);
    }

    return xkb;
}

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include "windowstr.h"
#include <xkbsrv.h>

int
XkbDDXPrivate(DeviceIntPtr dev,KeyCode key,XkbAction *act)
{
    return 0;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include <xkbsrv.h>

int
XkbDDXSwitchScreen(DeviceIntPtr dev,KeyCode key,XkbAction *act)
{
    return 1;
}
noinst_LTLIBRARIES = libxkb.la libxkbstubs.la

AM_CFLAGS = $(DIX_CFLAGS)

DDX_SRCS = \
        ddxBeep.c \
        ddxCtrls.c \
        ddxLEDs.c \
        ddxLoad.c \
        ddxList.c

DIX_SRCS = \
        xkb.c \
        xkbUtils.c \
        xkbEvents.c \
        xkbAccessX.c \
        xkbSwap.c \
        xkbLEDs.c \
        xkbInit.c \
        xkbActions.c \
        xkbPrKeyEv.c

# this should be replaced by a common library or something, ideally -d
XKBFILE_SRCS = \
        maprules.c \
        xkmread.c \
        xkbtext.c \
        xkbfmisc.c \
        xkbout.c

X11_SRCS = \
        XKBMisc.c \
        XKBAlloc.c \
        XKBGAlloc.c \
        XKBMAlloc.c

libxkb_la_SOURCES = $(DDX_SRCS) $(DIX_SRCS) $(XKBFILE_SRCS) $(X11_SRCS)
libxkbstubs_la_SOURCES = ddxVT.c ddxPrivate.c ddxKillSrv.c

EXTRA_DIST = xkbDflts.h xkbgeom.h xkb.h

xkbcompileddir = $(XKB_COMPILED_DIR)
dist_xkbcompiled_DATA = README.compiled
/************************************************************
 Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#define X_INCLUDE_STRING_H
#define XOS_USE_NO_LOCKING
#include <X11/Xos_r.h>

#include <X11/Xproto.h>
#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xfuncs.h>
#include <X11/Xatom.h>
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "os.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>

/***====================================================================***/



#define DFLT_LINE_SIZE	128

typedef struct {
	int	line_num;
	int	sz_line;
	int	num_line;
	char	buf[DFLT_LINE_SIZE];
	char *	line;
} InputLine;

static void
InitInputLine(InputLine *line)
{
    line->line_num= 1;
    line->num_line= 0;
    line->sz_line= DFLT_LINE_SIZE;
    line->line=	line->buf;
    return;
}

static void
FreeInputLine(InputLine *line)
{
    if (line->line!=line->buf)
	free(line->line);
    line->line_num= 1;
    line->num_line= 0;
    line->sz_line= DFLT_LINE_SIZE;
    line->line= line->buf;
    return;
}

static int
InputLineAddChar(InputLine *line,int ch)
{
    if (line->num_line>=line->sz_line) {
	if (line->line==line->buf) {
	    line->line= malloc(line->sz_line*2);
	    memcpy(line->line,line->buf,line->sz_line);
	}
	else {
	    line->line= realloc((char *)line->line,line->sz_line*2);
	}
	line->sz_line*= 2;
    }
    line->line[line->num_line++]= ch;
    return ch;
}

#define	ADD_CHAR(l,c)	((l)->num_line<(l)->sz_line?\
				(int)((l)->line[(l)->num_line++]= (c)):\
				InputLineAddChar(l,c))

static Bool
GetInputLine(FILE *file,InputLine *line,Bool checkbang)
{
int	ch;
Bool	endOfFile,spacePending,slashPending,inComment;

     endOfFile= FALSE;
     while ((!endOfFile)&&(line->num_line==0)) {
	spacePending= slashPending= inComment= FALSE;
	while (((ch=getc(file))!='\n')&&(ch!=EOF)) {
	    if (ch=='\\') {
		if ((ch=getc(file))==EOF)
		    break;
		if (ch=='\n') {
		    inComment= FALSE;
		    ch= ' ';
		    line->line_num++;
		}
	    }
	    if (inComment)
		continue;
	    if (ch=='/') {
		if (slashPending) {
		    inComment= TRUE;
		    slashPending= FALSE;
		}
		else {
		    slashPending= TRUE;
		}
		continue;
	    }
	    else if (slashPending) {
		if (spacePending) {
		    ADD_CHAR(line,' ');
		    spacePending= FALSE;
		}
		ADD_CHAR(line,'/');
		slashPending= FALSE;
	    }
	    if (isspace(ch)) {
		while (isspace(ch)&&(ch!='\n')&&(ch!=EOF)) {
		    ch= getc(file);
		}
		if (ch==EOF)
		    break;
		if ((ch!='\n')&&(line->num_line>0))
		    spacePending= TRUE;
		ungetc(ch,file);
	    }
	    else {
		if (spacePending) {
		    ADD_CHAR(line,' ');
		    spacePending= FALSE;
		}
		if (checkbang && ch=='!') {
		    if (line->num_line!=0) {
			DebugF("The '!' legal only at start of line\n");
			DebugF("Line containing '!' ignored\n");
			line->num_line= 0;
			inComment= 0;
			break;
		    }

		}
		ADD_CHAR(line,ch);
	    }
	}
	if (ch==EOF)
	     endOfFile= TRUE;
/*	else line->num_line++;*/
     }
     if ((line->num_line==0)&&(endOfFile))
	return FALSE;
      ADD_CHAR(line,'\0');
      return TRUE;
}

/***====================================================================***/

#define	MODEL		0
#define	LAYOUT		1
#define	VARIANT		2
#define	OPTION		3
#define	KEYCODES	4
#define SYMBOLS		5
#define	TYPES		6
#define	COMPAT		7
#define	GEOMETRY	8
#define	MAX_WORDS	9

#define	PART_MASK	0x000F
#define	COMPONENT_MASK	0x03F0

static	char *	cname[MAX_WORDS] = {
	"model", "layout", "variant", "option", 
	"keycodes", "symbols", "types", "compat", "geometry"
};

typedef	struct _RemapSpec {
	int			number;
	int			num_remap;
	struct	{
		int	word;
		int	index;
                }		remap[MAX_WORDS];
} RemapSpec;

typedef struct _FileSpec {
	char *			name[MAX_WORDS];
	struct _FileSpec *	pending;
} FileSpec;

typedef struct {
	char *			model;
	char *			layout[XkbNumKbdGroups+1];
	char *			variant[XkbNumKbdGroups+1];
	char *			options;
} XkbRF_MultiDefsRec, *XkbRF_MultiDefsPtr;

#define NDX_BUFF_SIZE	4

/***====================================================================***/

static char*
get_index(char *str, int *ndx)
{
   char ndx_buf[NDX_BUFF_SIZE];
   char *end;

   if (*str != '[') {
       *ndx = 0;
       return str;
   }
   str++;
   end = strchr(str, ']');
   if (end == NULL) {
       *ndx = -1;
       return str - 1;
   }
   if ( (end - str) >= NDX_BUFF_SIZE) {
       *ndx = -1;
       return end + 1;
   }
   strncpy(ndx_buf, str, end - str);
   ndx_buf[end - str] = '\0';
   *ndx = atoi(ndx_buf);
   return end + 1;
}

static void
SetUpRemap(InputLine *line,RemapSpec *remap)
{
char *		tok,*str;
unsigned	present, l_ndx_present, v_ndx_present;
register int	i;
int		len, ndx;
_Xstrtokparams	strtok_buf;
Bool		found;


   l_ndx_present = v_ndx_present = present= 0;
   str= &line->line[1];
   len = remap->number;
   memset((char *)remap, 0, sizeof(RemapSpec));
   remap->number = len;
   while ((tok=_XStrtok(str," ",strtok_buf))!=NULL) {
	found= FALSE;
	str= NULL;
	if (strcmp(tok,"=")==0)
	    continue;
	for (i=0;i<MAX_WORDS;i++) {
            len = strlen(cname[i]);
	    if (strncmp(cname[i],tok,len)==0) {
		if(strlen(tok) > len) {
		    char *end = get_index(tok+len, &ndx);
		    if ((i != LAYOUT && i != VARIANT) ||
			*end != '\0' || ndx == -1)
		        break;
		     if (ndx < 1 || ndx > XkbNumKbdGroups) {
		        DebugF("Illegal %s index: %d\n", cname[i], ndx);
		        DebugF("Index must be in range 1..%d\n",
				   XkbNumKbdGroups);
			break;
		     }
                } else {
		    ndx = 0;
                }
		found= TRUE;
		if (present&(1<<i)) {
		    if ((i == LAYOUT && l_ndx_present&(1<<ndx)) ||
			(i == VARIANT && v_ndx_present&(1<<ndx)) ) {
		        DebugF("Component \"%s\" listed twice\n",tok);
		        DebugF("Second definition ignored\n");
		        break;
		    }
		}
		present |= (1<<i);
                if (i == LAYOUT)
                    l_ndx_present |= 1 << ndx;
                if (i == VARIANT)
                    v_ndx_present |= 1 << ndx;
		remap->remap[remap->num_remap].word= i;
		remap->remap[remap->num_remap++].index= ndx;
		break;
	    }
	}
	if (!found) {
	    fprintf(stderr,"Unknown component \"%s\" ignored\n",tok);
	}
   }
   if ((present&PART_MASK)==0) {
	unsigned mask= PART_MASK;
	ErrorF("Mapping needs at least one of ");
	for (i=0; (i<MAX_WORDS); i++) {
	    if ((1L<<i)&mask) {
		mask&= ~(1L<<i);
		if (mask)	DebugF("\"%s,\" ",cname[i]);
		else		DebugF("or \"%s\"\n",cname[i]);
	    }
	}
	DebugF("Illegal mapping ignored\n");
	remap->num_remap= 0;
	return;
   }
   if ((present&COMPONENT_MASK)==0) {
	DebugF("Mapping needs at least one component\n");
	DebugF("Illegal mapping ignored\n");
	remap->num_remap= 0;
	return;
   }
   remap->number++;
   return;
}

static Bool
MatchOneOf(char *wanted,char *vals_defined)
{
char	*str,*next;
int	want_len= strlen(wanted);

    for (str=vals_defined,next=NULL;str!=NULL;str=next) {
	int len;
	next= strchr(str,',');
	if (next) {
	    len= next-str;
	    next++;
	}
	else {
	    len= strlen(str);
	}
	if ((len==want_len)&&(strncmp(wanted,str,len)==0))
	    return TRUE;
    }
    return FALSE;
}

/***====================================================================***/

static Bool
CheckLine(	InputLine *		line,
		RemapSpec *		remap,
		XkbRF_RulePtr		rule,
		XkbRF_GroupPtr		group)
{
char *		str,*tok;
register int	nread, i;
FileSpec	tmp;
_Xstrtokparams	strtok_buf;
Bool 		append = FALSE;

    if (line->line[0]=='!') {
        if (line->line[1] == '$' ||
            (line->line[1] == ' ' && line->line[2] == '$')) {
            char *gname = strchr(line->line, '$');
            char *words = strchr(gname, ' ');
            if(!words)
                return FALSE;
            *words++ = '\0';
            for (; *words; words++) {
                if (*words != '=' && *words != ' ')
                    break;
            }
            if (*words == '\0')
                return FALSE;
            group->name = Xstrdup(gname);
            group->words = Xstrdup(words);
            for (i = 1, words = group->words; *words; words++) {
                 if ( *words == ' ') {
                     *words++ = '\0';
                     i++;
                 }
            }
            group->number = i;
            return TRUE;
        } else {
	    SetUpRemap(line,remap);
	    return FALSE;
        }
    }

    if (remap->num_remap==0) {
	DebugF("Must have a mapping before first line of data\n");
	DebugF("Illegal line of data ignored\n");
	return FALSE;
    }
    memset((char *)&tmp, 0, sizeof(FileSpec));
    str= line->line;
    for (nread= 0;(tok=_XStrtok(str," ",strtok_buf))!=NULL;nread++) {
	str= NULL;
	if (strcmp(tok,"=")==0) {
	    nread--;
	    continue;
	}
	if (nread>remap->num_remap) {
	    DebugF("Too many words on a line\n");
	    DebugF("Extra word \"%s\" ignored\n",tok);
	    continue;
	}
	tmp.name[remap->remap[nread].word]= tok;
	if (*tok == '+' || *tok == '|')
	    append = TRUE;
    }
    if (nread<remap->num_remap) {
	DebugF("Too few words on a line: %s\n", line->line);
	DebugF("line ignored\n");
	return FALSE;
    }

    rule->flags= 0;
    rule->number = remap->number;
    if (tmp.name[OPTION])
	 rule->flags|= XkbRF_Option;
    else if (append)
	 rule->flags|= XkbRF_Append;
    else
	 rule->flags|= XkbRF_Normal;
    rule->model= Xstrdup(tmp.name[MODEL]);
    rule->layout= Xstrdup(tmp.name[LAYOUT]);
    rule->variant= Xstrdup(tmp.name[VARIANT]);
    rule->option= Xstrdup(tmp.name[OPTION]);

    rule->keycodes= Xstrdup(tmp.name[KEYCODES]);
    rule->symbols= Xstrdup(tmp.name[SYMBOLS]);
    rule->types= Xstrdup(tmp.name[TYPES]);
    rule->compat= Xstrdup(tmp.name[COMPAT]);
    rule->geometry= Xstrdup(tmp.name[GEOMETRY]);

    rule->layout_num = rule->variant_num = 0;
    for (i = 0; i < nread; i++) {
        if (remap->remap[i].index) {
	    if (remap->remap[i].word == LAYOUT)
	        rule->layout_num = remap->remap[i].index;
	    if (remap->remap[i].word == VARIANT)
	        rule->variant_num = remap->remap[i].index;
        }
    }
    return TRUE;
}

static char *
_Concat(char *str1,char *str2)
{
int len;

    if ((!str1)||(!str2))
	return str1;
    len= strlen(str1)+strlen(str2)+1;
    str1= realloc(str1,len * sizeof(char));
    if (str1)
	strcat(str1,str2);
    return str1;
}

static void
squeeze_spaces(char *p1)
{
   char *p2;
   for (p2 = p1; *p2; p2++) {
       *p1 = *p2;
       if (*p1 != ' ') p1++;
   }
   *p1 = '\0';
}

static Bool
MakeMultiDefs(XkbRF_MultiDefsPtr mdefs, XkbRF_VarDefsPtr defs)
{

   memset((char *)mdefs, 0, sizeof(XkbRF_MultiDefsRec));
   mdefs->model = defs->model;
   mdefs->options = Xstrdup(defs->options);
   if (mdefs->options) squeeze_spaces(mdefs->options); 

   if (defs->layout) {
       if (!strchr(defs->layout, ',')) {
           mdefs->layout[0] = defs->layout;
       } else {
           char *p;
           int i;
           mdefs->layout[1] = Xstrdup(defs->layout);
	   if (mdefs->layout[1] == NULL)
	      return FALSE;
           squeeze_spaces(mdefs->layout[1]);
           p = mdefs->layout[1];
           for (i = 2; i <= XkbNumKbdGroups; i++) {
              if ((p = strchr(p, ','))) {
                 *p++ = '\0';
                 mdefs->layout[i] = p;
              } else {
                 break;
              }
           }
           if (p && (p = strchr(p, ',')))
              *p = '\0';
       }
   }

   if (defs->variant) {
       if (!strchr(defs->variant, ',')) {
           mdefs->variant[0] = defs->variant;
       } else {
           char *p;
           int i;
           mdefs->variant[1] = Xstrdup(defs->variant);
	   if (mdefs->variant[1] == NULL)
	      return FALSE;
           squeeze_spaces(mdefs->variant[1]);
           p = mdefs->variant[1];
           for (i = 2; i <= XkbNumKbdGroups; i++) {
              if ((p = strchr(p, ','))) {
                 *p++ = '\0';
                 mdefs->variant[i] = p;
              } else {
                 break;
              }
           }
           if (p && (p = strchr(p, ',')))
              *p = '\0';
       }
   }
   return TRUE;
}

static void
FreeMultiDefs(XkbRF_MultiDefsPtr defs)
{
  free(defs->options);
  free(defs->layout[1]);
  free(defs->variant[1]);
}

static void
Apply(char *src, char **dst)
{
    if (src) {
        if (*src == '+' || *src == '!') {
	    *dst= _Concat(*dst, src);
        } else {
            if (*dst == NULL)
	        *dst= Xstrdup(src);
        }
    }
}

static void
XkbRF_ApplyRule(	XkbRF_RulePtr 		rule,
			XkbComponentNamesPtr	names)
{
    rule->flags&= ~XkbRF_PendingMatch; /* clear the flag because it's applied */

    Apply(rule->keycodes, &names->keycodes);
    Apply(rule->symbols,  &names->symbols);
    Apply(rule->types,    &names->types);
    Apply(rule->compat,   &names->compat);
    Apply(rule->geometry, &names->geometry);
}

static Bool
CheckGroup(	XkbRF_RulesPtr          rules,
		char * 			group_name,
		char * 			name)
{
   int i;
   char *p;
   XkbRF_GroupPtr group;

   for (i = 0, group = rules->groups; i < rules->num_groups; i++, group++) {
       if (! strcmp(group->name, group_name)) {
           break;
       }
   }
   if (i == rules->num_groups)
       return FALSE;
   for (i = 0, p = group->words; i < group->number; i++, p += strlen(p)+1) {
       if (! strcmp(p, name)) {
           return TRUE;
       }
   }
   return FALSE;
}

static int
XkbRF_CheckApplyRule(	XkbRF_RulePtr 		rule,
			XkbRF_MultiDefsPtr	mdefs,
			XkbComponentNamesPtr	names,
			XkbRF_RulesPtr          rules)
{
    Bool pending = FALSE;

    if (rule->model != NULL) {
        if(mdefs->model == NULL)
            return 0;
        if (strcmp(rule->model, "*") == 0) {
            pending = TRUE;
        } else {
            if (rule->model[0] == '$') {
               if (!CheckGroup(rules, rule->model, mdefs->model))
                  return 0;
            } else {
	       if (strcmp(rule->model, mdefs->model) != 0)
	          return 0;
	    }
	}
    }
    if (rule->option != NULL) {
	if (mdefs->options == NULL)
	    return 0;
	if ((!MatchOneOf(rule->option,mdefs->options)))
	    return 0;
    }

    if (rule->layout != NULL) {
	if(mdefs->layout[rule->layout_num] == NULL ||
	   *mdefs->layout[rule->layout_num] == '\0')
	    return 0;
        if (strcmp(rule->layout, "*") == 0) {
            pending = TRUE;
        } else {
            if (rule->layout[0] == '$') {
               if (!CheckGroup(rules, rule->layout,
                               mdefs->layout[rule->layout_num]))
                  return 0;
	    } else {
	       if (strcmp(rule->layout, mdefs->layout[rule->layout_num]) != 0)
	           return 0;
	    }
	}
    }
    if (rule->variant != NULL) {
	if (mdefs->variant[rule->variant_num] == NULL ||
	    *mdefs->variant[rule->variant_num] == '\0')
	    return 0;
        if (strcmp(rule->variant, "*") == 0) {
            pending = TRUE;
        } else {
            if (rule->variant[0] == '$') {
               if (!CheckGroup(rules, rule->variant,
                               mdefs->variant[rule->variant_num]))
                  return 0;
            } else {
	       if (strcmp(rule->variant,
                          mdefs->variant[rule->variant_num]) != 0)
	           return 0;
	    }
	}
    }
    if (pending) {
        rule->flags|= XkbRF_PendingMatch;
	return rule->number;
    }
    /* exact match, apply it now */
    XkbRF_ApplyRule(rule,names);
    return rule->number;
}

static void
XkbRF_ClearPartialMatches(XkbRF_RulesPtr rules)
{
register int 	i;
XkbRF_RulePtr	rule;

    for (i=0,rule=rules->rules;i<rules->num_rules;i++,rule++) {
	rule->flags&= ~XkbRF_PendingMatch;
    }
}

static void
XkbRF_ApplyPartialMatches(XkbRF_RulesPtr rules,XkbComponentNamesPtr names)
{
int		i;
XkbRF_RulePtr	rule;

    for (rule = rules->rules, i = 0; i < rules->num_rules; i++, rule++) {
	if ((rule->flags&XkbRF_PendingMatch)==0)
	    continue;
	XkbRF_ApplyRule(rule,names);
    }
}

static void
XkbRF_CheckApplyRules(	XkbRF_RulesPtr 		rules,
			XkbRF_MultiDefsPtr	mdefs,
			XkbComponentNamesPtr	names,
			int			flags)
{
int		i;
XkbRF_RulePtr	rule;
int		skip;

    for (rule = rules->rules, i=0; i < rules->num_rules; rule++, i++) {
	if ((rule->flags & flags) != flags)
	    continue;
	skip = XkbRF_CheckApplyRule(rule, mdefs, names, rules);
	if (skip && !(flags & XkbRF_Option)) {
	    for ( ;(i < rules->num_rules) && (rule->number == skip);
		  rule++, i++);
	    rule--; i--;
	}
    }
}

/***====================================================================***/

static char *
XkbRF_SubstituteVars(char *name, XkbRF_MultiDefsPtr mdefs)
{
char 	*str, *outstr, *orig, *var;
int	len, ndx;

    orig= name;
    str= index(name,'%');
    if (str==NULL)
	return name;
    len= strlen(name);
    while (str!=NULL) {
	char pfx= str[1];
	int   extra_len= 0;
	if ((pfx=='+')||(pfx=='|')||(pfx=='_')||(pfx=='-')) {
	    extra_len= 1;
	    str++;
	}
	else if (pfx=='(') {
	    extra_len= 2;
	    str++;
	}
	var = str + 1;
	str = get_index(var + 1, &ndx);
	if (ndx == -1) {
	    str = index(str,'%');
	    continue;
        }
	if ((*var=='l') && mdefs->layout[ndx] && *mdefs->layout[ndx])
	    len+= strlen(mdefs->layout[ndx])+extra_len;
	else if ((*var=='m')&&mdefs->model)
	    len+= strlen(mdefs->model)+extra_len;
	else if ((*var=='v') && mdefs->variant[ndx] && *mdefs->variant[ndx])
	    len+= strlen(mdefs->variant[ndx])+extra_len;
	if ((pfx=='(')&&(*str==')')) {
	    str++;
	}
	str= index(&str[0],'%');
    }
    name= malloc(len+1);
    str= orig;
    outstr= name;
    while (*str!='\0') {
	if (str[0]=='%') {
	    char pfx,sfx;
	    str++;
	    pfx= str[0];
	    sfx= '\0';
	    if ((pfx=='+')||(pfx=='|')||(pfx=='_')||(pfx=='-')) {
		str++;
	    }
	    else if (pfx=='(') {
		sfx= ')';
		str++;
	    }
	    else pfx= '\0';

	    var = str;
	    str = get_index(var + 1, &ndx);
	    if (ndx == -1) {
	        continue;
            }
	    if ((*var=='l') && mdefs->layout[ndx] && *mdefs->layout[ndx]) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->layout[ndx]);
		outstr+= strlen(mdefs->layout[ndx]);
		if (sfx) *outstr++= sfx;
	    }
	    else if ((*var=='m')&&(mdefs->model)) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->model);
		outstr+= strlen(mdefs->model);
		if (sfx) *outstr++= sfx;
	    }
	    else if ((*var=='v') && mdefs->variant[ndx] && *mdefs->variant[ndx]) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->variant[ndx]);
		outstr+= strlen(mdefs->variant[ndx]);
		if (sfx) *outstr++= sfx;
	    }
	    if ((pfx=='(')&&(*str==')'))
		str++;
	}
	else {
	    *outstr++= *str++;
	}
    }
    *outstr++= '\0';
    if (orig!=name)
	free(orig);
    return name;
}

/***====================================================================***/

Bool
XkbRF_GetComponents(	XkbRF_RulesPtr		rules,
			XkbRF_VarDefsPtr	defs,
			XkbComponentNamesPtr	names)
{
    XkbRF_MultiDefsRec mdefs;

    MakeMultiDefs(&mdefs, defs);

    memset((char *)names, 0, sizeof(XkbComponentNamesRec));
    XkbRF_ClearPartialMatches(rules);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Normal);
    XkbRF_ApplyPartialMatches(rules, names);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Append);
    XkbRF_ApplyPartialMatches(rules, names);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Option);

    if (names->keycodes)
	names->keycodes= XkbRF_SubstituteVars(names->keycodes, &mdefs);
    if (names->symbols)	
	names->symbols=	XkbRF_SubstituteVars(names->symbols, &mdefs);
    if (names->types)
	names->types= XkbRF_SubstituteVars(names->types, &mdefs);
    if (names->compat)
	names->compat= XkbRF_SubstituteVars(names->compat, &mdefs);
    if (names->geometry)
	names->geometry= XkbRF_SubstituteVars(names->geometry, &mdefs);

    FreeMultiDefs(&mdefs);
    return (names->keycodes && names->symbols && names->types &&
		names->compat && names->geometry);
}

static XkbRF_RulePtr
XkbRF_AddRule(XkbRF_RulesPtr	rules)
{
    if (rules->sz_rules<1) {
	rules->sz_rules= 16;
	rules->num_rules= 0;
	rules->rules= calloc(rules->sz_rules, sizeof(XkbRF_RuleRec));
    }
    else if (rules->num_rules>=rules->sz_rules) {
	rules->sz_rules*= 2;
	rules->rules= realloc(rules->rules,
				rules->sz_rules * sizeof(XkbRF_RuleRec));
    }
    if (!rules->rules) {
	rules->sz_rules= rules->num_rules= 0;
	DebugF("Allocation failure in XkbRF_AddRule\n");
	return NULL;
    }
    memset((char *)&rules->rules[rules->num_rules], 0, sizeof(XkbRF_RuleRec));
    return &rules->rules[rules->num_rules++];
}

static XkbRF_GroupPtr
XkbRF_AddGroup(XkbRF_RulesPtr	rules)
{
    if (rules->sz_groups<1) {
	rules->sz_groups= 16;
	rules->num_groups= 0;
	rules->groups= calloc(rules->sz_groups, sizeof(XkbRF_GroupRec));
    }
    else if (rules->num_groups >= rules->sz_groups) {
	rules->sz_groups *= 2;
	rules->groups= realloc(rules->groups,
				rules->sz_groups * sizeof(XkbRF_GroupRec));
    }
    if (!rules->groups) {
	rules->sz_groups= rules->num_groups= 0;
	return NULL;
    }

    memset((char *)&rules->groups[rules->num_groups], 0, sizeof(XkbRF_GroupRec));
    return &rules->groups[rules->num_groups++];
}

Bool
XkbRF_LoadRules(FILE *file, XkbRF_RulesPtr rules)
{
InputLine	line;
RemapSpec	remap;
XkbRF_RuleRec	trule,*rule;
XkbRF_GroupRec  tgroup,*group;

    if (!(rules && file))
	return FALSE;
    memset((char *)&remap, 0, sizeof(RemapSpec));
    memset((char *)&tgroup, 0, sizeof(XkbRF_GroupRec));
    InitInputLine(&line);
    while (GetInputLine(file,&line,TRUE)) {
	if (CheckLine(&line,&remap,&trule,&tgroup)) {
            if (tgroup.number) {
	        if ((group= XkbRF_AddGroup(rules))!=NULL) {
		    *group= tgroup;
		    memset((char *)&tgroup, 0, sizeof(XkbRF_GroupRec));
	        }
	    } else {
	        if ((rule= XkbRF_AddRule(rules))!=NULL) {
		    *rule= trule;
		    memset((char *)&trule, 0, sizeof(XkbRF_RuleRec));
	        }
	    }
	}
	line.num_line= 0;
    }
    FreeInputLine(&line);
    return TRUE;
}

Bool
XkbRF_LoadRulesByName(char *base,char *locale,XkbRF_RulesPtr rules)
{
FILE *		file;
char		buf[PATH_MAX];
Bool		ok;

    if ((!base)||(!rules))
	return FALSE;
    if (locale) {
	if (snprintf(buf, PATH_MAX, "%s-%s", base, locale) >= PATH_MAX)
	    return FALSE;
    }
    else {
	if (strlen(base)+1 > PATH_MAX)
	    return FALSE;
	strcpy(buf,base);
    }

    file= fopen(buf, "r");
    if ((!file)&&(locale)) { /* fallback if locale was specified */
	strcpy(buf,base);
	file= fopen(buf, "r");
    }
    if (!file)
	return FALSE;
    ok= XkbRF_LoadRules(file,rules);
    fclose(file);
    return ok;
}

/***====================================================================***/

XkbRF_RulesPtr
XkbRF_Create(void)
{
    return calloc(1, sizeof( XkbRF_RulesRec));
}

/***====================================================================***/

void
XkbRF_Free(XkbRF_RulesPtr rules,Bool freeRules)
{
int		i;
XkbRF_RulePtr	rule;
XkbRF_GroupPtr	group;

    if (!rules)
	return;
    if (rules->rules) {
	for (i=0,rule=rules->rules;i<rules->num_rules;i++,rule++) {
	    free(rule->model);
	    free(rule->layout);
	    free(rule->variant);
	    free(rule->option);
	    free(rule->keycodes);
	    free(rule->symbols);
	    free(rule->types);
	    free(rule->compat);
	    free(rule->geometry);
	    memset((char *)rule, 0, sizeof(XkbRF_RuleRec));
	}
	free(rules->rules);
	rules->num_rules= rules->sz_rules= 0;
	rules->rules= NULL;
    }

    if (rules->groups) {
	for (i=0, group=rules->groups;i<rules->num_groups;i++,group++) {
	    free(group->name);
	    free(group->words);
	}
	free(rules->groups);
	rules->num_groups= 0;
	rules->groups= NULL;
    }
    if (freeRules)
	free(rules);
    return;
}

The X server uses this directory to store the compiled version of the
current keymap and/or any scratch keymaps used by clients.  The X server
or some other tool might destroy or replace the files in this directory,
so it is not a safe place to store compiled keymaps for long periods of
time.  The default keymap for any server is usually stored in:
     X<num>-default.xkm
where <num> is the display number of the server in question, which makes
it possible for several servers *on the same host* to share the same 
directory.

Unless the X server is modified, sharing this directory between servers on
different hosts could cause problems.
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "extnsionst.h"
#include "xace.h"
#include "xkb.h"
#include "protocol-versions.h"

#include <X11/extensions/XI.h>
#include <X11/extensions/XKMformat.h>

int		XkbEventBase;
static	int	XkbErrorBase;
int		XkbReqCode;
int		XkbKeyboardErrorCode;
CARD32		xkbDebugFlags = 0;
static CARD32	xkbDebugCtrls = 0;

static RESTYPE	RT_XKBCLIENT;

/***====================================================================***/

#define	CHK_DEVICE(dev, id, client, access_mode, lf) {\
    int why;\
    int rc = lf(&(dev), id, client, access_mode, &why);\
    if (rc != Success) {\
	client->errorValue = _XkbErrCode2(why, id);\
	return rc;\
    }\
}

#define	CHK_KBD_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupKeyboard)
#define	CHK_LED_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupLedDevice)
#define	CHK_BELL_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupBellDevice)
#define	CHK_ANY_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupAnyDevice)

#define	CHK_ATOM_ONLY2(a,ev,er) {\
	if (((a)==None)||(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    return er;\
	}\
}
#define	CHK_ATOM_ONLY(a) \
	CHK_ATOM_ONLY2(a,client->errorValue,BadAtom)

#define	CHK_ATOM_OR_NONE3(a,ev,er,ret) {\
	if (((a)!=None)&&(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    (er)= BadAtom;\
	    return ret;\
	}\
}
#define	CHK_ATOM_OR_NONE2(a,ev,er) {\
	if (((a)!=None)&&(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    return er;\
	}\
}
#define	CHK_ATOM_OR_NONE(a) \
	CHK_ATOM_OR_NONE2(a,client->errorValue,BadAtom)

#define	CHK_MASK_LEGAL3(err,mask,legal,ev,er,ret)	{\
	if ((mask)&(~(legal))) { \
	    (ev)= _XkbErrCode2((err),((mask)&(~(legal))));\
	    (er)= BadValue;\
	    return ret;\
	}\
}
#define	CHK_MASK_LEGAL2(err,mask,legal,ev,er)	{\
	if ((mask)&(~(legal))) { \
	    (ev)= _XkbErrCode2((err),((mask)&(~(legal))));\
	    return er;\
	}\
}
#define	CHK_MASK_LEGAL(err,mask,legal) \
	CHK_MASK_LEGAL2(err,mask,legal,client->errorValue,BadValue)

#define	CHK_MASK_MATCH(err,affect,value) {\
	if ((value)&(~(affect))) { \
	    client->errorValue= _XkbErrCode2((err),((value)&(~(affect))));\
	    return BadMatch;\
	}\
}
#define	CHK_MASK_OVERLAP(err,m1,m2) {\
	if ((m1)&(m2)) { \
	    client->errorValue= _XkbErrCode2((err),((m1)&(m2)));\
	    return BadMatch;\
	}\
}
#define	CHK_KEY_RANGE2(err,first,num,x,ev,er) {\
	if (((unsigned)(first)+(num)-1)>(x)->max_key_code) {\
	    (ev)=_XkbErrCode4(err,(first),(num),(x)->max_key_code);\
	    return er;\
	}\
	else if ( (first)<(x)->min_key_code ) {\
	    (ev)=_XkbErrCode3(err+1,(first),xkb->min_key_code);\
	    return er;\
	}\
}
#define	CHK_KEY_RANGE(err,first,num,x)  \
	CHK_KEY_RANGE2(err,first,num,x,client->errorValue,BadValue)

#define	CHK_REQ_KEY_RANGE2(err,first,num,r,ev,er) {\
	if (((unsigned)(first)+(num)-1)>(r)->maxKeyCode) {\
	    (ev)=_XkbErrCode4(err,(first),(num),(r)->maxKeyCode);\
	    return er;\
	}\
	else if ( (first)<(r)->minKeyCode ) {\
	    (ev)=_XkbErrCode3(err+1,(first),(r)->minKeyCode);\
	    return er;\
	}\
}
#define	CHK_REQ_KEY_RANGE(err,first,num,r)  \
	CHK_REQ_KEY_RANGE2(err,first,num,r,client->errorValue,BadValue)

/***====================================================================***/

int
ProcXkbUseExtension(ClientPtr client)
{
    REQUEST(xkbUseExtensionReq);
    xkbUseExtensionReply	rep;
    register int n;
    int	supported;

    REQUEST_SIZE_MATCH(xkbUseExtensionReq);
    if (stuff->wantedMajor != SERVER_XKB_MAJOR_VERSION) {
	/* pre-release version 0.65 is compatible with 1.00 */
	supported= ((SERVER_XKB_MAJOR_VERSION==1)&&
		    (stuff->wantedMajor==0)&&(stuff->wantedMinor==65));
    }
    else supported = 1;

    if ((supported) && (!(client->xkbClientFlags&_XkbClientInitialized))) {
	client->xkbClientFlags= _XkbClientInitialized;
	client->vMajor= stuff->wantedMajor;
	client->vMinor= stuff->wantedMinor;
    }
    else if (xkbDebugFlags&0x1) {
	ErrorF("[xkb] Rejecting client %d (0x%lx) (wants %d.%02d, have %d.%02d)\n",
					client->index,
					(long)client->clientAsMask,
					stuff->wantedMajor,stuff->wantedMinor,
					SERVER_XKB_MAJOR_VERSION,SERVER_XKB_MINOR_VERSION);
    }
    memset(&rep, 0, sizeof(xkbUseExtensionReply));
    rep.type = X_Reply;
    rep.supported = supported;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.serverMajor = SERVER_XKB_MAJOR_VERSION;
    rep.serverMinor = SERVER_XKB_MINOR_VERSION;
    if ( client->swapped ) {
	swaps(&rep.sequenceNumber, n);
	swaps(&rep.serverMajor, n);
	swaps(&rep.serverMinor, n);
    }
    WriteToClient(client,SIZEOF(xkbUseExtensionReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

int
ProcXkbSelectEvents(ClientPtr client)
{
    unsigned		legal;
    DeviceIntPtr 	dev;
    XkbInterestPtr	masks;
    REQUEST(xkbSelectEventsReq);

    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixUseAccess);

    if (((stuff->affectWhich&XkbMapNotifyMask)!=0)&&(stuff->affectMap)) {
	client->mapNotifyMask&= ~stuff->affectMap;
	client->mapNotifyMask|= (stuff->affectMap&stuff->map);
    }
    if ((stuff->affectWhich&(~XkbMapNotifyMask))==0) 
	return Success;

    masks = XkbFindClientResource((DevicePtr)dev,client);
    if (!masks){
	XID id = FakeClientID(client->index);
	if (!AddResource(id,RT_XKBCLIENT,dev))
	    return BadAlloc;
	masks= XkbAddClientResource((DevicePtr)dev,client,id);
    }
    if (masks) {
	union {
	    CARD8	*c8;
	    CARD16	*c16;
	    CARD32	*c32;
	} from,to;
	register unsigned bit,ndx,maskLeft,dataLeft,size;

	from.c8= (CARD8 *)&stuff[1];
	dataLeft= (stuff->length*4)-SIZEOF(xkbSelectEventsReq);
	maskLeft= (stuff->affectWhich&(~XkbMapNotifyMask));
	for (ndx=0,bit=1; (maskLeft!=0); ndx++, bit<<=1) {
	    if ((bit&maskLeft)==0)
		continue;
	    maskLeft&= ~bit;
	    switch (ndx) {
		case XkbNewKeyboardNotify:
		    to.c16= &client->newKeyboardNotifyMask;
		    legal= XkbAllNewKeyboardEventsMask;
		    size= 2;
		    break;
		case XkbStateNotify:
		    to.c16= &masks->stateNotifyMask;
		    legal= XkbAllStateEventsMask;
		    size= 2;
		    break;
		case XkbControlsNotify:
		    to.c32= &masks->ctrlsNotifyMask;
		    legal= XkbAllControlEventsMask;
		    size= 4;
		    break;
		case XkbIndicatorStateNotify:
		    to.c32= &masks->iStateNotifyMask;
		    legal= XkbAllIndicatorEventsMask;
		    size= 4;
		    break;
		case XkbIndicatorMapNotify:
		    to.c32= &masks->iMapNotifyMask;
		    legal= XkbAllIndicatorEventsMask;
		    size= 4;
		    break;
		case XkbNamesNotify:
		    to.c16= &masks->namesNotifyMask;
		    legal= XkbAllNameEventsMask;
		    size= 2;
		    break;
		case XkbCompatMapNotify:
		    to.c8= &masks->compatNotifyMask;
		    legal= XkbAllCompatMapEventsMask;
		    size= 1;
		    break;
		case XkbBellNotify:
		    to.c8= &masks->bellNotifyMask;
		    legal= XkbAllBellEventsMask;
		    size= 1;
		    break;
		case XkbActionMessage:
		    to.c8= &masks->actionMessageMask;
		    legal= XkbAllActionMessagesMask;
		    size= 1;
		    break;
		case XkbAccessXNotify:
		    to.c16= &masks->accessXNotifyMask;
		    legal= XkbAllAccessXEventsMask;
		    size= 2;
		    break;
		case XkbExtensionDeviceNotify:
		    to.c16= &masks->extDevNotifyMask;
		    legal= XkbAllExtensionDeviceEventsMask;
		    size= 2;
		    break;
		default:
		    client->errorValue = _XkbErrCode2(33,bit);
		    return BadValue;
	    }

	    if (stuff->clear&bit) {
		if (size==2)		to.c16[0]= 0;
		else if (size==4)	to.c32[0]= 0;
		else			to.c8[0]=  0;
	    }
	    else if (stuff->selectAll&bit) {
		if (size==2)		to.c16[0]= ~0;
		else if (size==4)	to.c32[0]= ~0;
		else			to.c8[0]=  ~0;
	    }
	    else {
		if (dataLeft<(size*2))
		    return BadLength;
		if (size==2) {
		    CHK_MASK_MATCH(ndx,from.c16[0],from.c16[1]);
		    CHK_MASK_LEGAL(ndx,from.c16[0],legal);
		    to.c16[0]&= ~from.c16[0];
		    to.c16[0]|= (from.c16[0]&from.c16[1]);
		}
		else if (size==4) {
		    CHK_MASK_MATCH(ndx,from.c32[0],from.c32[1]);
		    CHK_MASK_LEGAL(ndx,from.c32[0],legal);
		    to.c32[0]&= ~from.c32[0];
		    to.c32[0]|= (from.c32[0]&from.c32[1]);
		}
		else  {
		    CHK_MASK_MATCH(ndx,from.c8[0],from.c8[1]);
		    CHK_MASK_LEGAL(ndx,from.c8[0],legal);
		    to.c8[0]&= ~from.c8[0];
		    to.c8[0]|= (from.c8[0]&from.c8[1]);
		    size= 2;
		}
		from.c8+= (size*2);
		dataLeft-= (size*2);
	    }
	}
	if (dataLeft>2) {
	    ErrorF("[xkb] Extra data (%d bytes) after SelectEvents\n",dataLeft);
	    return BadLength;
	}
	return Success;
    }
    return BadAlloc;
}

/***====================================================================***/
/**
 * Ring a bell on the given device for the given client.
 */
static int
_XkbBell(ClientPtr client, DeviceIntPtr dev, WindowPtr pWin,
         int bellClass, int bellID, int pitch, int duration,
         int percent, int forceSound, int eventOnly, Atom name)
{
    int         base;
    pointer     ctrl;
    int         oldPitch, oldDuration;
    int         newPercent;

    if (bellClass == KbdFeedbackClass) {
        KbdFeedbackPtr	k;
        if (bellID==XkbDfltXIId)
            k= dev->kbdfeed;
        else {
            for (k=dev->kbdfeed; k; k=k->next) {
                if (k->ctrl.id == bellID)
                    break;
            }
        }
        if (!k) {
            client->errorValue = _XkbErrCode2(0x5,bellID);
            return BadValue;
        }
        base = k->ctrl.bell;
        ctrl = (pointer) &(k->ctrl);
        oldPitch= k->ctrl.bell_pitch;
        oldDuration= k->ctrl.bell_duration;
        if (pitch!=0) {
            if (pitch==-1)
                k->ctrl.bell_pitch= defaultKeyboardControl.bell_pitch;
            else k->ctrl.bell_pitch= pitch;
        }
        if (duration!=0) {
            if (duration==-1)
                k->ctrl.bell_duration= defaultKeyboardControl.bell_duration;
            else k->ctrl.bell_duration= duration;
        }
    }
    else if (bellClass == BellFeedbackClass) {
        BellFeedbackPtr	b;
        if (bellID==XkbDfltXIId)
            b= dev->bell;
        else {
            for (b=dev->bell; b; b=b->next) {
                if (b->ctrl.id == bellID)
                    break;
            }
        }
        if (!b) {
            client->errorValue = _XkbErrCode2(0x6,bellID);
            return BadValue;
        }
        base = b->ctrl.percent;
        ctrl = (pointer) &(b->ctrl);
        oldPitch= b->ctrl.pitch;
        oldDuration= b->ctrl.duration;
        if (pitch!=0) {
            if (pitch==-1)
                b->ctrl.pitch= defaultKeyboardControl.bell_pitch;
            else b->ctrl.pitch= pitch;
        }
        if (duration!=0) {
            if (duration==-1)
                b->ctrl.duration= defaultKeyboardControl.bell_duration;
            else b->ctrl.duration= duration;
        }
    }
    else {
        client->errorValue = _XkbErrCode2(0x7, bellClass);
        return BadValue;
    }

    newPercent = (base * percent)/100;
    if (percent < 0)
         newPercent = base + newPercent;
    else newPercent = base - newPercent + percent;

    XkbHandleBell(forceSound, eventOnly,
                  dev, newPercent, ctrl, bellClass,
                  name, pWin, client);
    if ((pitch!=0)||(duration!=0)) {
        if (bellClass == KbdFeedbackClass) {
            KbdFeedbackPtr      k;
            k= (KbdFeedbackPtr)ctrl;
            if (pitch!=0)
                k->ctrl.bell_pitch= oldPitch;
            if (duration!=0)
                k->ctrl.bell_duration= oldDuration;
        }
        else {
            BellFeedbackPtr     b;
            b= (BellFeedbackPtr)ctrl;
            if (pitch!=0)
                b->ctrl.pitch= oldPitch;
            if (duration!=0)
                b->ctrl.duration= oldDuration;
        }
    }

    return Success;
}

int
ProcXkbBell(ClientPtr client)
{
    REQUEST(xkbBellReq);
    DeviceIntPtr dev;
    WindowPtr	 pWin;
    int rc;

    REQUEST_SIZE_MATCH(xkbBellReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_BELL_DEVICE(dev, stuff->deviceSpec, client, DixBellAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    /* device-independent checks request for sane values */
    if ((stuff->forceSound)&&(stuff->eventOnly)) {
	client->errorValue=_XkbErrCode3(0x1,stuff->forceSound,stuff->eventOnly);
	return BadMatch;
    }
    if (stuff->percent < -100 || stuff->percent > 100) {
	client->errorValue = _XkbErrCode2(0x2,stuff->percent);
	return BadValue;
    }
    if (stuff->duration<-1) {
	client->errorValue = _XkbErrCode2(0x3,stuff->duration);
	return BadValue;
    }
    if (stuff->pitch<-1) {
	client->errorValue = _XkbErrCode2(0x4,stuff->pitch);
	return BadValue;
    }

    if (stuff->bellClass == XkbDfltXIClass) {
	if (dev->kbdfeed!=NULL)
	     stuff->bellClass= KbdFeedbackClass;
	else stuff->bellClass= BellFeedbackClass;
    }

    if (stuff->window!=None) {
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success) {
	    client->errorValue= stuff->window;
	    return rc;
	}
    }
    else pWin= NULL;

    /* Client wants to ring a bell on the core keyboard?
       Ring the bell on the core keyboard (which does nothing, but if that
       fails the client is screwed anyway), and then on all extension devices.
       Fail if the core keyboard fails but not the extension devices.  this
       may cause some keyboards to ding and others to stay silent. Fix
       your client to use explicit keyboards to avoid this.

       dev is the device the client requested.
     */
    rc = _XkbBell(client, dev, pWin, stuff->bellClass, stuff->bellID,
                  stuff->pitch, stuff->duration, stuff->percent,
                  stuff->forceSound, stuff->eventOnly, stuff->name);

    if ((rc == Success) && ((stuff->deviceSpec == XkbUseCoreKbd) ||
                            (stuff->deviceSpec == XkbUseCorePtr)))
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixBellAccess);
                if (rc == Success)
                    _XkbBell(client, other, pWin, stuff->bellClass,
                             stuff->bellID, stuff->pitch, stuff->duration,
                             stuff->percent, stuff->forceSound,
                             stuff->eventOnly, stuff->name);
            }
        }
        rc = Success; /* reset to success, that's what we got for the VCK */
    }

    return rc;
}

/***====================================================================***/

int
ProcXkbGetState(ClientPtr client)
{
    REQUEST(xkbGetStateReq);
    DeviceIntPtr	dev;
    xkbGetStateReply	 rep;
    XkbStateRec		*xkb;

    REQUEST_SIZE_MATCH(xkbGetStateReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb= &dev->key->xkbInfo->state;
    memset(&rep, 0, sizeof(xkbGetStateReply));
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.mods = XkbStateFieldFromRec(xkb) & 0xff;
    rep.baseMods = xkb->base_mods;
    rep.lockedMods = xkb->locked_mods;
    rep.latchedMods = xkb->latched_mods;
    rep.group = xkb->group;
    rep.baseGroup = xkb->base_group;
    rep.latchedGroup = xkb->latched_group;
    rep.lockedGroup = xkb->locked_group;
    rep.compatState = xkb->compat_state;
    rep.ptrBtnState = xkb->ptr_buttons;
    if (client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swaps(&rep.ptrBtnState,n);
    }
    WriteToClient(client, SIZEOF(xkbGetStateReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

int
ProcXkbLatchLockState(ClientPtr client)
{
    int status;
    DeviceIntPtr dev, tmpd;
    XkbStateRec	oldState,*newState;
    CARD16 changed;
    xkbStateNotify sn;
    XkbEventCauseRec cause;

    REQUEST(xkbLatchLockStateReq);
    REQUEST_SIZE_MATCH(xkbLatchLockStateReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);
    CHK_MASK_MATCH(0x01, stuff->affectModLocks, stuff->modLocks);
    CHK_MASK_MATCH(0x01, stuff->affectModLatches, stuff->modLatches);

    status = Success;

    for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
        if ((tmpd == dev) || (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
            if (!tmpd->key || !tmpd->key->xkbInfo)
                continue;

            oldState = tmpd->key->xkbInfo->state;
            newState = &tmpd->key->xkbInfo->state;
            if (stuff->affectModLocks) {
                newState->locked_mods &= ~stuff->affectModLocks;
                newState->locked_mods |= (stuff->affectModLocks & stuff->modLocks);
            }
            if (status == Success && stuff->lockGroup)
                newState->locked_group = stuff->groupLock;
            if (status == Success && stuff->affectModLatches)
                status = XkbLatchModifiers(tmpd, stuff->affectModLatches,
                                           stuff->modLatches);
            if (status == Success && stuff->latchGroup)
                status = XkbLatchGroup(tmpd, stuff->groupLatch);

            if (status != Success)
                return status;

            XkbComputeDerivedState(tmpd->key->xkbInfo);

            changed = XkbStateChangedFlags(&oldState, newState);
            if (changed) {
                sn.keycode = 0;
                sn.eventType = 0;
                sn.requestMajor = XkbReqCode;
                sn.requestMinor = X_kbLatchLockState;
                sn.changed = changed;
                XkbSendStateNotify(tmpd, &sn);
                changed = XkbIndicatorsToUpdate(tmpd, changed, FALSE);
                if (changed) {
                    XkbSetCauseXkbReq(&cause, X_kbLatchLockState, client);
                    XkbUpdateIndicators(tmpd, changed, TRUE, NULL, &cause);
	        }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetControls(ClientPtr client)
{
    xkbGetControlsReply rep;
    XkbControlsPtr	xkb;
    DeviceIntPtr 	dev;
    register int 	n;

    REQUEST(xkbGetControlsReq);
    REQUEST_SIZE_MATCH(xkbGetControlsReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    
    xkb = dev->key->xkbInfo->desc->ctrls;
    rep.type = X_Reply;
    rep.length = bytes_to_int32(SIZEOF(xkbGetControlsReply)-
		  SIZEOF(xGenericReply));
    rep.sequenceNumber = client->sequence;
    rep.deviceID = ((DeviceIntPtr)dev)->id;
    rep.numGroups = xkb->num_groups;
    rep.groupsWrap = xkb->groups_wrap;
    rep.internalMods = xkb->internal.mask;
    rep.ignoreLockMods = xkb->ignore_lock.mask;
    rep.internalRealMods = xkb->internal.real_mods;
    rep.ignoreLockRealMods = xkb->ignore_lock.real_mods;
    rep.internalVMods = xkb->internal.vmods;
    rep.ignoreLockVMods = xkb->ignore_lock.vmods;
    rep.enabledCtrls = xkb->enabled_ctrls;
    rep.repeatDelay = xkb->repeat_delay;
    rep.repeatInterval = xkb->repeat_interval;
    rep.slowKeysDelay = xkb->slow_keys_delay;
    rep.debounceDelay = xkb->debounce_delay;
    rep.mkDelay = xkb->mk_delay;
    rep.mkInterval = xkb->mk_interval;
    rep.mkTimeToMax = xkb->mk_time_to_max;
    rep.mkMaxSpeed = xkb->mk_max_speed;
    rep.mkCurve = xkb->mk_curve;
    rep.mkDfltBtn = xkb->mk_dflt_btn;
    rep.axTimeout = xkb->ax_timeout;
    rep.axtCtrlsMask = xkb->axt_ctrls_mask;
    rep.axtCtrlsValues = xkb->axt_ctrls_values;
    rep.axtOptsMask = xkb->axt_opts_mask;
    rep.axtOptsValues = xkb->axt_opts_values;
    rep.axOptions = xkb->ax_options;
    memcpy(rep.perKeyRepeat,xkb->per_key_repeat,XkbPerKeyBitArraySize);
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length,n);
	swaps(&rep.internalVMods, n);
	swaps(&rep.ignoreLockVMods, n);
	swapl(&rep.enabledCtrls, n);
	swaps(&rep.repeatDelay, n);
	swaps(&rep.repeatInterval, n);
	swaps(&rep.slowKeysDelay, n);
	swaps(&rep.debounceDelay, n);
	swaps(&rep.mkDelay, n);
	swaps(&rep.mkInterval, n);
	swaps(&rep.mkTimeToMax, n);
	swaps(&rep.mkMaxSpeed, n);
	swaps(&rep.mkCurve, n);
	swaps(&rep.axTimeout, n);
	swapl(&rep.axtCtrlsMask, n);
	swapl(&rep.axtCtrlsValues, n);
	swaps(&rep.axtOptsMask, n);
	swaps(&rep.axtOptsValues, n);
	swaps(&rep.axOptions, n);
    }
    WriteToClient(client, SIZEOF(xkbGetControlsReply), (char *)&rep);
    return Success;
}

int
ProcXkbSetControls(ClientPtr client)
{
    DeviceIntPtr 	dev, tmpd;
    XkbSrvInfoPtr	xkbi;
    XkbControlsPtr	ctrl;
    XkbControlsRec	new,old;
    xkbControlsNotify	cn;
    XkbEventCauseRec	cause;
    XkbSrvLedInfoPtr	sli;

    REQUEST(xkbSetControlsReq);
    REQUEST_SIZE_MATCH(xkbSetControlsReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01, stuff->changeCtrls, XkbAllControlsMask);

    for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
        if (!tmpd->key || !tmpd->key->xkbInfo)
            continue;
        if ((tmpd == dev) || (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
            xkbi = tmpd->key->xkbInfo;
            ctrl = xkbi->desc->ctrls;
            new = *ctrl;
            XkbSetCauseXkbReq(&cause, X_kbSetControls, client);

            if (stuff->changeCtrls & XkbInternalModsMask) {
                CHK_MASK_MATCH(0x02, stuff->affectInternalMods,
                               stuff->internalMods);
                CHK_MASK_MATCH(0x03, stuff->affectInternalVMods,
                               stuff->internalVMods);

                new.internal.real_mods &= ~(stuff->affectInternalMods);
                new.internal.real_mods |= (stuff->affectInternalMods &
                                           stuff->internalMods);
                new.internal.vmods &= ~(stuff->affectInternalVMods);
                new.internal.vmods |= (stuff->affectInternalVMods &
                                       stuff->internalVMods);
                new.internal.mask = new.internal.real_mods |
                                    XkbMaskForVMask(xkbi->desc,
                                                    new.internal.vmods);
            }

            if (stuff->changeCtrls & XkbIgnoreLockModsMask) {
                CHK_MASK_MATCH(0x4, stuff->affectIgnoreLockMods,
                               stuff->ignoreLockMods);
                CHK_MASK_MATCH(0x5, stuff->affectIgnoreLockVMods,
                               stuff->ignoreLockVMods);

                new.ignore_lock.real_mods &= ~(stuff->affectIgnoreLockMods);
                new.ignore_lock.real_mods |= (stuff->affectIgnoreLockMods &
                                              stuff->ignoreLockMods);
                new.ignore_lock.vmods &= ~(stuff->affectIgnoreLockVMods);
                new.ignore_lock.vmods |= (stuff->affectIgnoreLockVMods &
                                          stuff->ignoreLockVMods);
                new.ignore_lock.mask = new.ignore_lock.real_mods |
                                       XkbMaskForVMask(xkbi->desc,
                                                       new.ignore_lock.vmods);
            }

            CHK_MASK_MATCH(0x06, stuff->affectEnabledCtrls,
                           stuff->enabledCtrls);
            if (stuff->affectEnabledCtrls) {
                CHK_MASK_LEGAL(0x07, stuff->affectEnabledCtrls,
                               XkbAllBooleanCtrlsMask);

                new.enabled_ctrls &= ~(stuff->affectEnabledCtrls);
                new.enabled_ctrls |= (stuff->affectEnabledCtrls &
                                      stuff->enabledCtrls);
            }

            if (stuff->changeCtrls & XkbRepeatKeysMask) {
                if (stuff->repeatDelay < 1 || stuff->repeatInterval < 1) {
                    client->errorValue = _XkbErrCode3(0x08, stuff->repeatDelay,
                                                      stuff->repeatInterval);
                    return BadValue;
                }

                new.repeat_delay = stuff->repeatDelay;
                new.repeat_interval = stuff->repeatInterval;
            }

            if (stuff->changeCtrls & XkbSlowKeysMask) {
                if (stuff->slowKeysDelay < 1) {
                    client->errorValue = _XkbErrCode2(0x09,
                                                      stuff->slowKeysDelay);
                    return BadValue;
                }

                new.slow_keys_delay = stuff->slowKeysDelay;
            }

            if (stuff->changeCtrls & XkbBounceKeysMask) {
                if (stuff->debounceDelay < 1) {
                    client->errorValue = _XkbErrCode2(0x0A,
                                                      stuff->debounceDelay);
                    return BadValue;
                }

                new.debounce_delay = stuff->debounceDelay;
            }

            if (stuff->changeCtrls & XkbMouseKeysMask) {
                if (stuff->mkDfltBtn > XkbMaxMouseKeysBtn) {
                    client->errorValue = _XkbErrCode2(0x0B, stuff->mkDfltBtn);
                    return BadValue;
                }

                new.mk_dflt_btn = stuff->mkDfltBtn;
            }

            if (stuff->changeCtrls & XkbMouseKeysAccelMask) {
                if (stuff->mkDelay < 1 || stuff->mkInterval < 1 ||
                    stuff->mkTimeToMax < 1 || stuff->mkMaxSpeed < 1 ||
                    stuff->mkCurve < -1000) {
                    client->errorValue = _XkbErrCode2(0x0C,0);
                    return BadValue;
                }

                new.mk_delay = stuff->mkDelay;
                new.mk_interval = stuff->mkInterval;
                new.mk_time_to_max = stuff->mkTimeToMax;
                new.mk_max_speed = stuff->mkMaxSpeed;
                new.mk_curve = stuff->mkCurve;
                AccessXComputeCurveFactor(xkbi, &new);
            }

            if (stuff->changeCtrls & XkbGroupsWrapMask) {
                unsigned act, num;

                act = XkbOutOfRangeGroupAction(stuff->groupsWrap);
                switch (act) {
                case XkbRedirectIntoRange:
                    num = XkbOutOfRangeGroupNumber(stuff->groupsWrap);
                    if (num >= new.num_groups) {
                        client->errorValue = _XkbErrCode3(0x0D, new.num_groups,
                                                          num);
                        return BadValue;
                    }
                case XkbWrapIntoRange:
                case XkbClampIntoRange:
                    break;
                default:
                    client->errorValue = _XkbErrCode2(0x0E, act);
                    return BadValue;
                }

                new.groups_wrap= stuff->groupsWrap;
            }

            CHK_MASK_LEGAL(0x0F, stuff->axOptions, XkbAX_AllOptionsMask);
            if (stuff->changeCtrls & XkbAccessXKeysMask) {
                new.ax_options = stuff->axOptions & XkbAX_AllOptionsMask;
            }
            else {
                if (stuff->changeCtrls & XkbStickyKeysMask) {
                    new.ax_options &= ~(XkbAX_SKOptionsMask);
                    new.ax_options |= (stuff->axOptions & XkbAX_SKOptionsMask);
                }
            
                if (stuff->changeCtrls & XkbAccessXFeedbackMask) {
                    new.ax_options &= ~(XkbAX_FBOptionsMask);
                    new.ax_options |= (stuff->axOptions & XkbAX_FBOptionsMask);
                }
            }

            if (stuff->changeCtrls & XkbAccessXTimeoutMask) {
                if (stuff->axTimeout < 1) {
                    client->errorValue = _XkbErrCode2(0x10, stuff->axTimeout);
                    return BadValue;
                }
                CHK_MASK_MATCH(0x11, stuff->axtCtrlsMask,
                               stuff->axtCtrlsValues);
                CHK_MASK_LEGAL(0x12, stuff->axtCtrlsMask,
                               XkbAllBooleanCtrlsMask);
                CHK_MASK_MATCH(0x13, stuff->axtOptsMask, stuff->axtOptsValues);
                CHK_MASK_LEGAL(0x14, stuff->axtOptsMask, XkbAX_AllOptionsMask);
                new.ax_timeout = stuff->axTimeout;
                new.axt_ctrls_mask = stuff->axtCtrlsMask;
                new.axt_ctrls_values = (stuff->axtCtrlsValues &
                                        stuff->axtCtrlsMask);
                new.axt_opts_mask = stuff->axtOptsMask;
                new.axt_opts_values = (stuff->axtOptsValues &
                                       stuff->axtOptsMask);
            }

            if (stuff->changeCtrls & XkbPerKeyRepeatMask) {
                memcpy(new.per_key_repeat, stuff->perKeyRepeat,
                       XkbPerKeyBitArraySize);
                if (xkbi->repeatKey &&
                    !BitIsOn(new.per_key_repeat, xkbi->repeatKey)) {
                    AccessXCancelRepeatKey(xkbi, xkbi->repeatKey);
                }
            }

            old= *ctrl;
            *ctrl= new;
            XkbDDXChangeControls(tmpd, &old, ctrl);

            if (XkbComputeControlsNotify(tmpd, &old, ctrl, &cn, FALSE)) {
                cn.keycode = 0;
                cn.eventType = 0;
                cn.requestMajor = XkbReqCode;
                cn.requestMinor = X_kbSetControls;
                XkbSendControlsNotify(tmpd, &cn);
            }

            sli = XkbFindSrvLedInfo(tmpd, XkbDfltXIClass, XkbDfltXIId, 0);
            if (sli)
                XkbUpdateIndicators(tmpd, sli->usesControls, TRUE, NULL,
                                    &cause);

            /* If sticky keys were disabled, clear all locks and latches */
            if ((old.enabled_ctrls & XkbStickyKeysMask) &&
                !(ctrl->enabled_ctrls & XkbStickyKeysMask))
                XkbClearAllLatchesAndLocks(tmpd, xkbi, TRUE, &cause);
        }
    }

    return Success;
}

/***====================================================================***/

static int
XkbSizeKeyTypes(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    XkbKeyTypeRec 	*type;
    unsigned		i,len;

    len= 0;
    if (((rep->present&XkbKeyTypesMask)==0)||(rep->nTypes<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->types)) {
	rep->present&= ~XkbKeyTypesMask;
	rep->firstType= rep->nTypes= 0;
	return 0;
    }
    type= &xkb->map->types[rep->firstType];
    for (i=0;i<rep->nTypes;i++,type++){
	len+= SIZEOF(xkbKeyTypeWireDesc);
	if (type->map_count>0) {
	    len+= (type->map_count*SIZEOF(xkbKTMapEntryWireDesc));
	    if (type->preserve)
		len+= (type->map_count*SIZEOF(xkbModsWireDesc));
	}
    }
    return len;
}

static char *
XkbWriteKeyTypes(	XkbDescPtr		xkb,
			xkbGetMapReply *	rep,
			char *			buf,
			ClientPtr 		client)
{
    XkbKeyTypePtr	type;
    unsigned		i;
    xkbKeyTypeWireDesc *wire;

    type= &xkb->map->types[rep->firstType];
    for (i=0;i<rep->nTypes;i++,type++) {
	register unsigned n;
	wire= (xkbKeyTypeWireDesc *)buf;
	wire->mask = type->mods.mask;
	wire->realMods = type->mods.real_mods;
	wire->virtualMods = type->mods.vmods;
	wire->numLevels = type->num_levels;
	wire->nMapEntries = type->map_count;
	wire->preserve = (type->preserve!=NULL);
	if (client->swapped) {
	    register int n;
	    swaps(&wire->virtualMods,n);
	}	

	buf= (char *)&wire[1];
	if (wire->nMapEntries>0) {
	    xkbKTMapEntryWireDesc *	wire;
	    XkbKTMapEntryPtr		entry;
	    wire= (xkbKTMapEntryWireDesc *)buf;
	    entry= type->map;
	    for (n=0;n<type->map_count;n++,wire++,entry++) {
		wire->active= entry->active;
		wire->mask= entry->mods.mask;
		wire->level= entry->level;
		wire->realMods= entry->mods.real_mods;
		wire->virtualMods= entry->mods.vmods;
		if (client->swapped) {
		    register int n;
		    swaps(&wire->virtualMods,n);
		}
	    }
	    buf= (char *)wire;
	    if (type->preserve!=NULL) {
		xkbModsWireDesc *	pwire;
		XkbModsPtr		preserve;
		pwire= (xkbModsWireDesc *)buf;
		preserve= type->preserve;
		for (n=0;n<type->map_count;n++,pwire++,preserve++) {
		    pwire->mask= preserve->mask;
		    pwire->realMods= preserve->real_mods;
		    pwire->virtualMods= preserve->vmods;
		    if (client->swapped) {
			register int n;
			swaps(&pwire->virtualMods,n);
		    }
		}
		buf= (char *)pwire;
	    }
	}
    }
    return buf;
}

static int
XkbSizeKeySyms(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    XkbSymMapPtr	symMap;
    unsigned		i,len;
    unsigned		nSyms,nSymsThisKey;

    if (((rep->present&XkbKeySymsMask)==0)||(rep->nKeySyms<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->key_sym_map)) {
	rep->present&= ~XkbKeySymsMask;
	rep->firstKeySym= rep->nKeySyms= 0;
	rep->totalSyms= 0;
	return 0;
    }
    len= rep->nKeySyms*SIZEOF(xkbSymMapWireDesc);
    symMap = &xkb->map->key_sym_map[rep->firstKeySym];
    for (i=nSyms=0;i<rep->nKeySyms;i++,symMap++) {
	if (symMap->offset!=0) {
	    nSymsThisKey= XkbNumGroups(symMap->group_info)*symMap->width;
	    nSyms+= nSymsThisKey;
	}
    }
    len+= nSyms*4;
    rep->totalSyms= nSyms;
    return len;
}

static int
XkbSizeVirtualMods(XkbDescPtr xkb,xkbGetMapReply *rep)
{
register unsigned i,nMods,bit;

    if (((rep->present&XkbVirtualModsMask)==0)||(rep->virtualMods==0)||
	(!xkb)||(!xkb->server)) {
	rep->present&= ~XkbVirtualModsMask;
	rep->virtualMods= 0;
	return 0;
    }
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
        if (rep->virtualMods&bit)
	    nMods++;
    }
    return XkbPaddedSize(nMods);
}

static char *
XkbWriteKeySyms(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,ClientPtr client)
{
register KeySym *	pSym;
XkbSymMapPtr		symMap;
xkbSymMapWireDesc *	outMap;
register unsigned	i;

    symMap = &xkb->map->key_sym_map[rep->firstKeySym];
    for (i=0;i<rep->nKeySyms;i++,symMap++) {
	outMap = (xkbSymMapWireDesc *)buf;
	outMap->ktIndex[0] = symMap->kt_index[0];
	outMap->ktIndex[1] = symMap->kt_index[1];
	outMap->ktIndex[2] = symMap->kt_index[2];
	outMap->ktIndex[3] = symMap->kt_index[3];
	outMap->groupInfo = symMap->group_info;
	outMap->width= symMap->width;
	outMap->nSyms = symMap->width*XkbNumGroups(symMap->group_info);
	buf= (char *)&outMap[1];
	if (outMap->nSyms==0)
	    continue;

	pSym = &xkb->map->syms[symMap->offset];
	memcpy((char *)buf,(char *)pSym,outMap->nSyms*4);
	if (client->swapped) {
	    register int n,nSyms= outMap->nSyms;
	    swaps(&outMap->nSyms,n);
	    while (nSyms-->0) {
		swapl(buf,n);
		buf+= 4;
	    }
	}
	else buf+= outMap->nSyms*4;
    }
    return buf;
}

static int
XkbSizeKeyActions(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned		i,len,nActs;
    register KeyCode	firstKey;

    if (((rep->present&XkbKeyActionsMask)==0)||(rep->nKeyActs<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->key_acts)) {
	rep->present&= ~XkbKeyActionsMask;
	rep->firstKeyAct= rep->nKeyActs= 0;
	rep->totalActs= 0;
	return 0;
    }
    firstKey= rep->firstKeyAct;
    for (nActs=i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+firstKey]!=0)
	    nActs+= XkbKeyNumActions(xkb,i+firstKey);
    }
    len= XkbPaddedSize(rep->nKeyActs)+(nActs*SIZEOF(xkbActionWireDesc));
    rep->totalActs= nActs;
    return len;
}

static char *
XkbWriteKeyActions(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
{
    unsigned		i;
    CARD8 *		numDesc;
    XkbAnyAction *	actDesc;

    numDesc = (CARD8 *)buf;
    for (i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+rep->firstKeyAct]==0)
	     numDesc[i] = 0;
	else numDesc[i] = XkbKeyNumActions(xkb,(i+rep->firstKeyAct));
    }
    buf+= XkbPaddedSize(rep->nKeyActs);

    actDesc = (XkbAnyAction *)buf;
    for (i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+rep->firstKeyAct]!=0) {
	    unsigned int num;
	    num = XkbKeyNumActions(xkb,(i+rep->firstKeyAct));
	    memcpy((char *)actDesc,
		   (char*)XkbKeyActionsPtr(xkb,(i+rep->firstKeyAct)),
		   num*SIZEOF(xkbActionWireDesc));
	    actDesc+= num;
	}
    }
    buf = (char *)actDesc;
    return buf;
}

static int
XkbSizeKeyBehaviors(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned		i,len,nBhvr;
    XkbBehavior *	bhv;

    if (((rep->present&XkbKeyBehaviorsMask)==0)||(rep->nKeyBehaviors<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->behaviors)) {
	rep->present&= ~XkbKeyBehaviorsMask;
	rep->firstKeyBehavior= rep->nKeyBehaviors= 0;
	rep->totalKeyBehaviors= 0;
	return 0;
    }
    bhv= &xkb->server->behaviors[rep->firstKeyBehavior];
    for (nBhvr=i=0;i<rep->nKeyBehaviors;i++,bhv++) {
	if (bhv->type!=XkbKB_Default)
	    nBhvr++;
    }
    len= nBhvr*SIZEOF(xkbBehaviorWireDesc);
    rep->totalKeyBehaviors= nBhvr;
    return len;
}

static char *
XkbWriteKeyBehaviors(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
{
    unsigned		i;
    xkbBehaviorWireDesc	*wire;
    XkbBehavior		*pBhvr;

    wire = (xkbBehaviorWireDesc *)buf;
    pBhvr= &xkb->server->behaviors[rep->firstKeyBehavior];
    for (i=0;i<rep->nKeyBehaviors;i++,pBhvr++) {
	if (pBhvr->type!=XkbKB_Default) {
	    wire->key=  i+rep->firstKeyBehavior;
	    wire->type= pBhvr->type;
	    wire->data= pBhvr->data;
	    wire++;
	}
    }
    buf = (char *)wire;
    return buf;
}

static int
XkbSizeExplicit(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned	i,len,nRtrn;

    if (((rep->present&XkbExplicitComponentsMask)==0)||(rep->nKeyExplicit<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->explicit)) {
	rep->present&= ~XkbExplicitComponentsMask;
	rep->firstKeyExplicit= rep->nKeyExplicit= 0;
	rep->totalKeyExplicit= 0;
	return 0;
    }
    for (nRtrn=i=0;i<rep->nKeyExplicit;i++) {
	if (xkb->server->explicit[i+rep->firstKeyExplicit]!=0)
	    nRtrn++;
    }
    rep->totalKeyExplicit= nRtrn;
    len= XkbPaddedSize(nRtrn*2); /* two bytes per non-zero explicit component */
    return len;
}

static char *
XkbWriteExplicit(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,ClientPtr client)
{
unsigned	i;
char *		start;
unsigned char *	pExp;

    start= buf;
    pExp= &xkb->server->explicit[rep->firstKeyExplicit];
    for (i=0;i<rep->nKeyExplicit;i++,pExp++) {
	if (*pExp!=0) {
	    *buf++= i+rep->firstKeyExplicit;
	    *buf++= *pExp;
	}
    }
    i= XkbPaddedSize(buf-start)-(buf-start); /* pad to word boundary */
    return buf+i;
}

static int
XkbSizeModifierMap(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned	i,len,nRtrn;

    if (((rep->present&XkbModifierMapMask)==0)||(rep->nModMapKeys<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->modmap)) {
	rep->present&= ~XkbModifierMapMask;
	rep->firstModMapKey= rep->nModMapKeys= 0;
	rep->totalModMapKeys= 0;
	return 0;
    }
    for (nRtrn=i=0;i<rep->nModMapKeys;i++) {
	if (xkb->map->modmap[i+rep->firstModMapKey]!=0)
	    nRtrn++;
    }
    rep->totalModMapKeys= nRtrn;
    len= XkbPaddedSize(nRtrn*2); /* two bytes per non-zero modmap component */
    return len;
}

static char *
XkbWriteModifierMap(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
{
unsigned	i;
char *		start;
unsigned char *	pMap;

    start= buf;
    pMap= &xkb->map->modmap[rep->firstModMapKey];
    for (i=0;i<rep->nModMapKeys;i++,pMap++) {
	if (*pMap!=0) {
	    *buf++= i+rep->firstModMapKey;
	    *buf++= *pMap;
	}
    }
    i= XkbPaddedSize(buf-start)-(buf-start); /* pad to word boundary */
    return buf+i;
}

static int
XkbSizeVirtualModMap(XkbDescPtr xkb,xkbGetMapReply *rep)
{
    unsigned	i,len,nRtrn;

    if (((rep->present&XkbVirtualModMapMask)==0)||(rep->nVModMapKeys<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->vmodmap)) {
	rep->present&= ~XkbVirtualModMapMask;
	rep->firstVModMapKey= rep->nVModMapKeys= 0;
	rep->totalVModMapKeys= 0;
	return 0;
    }
    for (nRtrn=i=0;i<rep->nVModMapKeys;i++) {
	if (xkb->server->vmodmap[i+rep->firstVModMapKey]!=0)
	    nRtrn++;
    }
    rep->totalVModMapKeys= nRtrn;
    len= nRtrn*SIZEOF(xkbVModMapWireDesc);
    return len;
}

static char *
XkbWriteVirtualModMap(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
{
unsigned		i;
xkbVModMapWireDesc *	wire;
unsigned short *	pMap;

    wire= (xkbVModMapWireDesc *)buf;
    pMap= &xkb->server->vmodmap[rep->firstVModMapKey];
    for (i=0;i<rep->nVModMapKeys;i++,pMap++) {
	if (*pMap!=0) {
	    wire->key= i+rep->firstVModMapKey;
	    wire->vmods= *pMap;
	    wire++;
	}
    }
    return (char *)wire;
}

static Status
XkbComputeGetMapReplySize(XkbDescPtr xkb,xkbGetMapReply *rep)
{
int	len;

    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    len= XkbSizeKeyTypes(xkb,rep);
    len+= XkbSizeKeySyms(xkb,rep);
    len+= XkbSizeKeyActions(xkb,rep);
    len+= XkbSizeKeyBehaviors(xkb,rep);
    len+= XkbSizeVirtualMods(xkb,rep);
    len+= XkbSizeExplicit(xkb,rep);
    len+= XkbSizeModifierMap(xkb,rep);
    len+= XkbSizeVirtualModMap(xkb,rep);
    rep->length+= (len/4);
    return Success;
}

static int
XkbSendMap(ClientPtr client,XkbDescPtr xkb,xkbGetMapReply *rep)
{
unsigned	i,len;
char		*desc,*start;

    len= (rep->length*4)-(SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply));
    start= desc= calloc(1, len);
    if (!start)
	return BadAlloc;
    if ( rep->nTypes>0 )
	desc = XkbWriteKeyTypes(xkb,rep,desc,client);
    if ( rep->nKeySyms>0 )
	desc = XkbWriteKeySyms(xkb,rep,desc,client);
    if ( rep->nKeyActs>0 )
	desc = XkbWriteKeyActions(xkb,rep,desc,client);
    if ( rep->totalKeyBehaviors>0 )
	desc = XkbWriteKeyBehaviors(xkb,rep,desc,client);
    if ( rep->virtualMods ) {
	register int sz,bit;
	for (i=sz=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	    if (rep->virtualMods&bit) {
		desc[sz++]= xkb->server->vmods[i];
	    }
	}
	desc+= XkbPaddedSize(sz);
    }
    if ( rep->totalKeyExplicit>0 )
	desc= XkbWriteExplicit(xkb,rep,desc,client);
    if ( rep->totalModMapKeys>0 )
	desc= XkbWriteModifierMap(xkb,rep,desc,client);
    if ( rep->totalVModMapKeys>0 )
	desc= XkbWriteVirtualModMap(xkb,rep,desc,client);
    if ((desc-start)!=(len)) {
	ErrorF("[xkb] BOGUS LENGTH in write keyboard desc, expected %d, got %ld\n",
					len, (unsigned long)(desc-start));
    }
    if (client->swapped) {
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swaps(&rep->present,n);
	swaps(&rep->totalSyms,n);
	swaps(&rep->totalActs,n);
    }
    WriteToClient(client, (i=SIZEOF(xkbGetMapReply)), (char *)rep);
    WriteToClient(client, len, start);
    free((char *)start);
    return Success;
}

int
ProcXkbGetMap(ClientPtr client)
{
    DeviceIntPtr	 dev;
    xkbGetMapReply	 rep;
    XkbDescRec		*xkb;
    int			 n,status;

    REQUEST(xkbGetMapReq);
    REQUEST_SIZE_MATCH(xkbGetMapReq);
    
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_OVERLAP(0x01,stuff->full,stuff->partial);
    CHK_MASK_LEGAL(0x02,stuff->full,XkbAllMapComponentsMask);
    CHK_MASK_LEGAL(0x03,stuff->partial,XkbAllMapComponentsMask);

    xkb= dev->key->xkbInfo->desc;
    memset(&rep, 0, sizeof(xkbGetMapReply));
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
    rep.length = (SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply))>>2;
    rep.deviceID = dev->id;
    rep.present = stuff->partial|stuff->full;
    rep.minKeyCode = xkb->min_key_code;
    rep.maxKeyCode = xkb->max_key_code;
    if ( stuff->full&XkbKeyTypesMask ) {
	rep.firstType = 0;
	rep.nTypes = xkb->map->num_types;
    }
    else if (stuff->partial&XkbKeyTypesMask) {
	if (((unsigned)stuff->firstType+stuff->nTypes)>xkb->map->num_types) {
	    client->errorValue = _XkbErrCode4(0x04,xkb->map->num_types,
					stuff->firstType,stuff->nTypes);
	    return BadValue;
	}
	rep.firstType = stuff->firstType;
	rep.nTypes = stuff->nTypes;
    }
    else rep.nTypes = 0;
    rep.totalTypes = xkb->map->num_types;

    n= XkbNumKeys(xkb);
    if ( stuff->full&XkbKeySymsMask ) {
	rep.firstKeySym = xkb->min_key_code;
	rep.nKeySyms = n;
    }
    else if (stuff->partial&XkbKeySymsMask) {
	CHK_KEY_RANGE(0x05,stuff->firstKeySym,stuff->nKeySyms,xkb);
	rep.firstKeySym = stuff->firstKeySym;
	rep.nKeySyms = stuff->nKeySyms;
    }
    else rep.nKeySyms = 0;
    rep.totalSyms= 0;

    if ( stuff->full&XkbKeyActionsMask ) {
	rep.firstKeyAct= xkb->min_key_code;
	rep.nKeyActs= n;
    }
    else if (stuff->partial&XkbKeyActionsMask) {
	CHK_KEY_RANGE(0x07,stuff->firstKeyAct,stuff->nKeyActs,xkb);
	rep.firstKeyAct= stuff->firstKeyAct;
	rep.nKeyActs= stuff->nKeyActs;
    }
    else rep.nKeyActs= 0;
    rep.totalActs= 0;

    if ( stuff->full&XkbKeyBehaviorsMask ) {
	rep.firstKeyBehavior = xkb->min_key_code;
	rep.nKeyBehaviors = n;
    }
    else if (stuff->partial&XkbKeyBehaviorsMask) {
	CHK_KEY_RANGE(0x09,stuff->firstKeyBehavior,stuff->nKeyBehaviors,xkb);
	rep.firstKeyBehavior= stuff->firstKeyBehavior;
	rep.nKeyBehaviors= stuff->nKeyBehaviors;
    }
    else rep.nKeyBehaviors = 0;
    rep.totalKeyBehaviors= 0;

    if (stuff->full&XkbVirtualModsMask)
	rep.virtualMods= ~0;
    else if (stuff->partial&XkbVirtualModsMask)
	rep.virtualMods= stuff->virtualMods;
    
    if (stuff->full&XkbExplicitComponentsMask) {
	rep.firstKeyExplicit= xkb->min_key_code;
	rep.nKeyExplicit= n;
    }
    else if (stuff->partial&XkbExplicitComponentsMask) {
	CHK_KEY_RANGE(0x0B,stuff->firstKeyExplicit,stuff->nKeyExplicit,xkb);
	rep.firstKeyExplicit= stuff->firstKeyExplicit;
	rep.nKeyExplicit= stuff->nKeyExplicit;
    }
    else rep.nKeyExplicit = 0;
    rep.totalKeyExplicit=  0;

    if (stuff->full&XkbModifierMapMask) {
	rep.firstModMapKey= xkb->min_key_code;
	rep.nModMapKeys= n;
    }
    else if (stuff->partial&XkbModifierMapMask) {
	CHK_KEY_RANGE(0x0D,stuff->firstModMapKey,stuff->nModMapKeys,xkb);
	rep.firstModMapKey= stuff->firstModMapKey;
	rep.nModMapKeys= stuff->nModMapKeys;
    }
    else rep.nModMapKeys = 0;
    rep.totalModMapKeys= 0;

    if (stuff->full&XkbVirtualModMapMask) {
	rep.firstVModMapKey= xkb->min_key_code;
	rep.nVModMapKeys= n;
    }
    else if (stuff->partial&XkbVirtualModMapMask) {
	CHK_KEY_RANGE(0x0F,stuff->firstVModMapKey,stuff->nVModMapKeys,xkb);
	rep.firstVModMapKey= stuff->firstVModMapKey;
	rep.nVModMapKeys= stuff->nVModMapKeys;
    }
    else rep.nVModMapKeys = 0;
    rep.totalVModMapKeys= 0;

    if ((status=XkbComputeGetMapReplySize(xkb,&rep))!=Success)
	return status;
    return XkbSendMap(client,xkb,&rep);
}

/***====================================================================***/

static int
CheckKeyTypes(	ClientPtr	client,
		XkbDescPtr	xkb,
		xkbSetMapReq *	req,
		xkbKeyTypeWireDesc **wireRtrn,
		int	 *	nMapsRtrn,
		CARD8 *		mapWidthRtrn)
{
unsigned		nMaps;
register unsigned	i,n;
register CARD8 *	map;
register xkbKeyTypeWireDesc	*wire = *wireRtrn;

    if (req->firstType>((unsigned)xkb->map->num_types)) {
	*nMapsRtrn = _XkbErrCode3(0x01,req->firstType,xkb->map->num_types);
	return 0;
    }
    if (req->flags&XkbSetMapResizeTypes) {
	nMaps = req->firstType+req->nTypes;
	if (nMaps<XkbNumRequiredTypes) {  /* canonical types must be there */
	    *nMapsRtrn= _XkbErrCode4(0x02,req->firstType,req->nTypes,4);
	    return 0;
	}
    }
    else if (req->present&XkbKeyTypesMask) {
	nMaps = xkb->map->num_types;
	if ((req->firstType+req->nTypes)>nMaps) {
	    *nMapsRtrn = req->firstType+req->nTypes;
	    return 0;
	}
    }
    else {
	*nMapsRtrn = xkb->map->num_types;
	for (i=0;i<xkb->map->num_types;i++) {
	    mapWidthRtrn[i] = xkb->map->types[i].num_levels;
	}
	return 1;
    }

    for (i=0;i<req->firstType;i++) {
	mapWidthRtrn[i] = xkb->map->types[i].num_levels;
    }
    for (i=0;i<req->nTypes;i++) {
	unsigned	width;
	if (client->swapped) {
	    register int s;
	    swaps(&wire->virtualMods,s);
	}
	n= i+req->firstType;
	width= wire->numLevels;
	if (width<1) {
	    *nMapsRtrn= _XkbErrCode3(0x04,n,width);
	    return 0;
	}
	else if ((n==XkbOneLevelIndex)&&(width!=1)) { /* must be width 1 */
	    *nMapsRtrn= _XkbErrCode3(0x05,n,width);
	    return 0;
	}
	else if ((width!=2)&&
		 ((n==XkbTwoLevelIndex)||(n==XkbKeypadIndex)||
		  (n==XkbAlphabeticIndex))) {
	    /* TWO_LEVEL, ALPHABETIC and KEYPAD must be width 2 */
	    *nMapsRtrn= _XkbErrCode3(0x05,n,width);
	    return 0;
	}
	if (wire->nMapEntries>0) {
	    xkbKTSetMapEntryWireDesc *	mapWire;
	    xkbModsWireDesc *		preWire;
	    mapWire= (xkbKTSetMapEntryWireDesc *)&wire[1];
	    preWire= (xkbModsWireDesc *)&mapWire[wire->nMapEntries];
	    for (n=0;n<wire->nMapEntries;n++) {
		if (client->swapped) {
		    register int s;
		    swaps(&mapWire[n].virtualMods,s);
		}
		if (mapWire[n].realMods&(~wire->realMods)) {
		    *nMapsRtrn= _XkbErrCode4(0x06,n,mapWire[n].realMods,
						 wire->realMods);
		    return 0;
		}
		if (mapWire[n].virtualMods&(~wire->virtualMods)) {
		    *nMapsRtrn= _XkbErrCode3(0x07,n,mapWire[n].virtualMods);
		    return 0;
		}
		if (mapWire[n].level>=wire->numLevels) {
		    *nMapsRtrn= _XkbErrCode4(0x08,n,wire->numLevels,
						 mapWire[n].level);
		    return 0;
		}
		if (wire->preserve) {
		    if (client->swapped) {
			register int s;
			swaps(&preWire[n].virtualMods,s);
		    }
		    if (preWire[n].realMods&(~mapWire[n].realMods)) {
			*nMapsRtrn= _XkbErrCode4(0x09,n,preWire[n].realMods,
							mapWire[n].realMods);
			return 0;
		    }
		    if (preWire[n].virtualMods&(~mapWire[n].virtualMods)) {
			*nMapsRtrn=_XkbErrCode3(0x0a,n,preWire[n].virtualMods);
			return 0;
		    }
		}
	    }
	    if (wire->preserve)
		 map= (CARD8 *)&preWire[wire->nMapEntries];
	    else map= (CARD8 *)&mapWire[wire->nMapEntries];
	}
	else map= (CARD8 *)&wire[1];
	mapWidthRtrn[i+req->firstType] = wire->numLevels;
	wire= (xkbKeyTypeWireDesc *)map;
    }
    for (i=req->firstType+req->nTypes;i<nMaps;i++) {
	mapWidthRtrn[i] = xkb->map->types[i].num_levels;
    }
    *nMapsRtrn = nMaps;
    *wireRtrn = wire;
    return 1;
}

static int
CheckKeySyms(	ClientPtr		client,
		XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		int			nTypes,
		CARD8 *	 		mapWidths,
		CARD16 *	 	symsPerKey,
		xkbSymMapWireDesc **	wireRtrn,
		int *			errorRtrn)
{
register unsigned	i;
XkbSymMapPtr		map;
xkbSymMapWireDesc*	wire = *wireRtrn;

    if (!(XkbKeySymsMask&req->present))
	return 1;
    CHK_REQ_KEY_RANGE2(0x11,req->firstKeySym,req->nKeySyms,req,(*errorRtrn),0);
    for (i=0;i<req->nKeySyms;i++) {
	KeySym *pSyms;
	register unsigned nG;
	if (client->swapped) {
	    swaps(&wire->nSyms,nG);
	}
	nG = XkbNumGroups(wire->groupInfo);
	if (nG>XkbNumKbdGroups) {
	    *errorRtrn = _XkbErrCode3(0x14,i+req->firstKeySym,nG);
	    return 0;
	}
	if (nG>0) {
	    register int g,w;
	    for (g=w=0;g<nG;g++) {
		if (wire->ktIndex[g]>=(unsigned)nTypes) {
		    *errorRtrn= _XkbErrCode4(0x15,i+req->firstKeySym,g,
		    					   wire->ktIndex[g]);
		    return 0;
		}
		if (mapWidths[wire->ktIndex[g]]>w)
		    w= mapWidths[wire->ktIndex[g]];
	    }
	    if (wire->width!=w) {
		*errorRtrn= _XkbErrCode3(0x16,i+req->firstKeySym,wire->width);
		return 0;
	    }
	    w*= nG;
	    symsPerKey[i+req->firstKeySym] = w;
	    if (w!=wire->nSyms) {
		*errorRtrn=_XkbErrCode4(0x16,i+req->firstKeySym,wire->nSyms,w);
		return 0;
	    }
	}
	else if (wire->nSyms!=0) {
	    *errorRtrn = _XkbErrCode3(0x17,i+req->firstKeySym,wire->nSyms);
	    return 0;
	}
	pSyms = (KeySym *)&wire[1];
	wire = (xkbSymMapWireDesc *)&pSyms[wire->nSyms];
    }

    map = &xkb->map->key_sym_map[i];
    for (;i<=(unsigned)xkb->max_key_code;i++,map++) {
	register int g,nG,w;
	nG= XkbKeyNumGroups(xkb,i);
	for (w=g=0;g<nG;g++)  {
	    if (map->kt_index[g]>=(unsigned)nTypes) {
		*errorRtrn = _XkbErrCode4(0x18,i,g,map->kt_index[g]);
		return 0;
	    }
	    if (mapWidths[map->kt_index[g]]>w)
		    w= mapWidths[map->kt_index[g]];
	}
	symsPerKey[i] = w*nG;
    }
    *wireRtrn = wire;
    return 1;
}

static int
CheckKeyActions(	XkbDescPtr	xkb,
			xkbSetMapReq *	req,
			int		nTypes,
			CARD8 *		mapWidths,
			CARD16 *	symsPerKey,
			CARD8 **	wireRtrn,
			int *		nActsRtrn)
{
int			 nActs;
CARD8 *			 wire = *wireRtrn;
register unsigned	 i;

    if (!(XkbKeyActionsMask&req->present))
	return 1;
    CHK_REQ_KEY_RANGE2(0x21,req->firstKeyAct,req->nKeyActs,req,(*nActsRtrn),0);
    for (nActs=i=0;i<req->nKeyActs;i++) {
	if (wire[0]!=0) {
	    if (wire[0]==symsPerKey[i+req->firstKeyAct])
		nActs+= wire[0];
	    else {
		*nActsRtrn= _XkbErrCode3(0x23,i+req->firstKeyAct,wire[0]);
		return 0;
	    }
	}
	wire++;
    }
    if (req->nKeyActs%4)
	wire+= 4-(req->nKeyActs%4);
    *wireRtrn = (CARD8 *)(((XkbAnyAction *)wire)+nActs);
    *nActsRtrn = nActs;
    return 1;
}

static int
CheckKeyBehaviors(	XkbDescPtr 		xkb,
			xkbSetMapReq *		req,
			xkbBehaviorWireDesc **	wireRtrn,
			int *			errorRtrn)
{
register xkbBehaviorWireDesc *	wire = *wireRtrn;
register XkbServerMapPtr	server = xkb->server;
register unsigned	 	i;
unsigned			first,last;

    if (((req->present&XkbKeyBehaviorsMask)==0)||(req->nKeyBehaviors<1)) {
	req->present&= ~XkbKeyBehaviorsMask;
	req->nKeyBehaviors= 0;
	return 1;
    }
    first= req->firstKeyBehavior;
    last=  req->firstKeyBehavior+req->nKeyBehaviors-1;
    if (first<req->minKeyCode) {
	*errorRtrn = _XkbErrCode3(0x31,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errorRtrn = _XkbErrCode3(0x32,last,req->maxKeyCode);
	return 0;
    }
	
    for (i=0;i<req->totalKeyBehaviors;i++,wire++) {
	if ((wire->key<first)||(wire->key>last)) {
	    *errorRtrn = _XkbErrCode4(0x33,first,last,wire->key);
	    return 0;
	}
	if ((wire->type&XkbKB_Permanent)&&
	    ((server->behaviors[wire->key].type!=wire->type)||
	     (server->behaviors[wire->key].data!=wire->data))) {
	    *errorRtrn = _XkbErrCode3(0x33,wire->key,wire->type);
	    return 0;
	}
	if ((wire->type==XkbKB_RadioGroup)&&
		((wire->data&(~XkbKB_RGAllowNone))>XkbMaxRadioGroups)) {
	    *errorRtrn= _XkbErrCode4(0x34,wire->key,wire->data,
							XkbMaxRadioGroups);
	    return 0;
	}
	if ((wire->type==XkbKB_Overlay1)||(wire->type==XkbKB_Overlay2)) {
	    CHK_KEY_RANGE2(0x35,wire->key,1,xkb,*errorRtrn,0);
	}
    }
    *wireRtrn = wire;
    return 1;
}

static int
CheckVirtualMods(	XkbDescRec *	xkb,
			xkbSetMapReq *	req,
			CARD8 **	wireRtrn,
			int *		errorRtrn)
{
register CARD8		*wire = *wireRtrn;
register unsigned 	 i,nMods,bit;

    if (((req->present&XkbVirtualModsMask)==0)||(req->virtualMods==0))
	return 1;
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (req->virtualMods&bit)
	    nMods++;
    }
    *wireRtrn= (wire+XkbPaddedSize(nMods));
    return 1;
}

static int
CheckKeyExplicit(	XkbDescPtr	xkb,
			xkbSetMapReq *	req,
			CARD8 **	wireRtrn,
			int	*	errorRtrn)
{
register CARD8 *	wire = *wireRtrn;
CARD8	*		start;
register unsigned 	i;
int			first,last;

    if (((req->present&XkbExplicitComponentsMask)==0)||(req->nKeyExplicit<1)) {
	req->present&= ~XkbExplicitComponentsMask;
	req->nKeyExplicit= 0;
	return 1;
    }
    first= req->firstKeyExplicit;
    last=  first+req->nKeyExplicit-1;
    if (first<req->minKeyCode) {
	*errorRtrn = _XkbErrCode3(0x51,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errorRtrn = _XkbErrCode3(0x52,last,req->maxKeyCode);
	return 0;
    }
    start= wire; 
    for (i=0;i<req->totalKeyExplicit;i++,wire+=2) {
	if ((wire[0]<first)||(wire[0]>last)) {
	    *errorRtrn = _XkbErrCode4(0x53,first,last,wire[0]);
	    return 0;
	}
	if (wire[1]&(~XkbAllExplicitMask)) {
	     *errorRtrn= _XkbErrCode3(0x52,~XkbAllExplicitMask,wire[1]);
	     return 0;
	}
    }
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    *wireRtrn= wire;
    return 1;
}

static int
CheckModifierMap(XkbDescPtr xkb,xkbSetMapReq *req,CARD8 **wireRtrn,int *errRtrn)
{
register CARD8 *	wire = *wireRtrn;
CARD8	*		start;
register unsigned 	i;
int			first,last;

    if (((req->present&XkbModifierMapMask)==0)||(req->nModMapKeys<1)) {
	req->present&= ~XkbModifierMapMask;
	req->nModMapKeys= 0;
	return 1;
    }
    first= req->firstModMapKey;
    last=  first+req->nModMapKeys-1;
    if (first<req->minKeyCode) {
	*errRtrn = _XkbErrCode3(0x61,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errRtrn = _XkbErrCode3(0x62,last,req->maxKeyCode);
	return 0;
    }
    start= wire; 
    for (i=0;i<req->totalModMapKeys;i++,wire+=2) {
	if ((wire[0]<first)||(wire[0]>last)) {
	    *errRtrn = _XkbErrCode4(0x63,first,last,wire[0]);
	    return 0;
	}
    }
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    *wireRtrn= wire;
    return 1;
}

static int
CheckVirtualModMap(	XkbDescPtr xkb,
			xkbSetMapReq *req,
			xkbVModMapWireDesc **wireRtrn,
			int *errRtrn)
{
register xkbVModMapWireDesc *	wire = *wireRtrn;
register unsigned 		i;
int				first,last;

    if (((req->present&XkbVirtualModMapMask)==0)||(req->nVModMapKeys<1)) {
	req->present&= ~XkbVirtualModMapMask;
	req->nVModMapKeys= 0;
	return 1;
    }
    first= req->firstVModMapKey;
    last=  first+req->nVModMapKeys-1;
    if (first<req->minKeyCode) {
	*errRtrn = _XkbErrCode3(0x71,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errRtrn = _XkbErrCode3(0x72,last,req->maxKeyCode);
	return 0;
    }
    for (i=0;i<req->totalVModMapKeys;i++,wire++) {
	if ((wire->key<first)||(wire->key>last)) {
	    *errRtrn = _XkbErrCode4(0x73,first,last,wire->key);
	    return 0;
	}
    }
    *wireRtrn= wire;
    return 1;
}

static char *
SetKeyTypes(	XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		xkbKeyTypeWireDesc *	wire,
		XkbChangesPtr		changes)
{
register unsigned	i;
unsigned		first,last;
CARD8			*map;

    if ((unsigned)(req->firstType+req->nTypes)>xkb->map->size_types) {
	i= req->firstType+req->nTypes;
	if (XkbAllocClientMap(xkb,XkbKeyTypesMask,i)!=Success) {
	    return NULL;
	}
    }
    if ((unsigned)(req->firstType+req->nTypes)>xkb->map->num_types)
	xkb->map->num_types= req->firstType+req->nTypes;

    for (i=0;i<req->nTypes;i++) {
	XkbKeyTypePtr		pOld;
	register unsigned 	n;

	if (XkbResizeKeyType(xkb,i+req->firstType,wire->nMapEntries,
				wire->preserve,wire->numLevels)!=Success) {
	    return NULL;
	}
	pOld = &xkb->map->types[i+req->firstType];
	map = (CARD8 *)&wire[1];

	pOld->mods.real_mods = wire->realMods;
	pOld->mods.vmods= wire->virtualMods;
	pOld->num_levels = wire->numLevels;
	pOld->map_count= wire->nMapEntries;

	pOld->mods.mask= pOld->mods.real_mods|
					XkbMaskForVMask(xkb,pOld->mods.vmods);

	if (wire->nMapEntries) {
	    xkbKTSetMapEntryWireDesc *mapWire;
	    xkbModsWireDesc *preWire;
	    unsigned tmp;
	    mapWire= (xkbKTSetMapEntryWireDesc *)map;
	    preWire= (xkbModsWireDesc *)&mapWire[wire->nMapEntries];
	    for (n=0;n<wire->nMapEntries;n++) {
		pOld->map[n].active= 1;
		pOld->map[n].mods.mask= mapWire[n].realMods;
		pOld->map[n].mods.real_mods= mapWire[n].realMods;
		pOld->map[n].mods.vmods= mapWire[n].virtualMods;
		pOld->map[n].level= mapWire[n].level;
		if (mapWire[n].virtualMods!=0) {
		    tmp= XkbMaskForVMask(xkb,mapWire[n].virtualMods);
		    pOld->map[n].active= (tmp!=0);
		    pOld->map[n].mods.mask|= tmp;
		}
		if (wire->preserve) {
		    pOld->preserve[n].real_mods= preWire[n].realMods;
		    pOld->preserve[n].vmods= preWire[n].virtualMods;
		    tmp= XkbMaskForVMask(xkb,preWire[n].virtualMods);
		    pOld->preserve[n].mask= preWire[n].realMods|tmp;
		}
	    }
	    if (wire->preserve)
		 map= (CARD8 *)&preWire[wire->nMapEntries];
	    else map= (CARD8 *)&mapWire[wire->nMapEntries];
	}
	else map= (CARD8 *)&wire[1];
	wire = (xkbKeyTypeWireDesc *)map;
    }
    first= req->firstType;
    last= first+req->nTypes-1; /* last changed type */
    if (changes->map.changed&XkbKeyTypesMask) {
	int oldLast;
	oldLast= changes->map.first_type+changes->map.num_types-1;
	if (changes->map.first_type<first)
	    first= changes->map.first_type;
	if (oldLast>last)
	    last= oldLast;
    }
    changes->map.changed|= XkbKeyTypesMask;
    changes->map.first_type = first;
    changes->map.num_types = (last-first)+1;
    return (char *)wire;
}

static char *
SetKeySyms(	ClientPtr		client,
		XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		xkbSymMapWireDesc *	wire,
		XkbChangesPtr 		changes,
		DeviceIntPtr		dev)
{
register unsigned 	i,s;
XkbSymMapPtr		oldMap;
KeySym *		newSyms;
KeySym *		pSyms;
unsigned		first,last;

    oldMap = &xkb->map->key_sym_map[req->firstKeySym];
    for (i=0;i<req->nKeySyms;i++,oldMap++) {
	pSyms = (KeySym *)&wire[1];
	if (wire->nSyms>0) {
	    newSyms = XkbResizeKeySyms(xkb,i+req->firstKeySym,wire->nSyms);
	    for (s=0;s<wire->nSyms;s++) {
		newSyms[s]= pSyms[s];
	    }
	    if (client->swapped) {
		int n;
		for (s=0;s<wire->nSyms;s++) {
		    swapl(&newSyms[s],n);
		}
	    }
	}
	oldMap->kt_index[0] = wire->ktIndex[0];
	oldMap->kt_index[1] = wire->ktIndex[1];
	oldMap->kt_index[2] = wire->ktIndex[2];
	oldMap->kt_index[3] = wire->ktIndex[3];
	oldMap->group_info = wire->groupInfo;
	oldMap->width = wire->width;
	wire= (xkbSymMapWireDesc *)&pSyms[wire->nSyms];
    }
    first= req->firstKeySym;
    last= first+req->nKeySyms-1;
    if (changes->map.changed&XkbKeySymsMask) {
	int oldLast= (changes->map.first_key_sym+changes->map.num_key_syms-1);
	if (changes->map.first_key_sym<first)
	    first= changes->map.first_key_sym;
	if (oldLast>last)
	    last= oldLast;
    }
    changes->map.changed|= XkbKeySymsMask;
    changes->map.first_key_sym = first;
    changes->map.num_key_syms = (last-first+1);

    s= 0;
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	if (XkbKeyNumGroups(xkb,i)>s)
	    s= XkbKeyNumGroups(xkb,i);
    }
    if (s!=xkb->ctrls->num_groups) {
	xkbControlsNotify	cn;
	XkbControlsRec		old;
	cn.keycode= 0;
	cn.eventType= 0;
	cn.requestMajor= XkbReqCode;
	cn.requestMinor= X_kbSetMap;
	old= *xkb->ctrls;
	xkb->ctrls->num_groups= s;
	if (XkbComputeControlsNotify(dev,&old,xkb->ctrls,&cn,FALSE))
	    XkbSendControlsNotify(dev,&cn);
    }
    return (char *)wire;
}

static char *
SetKeyActions(	XkbDescPtr	xkb,
		xkbSetMapReq *	req,
		CARD8 *		wire,
		XkbChangesPtr	changes)
{
register unsigned	i,first,last;
CARD8 *			nActs = wire;
XkbAction *		newActs;
    
    wire+= XkbPaddedSize(req->nKeyActs);
    for (i=0;i<req->nKeyActs;i++) {
	if (nActs[i]==0)
	    xkb->server->key_acts[i+req->firstKeyAct]= 0;
	else {
	    newActs= XkbResizeKeyActions(xkb,i+req->firstKeyAct,nActs[i]);
	    memcpy((char *)newActs,(char *)wire,
					nActs[i]*SIZEOF(xkbActionWireDesc));
	    wire+= nActs[i]*SIZEOF(xkbActionWireDesc);
	}
    }
    first= req->firstKeyAct;
    last= (first+req->nKeyActs-1);
    if (changes->map.changed&XkbKeyActionsMask) {
	int oldLast;
	oldLast= changes->map.first_key_act+changes->map.num_key_acts-1;
	if (changes->map.first_key_act<first)
	    first= changes->map.first_key_act;
	if (oldLast>last)
	    last= oldLast;
    }
    changes->map.changed|= XkbKeyActionsMask;
    changes->map.first_key_act= first;
    changes->map.num_key_acts= (last-first+1);
    return (char *)wire;
}

static char *
SetKeyBehaviors(	XkbSrvInfoPtr	 xkbi,
    			xkbSetMapReq	*req,
    			xkbBehaviorWireDesc	*wire,
    			XkbChangesPtr	 changes)
{
register unsigned i;
int maxRG = -1;
XkbDescPtr       xkb = xkbi->desc;
XkbServerMapPtr	 server = xkb->server;
unsigned	 first,last;

    first= req->firstKeyBehavior;
    last= req->firstKeyBehavior+req->nKeyBehaviors-1;
    memset(&server->behaviors[first], 0, req->nKeyBehaviors*sizeof(XkbBehavior));
    for (i=0;i<req->totalKeyBehaviors;i++) {
	if ((server->behaviors[wire->key].type&XkbKB_Permanent)==0) {
	    server->behaviors[wire->key].type= wire->type;
	    server->behaviors[wire->key].data= wire->data;
	    if ((wire->type==XkbKB_RadioGroup)&&(((int)wire->data)>maxRG))
		maxRG= wire->data + 1;
	}
	wire++;
    }

    if (maxRG>(int)xkbi->nRadioGroups) {
        int sz = maxRG*sizeof(XkbRadioGroupRec);
        if (xkbi->radioGroups)
             xkbi->radioGroups= realloc(xkbi->radioGroups,sz);
        else xkbi->radioGroups= calloc(1, sz);
        if (xkbi->radioGroups) {
             if (xkbi->nRadioGroups)
                 memset(&xkbi->radioGroups[xkbi->nRadioGroups], 0,
                        (maxRG-xkbi->nRadioGroups)*sizeof(XkbRadioGroupRec));
             xkbi->nRadioGroups= maxRG;
        }
        else xkbi->nRadioGroups= 0;
        /* should compute members here */
    }
    if (changes->map.changed&XkbKeyBehaviorsMask) {
	unsigned oldLast;
	oldLast= changes->map.first_key_behavior+
					changes->map.num_key_behaviors-1;
        if (changes->map.first_key_behavior<req->firstKeyBehavior)
             first= changes->map.first_key_behavior;
        if (oldLast>last)
            last= oldLast;
    }
    changes->map.changed|= XkbKeyBehaviorsMask;
    changes->map.first_key_behavior = first;
    changes->map.num_key_behaviors = (last-first+1);
    return (char *)wire;
}

static char *
SetVirtualMods(XkbSrvInfoPtr xkbi,xkbSetMapReq *req,CARD8 *wire,
						XkbChangesPtr changes)
{
register int 		i,bit,nMods;
XkbServerMapPtr		srv = xkbi->desc->server;

    if (((req->present&XkbVirtualModsMask)==0)||(req->virtualMods==0))
	return (char *)wire;
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (req->virtualMods&bit) {
	    if (srv->vmods[i]!=wire[nMods]) {
		changes->map.changed|= XkbVirtualModsMask;
		changes->map.vmods|= bit;
		srv->vmods[i]= wire[nMods];
	    }
	    nMods++;
	}
    }
    return (char *)(wire+XkbPaddedSize(nMods));
}

static char *
SetKeyExplicit(XkbSrvInfoPtr xkbi,xkbSetMapReq *req,CARD8 *wire,
							XkbChangesPtr changes)
{
register unsigned	i,first,last;
XkbServerMapPtr		xkb = xkbi->desc->server;
CARD8 *			start;

    start= wire;
    first= req->firstKeyExplicit;
    last=  req->firstKeyExplicit+req->nKeyExplicit-1;
    memset(&xkb->explicit[first], 0, req->nKeyExplicit);
    for (i=0;i<req->totalKeyExplicit;i++,wire+= 2) {
	xkb->explicit[wire[0]]= wire[1];
    }
    if (first>0) {
	if (changes->map.changed&XkbExplicitComponentsMask) {
	    int oldLast;
	    oldLast= changes->map.first_key_explicit+
					changes->map.num_key_explicit-1;
	    if (changes->map.first_key_explicit<first)
		first= changes->map.first_key_explicit;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_key_explicit= first;
	changes->map.num_key_explicit= (last-first)+1;
    }
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    return (char *)wire;
}

static char *
SetModifierMap(	XkbSrvInfoPtr	xkbi,
		xkbSetMapReq *	req,
		CARD8 *		wire,
		XkbChangesPtr	changes)
{
register unsigned	i,first,last;
XkbClientMapPtr		xkb = xkbi->desc->map;
CARD8 *			start;

    start= wire;
    first= req->firstModMapKey;
    last=  req->firstModMapKey+req->nModMapKeys-1;
    memset(&xkb->modmap[first], 0, req->nModMapKeys);
    for (i=0;i<req->totalModMapKeys;i++,wire+= 2) {
	xkb->modmap[wire[0]]= wire[1];
    }
    if (first>0) {
	if (changes->map.changed&XkbModifierMapMask) {
	    int oldLast;
	    oldLast= changes->map.first_modmap_key+
						changes->map.num_modmap_keys-1;
	    if (changes->map.first_modmap_key<first)
		first= changes->map.first_modmap_key;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_modmap_key= first;
	changes->map.num_modmap_keys= (last-first)+1;
    }
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    return (char *)wire;
}

static char *
SetVirtualModMap(	XkbSrvInfoPtr		xkbi,
			xkbSetMapReq *		req,
			xkbVModMapWireDesc *	wire,
			XkbChangesPtr 		changes)
{
register unsigned	i,first,last;
XkbServerMapPtr		srv = xkbi->desc->server;

    first= req->firstVModMapKey;
    last=  req->firstVModMapKey+req->nVModMapKeys-1;
    memset(&srv->vmodmap[first], 0, req->nVModMapKeys*sizeof(unsigned short));
    for (i=0;i<req->totalVModMapKeys;i++,wire++) {
	srv->vmodmap[wire->key]= wire->vmods;
    }
    if (first>0) {
	if (changes->map.changed&XkbVirtualModMapMask) {
	    int oldLast;
	    oldLast= changes->map.first_vmodmap_key+
					changes->map.num_vmodmap_keys-1;
	    if (changes->map.first_vmodmap_key<first)
		first= changes->map.first_vmodmap_key;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_vmodmap_key= first;
	changes->map.num_vmodmap_keys= (last-first)+1;
    }
    return (char *)wire;
}

/**
 * Check if the given request can be applied to the given device but don't
 * actually do anything..
 */
static int
_XkbSetMapChecks(ClientPtr client, DeviceIntPtr dev, xkbSetMapReq *req, char* values)
{
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;
    int                 error;
    int                 nTypes = 0, nActions;
    CARD8               mapWidths[XkbMaxLegalKeyCode + 1] = {0};
    CARD16              symsPerKey[XkbMaxLegalKeyCode + 1] = {0};
    XkbSymMapPtr        map;
    int                 i;

    xkbi= dev->key->xkbInfo;
    xkb = xkbi->desc;

    if ((xkb->min_key_code != req->minKeyCode)||
        (xkb->max_key_code != req->maxKeyCode)) {
	if (client->vMajor!=1) { /* pre 1.0 versions of Xlib have a bug */
	    req->minKeyCode= xkb->min_key_code;
	    req->maxKeyCode= xkb->max_key_code;
	}
	else {
	    if (!XkbIsLegalKeycode(req->minKeyCode)) {
		client->errorValue = _XkbErrCode3(2, req->minKeyCode, req->maxKeyCode);
		return BadValue;
	    }
	    if (req->minKeyCode > req->maxKeyCode) {
		client->errorValue = _XkbErrCode3(3, req->minKeyCode, req->maxKeyCode);
		return BadMatch;
	    }
	}
    }

    if ((req->present & XkbKeyTypesMask) &&
	(!CheckKeyTypes(client,xkb,req,(xkbKeyTypeWireDesc **)&values,
						&nTypes,mapWidths))) {
	client->errorValue = nTypes;
	return BadValue;
    }

    /* symsPerKey/mapWidths must be filled regardless of client-side flags */
    map = &xkb->map->key_sym_map[xkb->min_key_code];
    for (i=xkb->min_key_code;i<xkb->max_key_code;i++,map++) {
	register int g,ng,w;
	ng= XkbNumGroups(map->group_info);
	for (w=g=0;g<ng;g++) {
	    if (map->kt_index[g]>=(unsigned)nTypes) {
		client->errorValue = _XkbErrCode4(0x13,i,g,map->kt_index[g]);
		return 0;
	    }
	    if (mapWidths[map->kt_index[g]]>w)
		w= mapWidths[map->kt_index[g]];
	}
	symsPerKey[i] = w*ng;
    }

    if ((req->present & XkbKeySymsMask) &&
	(!CheckKeySyms(client,xkb,req,nTypes,mapWidths,symsPerKey,
					(xkbSymMapWireDesc **)&values,&error))) {
	client->errorValue = error;
	return BadValue;
    }

    if ((req->present & XkbKeyActionsMask) &&
	(!CheckKeyActions(xkb,req,nTypes,mapWidths,symsPerKey,
						(CARD8 **)&values,&nActions))) {
	client->errorValue = nActions;
	return BadValue;
    }

    if ((req->present & XkbKeyBehaviorsMask) &&
	(!CheckKeyBehaviors(xkb,req,(xkbBehaviorWireDesc**)&values,&error))) {
	client->errorValue = error;
	return BadValue;
    }

    if ((req->present & XkbVirtualModsMask) &&
	(!CheckVirtualMods(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbExplicitComponentsMask) &&
	(!CheckKeyExplicit(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbModifierMapMask) &&
	(!CheckModifierMap(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbVirtualModMapMask) &&
	(!CheckVirtualModMap(xkb,req,(xkbVModMapWireDesc **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }

    if (((values-((char *)req))/4)!= req->length) {
	ErrorF("[xkb] Internal error! Bad length in XkbSetMap (after check)\n");
	client->errorValue = values-((char *)&req[1]);
	return BadLength;
    }

    return Success;
}

/**
 * Apply the given request on the given device.
 */
static int
_XkbSetMap(ClientPtr client, DeviceIntPtr dev, xkbSetMapReq *req, char *values)
{
    XkbEventCauseRec	cause;
    XkbChangesRec	change;
    Bool		sentNKN;
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;

    xkbi= dev->key->xkbInfo;
    xkb = xkbi->desc;

    XkbSetCauseXkbReq(&cause,X_kbSetMap,client);
    memset(&change, 0, sizeof(change));
    sentNKN = FALSE;
    if ((xkb->min_key_code!=req->minKeyCode)||
        (xkb->max_key_code!=req->maxKeyCode)) {
	Status			status;
	xkbNewKeyboardNotify	nkn;
	nkn.deviceID = nkn.oldDeviceID = dev->id;
	nkn.oldMinKeyCode = xkb->min_key_code;
	nkn.oldMaxKeyCode = xkb->max_key_code;
	status= XkbChangeKeycodeRange(xkb, req->minKeyCode,
                                      req->maxKeyCode, &change);
	if (status != Success)
	    return status; /* oh-oh. what about the other keyboards? */
	nkn.minKeyCode = xkb->min_key_code;
	nkn.maxKeyCode = xkb->max_key_code;
	nkn.requestMajor = XkbReqCode;
	nkn.requestMinor = X_kbSetMap;
	nkn.changed = XkbNKN_KeycodesMask;
	XkbSendNewKeyboardNotify(dev,&nkn);
	sentNKN = TRUE;
    }

    if (req->present&XkbKeyTypesMask) {
	values = SetKeyTypes(xkb,req,(xkbKeyTypeWireDesc *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeySymsMask) {
	values = SetKeySyms(client,xkb,req,(xkbSymMapWireDesc *)values,&change,dev);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeyActionsMask) {
	values = SetKeyActions(xkb,req,(CARD8 *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeyBehaviorsMask) {
	values= SetKeyBehaviors(xkbi,req,(xkbBehaviorWireDesc *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbVirtualModsMask)
	values= SetVirtualMods(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbExplicitComponentsMask)
	values= SetKeyExplicit(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbModifierMapMask)
	values= SetModifierMap(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbVirtualModMapMask)
	values= SetVirtualModMap(xkbi,req,(xkbVModMapWireDesc *)values,&change);
    if (((values-((char *)req))/4)!=req->length) {
	ErrorF("[xkb] Internal error! Bad length in XkbSetMap (after set)\n");
	client->errorValue = values-((char *)&req[1]);
	return BadLength;
    }
    if (req->flags&XkbSetMapRecomputeActions) {
	KeyCode		first,last,firstMM,lastMM;
	if (change.map.num_key_syms>0) {
	    first= change.map.first_key_sym;
	    last= first+change.map.num_key_syms-1;
	}
	else first= last= 0;
	if (change.map.num_modmap_keys>0) {
	    firstMM= change.map.first_modmap_key;
	    lastMM= first+change.map.num_modmap_keys-1;
	}
	else firstMM= lastMM= 0;
	if ((last>0) && (lastMM>0)) {
	    if (firstMM<first)
		first= firstMM;
	    if (lastMM>last)
		last= lastMM;
	}
	else if (lastMM>0) {
	    first= firstMM;
	    last= lastMM;
	}
	if (last>0) {
	    unsigned check= 0;
	    XkbUpdateActions(dev,first,(last-first+1),&change,&check,&cause);
	    if (check)
		XkbCheckSecondaryEffects(xkbi,check,&change,&cause);
	}
    }
    if (!sentNKN)
	XkbSendNotification(dev,&change,&cause);

    return Success;
allocFailure:
    return BadAlloc;
}


int
ProcXkbSetMap(ClientPtr client)
{
    DeviceIntPtr	dev;
    char *		tmp;
    int                 rc;

    REQUEST(xkbSetMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01,stuff->present,XkbAllMapComponentsMask);

    tmp = (char *)&stuff[1];

    /* Check if we can to the SetMap on the requested device. If this
       succeeds, do the same thing for all extension devices (if needed).
       If any of them fails, fail.  */
    rc = _XkbSetMapChecks(client, dev, stuff, tmp);

    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetMapChecks(client, other, stuff, tmp);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* We know now that we will succed with the SetMap. In theory anyway. */
    rc = _XkbSetMap(client, dev, stuff, tmp);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                    _XkbSetMap(client, other, stuff, tmp);
                /* ignore rc. if the SetMap failed although the check above
                   reported true there isn't much we can do. we still need to
                   set all other devices, hoping that at least they stay in
                   sync. */
            }
        }
    }

    return Success;
}

/***====================================================================***/

static Status
XkbComputeGetCompatMapReplySize(	XkbCompatMapPtr 	compat,
					xkbGetCompatMapReply *	rep)
{
unsigned	 size,nGroups;

    nGroups= 0;
    if (rep->groups!=0) {
	register int i,bit;
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    if (rep->groups&bit)
		nGroups++;
	}
    }
    size= nGroups*SIZEOF(xkbModsWireDesc);
    size+= (rep->nSI*SIZEOF(xkbSymInterpretWireDesc));
    rep->length= size/4;
    return Success;
}

static int
XkbSendCompatMap(	ClientPtr 		client,
			XkbCompatMapPtr 	compat,
			xkbGetCompatMapReply *	rep)
{
char	*	data;
int		size;

    size= rep->length*4;
    if (size>0) {
	data = malloc(size);
	if (data) {
	    register unsigned i,bit;
	    xkbModsWireDesc *	grp;
	    XkbSymInterpretPtr	sym= &compat->sym_interpret[rep->firstSI];
	    xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *)data;
	    for (i=0;i<rep->nSI;i++,sym++,wire++) {
		wire->sym= sym->sym;
		wire->mods= sym->mods;
		wire->match= sym->match;
		wire->virtualMod= sym->virtual_mod;
		wire->flags= sym->flags;
		memcpy((char*)&wire->act,(char*)&sym->act,sz_xkbActionWireDesc);
		if (client->swapped) {
		    register int n;
		    swapl(&wire->sym,n);
		}
	    }
	    if (rep->groups) {
		grp = (xkbModsWireDesc *)wire;
		for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		    if (rep->groups&bit) {
			grp->mask= compat->groups[i].mask;
			grp->realMods= compat->groups[i].real_mods;
			grp->virtualMods= compat->groups[i].vmods;
			if (client->swapped) {
			    register int n;
			    swaps(&grp->virtualMods,n);
			}
			grp++;
		    }
		}
		wire= (xkbSymInterpretWireDesc*)grp;
	    }
	}
	else return BadAlloc;
    }
    else data= NULL;

    if (client->swapped) {
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swaps(&rep->firstSI,n);
	swaps(&rep->nSI,n);
	swaps(&rep->nTotalSI,n);
    }

    WriteToClient(client, SIZEOF(xkbGetCompatMapReply), (char *)rep);
    if (data) {
	WriteToClient(client, size, data);
	free((char *)data);
    }
    return Success;
}

int
ProcXkbGetCompatMap(ClientPtr client)
{
    xkbGetCompatMapReply 	rep;
    DeviceIntPtr 		dev;
    XkbDescPtr			xkb;
    XkbCompatMapPtr		compat;

    REQUEST(xkbGetCompatMapReq);
    REQUEST_SIZE_MATCH(xkbGetCompatMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb = dev->key->xkbInfo->desc;
    compat= xkb->compat;

    rep.type = X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.firstSI = stuff->firstSI;
    rep.nSI = stuff->nSI;
    if (stuff->getAllSI) {
	rep.firstSI = 0;
	rep.nSI = compat->num_si;
    }
    else if ((((unsigned)stuff->nSI)>0)&&
		((unsigned)(stuff->firstSI+stuff->nSI-1)>=compat->num_si)) {
	client->errorValue = _XkbErrCode2(0x05,compat->num_si);
	return BadValue;
    }
    rep.nTotalSI = compat->num_si;
    rep.groups= stuff->groups;
    XkbComputeGetCompatMapReplySize(compat,&rep);
    return XkbSendCompatMap(client,compat,&rep);
}

/**
 * Apply the given request on the given device.
 * If dryRun is TRUE, then value checks are performed, but the device isn't
 * modified.
 */
static int
_XkbSetCompatMap(ClientPtr client, DeviceIntPtr dev,
                 xkbSetCompatMapReq *req, char* data, BOOL dryRun)
{
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;
    XkbCompatMapPtr     compat;
    int                 nGroups;
    unsigned            i,bit;

    xkbi = dev->key->xkbInfo;
    xkb = xkbi->desc;
    compat = xkb->compat;

    if ((req->nSI>0)||(req->truncateSI)) {
	xkbSymInterpretWireDesc *wire;
	if (req->firstSI>compat->num_si) {
	    client->errorValue = _XkbErrCode2(0x02,compat->num_si);
	    return BadValue;
	}
	wire= (xkbSymInterpretWireDesc *)data;
	wire+= req->nSI;
	data = (char *)wire;
    }

    nGroups= 0;
    if (req->groups!=0) {
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    if ( req->groups&bit )
		nGroups++;
	}
    }
    data+= nGroups*SIZEOF(xkbModsWireDesc);
    if (((data-((char *)req))/4)!=req->length) {
	return BadLength;
    }

    /* Done all the checks we can do */
    if (dryRun)
        return Success;

    data = (char *)&req[1];
    if (req->nSI>0) {
	xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *)data;
	XkbSymInterpretPtr	sym;
	unsigned int		skipped = 0;
	if ((unsigned)(req->firstSI+req->nSI)>compat->num_si) {
	    compat->num_si= req->firstSI+req->nSI;
	    compat->sym_interpret= realloc(compat->sym_interpret,
					    compat->num_si * sizeof(XkbSymInterpretRec));
	    if (!compat->sym_interpret) {
		compat->num_si= 0;
		return BadAlloc;
	    }
	}
	else if (req->truncateSI) {
	    compat->num_si = req->firstSI+req->nSI;
	}
	sym = &compat->sym_interpret[req->firstSI];
	for (i=0;i<req->nSI;i++,wire++) {
	    if (client->swapped) {
		int n;
		swapl(&wire->sym,n);
	    }
	    if (wire->sym == NoSymbol && wire->match == XkbSI_AnyOfOrNone &&
		(wire->mods & 0xff) == 0xff &&
		wire->act.type == XkbSA_XFree86Private) {
		ErrorF("XKB: Skipping broken Any+AnyOfOrNone(All) -> Private "
		       "action from client\n");
		skipped++;
		continue;
	    }
	    sym->sym= wire->sym;
	    sym->mods= wire->mods;
	    sym->match= wire->match;
	    sym->flags= wire->flags;
	    sym->virtual_mod= wire->virtualMod;
	    memcpy((char *)&sym->act,(char *)&wire->act,
                   SIZEOF(xkbActionWireDesc));
            sym++;
	}
	if (skipped) {
	    if (req->firstSI + req->nSI < compat->num_si)
		memmove(sym, sym + skipped,
	                (compat->num_si - req->firstSI - req->nSI) *
			 sizeof(*sym));
	    compat->num_si -= skipped;
	}
	data = (char *)wire;
    }
    else if (req->truncateSI) {
	compat->num_si = req->firstSI;
    }

    if (req->groups!=0) {
	unsigned i, bit;
	xkbModsWireDesc *wire = (xkbModsWireDesc *)data;
	for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
	    if (req->groups & bit) {
		if (client->swapped) {
		    int n;
		    swaps(&wire->virtualMods,n);
		}
		compat->groups[i].mask= wire->realMods;
		compat->groups[i].real_mods= wire->realMods;
		compat->groups[i].vmods= wire->virtualMods;
		if (wire->virtualMods!=0) {
		    unsigned tmp;
		    tmp= XkbMaskForVMask(xkb,wire->virtualMods);
		    compat->groups[i].mask|= tmp;
		}
		data+= SIZEOF(xkbModsWireDesc);
		wire= (xkbModsWireDesc *)data;
	    }
	}
    }
    i= XkbPaddedSize((data-((char *)req)));
    if ((i/4)!=req->length) {
	ErrorF("[xkb] Internal length error on read in _XkbSetCompatMap\n");
	return BadLength;
    }

    if (dev->xkb_interest) {
	xkbCompatMapNotify ev;
	ev.deviceID = dev->id;
	ev.changedGroups = req->groups;
	ev.firstSI = req->firstSI;
	ev.nSI = req->nSI;
	ev.nTotalSI = compat->num_si;
	XkbSendCompatMapNotify(dev,&ev);
    }

    if (req->recomputeActions) {
	XkbChangesRec		change;
	unsigned		check;
	XkbEventCauseRec	cause;

	XkbSetCauseXkbReq(&cause,X_kbSetCompatMap,client);
	memset(&change, 0, sizeof(XkbChangesRec));
	XkbUpdateActions(dev,xkb->min_key_code,XkbNumKeys(xkb),&change,&check,
									&cause);
	if (check)
	    XkbCheckSecondaryEffects(xkbi,check,&change,&cause);
	XkbSendNotification(dev,&change,&cause);
    }
    return Success;
}

int
ProcXkbSetCompatMap(ClientPtr client)
{
    DeviceIntPtr        dev;
    char                *data;
    int                 rc;

    REQUEST(xkbSetCompatMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetCompatMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);

    data = (char *)&stuff[1];

    /* check first using a dry-run */
    rc = _XkbSetCompatMap(client, dev, stuff, data, TRUE);
    if (rc != Success)
        return rc;
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    /* dry-run */
                    rc = _XkbSetCompatMap(client, other, stuff, data, TRUE);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* Yay, the dry-runs succeed. Let's apply */
    rc = _XkbSetCompatMap(client, dev, stuff, data, FALSE);
    if (rc != Success)
        return rc;
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetCompatMap(client, other, stuff, data, FALSE);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetIndicatorState(ClientPtr client)
{
    xkbGetIndicatorStateReply 	rep;
    XkbSrvLedInfoPtr		sli;
    DeviceIntPtr 		dev;
    register int 		i;

    REQUEST(xkbGetIndicatorStateReq);
    REQUEST_SIZE_MATCH(xkbGetIndicatorStateReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixReadAccess);

    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,
						XkbXI_IndicatorStateMask);
    if (!sli)
	return BadAlloc;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.state = sli->effectiveState;

    if (client->swapped) {
	swaps(&rep.sequenceNumber,i);
	swapl(&rep.state,i);
    }
    WriteToClient(client, SIZEOF(xkbGetIndicatorStateReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

static Status
XkbComputeGetIndicatorMapReplySize(
    XkbIndicatorPtr		indicators,
    xkbGetIndicatorMapReply	*rep)
{
register int 	i,bit;
int		nIndicators;

    rep->realIndicators = indicators->phys_indicators;
    for (i=nIndicators=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (rep->which&bit)
	    nIndicators++;
    }
    rep->length = (nIndicators*SIZEOF(xkbIndicatorMapWireDesc))/4;
    return Success;
}

static int
XkbSendIndicatorMap(	ClientPtr			client,
			XkbIndicatorPtr			indicators,
			xkbGetIndicatorMapReply *	rep)
{
int 			length;
CARD8 *			map;
register int		i;
register unsigned	bit;

    length = rep->length*4;
    if (length>0) {
	CARD8 *to;
	to= map= malloc(length);
	if (map) {
	    xkbIndicatorMapWireDesc  *wire = (xkbIndicatorMapWireDesc *)to;
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		if (rep->which&bit) {
		    wire->flags= indicators->maps[i].flags;
		    wire->whichGroups= indicators->maps[i].which_groups;
		    wire->groups= indicators->maps[i].groups;
		    wire->whichMods= indicators->maps[i].which_mods;
		    wire->mods= indicators->maps[i].mods.mask;
		    wire->realMods= indicators->maps[i].mods.real_mods;
		    wire->virtualMods= indicators->maps[i].mods.vmods;
		    wire->ctrls= indicators->maps[i].ctrls;
		    if (client->swapped) {
			register int n;
			swaps(&wire->virtualMods,n);
			swapl(&wire->ctrls,n);
		    }
		    wire++;
		}
	    }
	    to = (CARD8 *)wire;
	    if ((to-map)!=length) {
		client->errorValue = _XkbErrCode2(0xff,length);
		free(map);
		return BadLength;
	    }
	}
	else return BadAlloc;
    }
    else map = NULL;
    if (client->swapped) {
	swaps(&rep->sequenceNumber,i);
	swapl(&rep->length,i);
	swapl(&rep->which,i);
	swapl(&rep->realIndicators,i);
    }
    WriteToClient(client, SIZEOF(xkbGetIndicatorMapReply), (char *)rep);
    if (map) {
	WriteToClient(client, length, (char *)map);
	free((char *)map);
    }
    return Success;
}

int
ProcXkbGetIndicatorMap(ClientPtr client)
{
xkbGetIndicatorMapReply rep;
DeviceIntPtr		dev;
XkbDescPtr		xkb;
XkbIndicatorPtr		leds;

    REQUEST(xkbGetIndicatorMapReq);
    REQUEST_SIZE_MATCH(xkbGetIndicatorMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb= dev->key->xkbInfo->desc;
    leds= xkb->indicators;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.which = stuff->which;
    XkbComputeGetIndicatorMapReplySize(leds,&rep);
    return XkbSendIndicatorMap(client,leds,&rep);
}

/**
 * Apply the given map to the given device. Which specifies which components
 * to apply.
 */
static int
_XkbSetIndicatorMap(ClientPtr client, DeviceIntPtr dev,
                    int which, xkbIndicatorMapWireDesc *desc)
{
    XkbSrvInfoPtr       xkbi;
    XkbSrvLedInfoPtr    sli;
    XkbEventCauseRec    cause;
    int                 i, bit;

    xkbi = dev->key->xkbInfo;

    sli= XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId,
						XkbXI_IndicatorMapsMask);
    if (!sli)
	return BadAlloc;

    for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
	if (which & bit) {
	    sli->maps[i].flags = desc->flags;
	    sli->maps[i].which_groups = desc->whichGroups;
	    sli->maps[i].groups = desc->groups;
	    sli->maps[i].which_mods = desc->whichMods;
	    sli->maps[i].mods.mask = desc->mods;
	    sli->maps[i].mods.real_mods = desc->mods;
	    sli->maps[i].mods.vmods= desc->virtualMods;
	    sli->maps[i].ctrls = desc->ctrls;
	    if (desc->virtualMods!=0) {
		unsigned tmp;
		tmp= XkbMaskForVMask(xkbi->desc,desc->virtualMods);
		sli->maps[i].mods.mask= desc->mods|tmp;
	    }
	    desc++;
	}
    }

    XkbSetCauseXkbReq(&cause,X_kbSetIndicatorMap,client);
    XkbApplyLedMapChanges(dev,sli,which,NULL,NULL,&cause);

    return Success;
}

int
ProcXkbSetIndicatorMap(ClientPtr client)
{
    int                 i, bit;
    int                 nIndicators;
    DeviceIntPtr        dev;
    xkbIndicatorMapWireDesc     *from;
    int                 rc;

    REQUEST(xkbSetIndicatorMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetIndicatorMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);

    if (stuff->which==0)
	return Success;

    for (nIndicators=i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (stuff->which&bit)
	    nIndicators++;
    }
    if (stuff->length!=((SIZEOF(xkbSetIndicatorMapReq)+
			(nIndicators*SIZEOF(xkbIndicatorMapWireDesc)))/4)) {
	return BadLength;
    }

    from = (xkbIndicatorMapWireDesc *)&stuff[1];
    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (stuff->which&bit) {
	    if (client->swapped) {
		int n;
		swaps(&from->virtualMods,n);
		swapl(&from->ctrls,n);
	    }
	    CHK_MASK_LEGAL(i,from->whichGroups,XkbIM_UseAnyGroup);
	    CHK_MASK_LEGAL(i,from->whichMods,XkbIM_UseAnyMods);
	    from++;
	}
    }

    from = (xkbIndicatorMapWireDesc *)&stuff[1];
    rc = _XkbSetIndicatorMap(client, dev, stuff->which, from);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess);
                if (rc == Success)
                    _XkbSetIndicatorMap(client, other, stuff->which, from);
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetNamedIndicator(ClientPtr client)
{
    DeviceIntPtr 		dev;
    xkbGetNamedIndicatorReply 	rep;
    register int		i = 0;
    XkbSrvLedInfoPtr		sli;
    XkbIndicatorMapPtr		map = NULL;

    REQUEST(xkbGetNamedIndicatorReq);
    REQUEST_SIZE_MATCH(xkbGetNamedIndicatorReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_LED_DEVICE(dev, stuff->deviceSpec, client, DixReadAccess);
    CHK_ATOM_ONLY(stuff->indicator);

    sli= XkbFindSrvLedInfo(dev,stuff->ledClass,stuff->ledID,0);
    if (!sli)
	return BadAlloc;

    i= 0;
    map= NULL;
    if ((sli->names)&&(sli->maps)) {
        for (i=0;i<XkbNumIndicators;i++) {
            if (stuff->indicator==sli->names[i]) {
                map= &sli->maps[i];
                break;
            }
        }
    }

    rep.type= X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.deviceID = dev->id;
    rep.indicator= stuff->indicator;
    if (map!=NULL) {
	rep.found= 		TRUE;
	rep.on=			((sli->effectiveState&(1<<i))!=0);
	rep.realIndicator=	((sli->physIndicators&(1<<i))!=0);
	rep.ndx= 		i;
	rep.flags= 		map->flags;
	rep.whichGroups= 	map->which_groups;
	rep.groups= 		map->groups;
	rep.whichMods= 		map->which_mods;
	rep.mods= 		map->mods.mask;
	rep.realMods= 		map->mods.real_mods;
	rep.virtualMods= 	map->mods.vmods;
	rep.ctrls= 		map->ctrls;
	rep.supported= 		TRUE;
    }
    else  {
	rep.found= 		FALSE;
	rep.on= 		FALSE;
	rep.realIndicator= 	FALSE;
	rep.ndx= 		XkbNoIndicator;
	rep.flags= 		0;
	rep.whichGroups= 	0;
	rep.groups= 		0;
	rep.whichMods= 		0;
	rep.mods=		0;
	rep.realMods= 		0;
	rep.virtualMods= 	0;
	rep.ctrls= 		0;
	rep.supported= 		TRUE;
    }
    if ( client->swapped ) {
	register int n;
	swapl(&rep.length,n);
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.indicator,n);
	swaps(&rep.virtualMods,n);
	swapl(&rep.ctrls,n);
    }

    WriteToClient(client,SIZEOF(xkbGetNamedIndicatorReply), (char *)&rep);
    return Success;
}


/**
 * Find the IM on the device.
 * Returns the map, or NULL if the map doesn't exist.
 * If the return value is NULL, led_return is undefined. Otherwise, led_return
 * is set to the led index of the map.
 */
static XkbIndicatorMapPtr
_XkbFindNamedIndicatorMap(XkbSrvLedInfoPtr sli, Atom indicator,
                          int *led_return)
{
    XkbIndicatorMapPtr  map;

    /* search for the right indicator */
    map = NULL;
    if (sli->names && sli->maps) {
	int led;

	for (led = 0; (led < XkbNumIndicators) && (map == NULL); led++) {
	    if (sli->names[led] == indicator) {
		map= &sli->maps[led];
		*led_return = led;
		break;
	    }
	}
    }

    return map;
}

/**
 * Creates an indicator map on the device. If dryRun is TRUE, it only checks
 * if creation is possible, but doesn't actually create it.
 */
static int
_XkbCreateIndicatorMap(DeviceIntPtr dev, Atom indicator,
                       int ledClass, int ledID,
                       XkbIndicatorMapPtr *map_return, int *led_return,
                       Bool dryRun)
{
    XkbSrvLedInfoPtr    sli;
    XkbIndicatorMapPtr  map;
    int                 led;

    sli = XkbFindSrvLedInfo(dev, ledClass, ledID, XkbXI_IndicatorsMask);
    if (!sli)
        return BadAlloc;

    map = _XkbFindNamedIndicatorMap(sli, indicator, &led);

    if (!map)
    {
        /* find first unused indicator maps and assign the name to it */
        for (led = 0, map = NULL; (led < XkbNumIndicators) && (map == NULL); led++) {
            if ((sli->names) && (sli->maps) && (sli->names[led] == None) &&
                    (!XkbIM_InUse(&sli->maps[led])))
            {
                map = &sli->maps[led];
                if (!dryRun)
                    sli->names[led] = indicator;
                break;
            }
        }
    }

    if (!map)
        return BadAlloc;

    *led_return = led;
    *map_return = map;
    return Success;
}

static int
_XkbSetNamedIndicator(ClientPtr client, DeviceIntPtr dev,
                      xkbSetNamedIndicatorReq *stuff)
{
    unsigned int                extDevReason;
    unsigned int                statec, namec, mapc;
    XkbSrvLedInfoPtr            sli;
    int                         led = 0;
    XkbIndicatorMapPtr          map;
    DeviceIntPtr                kbd;
    XkbEventCauseRec            cause;
    xkbExtensionDeviceNotify    ed;
    XkbChangesRec               changes;
    int                         rc;

    rc = _XkbCreateIndicatorMap(dev, stuff->indicator, stuff->ledClass,
                                stuff->ledID, &map, &led, FALSE);
    if (rc != Success || !map) /* oh-oh */
        return rc;

    sli = XkbFindSrvLedInfo(dev, stuff->ledClass, stuff->ledID,
                            XkbXI_IndicatorsMask);
    if (!sli)
        return BadAlloc;

    namec = mapc = statec = 0;
    extDevReason = 0;

    namec |= (1<<led);
    sli->namesPresent |= ((stuff->indicator != None) ? (1 << led) : 0);
    extDevReason |= XkbXI_IndicatorNamesMask;

    if (stuff->setMap) {
        map->flags = stuff->flags;
        map->which_groups = stuff->whichGroups;
        map->groups = stuff->groups;
        map->which_mods = stuff->whichMods;
        map->mods.mask = stuff->realMods;
        map->mods.real_mods = stuff->realMods;
        map->mods.vmods= stuff->virtualMods;
        map->ctrls = stuff->ctrls;
        mapc|= (1<<led);
    }

    if ((stuff->setState) && ((map->flags & XkbIM_NoExplicit) == 0))
    {
        if (stuff->on)	sli->explicitState |=  (1<<led);
        else		sli->explicitState &= ~(1<<led);
        statec |= ((sli->effectiveState ^ sli->explicitState) & (1 << led));
    }

    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    XkbSetCauseXkbReq(&cause,X_kbSetNamedIndicator,client);
    if (namec)
        XkbApplyLedNameChanges(dev,sli,namec,&ed,&changes,&cause);
    if (mapc)
        XkbApplyLedMapChanges(dev,sli,mapc,&ed,&changes,&cause);
    if (statec)
        XkbApplyLedStateChanges(dev,sli,statec,&ed,&changes,&cause);

    kbd = dev;
    if ((sli->flags&XkbSLI_HasOwnState)==0)
        kbd = inputInfo.keyboard;
    XkbFlushLedEvents(dev, kbd, sli, &ed, &changes, &cause);

    return Success;
}

int
ProcXkbSetNamedIndicator(ClientPtr client)
{
    int                         rc;
    DeviceIntPtr                dev;
    int                         led = 0;
    XkbIndicatorMapPtr          map;

    REQUEST(xkbSetNamedIndicatorReq);
    REQUEST_SIZE_MATCH(xkbSetNamedIndicatorReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_LED_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);
    CHK_ATOM_ONLY(stuff->indicator);
    CHK_MASK_LEGAL(0x10,stuff->whichGroups,XkbIM_UseAnyGroup);
    CHK_MASK_LEGAL(0x11,stuff->whichMods,XkbIM_UseAnyMods);

    /* Dry-run for checks */
    rc = _XkbCreateIndicatorMap(dev, stuff->indicator,
                                stuff->ledClass, stuff->ledID,
                                &map, &led, TRUE);
    if (rc != Success || !map) /* couldn't be created or didn't exist */
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd ||
        stuff->deviceSpec == XkbUseCorePtr)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev &&
                (other->kbdfeed || other->leds) &&
                (XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess) == Success))
            {
                rc = _XkbCreateIndicatorMap(other, stuff->indicator,
                                            stuff->ledClass, stuff->ledID,
                                            &map, &led, TRUE);
                if (rc != Success || !map)
                    return rc;
            }
        }
    }

    /* All checks passed, let's do it */
    rc = _XkbSetNamedIndicator(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd ||
        stuff->deviceSpec == XkbUseCorePtr)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev &&
                (other->kbdfeed || other->leds) &&
                (XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess) == Success))
            {
                _XkbSetNamedIndicator(client, other, stuff);
            }
        }
    }

    return Success;
}

/***====================================================================***/

static CARD32
_XkbCountAtoms(Atom *atoms,int maxAtoms,int *count)
{
register unsigned int i,bit,nAtoms;
register CARD32 atomsPresent;

    for (i=nAtoms=atomsPresent=0,bit=1;i<maxAtoms;i++,bit<<=1) {
	if (atoms[i]!=None) {
	    atomsPresent|= bit;
	    nAtoms++;
	}
    }
    if (count)
	*count= nAtoms;
    return atomsPresent;
}

static char *
_XkbWriteAtoms(char *wire,Atom *atoms,int maxAtoms,int swap)
{
register unsigned int i;
Atom *atm;

    atm = (Atom *)wire;
    for (i=0;i<maxAtoms;i++) {
	if (atoms[i]!=None) {
	    *atm= atoms[i];
	    if (swap) {
		register int n;
		swapl(atm,n);
	    }
	    atm++;
	}
    }
    return (char *)atm;
}

static Status
XkbComputeGetNamesReplySize(XkbDescPtr xkb,xkbGetNamesReply *rep)
{
register unsigned	which,length;
register int		i;

    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    which= rep->which;
    length= 0;
    if (xkb->names!=NULL) {
	 if (which&XkbKeycodesNameMask)		length++;
	 if (which&XkbGeometryNameMask)		length++;
	 if (which&XkbSymbolsNameMask)		length++;
	 if (which&XkbPhysSymbolsNameMask)	length++;
	 if (which&XkbTypesNameMask)		length++;
	 if (which&XkbCompatNameMask)		length++;
    }
    else which&= ~XkbComponentNamesMask;

    if (xkb->map!=NULL) {
	if (which&XkbKeyTypeNamesMask)
	    length+= xkb->map->num_types;
	rep->nTypes= xkb->map->num_types;
	if (which&XkbKTLevelNamesMask) {
	    XkbKeyTypePtr	pType = xkb->map->types;
	    int			nKTLevels = 0;

	    length+= XkbPaddedSize(xkb->map->num_types)/4;
	    for (i=0;i<xkb->map->num_types;i++,pType++) {
		if (pType->level_names!=NULL)
		    nKTLevels+= pType->num_levels;
	    }
	    rep->nKTLevels= nKTLevels;
	    length+= nKTLevels;
	}
    }
    else {
	rep->nTypes=    0;
	rep->nKTLevels= 0;
	which&= ~(XkbKeyTypeNamesMask|XkbKTLevelNamesMask);
    }

    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    rep->indicators= 0;
    rep->virtualMods= 0;
    rep->groupNames= 0;
    if (xkb->names!=NULL) {
	if (which&XkbIndicatorNamesMask) {
	    int nLeds;
	    rep->indicators= 
		_XkbCountAtoms(xkb->names->indicators,XkbNumIndicators,&nLeds);
	    length+= nLeds;
	    if (nLeds==0)
		which&= ~XkbIndicatorNamesMask;
	}

	if (which&XkbVirtualModNamesMask) {
	    int nVMods;
	    rep->virtualMods= 
		_XkbCountAtoms(xkb->names->vmods,XkbNumVirtualMods,&nVMods);
	    length+= nVMods;
	    if (nVMods==0)
		which&= ~XkbVirtualModNamesMask;
	}

	if (which&XkbGroupNamesMask) {
	    int nGroups;
	    rep->groupNames=
		_XkbCountAtoms(xkb->names->groups,XkbNumKbdGroups,&nGroups);
	    length+= nGroups;
	    if (nGroups==0)
		which&= ~XkbGroupNamesMask;
	}

	if ((which&XkbKeyNamesMask)&&(xkb->names->keys))
	     length+= rep->nKeys;
	else which&= ~XkbKeyNamesMask;

	if ((which&XkbKeyAliasesMask)&&
	    (xkb->names->key_aliases)&&(xkb->names->num_key_aliases>0)) {
	    rep->nKeyAliases= xkb->names->num_key_aliases;
	    length+= rep->nKeyAliases*2;
	} 
	else {
	    which&= ~XkbKeyAliasesMask;
	    rep->nKeyAliases= 0;
	}

	if ((which&XkbRGNamesMask)&&(xkb->names->num_rg>0))
	     length+= xkb->names->num_rg;
	else which&= ~XkbRGNamesMask;
    }
    else {
	which&= ~(XkbIndicatorNamesMask|XkbVirtualModNamesMask);
	which&= ~(XkbGroupNamesMask|XkbKeyNamesMask|XkbKeyAliasesMask);
	which&= ~XkbRGNamesMask;
    }

    rep->length= length;
    rep->which= which;
    return Success;
}

static int
XkbSendNames(ClientPtr client,XkbDescPtr xkb,xkbGetNamesReply *rep)
{
register unsigned 	i,length,which;
char *			start;
char *			desc;
register int            n;

    length= rep->length*4;
    which= rep->which;
    if (client->swapped) {
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swapl(&rep->which,n);
	swaps(&rep->virtualMods,n);
	swapl(&rep->indicators,n);
    }

    start = desc = calloc(1, length);
    if ( !start )
	return BadAlloc;
    if (xkb->names) {
        if (which&XkbKeycodesNameMask) {
            *((CARD32 *)desc)= xkb->names->keycodes;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbGeometryNameMask)  {
            *((CARD32 *)desc)= xkb->names->geometry;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbSymbolsNameMask) {
            *((CARD32 *)desc)= xkb->names->symbols;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbPhysSymbolsNameMask) {
            register CARD32 *atm= (CARD32 *)desc;
            atm[0]= (CARD32)xkb->names->phys_symbols;
            if (client->swapped) {
                swapl(&atm[0],n);
            }
            desc+= 4;
        }
        if (which&XkbTypesNameMask) {
            *((CARD32 *)desc)= (CARD32)xkb->names->types;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbCompatNameMask) {
            *((CARD32 *)desc)= (CARD32)xkb->names->compat;
            if (client->swapped) {
                swapl(desc,n);
            }
            desc+= 4;
        }
        if (which&XkbKeyTypeNamesMask) {
            register CARD32 *atm= (CARD32 *)desc;
            register XkbKeyTypePtr type= xkb->map->types;

            for (i=0;i<xkb->map->num_types;i++,atm++,type++) {
                *atm= (CARD32)type->name;
                if (client->swapped) {
                    swapl(atm,n);
                }
            }
            desc= (char *)atm;
        }
        if (which&XkbKTLevelNamesMask && xkb->map) {
            XkbKeyTypePtr type = xkb->map->types;
            register CARD32 *atm;
            for (i=0;i<rep->nTypes;i++,type++) {
                *desc++ = type->num_levels;
            }
            desc+= XkbPaddedSize(rep->nTypes)-rep->nTypes;

            atm= (CARD32 *)desc;
            type = xkb->map->types;
            for (i=0;i<xkb->map->num_types;i++,type++) {
                register unsigned l;
                if (type->level_names) {
                    for (l=0;l<type->num_levels;l++,atm++) {
                        *atm= type->level_names[l];
                        if (client->swapped) {
                            swapl(atm,n);
                        }
                    }
                    desc+= type->num_levels*4;
                }
            }
        }
        if (which&XkbIndicatorNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->indicators,XkbNumIndicators,
                                 client->swapped);
        }
        if (which&XkbVirtualModNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->vmods,XkbNumVirtualMods,
                                 client->swapped);
        }
        if (which&XkbGroupNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->groups,XkbNumKbdGroups,
                                 client->swapped);
        }
        if (which&XkbKeyNamesMask) {
            for (i=0;i<rep->nKeys;i++,desc+= sizeof(XkbKeyNameRec)) {
                *((XkbKeyNamePtr)desc)= xkb->names->keys[i+rep->firstKey];
            }
        }
        if (which&XkbKeyAliasesMask) {
            XkbKeyAliasPtr	pAl;
            pAl= xkb->names->key_aliases;
            for (i=0;i<rep->nKeyAliases;i++,pAl++,desc+=2*XkbKeyNameLength) {
                *((XkbKeyAliasPtr)desc)= *pAl;
            }
        }
        if ((which&XkbRGNamesMask)&&(rep->nRadioGroups>0)) {
            register CARD32	*atm= (CARD32 *)desc;
            for (i=0;i<rep->nRadioGroups;i++,atm++) {
                *atm= (CARD32)xkb->names->radio_groups[i];
                if (client->swapped) {
                    swapl(atm,n);
                }
            }
            desc+= rep->nRadioGroups*4;
        }
    }

    if ((desc-start)!=(length)) {
	ErrorF("[xkb] BOGUS LENGTH in write names, expected %d, got %ld\n",
					length, (unsigned long)(desc-start));
    }
    WriteToClient(client, SIZEOF(xkbGetNamesReply), (char *)rep);
    WriteToClient(client, length, start);
    free((char *)start);
    return Success;
}

int
ProcXkbGetNames(ClientPtr client)
{
    DeviceIntPtr	dev;
    XkbDescPtr		xkb;
    xkbGetNamesReply 	rep;

    REQUEST(xkbGetNamesReq);
    REQUEST_SIZE_MATCH(xkbGetNamesReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_LEGAL(0x01,stuff->which,XkbAllNamesMask);

    xkb = dev->key->xkbInfo->desc;
    memset(&rep, 0, sizeof(xkbGetNamesReply));
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.which = stuff->which;
    rep.nTypes = xkb->map->num_types;
    rep.firstKey = xkb->min_key_code;
    rep.nKeys = XkbNumKeys(xkb);
    if (xkb->names!=NULL) {
	rep.nKeyAliases= xkb->names->num_key_aliases;
	rep.nRadioGroups = xkb->names->num_rg;
    }
    else {
	rep.nKeyAliases= rep.nRadioGroups= 0;
    }
    XkbComputeGetNamesReplySize(xkb,&rep);
    return XkbSendNames(client,xkb,&rep);
}

/***====================================================================***/

static CARD32 *
_XkbCheckAtoms(CARD32 *wire,int nAtoms,int swapped,Atom *pError)
{
register int i;

    for (i=0;i<nAtoms;i++,wire++) {
	if (swapped) {
	    register int n;
	    swapl(wire,n);
	}
	if ((((Atom)*wire)!=None)&&(!ValidAtom((Atom)*wire))) {
	    *pError= ((Atom)*wire);
	    return NULL;
	}
    }
    return wire;
}

static CARD32 *
_XkbCheckMaskedAtoms(CARD32 *wire,int nAtoms,CARD32 present,int swapped,
								Atom *pError)
{
register unsigned i,bit;

    for (i=0,bit=1;(i<nAtoms)&&(present);i++,bit<<=1) {
	if ((present&bit)==0)
	    continue;
	if (swapped) {
	    register int n;
	    swapl(wire,n);
	}
	if ((((Atom)*wire)!=None)&&(!ValidAtom(((Atom)*wire)))) {
	    *pError= (Atom)*wire;
	    return NULL;
	}
	wire++;
    }
    return wire;
}

static Atom *
_XkbCopyMaskedAtoms(	Atom	*wire,
    			Atom	*dest,
			int   	 nAtoms,
			CARD32	 present)
{
register int i,bit;

    for (i=0,bit=1;(i<nAtoms)&&(present);i++,bit<<=1) {
	if ((present&bit)==0)
	    continue;
	dest[i]= *wire++;
    }
    return wire;
}

static Bool
_XkbCheckTypeName(Atom name,int typeNdx)
{
const char *	str;

    str= NameForAtom(name);
    if ((strcmp(str,"ONE_LEVEL")==0)||(strcmp(str,"TWO_LEVEL")==0)||
	(strcmp(str,"ALPHABETIC")==0)||(strcmp(str,"KEYPAD")==0))
	return FALSE;
    return TRUE;
}

/**
 * Check the device-dependent data in the request against the device. Returns
 * Success, or the appropriate error code.
 */
static int
_XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
                  xkbSetNamesReq *stuff, CARD32 *data)
{
    XkbDescRec		*xkb;
    XkbNamesRec		*names;
    CARD32		*tmp;
    Atom		 bad;

    tmp = data;
    xkb = dev->key->xkbInfo->desc;
    names = xkb->names;


    if (stuff->which & XkbKeyTypeNamesMask) {
        int i;
        CARD32	*old;
        if ( stuff->nTypes<1 ) {
            client->errorValue = _XkbErrCode2(0x02,stuff->nTypes);
            return BadValue;
        }
        if ((unsigned)(stuff->firstType+stuff->nTypes-1)>=xkb->map->num_types) {
            client->errorValue = _XkbErrCode4(0x03,stuff->firstType,
                    stuff->nTypes,
                    xkb->map->num_types);
            return BadValue;
        }
        if (((unsigned)stuff->firstType)<=XkbLastRequiredType) {
            client->errorValue = _XkbErrCode2(0x04,stuff->firstType);
            return BadAccess;
        }
        old= tmp;
        tmp= _XkbCheckAtoms(tmp,stuff->nTypes,client->swapped,&bad);
        if (!tmp) {
            client->errorValue= bad;
            return BadAtom;
        }
        for (i=0;i<stuff->nTypes;i++,old++) {
            if (!_XkbCheckTypeName((Atom)*old,stuff->firstType+i))
                client->errorValue= _XkbErrCode2(0x05,i);
        }
    }
    if (stuff->which&XkbKTLevelNamesMask) {
        unsigned i;
        XkbKeyTypePtr	type;
        CARD8 *		width;
        if ( stuff->nKTLevels<1 ) {
            client->errorValue = _XkbErrCode2(0x05,stuff->nKTLevels);
            return BadValue;
        }
        if ((unsigned)(stuff->firstKTLevel+stuff->nKTLevels-1)>=
                xkb->map->num_types) {
            client->errorValue = _XkbErrCode4(0x06,stuff->firstKTLevel,
                    stuff->nKTLevels,xkb->map->num_types);
            return BadValue;
        }
        width = (CARD8 *)tmp;
        tmp= (CARD32 *)(((char *)tmp)+XkbPaddedSize(stuff->nKTLevels));
        type = &xkb->map->types[stuff->firstKTLevel];
        for (i=0;i<stuff->nKTLevels;i++,type++) {
            if (width[i]==0)
                continue;
            else if (width[i]!=type->num_levels) {
                client->errorValue= _XkbErrCode4(0x07,i+stuff->firstKTLevel,
                        type->num_levels,width[i]);
                return BadMatch;
            }
            tmp= _XkbCheckAtoms(tmp,width[i],client->swapped,&bad);
            if (!tmp) {
                client->errorValue= bad;
                return BadAtom;
            }
        }
    }
    if (stuff->which&XkbIndicatorNamesMask) {
        if (stuff->indicators==0) {
            client->errorValue= 0x08;
            return BadMatch;
        }
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumIndicators,stuff->indicators,
                client->swapped,&bad);
        if (!tmp) {
            client->errorValue= bad;
            return BadAtom;
        }
    }
    if (stuff->which&XkbVirtualModNamesMask) {
        if (stuff->virtualMods==0) {
            client->errorValue= 0x09;
            return BadMatch;
        }
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumVirtualMods,
                (CARD32)stuff->virtualMods,
                client->swapped,&bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which&XkbGroupNamesMask) {
        if (stuff->groupNames==0) {
            client->errorValue= 0x0a;
            return BadMatch;
        }
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumKbdGroups,
                (CARD32)stuff->groupNames,
                client->swapped,&bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which&XkbKeyNamesMask) {
        if (stuff->firstKey<(unsigned)xkb->min_key_code) {
            client->errorValue= _XkbErrCode3(0x0b,xkb->min_key_code,
                    stuff->firstKey);
            return BadValue;
        }
        if (((unsigned)(stuff->firstKey+stuff->nKeys-1)>xkb->max_key_code)||
                (stuff->nKeys<1)) {
            client->errorValue= _XkbErrCode4(0x0c,xkb->max_key_code,
                    stuff->firstKey,stuff->nKeys);
            return BadValue;
        }
        tmp+= stuff->nKeys;
    }
    if ((stuff->which&XkbKeyAliasesMask)&&(stuff->nKeyAliases>0)) {
        tmp+= stuff->nKeyAliases*2;
    }
    if (stuff->which&XkbRGNamesMask) {
        if ( stuff->nRadioGroups<1 ) {
            client->errorValue= _XkbErrCode2(0x0d,stuff->nRadioGroups);
            return BadValue;
        }
        tmp= _XkbCheckAtoms(tmp,stuff->nRadioGroups,client->swapped,&bad);
        if (!tmp) {
            client->errorValue= bad;
            return BadAtom;
        }
    }
    if ((tmp-((CARD32 *)stuff))!=stuff->length) {
        client->errorValue = stuff->length;
        return BadLength;
    }



    return Success;
}

static int
_XkbSetNames(ClientPtr client, DeviceIntPtr dev, xkbSetNamesReq *stuff)
{
    XkbDescRec		*xkb;
    XkbNamesRec		*names;
    CARD32		*tmp;
    xkbNamesNotify	 nn;

    tmp = (CARD32 *)&stuff[1];
    xkb = dev->key->xkbInfo->desc;
    names = xkb->names;

    if (XkbAllocNames(xkb,stuff->which,stuff->nRadioGroups,
                stuff->nKeyAliases)!=Success) {
        return BadAlloc;
    }

    memset(&nn, 0, sizeof(xkbNamesNotify));
    nn.changed= stuff->which;
    tmp = (CARD32 *)&stuff[1];
    if (stuff->which&XkbKeycodesNameMask)
        names->keycodes= *tmp++;
    if (stuff->which&XkbGeometryNameMask)
        names->geometry= *tmp++;
    if (stuff->which&XkbSymbolsNameMask)
        names->symbols= *tmp++;
    if (stuff->which&XkbPhysSymbolsNameMask)
        names->phys_symbols= *tmp++;
    if (stuff->which&XkbTypesNameMask)
        names->types= *tmp++;
    if (stuff->which&XkbCompatNameMask)
        names->compat= *tmp++;
    if ((stuff->which&XkbKeyTypeNamesMask)&&(stuff->nTypes>0)) {
        register unsigned i;
        register XkbKeyTypePtr type;

        type= &xkb->map->types[stuff->firstType];
        for (i=0;i<stuff->nTypes;i++,type++) {
            type->name= *tmp++;
        }
        nn.firstType= stuff->firstType;
        nn.nTypes= stuff->nTypes;
    }
    if (stuff->which&XkbKTLevelNamesMask) {
        register XkbKeyTypePtr	type;
        register unsigned i;
        CARD8 *width;

        width = (CARD8 *)tmp;
        tmp= (CARD32 *)(((char *)tmp)+XkbPaddedSize(stuff->nKTLevels));
        type= &xkb->map->types[stuff->firstKTLevel];
        for (i=0;i<stuff->nKTLevels;i++,type++) {
            if (width[i]>0) {
                if (type->level_names) {
                    register unsigned n;
                    for (n=0;n<width[i];n++) {
                        type->level_names[n]= tmp[n];
                    }
                }
                tmp+= width[i];
            }
        }
        nn.firstLevelName= 0;
        nn.nLevelNames= stuff->nTypes;
    }
    if (stuff->which&XkbIndicatorNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->indicators,XkbNumIndicators,
                stuff->indicators);
        nn.changedIndicators= stuff->indicators;
    }
    if (stuff->which&XkbVirtualModNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->vmods,XkbNumVirtualMods,
                stuff->virtualMods);
        nn.changedVirtualMods= stuff->virtualMods;
    }
    if (stuff->which&XkbGroupNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->groups,XkbNumKbdGroups,
                stuff->groupNames);
        nn.changedVirtualMods= stuff->groupNames;
    }
    if (stuff->which&XkbKeyNamesMask) {
        memcpy((char*)&names->keys[stuff->firstKey],(char *)tmp,
                stuff->nKeys*XkbKeyNameLength);
        tmp+= stuff->nKeys;
        nn.firstKey= stuff->firstKey;
        nn.nKeys= stuff->nKeys;
    }
    if (stuff->which&XkbKeyAliasesMask) {
        if (stuff->nKeyAliases>0) {
            register int na= stuff->nKeyAliases;	
            if (XkbAllocNames(xkb,XkbKeyAliasesMask,0,na)!=Success)
                return BadAlloc;
            memcpy((char *)names->key_aliases,(char *)tmp,
                    stuff->nKeyAliases*sizeof(XkbKeyAliasRec));
            tmp+= stuff->nKeyAliases*2;
        }
        else if (names->key_aliases!=NULL) {
            free(names->key_aliases);
            names->key_aliases= NULL;
            names->num_key_aliases= 0;
        }
        nn.nAliases= names->num_key_aliases;
    }
    if (stuff->which&XkbRGNamesMask) {
        if (stuff->nRadioGroups>0) {
            register unsigned i,nrg;
            nrg= stuff->nRadioGroups;
            if (XkbAllocNames(xkb,XkbRGNamesMask,nrg,0)!=Success)
                return BadAlloc;

            for (i=0;i<stuff->nRadioGroups;i++) {
                names->radio_groups[i]= tmp[i];
            }
            tmp+= stuff->nRadioGroups;
        }
        else if (names->radio_groups) {
            free(names->radio_groups);
            names->radio_groups= NULL;
            names->num_rg= 0;
        }
        nn.nRadioGroups= names->num_rg;
    }
    if (nn.changed) {
        Bool needExtEvent;
        needExtEvent= (nn.changed&XkbIndicatorNamesMask)!=0;
        XkbSendNamesNotify(dev,&nn);
        if (needExtEvent) {
            XkbSrvLedInfoPtr		sli;
            xkbExtensionDeviceNotify	edev;
            register int		i;
            register unsigned		bit;

            sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,
                    XkbXI_IndicatorsMask);
            sli->namesPresent= 0;
            for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
                if (names->indicators[i]!=None)
                    sli->namesPresent|= bit;
            }
            memset(&edev, 0, sizeof(xkbExtensionDeviceNotify));
            edev.reason=	XkbXI_IndicatorNamesMask;
            edev.ledClass=	KbdFeedbackClass;
            edev.ledID=		dev->kbdfeed->ctrl.id;
            edev.ledsDefined= 	sli->namesPresent|sli->mapsPresent;
            edev.ledState=	sli->effectiveState;
            edev.firstBtn=	0;
            edev.nBtns=		0;
            edev.supported=	XkbXI_AllFeaturesMask;
            edev.unsupported=	0;
            XkbSendExtensionDeviceNotify(dev,client,&edev);
        }
    }
    return Success;
}

int
ProcXkbSetNames(ClientPtr client)
{
    DeviceIntPtr	 dev;
    CARD32		*tmp;
    Atom                 bad;
    int                  rc;

    REQUEST(xkbSetNamesReq);
    REQUEST_AT_LEAST_SIZE(xkbSetNamesReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01,stuff->which,XkbAllNamesMask);

    /* check device-independent stuff */
    tmp = (CARD32 *)&stuff[1];

    if (stuff->which&XkbKeycodesNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbGeometryNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbSymbolsNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbPhysSymbolsNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue= bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbTypesNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbCompatNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }

    /* start of device-dependent tests */
    rc = _XkbSetNamesCheck(client, dev, stuff, tmp);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {

                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetNamesCheck(client, other, stuff, tmp);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* everything is okay -- update names */

    rc = _XkbSetNames(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {

                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                    _XkbSetNames(client, other, stuff);
            }
        }
    }

    /* everything is okay -- update names */

    return Success;
}

/***====================================================================***/

#include "xkbgeom.h"

#define	XkbSizeCountedString(s)  ((s)?((((2+strlen(s))+3)/4)*4):4)

/**
 * Write the zero-terminated string str into wire as a pascal string with a
 * 16-bit length field prefixed before the actual string.
 *
 * @param wire The destination array, usually the wire struct
 * @param str The source string as zero-terminated C string
 * @param swap If TRUE, the length field is swapped.
 *
 * @return The input string in the format <string length><string> with a
 * (swapped) 16 bit string length, non-zero terminated.
 */
static char *
XkbWriteCountedString(char *wire,char *str,Bool swap)
{
    CARD16 len,*pLen, paddedLen;

    if (!str)
        return wire;

    len= strlen(str);
    pLen= (CARD16 *)wire;
    *pLen= len;
    if (swap) {
	register int n;
	swaps(pLen,n);
    }
    paddedLen= pad_to_int32(sizeof(len)+len)-sizeof(len);
    strncpy(&wire[sizeof(len)],str,paddedLen);
    wire+= sizeof(len)+paddedLen;
    return wire;
}

static int
XkbSizeGeomProperties(XkbGeometryPtr geom)
{
register int 	i,size;
XkbPropertyPtr	prop;
    
    for (size=i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	size+= XkbSizeCountedString(prop->name);
	size+= XkbSizeCountedString(prop->value);
    }
    return size;
}

static char *
XkbWriteGeomProperties(char *wire,XkbGeometryPtr geom,Bool swap)
{
register int 	i;
register XkbPropertyPtr	prop;
    
    for (i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	wire= XkbWriteCountedString(wire,prop->name,swap);
	wire= XkbWriteCountedString(wire,prop->value,swap);
    }
    return wire;
}

static int
XkbSizeGeomKeyAliases(XkbGeometryPtr geom)
{
    return geom->num_key_aliases*(2*XkbKeyNameLength);
}

static char *
XkbWriteGeomKeyAliases(char *wire,XkbGeometryPtr geom,Bool swap)
{
register int sz;
    
    sz= geom->num_key_aliases*(XkbKeyNameLength*2);
    if (sz>0) {
	memcpy(wire,(char *)geom->key_aliases,sz);
	wire+= sz;
    }
    return wire;
}

static int
XkbSizeGeomColors(XkbGeometryPtr geom)
{
register int 		i,size;
register XkbColorPtr	color;

    for (i=size=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	size+= XkbSizeCountedString(color->spec);
    }
    return size;
}

static char *
XkbWriteGeomColors(char *wire,XkbGeometryPtr geom,Bool swap)
{
register int		i;
register XkbColorPtr	color;

    for (i=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	wire= XkbWriteCountedString(wire,color->spec,swap);
    }
    return wire;
}

static int
XkbSizeGeomShapes(XkbGeometryPtr geom)
{
register int		i,size;
register XkbShapePtr	shape;

    for (i=size=0,shape=geom->shapes;i<geom->num_shapes;i++,shape++) {
	register int		n;
	register XkbOutlinePtr	ol;
	size+= SIZEOF(xkbShapeWireDesc);
	for (n=0,ol=shape->outlines;n<shape->num_outlines;n++,ol++) {
	    size+= SIZEOF(xkbOutlineWireDesc);
	    size+= ol->num_points*SIZEOF(xkbPointWireDesc);
	}
    }
    return size;
}

static char *
XkbWriteGeomShapes(char *wire,XkbGeometryPtr geom,Bool swap)
{
int			i;
XkbShapePtr		shape;
xkbShapeWireDesc *	shapeWire;

    for (i=0,shape=geom->shapes;i<geom->num_shapes;i++,shape++) {
	register int 		o;
	XkbOutlinePtr		ol;
	xkbOutlineWireDesc *	olWire;
	shapeWire= (xkbShapeWireDesc *)wire;
	shapeWire->name= shape->name;
	shapeWire->nOutlines= shape->num_outlines;
	if (shape->primary!=NULL)
	     shapeWire->primaryNdx= XkbOutlineIndex(shape,shape->primary);
	else shapeWire->primaryNdx= XkbNoShape;
	if (shape->approx!=NULL)
	     shapeWire->approxNdx= XkbOutlineIndex(shape,shape->approx);
	else shapeWire->approxNdx= XkbNoShape;
	shapeWire->pad= 0;
	if (swap) {
	    register int n;
	    swapl(&shapeWire->name,n);
	}
	wire= (char *)&shapeWire[1];
	for (o=0,ol=shape->outlines;o<shape->num_outlines;o++,ol++) {
	    register int	p;
	    XkbPointPtr		pt;
	    xkbPointWireDesc *	ptWire;
	    olWire= (xkbOutlineWireDesc *)wire;
	    olWire->nPoints= ol->num_points;
	    olWire->cornerRadius= ol->corner_radius;
	    olWire->pad= 0;
	    wire= (char *)&olWire[1];
	    ptWire= (xkbPointWireDesc *)wire;
	    for (p=0,pt=ol->points;p<ol->num_points;p++,pt++) {
		ptWire[p].x= pt->x;
		ptWire[p].y= pt->y;
		if (swap) {
		    register int n;
		    swaps(&ptWire[p].x,n);
		    swaps(&ptWire[p].y,n);
		}
	    }
	    wire= (char *)&ptWire[ol->num_points];
	}
    }
    return wire;
}

static int
XkbSizeGeomDoodads(int num_doodads,XkbDoodadPtr doodad)
{
register int	i,size;

    for (i=size=0;i<num_doodads;i++,doodad++) {
	size+= SIZEOF(xkbAnyDoodadWireDesc);
	if (doodad->any.type==XkbTextDoodad) {
	    size+= XkbSizeCountedString(doodad->text.text);
	    size+= XkbSizeCountedString(doodad->text.font);
	}
	else if (doodad->any.type==XkbLogoDoodad) {
	    size+= XkbSizeCountedString(doodad->logo.logo_name);
	}
    }
    return size;
}

static char *
XkbWriteGeomDoodads(char *wire,int num_doodads,XkbDoodadPtr doodad,Bool swap)
{
register int		i;
xkbDoodadWireDesc *	doodadWire;

    for (i=0;i<num_doodads;i++,doodad++) {
	doodadWire= (xkbDoodadWireDesc *)wire;
	wire= (char *)&doodadWire[1];
	memset(doodadWire, 0, SIZEOF(xkbDoodadWireDesc));
	doodadWire->any.name= doodad->any.name;
	doodadWire->any.type= doodad->any.type;
	doodadWire->any.priority= doodad->any.priority;
	doodadWire->any.top= doodad->any.top;
	doodadWire->any.left= doodad->any.left;
	if (swap) {
	    register int n;
	    swapl(&doodadWire->any.name,n);
	    swaps(&doodadWire->any.top,n);
	    swaps(&doodadWire->any.left,n);
	}
	switch (doodad->any.type) {
	    case XkbOutlineDoodad:
	    case XkbSolidDoodad:
		doodadWire->shape.angle= doodad->shape.angle;
		doodadWire->shape.colorNdx= doodad->shape.color_ndx;
		doodadWire->shape.shapeNdx= doodad->shape.shape_ndx;
		if (swap) {
		    register int n;
		    swaps(&doodadWire->shape.angle,n);
		}
		break;
	    case XkbTextDoodad:
		doodadWire->text.angle= doodad->text.angle;
		doodadWire->text.width= doodad->text.width;
		doodadWire->text.height= doodad->text.height;
		doodadWire->text.colorNdx= doodad->text.color_ndx;
		if (swap) {
		    register int n;
		    swaps(&doodadWire->text.angle,n);
		    swaps(&doodadWire->text.width,n);
		    swaps(&doodadWire->text.height,n);
		}
		wire= XkbWriteCountedString(wire,doodad->text.text,swap);
		wire= XkbWriteCountedString(wire,doodad->text.font,swap);
		break;
	    case XkbIndicatorDoodad:
		doodadWire->indicator.shapeNdx= doodad->indicator.shape_ndx;
		doodadWire->indicator.onColorNdx=doodad->indicator.on_color_ndx;
		doodadWire->indicator.offColorNdx=
						doodad->indicator.off_color_ndx;
		break;
	    case XkbLogoDoodad:
		doodadWire->logo.angle= doodad->logo.angle;
		doodadWire->logo.colorNdx= doodad->logo.color_ndx;
		doodadWire->logo.shapeNdx= doodad->logo.shape_ndx;
		wire= XkbWriteCountedString(wire,doodad->logo.logo_name,swap);
		break;
	    default:
		ErrorF("[xkb] Unknown doodad type %d in XkbWriteGeomDoodads\n",
			doodad->any.type);
		ErrorF("[xkb] Ignored\n");
		break;
	}
    }
    return wire;
}

static char *
XkbWriteGeomOverlay(char *wire,XkbOverlayPtr ol,Bool swap)
{
register int		r;
XkbOverlayRowPtr	row;
xkbOverlayWireDesc *	olWire;

   olWire= (xkbOverlayWireDesc *)wire;
   olWire->name= ol->name;
   olWire->nRows= ol->num_rows;
   olWire->pad1= 0;
   olWire->pad2= 0;
   if (swap) {
	register int n;
	swapl(&olWire->name,n);
   }
   wire= (char *)&olWire[1];
   for (r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
   	unsigned int		k;
	XkbOverlayKeyPtr	key;
	xkbOverlayRowWireDesc *	rowWire;
	rowWire= (xkbOverlayRowWireDesc *)wire;
	rowWire->rowUnder= row->row_under;
	rowWire->nKeys= row->num_keys;
	rowWire->pad1= 0;
	wire= (char *)&rowWire[1];
	for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
	    xkbOverlayKeyWireDesc *	keyWire;
	    keyWire= (xkbOverlayKeyWireDesc *)wire;
	    memcpy(keyWire->over,key->over.name,XkbKeyNameLength);
	    memcpy(keyWire->under,key->under.name,XkbKeyNameLength);
	    wire= (char *)&keyWire[1];
	}
   }
   return wire;
}

static int
XkbSizeGeomSections(XkbGeometryPtr geom)
{
register int 	i,size;
XkbSectionPtr	section;

    for (i=size=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	size+= SIZEOF(xkbSectionWireDesc);
	if (section->rows) {
	    int		r;
	    XkbRowPtr	row;
	    for (r=0,row=section->rows;r<section->num_rows;row++,r++) {
		size+= SIZEOF(xkbRowWireDesc);
		size+= row->num_keys*SIZEOF(xkbKeyWireDesc);
	    }
	}
	if (section->doodads)
	    size+= XkbSizeGeomDoodads(section->num_doodads,section->doodads);
	if (section->overlays) {
	    int			o;
	    XkbOverlayPtr	ol;
	    for (o=0,ol=section->overlays;o<section->num_overlays;o++,ol++) {
		int			r;
		XkbOverlayRowPtr	row;
		size+= SIZEOF(xkbOverlayWireDesc);
		for (r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
		   size+= SIZEOF(xkbOverlayRowWireDesc);
		   size+= row->num_keys*SIZEOF(xkbOverlayKeyWireDesc);
		}
	    }
	}
    }
    return size;
}

static char *
XkbWriteGeomSections(char *wire,XkbGeometryPtr geom,Bool swap)
{
register int		i;
XkbSectionPtr		section;
xkbSectionWireDesc *	sectionWire;

    for (i=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	sectionWire= (xkbSectionWireDesc *)wire;
	sectionWire->name= section->name;
	sectionWire->top= section->top;
	sectionWire->left= section->left;
	sectionWire->width= section->width;
	sectionWire->height= section->height;
	sectionWire->angle= section->angle;
	sectionWire->priority= section->priority;
	sectionWire->nRows= section->num_rows;
	sectionWire->nDoodads= section->num_doodads;
	sectionWire->nOverlays= section->num_overlays;
	sectionWire->pad= 0;
	if (swap) {
	    register int n;
	    swapl(&sectionWire->name,n);
	    swaps(&sectionWire->top,n);
	    swaps(&sectionWire->left,n);
	    swaps(&sectionWire->width,n);
	    swaps(&sectionWire->height,n);
	    swaps(&sectionWire->angle,n);
	}
	wire= (char *)&sectionWire[1];
	if (section->rows) {
	    int			r;
	    XkbRowPtr		row;
	    xkbRowWireDesc *	rowWire;
	    for (r=0,row=section->rows;r<section->num_rows;r++,row++) {
		rowWire= (xkbRowWireDesc *)wire;
		rowWire->top= row->top;
		rowWire->left= row->left;
		rowWire->nKeys= row->num_keys;
		rowWire->vertical= row->vertical;
		rowWire->pad= 0;
		if (swap) {
		    register int n;
		    swaps(&rowWire->top,n);
		    swaps(&rowWire->left,n);
		}
		wire= (char *)&rowWire[1];
		if (row->keys) {
		    int			k;
		    XkbKeyPtr		key;
		    xkbKeyWireDesc *	keyWire;
		    keyWire= (xkbKeyWireDesc *)wire;
		    for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
			memcpy(keyWire[k].name,key->name.name,XkbKeyNameLength);
			keyWire[k].gap= key->gap;
			keyWire[k].shapeNdx= key->shape_ndx;
			keyWire[k].colorNdx= key->color_ndx;
			if (swap) {
			    register int n;
			    swaps(&keyWire[k].gap,n);
			}
		    }
		    wire= (char *)&keyWire[row->num_keys];
		}
	    }
	}
	if (section->doodads) {
	    wire= XkbWriteGeomDoodads(wire,
	    			      section->num_doodads,section->doodads,
				      swap);
	}
	if (section->overlays) {
	    register int o;
	    for (o=0;o<section->num_overlays;o++) {
		wire= XkbWriteGeomOverlay(wire,&section->overlays[o],swap);
	    }
	}
    }
    return wire;
}

static Status
XkbComputeGetGeometryReplySize(	XkbGeometryPtr		geom,
				xkbGetGeometryReply *	rep,
				Atom			name)
{
int	len;

    if (geom!=NULL) {
	len= XkbSizeCountedString(geom->label_font);
	len+= XkbSizeGeomProperties(geom);
	len+= XkbSizeGeomColors(geom);
	len+= XkbSizeGeomShapes(geom);
	len+= XkbSizeGeomSections(geom);
	len+= XkbSizeGeomDoodads(geom->num_doodads,geom->doodads);
	len+= XkbSizeGeomKeyAliases(geom);
	rep->length= len/4;
	rep->found= TRUE;
	rep->name= geom->name;
	rep->widthMM= geom->width_mm;
	rep->heightMM= geom->height_mm;
	rep->nProperties= geom->num_properties;
	rep->nColors= geom->num_colors;
	rep->nShapes= geom->num_shapes;
	rep->nSections= geom->num_sections;
	rep->nDoodads= geom->num_doodads;
	rep->nKeyAliases= geom->num_key_aliases;
	rep->baseColorNdx= XkbGeomColorIndex(geom,geom->base_color);
	rep->labelColorNdx= XkbGeomColorIndex(geom,geom->label_color);
    }
    else {
	rep->length= 0;
	rep->found= FALSE;
	rep->name= name;
	rep->widthMM= rep->heightMM= 0;
	rep->nProperties= rep->nColors= rep->nShapes= 0;
	rep->nSections= rep->nDoodads= 0;
	rep->nKeyAliases= 0;
	rep->labelColorNdx= rep->baseColorNdx= 0;
    }
    return Success;
}

static int
XkbSendGeometry(	ClientPtr		client,
			XkbGeometryPtr		geom,
			xkbGetGeometryReply *	rep,
			Bool			freeGeom)
{
    char	*desc,*start;
    int		 len;

    if (geom!=NULL) {
	len= rep->length*4;
	start= desc= malloc(len);
	if (!start)
	    return BadAlloc;
	desc=  XkbWriteCountedString(desc,geom->label_font,client->swapped);
	if ( rep->nProperties>0 )
	    desc = XkbWriteGeomProperties(desc,geom,client->swapped);
	if ( rep->nColors>0 )
	    desc = XkbWriteGeomColors(desc,geom,client->swapped);
	if ( rep->nShapes>0 )
	    desc = XkbWriteGeomShapes(desc,geom,client->swapped);
	if ( rep->nSections>0 )
	    desc = XkbWriteGeomSections(desc,geom,client->swapped);
	if ( rep->nDoodads>0 )
	    desc = XkbWriteGeomDoodads(desc,geom->num_doodads,geom->doodads,
							  client->swapped);
	if ( rep->nKeyAliases>0 )
	    desc = XkbWriteGeomKeyAliases(desc,geom,client->swapped);
	if ((desc-start)!=(len)) {
	    ErrorF("[xkb] BOGUS LENGTH in XkbSendGeometry, expected %d, got %ld\n",
			len, (unsigned long)(desc-start));
	}
    }
    else {
	len= 0;
	start= NULL;
    }
    if (client->swapped) {
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swapl(&rep->name,n);
	swaps(&rep->widthMM,n);
	swaps(&rep->heightMM,n);
	swaps(&rep->nProperties,n);
	swaps(&rep->nColors,n);
	swaps(&rep->nShapes,n);
	swaps(&rep->nSections,n);
	swaps(&rep->nDoodads,n);
	swaps(&rep->nKeyAliases,n);
    }
    WriteToClient(client, SIZEOF(xkbGetGeometryReply), (char *)rep);
    if (len>0)
	WriteToClient(client, len, start);
    if (start!=NULL)
	free((char *)start);
    if (freeGeom)
	XkbFreeGeometry(geom,XkbGeomAllMask,TRUE);
    return Success;
}

int
ProcXkbGetGeometry(ClientPtr client)
{
    DeviceIntPtr 	dev;
    xkbGetGeometryReply rep;
    XkbGeometryPtr	geom;
    Bool		shouldFree;
    Status		status;

    REQUEST(xkbGetGeometryReq);
    REQUEST_SIZE_MATCH(xkbGetGeometryReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    geom= XkbLookupNamedGeometry(dev,stuff->name,&shouldFree);
    rep.type= X_Reply;
    rep.deviceID= dev->id;
    rep.sequenceNumber= client->sequence;
    rep.length= 0;
    status= XkbComputeGetGeometryReplySize(geom,&rep,stuff->name);
    if (status!=Success)
	 return status;
    else return XkbSendGeometry(client,geom,&rep,shouldFree);
}

/***====================================================================***/

static char *
_GetCountedString(char **wire_inout,Bool swap)
{
char *	wire,*str;
CARD16	len,*plen;

    wire= *wire_inout;
    plen= (CARD16 *)wire;
    if (swap) {
	register int n;
	swaps(plen,n);
    }
    len= *plen;
    str= malloc(len+1);
    if (str) {
	memcpy(str,&wire[2],len);
	str[len]= '\0';
    }
    wire+= XkbPaddedSize(len+2);
    *wire_inout= wire;
    return str;
}

static Status
_CheckSetDoodad(	char **		wire_inout,
			XkbGeometryPtr	geom,
			XkbSectionPtr	section,
			ClientPtr	client)
{
char *			wire;
xkbDoodadWireDesc *	dWire;
XkbDoodadPtr		doodad;

    dWire= (xkbDoodadWireDesc *)(*wire_inout);
    wire= (char *)&dWire[1];
    if (client->swapped) {
	register int n;
	swapl(&dWire->any.name,n);
	swaps(&dWire->any.top,n);
	swaps(&dWire->any.left,n);
	swaps(&dWire->any.angle,n);
    }
    CHK_ATOM_ONLY(dWire->any.name);
    doodad= XkbAddGeomDoodad(geom,section,dWire->any.name);
    if (!doodad)
	return BadAlloc;
    doodad->any.type= dWire->any.type;
    doodad->any.priority= dWire->any.priority;
    doodad->any.top= dWire->any.top;
    doodad->any.left= dWire->any.left;
    doodad->any.angle= dWire->any.angle;
    switch (doodad->any.type) {
	case XkbOutlineDoodad:
	case XkbSolidDoodad:
	    if (dWire->shape.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x40,geom->num_colors,
							dWire->shape.colorNdx);
		return BadMatch;
	    }
	    if (dWire->shape.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x41,geom->num_shapes,
							dWire->shape.shapeNdx);
		return BadMatch;
	    }
	    doodad->shape.color_ndx= dWire->shape.colorNdx;
	    doodad->shape.shape_ndx= dWire->shape.shapeNdx;
	    break;
	case XkbTextDoodad:
	    if (dWire->text.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x42,geom->num_colors,
							dWire->text.colorNdx);
		return BadMatch;
	    }
	    if (client->swapped) {
		register int n;
		swaps(&dWire->text.width,n);
		swaps(&dWire->text.height,n);
	    }
	    doodad->text.width= dWire->text.width;
	    doodad->text.height= dWire->text.height;
	    doodad->text.color_ndx= dWire->text.colorNdx;
	    doodad->text.text= _GetCountedString(&wire,client->swapped);
	    doodad->text.font= _GetCountedString(&wire,client->swapped);
	    break;
	case XkbIndicatorDoodad:
	    if (dWire->indicator.onColorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x43,geom->num_colors,
						dWire->indicator.onColorNdx);
		return BadMatch;
	    }
	    if (dWire->indicator.offColorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x44,geom->num_colors,
						dWire->indicator.offColorNdx);
		return BadMatch;
	    }
	    if (dWire->indicator.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x45,geom->num_shapes,
						dWire->indicator.shapeNdx);
		return BadMatch;
	    }
	    doodad->indicator.shape_ndx= dWire->indicator.shapeNdx;
	    doodad->indicator.on_color_ndx= dWire->indicator.onColorNdx;
	    doodad->indicator.off_color_ndx= dWire->indicator.offColorNdx;
	    break;
	case XkbLogoDoodad:
	    if (dWire->logo.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x46,geom->num_colors,
							dWire->logo.colorNdx);
		return BadMatch;
	    }
	    if (dWire->logo.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x47,geom->num_shapes,
							dWire->logo.shapeNdx);
		return BadMatch;
	    }
	    doodad->logo.color_ndx= dWire->logo.colorNdx;
	    doodad->logo.shape_ndx= dWire->logo.shapeNdx;
	    doodad->logo.logo_name= _GetCountedString(&wire,client->swapped);
	    break;
	default:
	    client->errorValue= _XkbErrCode2(0x4F,dWire->any.type);
	    return BadValue;
    }
    *wire_inout= wire;
    return Success;
}

static Status
_CheckSetOverlay(	char **		wire_inout,
			XkbGeometryPtr	geom,
			XkbSectionPtr	section,
			ClientPtr	client)
{
register int		r;
char *			wire;
XkbOverlayPtr		ol;
xkbOverlayWireDesc *	olWire;
xkbOverlayRowWireDesc *	rWire;

    wire= *wire_inout;
    olWire= (xkbOverlayWireDesc *)wire;
    if (client->swapped) {
	register int n;
	swapl(&olWire->name,n);
    }
    CHK_ATOM_ONLY(olWire->name);
    ol= XkbAddGeomOverlay(section,olWire->name,olWire->nRows);
    rWire= (xkbOverlayRowWireDesc *)&olWire[1];
    for (r=0;r<olWire->nRows;r++) {
	register int		k;
	xkbOverlayKeyWireDesc *	kWire;
	XkbOverlayRowPtr	row;

	if (rWire->rowUnder>section->num_rows) {
	    client->errorValue= _XkbErrCode4(0x20,r,section->num_rows,
							rWire->rowUnder);
	    return BadMatch;
	}
	row= XkbAddGeomOverlayRow(ol,rWire->rowUnder,rWire->nKeys);
	kWire= (xkbOverlayKeyWireDesc *)&rWire[1];
	for (k=0;k<rWire->nKeys;k++,kWire++) {
	    if (XkbAddGeomOverlayKey(ol,row,
	    		(char *)kWire->over,(char *)kWire->under)==NULL) {
		client->errorValue= _XkbErrCode3(0x21,r,k);
		return BadMatch;
	    }	
	}
	rWire= (xkbOverlayRowWireDesc *)kWire;
    }
    olWire= (xkbOverlayWireDesc *)rWire;
    wire= (char *)olWire;
    *wire_inout= wire;
    return Success;
}

static Status
_CheckSetSections( 	XkbGeometryPtr		geom,
			xkbSetGeometryReq *	req,
			char **			wire_inout,
			ClientPtr		client)
{
Status			status;
register int		s;
char *			wire;
xkbSectionWireDesc *	sWire;
XkbSectionPtr		section;

    wire= *wire_inout;
    if (req->nSections<1)
	return Success;
    sWire= (xkbSectionWireDesc *)wire;
    for (s=0;s<req->nSections;s++) {
	register int		r;
	xkbRowWireDesc *	rWire;
	if (client->swapped) {
	    register int n;
	    swapl(&sWire->name,n);
	    swaps(&sWire->top,n);
	    swaps(&sWire->left,n);
	    swaps(&sWire->width,n);
	    swaps(&sWire->height,n);
	    swaps(&sWire->angle,n);
	}
	CHK_ATOM_ONLY(sWire->name);
	section= XkbAddGeomSection(geom,sWire->name,sWire->nRows,
					sWire->nDoodads,sWire->nOverlays);
	if (!section)
	    return BadAlloc;
	section->priority=	sWire->priority;
	section->top=		sWire->top;
	section->left=		sWire->left;
	section->width=		sWire->width;
	section->height=	sWire->height;
	section->angle=		sWire->angle;
	rWire= (xkbRowWireDesc *)&sWire[1];
	for (r=0;r<sWire->nRows;r++) {
	    register int	k;
	    XkbRowPtr		row;
	    xkbKeyWireDesc *	kWire;
	    if (client->swapped) {
		register int n;
		swaps(&rWire->top,n);
		swaps(&rWire->left,n);
	    }
	    row= XkbAddGeomRow(section,rWire->nKeys);
	    if (!row)
		return BadAlloc;
	    row->top= rWire->top;
	    row->left= rWire->left;
	    row->vertical= rWire->vertical;
	    kWire= (xkbKeyWireDesc *)&rWire[1];
	    for (k=0;k<rWire->nKeys;k++) {
		XkbKeyPtr	key;
		key= XkbAddGeomKey(row);
		if (!key)
		    return BadAlloc;
		memcpy(key->name.name,kWire[k].name,XkbKeyNameLength);
		key->gap= kWire[k].gap;
		key->shape_ndx= kWire[k].shapeNdx;
		key->color_ndx= kWire[k].colorNdx;
		if (key->shape_ndx>=geom->num_shapes) {
		    client->errorValue= _XkbErrCode3(0x10,key->shape_ndx,
							  geom->num_shapes);
		    return BadMatch;
		}
		if (key->color_ndx>=geom->num_colors) {
		    client->errorValue= _XkbErrCode3(0x11,key->color_ndx,
							  geom->num_colors);
		    return BadMatch;
		}
	    }
	    rWire= (xkbRowWireDesc *)&kWire[rWire->nKeys];
	}
	wire= (char *)rWire;
	if (sWire->nDoodads>0) {
	    register int d;
	    for (d=0;d<sWire->nDoodads;d++) {
		status=_CheckSetDoodad(&wire,geom,section,client);
		if (status!=Success)
		    return status;
	    }
	}
	if (sWire->nOverlays>0) {
	    register int o;
	    for (o=0;o<sWire->nOverlays;o++) {
		status= _CheckSetOverlay(&wire,geom,section,client);
		if (status!=Success)
		    return status;
	    }
	}
	sWire= (xkbSectionWireDesc *)wire;
    }
    wire= (char *)sWire;
    *wire_inout= wire;
    return Success;
}

static Status
_CheckSetShapes( 	XkbGeometryPtr		geom,
			xkbSetGeometryReq *	req,
			char **			wire_inout,
			ClientPtr		client)
{
register int	i;
char *		wire;

    wire= *wire_inout;
    if (req->nShapes<1) {
	client->errorValue= _XkbErrCode2(0x06,req->nShapes);
	return BadValue;
    }
    else {
	xkbShapeWireDesc *	shapeWire;
	XkbShapePtr		shape;
	register int		o;
	shapeWire= (xkbShapeWireDesc *)wire;
	for (i=0;i<req->nShapes;i++) {
	    xkbOutlineWireDesc *	olWire;
	    XkbOutlinePtr		ol;
	    shape= XkbAddGeomShape(geom,shapeWire->name,shapeWire->nOutlines);
	    if (!shape)
		return BadAlloc;
	    olWire= (xkbOutlineWireDesc *)(&shapeWire[1]);
	    for (o=0;o<shapeWire->nOutlines;o++) {
		register int		p;
		XkbPointPtr		pt;
		xkbPointWireDesc *	ptWire;

		ol= XkbAddGeomOutline(shape,olWire->nPoints);
		if (!ol)
		    return BadAlloc;
		ol->corner_radius=	olWire->cornerRadius;
		ptWire= (xkbPointWireDesc *)&olWire[1];
		for (p=0,pt=ol->points;p<olWire->nPoints;p++,pt++) {
		    pt->x= ptWire[p].x;
		    pt->y= ptWire[p].y;
		    if (client->swapped) {
			register int n;
			swaps(&pt->x,n);
			swaps(&pt->y,n);
		    }
		}
		ol->num_points= olWire->nPoints;
		olWire= (xkbOutlineWireDesc *)(&ptWire[olWire->nPoints]);
	    }
	    if (shapeWire->primaryNdx!=XkbNoShape)
		shape->primary= &shape->outlines[shapeWire->primaryNdx];
	    if (shapeWire->approxNdx!=XkbNoShape)
		shape->approx= &shape->outlines[shapeWire->approxNdx];
	    shapeWire= (xkbShapeWireDesc *)olWire;
	}
	wire= (char *)shapeWire;
    }
    if (geom->num_shapes!=req->nShapes) {
	client->errorValue= _XkbErrCode3(0x07,geom->num_shapes,req->nShapes);
	return BadMatch;
    }

    *wire_inout= wire;
    return Success;
}

static Status
_CheckSetGeom(	XkbGeometryPtr		geom,
		xkbSetGeometryReq *	req,
		ClientPtr 		client)
{
register int	i;
Status		status;
char *		wire;

    wire= (char *)&req[1];
    geom->label_font= _GetCountedString(&wire,client->swapped);

    for (i=0;i<req->nProperties;i++) {
	char *name,*val;
	name= _GetCountedString(&wire,client->swapped);
        if (!name)
            return BadAlloc;
	val= _GetCountedString(&wire,client->swapped);
        if (!val) {
            free(name);
            return BadAlloc;
        }
	if (XkbAddGeomProperty(geom,name,val)==NULL) {
            free(name);
            free(val);
	    return BadAlloc;
        }
        free(name);
        free(val);
    }

    if (req->nColors<2) {
	client->errorValue= _XkbErrCode3(0x01,2,req->nColors);
	return BadValue;
    }
    if (req->baseColorNdx>req->nColors) {
	client->errorValue=_XkbErrCode3(0x03,req->nColors,req->baseColorNdx);
	return BadMatch;
    }
    if (req->labelColorNdx>req->nColors) {
	client->errorValue= _XkbErrCode3(0x03,req->nColors,req->labelColorNdx);
	return BadMatch;
    }
    if (req->labelColorNdx==req->baseColorNdx) {
	client->errorValue= _XkbErrCode3(0x04,req->baseColorNdx,
                                         req->labelColorNdx);
	return BadMatch;
    }

    for (i=0;i<req->nColors;i++) {
	char *name;
	name= _GetCountedString(&wire,client->swapped);
	if (!name)
            return BadAlloc;
        if (!XkbAddGeomColor(geom,name,geom->num_colors)) {
            free(name);
	    return BadAlloc;
        }
        free(name);
    }
    if (req->nColors!=geom->num_colors) {
	client->errorValue= _XkbErrCode3(0x05,req->nColors,geom->num_colors);
	return BadMatch;
    }
    geom->label_color= &geom->colors[req->labelColorNdx];
    geom->base_color= &geom->colors[req->baseColorNdx];

    if ((status=_CheckSetShapes(geom,req,&wire,client))!=Success)
	return status;

    if ((status=_CheckSetSections(geom,req,&wire,client))!=Success)
	return status;

    for (i=0;i<req->nDoodads;i++) {
	status=_CheckSetDoodad(&wire,geom,NULL,client);
	if (status!=Success)
	    return status;
    }

    for (i=0;i<req->nKeyAliases;i++) {
	if (XkbAddGeomKeyAlias(geom,&wire[XkbKeyNameLength],wire)==NULL)
	    return BadAlloc;
	wire+= 2*XkbKeyNameLength;
    }
    return Success;
}

static int
_XkbSetGeometry(ClientPtr client, DeviceIntPtr dev, xkbSetGeometryReq *stuff)
{
    XkbDescPtr		xkb;
    Bool		new_name;
    xkbNewKeyboardNotify	nkn;
    XkbGeometryPtr	geom,old;
    XkbGeometrySizesRec	sizes;
    Status		status;

    xkb= dev->key->xkbInfo->desc;
    old= xkb->geom;
    xkb->geom= NULL;

    sizes.which=		XkbGeomAllMask;
    sizes.num_properties=	stuff->nProperties;
    sizes.num_colors=	stuff->nColors;
    sizes.num_shapes=	stuff->nShapes;
    sizes.num_sections=	stuff->nSections;
    sizes.num_doodads=	stuff->nDoodads;
    sizes.num_key_aliases=	stuff->nKeyAliases;
    if ((status= XkbAllocGeometry(xkb,&sizes))!=Success) {
        xkb->geom= old;
        return status;
    }
    geom= xkb->geom;
    geom->name= stuff->name;
    geom->width_mm= stuff->widthMM;
    geom->height_mm= stuff->heightMM;
    if ((status= _CheckSetGeom(geom,stuff,client))!=Success) {
        XkbFreeGeometry(geom,XkbGeomAllMask,TRUE);
        xkb->geom= old;
        return status;
    }
    new_name= (xkb->names->geometry!=geom->name);
    xkb->names->geometry= geom->name;
    if (old)
        XkbFreeGeometry(old,XkbGeomAllMask,TRUE);
    if (new_name) {
        xkbNamesNotify	nn;
        memset(&nn, 0, sizeof(xkbNamesNotify));
        nn.changed= XkbGeometryNameMask;
        XkbSendNamesNotify(dev,&nn);
    }
    nkn.deviceID= nkn.oldDeviceID= dev->id;
    nkn.minKeyCode= nkn.oldMinKeyCode= xkb->min_key_code;
    nkn.maxKeyCode= nkn.oldMaxKeyCode= xkb->max_key_code;
    nkn.requestMajor=	XkbReqCode;
    nkn.requestMinor=	X_kbSetGeometry;
    nkn.changed=	XkbNKN_GeometryMask;
    XkbSendNewKeyboardNotify(dev,&nkn);
    return Success;
}

int
ProcXkbSetGeometry(ClientPtr client)
{
    DeviceIntPtr        dev;
    int                 rc;

    REQUEST(xkbSetGeometryReq);
    REQUEST_AT_LEAST_SIZE(xkbSetGeometryReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    rc = _XkbSetGeometry(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                    _XkbSetGeometry(client, other, stuff);
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbPerClientFlags(ClientPtr client)
{
    DeviceIntPtr 		dev;
    xkbPerClientFlagsReply 	rep;
    XkbInterestPtr		interest;
    Mask access_mode = DixGetAttrAccess | DixSetAttrAccess;

    REQUEST(xkbPerClientFlagsReq);
    REQUEST_SIZE_MATCH(xkbPerClientFlagsReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);
    CHK_MASK_LEGAL(0x01,stuff->change,XkbPCF_AllFlagsMask);
    CHK_MASK_MATCH(0x02,stuff->change,stuff->value);

    interest = XkbFindClientResource((DevicePtr)dev,client);
    memset(&rep, 0, sizeof(xkbPerClientFlagsReply));
    rep.type= X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    if (stuff->change) {
	client->xkbClientFlags&= ~stuff->change;
	client->xkbClientFlags|= stuff->value;
    }
    if (stuff->change&XkbPCF_AutoResetControlsMask) {
	Bool	want;
	want= stuff->value&XkbPCF_AutoResetControlsMask;
	if (interest && !want) {
	    interest->autoCtrls= interest->autoCtrlValues= 0;
	}
	else if (want && (!interest)) {
	    XID id = FakeClientID(client->index);
	    if (!AddResource(id,RT_XKBCLIENT,dev))
		return BadAlloc;
	    interest= XkbAddClientResource((DevicePtr)dev,client,id);
	    if (!interest)
		return BadAlloc;
	}
	if (interest && want ) {
	    register unsigned affect;
	    affect= stuff->ctrlsToChange;

	    CHK_MASK_LEGAL(0x03,affect,XkbAllBooleanCtrlsMask);
	    CHK_MASK_MATCH(0x04,affect,stuff->autoCtrls);
	    CHK_MASK_MATCH(0x05,stuff->autoCtrls,stuff->autoCtrlValues);

	    interest->autoCtrls&= ~affect;
	    interest->autoCtrlValues&= ~affect;
	    interest->autoCtrls|= stuff->autoCtrls&affect;
	    interest->autoCtrlValues|= stuff->autoCtrlValues&affect;
	}
    }
    rep.supported = XkbPCF_AllFlagsMask;
    rep.value= client->xkbClientFlags&XkbPCF_AllFlagsMask;
    if (interest) {
	rep.autoCtrls= interest->autoCtrls;
	rep.autoCtrlValues= interest->autoCtrlValues;
    }
    else {
	rep.autoCtrls= rep.autoCtrlValues= 0;
    }
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.supported,n);
	swapl(&rep.value,n);
	swapl(&rep.autoCtrls,n);
	swapl(&rep.autoCtrlValues,n);
    }
    WriteToClient(client,SIZEOF(xkbPerClientFlagsReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

/* all latin-1 alphanumerics, plus parens, minus, underscore, slash */
/* and wildcards */
static unsigned char componentSpecLegal[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0xa7, 0xff, 0x87,
        0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff
};

/* same as above but accepts percent, plus and bar too */
static unsigned char componentExprLegal[] = {
        0x00, 0x00, 0x00, 0x00, 0x20, 0xaf, 0xff, 0x87,
        0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x17,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff
};

static char *
GetComponentSpec(unsigned char **pWire,Bool allowExpr,int *errRtrn)
{
int		len;
register int	i;
unsigned char	*wire,*str,*tmp,*legal;

    if (allowExpr)	legal= &componentExprLegal[0];
    else		legal= &componentSpecLegal[0];

    wire= *pWire;
    len= (*(unsigned char *)wire++);
    if (len>0) {
	str= calloc(1, len+1);
	if (str) {
	    tmp= str;
	    for (i=0;i<len;i++) {
		if (legal[(*wire)/8]&(1<<((*wire)%8)))
		    *tmp++= *wire++;
		else wire++;
	    }
	    if (tmp!=str)
		*tmp++= '\0';
	    else {
		free(str);
		str= NULL;
	    }
	}
	else {
	    *errRtrn= BadAlloc;
	}
    }
    else {
	str= NULL;
    }
    *pWire= wire;
    return (char *)str;
}

/***====================================================================***/

int
ProcXkbListComponents(ClientPtr client)
{
    DeviceIntPtr 		dev;
    xkbListComponentsReply 	rep;
    unsigned			len;
    int				status;
    unsigned char *		str;
    XkbSrvListInfoRec		list;

    REQUEST(xkbListComponentsReq);
    REQUEST_AT_LEAST_SIZE(xkbListComponentsReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    status= Success;
    str= (unsigned char *)&stuff[1];
    memset(&list, 0, sizeof(XkbSrvListInfoRec));
    list.maxRtrn= stuff->maxNames;
    list.pattern[_XkbListKeycodes]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListTypes]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListCompat]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListSymbols]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListGeometry]= GetComponentSpec(&str,FALSE,&status);
    if (status!=Success)
	return status;
    len= str-((unsigned char *)stuff);
    if ((XkbPaddedSize(len)/4)!=stuff->length)
	return BadLength;
    if ((status=XkbDDXList(dev,&list,client))!=Success) {
	free(list.pool);
	list.pool = NULL;
	return status;
    }
    memset(&rep, 0, sizeof(xkbListComponentsReply));
    rep.type= X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = XkbPaddedSize(list.nPool)/4;
    rep.nKeymaps = 0;
    rep.nKeycodes = list.nFound[_XkbListKeycodes];
    rep.nTypes = list.nFound[_XkbListTypes];
    rep.nCompatMaps = list.nFound[_XkbListCompat];
    rep.nSymbols = list.nFound[_XkbListSymbols];
    rep.nGeometries = list.nFound[_XkbListGeometry];
    rep.extra=	0;
    if (list.nTotal>list.maxRtrn)
	rep.extra = (list.nTotal-list.maxRtrn);
    if (client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.nKeymaps,n);
	swaps(&rep.nKeycodes,n);
	swaps(&rep.nTypes,n);
	swaps(&rep.nCompatMaps,n);
	swaps(&rep.nSymbols,n);
	swaps(&rep.nGeometries,n);
	swaps(&rep.extra,n);
    }
    WriteToClient(client,SIZEOF(xkbListComponentsReply),(char *)&rep);
    if (list.nPool && list.pool) {
	WriteToClient(client,XkbPaddedSize(list.nPool), (char *)list.pool);
	free(list.pool);
	list.pool= NULL;
    }
    return Success;
}

/***====================================================================***/

int
ProcXkbGetKbdByName(ClientPtr client)
{
    DeviceIntPtr 		dev;
    DeviceIntPtr                tmpd;
    DeviceIntPtr                master;
    xkbGetKbdByNameReply 	rep = {0};
    xkbGetMapReply		mrep = {0};
    xkbGetCompatMapReply	crep = {0};
    xkbGetIndicatorMapReply	irep = {0};
    xkbGetNamesReply		nrep = {0};
    xkbGetGeometryReply		grep = {0};
    XkbComponentNamesRec	names = {0};
    XkbDescPtr			xkb, new;
    unsigned char *		str;
    char 			mapFile[PATH_MAX];
    unsigned			len;
    unsigned			fwant,fneed,reported;
    int				status;
    Bool			geom_changed;
    XkbSrvLedInfoPtr            old_sli;
    XkbSrvLedInfoPtr            sli;
    Mask access_mode = DixGetAttrAccess | DixManageAccess;

    REQUEST(xkbGetKbdByNameReq);
    REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);
    master = GetMaster(dev, MASTER_KEYBOARD);

    xkb = dev->key->xkbInfo->desc;
    status= Success;
    str= (unsigned char *)&stuff[1];
    if (GetComponentSpec(&str,TRUE,&status)) /* keymap, unsupported */
        return BadMatch;
    names.keycodes= GetComponentSpec(&str,TRUE,&status);
    names.types= GetComponentSpec(&str,TRUE,&status);
    names.compat= GetComponentSpec(&str,TRUE,&status);
    names.symbols= GetComponentSpec(&str,TRUE,&status);
    names.geometry= GetComponentSpec(&str,TRUE,&status);
    if (status!=Success)
	return status;
    len= str-((unsigned char *)stuff);
    if ((XkbPaddedSize(len)/4)!=stuff->length)
	return BadLength;

    CHK_MASK_LEGAL(0x01,stuff->want,XkbGBN_AllComponentsMask);
    CHK_MASK_LEGAL(0x02,stuff->need,XkbGBN_AllComponentsMask);
    
    if (stuff->load)
	 fwant= XkbGBN_AllComponentsMask;
    else fwant= stuff->want|stuff->need;
    if ((!names.compat)&&
        (fwant&(XkbGBN_CompatMapMask|XkbGBN_IndicatorMapMask))) {
        names.compat= Xstrdup("%");
    }
    if ((!names.types)&&(fwant&(XkbGBN_TypesMask))) {
        names.types= Xstrdup("%");
    }
    if ((!names.symbols)&&(fwant&XkbGBN_SymbolsMask)) {
        names.symbols= Xstrdup("%");
    }
    geom_changed= ((names.geometry!=NULL)&&(strcmp(names.geometry,"%")!=0));
    if ((!names.geometry)&&(fwant&XkbGBN_GeometryMask)) {
        names.geometry= Xstrdup("%");
        geom_changed= FALSE;
    }

    memset(mapFile, 0, PATH_MAX);
    rep.type= X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.minKeyCode = xkb->min_key_code;
    rep.maxKeyCode = xkb->max_key_code;
    rep.loaded=	FALSE;
    fwant= XkbConvertGetByNameComponents(TRUE,stuff->want)|XkmVirtualModsMask;
    fneed= XkbConvertGetByNameComponents(TRUE,stuff->need);
    rep.reported= XkbConvertGetByNameComponents(FALSE,fwant|fneed);
    if (stuff->load) {
	fneed|= XkmKeymapRequired;
	fwant|= XkmKeymapLegal;
    }
    if ((fwant|fneed)&XkmSymbolsMask) {
	fneed|= XkmKeyNamesIndex|XkmTypesIndex;
	fwant|= XkmIndicatorsIndex;
    }

    /* We pass dev in here so we can get the old names out if needed. */
    rep.found = XkbDDXLoadKeymapByNames(dev,&names,fwant,fneed,&new,
                                        mapFile,PATH_MAX);
    rep.newKeyboard= FALSE;
    rep.pad1= rep.pad2= rep.pad3= rep.pad4= 0;

    stuff->want|= stuff->need;
    if (new==NULL)
	rep.reported= 0;
    else {
	if (stuff->load)
	    rep.loaded= TRUE;
	if (stuff->load || 
		((rep.reported&XkbGBN_SymbolsMask) && (new->compat))) {
	    XkbChangesRec changes;
	    memset(&changes, 0, sizeof(changes));
	    XkbUpdateDescActions(new,
			new->min_key_code,XkbNumKeys(new),
			&changes);
	}

	if (new->map==NULL)
	    rep.reported&= ~(XkbGBN_SymbolsMask|XkbGBN_TypesMask);
	else if (rep.reported&(XkbGBN_SymbolsMask|XkbGBN_TypesMask)) {
	    mrep.type= X_Reply;
	    mrep.deviceID = dev->id;
	    mrep.sequenceNumber= client->sequence;
	    mrep.length = ((SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply))>>2);
	    mrep.minKeyCode = new->min_key_code;
	    mrep.maxKeyCode = new->max_key_code;
	    mrep.present = 0;
	    mrep.totalSyms = mrep.totalActs =
		mrep.totalKeyBehaviors= mrep.totalKeyExplicit= 
		mrep.totalModMapKeys= mrep.totalVModMapKeys= 0;
	    if (rep.reported&(XkbGBN_TypesMask|XkbGBN_ClientSymbolsMask)) {
		mrep.present|= XkbKeyTypesMask;
		mrep.firstType = 0;
		mrep.nTypes = mrep.totalTypes= new->map->num_types;
	    }
	    else {
		mrep.firstType = mrep.nTypes= 0;
		mrep.totalTypes= 0;
	    }
	    if (rep.reported&XkbGBN_ClientSymbolsMask) {
		mrep.present|= (XkbKeySymsMask|XkbModifierMapMask);
		mrep.firstKeySym = mrep.firstModMapKey= new->min_key_code;
		mrep.nKeySyms = mrep.nModMapKeys= XkbNumKeys(new);
	    }
	    else {
		mrep.firstKeySym= mrep.firstModMapKey= 0;
		mrep.nKeySyms= mrep.nModMapKeys= 0;
	    }
	    if (rep.reported&XkbGBN_ServerSymbolsMask) {
		mrep.present|= XkbAllServerInfoMask;
		mrep.virtualMods= ~0;
		mrep.firstKeyAct = mrep.firstKeyBehavior = 
			mrep.firstKeyExplicit = new->min_key_code;
		mrep.nKeyActs = mrep.nKeyBehaviors = 
			mrep.nKeyExplicit = XkbNumKeys(new);
		mrep.firstVModMapKey= new->min_key_code;
		mrep.nVModMapKeys= XkbNumKeys(new);
	    }
	    else {
		mrep.virtualMods= 0;
		mrep.firstKeyAct= mrep.firstKeyBehavior= 
			mrep.firstKeyExplicit = 0;
		mrep.nKeyActs= mrep.nKeyBehaviors= mrep.nKeyExplicit= 0;
	    }
	    XkbComputeGetMapReplySize(new,&mrep);
	    rep.length+= SIZEOF(xGenericReply)/4+mrep.length;
	}
	if (new->compat==NULL)
	    rep.reported&= ~XkbGBN_CompatMapMask;
	else if (rep.reported&XkbGBN_CompatMapMask) {
	    crep.type= X_Reply;
	    crep.deviceID= dev->id;
	    crep.sequenceNumber= client->sequence;
	    crep.length= 0;
	    crep.groups= XkbAllGroupsMask;
	    crep.firstSI= 0;
	    crep.nSI= crep.nTotalSI= new->compat->num_si;
	    XkbComputeGetCompatMapReplySize(new->compat,&crep);
	    rep.length+= SIZEOF(xGenericReply)/4+crep.length;
	}
	if (new->indicators==NULL)
	    rep.reported&= ~XkbGBN_IndicatorMapMask;
	else if (rep.reported&XkbGBN_IndicatorMapMask) {
	    irep.type= X_Reply;
	    irep.deviceID= dev->id;
	    irep.sequenceNumber= client->sequence;
	    irep.length= 0;
	    irep.which= XkbAllIndicatorsMask;
	    XkbComputeGetIndicatorMapReplySize(new->indicators,&irep);
	    rep.length+= SIZEOF(xGenericReply)/4+irep.length;
	}
	if (new->names==NULL)
	    rep.reported&= ~(XkbGBN_OtherNamesMask|XkbGBN_KeyNamesMask);
	else if (rep.reported&(XkbGBN_OtherNamesMask|XkbGBN_KeyNamesMask)) {
	    nrep.type= X_Reply;
	    nrep.deviceID= dev->id;
	    nrep.sequenceNumber= client->sequence;
	    nrep.length= 0;
	    nrep.minKeyCode= new->min_key_code;
	    nrep.maxKeyCode= new->max_key_code;
	    if (rep.reported&XkbGBN_OtherNamesMask) {
		nrep.which= XkbAllNamesMask;
		if (new->map!=NULL)
		     nrep.nTypes= new->map->num_types;
		else nrep.nTypes= 0;
		nrep.nKTLevels= 0;
		nrep.groupNames= XkbAllGroupsMask;
		nrep.virtualMods= XkbAllVirtualModsMask;
		nrep.indicators= XkbAllIndicatorsMask;
		nrep.nRadioGroups= new->names->num_rg;
	    }
	    else {
		nrep.which= 0;
		nrep.nTypes= 0;
		nrep.nKTLevels= 0;
		nrep.groupNames= 0;
		nrep.virtualMods= 0;
		nrep.indicators= 0;
		nrep.nRadioGroups= 0;
	    }
	    if (rep.reported&XkbGBN_KeyNamesMask) {
		nrep.which|= XkbKeyNamesMask;
		nrep.firstKey= new->min_key_code;
		nrep.nKeys= XkbNumKeys(new);
		nrep.nKeyAliases= new->names->num_key_aliases;
		if (nrep.nKeyAliases)
		    nrep.which|= XkbKeyAliasesMask;
	    }
	    else {
		nrep.which&= ~(XkbKeyNamesMask|XkbKeyAliasesMask);
		nrep.firstKey= nrep.nKeys= 0;
		nrep.nKeyAliases= 0;
	    }
	    XkbComputeGetNamesReplySize(new,&nrep);
	    rep.length+= SIZEOF(xGenericReply)/4+nrep.length;
	}
	if (new->geom==NULL)
	    rep.reported&= ~XkbGBN_GeometryMask;
	else if (rep.reported&XkbGBN_GeometryMask) {
	    grep.type= X_Reply;
	    grep.deviceID= dev->id;
	    grep.sequenceNumber= client->sequence;
	    grep.length= 0;
	    grep.found= TRUE;
	    grep.pad= 0;
	    grep.widthMM= grep.heightMM= 0;
	    grep.nProperties= grep.nColors= grep.nShapes= 0;
	    grep.nSections= grep.nDoodads= 0;
	    grep.baseColorNdx= grep.labelColorNdx= 0;
	    XkbComputeGetGeometryReplySize(new->geom,&grep,None);
	    rep.length+= SIZEOF(xGenericReply)/4+grep.length;
	}
    }

    reported= rep.reported;
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.found,n);
	swaps(&rep.reported,n);
    }
    WriteToClient(client,SIZEOF(xkbGetKbdByNameReply), (char *)&rep);
    if (reported&(XkbGBN_SymbolsMask|XkbGBN_TypesMask))
	XkbSendMap(client,new,&mrep);
    if (reported&XkbGBN_CompatMapMask)
	XkbSendCompatMap(client,new->compat,&crep);
    if (reported&XkbGBN_IndicatorMapMask)
	XkbSendIndicatorMap(client,new->indicators,&irep);
    if (reported&(XkbGBN_KeyNamesMask|XkbGBN_OtherNamesMask))
	XkbSendNames(client,new,&nrep);
    if (reported&XkbGBN_GeometryMask)
	XkbSendGeometry(client,new->geom,&grep,FALSE);
    if (rep.loaded) {
	XkbDescPtr		old_xkb;
	xkbNewKeyboardNotify 	nkn;
	int 			i,nG,nTG;
	old_xkb= xkb;
	xkb= new;
	dev->key->xkbInfo->desc= xkb;
	new= old_xkb; /* so it'll get freed automatically */

	*xkb->ctrls= *old_xkb->ctrls;
	for (nG=nTG=0,i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    nG= XkbKeyNumGroups(xkb,i);
	    if (nG>=XkbNumKbdGroups) {
		nTG= XkbNumKbdGroups;
		break;
	    }
	    if (nG>nTG) {
		nTG= nG;
	    }
	}
	xkb->ctrls->num_groups= nTG;

	nkn.deviceID= nkn.oldDeviceID= dev->id;
	nkn.minKeyCode= new->min_key_code;
	nkn.maxKeyCode= new->max_key_code;
	nkn.oldMinKeyCode= xkb->min_key_code;
	nkn.oldMaxKeyCode= xkb->max_key_code;
	nkn.requestMajor= XkbReqCode;
	nkn.requestMinor= X_kbGetKbdByName;
	nkn.changed= XkbNKN_KeycodesMask;
	if (geom_changed)
	    nkn.changed|= XkbNKN_GeometryMask;
	XkbSendNewKeyboardNotify(dev,&nkn);

        /* Update the map and LED info on the device itself, as well as
         * any slaves if it's an MD, or its MD if it's an SD and was the
         * last device used on that MD. */
        for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
            if (tmpd != dev && GetMaster(tmpd, MASTER_KEYBOARD) != dev &&
                (tmpd != master || dev != master->lastSlave))
                continue;

            if (tmpd != dev)
                XkbCopyDeviceKeymap(tmpd, dev);

            if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) {
                old_sli = tmpd->kbdfeed->xkb_sli;
                tmpd->kbdfeed->xkb_sli = NULL;
                sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0);
                if (sli) {
                    sli->explicitState = old_sli->explicitState;
                    sli->effectiveState = old_sli->effectiveState;
                }
                tmpd->kbdfeed->xkb_sli = sli;
                XkbFreeSrvLedInfo(old_sli);
            }
        }
    }
    if ((new!=NULL)&&(new!=xkb)) {
	XkbFreeKeyboard(new,XkbAllComponentsMask,TRUE);
	new= NULL;
    }
    XkbFreeComponentNames(&names, FALSE);
    return Success;
}

/***====================================================================***/

static int
ComputeDeviceLedInfoSize(	DeviceIntPtr		dev,
				unsigned int		what,
				XkbSrvLedInfoPtr	sli)
{
int			nNames,nMaps;
register unsigned 	n,bit;

    if (sli==NULL)
	return 0;
    nNames= nMaps= 0;
    if ((what&XkbXI_IndicatorNamesMask)==0)
	sli->namesPresent= 0;
    if ((what&XkbXI_IndicatorMapsMask)==0)
	sli->mapsPresent= 0;

    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
	if (sli->names && sli->names[n]!=None) {
	    sli->namesPresent|= bit;
	    nNames++;
	}
	if (sli->maps && XkbIM_InUse(&sli->maps[n])) {
	    sli->mapsPresent|= bit;
	    nMaps++;
	}
    }
    return (nNames*4)+(nMaps*SIZEOF(xkbIndicatorMapWireDesc));
}

static int 
CheckDeviceLedFBs(	DeviceIntPtr			dev,
			int				class,
			int				id,
			xkbGetDeviceInfoReply *		rep,
			ClientPtr			client)
{
int			nFBs= 0;
int			length= 0;
Bool			classOk;

    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
	else {
	    client->errorValue= _XkbErrCode2(XkbErr_BadClass,class);
	    return XkbKeyboardErrorCode;
	}
    }
    classOk= FALSE;
    if ((dev->kbdfeed)&&((class==KbdFeedbackClass)||(class==XkbAllXIClasses))) {
	KbdFeedbackPtr kf;
	classOk= TRUE;
	for (kf= dev->kbdfeed;(kf);kf=kf->next) {
	    if ((id!=XkbAllXIIds)&&(id!=XkbDfltXIId)&&(id!=kf->ctrl.id))
		continue;
	    nFBs++;
	    length+= SIZEOF(xkbDeviceLedsWireDesc);
	    if (!kf->xkb_sli)
		kf->xkb_sli= XkbAllocSrvLedInfo(dev,kf,NULL,0);
	    length+= ComputeDeviceLedInfoSize(dev,rep->present,kf->xkb_sli);
	    if (id!=XkbAllXIIds)
		break;
	}
    }
    if ((dev->leds)&&((class==LedFeedbackClass)||(class==XkbAllXIClasses))) {
	LedFeedbackPtr lf;
	classOk= TRUE;
	for (lf= dev->leds;(lf);lf=lf->next) {
	    if ((id!=XkbAllXIIds)&&(id!=XkbDfltXIId)&&(id!=lf->ctrl.id))
		continue;
	    nFBs++;
	    length+= SIZEOF(xkbDeviceLedsWireDesc);
	    if (!lf->xkb_sli)
		lf->xkb_sli= XkbAllocSrvLedInfo(dev,NULL,lf,0);
	    length+= ComputeDeviceLedInfoSize(dev,rep->present,lf->xkb_sli);
	    if (id!=XkbAllXIIds)
		break;
	}
    }
    if (nFBs>0) {
        rep->nDeviceLedFBs= nFBs;
        rep->length+= (length/4);
	return Success;
    }
    if (classOk) client->errorValue= _XkbErrCode2(XkbErr_BadId,id);
    else	 client->errorValue= _XkbErrCode2(XkbErr_BadClass,class);
    return XkbKeyboardErrorCode;
}

static int
SendDeviceLedInfo(	XkbSrvLedInfoPtr	sli,
			ClientPtr		client)
{
xkbDeviceLedsWireDesc	wire;
int			length;

    length= 0;
    wire.ledClass= 		sli->class;
    wire.ledID= 		sli->id;
    wire.namesPresent= 		sli->namesPresent;
    wire.mapsPresent=   	sli->mapsPresent;
    wire.physIndicators= 	sli->physIndicators;
    wire.state=			sli->effectiveState;
    if (client->swapped) {
	register int n;
	swaps(&wire.ledClass,n);
	swaps(&wire.ledID,n);
	swapl(&wire.namesPresent,n);
	swapl(&wire.mapsPresent,n);
	swapl(&wire.physIndicators,n);
	swapl(&wire.state,n);
    }
    WriteToClient(client,SIZEOF(xkbDeviceLedsWireDesc),(char *)&wire);
    length+= SIZEOF(xkbDeviceLedsWireDesc);
    if (sli->namesPresent|sli->mapsPresent) {
	register unsigned i,bit;
	if (sli->namesPresent) {
	    CARD32	awire;
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		if (sli->namesPresent&bit) {
		    awire= (CARD32)sli->names[i];
		    if (client->swapped) {
			register int n;
			swapl(&awire,n);
		    }
		    WriteToClient(client,4,(char *)&awire);
		    length+= 4;
		}
	    }
	}
	if (sli->mapsPresent) {
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		xkbIndicatorMapWireDesc	iwire;
		if (sli->mapsPresent&bit) {
		    iwire.flags= 	sli->maps[i].flags;
		    iwire.whichGroups=	sli->maps[i].which_groups;
		    iwire.groups=	sli->maps[i].groups;
		    iwire.whichMods=	sli->maps[i].which_mods;
		    iwire.mods=		sli->maps[i].mods.mask;
		    iwire.realMods=	sli->maps[i].mods.real_mods;
		    iwire.virtualMods=	sli->maps[i].mods.vmods;
		    iwire.ctrls= 	sli->maps[i].ctrls;
		    if (client->swapped) {
			register int n;
			swaps(&iwire.virtualMods,n);
			swapl(&iwire.ctrls,n);
		    }
		    WriteToClient(client,SIZEOF(xkbIndicatorMapWireDesc),
								(char *)&iwire);
		    length+= SIZEOF(xkbIndicatorMapWireDesc);
		}
	    }
	}
    }
    return length;
}

static int
SendDeviceLedFBs(	DeviceIntPtr	dev,
			int		class,
			int		id,
			unsigned	wantLength,
			ClientPtr	client)
{
int			length= 0;

    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
    }
    if ((dev->kbdfeed)&&
	((class==KbdFeedbackClass)||(class==XkbAllXIClasses))) {
	KbdFeedbackPtr kf;
	for (kf= dev->kbdfeed;(kf);kf=kf->next) {
	    if ((id==XkbAllXIIds)||(id==XkbDfltXIId)||(id==kf->ctrl.id)) {
		length+= SendDeviceLedInfo(kf->xkb_sli,client);
		if (id!=XkbAllXIIds)
		    break;
	    }
	}
    }
    if ((dev->leds)&&
	((class==LedFeedbackClass)||(class==XkbAllXIClasses))) {
	LedFeedbackPtr lf;
	for (lf= dev->leds;(lf);lf=lf->next) {
	    if ((id==XkbAllXIIds)||(id==XkbDfltXIId)||(id==lf->ctrl.id)) {
		length+= SendDeviceLedInfo(lf->xkb_sli,client);
		if (id!=XkbAllXIIds)
		    break;
	    }
	}
    }
    if (length==wantLength)
	 return Success;
    else return BadLength;
}

int
ProcXkbGetDeviceInfo(ClientPtr client)
{
DeviceIntPtr		dev;
xkbGetDeviceInfoReply	rep;
int			status,nDeviceLedFBs;
unsigned		length,nameLen;
CARD16			ledClass,ledID;
unsigned		wanted;
char *			str;

    REQUEST(xkbGetDeviceInfoReq);
    REQUEST_SIZE_MATCH(xkbGetDeviceInfoReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    wanted= stuff->wanted;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_LEGAL(0x01,wanted,XkbXI_AllDeviceFeaturesMask);

    if ((!dev->button)||((stuff->nBtns<1)&&(!stuff->allBtns)))
	wanted&= ~XkbXI_ButtonActionsMask;
    if ((!dev->kbdfeed)&&(!dev->leds))
	wanted&= ~XkbXI_IndicatorsMask;

    nameLen= XkbSizeCountedString(dev->name);
    memset((char *)&rep, 0, SIZEOF(xkbGetDeviceInfoReply));
    rep.type = X_Reply;
    rep.deviceID= dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = nameLen/4;
    rep.present = wanted;
    rep.supported = XkbXI_AllDeviceFeaturesMask;
    rep.unsupported = 0;
    rep.firstBtnWanted = rep.nBtnsWanted = 0;
    rep.firstBtnRtrn = rep.nBtnsRtrn = 0;
    if (dev->button)
	 rep.totalBtns= dev->button->numButtons;
    else rep.totalBtns= 0;
    rep.devType=	dev->xinput_type;
    rep.hasOwnState=	(dev->key && dev->key->xkbInfo);
    rep.nDeviceLedFBs = 0;
    if (dev->kbdfeed)	rep.dfltKbdFB= dev->kbdfeed->ctrl.id;
    else		rep.dfltKbdFB= XkbXINone;
    if (dev->leds)	rep.dfltLedFB= dev->leds->ctrl.id;
    else		rep.dfltLedFB= XkbXINone;

    ledClass= stuff->ledClass;
    ledID= stuff->ledID;

    rep.firstBtnWanted= rep.nBtnsWanted= 0;
    rep.firstBtnRtrn= rep.nBtnsRtrn= 0;
    if (wanted&XkbXI_ButtonActionsMask) {
	if (stuff->allBtns) {
	    stuff->firstBtn= 0;
	    stuff->nBtns= dev->button->numButtons;
	}

	if ((stuff->firstBtn+stuff->nBtns)>dev->button->numButtons) {
	    client->errorValue = _XkbErrCode4(0x02,dev->button->numButtons,
							stuff->firstBtn,
							stuff->nBtns);
	    return BadValue;
	}
	else {
	    rep.firstBtnWanted= stuff->firstBtn;
	    rep.nBtnsWanted= stuff->nBtns;
	    if (dev->button->xkb_acts!=NULL) {
		XkbAction *act;
		register int i;

		rep.firstBtnRtrn= stuff->firstBtn;
		rep.nBtnsRtrn= stuff->nBtns;
		act= &dev->button->xkb_acts[rep.firstBtnWanted];
		for (i=0;i<rep.nBtnsRtrn;i++,act++) {
		    if (act->type!=XkbSA_NoAction)
			break;
		}
		rep.firstBtnRtrn+=	i;
		rep.nBtnsRtrn-=		i;
		act= &dev->button->xkb_acts[rep.firstBtnRtrn+rep.nBtnsRtrn-1];
		for (i=0;i<rep.nBtnsRtrn;i++,act--) {
		    if (act->type!=XkbSA_NoAction)
			break;
		}
		rep.nBtnsRtrn-=		i;
	    }
	    rep.length+= (rep.nBtnsRtrn*SIZEOF(xkbActionWireDesc))/4;
	}
    }

    if (wanted&XkbXI_IndicatorsMask) {
	status= CheckDeviceLedFBs(dev,ledClass,ledID,&rep,client);
	if (status!=Success)
	    return status;
    }
    length= rep.length*4;
    nDeviceLedFBs = rep.nDeviceLedFBs;
    if (client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.present,n);
	swaps(&rep.supported,n);
	swaps(&rep.unsupported,n);
	swaps(&rep.nDeviceLedFBs,n);
	swapl(&rep.type,n);
	swaps(&rep.dfltKbdFB, n);
	swaps(&rep.dfltLedFB, n);
	swapl(&rep.devType, n);
    }
    WriteToClient(client,SIZEOF(xkbGetDeviceInfoReply), (char *)&rep);

    str= malloc(nameLen);
    if (!str) 
	return BadAlloc;
    XkbWriteCountedString(str,dev->name,client->swapped);
    WriteToClient(client,nameLen,str);
    free(str);
    length-= nameLen;

    if (rep.nBtnsRtrn>0) {
	int			sz;
	xkbActionWireDesc *	awire;
	sz= rep.nBtnsRtrn*SIZEOF(xkbActionWireDesc);
	awire= (xkbActionWireDesc *)&dev->button->xkb_acts[rep.firstBtnRtrn];
	WriteToClient(client,sz,(char *)awire);
	length-= sz;
    }
    if (nDeviceLedFBs>0) {
	status= SendDeviceLedFBs(dev,ledClass,ledID,length,client);
	if (status!=Success)
	    return status;
    }
    else if (length!=0)  {
	ErrorF("[xkb] Internal Error!  BadLength in ProcXkbGetDeviceInfo\n");
	ErrorF("[xkb]                  Wrote %d fewer bytes than expected\n",length);
	return BadLength;
    }
    return Success;
}

static char *
CheckSetDeviceIndicators(	char *		wire,
				DeviceIntPtr	dev,
				int		num,
				int *		status_rtrn,
				ClientPtr	client)
{
xkbDeviceLedsWireDesc *	ledWire;
int			i;
XkbSrvLedInfoPtr 	sli;

    ledWire= (xkbDeviceLedsWireDesc *)wire;
    for (i=0;i<num;i++) {
	if (client->swapped) {
	   register int n;
	   swaps(&ledWire->ledClass,n);
	   swaps(&ledWire->ledID,n);
	   swapl(&ledWire->namesPresent,n);
	   swapl(&ledWire->mapsPresent,n);
	   swapl(&ledWire->physIndicators,n);
	}

        sli= XkbFindSrvLedInfo(dev,ledWire->ledClass,ledWire->ledID,
							XkbXI_IndicatorsMask);
	if (sli!=NULL) {
	    register int n;
	    register unsigned bit;
	    int nMaps,nNames;
	    CARD32 *atomWire;
	    xkbIndicatorMapWireDesc *mapWire;

	    nMaps= nNames= 0;
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->namesPresent&bit)
		    nNames++;
		if (ledWire->mapsPresent&bit)
		    nMaps++;
	    }
	    atomWire= (CARD32 *)&ledWire[1];
	    if (nNames>0) {
		for (n=0;n<nNames;n++) {
		    if (client->swapped) {
			register int t;
			swapl(atomWire,t);
		    }
		    CHK_ATOM_OR_NONE3(((Atom)(*atomWire)),client->errorValue,
							*status_rtrn,NULL);
		    atomWire++;
		}
	    }
	    mapWire= (xkbIndicatorMapWireDesc *)atomWire;
	    if (nMaps>0) {
		for (n=0;n<nMaps;n++) {
		    if (client->swapped) {
			register int t;
			swaps(&mapWire->virtualMods,t);
			swapl(&mapWire->ctrls,t);
		    }
		    CHK_MASK_LEGAL3(0x21,mapWire->whichGroups,
						XkbIM_UseAnyGroup,
						client->errorValue,
						*status_rtrn,NULL);
		    CHK_MASK_LEGAL3(0x22,mapWire->whichMods,XkbIM_UseAnyMods,
						client->errorValue,
						*status_rtrn,NULL);
		    mapWire++;
		}
	    }
	    ledWire= (xkbDeviceLedsWireDesc *)mapWire;
	}
	else {
	    /* SHOULD NEVER HAPPEN */
	    return (char *)ledWire;
	}
    }
    return (char *)ledWire;
}

static char *
SetDeviceIndicators(	char *			wire,
			DeviceIntPtr		dev,
			unsigned		changed,
			int			num,
			int *			status_rtrn,
			ClientPtr		client,
			xkbExtensionDeviceNotify *ev)
{
xkbDeviceLedsWireDesc *		ledWire;
int				i;
XkbEventCauseRec		cause;
unsigned			namec,mapc,statec;
xkbExtensionDeviceNotify	ed;
XkbChangesRec			changes;
DeviceIntPtr			kbd;

    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    XkbSetCauseXkbReq(&cause,X_kbSetDeviceInfo,client);
    ledWire= (xkbDeviceLedsWireDesc *)wire;
    for (i=0;i<num;i++) {
	register int			n;
	register unsigned 		bit;
	CARD32 *			atomWire;
	xkbIndicatorMapWireDesc *	mapWire;
	XkbSrvLedInfoPtr		sli;

	namec= mapc= statec= 0;
    	sli= XkbFindSrvLedInfo(dev,ledWire->ledClass,ledWire->ledID,
						XkbXI_IndicatorMapsMask);
	if (!sli) {
	    /* SHOULD NEVER HAPPEN!! */
	    return (char *)ledWire;
	}

	atomWire= (CARD32 *)&ledWire[1];
	if (changed&XkbXI_IndicatorNamesMask) {
	    namec= sli->namesPresent|ledWire->namesPresent;
	    memset((char *)sli->names, 0, XkbNumIndicators*sizeof(Atom));
	}
	if (ledWire->namesPresent) {
	    sli->namesPresent= ledWire->namesPresent;
	    memset((char *)sli->names, 0, XkbNumIndicators*sizeof(Atom));
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->namesPresent&bit) {
		     sli->names[n]= (Atom)*atomWire;
		     if (sli->names[n]==None)
			ledWire->namesPresent&= ~bit;
		     atomWire++; 
		}
	    }
	}
	mapWire= (xkbIndicatorMapWireDesc *)atomWire;
	if (changed&XkbXI_IndicatorMapsMask) {
	    mapc= sli->mapsPresent|ledWire->mapsPresent;
	    sli->mapsPresent= ledWire->mapsPresent;
	    memset((char*)sli->maps, 0, XkbNumIndicators*sizeof(XkbIndicatorMapRec));
	}
	if (ledWire->mapsPresent) {
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->mapsPresent&bit) {
		    sli->maps[n].flags=		mapWire->flags;
		    sli->maps[n].which_groups=	mapWire->whichGroups;
		    sli->maps[n].groups=	mapWire->groups;
		    sli->maps[n].which_mods=	mapWire->whichMods;
		    sli->maps[n].mods.mask=	mapWire->mods;
		    sli->maps[n].mods.real_mods=mapWire->realMods;
		    sli->maps[n].mods.vmods=	mapWire->virtualMods;
		    sli->maps[n].ctrls=		mapWire->ctrls;
		    mapWire++; 
		}
	    }
	}
	if (changed&XkbXI_IndicatorStateMask) {
	    statec= sli->effectiveState^ledWire->state;
	    sli->explicitState&= ~statec;
	    sli->explicitState|= (ledWire->state&statec);
	}
	if (namec)
	    XkbApplyLedNameChanges(dev,sli,namec,&ed,&changes,&cause);
	if (mapc)
	    XkbApplyLedMapChanges(dev,sli,mapc,&ed,&changes,&cause);
	if (statec)
	    XkbApplyLedStateChanges(dev,sli,statec,&ed,&changes,&cause);

	kbd= dev;
	if ((sli->flags&XkbSLI_HasOwnState)==0)
	    kbd = inputInfo.keyboard;

	XkbFlushLedEvents(dev,kbd,sli,&ed,&changes,&cause);
	ledWire= (xkbDeviceLedsWireDesc *)mapWire;
    }
    return (char *)ledWire;
}


static int
_XkbSetDeviceInfo(ClientPtr client, DeviceIntPtr dev,
                  xkbSetDeviceInfoReq *stuff)
{
    char                       *wire;

    wire= (char *)&stuff[1];
    if (stuff->change&XkbXI_ButtonActionsMask) {
	if (!dev->button) {
	    client->errorValue = _XkbErrCode2(XkbErr_BadClass,ButtonClass);
	    return XkbKeyboardErrorCode;
	}
	if ((stuff->firstBtn+stuff->nBtns)>dev->button->numButtons) {
	    client->errorValue= _XkbErrCode4(0x02,stuff->firstBtn,stuff->nBtns,
						dev->button->numButtons);
	    return BadMatch;
	}
	wire+= (stuff->nBtns*SIZEOF(xkbActionWireDesc));
    }
    if (stuff->change&XkbXI_IndicatorsMask) {
	int status= Success;
	wire= CheckSetDeviceIndicators(wire,dev,stuff->nDeviceLedFBs,
							&status,client);
	if (status!=Success)
	    return status;
    }
    if (((wire-((char *)stuff))/4)!=stuff->length)
	return BadLength;

    return Success;
}

static int
_XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,
                       xkbSetDeviceInfoReq *stuff)
{
    char                       *wire;
    xkbExtensionDeviceNotify    ed;

    memset((char *)&ed, 0, SIZEOF(xkbExtensionDeviceNotify));
    ed.deviceID=	dev->id;
    wire= (char *)&stuff[1];
    if (stuff->change&XkbXI_ButtonActionsMask) {
	int			nBtns,sz,i;
	XkbAction *		acts;
	DeviceIntPtr		kbd;

	nBtns= dev->button->numButtons;
	acts= dev->button->xkb_acts;
	if (acts==NULL) {
	    acts= calloc(nBtns, sizeof(XkbAction));
	    if (!acts)
		return BadAlloc;
	    dev->button->xkb_acts= acts;
	}
	sz= stuff->nBtns*SIZEOF(xkbActionWireDesc);
	memcpy((char *)&acts[stuff->firstBtn],(char *)wire,sz);
	wire+= sz;
	ed.reason|=	XkbXI_ButtonActionsMask;
	ed.firstBtn=	stuff->firstBtn;
	ed.nBtns=	stuff->nBtns;

	if (dev->key)	kbd= dev;
	else		kbd= inputInfo.keyboard;
	acts= &dev->button->xkb_acts[stuff->firstBtn];
	for (i=0;i<stuff->nBtns;i++,acts++) {
	    if (acts->type!=XkbSA_NoAction)
		XkbSetActionKeyMods(kbd->key->xkbInfo->desc,acts,0);
	}
    }
    if (stuff->change&XkbXI_IndicatorsMask) {
	int status= Success;
	wire= SetDeviceIndicators(wire,dev,stuff->change,
				  stuff->nDeviceLedFBs, &status,client,&ed);
	if (status!=Success)
	    return status;
    }
    if ((stuff->change)&&(ed.reason))
	XkbSendExtensionDeviceNotify(dev,client,&ed);
    return Success;
}

int
ProcXkbSetDeviceInfo(ClientPtr client)
{
    DeviceIntPtr        dev;
    int                 rc;

    REQUEST(xkbSetDeviceInfoReq);
    REQUEST_AT_LEAST_SIZE(xkbSetDeviceInfoReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01,stuff->change,XkbXI_AllFeaturesMask);

    rc = _XkbSetDeviceInfoCheck(client, dev, stuff);

    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd || stuff->deviceSpec == XkbUseCorePtr)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if (((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev) &&
                ((stuff->deviceSpec == XkbUseCoreKbd && other->key) ||
                (stuff->deviceSpec == XkbUseCorePtr && other->button)))
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetDeviceInfoCheck(client, other, stuff);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* checks done, apply */
    rc = _XkbSetDeviceInfo(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd || stuff->deviceSpec == XkbUseCorePtr)
    {
        DeviceIntPtr other;
        for (other = inputInfo.devices; other; other = other->next)
        {
            if (((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev) &&
                ((stuff->deviceSpec == XkbUseCoreKbd && other->key) ||
                (stuff->deviceSpec == XkbUseCorePtr && other->button)))
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
                    rc = _XkbSetDeviceInfo(client, other, stuff);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbSetDebuggingFlags(ClientPtr client)
{
CARD32 				newFlags,newCtrls,extraLength;
xkbSetDebuggingFlagsReply 	rep;
int rc;

    REQUEST(xkbSetDebuggingFlagsReq);
    REQUEST_AT_LEAST_SIZE(xkbSetDebuggingFlagsReq);

    rc = XaceHook(XACE_SERVER_ACCESS, client, DixDebugAccess);
    if (rc != Success)
	return rc;

    newFlags=  xkbDebugFlags&(~stuff->affectFlags);
    newFlags|= (stuff->flags&stuff->affectFlags);
    newCtrls=  xkbDebugCtrls&(~stuff->affectCtrls);
    newCtrls|= (stuff->ctrls&stuff->affectCtrls);
    if (xkbDebugFlags || newFlags || stuff->msgLength) {
	ErrorF("[xkb] XkbDebug: Setting debug flags to 0x%lx\n",(long)newFlags);
	if (newCtrls!=xkbDebugCtrls)
	    ErrorF("[xkb] XkbDebug: Setting debug controls to 0x%lx\n",(long)newCtrls);
    }
    extraLength= (stuff->length<<2)-sz_xkbSetDebuggingFlagsReq;
    if (stuff->msgLength>0) {
	char *msg;
	if (extraLength<XkbPaddedSize(stuff->msgLength)) {
	    ErrorF("[xkb] XkbDebug: msgLength= %d, length= %ld (should be %d)\n",
			stuff->msgLength,(long)extraLength,
			XkbPaddedSize(stuff->msgLength));
	    return BadLength;
	}
	msg= (char *)&stuff[1];
	if (msg[stuff->msgLength-1]!='\0') {
	    ErrorF("[xkb] XkbDebug: message not null-terminated\n");
	    return BadValue;
	}
	ErrorF("[xkb] XkbDebug: %s\n",msg);
    }
    xkbDebugFlags = newFlags;
    xkbDebugCtrls = newCtrls;

    rep.type= X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.currentFlags = newFlags;
    rep.currentCtrls = newCtrls;
    rep.supportedFlags = ~0;
    rep.supportedCtrls = ~0;
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.currentFlags, n);
	swapl(&rep.currentCtrls, n);
	swapl(&rep.supportedFlags, n);
	swapl(&rep.supportedCtrls, n);
    }
    WriteToClient(client,SIZEOF(xkbSetDebuggingFlagsReply), (char *)&rep);
    return Success;
}

/***====================================================================***/

static int
ProcXkbDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_kbUseExtension:
	return ProcXkbUseExtension(client);
    case X_kbSelectEvents:
	return ProcXkbSelectEvents(client);
    case X_kbBell:
	return ProcXkbBell(client);
    case X_kbGetState:
	return ProcXkbGetState(client);
    case X_kbLatchLockState:
	return ProcXkbLatchLockState(client);
    case X_kbGetControls:
	return ProcXkbGetControls(client);
    case X_kbSetControls:
	return ProcXkbSetControls(client);
    case X_kbGetMap:
	return ProcXkbGetMap(client);
    case X_kbSetMap:
	return ProcXkbSetMap(client);
    case X_kbGetCompatMap:
	return ProcXkbGetCompatMap(client);
    case X_kbSetCompatMap:
	return ProcXkbSetCompatMap(client);
    case X_kbGetIndicatorState:
	return ProcXkbGetIndicatorState(client);
    case X_kbGetIndicatorMap:
	return ProcXkbGetIndicatorMap(client);
    case X_kbSetIndicatorMap:
	return ProcXkbSetIndicatorMap(client);
    case X_kbGetNamedIndicator:
	return ProcXkbGetNamedIndicator(client);
    case X_kbSetNamedIndicator:
	return ProcXkbSetNamedIndicator(client);
    case X_kbGetNames:
	return ProcXkbGetNames(client);
    case X_kbSetNames:
	return ProcXkbSetNames(client);
    case X_kbGetGeometry:
	return ProcXkbGetGeometry(client);
    case X_kbSetGeometry:
	return ProcXkbSetGeometry(client);
    case X_kbPerClientFlags:
	return ProcXkbPerClientFlags(client);
    case X_kbListComponents:
	return ProcXkbListComponents(client);
    case X_kbGetKbdByName:
	return ProcXkbGetKbdByName(client);
    case X_kbGetDeviceInfo:
	return ProcXkbGetDeviceInfo(client);
    case X_kbSetDeviceInfo:
	return ProcXkbSetDeviceInfo(client);
    case X_kbSetDebuggingFlags:
	return ProcXkbSetDebuggingFlags(client);
    default:
	return BadRequest;
    }
}

static int
XkbClientGone(pointer data,XID id)
{
    DevicePtr	pXDev = (DevicePtr)data;

    if (!XkbRemoveResourceClient(pXDev,id)) {
	ErrorF("[xkb] Internal Error! bad RemoveResourceClient in XkbClientGone\n");
    }
    return 1;
}

void
XkbExtensionInit(void)
{
    ExtensionEntry *extEntry;

    RT_XKBCLIENT = CreateNewResourceType(XkbClientGone, "XkbClient");
    if (!RT_XKBCLIENT)
	return;

    if (!XkbInitPrivates())
	return;

    if ((extEntry = AddExtension(XkbName, XkbNumberEvents, XkbNumberErrors,
				 ProcXkbDispatch, SProcXkbDispatch,
				 NULL, StandardMinorOpcode))) {
	XkbReqCode = (unsigned char)extEntry->base;
	XkbEventBase = (unsigned char)extEntry->eventBase;
	XkbErrorBase = (unsigned char)extEntry->errorBase;
	XkbKeyboardErrorCode = XkbErrorBase+XkbKeyboard;
    }
    return;
}


#ifndef _XKB_H
#define _XKB_H

extern int ProcXkbUseExtension(ClientPtr client);
extern int ProcXkbSelectEvents(ClientPtr client);
extern int ProcXkbBell(ClientPtr client);
extern int ProcXkbGetState(ClientPtr client);
extern int ProcXkbLatchLockState(ClientPtr client);
extern int ProcXkbGetControls(ClientPtr client);
extern int ProcXkbSetControls(ClientPtr client);
extern int ProcXkbGetMap(ClientPtr client);
extern int ProcXkbSetMap(ClientPtr client);
extern int ProcXkbGetCompatMap(ClientPtr client);
extern int ProcXkbSetCompatMap(ClientPtr client);
extern int ProcXkbGetIndicatorState(ClientPtr client);
extern int ProcXkbGetIndicatorMap(ClientPtr client);
extern int ProcXkbSetIndicatorMap(ClientPtr client);
extern int ProcXkbGetNamedIndicator(ClientPtr client);
extern int ProcXkbSetNamedIndicator(ClientPtr client);
extern int ProcXkbGetNames(ClientPtr client);
extern int ProcXkbSetNames(ClientPtr client);
extern int ProcXkbGetGeometry(ClientPtr client);
extern int ProcXkbSetGeometry(ClientPtr client);
extern int ProcXkbPerClientFlags(ClientPtr client);
extern int ProcXkbListComponents(ClientPtr client);
extern int ProcXkbGetKbdByName(ClientPtr client);
extern int ProcXkbGetDeviceInfo(ClientPtr client);
extern int ProcXkbSetDeviceInfo(ClientPtr client);
extern int ProcXkbSetDebuggingFlags(ClientPtr client);

extern void XkbExtensionInit(void);
#endif
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "exglobals.h"
#include <X11/extensions/XIproto.h>
#include "inputstr.h"
#include "eventstr.h"
#include <xkbsrv.h>
#if !defined(WIN32)
#include <sys/time.h>
#endif

int	XkbDfltRepeatDelay=	660;
int	XkbDfltRepeatInterval=	40;

#define	DFLT_TIMEOUT_CTRLS (XkbAX_KRGMask|XkbStickyKeysMask|XkbMouseKeysMask)
#define	DFLT_TIMEOUT_OPTS  (XkbAX_IndicatorFBMask)

unsigned short	XkbDfltAccessXTimeout= 	120;
unsigned int	XkbDfltAccessXTimeoutMask= DFLT_TIMEOUT_CTRLS;
static unsigned int XkbDfltAccessXTimeoutValues= 0;
static unsigned int XkbDfltAccessXTimeoutOptionsMask= DFLT_TIMEOUT_OPTS;
static unsigned int XkbDfltAccessXTimeoutOptionsValues= 0;
unsigned int	XkbDfltAccessXFeedback= XkbAccessXFeedbackMask;
unsigned short	XkbDfltAccessXOptions=  XkbAX_AllOptionsMask & ~(XkbAX_IndicatorFBMask|XkbAX_SKReleaseFBMask|XkbAX_SKRejectFBMask);

void
AccessXComputeCurveFactor(XkbSrvInfoPtr xkbi,XkbControlsPtr ctrls)
{
    xkbi->mouseKeysCurve= 1.0+(((double)ctrls->mk_curve)*0.001);
    xkbi->mouseKeysCurveFactor= ( ((double)ctrls->mk_max_speed)/
	pow((double)ctrls->mk_time_to_max,xkbi->mouseKeysCurve));
    return;
}

void
AccessXInit(DeviceIntPtr keybd)
{
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;

    xkbi->shiftKeyCount= 0;
    xkbi->mouseKeysCounter= 0;
    xkbi->inactiveKey= 0;
    xkbi->slowKey= 0;
    xkbi->repeatKey= 0;
    xkbi->krgTimerActive= _OFF_TIMER;
    xkbi->beepType= _BEEP_NONE;
    xkbi->beepCount= 0;
    xkbi->mouseKeyTimer= NULL;
    xkbi->slowKeysTimer= NULL;
    xkbi->bounceKeysTimer= NULL;
    xkbi->repeatKeyTimer= NULL;
    xkbi->krgTimer= NULL;
    xkbi->beepTimer= NULL;
    ctrls->repeat_delay = XkbDfltRepeatDelay;
    ctrls->repeat_interval = XkbDfltRepeatInterval;
    ctrls->debounce_delay = 300;
    ctrls->slow_keys_delay = 300;
    ctrls->mk_delay = 160;
    ctrls->mk_interval = 40;
    ctrls->mk_time_to_max = 30;
    ctrls->mk_max_speed = 30;
    ctrls->mk_curve = 500;
    ctrls->mk_dflt_btn = 1;
    ctrls->ax_timeout = XkbDfltAccessXTimeout;
    ctrls->axt_ctrls_mask = XkbDfltAccessXTimeoutMask;
    ctrls->axt_ctrls_values = XkbDfltAccessXTimeoutValues;
    ctrls->axt_opts_mask = XkbDfltAccessXTimeoutOptionsMask;
    ctrls->axt_opts_values = XkbDfltAccessXTimeoutOptionsValues;
    if (XkbDfltAccessXTimeout)
	ctrls->enabled_ctrls |= XkbAccessXTimeoutMask;
    else
	ctrls->enabled_ctrls &= ~XkbAccessXTimeoutMask;
    ctrls->enabled_ctrls |= XkbDfltAccessXFeedback;
    ctrls->ax_options = XkbDfltAccessXOptions; 
    AccessXComputeCurveFactor(xkbi,ctrls);
    return;
}

/************************************************************************/
/*									*/
/* AccessXKeyboardEvent							*/
/*									*/
/*	Generate a synthetic keyboard event.				*/
/*									*/
/************************************************************************/
static void 
AccessXKeyboardEvent(DeviceIntPtr	keybd,
				 int		type,
				 BYTE		keyCode,
				 Bool		isRepeat)
{
    DeviceEvent event;
    memset(&event, 0, sizeof(DeviceEvent));
    event.header = ET_Internal;
    event.type = type;
    event.detail.key = keyCode;
    event.time = GetTimeInMillis();
    event.length = sizeof(DeviceEvent);
    event.key_repeat = isRepeat;
    event.sourceid = keybd->id;
    event.deviceid = keybd->id;

    if (xkbDebugFlags&0x8) {
	DebugF("[xkb] AXKE: Key %d %s\n", keyCode,
               (event.type == ET_KeyPress ? "down" : "up"));
    }

    XkbProcessKeyboardEvent(&event, keybd);
    return;
} /* AccessXKeyboardEvent */

/************************************************************************/
/*									*/
/* AccessXKRGTurnOn							*/
/*									*/
/*	Turn the keyboard response group on.				*/
/*									*/
/************************************************************************/
static void
AccessXKRGTurnOn(DeviceIntPtr dev,CARD16 KRGControl,xkbControlsNotify	*pCN)
{
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old= *ctrls;
    ctrls->enabled_ctrls |= (KRGControl&XkbAX_KRGMask);
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_ON,KRGControl);
    return;
    
} /* AccessXKRGTurnOn */

/************************************************************************/
/*									*/
/* AccessXKRGTurnOff							*/
/*									*/
/*	Turn the keyboard response group off.				*/
/*									*/
/************************************************************************/
static void 
AccessXKRGTurnOff(DeviceIntPtr dev,xkbControlsNotify *pCN)
{
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old = *ctrls;
    ctrls->enabled_ctrls &= ~XkbAX_KRGMask;
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	unsigned changes= old.enabled_ctrls^ctrls->enabled_ctrls;
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_OFF,changes);
    }
    return;
    
} /* AccessXKRGTurnOff */

/************************************************************************/
/*									*/
/* AccessXStickyKeysTurnOn						*/
/*									*/
/*	Turn StickyKeys on.						*/
/*									*/
/************************************************************************/
static void
AccessXStickyKeysTurnOn(DeviceIntPtr dev,xkbControlsNotify *pCN)
{
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old = *ctrls;
    ctrls->enabled_ctrls |= XkbStickyKeysMask;
    xkbi->shiftKeyCount = 0;
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_ON,XkbStickyKeysMask);
    }
    return;
    
} /* AccessXStickyKeysTurnOn */

/************************************************************************/
/*									*/
/* AccessXStickyKeysTurnOff						*/
/*									*/
/*	Turn StickyKeys off.						*/
/*									*/
/************************************************************************/
static void
AccessXStickyKeysTurnOff(DeviceIntPtr dev,xkbControlsNotify *pCN)
{
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old = *ctrls;
    ctrls->enabled_ctrls &= ~XkbStickyKeysMask;
    xkbi->shiftKeyCount = 0;
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);

    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_OFF,XkbStickyKeysMask);
    }
#ifndef NO_CLEAR_LATCHES_FOR_STICKY_KEYS_OFF
    XkbClearAllLatchesAndLocks(dev,xkbi,FALSE,&cause);
#endif
    return;
} /* AccessXStickyKeysTurnOff */

static CARD32
AccessXKRGExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
XkbSrvInfoPtr		xkbi= ((DeviceIntPtr)arg)->key->xkbInfo;
xkbControlsNotify	cn;

    if (xkbi->krgTimerActive==_KRG_WARN_TIMER) {
	XkbDDXAccessXBeep((DeviceIntPtr)arg,_BEEP_SLOW_WARN,XkbStickyKeysMask);
	xkbi->krgTimerActive= _KRG_TIMER;
	return 4000;
    }
    xkbi->krgTimerActive= _OFF_TIMER;
    cn.keycode = 0;
    cn.eventType = 0;
    cn.requestMajor = 0;
    cn.requestMinor = 0;
    if (xkbi->desc->ctrls->enabled_ctrls&XkbSlowKeysMask)
	 AccessXKRGTurnOff((DeviceIntPtr)arg,&cn);
    else AccessXKRGTurnOn((DeviceIntPtr)arg,XkbSlowKeysMask,&cn);
    return 0;
}

static CARD32
AccessXRepeatKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
DeviceIntPtr    dev = (DeviceIntPtr) arg;
XkbSrvInfoPtr	xkbi = dev->key->xkbInfo;

    if (xkbi->repeatKey == 0)
	return 0;

    AccessXKeyboardEvent(dev, ET_KeyPress, xkbi->repeatKey, TRUE);

    return xkbi->desc->ctrls->repeat_interval;
}

void
AccessXCancelRepeatKey(XkbSrvInfoPtr xkbi,KeyCode key)
{
    if (xkbi->repeatKey==key)
	xkbi->repeatKey= 0;
    return;
}

static CARD32
AccessXSlowKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
DeviceIntPtr	keybd;
XkbSrvInfoPtr	xkbi;
XkbDescPtr	xkb;
XkbControlsPtr	ctrls;

    keybd= 	(DeviceIntPtr)arg;
    xkbi= 	keybd->key->xkbInfo;
    xkb= 	xkbi->desc;
    ctrls= 	xkb->ctrls;
    if (xkbi->slowKey!=0) {
	xkbAccessXNotify ev;
	KeySym *sym= XkbKeySymsPtr(xkb,xkbi->slowKey);
	ev.detail= XkbAXN_SKAccept;
	ev.keycode= xkbi->slowKey;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKAcceptFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_SLOW_ACCEPT,XkbSlowKeysMask);
	AccessXKeyboardEvent(keybd, ET_KeyPress,xkbi->slowKey,FALSE);
	/* check for magic sequences */
	if ((ctrls->enabled_ctrls&XkbAccessXKeysMask) &&
	    ((sym[0]==XK_Shift_R)||(sym[0]==XK_Shift_L)))
	    xkbi->shiftKeyCount++;

	/* Start repeating if necessary.  Stop autorepeating if the user
	 * presses a non-modifier key that doesn't autorepeat.
	 */
	if (keybd->kbdfeed->ctrl.autoRepeat && 
	    ((xkbi->slowKey != xkbi->mouseKey) || (!xkbi->mouseKeysAccel)) &&
	     (ctrls->enabled_ctrls&XkbRepeatKeysMask)) {
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,xkbi->slowKey)) {
		xkbi->repeatKey = xkbi->slowKey;
		xkbi->repeatKeyTimer= TimerSet(xkbi->repeatKeyTimer,
					0, ctrls->repeat_delay,
					AccessXRepeatKeyExpire, (pointer)keybd);
	    }
	}
    }
    return 0;
}

static CARD32
AccessXBounceKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
XkbSrvInfoPtr	xkbi= ((DeviceIntPtr)arg)->key->xkbInfo;

    xkbi->inactiveKey= 0;
    return 0;
}

static CARD32
AccessXTimeoutExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
DeviceIntPtr		dev = (DeviceIntPtr)arg;
XkbSrvInfoPtr		xkbi= dev->key->xkbInfo;
XkbControlsPtr		ctrls= xkbi->desc->ctrls;
XkbControlsRec		old;
xkbControlsNotify	cn;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    if (xkbi->lastPtrEventTime) {
	unsigned timeToWait = (ctrls->ax_timeout*1000);
	unsigned timeElapsed = (now-xkbi->lastPtrEventTime);

	if (timeToWait > timeElapsed)
	    return timeToWait - timeElapsed;
    }
    old= *ctrls;
    xkbi->shiftKeyCount= 0;
    ctrls->enabled_ctrls&= ~ctrls->axt_ctrls_mask;
    ctrls->enabled_ctrls|= 
	(ctrls->axt_ctrls_values&ctrls->axt_ctrls_mask);
    if (ctrls->axt_opts_mask) {
	ctrls->ax_options&= ~ctrls->axt_opts_mask;
	ctrls->ax_options|= (ctrls->axt_opts_values&ctrls->axt_opts_mask);
    }
    if (XkbComputeControlsNotify(dev,&old,ctrls,&cn,FALSE)) {
	cn.keycode = 0;
	cn.eventType = 0;
	cn.requestMajor = 0;
	cn.requestMinor = 0;
	XkbSendControlsNotify(dev,&cn);
    }
    XkbSetCauseUnknown(&cause);
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (ctrls->ax_options!=old.ax_options) {
	unsigned set,cleared,bell;
	set= ctrls->ax_options&(~old.ax_options);
	cleared= (~ctrls->ax_options)&old.ax_options;
	if (set && cleared)	bell= _BEEP_FEATURE_CHANGE;
	else if (set)		bell= _BEEP_FEATURE_ON;
	else 			bell= _BEEP_FEATURE_OFF;
	XkbDDXAccessXBeep(dev,bell,XkbAccessXTimeoutMask);
    }
    xkbi->krgTimerActive= _OFF_TIMER;
    return 0;
}


/************************************************************************/
/*									*/
/* AccessXFilterPressEvent						*/
/*									*/
/* Filter events before they get any further if SlowKeys is turned on.	*/
/* In addition, this routine handles the ever so popular magic key	*/
/* acts for turning various accessibility features on/off.		*/
/*									*/
/* Returns TRUE if this routine has discarded the event.		*/
/* Returns FALSE if the event needs further processing.			*/
/*									*/
/************************************************************************/
Bool
AccessXFilterPressEvent(	DeviceEvent*	event,
				DeviceIntPtr	keybd)
{
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;
Bool		ignoreKeyEvent = FALSE;
KeyCode		key = event->detail.key;
KeySym *	sym = XkbKeySymsPtr(xkbi->desc,key);

    if (ctrls->enabled_ctrls&XkbAccessXKeysMask) {
	/* check for magic sequences */
	if ((sym[0]==XK_Shift_R)||(sym[0]==XK_Shift_L)) {
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_SlowWarnFBMask)) {
		xkbi->krgTimerActive = _KRG_WARN_TIMER;
		xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 4000,
					AccessXKRGExpire, (pointer)keybd);
	    }
	    else {
		xkbi->krgTimerActive = _KRG_TIMER;
		xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 8000,
					AccessXKRGExpire, (pointer)keybd);
	    }
	    if (!(ctrls->enabled_ctrls & XkbSlowKeysMask)) {
		CARD32 now= GetTimeInMillis();
		if ((now-xkbi->lastShiftEventTime)>15000)
		     xkbi->shiftKeyCount= 1;
		else xkbi->shiftKeyCount++;
		xkbi->lastShiftEventTime= now;
	    }
	}
	else {
	    if (xkbi->krgTimerActive) {
		xkbi->krgTimer= TimerSet(xkbi->krgTimer,0, 0, NULL, NULL);
		xkbi->krgTimerActive= _OFF_TIMER;
	    }
	}
    }
	
    /* Don't transmit the KeyPress if SlowKeys is turned on;
     * The wakeup handler will synthesize one for us if the user
     * has held the key long enough.
     */
    if (ctrls->enabled_ctrls & XkbSlowKeysMask) {
	xkbAccessXNotify	ev;
	/* If key was already pressed, ignore subsequent press events
	 * from the server's autorepeat
	 */
	if(xkbi->slowKey == key)
	    return TRUE;
	ev.detail= XkbAXN_SKPress;
	ev.keycode= key;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKPressFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_SLOW_PRESS,XkbSlowKeysMask);
	xkbi->slowKey= key;
	xkbi->slowKeysTimer = TimerSet(xkbi->slowKeysTimer,
				 0, ctrls->slow_keys_delay,
				 AccessXSlowKeyExpire, (pointer)keybd);
	ignoreKeyEvent = TRUE;
    }

    /* Don't transmit the KeyPress if BounceKeys is turned on
     * and the user pressed the same key within a given time period
     * from the last release.
     */
    else if ((ctrls->enabled_ctrls & XkbBounceKeysMask) && 
					(key == xkbi->inactiveKey)) {
	if (XkbAX_NeedFeedback(ctrls,XkbAX_BKRejectFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_BOUNCE_REJECT,XkbBounceKeysMask);
	ignoreKeyEvent = TRUE;
    }

    /* Start repeating if necessary.  Stop autorepeating if the user
     * presses a non-modifier key that doesn't autorepeat.
     */
    if (XkbDDXUsesSoftRepeat(keybd)) {
	if ((keybd->kbdfeed->ctrl.autoRepeat) &&
		((ctrls->enabled_ctrls&(XkbSlowKeysMask|XkbRepeatKeysMask))==
							XkbRepeatKeysMask)) {
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,key)) {
		if (xkbDebugFlags&0x10)
		    DebugF("Starting software autorepeat...\n");
		if (xkbi->repeatKey == key)
		    ignoreKeyEvent = TRUE;
		else {
		    xkbi->repeatKey = key;
		    xkbi->repeatKeyTimer= TimerSet(xkbi->repeatKeyTimer,
			    0, ctrls->repeat_delay,
			    AccessXRepeatKeyExpire, (pointer)keybd);
		}
	    }
	}
    }
    
    /* Check for two keys being pressed at the same time.  This section
     * essentially says the following:
     *
     *	If StickyKeys is on, and a modifier is currently being held down,
     *  and one of the following is true:  the current key is not a modifier
     *  or the currentKey is a modifier, but not the only modifier being
     *  held down, turn StickyKeys off if the TwoKeys off ctrl is set.
     */
    if ((ctrls->enabled_ctrls & XkbStickyKeysMask) && 
				(xkbi->state.base_mods!=0) &&
				(XkbAX_NeedOption(ctrls,XkbAX_TwoKeysMask))) {
	xkbControlsNotify cn;
	cn.keycode = key;
	cn.eventType = KeyPress;
	cn.requestMajor = 0;
	cn.requestMinor = 0;
	AccessXStickyKeysTurnOff(keybd,&cn);
    }
    
    if (!ignoreKeyEvent)
	XkbProcessKeyboardEvent(event, keybd);
    return ignoreKeyEvent;
} /* AccessXFilterPressEvent */

/************************************************************************/
/*									*/
/* AccessXFilterReleaseEvent						*/
/*									*/
/* Filter events before they get any further if SlowKeys is turned on.	*/
/* In addition, this routine handles the ever so popular magic key	*/
/* acts for turning various accessibility features on/off.		*/
/*									*/
/* Returns TRUE if this routine has discarded the event.		*/
/* Returns FALSE if the event needs further processing.			*/
/*									*/
/************************************************************************/
Bool
AccessXFilterReleaseEvent(	DeviceEvent*	event,
				DeviceIntPtr	keybd)
{
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;
KeyCode		key = event->detail.key;
Bool		ignoreKeyEvent = FALSE;
    
    /* Don't transmit the KeyRelease if BounceKeys is on and
     * this is the release of a key that was ignored due to 
     * BounceKeys.
     */
    if (ctrls->enabled_ctrls & XkbBounceKeysMask) {
	if ((key!=xkbi->mouseKey)&&(!BitIsOn(keybd->key->down,key)))
	    ignoreKeyEvent = TRUE;
	xkbi->inactiveKey= key;
	xkbi->bounceKeysTimer= TimerSet(xkbi->bounceKeysTimer, 0,
					ctrls->debounce_delay,
					AccessXBounceKeyExpire, (pointer)keybd);
    }

    /* Don't transmit the KeyRelease if SlowKeys is turned on and
     * the user didn't hold the key long enough.  We know we passed
     * the key if the down bit was set by CoreProcessKeyboadEvent.
     */
    if (ctrls->enabled_ctrls & XkbSlowKeysMask) {
	xkbAccessXNotify	ev;
	unsigned		beep_type;
	ev.keycode= key;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	if (BitIsOn(keybd->key->down,key) || (xkbi->mouseKey == key)) {
	    ev.detail= XkbAXN_SKRelease;
	    beep_type= _BEEP_SLOW_RELEASE;
	}
	else {
	    ev.detail= XkbAXN_SKReject;
	    beep_type= _BEEP_SLOW_REJECT;
	    ignoreKeyEvent = TRUE;
	}
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKRejectFBMask)) {
	    XkbDDXAccessXBeep(keybd,beep_type,XkbSlowKeysMask);
	}
	if (xkbi->slowKey==key)
	    xkbi->slowKey= 0;
    }

    /* Stop Repeating if the user releases the key that is currently
     * repeating.
     */
    if (xkbi->repeatKey==key) {
	xkbi->repeatKey= 0;
    }

    if ((ctrls->enabled_ctrls&XkbAccessXTimeoutMask)&&(ctrls->ax_timeout>0)) {
	xkbi->lastPtrEventTime= 0;
	xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 
					ctrls->ax_timeout*1000,
					AccessXTimeoutExpire, (pointer)keybd);
	xkbi->krgTimerActive= _ALL_TIMEOUT_TIMER;
    }
    else if (xkbi->krgTimerActive!=_OFF_TIMER) {
	xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 0, NULL, NULL);
	xkbi->krgTimerActive= _OFF_TIMER;
    }
	
    /* Keep track of how many times the Shift key has been pressed.
     * If it has been pressed and released 5 times in a row, toggle
     * the state of StickyKeys.
     */
    if ((!ignoreKeyEvent)&&(xkbi->shiftKeyCount)) {
	KeySym *pSym= XkbKeySymsPtr(xkbi->desc,key);
	if ((pSym[0]!=XK_Shift_L)&&(pSym[0]!=XK_Shift_R)) {
	    xkbi->shiftKeyCount= 0;
	}
	else if (xkbi->shiftKeyCount>=5) {
	     xkbControlsNotify cn;
	     cn.keycode = key;
	     cn.eventType = KeyPress;
	     cn.requestMajor = 0;
	     cn.requestMinor = 0;
	     if (ctrls->enabled_ctrls & XkbStickyKeysMask)
		AccessXStickyKeysTurnOff(keybd,&cn);
	     else
		AccessXStickyKeysTurnOn(keybd,&cn);
	     xkbi->shiftKeyCount= 0;
	}
    }
    
    if (!ignoreKeyEvent)
	XkbProcessKeyboardEvent(event, keybd);
    return ignoreKeyEvent;
    
} /* AccessXFilterReleaseEvent */

/************************************************************************/
/*									*/
/* ProcessPointerEvent							*/
/*									*/
/* This routine merely sets the shiftKeyCount and clears the keyboard   */
/* response group timer (if necessary) on a mouse event.  This is so	*/
/* multiple shifts with just the mouse and shift-drags with the mouse	*/
/* don't accidentally turn on StickyKeys or the Keyboard Response Group.*/
/*									*/
/************************************************************************/
extern int xkbDevicePrivateIndex;
extern void xkbUnwrapProc(DeviceIntPtr, DeviceHandleProc, pointer);
void
ProcessPointerEvent(	InternalEvent   *ev,
			DeviceIntPtr    mouse)
{
DeviceIntPtr	dev;
XkbSrvInfoPtr	xkbi = NULL;
unsigned 	changed = 0;
ProcessInputProc backupproc;
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(mouse);
DeviceEvent     *event = &ev->device_event;

    dev = IsFloating(mouse) ? mouse : GetMaster(mouse, MASTER_KEYBOARD);

    if (dev && dev->key)
    {
	xkbi = dev->key->xkbInfo;
	xkbi->shiftKeyCount = 0;
	xkbi->lastPtrEventTime= event->time;
    }

    if (event->type == ET_ButtonPress) {
	    changed |= XkbPointerButtonMask;
    }
    else if (event->type == ET_ButtonRelease) {
	if (xkbi) {
	    xkbi->lockedPtrButtons&= ~(1 << (event->detail.key & 0x7));

            if (IsMaster(dev))
            {
                DeviceIntPtr source;
                int rc;
                rc = dixLookupDevice(&source, event->sourceid, serverClient, DixWriteAccess);
                if (rc != Success)
                    ErrorF("[xkb] bad sourceid '%d' on button release event.\n", event->sourceid);
                else if (!IsXTestDevice(source, GetMaster(dev, MASTER_POINTER)))
                    XkbFakeDeviceButton(dev, FALSE, event->detail.key);
            }
	}

	changed |= XkbPointerButtonMask;
    }

    UNWRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr, backupproc);
    mouse->public.processInputProc(ev, mouse);
    COND_WRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr,
				     backupproc, xkbUnwrapProc);

    if (!xkbi)
	return;

    xkbi->state.ptr_buttons = (mouse->button) ? mouse->button->state : 0;
    
    /* clear any latched modifiers */
    if ( xkbi->state.latched_mods && (event->type == ET_ButtonRelease) ) {
	unsigned 		changed_leds;
	XkbStateRec		oldState;
	XkbSrvLedInfoPtr	sli;

	sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
	oldState= xkbi->state;
	XkbLatchModifiers(dev,0xFF,0x00);

	XkbComputeDerivedState(xkbi);
	changed |= XkbStateChangedFlags(&oldState,&xkbi->state);
	if (changed&sli->usedComponents) {
	    changed_leds= XkbIndicatorsToUpdate(dev,changed,FALSE);
	    if (changed_leds) {
		XkbEventCauseRec	cause;
		XkbSetCauseKey(&cause,(event->detail.key & 0x7), event->type);
		XkbUpdateIndicators(dev,changed_leds,TRUE,NULL,&cause);
	    }
	}
    }

    if (((xkbi->flags&_XkbStateNotifyInProgress)==0)&&(changed!=0)) {
	xkbStateNotify	sn;
	sn.keycode= event->detail.key;
	sn.eventType= event->type;
	sn.requestMajor = sn.requestMinor = 0;
	sn.changed= changed;
	XkbSendStateNotify(dev,&sn);
    }

} /* ProcessPointerEvent */




/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "exevents.h"
#include "eventstr.h"
#include <xkbsrv.h>
#include "xkb.h"
#include <ctype.h>
#include "mi.h"
#include "mipointer.h"
#include "inpututils.h"
#define EXTENSION_EVENT_BASE 64

DevPrivateKeyRec xkbDevicePrivateKeyRec;

void XkbFakeDeviceButton(DeviceIntPtr dev,Bool press,int button);
static void XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags,int x,int y);

void
xkbUnwrapProc(DeviceIntPtr device, DeviceHandleProc proc,
                   pointer data)
{
    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(device);
    ProcessInputProc backupproc;
    if(xkbPrivPtr->unwrapProc)
	xkbPrivPtr->unwrapProc = NULL;

    UNWRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr, backupproc);
    proc(device,data);
    COND_WRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr,
				 backupproc,xkbUnwrapProc);
}

Bool
XkbInitPrivates(void)
{
    return dixRegisterPrivateKey(&xkbDevicePrivateKeyRec, PRIVATE_DEVICE, sizeof(xkbDeviceInfoRec));
}

void
XkbSetExtension(DeviceIntPtr device, ProcessInputProc proc)
{
    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(device);
    WRAP_PROCESS_INPUT_PROC(device, xkbPrivPtr, proc, xkbUnwrapProc);
}

/***====================================================================***/

static XkbAction
_FixUpAction(XkbDescPtr xkb,XkbAction *act)
{
static XkbAction	fake;

    if (XkbIsPtrAction(act)&&(!(xkb->ctrls->enabled_ctrls&XkbMouseKeysMask))) {
	fake.type = XkbSA_NoAction;
	return fake;
    }
    if (xkb->ctrls->enabled_ctrls&XkbStickyKeysMask) {
	if (act->any.type==XkbSA_SetMods) {
	    fake.mods.type = XkbSA_LatchMods;
	    fake.mods.mask = act->mods.mask;
	    if (XkbAX_NeedOption(xkb->ctrls,XkbAX_LatchToLockMask))
		 fake.mods.flags= XkbSA_ClearLocks|XkbSA_LatchToLock;
	    else fake.mods.flags= XkbSA_ClearLocks;
	    return fake;
	}
	if (act->any.type==XkbSA_SetGroup) {
	    fake.group.type = XkbSA_LatchGroup;
	    if (XkbAX_NeedOption(xkb->ctrls,XkbAX_LatchToLockMask))
		 fake.group.flags= XkbSA_ClearLocks|XkbSA_LatchToLock;
	    else fake.group.flags= XkbSA_ClearLocks;
	    XkbSASetGroup(&fake.group,XkbSAGroup(&act->group));
	    return fake;
	}
    }
    return *act;
}

static XkbAction
XkbGetKeyAction(XkbSrvInfoPtr xkbi,XkbStatePtr xkbState,CARD8 key)
{
int			effectiveGroup;
int			col;
XkbDescPtr		xkb;
XkbKeyTypePtr		type;
XkbAction *		pActs;
static XkbAction 	fake;

    xkb= xkbi->desc;
    if (!XkbKeyHasActions(xkb,key) || !XkbKeycodeInRange(xkb,key)) {
	fake.type = XkbSA_NoAction;
	return fake;
    }
    pActs= XkbKeyActionsPtr(xkb,key);
    col= 0;

    effectiveGroup = XkbGetEffectiveGroup(xkbi, xkbState, key);
    if (effectiveGroup != XkbGroup1Index)
        col += (effectiveGroup * XkbKeyGroupsWidth(xkb, key));

    type= XkbKeyKeyType(xkb,key,effectiveGroup);
    if (type->map!=NULL) {
	register unsigned		i,mods;
	register XkbKTMapEntryPtr	entry;
	mods= xkbState->mods&type->mods.mask;
	for (entry= type->map,i=0;i<type->map_count;i++,entry++) {
	    if ((entry->active)&&(entry->mods.mask==mods)) {
		col+= entry->level;
		break;
	    }
	}
    }
    if (pActs[col].any.type==XkbSA_NoAction)
	return pActs[col];
    fake= _FixUpAction(xkb,&pActs[col]);
    return fake;
}

static XkbAction
XkbGetButtonAction(DeviceIntPtr kbd,DeviceIntPtr dev,int button)
{
XkbAction fake;
   if ((dev->button)&&(dev->button->xkb_acts)) {
	if (dev->button->xkb_acts[button-1].any.type!=XkbSA_NoAction) {
	    fake= _FixUpAction(kbd->key->xkbInfo->desc,
					&dev->button->xkb_acts[button-1]);
	    return fake;
	}
   }
   fake.any.type= XkbSA_NoAction;
   return fake;
}

/***====================================================================***/

#define	SYNTHETIC_KEYCODE	1
#define	BTN_ACT_FLAG		0x100

static int
_XkbFilterSetState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *pAction)
{
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = ((pAction->mods.mask&XkbSA_ClearLocks)!=0);
	filter->priv = 0;
	filter->filter = _XkbFilterSetState;
	if (pAction->type==XkbSA_SetMods) {
	    filter->upAction = *pAction;
	    xkbi->setMods= pAction->mods.mask;
	}
	else {
	    xkbi->groupChange = XkbSAGroup(&pAction->group);
	    if (pAction->group.flags&XkbSA_GroupAbsolute)
		xkbi->groupChange-= xkbi->state.base_group;
	    filter->upAction= *pAction;
	    XkbSASetGroup(&filter->upAction.group,xkbi->groupChange);
	}
    }
    else if (filter->keycode==keycode) {
	if (filter->upAction.type==XkbSA_SetMods) {
	    xkbi->clearMods = filter->upAction.mods.mask;
	    if (filter->upAction.mods.flags&XkbSA_ClearLocks) {
		xkbi->state.locked_mods&= ~filter->upAction.mods.mask;
	    }
	}
	else {
	    if (filter->upAction.group.flags&XkbSA_ClearLocks) {
		xkbi->state.locked_group = 0;
	    }
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.group);
	}
	filter->active = 0;
    }
    else {
	filter->upAction.mods.flags&= ~XkbSA_ClearLocks;
	filter->filterOthers = 0;
    }
    return 1;
}

#define	LATCH_KEY_DOWN	1
#define	LATCH_PENDING	2
#define	NO_LATCH	3

static int
_XkbFilterLatchState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{

    if (filter->keycode==0) {			/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 1;
	filter->priv = LATCH_KEY_DOWN;
	filter->filter = _XkbFilterLatchState;
	if (pAction->type==XkbSA_LatchMods) {
	    filter->upAction = *pAction;
	    xkbi->setMods = pAction->mods.mask;
	}
	else {
	    xkbi->groupChange = XkbSAGroup(&pAction->group);
	    if (pAction->group.flags&XkbSA_GroupAbsolute)
		 xkbi->groupChange-= xkbi->state.base_group;
	    filter->upAction= *pAction;
	    XkbSASetGroup(&filter->upAction.group,xkbi->groupChange);
	}
    }
    else if ( pAction && (filter->priv==LATCH_PENDING) ) {
	if (((1<<pAction->type)&XkbSA_BreakLatch)!=0) {
	    filter->active = 0;
	    if (filter->upAction.type==XkbSA_LatchMods)
		 xkbi->state.latched_mods&= ~filter->upAction.mods.mask;
	    else xkbi->state.latched_group-=XkbSAGroup(&filter->upAction.group);
	}
	else if ((pAction->type==filter->upAction.type)&&
		 (pAction->mods.flags==filter->upAction.mods.flags)&&
		 (pAction->mods.mask==filter->upAction.mods.mask)) {
	    if (filter->upAction.mods.flags&XkbSA_LatchToLock) {
		XkbControlsPtr ctrls= xkbi->desc->ctrls;
		if (filter->upAction.type==XkbSA_LatchMods)
		     pAction->mods.type= XkbSA_LockMods;
		else pAction->group.type= XkbSA_LockGroup;
		if (XkbAX_NeedFeedback(ctrls,XkbAX_StickyKeysFBMask)&&
		    		(ctrls->enabled_ctrls&XkbStickyKeysMask)) {
		    XkbDDXAccessXBeep(xkbi->device,_BEEP_STICKY_LOCK,
						XkbStickyKeysMask);
		}
	    }
	    else {
		if (filter->upAction.type==XkbSA_LatchMods)
		     pAction->mods.type= XkbSA_SetMods;
		else pAction->group.type= XkbSA_SetGroup;
	    }
	    if (filter->upAction.type==XkbSA_LatchMods)
		 xkbi->state.latched_mods&= ~filter->upAction.mods.mask;
	    else xkbi->state.latched_group-=XkbSAGroup(&filter->upAction.group);
	    filter->active = 0;
	}
    }
    else if (filter->keycode==keycode) {	/* release */
	XkbControlsPtr	ctrls= xkbi->desc->ctrls;
	int		needBeep;
	int		beepType= _BEEP_NONE;

	needBeep= ((ctrls->enabled_ctrls&XkbStickyKeysMask)&&
			XkbAX_NeedFeedback(ctrls,XkbAX_StickyKeysFBMask));
	if (filter->upAction.type==XkbSA_LatchMods) {
	    xkbi->clearMods = filter->upAction.mods.mask;
	    if ((filter->upAction.mods.flags&XkbSA_ClearLocks)&&
		 (xkbi->clearMods&xkbi->state.locked_mods)==xkbi->clearMods) {
		xkbi->state.locked_mods&= ~xkbi->clearMods;
		filter->priv= NO_LATCH;
		beepType= _BEEP_STICKY_UNLOCK;
	    }
	}
	else {
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.group);
	    if ((filter->upAction.group.flags&XkbSA_ClearLocks)&&
						(xkbi->state.locked_group)) {
		xkbi->state.locked_group = 0;
		filter->priv = NO_LATCH;
		beepType= _BEEP_STICKY_UNLOCK;
	    }
	}
	if (filter->priv==NO_LATCH) {
	    filter->active= 0;
	}
	else {
	    filter->priv= LATCH_PENDING;
	    if (filter->upAction.type==XkbSA_LatchMods) {
		xkbi->state.latched_mods |= filter->upAction.mods.mask;
		needBeep = xkbi->state.latched_mods ? needBeep : 0;
		xkbi->state.latched_mods |= filter->upAction.mods.mask;
	    }
	    else {
		xkbi->state.latched_group+= XkbSAGroup(&filter->upAction.group);
	    }
	    if (needBeep && (beepType==_BEEP_NONE))
		beepType= _BEEP_STICKY_LATCH;
	}
	if (needBeep && (beepType!=_BEEP_NONE))
	    XkbDDXAccessXBeep(xkbi->device,beepType,XkbStickyKeysMask);
    }
    else if (filter->priv==LATCH_KEY_DOWN) {
	filter->priv= NO_LATCH;
	filter->filterOthers = 0;
    }
    return 1;
}

static int
_XkbFilterLockState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    if (pAction&&(pAction->type==XkbSA_LockGroup)) {
	if (pAction->group.flags&XkbSA_GroupAbsolute)
	     xkbi->state.locked_group= XkbSAGroup(&pAction->group);
	else xkbi->state.locked_group+= XkbSAGroup(&pAction->group);
	return 1;
    }
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv = 0;
	filter->filter = _XkbFilterLockState;
	filter->upAction = *pAction;
	xkbi->state.locked_mods^= pAction->mods.mask;
	xkbi->setMods = pAction->mods.mask;
    }
    else if (filter->keycode==keycode) {
	filter->active = 0;
	xkbi->clearMods = filter->upAction.mods.mask;
    }
    return 1;
}

#define	ISO_KEY_DOWN		0
#define	NO_ISO_LOCK		1

static int
_XkbFilterISOLock(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{

    if (filter->keycode==0) {		/* initial press */
	CARD8	flags= pAction->iso.flags;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 1;
	filter->priv = ISO_KEY_DOWN;
	filter->upAction = *pAction;
	filter->filter = _XkbFilterISOLock;
	if (flags&XkbSA_ISODfltIsGroup) {
	    xkbi->groupChange = XkbSAGroup(&pAction->iso);
	    xkbi->setMods = 0;
	}
	else {
	    xkbi->setMods = pAction->iso.mask;
	    xkbi->groupChange = 0;
	}
	if ((!(flags&XkbSA_ISONoAffectMods))&&(xkbi->state.base_mods)) {
	    filter->priv= NO_ISO_LOCK;
	    xkbi->state.locked_mods^= xkbi->state.base_mods;
	}
	if ((!(flags&XkbSA_ISONoAffectGroup))&&(xkbi->state.base_group)) {
/* 6/22/93 (ef) -- lock groups if group key is down first */
	}
	if (!(flags&XkbSA_ISONoAffectPtr)) {
/* 6/22/93 (ef) -- lock mouse buttons if they're down */
	}
    }
    else if (filter->keycode==keycode) {
	CARD8	flags= filter->upAction.iso.flags;

	if (flags&XkbSA_ISODfltIsGroup) {
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.iso);
	    xkbi->clearMods = 0;
	    if (filter->priv==ISO_KEY_DOWN)
		xkbi->state.locked_group+= XkbSAGroup(&filter->upAction.iso);
	}
	else {
	    xkbi->clearMods= filter->upAction.iso.mask;
	    xkbi->groupChange= 0;
	    if (filter->priv==ISO_KEY_DOWN)
		xkbi->state.locked_mods^= filter->upAction.iso.mask;
	}
	filter->active = 0;
    }
    else if (pAction) {
	CARD8	flags= filter->upAction.iso.flags;

	switch (pAction->type) {
	    case XkbSA_SetMods: case XkbSA_LatchMods:
		if (!(flags&XkbSA_ISONoAffectMods)) {
		    pAction->type= XkbSA_LockMods;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_SetGroup: case XkbSA_LatchGroup:
		if (!(flags&XkbSA_ISONoAffectGroup)) {
		    pAction->type= XkbSA_LockGroup;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_PtrBtn:
		if (!(flags&XkbSA_ISONoAffectPtr)) {
		     pAction->type= XkbSA_LockPtrBtn;
		     filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_SetControls:
		if (!(flags&XkbSA_ISONoAffectCtrls)) {
		    pAction->type= XkbSA_LockControls;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	}
    }
    return 1;
}


static CARD32
_XkbPtrAccelExpire(OsTimerPtr timer,CARD32 now,pointer arg)
{
XkbSrvInfoPtr	xkbi= (XkbSrvInfoPtr)arg;
XkbControlsPtr	ctrls= xkbi->desc->ctrls;
int		dx,dy;

    if (xkbi->mouseKey==0)
	return 0;

    if (xkbi->mouseKeysAccel) {
	if ((xkbi->mouseKeysCounter)<ctrls->mk_time_to_max) {
	    double step;
	    xkbi->mouseKeysCounter++;
	    step= xkbi->mouseKeysCurveFactor*
		 pow((double)xkbi->mouseKeysCounter,xkbi->mouseKeysCurve);
	    if (xkbi->mouseKeysDX<0)
		 dx= floor( ((double)xkbi->mouseKeysDX)*step );
	    else dx=  ceil( ((double)xkbi->mouseKeysDX)*step );
	    if (xkbi->mouseKeysDY<0)
		 dy= floor( ((double)xkbi->mouseKeysDY)*step );
	    else dy=  ceil( ((double)xkbi->mouseKeysDY)*step );
	}
	else {
	    dx= xkbi->mouseKeysDX*ctrls->mk_max_speed;
	    dy= xkbi->mouseKeysDY*ctrls->mk_max_speed;
	}
	if (xkbi->mouseKeysFlags&XkbSA_MoveAbsoluteX)
	    dx= xkbi->mouseKeysDX;
	if (xkbi->mouseKeysFlags&XkbSA_MoveAbsoluteY)
	    dy= xkbi->mouseKeysDY;
    }
    else {
	dx= xkbi->mouseKeysDX;
	dy= xkbi->mouseKeysDY;
    }
    XkbFakePointerMotion(xkbi->device, xkbi->mouseKeysFlags,dx,dy);
    return xkbi->desc->ctrls->mk_interval;
}

static int
_XkbFilterPointerMove(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
int	x,y;
Bool	accel;

    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterPointerMove;
	filter->upAction= *pAction;
	xkbi->mouseKeysCounter= 0;
	xkbi->mouseKey= keycode;
	accel= ((pAction->ptr.flags&XkbSA_NoAcceleration)==0);
	x= XkbPtrActionX(&pAction->ptr);
	y= XkbPtrActionY(&pAction->ptr);
	XkbFakePointerMotion(xkbi->device, pAction->ptr.flags,x,y);
	AccessXCancelRepeatKey(xkbi,keycode);
	xkbi->mouseKeysAccel= accel&&
		(xkbi->desc->ctrls->enabled_ctrls&XkbMouseKeysAccelMask);
	xkbi->mouseKeysFlags= pAction->ptr.flags;
	xkbi->mouseKeysDX= XkbPtrActionX(&pAction->ptr);
	xkbi->mouseKeysDY= XkbPtrActionY(&pAction->ptr);
	xkbi->mouseKeyTimer= TimerSet(xkbi->mouseKeyTimer, 0,
				xkbi->desc->ctrls->mk_delay,
				_XkbPtrAccelExpire,(pointer)xkbi);
    }
    else if (filter->keycode==keycode) {
	filter->active = 0;
	if (xkbi->mouseKey==keycode) {
	    xkbi->mouseKey= 0;
	    xkbi->mouseKeyTimer= TimerSet(xkbi->mouseKeyTimer, 0, 0,
							NULL, NULL);
	}
    }
    return 0;
}

static int
_XkbFilterPointerBtn(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    if (filter->keycode==0) {		/* initial press */
	int	button= pAction->btn.button;

	if (button==XkbSA_UseDfltButton)
	    button = xkbi->desc->ctrls->mk_dflt_btn;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterPointerBtn;
	filter->upAction= *pAction;
	filter->upAction.btn.button= button;
	switch (pAction->type) {
	    case XkbSA_LockPtrBtn:
		if (((xkbi->lockedPtrButtons&(1<<button))==0)&&
			((pAction->btn.flags&XkbSA_LockNoLock)==0)) {
		    xkbi->lockedPtrButtons|= (1<<button);
		    AccessXCancelRepeatKey(xkbi,keycode);
		    XkbFakeDeviceButton(xkbi->device, 1, button);
		    filter->upAction.type= XkbSA_NoAction;
		}
		break;
	    case XkbSA_PtrBtn:
		{
		    register int i,nClicks;
		    AccessXCancelRepeatKey(xkbi,keycode);
		    if (pAction->btn.count>0) {
			nClicks= pAction->btn.count;
			for (i=0;i<nClicks;i++) {
			    XkbFakeDeviceButton(xkbi->device, 1, button);
			    XkbFakeDeviceButton(xkbi->device, 0, button);
			}
			filter->upAction.type= XkbSA_NoAction;
		    }
		    else XkbFakeDeviceButton(xkbi->device, 1, button);
		}
		break;
	    case XkbSA_SetPtrDflt:
		{
		    XkbControlsPtr	ctrls= xkbi->desc->ctrls;
		    XkbControlsRec	old;
		    xkbControlsNotify	cn;

		    old= *ctrls;
		    AccessXCancelRepeatKey(xkbi,keycode);
		    switch (pAction->dflt.affect) {
			case XkbSA_AffectDfltBtn:
			    if (pAction->dflt.flags&XkbSA_DfltBtnAbsolute)
				ctrls->mk_dflt_btn= 
					XkbSAPtrDfltValue(&pAction->dflt);
			    else {
				ctrls->mk_dflt_btn+=
					XkbSAPtrDfltValue(&pAction->dflt);
				if (ctrls->mk_dflt_btn>5)
				    ctrls->mk_dflt_btn= 5;
				else if (ctrls->mk_dflt_btn<1)
				    ctrls->mk_dflt_btn= 1;
			    }
			    break;
			default:
			    ErrorF(
		"Attempt to change unknown pointer default (%d) ignored\n",
							pAction->dflt.affect);
			    break;
		    }
		    if (XkbComputeControlsNotify(xkbi->device,
						&old,xkbi->desc->ctrls,
						&cn,FALSE)) {
			cn.keycode = keycode;
                        /* XXX: what about DeviceKeyPress? */
			cn.eventType = KeyPress;
			cn.requestMajor = 0;
			cn.requestMinor = 0;
			XkbSendControlsNotify(xkbi->device,&cn);
		    }
		}
		break;
	}
    }
    else if (filter->keycode==keycode) {
	int	button= filter->upAction.btn.button;

	switch (filter->upAction.type) {
	    case XkbSA_LockPtrBtn:
		if (((filter->upAction.btn.flags&XkbSA_LockNoUnlock)!=0)||
				((xkbi->lockedPtrButtons&(1<<button))==0)) {
		    break;
		}
		xkbi->lockedPtrButtons&= ~(1<<button);

		if (IsMaster(xkbi->device))
		{
		    XkbMergeLockedPtrBtns(xkbi->device);
                    /* One SD still has lock set, don't post event */
		    if ((xkbi->lockedPtrButtons & (1 << button)) != 0)
			break;
		}

		/* fallthrough */
	    case XkbSA_PtrBtn:
		XkbFakeDeviceButton(xkbi->device, 0, button);
		break;
	}
	filter->active = 0;
    }
    return 0;
}

static int
_XkbFilterControls(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
XkbControlsRec		old;
XkbControlsPtr		ctrls;
DeviceIntPtr		kbd;
unsigned int		change;
XkbEventCauseRec	cause;

    kbd= xkbi->device;
    ctrls= xkbi->desc->ctrls;
    old= *ctrls;
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	change= XkbActionCtrls(&pAction->ctrls);
	filter->priv = change;
	filter->filter = _XkbFilterControls;
	filter->upAction = *pAction;

	if (pAction->type==XkbSA_LockControls) {
	    filter->priv= (ctrls->enabled_ctrls&change);
	    change&= ~ctrls->enabled_ctrls;
	}

	if (change) {
	    xkbControlsNotify	cn;
	    XkbSrvLedInfoPtr	sli;

	    ctrls->enabled_ctrls|= change;
	    if (XkbComputeControlsNotify(kbd,&old,ctrls,&cn,FALSE)) {
		cn.keycode = keycode;
                /* XXX: what about DeviceKeyPress? */
		cn.eventType = KeyPress;
		cn.requestMajor = 0;
		cn.requestMinor = 0;
		XkbSendControlsNotify(kbd,&cn);
	    }

	    XkbSetCauseKey(&cause,keycode,KeyPress);

	    /* If sticky keys were disabled, clear all locks and latches */
	    if ((old.enabled_ctrls&XkbStickyKeysMask)&&
		(!(ctrls->enabled_ctrls&XkbStickyKeysMask))) {
		XkbClearAllLatchesAndLocks(kbd,xkbi,FALSE,&cause);
    	    }
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	    XkbUpdateIndicators(kbd,sli->usesControls,TRUE,NULL,&cause);
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
		XkbDDXAccessXBeep(kbd,_BEEP_FEATURE_ON,change);
	}
    }
    else if (filter->keycode==keycode) {
	change= filter->priv;
	if (change) {
	    xkbControlsNotify 	cn;
	    XkbSrvLedInfoPtr	sli;

	    ctrls->enabled_ctrls&= ~change;
	    if (XkbComputeControlsNotify(kbd,&old,ctrls,&cn,FALSE)) {
		cn.keycode = keycode;
		cn.eventType = KeyRelease;
		cn.requestMajor = 0;
		cn.requestMinor = 0;
		XkbSendControlsNotify(kbd,&cn);
	    }

	    XkbSetCauseKey(&cause,keycode,KeyRelease);
	    /* If sticky keys were disabled, clear all locks and latches */
	    if ((old.enabled_ctrls&XkbStickyKeysMask)&&
		(!(ctrls->enabled_ctrls&XkbStickyKeysMask))) {
		XkbClearAllLatchesAndLocks(kbd,xkbi,FALSE,&cause);
    	    }
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	    XkbUpdateIndicators(kbd,sli->usesControls,TRUE,NULL,&cause);
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
		XkbDDXAccessXBeep(kbd,_BEEP_FEATURE_OFF,change);
	}
	filter->keycode= 0;
	filter->active= 0;
    }
    return 1;
}

static int
_XkbFilterActionMessage(XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
XkbMessageAction *	pMsg;
DeviceIntPtr		kbd;

    kbd= xkbi->device;
    if (filter->keycode==0) {		/* initial press */
	pMsg= &pAction->msg;
	if ((pMsg->flags&XkbSA_MessageOnRelease)||
	    ((pMsg->flags&XkbSA_MessageGenKeyEvent)==0)) {
	    filter->keycode = keycode;
	    filter->active = 1;
	    filter->filterOthers = 0;
	    filter->priv = 0;
	    filter->filter = _XkbFilterActionMessage;
	    filter->upAction = *pAction;
	}
	if (pMsg->flags&XkbSA_MessageOnPress)  {
	    xkbActionMessage	msg;

	    msg.keycode= keycode;
	    msg.press= 1;
	    msg.keyEventFollows=((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
	    memcpy((char *)msg.message,
				(char *)pMsg->message,XkbActionMessageLength);
	    XkbSendActionMessage(kbd,&msg);
	}
	return ((pAction->msg.flags&XkbSA_MessageGenKeyEvent)!=0);
    }
    else if (filter->keycode==keycode) {
	pMsg= &filter->upAction.msg;
	if (pMsg->flags&XkbSA_MessageOnRelease) {
	    xkbActionMessage	msg;

	    msg.keycode= keycode;
	    msg.press= 0;
	    msg.keyEventFollows=((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
	    memcpy((char *)msg.message,(char *)pMsg->message,
						XkbActionMessageLength);
	    XkbSendActionMessage(kbd,&msg);
	}
	filter->keycode= 0;
	filter->active= 0;
	return ((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
    }
    return 0;
}

static int
_XkbFilterRedirectKey(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
DeviceEvent	ev;
int		x,y;
XkbStateRec	old;
unsigned	mods,mask;
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(xkbi->device);
ProcessInputProc backupproc;

    /* never actually used uninitialised, but gcc isn't smart enough
     * to work that out. */
    memset(&old, 0, sizeof(old));
    memset(&ev, 0, sizeof(ev));

    if ((filter->keycode!=0)&&(filter->keycode!=keycode))
	return 1;

    GetSpritePosition(xkbi->device, &x,&y);
    ev.header = ET_Internal;
    ev.length = sizeof(DeviceEvent);
    ev.time = GetTimeInMillis();
    ev.root_x = x;
    ev.root_y = y;

    if (filter->keycode==0) {		/* initial press */
	if ((pAction->redirect.new_key<xkbi->desc->min_key_code)||
	    (pAction->redirect.new_key>xkbi->desc->max_key_code)) {
	    return 1;
	}
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv = 0;
	filter->filter = _XkbFilterRedirectKey;
	filter->upAction = *pAction;

        ev.type = ET_KeyPress;
        ev.detail.key = pAction->redirect.new_key;

        mask= XkbSARedirectVModsMask(&pAction->redirect);
        mods= XkbSARedirectVMods(&pAction->redirect);
        if (mask) XkbVirtualModsToReal(xkbi->desc,mask,&mask);
        if (mods) XkbVirtualModsToReal(xkbi->desc,mods,&mods);
        mask|= pAction->redirect.mods_mask;
        mods|= pAction->redirect.mods;

	if ( mask || mods ) {
	    old= xkbi->state;
	    xkbi->state.base_mods&= ~mask;
	    xkbi->state.base_mods|= (mods&mask);
	    xkbi->state.latched_mods&= ~mask;
	    xkbi->state.latched_mods|= (mods&mask);
	    xkbi->state.locked_mods&= ~mask;
	    xkbi->state.locked_mods|= (mods&mask);
	    XkbComputeDerivedState(xkbi);
	}

	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr, backupproc);
	xkbi->device->public.processInputProc((InternalEvent*)&ev, xkbi->device);
	COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr,
				     backupproc,xkbUnwrapProc);
	
	if ( mask || mods )
	    xkbi->state= old;
    }
    else if (filter->keycode==keycode) {

        ev.type = ET_KeyRelease;
        ev.detail.key = filter->upAction.redirect.new_key;

        mask= XkbSARedirectVModsMask(&filter->upAction.redirect);
        mods= XkbSARedirectVMods(&filter->upAction.redirect);
        if (mask) XkbVirtualModsToReal(xkbi->desc,mask,&mask);
        if (mods) XkbVirtualModsToReal(xkbi->desc,mods,&mods);
        mask|= filter->upAction.redirect.mods_mask;
        mods|= filter->upAction.redirect.mods;

	if ( mask || mods ) {
	    old= xkbi->state;
	    xkbi->state.base_mods&= ~mask;
	    xkbi->state.base_mods|= (mods&mask);
	    xkbi->state.latched_mods&= ~mask;
	    xkbi->state.latched_mods|= (mods&mask);
	    xkbi->state.locked_mods&= ~mask;
	    xkbi->state.locked_mods|= (mods&mask);
	    XkbComputeDerivedState(xkbi);
	}

	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr, backupproc);
	xkbi->device->public.processInputProc((InternalEvent*)&ev, xkbi->device);
	COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr,
				     backupproc,xkbUnwrapProc);

	if ( mask || mods )
	    xkbi->state= old;

	filter->keycode= 0;
	filter->active= 0;
    }
    return 0;
}

static int
_XkbFilterSwitchScreen(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    DeviceIntPtr dev = xkbi->device;
    if (dev == inputInfo.keyboard)
        return 0;

    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->filter = _XkbFilterSwitchScreen;
	AccessXCancelRepeatKey(xkbi, keycode);
	XkbDDXSwitchScreen(dev,keycode,pAction);
        return 0; 
    }
    else if (filter->keycode==keycode) {
	filter->active= 0;
        return 0; 
    }
    return 1;
}

static int
_XkbFilterXF86Private(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    DeviceIntPtr dev = xkbi->device;
    if (dev == inputInfo.keyboard)
        return 0;

    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->filter = _XkbFilterXF86Private;
	XkbDDXPrivate(dev,keycode,pAction);
        return 0; 
    }
    else if (filter->keycode==keycode) {
	filter->active= 0;
        return 0; 
    }
    return 1;
}


static int
_XkbFilterDeviceBtn(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
DeviceIntPtr	dev;
int		button;

    if (xkbi->device == inputInfo.keyboard)
        return 0;

    if (filter->keycode==0) {		/* initial press */
	_XkbLookupButtonDevice(&dev, pAction->devbtn.device, serverClient,
			       DixUnknownAccess, &button);
	if (!dev || !dev->public.on)
	    return 1;

	button= pAction->devbtn.button;
	if ((button<1)||(button>dev->button->numButtons))
	    return 1;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterDeviceBtn;
	filter->upAction= *pAction;
	switch (pAction->type) {
	    case XkbSA_LockDeviceBtn:
		if ((pAction->devbtn.flags&XkbSA_LockNoLock)||
		    BitIsOn(dev->button->down, button))
		    return 0;
		XkbFakeDeviceButton(dev,TRUE,button);
		filter->upAction.type= XkbSA_NoAction;
		break;
	    case XkbSA_DeviceBtn:
		if (pAction->devbtn.count>0) {
		    int nClicks,i;
		    nClicks= pAction->btn.count;
		    for (i=0;i<nClicks;i++) {
			XkbFakeDeviceButton(dev,TRUE,button);
			XkbFakeDeviceButton(dev,FALSE,button);
		    }
		    filter->upAction.type= XkbSA_NoAction;
		}
		else XkbFakeDeviceButton(dev,TRUE,button);
		break;
	}
    }
    else if (filter->keycode==keycode) {
	int	button;

	filter->active= 0;
	_XkbLookupButtonDevice(&dev, filter->upAction.devbtn.device,
			       serverClient, DixUnknownAccess, &button);
	if (!dev || !dev->public.on)
	    return 1;

	button= filter->upAction.btn.button;
	switch (filter->upAction.type) {
	    case XkbSA_LockDeviceBtn:
		if ((filter->upAction.devbtn.flags&XkbSA_LockNoUnlock)||
		    !BitIsOn(dev->button->down, button))
		    return 0;
		XkbFakeDeviceButton(dev,FALSE,button);
		break;
	    case XkbSA_DeviceBtn:
		XkbFakeDeviceButton(dev,FALSE,button);
		break;
	}
	filter->active = 0;
    }
    return 0;
}

static XkbFilterPtr
_XkbNextFreeFilter(
	XkbSrvInfoPtr xkbi
)
{
register int	i;

    if (xkbi->szFilters==0) {
	xkbi->szFilters = 4;
	xkbi->filters = calloc(xkbi->szFilters, sizeof(XkbFilterRec));
	/* 6/21/93 (ef) -- XXX! deal with allocation failure */
    }
    for (i=0;i<xkbi->szFilters;i++) {
	if (!xkbi->filters[i].active) {
	    xkbi->filters[i].keycode = 0;
	    return &xkbi->filters[i];
	}
    }
    xkbi->szFilters*=2;
    xkbi->filters= realloc(xkbi->filters,
                            xkbi->szFilters * sizeof(XkbFilterRec));
    /* 6/21/93 (ef) -- XXX! deal with allocation failure */
    memset(&xkbi->filters[xkbi->szFilters/2], 0,
            (xkbi->szFilters/2)*sizeof(XkbFilterRec));
    return &xkbi->filters[xkbi->szFilters/2];
}

static int
_XkbApplyFilters(XkbSrvInfoPtr xkbi,unsigned kc,XkbAction *pAction)
{
register int	i,send;

    send= 1;
    for (i=0;i<xkbi->szFilters;i++) {
	if ((xkbi->filters[i].active)&&(xkbi->filters[i].filter))
	    send= ((*xkbi->filters[i].filter)(xkbi,&xkbi->filters[i],kc,pAction) 
                    && send);
    }
    return send;
}

void
XkbHandleActions(DeviceIntPtr dev, DeviceIntPtr kbd, DeviceEvent* event)
{
int		key,bit,i;
XkbSrvInfoPtr	xkbi;
KeyClassPtr	keyc;
int		changed,sendEvent;
Bool		genStateNotify;
XkbAction	act;
XkbFilterPtr	filter;
Bool		keyEvent;
Bool		pressEvent;
ProcessInputProc backupproc;
    
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(dev);

    keyc= kbd->key;
    xkbi= keyc->xkbInfo;
    key= event->detail.key;
    /* The state may change, so if we're not in the middle of sending a state
     * notify, prepare for it */
    if ((xkbi->flags&_XkbStateNotifyInProgress)==0) {
	xkbi->prev_state = xkbi->state;
	xkbi->flags|= _XkbStateNotifyInProgress;
	genStateNotify= TRUE;
    }
    else genStateNotify= FALSE;

    xkbi->clearMods = xkbi->setMods = 0;
    xkbi->groupChange = 0;

    sendEvent = 1;
    keyEvent= ((event->type == ET_KeyPress) || (event->type == ET_KeyRelease));
    pressEvent= ((event->type == ET_KeyPress)|| (event->type == ET_ButtonPress));

    if (pressEvent) {
	if (keyEvent)	
	    act = XkbGetKeyAction(xkbi,&xkbi->state,key);
	else {
	    act = XkbGetButtonAction(kbd,dev,key);
	    key|= BTN_ACT_FLAG;
	}
	sendEvent = _XkbApplyFilters(xkbi,key,&act);
	if (sendEvent) {
	    switch (act.type) {
		case XkbSA_SetMods:
		case XkbSA_SetGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent = _XkbFilterSetState(xkbi,filter,key,&act);
		    break;
		case XkbSA_LatchMods:
		case XkbSA_LatchGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterLatchState(xkbi,filter,key,&act);
		    break;
		case XkbSA_LockMods:
		case XkbSA_LockGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterLockState(xkbi,filter,key,&act);
		    break;
		case XkbSA_ISOLock:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterISOLock(xkbi,filter,key,&act);
		    break;
		case XkbSA_MovePtr:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterPointerMove(xkbi,filter,key,&act);
		    break;
		case XkbSA_PtrBtn:
		case XkbSA_LockPtrBtn:
		case XkbSA_SetPtrDflt:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterPointerBtn(xkbi,filter,key,&act);
		    break;
		case XkbSA_Terminate:
		    sendEvent= XkbDDXTerminateServer(dev,key,&act);
		    break;
		case XkbSA_SwitchScreen:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterSwitchScreen(xkbi,filter,key,&act);
		    break;
		case XkbSA_SetControls:
		case XkbSA_LockControls:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterControls(xkbi,filter,key,&act);
		    break;
		case XkbSA_ActionMessage:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterActionMessage(xkbi,filter,key,&act);
		    break;
		case XkbSA_RedirectKey:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterRedirectKey(xkbi,filter,key,&act);
		    break;
		case XkbSA_DeviceBtn:
		case XkbSA_LockDeviceBtn:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterDeviceBtn(xkbi,filter,key,&act);
		    break;
		case XkbSA_XFree86Private:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterXF86Private(xkbi,filter,key,&act);
		    break;
	    }
	}
    }
    else {
	if (!keyEvent)
	    key|= BTN_ACT_FLAG;
	sendEvent = _XkbApplyFilters(xkbi,key,NULL);
    }

    if (xkbi->groupChange!=0)
	xkbi->state.base_group+= xkbi->groupChange;
    if (xkbi->setMods) {
	for (i=0,bit=1; xkbi->setMods; i++,bit<<=1 ) {
	    if (xkbi->setMods&bit) {
		keyc->modifierKeyCount[i]++;
		xkbi->state.base_mods|= bit;
		xkbi->setMods&= ~bit;
	    }
	}
    }
    if (xkbi->clearMods) {
	for (i=0,bit=1; xkbi->clearMods; i++,bit<<=1 ) {
	    if (xkbi->clearMods&bit) {
		keyc->modifierKeyCount[i]--;
		if (keyc->modifierKeyCount[i]<=0) {
		    xkbi->state.base_mods&= ~bit;
		    keyc->modifierKeyCount[i] = 0;
		}
		xkbi->clearMods&= ~bit;
	    }
	}
    }

    if (sendEvent) {
        DeviceIntPtr tmpdev;
	if (keyEvent)
            tmpdev = dev;
        else
            tmpdev = GetPairedDevice(dev);

        UNWRAP_PROCESS_INPUT_PROC(tmpdev,xkbPrivPtr, backupproc);
        dev->public.processInputProc((InternalEvent*)event, tmpdev);
        COND_WRAP_PROCESS_INPUT_PROC(tmpdev, xkbPrivPtr,
                                     backupproc,xkbUnwrapProc);
    }
    else if (keyEvent) {
	FixKeyState(event, dev);
    }

    XkbComputeDerivedState(xkbi);
    changed = XkbStateChangedFlags(&xkbi->prev_state,&xkbi->state);
    if (genStateNotify) {
	if (changed) {
	    xkbStateNotify	sn;
	    sn.keycode= key;
	    sn.eventType= event->type;
	    sn.requestMajor = sn.requestMinor = 0;
	    sn.changed= changed;
	    XkbSendStateNotify(dev,&sn);
	}
	xkbi->flags&= ~_XkbStateNotifyInProgress;
    }
    changed= XkbIndicatorsToUpdate(dev,changed,FALSE);
    if (changed) {
	XkbEventCauseRec	cause;
	XkbSetCauseKey(&cause, key, event->type);
	XkbUpdateIndicators(dev,changed,FALSE,NULL,&cause);
    }
    return;
}

int
XkbLatchModifiers(DeviceIntPtr pXDev,CARD8 mask,CARD8 latches)
{
XkbSrvInfoPtr	xkbi;
XkbFilterPtr	filter;
XkbAction	act;
unsigned	clear;

    if ( pXDev && pXDev->key && pXDev->key->xkbInfo ) {
	xkbi = pXDev->key->xkbInfo;
	clear= (mask&(~latches));
	xkbi->state.latched_mods&= ~clear;
	/* Clear any pending latch to locks.
	 */
	act.type = XkbSA_NoAction;
	_XkbApplyFilters(xkbi,SYNTHETIC_KEYCODE,&act);
	act.type = XkbSA_LatchMods;
	act.mods.flags = 0;
	act.mods.mask  = mask&latches;
	filter = _XkbNextFreeFilter(xkbi);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,&act);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,(XkbAction *)NULL);
	return Success;
    }
    return BadValue;
}

int
XkbLatchGroup(DeviceIntPtr pXDev,int group)
{
XkbSrvInfoPtr	xkbi;
XkbFilterPtr	filter;
XkbAction	act;

    if ( pXDev && pXDev->key && pXDev->key->xkbInfo ) {
	xkbi = pXDev->key->xkbInfo;
	act.type = XkbSA_LatchGroup;
	act.group.flags = 0;
	XkbSASetGroup(&act.group,group);
	filter = _XkbNextFreeFilter(xkbi);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,&act);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,(XkbAction *)NULL);
	return Success;
    }
    return BadValue;
}

/***====================================================================***/

void
XkbClearAllLatchesAndLocks(	DeviceIntPtr		dev,
				XkbSrvInfoPtr		xkbi,
				Bool			genEv,
				XkbEventCausePtr	cause)
{
XkbStateRec	os;
xkbStateNotify	sn;

    sn.changed= 0;
    os= xkbi->state;
    if (os.latched_mods) { /* clear all latches */
	XkbLatchModifiers(dev,~0,0);
	sn.changed|= XkbModifierLatchMask;
    }
    if (os.latched_group) {
	XkbLatchGroup(dev,0);
	sn.changed|= XkbGroupLatchMask;
    }
    if (os.locked_mods) {
	xkbi->state.locked_mods= 0;
	sn.changed|= XkbModifierLockMask;
    }
    if (os.locked_group) {
	xkbi->state.locked_group= 0;
	sn.changed|= XkbGroupLockMask;
    }
    if ( genEv && sn.changed) {
	CARD32 	changed;

	XkbComputeDerivedState(xkbi);
	sn.keycode= 		cause->kc;
	sn.eventType=		cause->event;
	sn.requestMajor= 	cause->mjr;
	sn.requestMinor= 	cause->mnr;
	sn.changed= XkbStateChangedFlags(&os,&xkbi->state);
	XkbSendStateNotify(dev,&sn);
	changed= XkbIndicatorsToUpdate(dev,sn.changed,FALSE);
	if (changed) {
	    XkbUpdateIndicators(dev,changed,TRUE,NULL,cause);
	}
    }
    return;
}

/*
 * The event is injected into the event processing, not the EQ. Thus,
 * ensure that we restore the master after the event sequence to the
 * original set of classes. Otherwise, the master remains on the XTEST
 * classes and drops events that don't fit into the XTEST layout (e.g.
 * events with more than 2 valuators).
 *
 * FIXME: EQ injection in the processing stage is not designed for, so this
 * is a rather awkward hack. The event list returned by GetPointerEvents()
 * and friends is always prefixed with a DCE if the last _posted_ device was
 * different. For normal events, this sequence then resets the master during
 * the processing stage. Since we inject the PointerKey events in the
 * processing stage though, we need to manually reset to restore the
 * previous order, because the events already in the EQ must be sent for the
 * right device.
 * So we post-fix the event list we get from GPE with a DCE back to the
 * previous slave device.
 *
 * First one on drinking island wins!
 */
static void
InjectPointerKeyEvents(DeviceIntPtr dev, int type, int button, int flags, ValuatorMask *mask)
{
    ScreenPtr           pScreen;
    InternalEvent*      events;
    int                 nevents, i;
    DeviceIntPtr        ptr, mpointer, lastSlave = NULL;
    Bool                saveWait;

    if (IsMaster(dev)) {
        mpointer = GetMaster(dev, MASTER_POINTER);
        lastSlave = mpointer->lastSlave;
        ptr = GetXTestDevice(mpointer);
    } else if (IsFloating(dev))
        ptr = dev;
    else
        return;


    events = InitEventList(GetMaximumEventsNum() + 1);
    OsBlockSignals();
    pScreen = miPointerGetScreen(ptr);
    saveWait = miPointerSetWaitForUpdate(pScreen, FALSE);
    nevents = GetPointerEvents(events, ptr, type, button, flags, mask);
    if (IsMaster(dev) && (lastSlave && lastSlave != ptr))
        UpdateFromMaster(&events[nevents], lastSlave, DEVCHANGE_POINTER_EVENT, &nevents);
    miPointerSetWaitForUpdate(pScreen, saveWait);
    OsReleaseSignals();

    for (i = 0; i < nevents; i++)
        mieqProcessDeviceEvent(ptr, &events[i], NULL);

    FreeEventList(events, GetMaximumEventsNum());

}

static void
XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags,int x,int y)
{
    ValuatorMask        mask;
    int                 gpe_flags = 0;

    /* ignore attached SDs */
    if (!IsMaster(dev) && !IsFloating(dev))
        return;

    if (flags & XkbSA_MoveAbsoluteX || flags & XkbSA_MoveAbsoluteY)
        gpe_flags = POINTER_ABSOLUTE;
    else
        gpe_flags = POINTER_RELATIVE;

    valuator_mask_set_range(&mask, 0, 2, (int[]){x, y});

    InjectPointerKeyEvents(dev, MotionNotify, 0, gpe_flags, &mask);
}

void
XkbFakeDeviceButton(DeviceIntPtr dev,Bool press,int button)
{
    DeviceIntPtr        ptr;
    int                 down;

    /* If dev is a slave device, and the SD is attached, do nothing. If we'd
     * post through the attached master pointer we'd get duplicate events.
     *
     * if dev is a master keyboard, post through the XTEST device
     *
     * if dev is a floating slave, post through the device itself.
     */

    if (IsMaster(dev)) {
        DeviceIntPtr mpointer = GetMaster(dev, MASTER_POINTER);
        ptr = GetXTestDevice(mpointer);
    } else if (IsFloating(dev))
        ptr = dev;
    else
        return;

    down = button_is_down(ptr, button, BUTTON_PROCESSED);
    if (press == down)
        return;

    InjectPointerKeyEvents(dev, press ? ButtonPress : ButtonRelease,
                           button, 0, NULL);
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <xkbsrv.h>
#include "xkbgeom.h"
#include <os.h>
#include <string.h>

/***===================================================================***/

/*ARGSUSED*/
Status
XkbAllocCompatMap(XkbDescPtr xkb,unsigned which,unsigned nSI)
{
XkbCompatMapPtr	compat;
XkbSymInterpretRec *prev_interpret;

    if (!xkb)
	return BadMatch;
    if (xkb->compat) {
	if (xkb->compat->size_si>=nSI)
	    return Success;
	compat= xkb->compat;
	compat->size_si= nSI;
	if (compat->sym_interpret==NULL)
	    compat->num_si= 0;
	prev_interpret = compat->sym_interpret;
	compat->sym_interpret= realloc(compat->sym_interpret,
					nSI * sizeof(XkbSymInterpretRec));
	if (compat->sym_interpret==NULL) {
	    free(prev_interpret);
	    compat->size_si= compat->num_si= 0;
	    return BadAlloc;
	}
	if (compat->num_si!=0) {
	    memset(&compat->sym_interpret[compat->num_si], 0,
		   (compat->size_si - compat->num_si) * sizeof(XkbSymInterpretRec));
	}
	return Success;
    }
   compat= calloc(1, sizeof(XkbCompatMapRec));
    if (compat==NULL)
	return BadAlloc;
    if (nSI>0) {
	compat->sym_interpret= calloc(nSI, sizeof(XkbSymInterpretRec));
	if (!compat->sym_interpret) {
	    free(compat);
	    return BadAlloc;
	}
    }
    compat->size_si= nSI;
    compat->num_si= 0;
    memset((char *)&compat->groups[0], 0, XkbNumKbdGroups*sizeof(XkbModsRec));
    xkb->compat= compat;
    return Success;
}


void
XkbFreeCompatMap(XkbDescPtr xkb,unsigned which,Bool freeMap)
{
register XkbCompatMapPtr compat;

    if ((xkb==NULL)||(xkb->compat==NULL))
	return;
    compat= xkb->compat;
    if (freeMap)
	which= XkbAllCompatMask;
    if (which&XkbGroupCompatMask)
	memset((char *)&compat->groups[0], 0, XkbNumKbdGroups*sizeof(XkbModsRec));
    if (which&XkbSymInterpMask) {
	if ((compat->sym_interpret)&&(compat->size_si>0))
	    free(compat->sym_interpret);
	compat->size_si= compat->num_si= 0;
	compat->sym_interpret= NULL;
    }
    if (freeMap) {
	free(compat);
	xkb->compat= NULL;
    }
    return;
}

/***===================================================================***/

Status
XkbAllocNames(XkbDescPtr xkb,unsigned which,int nTotalRG,int nTotalAliases)
{
XkbNamesPtr	names;

    if (xkb==NULL)
	return BadMatch;
    if (xkb->names==NULL) {
	xkb->names = calloc(1, sizeof(XkbNamesRec));
	if (xkb->names==NULL)
	    return BadAlloc;
    }
    names= xkb->names;
    if ((which&XkbKTLevelNamesMask)&&(xkb->map!=NULL)&&(xkb->map->types!=NULL)){
	register int	i;
	XkbKeyTypePtr	type;

	type= xkb->map->types;
	for (i=0;i<xkb->map->num_types;i++,type++) {
	    if (type->level_names==NULL) {
		type->level_names= calloc(type->num_levels, sizeof(Atom));
		if (type->level_names==NULL)
		    return BadAlloc;
	    }
	}
    }
    if ((which&XkbKeyNamesMask)&&(names->keys==NULL)) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code)) 
	    return BadValue;
	names->keys= calloc((xkb->max_key_code+1), sizeof(XkbKeyNameRec));
	if (names->keys==NULL)
	    return BadAlloc;
    }
    if ((which&XkbKeyAliasesMask)&&(nTotalAliases>0)) {
	if (names->key_aliases==NULL) {
	    names->key_aliases= calloc(nTotalAliases, sizeof(XkbKeyAliasRec));
	}
	else if (nTotalAliases>names->num_key_aliases) {
	    XkbKeyAliasRec *prev_aliases = names->key_aliases;

	    names->key_aliases= realloc(names->key_aliases,
					 nTotalAliases * sizeof(XkbKeyAliasRec));
	    if (names->key_aliases!=NULL) {
		memset(&names->key_aliases[names->num_key_aliases], 0,
			(nTotalAliases - names->num_key_aliases) * sizeof(XkbKeyAliasRec));
	    } else {
		free(prev_aliases);
	    }
	}
	if (names->key_aliases==NULL) {
	    names->num_key_aliases= 0;
	    return BadAlloc;
	}
	names->num_key_aliases= nTotalAliases;
    }
    if ((which&XkbRGNamesMask)&&(nTotalRG>0)) {
	if (names->radio_groups==NULL) {
	    names->radio_groups= calloc(nTotalRG, sizeof(Atom));
	}
	else if (nTotalRG>names->num_rg) {
	    Atom *prev_radio_groups = names->radio_groups;

	    names->radio_groups= realloc(names->radio_groups,
					  nTotalRG * sizeof(Atom));
	    if (names->radio_groups!=NULL) {
		memset(&names->radio_groups[names->num_rg], 0,
			(nTotalRG - names->num_rg) * sizeof(Atom));
	    } else {
		free(prev_radio_groups);
	    }
	}
	if (names->radio_groups==NULL)
	    return BadAlloc;
	names->num_rg= nTotalRG;
    }
    return Success;
}

void
XkbFreeNames(XkbDescPtr xkb,unsigned which,Bool freeMap)
{
XkbNamesPtr	names;

    if ((xkb==NULL)||(xkb->names==NULL))
	return;
    names= xkb->names;
    if (freeMap)
	which= XkbAllNamesMask; 
    if (which&XkbKTLevelNamesMask) {
	XkbClientMapPtr	map= xkb->map;
	if ((map!=NULL)&&(map->types!=NULL)) {
	    register int 		i;
	    register XkbKeyTypePtr	type;
	    type= map->types;
	    for (i=0;i<map->num_types;i++,type++) {
		free(type->level_names);
		type->level_names = NULL;
	    }
	}
    }
    if ((which&XkbKeyNamesMask)&&(names->keys!=NULL)) {
	free(names->keys);
	names->keys= NULL;
	names->num_keys= 0;
    }
    if ((which&XkbKeyAliasesMask)&&(names->key_aliases)){
	free(names->key_aliases);
	names->key_aliases=NULL;
	names->num_key_aliases=0;
    }
    if ((which&XkbRGNamesMask)&&(names->radio_groups)) {
	free(names->radio_groups);
	names->radio_groups= NULL;
	names->num_rg= 0;
    }
    if (freeMap) {
	free(names);
	xkb->names= NULL;
    }
    return;
}

/***===================================================================***/

/*ARGSUSED*/
Status
XkbAllocControls(XkbDescPtr xkb,unsigned which)
{
    if (xkb==NULL)
	return BadMatch;

    if (xkb->ctrls==NULL) {
	xkb->ctrls= calloc(1, sizeof(XkbControlsRec));
	if (!xkb->ctrls)
	    return BadAlloc;
    }
    return Success;
}

/*ARGSUSED*/
static void
XkbFreeControls(XkbDescPtr xkb,unsigned which,Bool freeMap)
{
    if (freeMap && (xkb!=NULL) && (xkb->ctrls!=NULL)) {
	free(xkb->ctrls);
	xkb->ctrls= NULL;
    }
    return;
}

/***===================================================================***/

Status
XkbAllocIndicatorMaps(XkbDescPtr xkb)
{
    if (xkb==NULL)
	return BadMatch;
    if (xkb->indicators==NULL) {
	xkb->indicators= calloc(1, sizeof(XkbIndicatorRec));
	if (!xkb->indicators)
	    return BadAlloc;
    }
    return Success;
}

static void
XkbFreeIndicatorMaps(XkbDescPtr xkb)
{
    if ((xkb!=NULL)&&(xkb->indicators!=NULL)) {
	free(xkb->indicators);
	xkb->indicators= NULL;
    }
    return;
}

/***====================================================================***/

XkbDescRec	*
XkbAllocKeyboard(void)
{
XkbDescRec *xkb;

    xkb = calloc(1, sizeof(XkbDescRec));
    if (xkb)
	xkb->device_spec= XkbUseCoreKbd;
    return xkb;
}

void
XkbFreeKeyboard(XkbDescPtr xkb,unsigned which,Bool freeAll)
{
    if (xkb==NULL)
	return;
    if (freeAll)
	which= XkbAllComponentsMask;
    if (which&XkbClientMapMask)
	XkbFreeClientMap(xkb,XkbAllClientInfoMask,TRUE);
    if (which&XkbServerMapMask)
	XkbFreeServerMap(xkb,XkbAllServerInfoMask,TRUE);
    if (which&XkbCompatMapMask)
	XkbFreeCompatMap(xkb,XkbAllCompatMask,TRUE);
    if (which&XkbIndicatorMapMask)
	XkbFreeIndicatorMaps(xkb);
    if (which&XkbNamesMask)
	XkbFreeNames(xkb,XkbAllNamesMask,TRUE);
    if ((which&XkbGeometryMask) && (xkb->geom!=NULL)) {
	XkbFreeGeometry(xkb->geom,XkbGeomAllMask,TRUE);
        /* PERHAPS BONGHITS etc */
        xkb->geom = NULL;
    }
    if (which&XkbControlsMask)
	XkbFreeControls(xkb,XkbAllControlsMask,TRUE);
    if (freeAll)
	free(xkb);
    return;
}


/***====================================================================***/

void
XkbFreeComponentNames(XkbComponentNamesPtr names, Bool freeNames)
{
    if (names)
    {
        free(names->keycodes);
        free(names->types);
        free(names->compat);
        free(names->symbols);
        free(names->geometry);
        memset(names, 0, sizeof(XkbComponentNamesRec));
    }
    if (freeNames)
        free(names);
}
/* This file generated automatically by xkbcomp */
/* DO  NOT EDIT */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef DEFAULT_H
#define DEFAULT_H 1

#define GET_ATOM(d,s)	MakeAtom(s,strlen(s),1)
#define DPYTYPE	char *
#define NUM_KEYS	1

#define	vmod_NumLock	0
#define	vmod_Alt	1
#define	vmod_LevelThree	2
#define	vmod_AltGr	3
#define	vmod_ScrollLock	4

#define	vmod_NumLockMask	(1<<0)
#define	vmod_AltMask	(1<<1)
#define	vmod_LevelThreeMask	(1<<2)
#define	vmod_AltGrMask	(1<<3)
#define	vmod_ScrollLockMask	(1<<4)

/* types name is "default" */
static Atom lnames_ONE_LEVEL[1];

static XkbKTMapEntryRec map_TWO_LEVEL[1]= {
    { 1,      1, {       ShiftMask,       ShiftMask,               0 } }
};
static Atom lnames_TWO_LEVEL[2];

static XkbKTMapEntryRec map_ALPHABETIC[2]= {
    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
    { 1,      0, {        LockMask,        LockMask,               0 } }
};
static XkbModsRec preserve_ALPHABETIC[2]= {
    {                 0,               0,               0 },
    {          LockMask,        LockMask,               0 }
};
static Atom lnames_ALPHABETIC[2];

static XkbKTMapEntryRec map_KEYPAD[2]= {
    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
    { 0,      1, {               0,               0, vmod_NumLockMask } }
};
static Atom lnames_KEYPAD[2];

static XkbKTMapEntryRec map_PC_BREAK[1]= {
    { 1,      1, {     ControlMask,     ControlMask,               0 } }
};
static Atom lnames_PC_BREAK[2];

static XkbKTMapEntryRec map_PC_SYSRQ[1]= {
    { 0,      1, {               0,               0,    vmod_AltMask } }
};
static Atom lnames_PC_SYSRQ[2];

static XkbKTMapEntryRec map_CTRL_ALT[1]= {
    { 0,      1, {     ControlMask,     ControlMask,    vmod_AltMask } }
};
static Atom lnames_CTRL_ALT[2];

static XkbKTMapEntryRec map_THREE_LEVEL[3]= {
    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
    { 0,      2, {               0,               0, vmod_LevelThreeMask } },
    { 0,      2, {       ShiftMask,       ShiftMask, vmod_LevelThreeMask } }
};
static Atom lnames_THREE_LEVEL[3];

static XkbKTMapEntryRec map_SHIFT_ALT[1]= {
    { 0,      1, {       ShiftMask,       ShiftMask,    vmod_AltMask } }
};
static Atom lnames_SHIFT_ALT[2];

static XkbKeyTypeRec dflt_types[]= {
    {
	{               0,               0,               0 },
	1,
	0,	NULL,	NULL,
	None,	lnames_ONE_LEVEL
    },
    {
	{       ShiftMask,       ShiftMask,               0 },
	2,
	1,	map_TWO_LEVEL,	NULL,
	None,	lnames_TWO_LEVEL
    },
    {
	{ ShiftMask|LockMask, ShiftMask|LockMask,               0 },
	2,
	2,	map_ALPHABETIC,	preserve_ALPHABETIC,
	None,	lnames_ALPHABETIC
    },
    {
	{       ShiftMask,       ShiftMask, vmod_NumLockMask },
	2,
	2,	map_KEYPAD,	NULL,
	None,	lnames_KEYPAD
    },
    {
	{     ControlMask,     ControlMask,               0 },
	2,
	1,	map_PC_BREAK,	NULL,
	None,	lnames_PC_BREAK
    },
    {
	{               0,               0,    vmod_AltMask },
	2,
	1,	map_PC_SYSRQ,	NULL,
	None,	lnames_PC_SYSRQ
    },
    {
	{     ControlMask,     ControlMask,    vmod_AltMask },
	2,
	1,	map_CTRL_ALT,	NULL,
	None,	lnames_CTRL_ALT
    },
    {
	{       ShiftMask,       ShiftMask, vmod_LevelThreeMask },
	3,
	3,	map_THREE_LEVEL,	NULL,
	None,	lnames_THREE_LEVEL
    },
    {
	{       ShiftMask,       ShiftMask,    vmod_AltMask },
	2,
	1,	map_SHIFT_ALT,	NULL,
	None,	lnames_SHIFT_ALT
    }
};
#define num_dflt_types (sizeof(dflt_types)/sizeof(XkbKeyTypeRec))


static void
initTypeNames(DPYTYPE dpy)
{
    dflt_types[0].name= GET_ATOM(dpy,"ONE_LEVEL");
    lnames_ONE_LEVEL[0]=	GET_ATOM(dpy,"Any");
    dflt_types[1].name= GET_ATOM(dpy,"TWO_LEVEL");
    lnames_TWO_LEVEL[0]=	GET_ATOM(dpy,"Base");
    lnames_TWO_LEVEL[1]=	GET_ATOM(dpy,"Shift");
    dflt_types[2].name= GET_ATOM(dpy,"ALPHABETIC");
    lnames_ALPHABETIC[0]=	GET_ATOM(dpy,"Base");
    lnames_ALPHABETIC[1]=	GET_ATOM(dpy,"Caps");
    dflt_types[3].name= GET_ATOM(dpy,"KEYPAD");
    lnames_KEYPAD[0]=	GET_ATOM(dpy,"Base");
    lnames_KEYPAD[1]=	GET_ATOM(dpy,"Number");
    dflt_types[4].name= GET_ATOM(dpy,"PC_BREAK");
    lnames_PC_BREAK[0]=	GET_ATOM(dpy,"Base");
    lnames_PC_BREAK[1]=	GET_ATOM(dpy,"Control");
    dflt_types[5].name= GET_ATOM(dpy,"PC_SYSRQ");
    lnames_PC_SYSRQ[0]=	GET_ATOM(dpy,"Base");
    lnames_PC_SYSRQ[1]=	GET_ATOM(dpy,"Alt");
    dflt_types[6].name= GET_ATOM(dpy,"CTRL+ALT");
    lnames_CTRL_ALT[0]=	GET_ATOM(dpy,"Base");
    lnames_CTRL_ALT[1]=	GET_ATOM(dpy,"Ctrl+Alt");
    dflt_types[7].name= GET_ATOM(dpy,"THREE_LEVEL");
    lnames_THREE_LEVEL[0]=	GET_ATOM(dpy,"Base");
    lnames_THREE_LEVEL[1]=	GET_ATOM(dpy,"Shift");
    lnames_THREE_LEVEL[2]=	GET_ATOM(dpy,"Level3");
    dflt_types[8].name= GET_ATOM(dpy,"SHIFT+ALT");
    lnames_SHIFT_ALT[0]=	GET_ATOM(dpy,"Base");
    lnames_SHIFT_ALT[1]=	GET_ATOM(dpy,"Shift+Alt");
}
/* compat name is "default" */
static XkbSymInterpretRec dfltSI[69]= {
    {    XK_ISO_Level2_Latch, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_Exactly, ShiftMask,
         255,
       {      XkbSA_LatchMods, { 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Eisu_Shift, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Eisu_toggle, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Kana_Shift, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Kana_Lock, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Shift_Lock, 0x0000,
         XkbSI_AnyOf, ShiftMask|LockMask,
         255,
       {       XkbSA_LockMods, { 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Num_Lock, 0x0000,
         XkbSI_AnyOf, 0xff,
         0,
       {       XkbSA_LockMods, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_Alt_L, 0x0000,
         XkbSI_AnyOf, 0xff,
         1,
       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Alt_R, 0x0000,
         XkbSI_AnyOf, 0xff,
         1,
       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Scroll_Lock, 0x0000,
         XkbSI_AnyOf, 0xff,
         4,
       {       XkbSA_LockMods, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Lock, 0x0000,
         XkbSI_AnyOf, 0xff,
         255,
       {        XkbSA_ISOLock, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Level3_Shift, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOf, 0xff,
         2,
       {        XkbSA_SetMods, { 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 } } },
    {    XK_ISO_Level3_Latch, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOf, 0xff,
         2,
       {      XkbSA_LatchMods, { 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 } } },
    {    XK_Mode_switch, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
         3,
       {       XkbSA_SetGroup, { 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_1, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_End, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_2, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_Down, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_3, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_Next, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00 } } },
    {    XK_KP_4, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Left, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_6, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Right, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_7, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_Home, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_8, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_Up, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_9, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_Prior, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00 } } },
    {    XK_KP_5, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Begin, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_F1, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Divide, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_F2, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Multiply, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_F3, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Subtract, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Separator, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Add, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_0, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Insert, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Decimal, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_KP_Delete, 0x0001,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Button_Dflt, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Button1, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Button2, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Button3, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DblClick_Dflt, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DblClick1, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DblClick2, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DblClick3, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Drag_Dflt, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Drag1, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Drag2, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_Drag3, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_EnableKeys, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00 } } },
    {    XK_Pointer_Accelerate, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00 } } },
    {    XK_Pointer_DfltBtnNext, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_Pointer_DfltBtnPrev, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {     XkbSA_SetPtrDflt, { 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_AccessX_Enable, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00 } } },
    {    XK_Terminate_Server, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {      XkbSA_Terminate, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Group_Latch, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
         3,
       {     XkbSA_LatchGroup, { 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Next_Group, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
         3,
       {      XkbSA_LockGroup, { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Prev_Group, 0x0000,
         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
         3,
       {      XkbSA_LockGroup, { 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_First_Group, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {      XkbSA_LockGroup, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    XK_ISO_Last_Group, 0x0000,
         XkbSI_AnyOfOrNone, 0xff,
         255,
       {      XkbSA_LockGroup, { 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
    {    NoSymbol, 0x0000,
         XkbSI_Exactly, LockMask,
         255,
       {       XkbSA_LockMods, { 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
    {    NoSymbol, 0x0000,
         XkbSI_AnyOf, 0xff,
         255,
       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } }
};
#define num_dfltSI (sizeof(dfltSI)/sizeof(XkbSymInterpretRec))

static XkbCompatMapRec compatMap= {
    dfltSI,
    {   /* group compatibility */
        {            0,            0,            0 },
        {            0,            0, vmod_AltGrMask },
        {            0,            0, vmod_AltGrMask },
        {            0,            0, vmod_AltGrMask }
    },
    num_dfltSI, num_dfltSI
};

static void
initIndicatorNames(DPYTYPE dpy,XkbDescPtr xkb)
{
    xkb->names->indicators[ 0]=	GET_ATOM(dpy,"Caps Lock");
    xkb->names->indicators[ 1]=	GET_ATOM(dpy,"Num Lock");
    xkb->names->indicators[ 2]=	GET_ATOM(dpy,"Shift Lock");
    xkb->names->indicators[ 3]=	GET_ATOM(dpy,"Mouse Keys");
    xkb->names->indicators[ 4]=	GET_ATOM(dpy,"Scroll Lock");
    xkb->names->indicators[ 5]=	GET_ATOM(dpy,"Group 2");
}
#endif /* DEFAULT_H */
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "inputstr.h"
#include "exevents.h"
#include "exglobals.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include "xkb.h"

/***====================================================================***/

/*
 * This function sends out two kinds of notification:
 *   - Core mapping notify events sent to clients for whom kbd is the
 *     current core ('picked') keyboard _and_ have not explicitly
 *     selected for XKB mapping notify events;
 *   - Xi mapping events, sent unconditionally to all clients who have
 *     explicitly selected for them (including those who have explicitly
 *     selected for XKB mapping notify events!).
 */
static void
XkbSendLegacyMapNotify(DeviceIntPtr kbd, CARD16 xkb_event, CARD16 changed,
                       int first_key, int num_keys)
{
    int i;
    int keymap_changed = 0;
    int modmap_changed = 0;
    xEvent core_mn;
    deviceMappingNotify xi_mn;
    CARD32 time = GetTimeInMillis();

    if (xkb_event == XkbNewKeyboardNotify) {
        if (changed & XkbNKN_KeycodesMask) {
            keymap_changed = 1;
            modmap_changed = 1;
        }
    }
    else if (xkb_event == XkbMapNotify) {
        if (changed & XkbKeySymsMask)
            keymap_changed = 1;
        if (changed & XkbModifierMapMask)
            modmap_changed = 1;
    }
    if (!keymap_changed && !modmap_changed)
        return;

    core_mn.u.u.type = MappingNotify;
    xi_mn.type = DeviceMappingNotify;
    xi_mn.deviceid = kbd->id;
    xi_mn.time = time;

    /* 0 is serverClient. */
    for (i = 1; i < currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        /* XKB allows clients to restrict the MappingNotify events sent to
         * them.  This was broken for three years.  Sorry. */
        if (xkb_event == XkbMapNotify &&
            (clients[i]->xkbClientFlags & _XkbClientInitialized) &&
            !(clients[i]->mapNotifyMask & changed))
            continue;
        /* Emulate previous server behaviour: any client which has activated
         * XKB will not receive core events emulated from a NewKeyboardNotify
         * at all. */
        if (xkb_event == XkbNewKeyboardNotify &&
            (clients[i]->xkbClientFlags & _XkbClientInitialized))
            continue;

        /* Don't send core events to clients who don't know about us. */
        if (!XIShouldNotify(clients[i], kbd))
            continue;

        if (keymap_changed) {
            core_mn.u.mappingNotify.request = MappingKeyboard;

            /* Clip the keycode range to what the client knows about, so it
             * doesn't freak out. */
            if (first_key >= clients[i]->minKC)
                core_mn.u.mappingNotify.firstKeyCode = first_key;
            else
                core_mn.u.mappingNotify.firstKeyCode = clients[i]->minKC;
            if (first_key + num_keys - 1 <= clients[i]->maxKC)
                core_mn.u.mappingNotify.count = num_keys;
            else
                core_mn.u.mappingNotify.count = clients[i]->maxKC -
                                                 clients[i]->minKC + 1;

            WriteEventsToClient(clients[i], 1, &core_mn);
        }
        if (modmap_changed) {
            core_mn.u.mappingNotify.request = MappingModifier;
            core_mn.u.mappingNotify.firstKeyCode = 0;
            core_mn.u.mappingNotify.count = 0;
            WriteEventsToClient(clients[i], 1, &core_mn);
        }
    }

    /* Hmm, maybe we can accidentally generate Xi events for core devices
     * here? Clients might be upset, but that seems better than the
     * alternative of stale keymaps. -ds */
    if (keymap_changed) {
        xi_mn.request = MappingKeyboard;
        xi_mn.firstKeyCode = first_key;
        xi_mn.count = num_keys;
        SendEventToAllWindows(kbd, DeviceMappingNotifyMask, (xEvent *) &xi_mn,
                              1);
    }
    if (modmap_changed) {
        xi_mn.request = MappingModifier;
        xi_mn.firstKeyCode = 0;
        xi_mn.count = 0;
        SendEventToAllWindows(kbd, DeviceMappingNotifyMask, (xEvent *) &xi_mn,
                              1);
    }
}

/***====================================================================***/

void
XkbSendNewKeyboardNotify(DeviceIntPtr kbd,xkbNewKeyboardNotify *pNKN)
{
    int i;
    Time time = GetTimeInMillis();
    CARD16 changed = pNKN->changed;

    pNKN->type = XkbEventCode + XkbEventBase;
    pNKN->xkbType = XkbNewKeyboardNotify;

    for (i=1; i<currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        if (!(clients[i]->newKeyboardNotifyMask & changed))
            continue;

        pNKN->sequenceNumber = clients[i]->sequence;
        pNKN->time = time;
        pNKN->changed = changed;
        if (clients[i]->swapped) {
            int n;
            swaps(&pNKN->sequenceNumber,n);
            swapl(&pNKN->time,n);
            swaps(&pNKN->changed,n);
        }
        WriteToClient(clients[i], sizeof(xEvent), pNKN);

        if (changed & XkbNKN_KeycodesMask) {
            clients[i]->minKC = pNKN->minKeyCode;
            clients[i]->maxKC = pNKN->maxKeyCode;
        }
    }

    XkbSendLegacyMapNotify(kbd, XkbNewKeyboardNotify, changed, pNKN->minKeyCode,
                           pNKN->maxKeyCode - pNKN->minKeyCode + 1);

    return;
}

/***====================================================================***/

void
XkbSendStateNotify(DeviceIntPtr kbd,xkbStateNotify *pSN)
{
XkbSrvInfoPtr	xkbi;
XkbStatePtr	state;
XkbInterestPtr	interest;
Time 		time;
register CARD16	changed,bState;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
	return;
    xkbi = kbd->key->xkbInfo;
    state= &xkbi->state;

    pSN->type = XkbEventCode + XkbEventBase;
    pSN->xkbType = XkbStateNotify;
    pSN->deviceID = kbd->id;
    pSN->time = time = GetTimeInMillis();
    pSN->mods = state->mods;
    pSN->baseMods = state->base_mods;
    pSN->latchedMods = state->latched_mods;
    pSN->lockedMods = state->locked_mods;
    pSN->group = state->group;
    pSN->baseGroup = state->base_group;
    pSN->latchedGroup = state->latched_group;
    pSN->lockedGroup = state->locked_group;
    pSN->compatState = state->compat_state;
    pSN->grabMods = state->grab_mods;
    pSN->compatGrabMods = state->compat_grab_mods;
    pSN->lookupMods = state->lookup_mods;
    pSN->compatLookupMods = state->compat_lookup_mods;
    pSN->ptrBtnState = state->ptr_buttons;
    changed = pSN->changed;
    bState= pSN->ptrBtnState;

    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->stateNotifyMask&changed)) {
	    pSN->sequenceNumber = interest->client->sequence;
	    pSN->time = time;
	    pSN->changed = changed;
	    pSN->ptrBtnState = bState;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pSN->sequenceNumber,n);
		swapl(&pSN->time,n);
		swaps(&pSN->changed,n);
		swaps(&pSN->ptrBtnState,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pSN);
	}
	interest= interest->next;
    }
    return;
}

/***====================================================================***/

/*
 * This function sends out XKB mapping notify events to clients which
 * have explicitly selected for them.  Core and Xi events are handled by
 * XkbSendLegacyMapNotify. */
void
XkbSendMapNotify(DeviceIntPtr kbd, xkbMapNotify *pMN)
{
    int i;
    CARD32 time = GetTimeInMillis();
    CARD16 changed = pMN->changed;
    XkbSrvInfoPtr xkbi = kbd->key->xkbInfo;

    pMN->minKeyCode = xkbi->desc->min_key_code;
    pMN->maxKeyCode = xkbi->desc->max_key_code;
    pMN->type = XkbEventCode + XkbEventBase;
    pMN->xkbType = XkbMapNotify;
    pMN->deviceID = kbd->id;

    /* 0 is serverClient. */
    for (i = 1; i < currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        if (!(clients[i]->mapNotifyMask & changed))
            continue;

        pMN->time = time;
        pMN->sequenceNumber = clients[i]->sequence;
        pMN->changed = changed;

        if (clients[i]->swapped) {
            int n;
            swaps(&pMN->sequenceNumber, n);
            swapl(&pMN->time, n);
            swaps(&pMN->changed, n);
        }
        WriteToClient(clients[i], sizeof(xEvent), pMN);
    }

    XkbSendLegacyMapNotify(kbd, XkbMapNotify, changed, pMN->firstKeySym,
                           pMN->nKeySyms);
}

int
XkbComputeControlsNotify(	DeviceIntPtr	 	kbd,
				XkbControlsPtr		old,
				XkbControlsPtr		new,
				xkbControlsNotify *	pCN,
				Bool			forceCtrlProc)
{
int		i;
CARD32 		changedControls;

    changedControls= 0;

    if (!kbd || !kbd->kbdfeed)
        return 0;
    
    if (old->enabled_ctrls!=new->enabled_ctrls)
	changedControls|= XkbControlsEnabledMask;
    if ((old->repeat_delay!=new->repeat_delay)||
	(old->repeat_interval!=new->repeat_interval))
	changedControls|= XkbRepeatKeysMask;
    for (i = 0; i < XkbPerKeyBitArraySize; i++)
	if (old->per_key_repeat[i] != new->per_key_repeat[i])
	    changedControls|= XkbPerKeyRepeatMask;
    if (old->slow_keys_delay!=new->slow_keys_delay)
	changedControls|= XkbSlowKeysMask;
    if (old->debounce_delay!=new->debounce_delay)
	changedControls|= XkbBounceKeysMask;
    if ((old->mk_delay!=new->mk_delay)||
	(old->mk_interval!=new->mk_interval)||
	(old->mk_dflt_btn!=new->mk_dflt_btn))
	changedControls|= XkbMouseKeysMask;
    if ((old->mk_time_to_max!=new->mk_time_to_max)||
	(old->mk_curve!=new->mk_curve)||
	(old->mk_max_speed!=new->mk_max_speed))
	changedControls|= XkbMouseKeysAccelMask;
    if (old->ax_options!=new->ax_options)
	changedControls|= XkbAccessXKeysMask;
    if ((old->ax_options^new->ax_options) & XkbAX_SKOptionsMask)
	changedControls|= XkbStickyKeysMask;
    if ((old->ax_options^new->ax_options) & XkbAX_FBOptionsMask)
	changedControls|= XkbAccessXFeedbackMask;
    if ((old->ax_timeout!=new->ax_timeout)||
	(old->axt_ctrls_mask!=new->axt_ctrls_mask)||
	(old->axt_ctrls_values!=new->axt_ctrls_values)||
	(old->axt_opts_mask!=new->axt_opts_mask)||
	(old->axt_opts_values!= new->axt_opts_values)) {
	changedControls|= XkbAccessXTimeoutMask;
    }
    if ((old->internal.mask!=new->internal.mask)||
	(old->internal.real_mods!=new->internal.real_mods)||
	(old->internal.vmods!=new->internal.vmods))
	changedControls|= XkbInternalModsMask;
    if ((old->ignore_lock.mask!=new->ignore_lock.mask)||
	(old->ignore_lock.real_mods!=new->ignore_lock.real_mods)||
	(old->ignore_lock.vmods!=new->ignore_lock.vmods))
	changedControls|= XkbIgnoreLockModsMask;

    if (new->enabled_ctrls&XkbRepeatKeysMask)
	 kbd->kbdfeed->ctrl.autoRepeat=TRUE;
    else kbd->kbdfeed->ctrl.autoRepeat=FALSE;

    if (kbd->kbdfeed && kbd->kbdfeed->CtrlProc &&
	(changedControls || forceCtrlProc))
	(*kbd->kbdfeed->CtrlProc)(kbd, &kbd->kbdfeed->ctrl);

    if ((!changedControls)&&(old->num_groups==new->num_groups))
	return 0;

    if (!kbd->xkb_interest)
	return 0;

    pCN->changedControls = changedControls;
    pCN->enabledControls = new->enabled_ctrls;
    pCN->enabledControlChanges = (new->enabled_ctrls^old->enabled_ctrls);
    pCN->numGroups = new->num_groups;

    return 1;
}

void
XkbSendControlsNotify(DeviceIntPtr kbd,xkbControlsNotify *pCN)
{
int			initialized;
CARD32 		 	changedControls, enabledControls, enabledChanges = 0;
XkbSrvInfoPtr		xkbi;
XkbInterestPtr		interest;
Time 		 	time = 0;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
	return;
    xkbi = kbd->key->xkbInfo;
 
    initialized = 0;
    enabledControls = xkbi->desc->ctrls->enabled_ctrls;
    changedControls = pCN->changedControls;
    pCN->numGroups= xkbi->desc->ctrls->num_groups;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->ctrlsNotifyMask&changedControls)) {
	    if (!initialized) {
		pCN->type = XkbEventCode + XkbEventBase;
		pCN->xkbType = XkbControlsNotify;
		pCN->deviceID = kbd->id;
		pCN->time = time = GetTimeInMillis();
		enabledChanges = pCN->enabledControlChanges;
		initialized= 1;
	    }
	    pCN->changedControls = changedControls;
	    pCN->enabledControls = enabledControls;
	    pCN->enabledControlChanges = enabledChanges;
	    pCN->sequenceNumber = interest->client->sequence;
	    pCN->time = time;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pCN->sequenceNumber,n);
		swapl(&pCN->changedControls,n);
		swapl(&pCN->enabledControls,n);
		swapl(&pCN->enabledControlChanges,n);
		swapl(&pCN->time,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pCN);
	}
	interest= interest->next;
    }
    return;
}

static void
XkbSendIndicatorNotify(DeviceIntPtr kbd,int xkbType,xkbIndicatorNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD32		state,changed;

    interest = kbd->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    state = pEv->state;
    changed = pEv->changed;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (((xkbType==XkbIndicatorStateNotify)&&
				(interest->iStateNotifyMask&changed))||
	     ((xkbType==XkbIndicatorMapNotify)&&
	    			(interest->iMapNotifyMask&changed)))) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = xkbType;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->changed = changed;
	    pEv->state = state;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swapl(&pEv->changed,n);
		swapl(&pEv->state,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}


void
XkbHandleBell(	BOOL		 force,
		BOOL		 eventOnly,
		DeviceIntPtr	 kbd,
		CARD8		 percent,
		pointer		 pCtrl,
		CARD8		 class,
		Atom		 name,
		WindowPtr	 pWin,
		ClientPtr	 pClient)
{
xkbBellNotify	bn;
int		initialized;
XkbSrvInfoPtr	xkbi;
XkbInterestPtr	interest;
CARD8		id;
CARD16		pitch,duration;
Time 		time = 0;
XID		winID = 0;

    if (!kbd->key || !kbd->key->xkbInfo)
        return;

    xkbi = kbd->key->xkbInfo;

    if ((force||(xkbi->desc->ctrls->enabled_ctrls&XkbAudibleBellMask))&&
							(!eventOnly)) {
        if (kbd->kbdfeed->BellProc)
            (*kbd->kbdfeed->BellProc)(percent,kbd,(pointer)pCtrl,class);
    }
    interest = kbd->xkb_interest;
    if ((!interest)||(force))
	return;

    if ((class==0)||(class==KbdFeedbackClass)) {
	KeybdCtrl *pKeyCtrl= (KeybdCtrl *)pCtrl;
	id= pKeyCtrl->id;
	pitch= pKeyCtrl->bell_pitch;
	duration= pKeyCtrl->bell_duration;
    }
    else if (class==BellFeedbackClass) {
	BellCtrl *pBellCtrl= (BellCtrl *)pCtrl;
	id= pBellCtrl->id;
	pitch= pBellCtrl->pitch;
	duration= pBellCtrl->duration;
    }
    else return;
 
    initialized = 0;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->bellNotifyMask)) {
	    if (!initialized) {
		time = GetTimeInMillis();
		bn.type = XkbEventCode + XkbEventBase;
		bn.xkbType = XkbBellNotify;
		bn.deviceID = kbd->id;
		bn.bellClass = class;
		bn.bellID = id;
		bn.percent= percent;
		bn.eventOnly = (eventOnly!=0);
		winID= (pWin?pWin->drawable.id:None);
		initialized= 1;
	    }
	    bn.sequenceNumber = interest->client->sequence;
	    bn.time = time;
	    bn.pitch = pitch;
	    bn.duration = duration;
	    bn.name = name;
	    bn.window=  winID;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&bn.sequenceNumber,n);
		swapl(&bn.time,n);
		swaps(&bn.pitch,n);
		swaps(&bn.duration,n);
		swapl(&bn.name,n);
		swapl(&bn.window,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)&bn);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendAccessXNotify(DeviceIntPtr kbd,xkbAccessXNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		sk_delay,db_delay;

    interest = kbd->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    sk_delay= pEv->slowKeysDelay;
    db_delay= pEv->debounceDelay;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->accessXNotifyMask&(1<<pEv->detail))) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbAccessXNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->slowKeysDelay = sk_delay;
	    pEv->debounceDelay = db_delay;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->slowKeysDelay,n);
		swaps(&pEv->debounceDelay,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendNamesNotify(DeviceIntPtr kbd,xkbNamesNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		changed,changedVirtualMods;
CARD32		changedIndicators;

    interest = kbd->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    changed= pEv->changed;
    changedIndicators= pEv->changedIndicators;
    changedVirtualMods= pEv->changedVirtualMods;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->namesNotifyMask&pEv->changed)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbNamesNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->changed = changed;
	    pEv->changedIndicators = changedIndicators;
	    pEv->changedVirtualMods= changedVirtualMods;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->changed,n);
		swapl(&pEv->changedIndicators,n);
		swaps(&pEv->changedVirtualMods,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendCompatMapNotify(DeviceIntPtr kbd,xkbCompatMapNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		firstSI = 0, nSI = 0, nTotalSI = 0;

    interest = kbd->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->compatNotifyMask)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbCompatMapNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		firstSI= pEv->firstSI;
		nSI= pEv->nSI;
		nTotalSI= pEv->nTotalSI;
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->firstSI = firstSI;
	    pEv->nSI = nSI;
	    pEv->nTotalSI = nTotalSI;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->firstSI,n);
		swaps(&pEv->nSI,n);
		swaps(&pEv->nTotalSI,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendActionMessage(DeviceIntPtr kbd,xkbActionMessage *pEv)
{
int		 initialized;
XkbSrvInfoPtr	 xkbi;
XkbInterestPtr	 interest;
Time 		 time = 0;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
	return;
 
    xkbi = kbd->key->xkbInfo;

    initialized = 0;
    pEv->mods= xkbi->state.mods;
    pEv->group= xkbi->state.group;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->actionMessageMask)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbActionMessage;
		pEv->deviceID = kbd->id;
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendExtensionDeviceNotify(	DeviceIntPtr 			dev,
				ClientPtr			client,
				xkbExtensionDeviceNotify *	pEv)
{
int		 initialized;
XkbInterestPtr	 interest;
Time 		 time = 0;
CARD32		 defined, state;
CARD16		 reason;

    interest = dev->xkb_interest;
    if (!interest)
	return;
 
    initialized = 0;
    reason= pEv->reason;
    defined= pEv->ledsDefined;
    state= pEv->ledState;
    while (interest) {
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->extDevNotifyMask&reason)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbExtensionDeviceNotify;
		pEv->deviceID = dev->id;
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    else {
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time;
		pEv->ledsDefined= defined;
		pEv->ledState= state;
		pEv->reason= reason;
		pEv->supported= XkbXI_AllFeaturesMask;
	    }
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swapl(&pEv->ledsDefined,n);
		swapl(&pEv->ledState,n);
		swaps(&pEv->reason,n);
		swaps(&pEv->supported,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
    }
    return;
}

void
XkbSendNotification(	DeviceIntPtr		kbd,
			XkbChangesPtr		pChanges,
			XkbEventCausePtr	cause)
{
XkbSrvLedInfoPtr	sli;

    sli= NULL;
    if (pChanges->state_changes) {
	xkbStateNotify sn;
	sn.changed= pChanges->state_changes;
	sn.keycode= cause->kc;
	sn.eventType= cause->event;
	sn.requestMajor= cause->mjr;
	sn.requestMinor= cause->mnr;
	XkbSendStateNotify(kbd,&sn);
    }
    if (pChanges->map.changed) {
	xkbMapNotify mn;
	memset(&mn, 0, sizeof(xkbMapNotify));
	mn.changed= pChanges->map.changed;
	mn.firstType= pChanges->map.first_type;
	mn.nTypes= pChanges->map.num_types;
	mn.firstKeySym= pChanges->map.first_key_sym;
	mn.nKeySyms= pChanges->map.num_key_syms;
	mn.firstKeyAct= pChanges->map.first_key_act;
	mn.nKeyActs= pChanges->map.num_key_acts;
	mn.firstKeyBehavior= pChanges->map.first_key_behavior;
	mn.nKeyBehaviors= pChanges->map.num_key_behaviors;
	mn.virtualMods= pChanges->map.vmods;
	mn.firstKeyExplicit= pChanges->map.first_key_explicit;
	mn.nKeyExplicit= pChanges->map.num_key_explicit;
	mn.firstModMapKey= pChanges->map.first_modmap_key;
	mn.nModMapKeys= pChanges->map.num_modmap_keys;
	mn.firstVModMapKey= pChanges->map.first_vmodmap_key;
	mn.nVModMapKeys= pChanges->map.num_vmodmap_keys;
	XkbSendMapNotify(kbd,&mn);
    }
    if ((pChanges->ctrls.changed_ctrls)||
	(pChanges->ctrls.enabled_ctrls_changes)) {
	xkbControlsNotify cn;
	memset(&cn, 0, sizeof(xkbControlsNotify));
	cn.changedControls= pChanges->ctrls.changed_ctrls;
	cn.enabledControlChanges= pChanges->ctrls.enabled_ctrls_changes;
	cn.keycode= cause->kc;
	cn.eventType= cause->event;
	cn.requestMajor= cause->mjr;
	cn.requestMinor= cause->mnr;
	XkbSendControlsNotify(kbd,&cn);
    }
    if (pChanges->indicators.map_changes) {
	xkbIndicatorNotify in;
	if (sli==NULL)
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	memset(&in, 0, sizeof(xkbIndicatorNotify));
	in.state= sli->effectiveState;
	in.changed= pChanges->indicators.map_changes;
	XkbSendIndicatorNotify(kbd,XkbIndicatorMapNotify,&in);
    }
    if (pChanges->indicators.state_changes) {
	xkbIndicatorNotify in;
	if (sli==NULL)
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	memset(&in, 0, sizeof(xkbIndicatorNotify));
	in.state= sli->effectiveState;
	in.changed= pChanges->indicators.state_changes;
	XkbSendIndicatorNotify(kbd,XkbIndicatorStateNotify,&in);
    }
    if (pChanges->names.changed) {
	xkbNamesNotify nn;
	memset(&nn, 0, sizeof(xkbNamesNotify));
	nn.changed= pChanges->names.changed;
	nn.firstType= pChanges->names.first_type;
	nn.nTypes= pChanges->names.num_types;
	nn.firstLevelName= pChanges->names.first_lvl;
	nn.nLevelNames= pChanges->names.num_lvls;
	nn.nRadioGroups= pChanges->names.num_rg;
	nn.changedVirtualMods= pChanges->names.changed_vmods;
	nn.changedIndicators= pChanges->names.changed_indicators;
	XkbSendNamesNotify(kbd,&nn);
    }
    if ((pChanges->compat.changed_groups)||(pChanges->compat.num_si>0)) {
	xkbCompatMapNotify cmn;
	memset(&cmn, 0, sizeof(xkbCompatMapNotify));
	cmn.changedGroups= pChanges->compat.changed_groups;
	cmn.firstSI= pChanges->compat.first_si;
	cmn.nSI= pChanges->compat.num_si;
	cmn.nTotalSI= kbd->key->xkbInfo->desc->compat->num_si;
	XkbSendCompatMapNotify(kbd,&cmn);
    }
    return;
}

/***====================================================================***/

void
XkbFilterEvents(ClientPtr client,int nEvents,xEvent *xE)
{
    DeviceIntPtr dev = NULL;
    XkbSrvInfoPtr xkbi;
    CARD8 type = xE[0].u.u.type;

    if (xE->u.u.type & EXTENSION_EVENT_BASE)
        dev = XIGetDevice(xE);

    if (!dev)
        dev = PickKeyboard(client);

    if (!dev->key)
        return;

    xkbi = dev->key->xkbInfo;

    if (client->xkbClientFlags & _XkbClientInitialized) {
	if ((xkbDebugFlags&0x10)&&
            (type == KeyPress || type == KeyRelease ||
             type == DeviceKeyPress || type == DeviceKeyRelease))
	    DebugF("[xkb] XkbFilterWriteEvents (XKB client): state 0x%04x\n",
                   xE[0].u.keyButtonPointer.state);

	if (dev->deviceGrab.grab != NullGrab && dev->deviceGrab.fromPassiveGrab &&
	    (type == KeyPress || type == KeyRelease ||
             type == DeviceKeyPress || type == DeviceKeyRelease)) {
	    unsigned int state, flags;

	    flags = client->xkbClientFlags;
	    state = xkbi->state.compat_grab_mods;
	    if (flags & XkbPCF_GrabsUseXKBStateMask) {
		int group;
		if (flags & XkbPCF_LookupStateWhenGrabbed) {
		     group = xkbi->state.group;
		     state = xkbi->state.lookup_mods;
		}
		else {
		    state = xkbi->state.grab_mods;
		    group = xkbi->state.base_group + xkbi->state.latched_group;
		    if (group < 0 || group >= xkbi->desc->ctrls->num_groups)
			group = XkbAdjustGroup(group, xkbi->desc->ctrls);
		}
		state = XkbBuildCoreState(state, group);
	    }
	    else if (flags & XkbPCF_LookupStateWhenGrabbed) {
		state = xkbi->state.compat_lookup_mods;
            }
	    xE[0].u.keyButtonPointer.state = state;
	}
    }
    else {
        if ((xkbDebugFlags & 0x4) &&
	    (xE[0].u.u.type == KeyPress || xE[0].u.u.type==KeyRelease ||
             xE[0].u.u.type == DeviceKeyPress ||
             xE[0].u.u.type == DeviceKeyRelease)) {
	    DebugF("[xkb] XKbFilterWriteEvents (non-XKB):\n");
	    DebugF("[xkb] event= 0x%04x\n",xE[0].u.keyButtonPointer.state);
	    DebugF("[xkb] lookup= 0x%02x, grab= 0x%02x\n",
                   xkbi->state.lookup_mods, xkbi->state.grab_mods);
	    DebugF("[xkb] compat lookup= 0x%02x, grab= 0x%02x\n",
		   xkbi->state.compat_lookup_mods, xkbi->state.compat_grab_mods);
	}
	if (type >= KeyPress && type <= MotionNotify) {
	    CARD16 old, new;

	    old = xE[0].u.keyButtonPointer.state & ~0x1f00;
	    new = xE[0].u.keyButtonPointer.state & 0x1F00;

	    if (old == XkbStateFieldFromRec(&xkbi->state))
		new |= xkbi->state.compat_lookup_mods;
	    else
                new |= xkbi->state.compat_grab_mods;
	    xE[0].u.keyButtonPointer.state = new;
	}
	else if (type == EnterNotify || type == LeaveNotify) {
	    xE[0].u.enterLeave.state &= 0x1F00;
	    xE[0].u.enterLeave.state |= xkbi->state.compat_grab_mods;
	}
        else if (type >= DeviceKeyPress && type <= DeviceMotionNotify) {
            CARD16 old, new;
            deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer*) &xE[0];

            old = kbp->state & ~0x1F00;
            new = kbp->state & 0x1F00;
	    if (old == XkbStateFieldFromRec(&xkbi->state))
		new |= xkbi->state.compat_lookup_mods;
	    else
                new |= xkbi->state.compat_grab_mods;
            kbp->state = new;
        }
    }
}

/***====================================================================***/

XkbInterestPtr
XkbFindClientResource(DevicePtr inDev,ClientPtr client)
{
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;

    if ( dev->xkb_interest ) {
	interest = dev->xkb_interest;
	while (interest){
	    if (interest->client==client) {
		return interest;
	    }
	    interest = interest->next;
	}
    }
    return NULL;
}

XkbInterestPtr
XkbAddClientResource(DevicePtr inDev,ClientPtr client,XID id)
{
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;

    interest = dev->xkb_interest;
    while (interest) {
	if (interest->client==client)
	    return ((interest->resource==id)?interest:NULL);
	interest = interest->next;
    }
    interest = calloc(1, sizeof(XkbInterestRec));
    if (interest) {
	interest->dev = dev;
	interest->client = client;
	interest->resource = id;
	interest->next = dev->xkb_interest;
	dev->xkb_interest= interest;
	return interest;
    }
    return NULL;
}

int
XkbRemoveResourceClient(DevicePtr inDev,XID id) 
{
XkbSrvInfoPtr	xkbi;
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;
Bool		found;
unsigned long	autoCtrls,autoValues;
ClientPtr	client = NULL;

    found= FALSE;

    if (!dev->key || !dev->key->xkbInfo)
        return found;

    autoCtrls= autoValues= 0;
    if ( dev->xkb_interest ) {
	interest = dev->xkb_interest;
	if (interest && (interest->resource==id)){
	    dev->xkb_interest = interest->next;
	    autoCtrls= interest->autoCtrls;
	    autoValues= interest->autoCtrlValues;
	    client= interest->client;
	    free(interest);
	    found= TRUE;
	}
	while ((!found)&&(interest->next)) {
	    if (interest->next->resource==id) {
		XkbInterestPtr	victim = interest->next;
		interest->next = victim->next;
		autoCtrls= victim->autoCtrls;
		autoValues= victim->autoCtrlValues;
		client= victim->client;
		free(victim);
		found= TRUE;
	    }
	    interest = interest->next;
	}
    }
    if (found && autoCtrls && dev->key && dev->key->xkbInfo ) {
	XkbEventCauseRec cause;

	xkbi= dev->key->xkbInfo;
	XkbSetCauseXkbReq(&cause,X_kbPerClientFlags,client);
	XkbEnableDisableControls(xkbi,autoCtrls,autoValues,NULL,&cause);
    }
    return found;
}
/************************************************************
 Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include <X11/Xos.h>
#include <X11/Xfuncs.h>
#include <X11/extensions/XKMformat.h>

#include <X11/X.h>
#include <X11/keysym.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS	1
#include <xkbsrv.h>
#include "xkbgeom.h"
#include "xkb.h"

unsigned
_XkbKSCheckCase(KeySym ks)
{
unsigned	set,rtrn;

    set= (ks & (~0xff)) >> 8;
    rtrn= 0;
    switch (set) {
	case 0:		/* latin 1 */
	    if (((ks>=XK_A)&&(ks<=XK_Z))||
		((ks>=XK_Agrave)&&(ks<=XK_THORN)&&(ks!=XK_multiply))) {
		rtrn|= _XkbKSUpper;
	    }
	    if (((ks>=XK_a)&&(ks<=XK_z))||
		((ks>=XK_ssharp)&&(ks<=XK_ydiaeresis)&&(ks!=XK_division))) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 1:		/* latin 2 */
	    if (((ks>=XK_Aogonek)&&(ks<=XK_Zabovedot)&&(ks!=XK_breve))||
		((ks>=XK_Racute)&&(ks<=XK_Tcedilla))) {
		rtrn|= _XkbKSUpper;
	    }
	    if (((ks>=XK_aogonek)&&(ks<=XK_zabovedot)&&(ks!=XK_ogonek)&&(ks!=XK_caron)&&(ks!=XK_doubleacute))||
		((ks>=XK_racute)&&(ks<=XK_tcedilla))) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 2:		/* latin 3 */
	    if (((ks>=XK_Hstroke)&&(ks<=XK_Jcircumflex))||
		((ks>=XK_Cabovedot)&&(ks<=XK_Scircumflex))) {
		rtrn|= _XkbKSUpper;
	    }
	    if (((ks>=XK_hstroke)&&(ks<=XK_jcircumflex))||
		((ks>=XK_cabovedot)&&(ks<=XK_scircumflex))) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 3:		/* latin 4 */
	    if (((ks>=XK_Rcedilla)&&(ks<=XK_Tslash))||
	        (ks==XK_ENG)||
		((ks>=XK_Amacron)&&(ks<=XK_Umacron))) {
		rtrn|= _XkbKSUpper;
	    }
	    if ((ks==XK_kra)||
	        ((ks>=XK_rcedilla)&&(ks<=XK_tslash))||
	        (ks==XK_eng)||
		((ks>=XK_amacron)&&(ks<=XK_umacron))) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 18:		/* latin 8 */
	    if ((ks==XK_Wcircumflex)||
		(ks==XK_Ycircumflex)||
		(ks==XK_Babovedot)||
		(ks==XK_Dabovedot)||
		(ks==XK_Fabovedot)||
		(ks==XK_Mabovedot)||
		(ks==XK_Pabovedot)||
		(ks==XK_Sabovedot)||
		(ks==XK_Tabovedot)||
		(ks==XK_Wgrave)||
		(ks==XK_Wacute)||
		(ks==XK_Wdiaeresis)||
		(ks==XK_Ygrave)) {
		rtrn|= _XkbKSUpper;
	    }
	    if ((ks==XK_wcircumflex)||
		(ks==XK_ycircumflex)||
		(ks==XK_babovedot)||
		(ks==XK_dabovedot)||
		(ks==XK_fabovedot)||
		(ks==XK_mabovedot)||
		(ks==XK_pabovedot)||
		(ks==XK_sabovedot)||
		(ks==XK_tabovedot)||
		(ks==XK_wgrave)||
		(ks==XK_wacute)||
		(ks==XK_wdiaeresis)||
		(ks==XK_ygrave)) {
		rtrn|= _XkbKSLower;
	    }
	    break;
	case 19:		/* latin 9 */
	    if ((ks==XK_OE)||(ks==XK_Ydiaeresis)) {
		rtrn|= _XkbKSUpper;
	    }
	    if (ks==XK_oe) {
		rtrn|= _XkbKSLower;
	    }
	    break;
    }
    return rtrn;
}

/***===================================================================***/

static Bool
XkbWriteSectionFromName(FILE *file,char *sectionName,char *name)
{
    fprintf(file,"    xkb_%-20s { include \"%s\" };\n",sectionName,name);
    return TRUE;
}

#define	NEED_DESC(n) ((!n)||((n)[0]=='+')||((n)[0]=='|')||(strchr((n),'%')))
#define	COMPLETE(n)  ((n)&&(!NEED_DESC(n)))

/* ARGSUSED */
static void
_AddIncl(	FILE *		file,
		XkbDescPtr 	xkb,
		Bool 		topLevel,
		Bool 		showImplicit,
		int 		index,
		void *		priv)
{
    if ((priv)&&(strcmp((char *)priv,"%")!=0))
	fprintf(file,"    include \"%s\"\n",(char *)priv);
    return;
}

Bool
XkbWriteXKBKeymapForNames(	FILE *			file,
				XkbComponentNamesPtr	names,
				XkbDescPtr		xkb,
				unsigned		want,
				unsigned		need)
{
const char *	tmp;
unsigned	complete;
XkbNamesPtr	old_names;
int		multi_section;
unsigned	wantNames,wantConfig,wantDflts;

    complete= 0;
    if (COMPLETE(names->keycodes))	complete|= XkmKeyNamesMask;
    if (COMPLETE(names->types))		complete|= XkmTypesMask;
    if (COMPLETE(names->compat))	complete|= XkmCompatMapMask;
    if (COMPLETE(names->symbols))	complete|= XkmSymbolsMask;
    if (COMPLETE(names->geometry))	complete|= XkmGeometryMask;
    want|= (complete|need);
    if (want&XkmSymbolsMask)
	want|= XkmKeyNamesMask|XkmTypesMask;

    if (want==0)
	return FALSE;

    if (xkb) {
        old_names = xkb->names;

        xkb->defined = 0;
        /* Wow would it ever be neat if we didn't need this noise. */
        if (xkb->names && xkb->names->keys)
            xkb->defined |= XkmKeyNamesMask;
        if (xkb->map && xkb->map->types)
            xkb->defined |= XkmTypesMask;
        if (xkb->compat)
            xkb->defined |= XkmCompatMapMask;
        if (xkb->map && xkb->map->num_syms)
            xkb->defined |= XkmSymbolsMask;
        if (xkb->indicators)
            xkb->defined |= XkmIndicatorsMask;
        if (xkb->geom)
            xkb->defined |= XkmGeometryMask;
    }
    else {
        old_names= NULL;
    }

    wantConfig= want&(~complete);
    if (xkb!=NULL) {
	if (wantConfig&XkmTypesMask) {
	    if ((!xkb->map) || (xkb->map->num_types<XkbNumRequiredTypes))
		wantConfig&= ~XkmTypesMask;
	}
	if (wantConfig&XkmCompatMapMask) {
	    if ((!xkb->compat) || (xkb->compat->num_si<1))
		wantConfig&= ~XkmCompatMapMask;
	}
	if (wantConfig&XkmSymbolsMask) {
	    if ((!xkb->map) || (!xkb->map->key_sym_map))
		wantConfig&= ~XkmSymbolsMask;
	}
	if (wantConfig&XkmIndicatorsMask) {
	    if (!xkb->indicators)
		wantConfig&= ~XkmIndicatorsMask;
	}
	if (wantConfig&XkmKeyNamesMask) {
	    if ((!xkb->names)||(!xkb->names->keys))
		wantConfig&= ~XkmKeyNamesMask;
	}
	if ((wantConfig&XkmGeometryMask)&&(!xkb->geom))
	    wantConfig&= ~XkmGeometryMask;
    }
    else {
	wantConfig= 0;
    }
    complete|= wantConfig;

    wantDflts= 0;
    wantNames= want&(~complete);
    if ((xkb!=NULL) && (old_names!=NULL)) {
	if (wantNames&XkmTypesMask) {
	    if (old_names->types!=None) {
		tmp= NameForAtom(old_names->types);
		names->types= Xstrdup(tmp);
	    }
	    else {
		wantDflts|= XkmTypesMask;
	    }
	    complete|= XkmTypesMask; 
	}
	if (wantNames&XkmCompatMapMask) {
	    if (old_names->compat!=None) {
		tmp= NameForAtom(old_names->compat);
		names->compat= Xstrdup(tmp);
	    }
	    else wantDflts|= XkmCompatMapMask;
	    complete|= XkmCompatMapMask; 
	}
	if (wantNames&XkmSymbolsMask) {
	    if (old_names->symbols==None)
		return FALSE;
	    tmp= NameForAtom(old_names->symbols);
	    names->symbols= Xstrdup(tmp);
	    complete|= XkmSymbolsMask; 
	}
	if (wantNames&XkmKeyNamesMask) {
	   if (old_names->keycodes!=None) {
		tmp= NameForAtom(old_names->keycodes);
		names->keycodes= Xstrdup(tmp);
	    }
	    else wantDflts|= XkmKeyNamesMask;
	    complete|= XkmKeyNamesMask;
	}
	if (wantNames&XkmGeometryMask) {
	    if (old_names->geometry==None)
		return FALSE;
	    tmp= NameForAtom(old_names->geometry);
	    names->geometry= Xstrdup(tmp);
	    complete|= XkmGeometryMask; 
	    wantNames&= ~XkmGeometryMask;
	}
    }
    if (complete&XkmCompatMapMask)
	complete|= XkmIndicatorsMask|XkmVirtualModsMask;
    else if (complete&(XkmSymbolsMask|XkmTypesMask))
	complete|= XkmVirtualModsMask;
    if (need & (~complete))
	return FALSE;
    if ((complete&XkmSymbolsMask)&&((XkmKeyNamesMask|XkmTypesMask)&(~complete)))
	return FALSE;

    multi_section= 1;
    if (((complete&XkmKeymapRequired)==XkmKeymapRequired)&&
	((complete&(~XkmKeymapLegal))==0)) {
	fprintf(file,"xkb_keymap \"default\" {\n");
    }
    else if (((complete&XkmSemanticsRequired)==XkmSemanticsRequired)&&
	((complete&(~XkmSemanticsLegal))==0)) {
	fprintf(file,"xkb_semantics \"default\" {\n");
    }
    else if (((complete&XkmLayoutRequired)==XkmLayoutRequired)&&
	((complete&(~XkmLayoutLegal))==0)) {
	fprintf(file,"xkb_layout \"default\" {\n");
    }
    else if (XkmSingleSection(complete&(~XkmVirtualModsMask))) {
	multi_section= 0;
    }
    else {
	return FALSE;
    }

    wantNames= complete&(~(wantConfig|wantDflts));
    if (wantConfig&XkmKeyNamesMask)
	XkbWriteXKBKeycodes(file,xkb,FALSE,FALSE,_AddIncl,names->keycodes);
    else if (wantDflts&XkmKeyNamesMask)
	fprintf(stderr,"Default symbols not implemented yet!\n");
    else if (wantNames&XkmKeyNamesMask)
	XkbWriteSectionFromName(file,"keycodes",names->keycodes);

    if (wantConfig&XkmTypesMask)
	XkbWriteXKBKeyTypes(file,xkb,FALSE,FALSE,_AddIncl,names->types);
    else if (wantDflts&XkmTypesMask)
	fprintf(stderr,"Default types not implemented yet!\n");
    else if (wantNames&XkmTypesMask)
	XkbWriteSectionFromName(file,"types",names->types);

    if (wantConfig&XkmCompatMapMask)
	XkbWriteXKBCompatMap(file,xkb,FALSE,FALSE,_AddIncl,names->compat);
    else if (wantDflts&XkmCompatMapMask)
	fprintf(stderr,"Default interps not implemented yet!\n");
    else if (wantNames&XkmCompatMapMask)
	XkbWriteSectionFromName(file,"compatibility",names->compat);

    if (wantConfig&XkmSymbolsMask)
	XkbWriteXKBSymbols(file,xkb,FALSE,FALSE,_AddIncl,names->symbols);
    else if (wantNames&XkmSymbolsMask)
	XkbWriteSectionFromName(file,"symbols",names->symbols);

    if (wantConfig&XkmGeometryMask)
	XkbWriteXKBGeometry(file,xkb,FALSE,FALSE,_AddIncl,names->geometry);
    else if (wantNames&XkmGeometryMask)
	XkbWriteSectionFromName(file,"geometry",names->geometry);

    if (multi_section)
	fprintf(file,"};\n");
    return TRUE;
}

/***====================================================================***/

int
XkbFindKeycodeByName(XkbDescPtr xkb,char *name,Bool use_aliases)
{
register int	i;

    if ((!xkb)||(!xkb->names)||(!xkb->names->keys))
	return 0;
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	if (strncmp(xkb->names->keys[i].name,name,XkbKeyNameLength)==0)
	    return i;
    }
    if (!use_aliases)
	return 0;
    if (xkb->geom && xkb->geom->key_aliases) {
	XkbKeyAliasPtr	a;
	a= xkb->geom->key_aliases;
	for (i=0;i<xkb->geom->num_key_aliases;i++,a++) {
	    if (strncmp(name,a->alias,XkbKeyNameLength)==0)
		return XkbFindKeycodeByName(xkb,a->real,FALSE);
	}
    }
    if (xkb->names && xkb->names->key_aliases) {
	XkbKeyAliasPtr	a;
	a= xkb->names->key_aliases;
	for (i=0;i<xkb->names->num_key_aliases;i++,a++) {
	    if (strncmp(name,a->alias,XkbKeyNameLength)==0)
		return XkbFindKeycodeByName(xkb,a->real,FALSE);
	}
    }
    return 0;
}


unsigned
XkbConvertGetByNameComponents(Bool toXkm,unsigned orig)
{
unsigned	rtrn;

    rtrn= 0;
    if (toXkm) {
	if (orig&XkbGBN_TypesMask)		rtrn|= XkmTypesMask;
	if (orig&XkbGBN_CompatMapMask)		rtrn|= XkmCompatMapMask;
	if (orig&XkbGBN_SymbolsMask)		rtrn|= XkmSymbolsMask;
	if (orig&XkbGBN_IndicatorMapMask)	rtrn|= XkmIndicatorsMask;
	if (orig&XkbGBN_KeyNamesMask)		rtrn|= XkmKeyNamesMask;
	if (orig&XkbGBN_GeometryMask)		rtrn|= XkmGeometryMask;
    }
    else {
	if (orig&XkmTypesMask)			rtrn|= XkbGBN_TypesMask;
	if (orig&XkmCompatMapMask)		rtrn|= XkbGBN_CompatMapMask;
	if (orig&XkmSymbolsMask)		rtrn|= XkbGBN_SymbolsMask;
	if (orig&XkmIndicatorsMask)		rtrn|= XkbGBN_IndicatorMapMask;
	if (orig&XkmKeyNamesMask)		rtrn|= XkbGBN_KeyNamesMask;
	if (orig&XkmGeometryMask)		rtrn|= XkbGBN_GeometryMask;
	if (orig!=0)				rtrn|= XkbGBN_OtherNamesMask;
    }
    return rtrn;
}

/***====================================================================***/

#define	UNMATCHABLE(c)	(((c)=='(')||((c)==')')||((c)=='/'))

Bool
XkbNameMatchesPattern(char *name,char *ptrn)
{
    while (ptrn[0]!='\0') {
	if (name[0]=='\0') {
	    if (ptrn[0]=='*') {
		ptrn++;
		continue;
	    }
	    return FALSE;
	}
	if (ptrn[0]=='?') {
	    if (UNMATCHABLE(name[0]))
		return FALSE;
	}
	else if (ptrn[0]=='*') {
	    if ((!UNMATCHABLE(name[0]))&&XkbNameMatchesPattern(name+1,ptrn))
		return TRUE;
	    return XkbNameMatchesPattern(name,ptrn+1);
	}
	else if (ptrn[0]!=name[0])
	    return FALSE;
	name++;
	ptrn++;
    }
    /* if we get here, the pattern is exhausted (-:just like me:-) */
    return name[0]=='\0';
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif


#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <xkbsrv.h>
#include "xkbgeom.h"

/***====================================================================***/

static void 
_XkbFreeGeomLeafElems(	Bool			freeAll,
			int			first,
			int 			count,
			unsigned short *	num_inout,
			unsigned short *	sz_inout,
			char **			elems,
			unsigned int		elem_sz)
{
    if ((freeAll)||(*elems==NULL)) {
	*num_inout= *sz_inout= 0;
	free(*elems);
	*elems = NULL;
	return;
    }

    if ((first>=(*num_inout))||(first<0)||(count<1))
	return;

    if (first+count>=(*num_inout)) { 
	/* truncating the array is easy */
	(*num_inout)= first;
    }
    else {
	char *	ptr;
	int 	extra;
	ptr= *elems;
	extra= ((*num_inout)-(first+count))*elem_sz;
	if (extra>0)
	    memmove(&ptr[first*elem_sz],&ptr[(first+count)*elem_sz],extra);
	(*num_inout)-= count;
    }
    return;
}

typedef void (*ContentsClearFunc)(
		char *		/* priv */
);

static void 
_XkbFreeGeomNonLeafElems(	Bool			freeAll,
				int			first,
				int 			count,
				unsigned short *	num_inout,
				unsigned short *	sz_inout,
				char **			elems,
				unsigned int		elem_sz,
				ContentsClearFunc	freeFunc)
{
register int i;
register char *ptr;

    if (freeAll) {
	first= 0;
	count= (*num_inout);
    }
    else if ((first>=(*num_inout))||(first<0)||(count<1))
	return;
    else if (first+count>(*num_inout))
	count= (*num_inout)-first;
    if (*elems==NULL)
	return;

    if (freeFunc) {
	ptr= *elems;
	ptr+= first*elem_sz;
	for (i=0;i<count;i++) {
	    (*freeFunc)(ptr);
	    ptr+= elem_sz;
	}
    }
    if (freeAll) {
	(*num_inout)= (*sz_inout)= 0;
	free(*elems);
	*elems = NULL;
    }
    else if (first+count>=(*num_inout))
	*num_inout= first;
    else {
	i= ((*num_inout)-(first+count))*elem_sz;
	ptr= *elems;
	memmove(&ptr[first*elem_sz],&ptr[(first+count)*elem_sz],i);
	(*num_inout)-= count;
    }
    return;
}

/***====================================================================***/

static void
_XkbClearProperty(char *prop_in)
{
XkbPropertyPtr	prop= (XkbPropertyPtr)prop_in;

    free(prop->name);
    prop->name = NULL;
    free(prop->value);
    prop->value = NULL;
    return;
}

void
XkbFreeGeomProperties(	XkbGeometryPtr	geom,
			int		first,
			int		count,
			Bool		freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_properties,&geom->sz_properties,
				(char **)&geom->properties,
				sizeof(XkbPropertyRec),_XkbClearProperty);
    return;
}

/***====================================================================***/

void
XkbFreeGeomKeyAliases(	XkbGeometryPtr	geom,
			int		first,
			int		count,
			Bool		freeAll)
{	
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&geom->num_key_aliases,&geom->sz_key_aliases,
				(char **)&geom->key_aliases,
				sizeof(XkbKeyAliasRec));
    return;
}

/***====================================================================***/

static void
_XkbClearColor(char *color_in)
{
XkbColorPtr	color= (XkbColorPtr)color_in;

    free(color->spec);
    return;
}

void
XkbFreeGeomColors(XkbGeometryPtr geom,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_colors,&geom->sz_colors,
				(char **)&geom->colors,
				sizeof(XkbColorRec),_XkbClearColor);
    return;
}

/***====================================================================***/

void
XkbFreeGeomPoints(XkbOutlinePtr outline,int first,int count,Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&outline->num_points,&outline->sz_points,
				(char **)&outline->points,
				sizeof(XkbPointRec));
    return;
}

/***====================================================================***/

static void
_XkbClearOutline(char *outline_in)
{
XkbOutlinePtr	outline= (XkbOutlinePtr)outline_in;

    if (outline->points!=NULL)
	XkbFreeGeomPoints(outline,0,outline->num_points,TRUE);
    return;
}

void
XkbFreeGeomOutlines(XkbShapePtr	shape,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&shape->num_outlines,&shape->sz_outlines,
				(char **)&shape->outlines,
				sizeof(XkbOutlineRec),_XkbClearOutline);
	
    return;
}

/***====================================================================***/

static void
_XkbClearShape(char *shape_in)
{
XkbShapePtr	shape= (XkbShapePtr)shape_in;

    if (shape->outlines)
	XkbFreeGeomOutlines(shape,0,shape->num_outlines,TRUE);
    return;
}

void
XkbFreeGeomShapes(XkbGeometryPtr geom,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_shapes,&geom->sz_shapes,
				(char **)&geom->shapes,
				sizeof(XkbShapeRec),_XkbClearShape);
    return;
}

/***====================================================================***/

void 
XkbFreeGeomOverlayKeys(XkbOverlayRowPtr row,int first,int count,Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&row->num_keys,&row->sz_keys,
				(char **)&row->keys,
				sizeof(XkbOverlayKeyRec));
    return;
}

/***====================================================================***/

static void
_XkbClearOverlayRow(char *row_in)
{
XkbOverlayRowPtr	row= (XkbOverlayRowPtr)row_in;

    if (row->keys!=NULL)
	XkbFreeGeomOverlayKeys(row,0,row->num_keys,TRUE);
    return;
}

void
XkbFreeGeomOverlayRows(XkbOverlayPtr overlay,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&overlay->num_rows,&overlay->sz_rows,
				(char **)&overlay->rows,
				sizeof(XkbOverlayRowRec),_XkbClearOverlayRow);
    return;
}

/***====================================================================***/

static void
_XkbClearOverlay(char *overlay_in)
{
XkbOverlayPtr	overlay= (XkbOverlayPtr)overlay_in;

    if (overlay->rows!=NULL)
	XkbFreeGeomOverlayRows(overlay,0,overlay->num_rows,TRUE);
    return;
}

void
XkbFreeGeomOverlays(XkbSectionPtr section,int first,int	count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&section->num_overlays,&section->sz_overlays,
				(char **)&section->overlays,
				sizeof(XkbOverlayRec),_XkbClearOverlay);
    return;
}

/***====================================================================***/

void
XkbFreeGeomKeys(XkbRowPtr row,int first,int count,Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&row->num_keys,&row->sz_keys,
				(char **)&row->keys,
				sizeof(XkbKeyRec));
    return;
}

/***====================================================================***/

static void
_XkbClearRow(char *row_in)
{
XkbRowPtr	row= (XkbRowPtr)row_in;

    if (row->keys!=NULL)
	XkbFreeGeomKeys(row,0,row->num_keys,TRUE);
    return;
}

void
XkbFreeGeomRows(XkbSectionPtr section,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&section->num_rows,&section->sz_rows,
				(char **)&section->rows,
				sizeof(XkbRowRec),_XkbClearRow);
}

/***====================================================================***/

static void
_XkbClearSection(char *section_in)
{
XkbSectionPtr	section= (XkbSectionPtr)section_in;

    if (section->rows!=NULL)
	XkbFreeGeomRows(section,0,section->num_rows,TRUE);
    if (section->doodads!=NULL) {
	XkbFreeGeomDoodads(section->doodads,section->num_doodads,TRUE);
	section->doodads= NULL;
    }
    return;
}

void
XkbFreeGeomSections(XkbGeometryPtr geom,int first,int count,Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_sections,&geom->sz_sections,
				(char **)&geom->sections,
				sizeof(XkbSectionRec),_XkbClearSection);
    return;
}

/***====================================================================***/

static void
_XkbClearDoodad(char *doodad_in)
{
XkbDoodadPtr	doodad= (XkbDoodadPtr)doodad_in;

    switch (doodad->any.type) {
   	case XkbTextDoodad: 
	    {
		free(doodad->text.text);
		doodad->text.text = NULL;
		free(doodad->text.font);
		doodad->text.font = NULL;
	    }
	    break;
   	case XkbLogoDoodad: 
	    {
		free(doodad->logo.logo_name);
		doodad->logo.logo_name = NULL;
	    }
	    break;
    }
    return;
}

void
XkbFreeGeomDoodads(XkbDoodadPtr doodads,int nDoodads,Bool freeAll)
{
register int 		i;
register XkbDoodadPtr	doodad;

    if (doodads) {
	for (i=0,doodad= doodads;i<nDoodads;i++,doodad++) {
	    _XkbClearDoodad((char *)doodad);
	}
	if (freeAll)
	    free(doodads);
    }
    return;
}

void
XkbFreeGeometry(XkbGeometryPtr geom,unsigned which,Bool freeMap)
{
    if (geom==NULL)
	return;
    if (freeMap)
	which= XkbGeomAllMask;
    if ((which&XkbGeomPropertiesMask)&&(geom->properties!=NULL))
	XkbFreeGeomProperties(geom,0,geom->num_properties,TRUE);
    if ((which&XkbGeomColorsMask)&&(geom->colors!=NULL))
	XkbFreeGeomColors(geom,0,geom->num_colors,TRUE);
    if ((which&XkbGeomShapesMask)&&(geom->shapes!=NULL))
	XkbFreeGeomShapes(geom,0,geom->num_shapes,TRUE);
    if ((which&XkbGeomSectionsMask)&&(geom->sections!=NULL))
	XkbFreeGeomSections(geom,0,geom->num_sections,TRUE);
    if ((which&XkbGeomDoodadsMask)&&(geom->doodads!= NULL)) {
	XkbFreeGeomDoodads(geom->doodads,geom->num_doodads,TRUE);
	geom->doodads= NULL;
	geom->num_doodads= geom->sz_doodads= 0;
    }
    if ((which&XkbGeomKeyAliasesMask)&&(geom->key_aliases!=NULL))
	XkbFreeGeomKeyAliases(geom,0,geom->num_key_aliases,TRUE);
    if (freeMap) {
	free(geom->label_font);
	geom->label_font = NULL;
	free(geom);
    }
    return;
}

/***====================================================================***/

/**
 * Resize and clear an XKB geometry item array. The array size may
 * grow or shrink unlike in _XkbGeomAlloc.
 *
 * @param buffer[in,out]  buffer to reallocate and clear
 * @param szItems[in]     currently allocated item count for "buffer"
 * @param nrItems[in]     required item count for "buffer"
 * @param itemSize[in]    size of a single item in "buffer"
 * @param clearance[in]   items to clear after reallocation
 *
 * @see _XkbGeomAlloc
 *
 * @return TRUE if reallocation succeeded. Otherwise FALSE is returned
 *         and contents of "buffer" aren't touched.
 */
Bool
XkbGeomRealloc(void **buffer, int szItems, int nrItems,
               int itemSize, XkbGeomClearance clearance)
{
    void *items;
    int clearBegin;
    /* Check validity of arguments. */
    if (!buffer)
        return FALSE;
    items = *buffer;
    if (!((items && (szItems > 0)) || (!items && !szItems)))
        return FALSE;
    /* Check if there is need to resize. */
    if (nrItems != szItems)
        if (!(items = realloc(items, nrItems * itemSize)))
            return FALSE;
    /* Clear specified items to zero. */
    switch (clearance)
    {
    case XKB_GEOM_CLEAR_EXCESS:
        clearBegin = szItems;
        break;
    case XKB_GEOM_CLEAR_ALL:
        clearBegin = 0;
        break;
    case XKB_GEOM_CLEAR_NONE:
    default:
        clearBegin = nrItems;
        break;
    }
    if (items && (clearBegin < nrItems))
        memset((char *)items + (clearBegin * itemSize), 0, (nrItems - clearBegin) * itemSize);
    *buffer = items;
    return TRUE;
}

static Status
_XkbGeomAlloc(	void **		old,
		unsigned short *	num,
		unsigned short *	total,
		int			num_new,
		size_t			sz_elem)
{
    if (num_new<1)
	return Success;
    if ((*old)==NULL)
	*num= *total= 0;

    if ((*num)+num_new<=(*total))
	return Success;

    *total= (*num)+num_new;

    if (!XkbGeomRealloc(old, *num, *total, sz_elem, XKB_GEOM_CLEAR_EXCESS))
    {
	free(*old);
	(*old)= NULL;
	*total= *num= 0;
	return BadAlloc;
    }

    return Success;
}

#define	_XkbAllocProps(g,n) _XkbGeomAlloc((void *)&(g)->properties,\
				&(g)->num_properties,&(g)->sz_properties,\
				(n),sizeof(XkbPropertyRec))
#define	_XkbAllocColors(g,n) _XkbGeomAlloc((void *)&(g)->colors,\
				&(g)->num_colors,&(g)->sz_colors,\
				(n),sizeof(XkbColorRec))
#define	_XkbAllocShapes(g,n) _XkbGeomAlloc((void *)&(g)->shapes,\
				&(g)->num_shapes,&(g)->sz_shapes,\
				(n),sizeof(XkbShapeRec))
#define	_XkbAllocSections(g,n) _XkbGeomAlloc((void *)&(g)->sections,\
				&(g)->num_sections,&(g)->sz_sections,\
				(n),sizeof(XkbSectionRec))
#define	_XkbAllocDoodads(g,n) _XkbGeomAlloc((void *)&(g)->doodads,\
				&(g)->num_doodads,&(g)->sz_doodads,\
				(n),sizeof(XkbDoodadRec))
#define	_XkbAllocKeyAliases(g,n) _XkbGeomAlloc((void *)&(g)->key_aliases,\
				&(g)->num_key_aliases,&(g)->sz_key_aliases,\
				(n),sizeof(XkbKeyAliasRec))

#define	_XkbAllocOutlines(s,n) _XkbGeomAlloc((void *)&(s)->outlines,\
				&(s)->num_outlines,&(s)->sz_outlines,\
				(n),sizeof(XkbOutlineRec))
#define	_XkbAllocRows(s,n) _XkbGeomAlloc((void *)&(s)->rows,\
				&(s)->num_rows,&(s)->sz_rows,\
				(n),sizeof(XkbRowRec))
#define	_XkbAllocPoints(o,n) _XkbGeomAlloc((void *)&(o)->points,\
				&(o)->num_points,&(o)->sz_points,\
				(n),sizeof(XkbPointRec))
#define	_XkbAllocKeys(r,n) _XkbGeomAlloc((void *)&(r)->keys,\
				&(r)->num_keys,&(r)->sz_keys,\
				(n),sizeof(XkbKeyRec))
#define	_XkbAllocOverlays(s,n) _XkbGeomAlloc((void *)&(s)->overlays,\
				&(s)->num_overlays,&(s)->sz_overlays,\
				(n),sizeof(XkbOverlayRec))
#define	_XkbAllocOverlayRows(o,n) _XkbGeomAlloc((void *)&(o)->rows,\
				&(o)->num_rows,&(o)->sz_rows,\
				(n),sizeof(XkbOverlayRowRec))
#define	_XkbAllocOverlayKeys(r,n) _XkbGeomAlloc((void *)&(r)->keys,\
				&(r)->num_keys,&(r)->sz_keys,\
				(n),sizeof(XkbOverlayKeyRec))
    
Status
XkbAllocGeomProps(XkbGeometryPtr geom,int nProps)
{
    return _XkbAllocProps(geom,nProps);
}

Status
XkbAllocGeomColors(XkbGeometryPtr geom,int nColors)
{
    return _XkbAllocColors(geom,nColors);
}

Status
XkbAllocGeomKeyAliases(XkbGeometryPtr geom,int nKeyAliases)
{
    return _XkbAllocKeyAliases(geom,nKeyAliases);
}

Status
XkbAllocGeomShapes(XkbGeometryPtr geom,int nShapes)
{
    return _XkbAllocShapes(geom,nShapes);
}

Status
XkbAllocGeomSections(XkbGeometryPtr geom,int nSections)
{
    return _XkbAllocSections(geom,nSections);
}

Status
XkbAllocGeomOverlays(XkbSectionPtr section,int nOverlays)
{
    return _XkbAllocOverlays(section,nOverlays);
}

Status
XkbAllocGeomOverlayRows(XkbOverlayPtr overlay,int nRows)
{
    return _XkbAllocOverlayRows(overlay,nRows);
}

Status
XkbAllocGeomOverlayKeys(XkbOverlayRowPtr row,int nKeys)
{
    return _XkbAllocOverlayKeys(row,nKeys);
}

Status
XkbAllocGeomDoodads(XkbGeometryPtr geom,int nDoodads)
{
    return _XkbAllocDoodads(geom,nDoodads);
}

Status
XkbAllocGeomSectionDoodads(XkbSectionPtr section,int nDoodads)
{
    return _XkbAllocDoodads(section,nDoodads);
}

Status
XkbAllocGeomOutlines(XkbShapePtr shape,int nOL)
{
    return _XkbAllocOutlines(shape,nOL);
}

Status
XkbAllocGeomRows(XkbSectionPtr section,int nRows)
{
    return _XkbAllocRows(section,nRows);
}

Status
XkbAllocGeomPoints(XkbOutlinePtr ol,int nPts)
{
    return _XkbAllocPoints(ol,nPts);
}

Status
XkbAllocGeomKeys(XkbRowPtr row,int nKeys)
{
    return _XkbAllocKeys(row,nKeys);
}

Status
XkbAllocGeometry(XkbDescPtr xkb,XkbGeometrySizesPtr sizes)
{
XkbGeometryPtr	geom;
Status		rtrn;

    if (xkb->geom==NULL) {
	xkb->geom= calloc(1, sizeof(XkbGeometryRec));
	if (!xkb->geom)
	    return BadAlloc;
    }
    geom= xkb->geom;
    if ((sizes->which&XkbGeomPropertiesMask)&&
	((rtrn=_XkbAllocProps(geom,sizes->num_properties))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomColorsMask)&&
	((rtrn=_XkbAllocColors(geom,sizes->num_colors))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomShapesMask)&&
	((rtrn=_XkbAllocShapes(geom,sizes->num_shapes))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomSectionsMask)&&
	((rtrn=_XkbAllocSections(geom,sizes->num_sections))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomDoodadsMask)&&
	((rtrn=_XkbAllocDoodads(geom,sizes->num_doodads))!=Success)) {
	goto BAIL;
    }
    if ((sizes->which&XkbGeomKeyAliasesMask)&&
	((rtrn=_XkbAllocKeyAliases(geom,sizes->num_key_aliases))!=Success)) {
	goto BAIL;
    }
    return Success;
BAIL:
    XkbFreeGeometry(geom,XkbGeomAllMask,TRUE);
    xkb->geom= NULL;
    return rtrn;
}

/***====================================================================***/

XkbPropertyPtr
XkbAddGeomProperty(XkbGeometryPtr geom,char *name,char *value)
{
register int i;
register XkbPropertyPtr prop;

    if ((!geom)||(!name)||(!value))
	return NULL;
    for (i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	if ((prop->name)&&(strcmp(name,prop->name)==0)) {
	    free(prop->value);
	    prop->value= strdup(value);
	    return prop;
	}    
    }
    if ((geom->num_properties>=geom->sz_properties)&&
					(_XkbAllocProps(geom,1)!=Success)) {
	return NULL;
    }
    prop= &geom->properties[geom->num_properties];
    prop->name= strdup(name);
    if (!prop->name)
	return NULL;
    prop->value= strdup(value);
    if (!prop->value) {
	free(prop->name);
	prop->name= NULL;
	return NULL;
    }
    geom->num_properties++;
    return prop;
}

XkbKeyAliasPtr
XkbAddGeomKeyAlias(XkbGeometryPtr geom,char *aliasStr,char *realStr)
{
register int i;
register XkbKeyAliasPtr alias;

    if ((!geom)||(!aliasStr)||(!realStr)||(!aliasStr[0])||(!realStr[0]))
	return NULL;
    for (i=0,alias=geom->key_aliases;i<geom->num_key_aliases;i++,alias++) {
	if (strncmp(alias->alias,aliasStr,XkbKeyNameLength)==0) {
	    memset(alias->real, 0, XkbKeyNameLength);
	    strncpy(alias->real,realStr,XkbKeyNameLength);
	    return alias;
	}
    }
    if ((geom->num_key_aliases>=geom->sz_key_aliases)&&
				(_XkbAllocKeyAliases(geom,1)!=Success)) {
	return NULL;
    }
    alias= &geom->key_aliases[geom->num_key_aliases];
    memset(alias, 0, sizeof(XkbKeyAliasRec));
    strncpy(alias->alias,aliasStr,XkbKeyNameLength);
    strncpy(alias->real,realStr,XkbKeyNameLength);
    geom->num_key_aliases++;
    return alias;
}

XkbColorPtr
XkbAddGeomColor(XkbGeometryPtr geom,char *spec,unsigned int pixel)
{
register int i;
register XkbColorPtr color;

    if ((!geom)||(!spec))
	return NULL;
    for (i=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	if ((color->spec)&&(strcmp(color->spec,spec)==0)) {
	    color->pixel= pixel;
	    return color;
	}
    }
    if ((geom->num_colors>=geom->sz_colors)&&
					(_XkbAllocColors(geom,1)!=Success)) {
	return NULL;
    }
    color= &geom->colors[geom->num_colors];
    color->pixel= pixel;
    color->spec= strdup(spec);
    if (!color->spec)
	return NULL;
    geom->num_colors++;
    return color;
}

XkbOutlinePtr
XkbAddGeomOutline(XkbShapePtr shape,int sz_points)
{
XkbOutlinePtr	outline;

    if ((!shape)||(sz_points<0))
	return NULL;
    if ((shape->num_outlines>=shape->sz_outlines)&&
					(_XkbAllocOutlines(shape,1)!=Success)) {
	return NULL;
    }
    outline= &shape->outlines[shape->num_outlines];
    memset(outline, 0, sizeof(XkbOutlineRec));
    if ((sz_points>0)&&(_XkbAllocPoints(outline,sz_points)!=Success))
	return NULL;
    shape->num_outlines++;
    return outline;
}

XkbShapePtr
XkbAddGeomShape(XkbGeometryPtr geom,Atom name,int sz_outlines)
{
XkbShapePtr	shape;
register int	i;

    if ((!geom)||(!name)||(sz_outlines<0))
	return NULL;
    if (geom->num_shapes>0) {
	for (shape=geom->shapes,i=0;i<geom->num_shapes;i++,shape++) {
	    if (name==shape->name)
		return shape;
	}
    }
    if ((geom->num_shapes>=geom->sz_shapes)&&
					(_XkbAllocShapes(geom,1)!=Success))
	return NULL;
    shape= &geom->shapes[geom->num_shapes];
    memset(shape, 0, sizeof(XkbShapeRec));
    if ((sz_outlines>0)&&(_XkbAllocOutlines(shape,sz_outlines)!=Success))
	return NULL;
    shape->name= name;
    shape->primary= shape->approx= NULL;
    geom->num_shapes++;
    return shape;
}

XkbKeyPtr
XkbAddGeomKey(XkbRowPtr row)
{
XkbKeyPtr	key;
    if (!row)
	return NULL;
    if ((row->num_keys>=row->sz_keys)&&(_XkbAllocKeys(row,1)!=Success))
	return NULL;
    key= &row->keys[row->num_keys++];
    memset(key, 0, sizeof(XkbKeyRec));
    return key;
}

XkbRowPtr
XkbAddGeomRow(XkbSectionPtr section,int sz_keys)
{
XkbRowPtr	row;

    if ((!section)||(sz_keys<0))
	return NULL;
    if ((section->num_rows>=section->sz_rows)&&
    					(_XkbAllocRows(section,1)!=Success))
	return NULL;
    row= &section->rows[section->num_rows];
    memset(row, 0, sizeof(XkbRowRec));
    if ((sz_keys>0)&&(_XkbAllocKeys(row,sz_keys)!=Success))
	return NULL;
    section->num_rows++;
    return row;
}

XkbSectionPtr
XkbAddGeomSection(	XkbGeometryPtr	geom,
			Atom		name,
			int		sz_rows,
			int		sz_doodads,
			int		sz_over)
{
register int	i;
XkbSectionPtr	section;

    if ((!geom)||(name==None)||(sz_rows<0))
	return NULL;
    for (i=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	if (section->name!=name)
	    continue;
	if (((sz_rows>0)&&(_XkbAllocRows(section,sz_rows)!=Success))||
	    ((sz_doodads>0)&&(_XkbAllocDoodads(section,sz_doodads)!=Success))||
	    ((sz_over>0)&&(_XkbAllocOverlays(section,sz_over)!=Success)))
	    return NULL;
	return section;
    }
    if ((geom->num_sections>=geom->sz_sections)&&
					(_XkbAllocSections(geom,1)!=Success))
	return NULL;
    section= &geom->sections[geom->num_sections];
    if ((sz_rows>0)&&(_XkbAllocRows(section,sz_rows)!=Success))
	return NULL;
    if ((sz_doodads>0)&&(_XkbAllocDoodads(section,sz_doodads)!=Success)) {
	if (section->rows) {
	    free(section->rows);
	    section->rows= NULL;
	    section->sz_rows= section->num_rows= 0;
	}
	return NULL;
    }
    section->name= name;
    geom->num_sections++;
    return section;
}

XkbDoodadPtr
XkbAddGeomDoodad(XkbGeometryPtr geom,XkbSectionPtr section,Atom name)
{
XkbDoodadPtr	old,doodad;
register int	i,nDoodads;

    if ((!geom)||(name==None))
	return NULL;
    if ((section!=NULL)&&(section->num_doodads>0)) {
	old= section->doodads;
	nDoodads= section->num_doodads;
    }
    else {
	old= geom->doodads;
	nDoodads= geom->num_doodads;
    }
    for (i=0,doodad=old;i<nDoodads;i++,doodad++) {
	if (doodad->any.name==name)
	    return doodad;
    }
    if (section) {
	if ((section->num_doodads>=geom->sz_doodads)&&
	    (_XkbAllocDoodads(section,1)!=Success)) {
	    return NULL;
	}
	doodad= &section->doodads[section->num_doodads++];
    }
    else {
	if ((geom->num_doodads>=geom->sz_doodads)&&
					(_XkbAllocDoodads(geom,1)!=Success))
	    return NULL;
	doodad= &geom->doodads[geom->num_doodads++];
    }
    memset(doodad, 0, sizeof(XkbDoodadRec));
    doodad->any.name= name;
    return doodad;
}

XkbOverlayKeyPtr
XkbAddGeomOverlayKey(	XkbOverlayPtr		overlay,
			XkbOverlayRowPtr 	row,
			char *			over,
			char *			under)
{
register int	i;
XkbOverlayKeyPtr key;
XkbSectionPtr	section;
XkbRowPtr	row_under;
Bool		found;

    if ((!overlay)||(!row)||(!over)||(!under))
	return NULL;
    section= overlay->section_under;
    if (row->row_under>=section->num_rows)
	return NULL;
    row_under= &section->rows[row->row_under];
    for (i=0,found=FALSE;i<row_under->num_keys;i++) {
	if (strncmp(under,row_under->keys[i].name.name,XkbKeyNameLength)==0) {
	    found= TRUE;
	    break;
	}
    }
    if (!found)
   	return NULL; 
    if ((row->num_keys>=row->sz_keys)&&(_XkbAllocOverlayKeys(row,1)!=Success))
	return NULL;
    key= &row->keys[row->num_keys];
    strncpy(key->under.name,under,XkbKeyNameLength);
    strncpy(key->over.name,over,XkbKeyNameLength);
    row->num_keys++;
    return key;
}

XkbOverlayRowPtr
XkbAddGeomOverlayRow(XkbOverlayPtr overlay,int row_under,int sz_keys)
{
register int		i;
XkbOverlayRowPtr	row;

    if ((!overlay)||(sz_keys<0))
	return NULL;
    if (row_under>=overlay->section_under->num_rows)
	return NULL;
    for (i=0;i<overlay->num_rows;i++) {
	if (overlay->rows[i].row_under==row_under) {
	    row= &overlay->rows[i];
	    if ((row->sz_keys<sz_keys)&&
				(_XkbAllocOverlayKeys(row,sz_keys)!=Success)) {
		return NULL;
	    }
	    return &overlay->rows[i];
	}
    }
    if ((overlay->num_rows>=overlay->sz_rows)&&
				(_XkbAllocOverlayRows(overlay,1)!=Success))
	return NULL;
    row= &overlay->rows[overlay->num_rows];
    memset(row, 0, sizeof(XkbOverlayRowRec));
    if ((sz_keys>0)&&(_XkbAllocOverlayKeys(row,sz_keys)!=Success))
	return NULL;
    row->row_under= row_under;
    overlay->num_rows++;
    return row;
}

XkbOverlayPtr
XkbAddGeomOverlay(XkbSectionPtr section,Atom name,int sz_rows)
{
register int	i;
XkbOverlayPtr	overlay;

    if ((!section)||(name==None)||(sz_rows==0))
	return NULL;

    for (i=0,overlay=section->overlays;i<section->num_overlays;i++,overlay++) {
	if (overlay->name==name) {
	    if ((sz_rows>0)&&(_XkbAllocOverlayRows(overlay,sz_rows)!=Success))
		return NULL;
	    return overlay;
	}
    }
    if ((section->num_overlays>=section->sz_overlays)&&
				(_XkbAllocOverlays(section,1)!=Success))
	return NULL;
    overlay= &section->overlays[section->num_overlays];
    if ((sz_rows>0)&&(_XkbAllocOverlayRows(overlay,sz_rows)!=Success))
	return NULL;
    overlay->name= name;
    overlay->section_under= section;
    section->num_overlays++;
    return overlay;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifndef _XKBGEOM_H_
#define	_XKBGEOM_H_

#include "xkbstr.h"

#define XkbAddGeomKeyAlias 		SrvXkbAddGeomKeyAlias
#define XkbAddGeomColor 		SrvXkbAddGeomColor
#define XkbAddGeomDoodad		SrvXkbAddGeomDoodad
#define XkbAddGeomKey			SrvXkbAddGeomKey
#define XkbAddGeomOutline		SrvXkbAddGeomOutline
#define XkbAddGeomOverlay		SrvXkbAddGeomOverlay
#define XkbAddGeomOverlayRow		SrvXkbAddGeomOverlayRow
#define	XkbAddGeomOverlayKey		SrvXkbAddGeomOverlayKey
#define XkbAddGeomProperty		SrvXkbAddGeomProperty
#define XkbAddGeomRow			SrvXkbAddGeomRow
#define XkbAddGeomSection		SrvXkbAddGeomSection
#define XkbAddGeomShape			SrvXkbAddGeomShape
#define XkbAllocGeomKeyAliases		SrvXkbAllocGeomKeyAliases
#define XkbAllocGeomColors		SrvXkbAllocGeomColors
#define XkbAllocGeomDoodads		SrvXkbAllocGeomDoodads
#define XkbAllocGeomKeys		SrvXkbAllocGeomKeys
#define XkbAllocGeomOutlines		SrvXkbAllocGeomOutlines
#define XkbAllocGeomPoints		SrvXkbAllocGeomPoints
#define XkbAllocGeomProps		SrvXkbAllocGeomProps
#define XkbAllocGeomRows		SrvXkbAllocGeomRows
#define XkbAllocGeomSectionDoodads	SrvXkbAllocGeomSectionDoodads
#define XkbAllocGeomSections		SrvXkbAllocGeomSections
#define	XkbAllocGeomOverlays		SrvXkbAllocGeomOverlays
#define	XkbAllocGeomOverlayRows		SrvXkbAllocGeomOverlayRows
#define	XkbAllocGeomOverlayKeys		SrvXkbAllocGeomOverlayKeys
#define XkbAllocGeomShapes		SrvXkbAllocGeomShapes
#define XkbAllocGeometry		SrvXkbAllocGeometry
#define XkbFreeGeomKeyAliases		SrvXkbFreeGeomKeyAliases
#define XkbFreeGeomColors		SrvXkbFreeGeomColors
#define XkbFreeGeomDoodads		SrvXkbFreeGeomDoodads
#define XkbFreeGeomProperties		SrvXkbFreeGeomProperties
#define	XkbFreeGeomOverlayKeys		SrvXkbFreeGeomOverlayKeys
#define	XkbFreeGeomOverlayRows		SrvXkbFreeGeomOverlayRows
#define	XkbFreeGeomOverlays		SrvXkbFreeGeomOverlays
#define	XkbFreeGeomKeys			SrvXkbFreeGeomKeys
#define	XkbFreeGeomRows			SrvXkbFreeGeomRows
#define XkbFreeGeomSections		SrvXkbFreeGeomSections
#define	XkbFreeGeomPoints		SrvXkbFreeGeomPoints
#define	XkbFreeGeomOutlines		SrvXkbFreeGeomOutlines
#define XkbFreeGeomShapes		SrvXkbFreeGeomShapes
#define XkbFreeGeometry			SrvXkbFreeGeometry

typedef	struct _XkbProperty {
	char	*name;
	char	*value;
} XkbPropertyRec,*XkbPropertyPtr;

typedef struct _XkbColor {
	unsigned int 	pixel;
	char *		spec;
} XkbColorRec,*XkbColorPtr;

typedef	struct _XkbPoint {
	short	x;
	short	y;
} XkbPointRec, *XkbPointPtr;

typedef struct	_XkbBounds {
	short	x1,y1;
	short	x2,y2;
} XkbBoundsRec, *XkbBoundsPtr;
#define	XkbBoundsWidth(b)	(((b)->x2)-((b)->x1))
#define	XkbBoundsHeight(b)	(((b)->y2)-((b)->y1))

typedef struct _XkbOutline {
	unsigned short	num_points;
	unsigned short	sz_points;
	unsigned short	corner_radius;
	XkbPointPtr	points;
} XkbOutlineRec, *XkbOutlinePtr;

typedef struct _XkbShape {
	Atom	 	 name;
	unsigned short	 num_outlines;
	unsigned short	 sz_outlines;
	XkbOutlinePtr	 outlines;
	XkbOutlinePtr	 approx;
	XkbOutlinePtr	 primary;
	XkbBoundsRec	 bounds;
} XkbShapeRec, *XkbShapePtr;
#define	XkbOutlineIndex(s,o)	((int)((o)-&(s)->outlines[0]))

typedef struct _XkbShapeDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short		 top;
	short		 left;
	short	 	 angle;
	unsigned short	 color_ndx;
	unsigned short	 shape_ndx;
} XkbShapeDoodadRec, *XkbShapeDoodadPtr;
#define	XkbShapeDoodadColor(g,d)	(&(g)->colors[(d)->color_ndx])
#define	XkbShapeDoodadShape(g,d)	(&(g)->shapes[(d)->shape_ndx])
#define	XkbSetShapeDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
#define	XkbSetShapeDoodadShape(g,d,s)	((d)->shape_ndx= (s)-&(g)->shapes[0])

typedef struct _XkbTextDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short	 	 top;
	short	 	 left;
	short	 	 angle;
	short	 	 width;
	short		 height;
	unsigned short	 color_ndx;
	char *		 text;
	char *		 font;
} XkbTextDoodadRec, *XkbTextDoodadPtr;
#define	XkbTextDoodadColor(g,d)	(&(g)->colors[(d)->color_ndx])
#define	XkbSetTextDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])

typedef struct _XkbIndicatorDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short	 	 top;
	short	 	 left;
	short		 angle;
	unsigned short	 shape_ndx;
	unsigned short	 on_color_ndx;
	unsigned short	 off_color_ndx;
} XkbIndicatorDoodadRec, *XkbIndicatorDoodadPtr;
#define	XkbIndicatorDoodadShape(g,d)	(&(g)->shapes[(d)->shape_ndx])
#define	XkbIndicatorDoodadOnColor(g,d)	(&(g)->colors[(d)->on_color_ndx])
#define	XkbIndicatorDoodadOffColor(g,d)	(&(g)->colors[(d)->off_color_ndx])
#define	XkbSetIndicatorDoodadOnColor(g,d,c) \
				((d)->on_color_ndx= (c)-&(g)->colors[0])
#define	XkbSetIndicatorDoodadOffColor(g,d,c) \
				((d)->off_color_ndx= (c)-&(g)->colors[0])
#define	XkbSetIndicatorDoodadShape(g,d,s) \
				((d)->shape_ndx= (s)-&(g)->shapes[0])

typedef struct _XkbLogoDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short		 top;
	short		 left;
	short	 	 angle;
	unsigned short	 color_ndx;
	unsigned short	 shape_ndx;
	char *		 logo_name;
} XkbLogoDoodadRec, *XkbLogoDoodadPtr;
#define	XkbLogoDoodadColor(g,d)		(&(g)->colors[(d)->color_ndx])
#define	XkbLogoDoodadShape(g,d)		(&(g)->shapes[(d)->shape_ndx])
#define	XkbSetLogoDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
#define	XkbSetLogoDoodadShape(g,d,s)	((d)->shape_ndx= (s)-&(g)->shapes[0])

typedef struct _XkbAnyDoodad {
	Atom		 name;
	unsigned char	 type;
	unsigned char	 priority;
	short	 	 top;
	short	 	 left;
	short		 angle;
} XkbAnyDoodadRec, *XkbAnyDoodadPtr;

typedef union _XkbDoodad {
	XkbAnyDoodadRec		any;
	XkbShapeDoodadRec	shape;
	XkbTextDoodadRec	text;
	XkbIndicatorDoodadRec	indicator;
	XkbLogoDoodadRec	logo;
} XkbDoodadRec, *XkbDoodadPtr;

#define	XkbUnknownDoodad	0
#define	XkbOutlineDoodad	1
#define	XkbSolidDoodad		2
#define	XkbTextDoodad		3
#define	XkbIndicatorDoodad	4
#define	XkbLogoDoodad		5

typedef struct _XkbKey {
	XkbKeyNameRec	 name;
	short		 gap;
	unsigned char	 shape_ndx;
	unsigned char	 color_ndx;
} XkbKeyRec, *XkbKeyPtr;
#define	XkbKeyShape(g,k)	(&(g)->shapes[(k)->shape_ndx])
#define	XkbKeyColor(g,k)	(&(g)->colors[(k)->color_ndx])
#define	XkbSetKeyShape(g,k,s)	((k)->shape_ndx= (s)-&(g)->shapes[0])
#define	XkbSetKeyColor(g,k,c)	((k)->color_ndx= (c)-&(g)->colors[0])

typedef struct _XkbRow {
	short	 	top;
	short	 	left;
	unsigned short	num_keys;
	unsigned short	sz_keys;
	int		vertical;
	XkbKeyPtr	keys;
	XkbBoundsRec	bounds;
} XkbRowRec, *XkbRowPtr;

typedef struct _XkbSection {
	Atom		 name;
	unsigned char	 priority;
	short	 	 top;
	short	 	 left;
	unsigned short	 width;
	unsigned short	 height;
	short	 	 angle;
	unsigned short	 num_rows;
	unsigned short	 num_doodads;
	unsigned short	 num_overlays;
	unsigned short	 sz_rows;
	unsigned short	 sz_doodads;
	unsigned short	 sz_overlays;
	XkbRowPtr	 rows;
	XkbDoodadPtr	 doodads;
	XkbBoundsRec	 bounds;
	struct _XkbOverlay *overlays;
} XkbSectionRec, *XkbSectionPtr;

typedef	struct _XkbOverlayKey {
	XkbKeyNameRec	over;
	XkbKeyNameRec	under;
} XkbOverlayKeyRec,*XkbOverlayKeyPtr;

typedef struct _XkbOverlayRow {
	unsigned short		row_under;
	unsigned short		num_keys;
	unsigned short		sz_keys;
	XkbOverlayKeyPtr	keys;
} XkbOverlayRowRec,*XkbOverlayRowPtr;

typedef struct _XkbOverlay {
	Atom			name;
	XkbSectionPtr		section_under;
	unsigned short		num_rows;
	unsigned short		sz_rows;
	XkbOverlayRowPtr	rows;
	XkbBoundsPtr		bounds;
} XkbOverlayRec,*XkbOverlayPtr;

typedef struct _XkbGeometry {
	Atom		 name;
	unsigned short	 width_mm;
	unsigned short	 height_mm;
	char *		 label_font;
	XkbColorPtr	 label_color;
	XkbColorPtr	 base_color;
	unsigned short	 sz_properties;
	unsigned short	 sz_colors;
	unsigned short	 sz_shapes;
	unsigned short   sz_sections;
	unsigned short	 sz_doodads;
	unsigned short	 sz_key_aliases;
	unsigned short	 num_properties;
	unsigned short	 num_colors;
	unsigned short	 num_shapes;
	unsigned short	 num_sections;
	unsigned short	 num_doodads;
	unsigned short	 num_key_aliases;
	XkbPropertyPtr	 properties;
	XkbColorPtr	 colors;
	XkbShapePtr	 shapes;
	XkbSectionPtr	 sections;
	XkbDoodadPtr	 doodads;
	XkbKeyAliasPtr	 key_aliases;
} XkbGeometryRec;
#define	XkbGeomColorIndex(g,c)	((int)((c)-&(g)->colors[0]))

#define	XkbGeomPropertiesMask	(1<<0)
#define	XkbGeomColorsMask	(1<<1)
#define	XkbGeomShapesMask	(1<<2)
#define	XkbGeomSectionsMask	(1<<3)
#define	XkbGeomDoodadsMask	(1<<4)
#define	XkbGeomKeyAliasesMask	(1<<5)
#define	XkbGeomAllMask		(0x3f)

typedef struct _XkbGeometrySizes {
	unsigned int	which;
	unsigned short	num_properties;
	unsigned short	num_colors;
	unsigned short	num_shapes;
	unsigned short	num_sections;
	unsigned short	num_doodads;
	unsigned short	num_key_aliases;
} XkbGeometrySizesRec,*XkbGeometrySizesPtr;

/**
 * Specifies which items should be cleared in an XKB geometry array
 * when the array is reallocated.
 */
typedef enum
{
    XKB_GEOM_CLEAR_NONE,   /* Don't clear any items, just reallocate.   */
    XKB_GEOM_CLEAR_EXCESS, /* Clear new extra items after reallocation. */
    XKB_GEOM_CLEAR_ALL     /* Clear all items after reallocation.       */
} XkbGeomClearance;

extern	XkbPropertyPtr
XkbAddGeomProperty(
    XkbGeometryPtr	/* geom */,
    char *		/* name */,
    char *		/* value */
);

extern	XkbKeyAliasPtr
XkbAddGeomKeyAlias(
    XkbGeometryPtr	/* geom */,
    char *		/* alias */,
    char *		/* real */
);

extern	XkbColorPtr
XkbAddGeomColor(
    XkbGeometryPtr	/* geom */,
    char *		/* spec */,
    unsigned int	/* pixel */
);

extern	XkbOutlinePtr
XkbAddGeomOutline(
    XkbShapePtr		/* shape */,
    int			/* sz_points */
);

extern XkbShapePtr
XkbAddGeomShape(
    XkbGeometryPtr	/* geom */,
    Atom		/* name */,
    int			/* sz_outlines */
);

extern XkbKeyPtr
XkbAddGeomKey(
    XkbRowPtr		/* row */
);

extern XkbRowPtr
XkbAddGeomRow(
    XkbSectionPtr	/* section */,
    int			/* sz_keys */
);

extern XkbSectionPtr
XkbAddGeomSection(
    XkbGeometryPtr	/* geom */,
    Atom		/* name */,
    int			/* sz_rows */,
    int			/* sz_doodads */,
    int			/* sz_overlays */
);

extern XkbOverlayPtr
XkbAddGeomOverlay(
    XkbSectionPtr	/* section */,
    Atom		/* name */,
    int			/* sz_rows */
);

extern XkbOverlayRowPtr
XkbAddGeomOverlayRow(
    XkbOverlayPtr	/* overlay */,
    int			/* row_under */,
    int			/* sz_keys */
);

extern XkbOverlayKeyPtr
XkbAddGeomOverlayKey(
    XkbOverlayPtr	/* overlay */,
    XkbOverlayRowPtr	/* row */,
    char *		/* over */,
    char *		/* under */
);

extern XkbDoodadPtr
XkbAddGeomDoodad(
    XkbGeometryPtr	/* geom */,
    XkbSectionPtr	/* section */,
    Atom		/* name */
);


extern void
XkbFreeGeomKeyAliases(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomColors(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomDoodads(
    XkbDoodadPtr	/* doodads */,
    int			/* nDoodads */,
    Bool		/* freeAll */
);


extern void
XkbFreeGeomProperties(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomOverlayKeys(
    XkbOverlayRowPtr	/* row */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomOverlayRows(
    XkbOverlayPtr	/* overlay */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomOverlays(
    XkbSectionPtr	/* section */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomKeys(
    XkbRowPtr		/* row */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomRows(
    XkbSectionPtr	/* section */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomSections(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);


extern void
XkbFreeGeomPoints(
    XkbOutlinePtr	/* outline */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomOutlines(
    XkbShapePtr		/* shape */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeomShapes(
    XkbGeometryPtr	/* geom */,
    int			/* first */,
    int			/* count */,
    Bool		/* freeAll */
);

extern void
XkbFreeGeometry(
    XkbGeometryPtr	/* geom */,
    unsigned int	/* which */,
    Bool		/* freeMap */
);

extern Bool
XkbGeomRealloc(
    void **		/* buffer */,
    int			/* szItems */,
    int			/* nrItems */,
    int			/* itemSize */,
    XkbGeomClearance	/* clearance */
);

extern Status
XkbAllocGeomProps(
    XkbGeometryPtr	/* geom */,
    int			/* nProps */
);

extern Status
XkbAllocGeomKeyAliases(
    XkbGeometryPtr	/* geom */,
    int			/* nAliases */
);

extern Status
XkbAllocGeomColors(
    XkbGeometryPtr	/* geom */,
    int			/* nColors */
);

extern Status
XkbAllocGeomShapes(
    XkbGeometryPtr	/* geom */,
    int			/* nShapes */
);

extern Status
XkbAllocGeomSections(
    XkbGeometryPtr	/* geom */,
    int			/* nSections */
);

extern Status
XkbAllocGeomOverlays(
    XkbSectionPtr	/* section */,
    int			/* num_needed */
);

extern Status
XkbAllocGeomOverlayRows(
    XkbOverlayPtr	/* overlay */,
    int			/* num_needed */
);

extern Status
XkbAllocGeomOverlayKeys(
    XkbOverlayRowPtr	/* row */,
    int			/* num_needed */
);

extern Status
XkbAllocGeomDoodads(
    XkbGeometryPtr	/* geom */,
    int			/* nDoodads */
);

extern Status
XkbAllocGeomSectionDoodads(
    XkbSectionPtr	/* section */,
    int			/* nDoodads */
);

extern Status
XkbAllocGeomOutlines(
    XkbShapePtr		/* shape */,
    int			/* nOL */
);

extern Status
XkbAllocGeomRows(
    XkbSectionPtr	/* section */,
    int			/* nRows */
);

extern Status
XkbAllocGeomPoints(
    XkbOutlinePtr	/* ol */,
    int			/* nPts */
);

extern Status
XkbAllocGeomKeys(
    XkbRowPtr		/* row */,
    int			/* nKeys */
);

extern	Status
XkbAllocGeometry(
	XkbDescPtr		/* xkb */,
	XkbGeometrySizesPtr	/* sizes */
);

extern	Bool
XkbComputeShapeTop(
	XkbShapePtr		/* shape */,
	XkbBoundsPtr		/* bounds */
);

extern	Bool
XkbComputeShapeBounds(
	XkbShapePtr		/* shape */
);

extern	Bool
XkbComputeRowBounds(
	XkbGeometryPtr		/* geom */,
	XkbSectionPtr		/* section */,
	XkbRowPtr		/* row */
);

extern	Bool
XkbComputeSectionBounds(
	XkbGeometryPtr		/* geom */,
	XkbSectionPtr		/* section */
);

extern	char *
XkbFindOverlayForKey(
	XkbGeometryPtr		/* geom */,
	XkbSectionPtr		/* wanted */,
	char *			/* under */
);

#endif /* _XKBGEOM_H_ */
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "inputstr.h"
#include "opaque.h"
#include "property.h"
#include "scrnintstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "xkbgeom.h"
#include <X11/extensions/XKMformat.h>
#include "xkbfile.h"
#include "xkb.h"

#define	CREATE_ATOM(s)	MakeAtom(s,sizeof(s)-1,1)

#if defined(__alpha) || defined(__alpha__)
#define	LED_COMPOSE	2
#define LED_CAPS	3
#define	LED_SCROLL	4
#define	LED_NUM		5
#define	PHYS_LEDS	0x1f
#else
#ifdef sun
#define LED_NUM		1
#define	LED_SCROLL	2
#define	LED_COMPOSE	3
#define LED_CAPS	4
#define	PHYS_LEDS	0x0f
#else
#define	LED_CAPS	1
#define	LED_NUM		2
#define	LED_SCROLL	3
#define	PHYS_LEDS	0x07
#endif
#endif

#define	MAX_TOC	16
typedef struct	_SrvXkmInfo {
	DeviceIntPtr	dev;
	FILE *		file;
	XkbDescPtr	xkb;
} SrvXkmInfo;


/***====================================================================***/

#ifndef XKB_DFLT_RULES_PROP
#define	XKB_DFLT_RULES_PROP	TRUE
#endif

char	*		XkbBaseDirectory=	XKB_BASE_DIRECTORY;
char	*		XkbBinDirectory=	XKB_BIN_DIRECTORY;
static int	 	XkbWantAccessX=		0;	

static char *		XkbRulesDflt=		NULL;
static char *		XkbModelDflt=		NULL;
static char *		XkbLayoutDflt=		NULL;
static char *		XkbVariantDflt=		NULL;
static char *		XkbOptionsDflt=		NULL;

static char *           XkbRulesUsed=   NULL;
static char *		XkbModelUsed=	NULL;
static char *		XkbLayoutUsed=	NULL;
static char *		XkbVariantUsed=	NULL;
static char *		XkbOptionsUsed=	NULL;

static XkbDescPtr	xkb_cached_map = NULL;

static Bool		XkbWantRulesProp=	XKB_DFLT_RULES_PROP;

/***====================================================================***/

/**
 * Get the current default XKB rules.
 * Caller must free the data in rmlvo.
 */
void
XkbGetRulesDflts(XkbRMLVOSet *rmlvo)
{
    if (XkbRulesDflt)   rmlvo->rules = XkbRulesDflt;
    else                rmlvo->rules = XKB_DFLT_RULES;
    if (XkbModelDflt)	rmlvo->model= XkbModelDflt;
    else		rmlvo->model= XKB_DFLT_MODEL;
    if (XkbLayoutDflt)	rmlvo->layout= XkbLayoutDflt;
    else		rmlvo->layout= XKB_DFLT_LAYOUT;
    if (XkbVariantDflt)	rmlvo->variant= XkbVariantDflt;
    else		rmlvo->variant= XKB_DFLT_VARIANT;
    if (XkbOptionsDflt)	rmlvo->options= XkbOptionsDflt;
    else		rmlvo->options= XKB_DFLT_OPTIONS;

    rmlvo->rules = strdup(rmlvo->rules);
    rmlvo->model = strdup(rmlvo->model);
    rmlvo->layout = strdup(rmlvo->layout);
    rmlvo->variant = strdup(rmlvo->variant);
    rmlvo->options = strdup(rmlvo->options);
}

void
XkbFreeRMLVOSet(XkbRMLVOSet *rmlvo, Bool freeRMLVO)
{
    if (!rmlvo)
        return;

    free(rmlvo->rules);
    free(rmlvo->model);
    free(rmlvo->layout);
    free(rmlvo->variant);
    free(rmlvo->options);

    if (freeRMLVO)
        free(rmlvo);
    else
        memset(rmlvo, 0, sizeof(XkbRMLVOSet));
}

static Bool
XkbWriteRulesProp(ClientPtr client, pointer closure)
{
int 			len,out;
Atom			name;
char *			pval;

    len= (XkbRulesUsed?strlen(XkbRulesUsed):0);
    len+= (XkbModelUsed?strlen(XkbModelUsed):0);
    len+= (XkbLayoutUsed?strlen(XkbLayoutUsed):0);
    len+= (XkbVariantUsed?strlen(XkbVariantUsed):0);
    len+= (XkbOptionsUsed?strlen(XkbOptionsUsed):0);
    if (len<1)
	return TRUE;

    len+= 5; /* trailing NULs */

    name= MakeAtom(_XKB_RF_NAMES_PROP_ATOM,strlen(_XKB_RF_NAMES_PROP_ATOM),1);
    if (name==None) {
	ErrorF("[xkb] Atom error: %s not created\n",_XKB_RF_NAMES_PROP_ATOM);
	return TRUE;
    }
    pval= (char*) malloc(len);
    if (!pval) {
	ErrorF("[xkb] Allocation error: %s proprerty not created\n",
						_XKB_RF_NAMES_PROP_ATOM);
	return TRUE;
    }
    out= 0;
    if (XkbRulesUsed) {
	strcpy(&pval[out],XkbRulesUsed);
	out+= strlen(XkbRulesUsed);
    }
    pval[out++]= '\0';
    if (XkbModelUsed) {
	strcpy(&pval[out],XkbModelUsed);
	out+= strlen(XkbModelUsed);
    } 
    pval[out++]= '\0';
    if (XkbLayoutUsed) {
	strcpy(&pval[out],XkbLayoutUsed);
	out+= strlen(XkbLayoutUsed);
    }
    pval[out++]= '\0';
    if (XkbVariantUsed) {
	strcpy(&pval[out],XkbVariantUsed);
	out+= strlen(XkbVariantUsed);
    }
    pval[out++]= '\0';
    if (XkbOptionsUsed) {
	strcpy(&pval[out],XkbOptionsUsed);
	out+= strlen(XkbOptionsUsed);
    }
    pval[out++]= '\0';
    if (out!=len) {
	ErrorF("[xkb] Internal Error! bad size (%d!=%d) for _XKB_RULES_NAMES\n",
								out,len);
    }
    dixChangeWindowProperty(serverClient, screenInfo.screens[0]->root, name, XA_STRING, 8,
			    PropModeReplace, len, pval, TRUE);
    free(pval);
    return TRUE;
}

static void
XkbSetRulesUsed(XkbRMLVOSet *rmlvo)
{
    free(XkbRulesUsed);
    XkbRulesUsed= (rmlvo->rules?Xstrdup(rmlvo->rules):NULL);
    free(XkbModelUsed);
    XkbModelUsed= (rmlvo->model?Xstrdup(rmlvo->model):NULL);
    free(XkbLayoutUsed);
    XkbLayoutUsed= (rmlvo->layout?Xstrdup(rmlvo->layout):NULL);
    free(XkbVariantUsed);
    XkbVariantUsed= (rmlvo->variant?Xstrdup(rmlvo->variant):NULL);
    free(XkbOptionsUsed);
    XkbOptionsUsed= (rmlvo->options?Xstrdup(rmlvo->options):NULL);
    if (XkbWantRulesProp)
	QueueWorkProc(XkbWriteRulesProp,NULL,NULL);
    return;
}

void
XkbSetRulesDflts(XkbRMLVOSet *rmlvo)
{
    if (rmlvo->rules) {
        free(XkbRulesDflt);
        XkbRulesDflt= Xstrdup(rmlvo->rules);
    }
    if (rmlvo->model) {
	free(XkbModelDflt);
	XkbModelDflt= Xstrdup(rmlvo->model);
    }
    if (rmlvo->layout) {
	free(XkbLayoutDflt);
	XkbLayoutDflt= Xstrdup(rmlvo->layout);
    }
    if (rmlvo->variant) {
	free(XkbVariantDflt);
	XkbVariantDflt= Xstrdup(rmlvo->variant);
    }
    if (rmlvo->options) {
	free(XkbOptionsDflt);
	XkbOptionsDflt= Xstrdup(rmlvo->options);
    }
    return;
}

void
XkbDeleteRulesDflts(void)
{
    free(XkbRulesDflt);
    XkbRulesDflt = NULL;
    free(XkbModelDflt);
    XkbModelDflt = NULL;
    free(XkbLayoutDflt);
    XkbLayoutDflt = NULL;
    free(XkbVariantDflt);
    XkbVariantDflt = NULL;
    free(XkbOptionsDflt);
    XkbOptionsDflt = NULL;

    XkbFreeKeyboard(xkb_cached_map, XkbAllComponentsMask, TRUE);
    xkb_cached_map = NULL;
}

#define DIFFERS(a, b) (strcmp((a) ? (a) : "", (b) ? (b) : "") != 0)

static Bool
XkbCompareUsedRMLVO(XkbRMLVOSet *rmlvo)
{
    if (DIFFERS(rmlvo->rules, XkbRulesUsed) ||
        DIFFERS(rmlvo->model, XkbModelUsed) ||
        DIFFERS(rmlvo->layout, XkbLayoutUsed) ||
        DIFFERS(rmlvo->variant, XkbVariantUsed) ||
        DIFFERS(rmlvo->options, XkbOptionsUsed))
        return FALSE;
    return TRUE;
}

#undef DIFFERS

/***====================================================================***/

#include "xkbDflts.h"

static Bool
XkbInitKeyTypes(XkbDescPtr xkb)
{
    if (xkb->defined & XkmTypesMask)
        return TRUE;

    initTypeNames(NULL);
    if (XkbAllocClientMap(xkb,XkbKeyTypesMask,num_dflt_types)!=Success)
	return FALSE;
    if (XkbCopyKeyTypes(dflt_types,xkb->map->types,num_dflt_types)!=
    								 Success) {
	return FALSE;
    }
    xkb->map->size_types= xkb->map->num_types= num_dflt_types;
    return TRUE;
}

static void
XkbInitRadioGroups(XkbSrvInfoPtr xkbi)
{
    xkbi->nRadioGroups = 0;
    xkbi->radioGroups = NULL;
    return;
}


static Status
XkbInitCompatStructs(XkbDescPtr xkb)
{
register int 	i;
XkbCompatMapPtr	compat;

    if (xkb->defined & XkmCompatMapMask)
        return TRUE;

    if (XkbAllocCompatMap(xkb,XkbAllCompatMask,num_dfltSI)!=Success)
	return BadAlloc;
    compat = xkb->compat;
    if (compat->sym_interpret) {
	compat->num_si = num_dfltSI;
	memcpy((char *)compat->sym_interpret,(char *)dfltSI,sizeof(dfltSI));
    }
    for (i=0;i<XkbNumKbdGroups;i++) {
	compat->groups[i]= compatMap.groups[i];
	if (compat->groups[i].vmods!=0) {
	    unsigned mask;
	    mask= XkbMaskForVMask(xkb,compat->groups[i].vmods);
	    compat->groups[i].mask= compat->groups[i].real_mods|mask;
	}
	else compat->groups[i].mask= compat->groups[i].real_mods;
    }
    return Success;
}

static void
XkbInitSemantics(XkbDescPtr xkb)
{
    XkbInitKeyTypes(xkb);
    XkbInitCompatStructs(xkb);
    return;
}

/***====================================================================***/

static Status
XkbInitNames(XkbSrvInfoPtr xkbi)
{
XkbDescPtr	xkb;
XkbNamesPtr	names;
Status		rtrn;
Atom		unknown;

    xkb= xkbi->desc;
    if ((rtrn=XkbAllocNames(xkb,XkbAllNamesMask,0,0))!=Success)
	return rtrn;
    unknown= CREATE_ATOM("unknown");
    names = xkb->names;
    if (names->keycodes==None)		names->keycodes= unknown;
    if (names->geometry==None)		names->geometry= unknown;
    if (names->phys_symbols==None)	names->phys_symbols= unknown;
    if (names->symbols==None)		names->symbols= unknown;
    if (names->types==None)		names->types= unknown;
    if (names->compat==None)		names->compat= unknown;
    if (!(xkb->defined & XkmVirtualModsMask)) {
        if (names->vmods[vmod_NumLock]==None)
            names->vmods[vmod_NumLock]= CREATE_ATOM("NumLock");
        if (names->vmods[vmod_Alt]==None)
            names->vmods[vmod_Alt]= CREATE_ATOM("Alt");
        if (names->vmods[vmod_AltGr]==None)
            names->vmods[vmod_AltGr]= CREATE_ATOM("ModeSwitch");
    }

    if (!(xkb->defined & XkmIndicatorsMask) ||
        !(xkb->defined & XkmGeometryMask)) {
        initIndicatorNames(NULL,xkb);
        if (names->indicators[LED_CAPS-1]==None)
            names->indicators[LED_CAPS-1] = CREATE_ATOM("Caps Lock");
        if (names->indicators[LED_NUM-1]==None)
            names->indicators[LED_NUM-1] = CREATE_ATOM("Num Lock");
        if (names->indicators[LED_SCROLL-1]==None)
            names->indicators[LED_SCROLL-1] = CREATE_ATOM("Scroll Lock");
#ifdef LED_COMPOSE
        if (names->indicators[LED_COMPOSE-1]==None)
            names->indicators[LED_COMPOSE-1] = CREATE_ATOM("Compose");
#endif
    }

    if (xkb->geom!=NULL)
	 names->geometry= xkb->geom->name;
    else names->geometry= unknown;

    return Success;
}

static Status
XkbInitIndicatorMap(XkbSrvInfoPtr xkbi)
{
XkbDescPtr		xkb;
XkbIndicatorPtr		map;
XkbSrvLedInfoPtr	sli;

    xkb= xkbi->desc;
    if (XkbAllocIndicatorMaps(xkb)!=Success)
	return BadAlloc;

    if (!(xkb->defined & XkmIndicatorsMask)) {
        map= xkb->indicators;
        map->phys_indicators = PHYS_LEDS;
        map->maps[LED_CAPS-1].flags= XkbIM_NoExplicit;
        map->maps[LED_CAPS-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_CAPS-1].mods.mask= LockMask;
        map->maps[LED_CAPS-1].mods.real_mods= LockMask;

        map->maps[LED_NUM-1].flags= XkbIM_NoExplicit;
        map->maps[LED_NUM-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_NUM-1].mods.mask= 0;
        map->maps[LED_NUM-1].mods.real_mods= 0;
        map->maps[LED_NUM-1].mods.vmods= vmod_NumLockMask;

        map->maps[LED_SCROLL-1].flags= XkbIM_NoExplicit;
        map->maps[LED_SCROLL-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_SCROLL-1].mods.mask= Mod3Mask;
        map->maps[LED_SCROLL-1].mods.real_mods= Mod3Mask;
    }

    sli= XkbFindSrvLedInfo(xkbi->device,XkbDfltXIClass,XkbDfltXIId,0);
    if (sli)
	XkbCheckIndicatorMaps(xkbi->device,sli,XkbAllIndicatorsMask);

    return Success;
}

static Status
XkbInitControls(DeviceIntPtr pXDev,XkbSrvInfoPtr xkbi)
{
XkbDescPtr	xkb;
XkbControlsPtr	ctrls;

    xkb= xkbi->desc;
    /* 12/31/94 (ef) -- XXX! Should check if controls loaded from file */
    if (XkbAllocControls(xkb,XkbAllControlsMask)!=Success)
	FatalError("Couldn't allocate keyboard controls\n");
    ctrls= xkb->ctrls;
    if (!(xkb->defined & XkmSymbolsMask))
        ctrls->num_groups = 1;
    ctrls->groups_wrap = XkbSetGroupInfo(1,XkbWrapIntoRange,0);
    ctrls->internal.mask = 0;
    ctrls->internal.real_mods = 0;
    ctrls->internal.vmods = 0;
    ctrls->ignore_lock.mask = 0;
    ctrls->ignore_lock.real_mods = 0;
    ctrls->ignore_lock.vmods = 0;
    ctrls->enabled_ctrls = XkbAccessXTimeoutMask|XkbRepeatKeysMask|
				XkbMouseKeysAccelMask|XkbAudibleBellMask|
				XkbIgnoreGroupLockMask;
    if (XkbWantAccessX)
	ctrls->enabled_ctrls|= XkbAccessXKeysMask;
    AccessXInit(pXDev);
    return Success;
}

_X_EXPORT Bool
InitKeyboardDeviceStruct(DeviceIntPtr dev, XkbRMLVOSet *rmlvo,
                         BellProcPtr bell_func, KbdCtrlProcPtr ctrl_func)
{
    int	i;
    unsigned int check;
    XkbSrvInfoPtr xkbi;
    XkbDescPtr xkb;
    XkbSrvLedInfoPtr sli;
    XkbChangesRec changes;
    XkbEventCauseRec cause;
    XkbRMLVOSet rmlvo_dflts = { NULL };

    if (dev->key || dev->kbdfeed)
	return FALSE;

    if (!rmlvo)
    {
        rmlvo = &rmlvo_dflts;
        XkbGetRulesDflts(rmlvo);
    }


    memset(&changes, 0, sizeof(changes));
    XkbSetCauseUnknown(&cause);

    dev->key = calloc(1, sizeof(*dev->key));
    if (!dev->key) {
        ErrorF("XKB: Failed to allocate key class\n");
        return FALSE;
    }
    dev->key->sourceid = dev->id;

    dev->kbdfeed = calloc(1, sizeof(*dev->kbdfeed));
    if (!dev->kbdfeed) {
        ErrorF("XKB: Failed to allocate key feedback class\n");
        goto unwind_key;
    }

    xkbi = calloc(1, sizeof(*xkbi));
    if (!xkbi) {
        ErrorF("XKB: Failed to allocate XKB info\n");
        goto unwind_kbdfeed;
    }
    dev->key->xkbInfo = xkbi;

    if (xkb_cached_map && !XkbCompareUsedRMLVO(rmlvo)) {
        XkbFreeKeyboard(xkb_cached_map, XkbAllComponentsMask, TRUE);
        xkb_cached_map = NULL;
    }

    if (xkb_cached_map)
        LogMessageVerb(X_INFO, 4, "XKB: Reusing cached keymap\n");
    else {
        xkb_cached_map = XkbCompileKeymap(dev, rmlvo);
        if (!xkb_cached_map) {
            ErrorF("XKB: Failed to compile keymap\n");
            goto unwind_info;
        }
    }

    xkb = XkbAllocKeyboard();
    if (!xkb) {
        ErrorF("XKB: Failed to allocate keyboard description\n");
        goto unwind_info;
    }

    if (!XkbCopyKeymap(xkb, xkb_cached_map)) {
        ErrorF("XKB: Failed to copy keymap\n");
        goto unwind_desc;
    }
    xkb->defined = xkb_cached_map->defined;
    xkb->flags = xkb_cached_map->flags;
    xkb->device_spec = xkb_cached_map->device_spec;
    xkbi->desc = xkb;

    if (xkb->min_key_code == 0)
        xkb->min_key_code = 8;
    if (xkb->max_key_code == 0)
        xkb->max_key_code = 255;

    i = XkbNumKeys(xkb) / 3 + 1;
    if (XkbAllocClientMap(xkb, XkbAllClientInfoMask, 0) != Success)
        goto unwind_desc;
    if (XkbAllocServerMap(xkb, XkbAllServerInfoMask, i) != Success)
        goto unwind_desc;

    xkbi->dfltPtrDelta = 1;
    xkbi->device = dev;

    XkbInitSemantics(xkb);
    XkbInitNames(xkbi);
    XkbInitRadioGroups(xkbi);

    XkbInitControls(dev, xkbi);

    XkbInitIndicatorMap(xkbi);

    XkbUpdateActions(dev, xkb->min_key_code, XkbNumKeys(xkb), &changes,
                     &check, &cause);

    InitFocusClassDeviceStruct(dev);

    xkbi->kbdProc = ctrl_func;
    dev->kbdfeed->BellProc = bell_func;
    dev->kbdfeed->CtrlProc = XkbDDXKeybdCtrlProc;

    dev->kbdfeed->ctrl = defaultKeyboardControl;
    if (dev->kbdfeed->ctrl.autoRepeat)
        xkb->ctrls->enabled_ctrls |= XkbRepeatKeysMask;

    memcpy(dev->kbdfeed->ctrl.autoRepeats, xkb->ctrls->per_key_repeat,
           XkbPerKeyBitArraySize);

    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    if (sli)
	XkbCheckIndicatorMaps(dev, sli, XkbAllIndicatorsMask);
    else
        DebugF("XKB: No indicator feedback in XkbFinishInit!\n");

    dev->kbdfeed->CtrlProc(dev,&dev->kbdfeed->ctrl);

    XkbSetRulesDflts(rmlvo);
    XkbSetRulesUsed(rmlvo);
    XkbFreeRMLVOSet(&rmlvo_dflts, FALSE);

    return TRUE;

unwind_desc:
    XkbFreeKeyboard(xkb, 0, TRUE);
unwind_info:
    free(xkbi);
    dev->key->xkbInfo = NULL;
unwind_kbdfeed:
    free(dev->kbdfeed);
    dev->kbdfeed = NULL;
unwind_key:
    free(dev->key);
    dev->key = NULL;
    return FALSE;
}


/***====================================================================***/

	/*
	 * Be very careful about what does and doesn't get freed by this 
	 * function.  To reduce fragmentation, XkbInitDevice allocates a 
	 * single huge block per device and divides it up into most of the 
	 * fixed-size structures for the device.   Don't free anything that
	 * is part of this larger block.
	 */
void
XkbFreeInfo(XkbSrvInfoPtr xkbi)
{
    free(xkbi->radioGroups);
    xkbi->radioGroups = NULL;
    if (xkbi->mouseKeyTimer) {
	TimerFree(xkbi->mouseKeyTimer);
	xkbi->mouseKeyTimer= NULL;
    }
    if (xkbi->slowKeysTimer) {
	TimerFree(xkbi->slowKeysTimer);
	xkbi->slowKeysTimer= NULL;
    }
    if (xkbi->bounceKeysTimer) {
	TimerFree(xkbi->bounceKeysTimer);
	xkbi->bounceKeysTimer= NULL;
    }
    if (xkbi->repeatKeyTimer) {
	TimerFree(xkbi->repeatKeyTimer);
	xkbi->repeatKeyTimer= NULL;
    }
    if (xkbi->krgTimer) {
	TimerFree(xkbi->krgTimer);
	xkbi->krgTimer= NULL;
    }
    xkbi->beepType= _BEEP_NONE;
    if (xkbi->beepTimer) {
	TimerFree(xkbi->beepTimer);
	xkbi->beepTimer= NULL;
    }
    if (xkbi->desc) {
	XkbFreeKeyboard(xkbi->desc,XkbAllComponentsMask,TRUE);
	xkbi->desc= NULL;
    }
    free(xkbi);
    return;
}

/***====================================================================***/

extern int	XkbDfltRepeatDelay;
extern int	XkbDfltRepeatInterval;

extern unsigned short	XkbDfltAccessXTimeout;
extern unsigned int	XkbDfltAccessXTimeoutMask;
extern unsigned int	XkbDfltAccessXFeedback;
extern unsigned char	XkbDfltAccessXOptions;

int
XkbProcessArguments(int argc,char *argv[],int i)
{
    if (strncmp(argv[i], "-xkbdir", 7) == 0) {
	if(++i < argc) {
#if !defined(WIN32) && !defined(__CYGWIN__)
	    if (getuid() != geteuid()) {
		LogMessage(X_WARNING, "-xkbdir is not available for setuid X servers\n");
		return -1;
	    } else
#endif
	    {
		if (strlen(argv[i]) < PATH_MAX) {
		    XkbBaseDirectory= argv[i];
		    return 2;
	        } else {
		    LogMessage(X_ERROR, "-xkbdir pathname too long\n");
		    return -1;
		}
	    }
	}
	else {
	    return -1;
	}
    }
    else if ((strncmp(argv[i],"-accessx",8)==0)||
                 (strncmp(argv[i],"+accessx",8)==0)) {
	int j=1;	    
	if (argv[i][0]=='-')        
	    XkbWantAccessX= 0;
	else {
	    XkbWantAccessX= 1;
	    
	    if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		XkbDfltAccessXTimeout = atoi(argv[++i]);
		j++;

		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    /*
		     * presumption that the reasonably useful range of
		     * values fits in 0..MAXINT since SunOS 4 doesn't
		     * have strtoul.
		     */
		    XkbDfltAccessXTimeoutMask=(unsigned int)
					      strtol(argv[++i],NULL,16); 
		    j++;
		}
		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    if (argv[++i][0] == '1' ) 
			XkbDfltAccessXFeedback=XkbAccessXFeedbackMask;
		    else
			XkbDfltAccessXFeedback=0;
		    j++;
		}
		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    XkbDfltAccessXOptions=(unsigned char)
					   strtol(argv[++i],NULL,16);
		    j++;
		}
	    }
	}
	return j;
    }
    if ((strcmp(argv[i], "-ardelay") == 0) ||
        (strcmp (argv[i], "-ar1") == 0)) {	/* -ardelay int */
	if (++i >= argc) UseMsg ();
	XkbDfltRepeatDelay = (long)atoi(argv[i]);
	return 2;
    }
    if ((strcmp(argv[i], "-arinterval") == 0) ||
        (strcmp (argv[i], "-ar2") == 0)) {	/* -arinterval int */
	if (++i >= argc) UseMsg ();
	XkbDfltRepeatInterval = (long)atoi(argv[i]);
	return 2;
    }
    return 0;
}

void
XkbUseMsg(void)
{
    ErrorF("[+-]accessx [ timeout [ timeout_mask [ feedback [ options_mask] ] ] ]\n");
    ErrorF("                       enable/disable accessx key sequences\n");
    ErrorF("-ardelay               set XKB autorepeat delay\n");
    ErrorF("-arinterval            set XKB autorepeat interval\n");
}
/************************************************************
Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"

#include <X11/extensions/XI.h>
#include <xkbsrv.h>
#include "xkb.h"

/***====================================================================***/

	/*
	 * unsigned
	 * XkbIndicatorsToUpdate(dev,changed,check_devs_rtrn)
	 *
	 * Given a keyboard and a set of state components that have changed,
	 * this function returns the indicators on the default keyboard 
	 * feedback that might be affected.   It also reports whether or not 
	 * any extension devices might be affected in check_devs_rtrn.
	 */

unsigned
XkbIndicatorsToUpdate(	DeviceIntPtr	dev,
			unsigned long 	state_changes,
			Bool		enable_changes)
{
register unsigned	update=	0;
XkbSrvLedInfoPtr	sli;

    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);

    if (!sli)
        return update;

    if (state_changes&(XkbModifierStateMask|XkbGroupStateMask))
	update|= sli->usesEffective;
    if (state_changes&(XkbModifierBaseMask|XkbGroupBaseMask))
	update|= sli->usesBase;
    if (state_changes&(XkbModifierLatchMask|XkbGroupLatchMask))
	update|= sli->usesLatched;
    if (state_changes&(XkbModifierLockMask|XkbGroupLockMask))
	update|= sli->usesLocked;
    if (state_changes&XkbCompatStateMask)
	update|= sli->usesCompat;
    if (enable_changes)
	update|= sli->usesControls;
    return update;
}

/***====================================================================***/

	/*
	 * Bool
	 *XkbApplyLEDChangeToKeyboard(xkbi,map,on,change)
	 *
	 * Some indicators "drive" the keyboard when their state is explicitly 
	 * changed, as described in section 9.2.1 of the XKB protocol spec.
	 * This function updates the state and controls for the keyboard 
	 * specified by 'xkbi' to reflect any changes that are required 
	 * when the indicator described by 'map' is turned on or off.  The
	 * extent of the changes is reported in change, which must be defined.
	 */
static Bool
XkbApplyLEDChangeToKeyboard(	XkbSrvInfoPtr		xkbi,
				XkbIndicatorMapPtr	map,
				Bool			on,
				XkbChangesPtr		change)
{
Bool		ctrlChange,stateChange;
XkbStatePtr	state;

    if ((map->flags&XkbIM_NoExplicit)||((map->flags&XkbIM_LEDDrivesKB)==0))
	return FALSE;
    ctrlChange= stateChange= FALSE;
    if (map->ctrls) {
	XkbControlsPtr	ctrls= xkbi->desc->ctrls;
	unsigned 	old;

	old= ctrls->enabled_ctrls;
	if (on)	ctrls->enabled_ctrls|= map->ctrls;
	else	ctrls->enabled_ctrls&= ~map->ctrls;
	if (old!=ctrls->enabled_ctrls) {
	    change->ctrls.changed_ctrls= XkbControlsEnabledMask;
	    change->ctrls.enabled_ctrls_changes= old^ctrls->enabled_ctrls;
	    ctrlChange= TRUE;
	}
    }
    state= &xkbi->state;
    if ((map->groups)&&((map->which_groups&(~XkbIM_UseBase))!=0)) {
	register int i;
	register unsigned bit,match;

	if (on)	match= (map->groups)&XkbAllGroupsMask;
	else 	match= (~map->groups)&XkbAllGroupsMask;
	if (map->which_groups&(XkbIM_UseLocked|XkbIM_UseEffective)) {
	    for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		if (bit&match)
		    break;
	    }
	    if (map->which_groups&XkbIM_UseLatched)
		XkbLatchGroup(xkbi->device,0); /* unlatch group */
	    state->locked_group= i;
	    stateChange= TRUE;
	}
	else if (map->which_groups&(XkbIM_UseLatched|XkbIM_UseEffective)) {
	    for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		if (bit&match)
		    break;
	    }
	    state->locked_group= 0;
	    XkbLatchGroup(xkbi->device,i);
	    stateChange= TRUE;
	}
    }
    if ((map->mods.mask)&&((map->which_mods&(~XkbIM_UseBase))!=0)) {
	if (map->which_mods&(XkbIM_UseLocked|XkbIM_UseEffective)) {
	    register unsigned long old;
	    old= state->locked_mods;
	    if (on)	state->locked_mods|= map->mods.mask;
	    else	state->locked_mods&= ~map->mods.mask;
	    if (state->locked_mods!=old)
		stateChange= TRUE;
	}
	if (map->which_mods&(XkbIM_UseLatched|XkbIM_UseEffective)) {
	    register unsigned long newmods;
	    newmods= state->latched_mods;
	    if (on)	newmods|=  map->mods.mask;
	    else	newmods&= ~map->mods.mask;
	    if (newmods!=state->locked_mods) {
		newmods&= map->mods.mask;
		XkbLatchModifiers(xkbi->device,map->mods.mask,newmods);
		stateChange= TRUE;
	    }
	}
    }
    return stateChange || ctrlChange;
}
	
	/*
	 * Bool
	 * ComputeAutoState(map,state,ctrls)
	 *
	 * This function reports the effect of applying the specified
	 * indicator map given the specified state and controls, as
	 * described in section 9.2 of the XKB protocol specification.
	 */

static Bool
ComputeAutoState(	XkbIndicatorMapPtr	map,
			XkbStatePtr 		state,
			XkbControlsPtr 		ctrls)
{
Bool 			on;
CARD8 			mods,group;

    on= FALSE;
    mods= group= 0;
    if (map->which_mods&XkbIM_UseAnyMods) {
	if (map->which_mods&XkbIM_UseBase)
	    mods|= state->base_mods;
	if (map->which_mods&XkbIM_UseLatched)
	    mods|= state->latched_mods;
	if (map->which_mods&XkbIM_UseLocked)
	    mods|= state->locked_mods;
	if (map->which_mods&XkbIM_UseEffective)
	    mods|= state->mods;
	if (map->which_mods&XkbIM_UseCompat)
	    mods|= state->compat_state;
	on = ((map->mods.mask&mods)!=0);
	on = on||((mods==0)&&(map->mods.mask==0)&&(map->mods.vmods==0));
    }
    if (map->which_groups&XkbIM_UseAnyGroup) {
	if (map->which_groups&XkbIM_UseBase)
	    group|= (1L << state->base_group);
	if (map->which_groups&XkbIM_UseLatched)
	    group|= (1L << state->latched_group);
	if (map->which_groups&XkbIM_UseLocked)
	    group|= (1L << state->locked_group);
	if (map->which_groups&XkbIM_UseEffective)
	    group|= (1L << state->group);
	on = on||(((map->groups&group)!=0)||(map->groups==0));
    }
    if (map->ctrls)
	on = on||(ctrls->enabled_ctrls&map->ctrls);
    return on;
}


static void
XkbUpdateLedAutoState(	DeviceIntPtr			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			maps_to_check,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbStatePtr			state;
XkbControlsPtr			ctrls;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
register unsigned		i,bit,affected;
register XkbIndicatorMapPtr	map;
unsigned			oldState;

    if ((maps_to_check==0)||(sli->maps==NULL)||(sli->mapsPresent==0))
	return;

    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= inputInfo.keyboard;

    state= &kbd->key->xkbInfo->state;
    ctrls= kbd->key->xkbInfo->desc->ctrls;
    affected= maps_to_check;
    oldState= sli->effectiveState;
    sli->autoState&= ~affected;
    for (i=0,bit=1;(i<XkbNumIndicators)&&(affected);i++,bit<<=1) {
	if ((affected&bit)==0)
	    continue;
	affected&= ~bit;
	map= &sli->maps[i];
	if((!(map->flags&XkbIM_NoAutomatic))&&ComputeAutoState(map,state,ctrls))
	    sli->autoState|= bit;
    }
    sli->effectiveState= (sli->autoState|sli->explicitState);
    affected= sli->effectiveState^oldState;
    if (affected==0)
	return;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) {
	if (changes==NULL) {
	    changes= &my_changes;
	    memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->indicators.state_changes|= affected;
    }

    ed->reason|=	XkbXI_IndicatorStateMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    return;
}

static void
XkbUpdateAllDeviceIndicators(XkbChangesPtr changes,XkbEventCausePtr cause)
{
DeviceIntPtr		edev;
XkbSrvLedInfoPtr	sli;

    for (edev=inputInfo.devices;edev!=NULL;edev=edev->next) {
	if (edev->kbdfeed) {
	    KbdFeedbackPtr	kf;
	    for (kf=edev->kbdfeed;kf!=NULL;kf=kf->next) {
		if ((kf->xkb_sli==NULL)||(kf->xkb_sli->maps==NULL))
		    continue;
		sli= kf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
	if (edev->leds) {
	    LedFeedbackPtr	lf;
	    for (lf=edev->leds;lf!=NULL;lf=lf->next) {
		if ((lf->xkb_sli==NULL)||(lf->xkb_sli->maps==NULL))
		    continue;
		sli= lf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
    }
    return;
}


/***====================================================================***/

	/*
	 * void
	 * XkbSetIndicators(dev,affect,values,cause)
	 *
	 * Attempts to change the indicators specified in 'affect' to the
	 * states specified in 'values' for the default keyboard feedback
	 * on the keyboard specified by 'dev.'   Attempts to change indicator
	 * state might be ignored or have no affect, depending on the XKB
	 * indicator map for any affected indicators, as described in section
	 * 9.2 of the XKB protocol specification.
	 *
	 * If 'changes' is non-NULL, this function notes any changes to the
	 * keyboard state, controls, or indicator state that result from this
	 * attempted change.   If 'changes' is NULL, this function generates
	 * XKB events to report any such changes to interested clients.
	 *
	 * If 'cause' is non-NULL, it specifies the reason for the change, 
	 * as reported in some XKB events.   If it is NULL, this function 
	 * assumes that the change is the result of a core protocol 
	 * ChangeKeyboardMapping request.
	 */

void
XkbSetIndicators(	DeviceIntPtr		dev,
			CARD32			affect,
			CARD32			values,
			XkbEventCausePtr	cause)
{
XkbSrvLedInfoPtr		sli;
XkbChangesRec			changes;
xkbExtensionDeviceNotify	ed;
unsigned 			side_affected;

    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    sli->explicitState&= ~affect;
    sli->explicitState|= (affect&values);
    XkbApplyLedStateChanges(dev,sli,affect,&ed,&changes,cause);

    side_affected= 0;
    if (changes.state_changes!=0)
	side_affected|= XkbIndicatorsToUpdate(dev,changes.state_changes,FALSE);
    if (changes.ctrls.enabled_ctrls_changes)
	side_affected|= sli->usesControls;

    if (side_affected) {
	XkbUpdateLedAutoState(dev,sli,side_affected,&ed,&changes,cause);
	affect|= side_affected;
    }
    if (changes.state_changes || changes.ctrls.enabled_ctrls_changes)
	XkbUpdateAllDeviceIndicators(NULL,cause);

    XkbFlushLedEvents(dev,dev,sli,&ed,&changes,cause);
    return;
}

/***====================================================================***/

/***====================================================================***/

	/*
	 * void
	 * XkbUpdateIndicators(dev,update,check_edevs,changes,cause)
	 *
	 * Applies the indicator maps for any indicators specified in
	 * 'update' from the default keyboard feedback on the device
	 * specified by 'dev.' 
	 *
	 * If 'changes' is NULL, this function generates and XKB events
	 * required to report the necessary changes, otherwise it simply
	 * notes the indicators with changed state.
	 *
	 * If 'check_edevs' is TRUE, this function also checks the indicator
	 * maps for any open extension devices that have them, and updates
	 * the state of any extension device indicators as necessary.
	 */

void
XkbUpdateIndicators(	DeviceIntPtr		dev,
			register CARD32		update,
			Bool			check_edevs,
			XkbChangesPtr		changes,
			XkbEventCausePtr	cause)
{
XkbSrvLedInfoPtr	sli;

    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateLedAutoState(dev,sli,update,NULL,changes,cause);
    if (check_edevs)
	XkbUpdateAllDeviceIndicators(changes,cause);
    return;
}

/***====================================================================***/

/***====================================================================***/

	/*
	 * void
	 * XkbCheckIndicatorMaps(dev,sli,which)
	 *
	 * Updates the 'indicator accelerators' for the indicators specified
	 * by 'which' in the feedback specified by 'sli.' The indicator 
	 * accelerators are internal to the server and are used to simplify 
	 * and speed up the process of figuring out which indicators might 
	 * be affected by a particular change in keyboard state or controls.
	 */

void
XkbCheckIndicatorMaps(DeviceIntPtr dev,XkbSrvLedInfoPtr sli,unsigned which)
{
register unsigned	i,bit;
XkbIndicatorMapPtr	map;
XkbDescPtr		xkb;

    if ((sli->flags&XkbSLI_HasOwnState)==0)
        return;

    sli->usesBase&=	 ~which;
    sli->usesLatched&=	 ~which;
    sli->usesLocked&=	 ~which;
    sli->usesEffective&= ~which;
    sli->usesCompat&=	 ~which;
    sli->usesControls&=	 ~which;
    sli->mapsPresent&=	 ~which;

    xkb= dev->key->xkbInfo->desc;
    for (i=0,bit=1,map=sli->maps;i<XkbNumIndicators;i++,bit<<=1,map++) {
	if (which&bit) {
	    CARD8		what;

	    if (!map || !XkbIM_InUse(map))
		continue;
	    sli->mapsPresent|= bit;

	    what= (map->which_mods|map->which_groups);
	    if (what&XkbIM_UseBase)
		 sli->usesBase|= bit;
	    if (what&XkbIM_UseLatched)
		 sli->usesLatched|= bit;
	    if (what&XkbIM_UseLocked)
		 sli->usesLocked|= bit;
	    if (what&XkbIM_UseEffective)
		 sli->usesEffective|= bit;
	    if (what&XkbIM_UseCompat)
		 sli->usesCompat|= bit;
	    if (map->ctrls)
		 sli->usesControls|= bit;

	    map->mods.mask= map->mods.real_mods;
	    if (map->mods.vmods!=0) {
		map->mods.mask|= XkbMaskForVMask(xkb,map->mods.vmods);
	    }
	}
    }
    sli->usedComponents= 0;
    if (sli->usesBase)
	sli->usedComponents|= XkbModifierBaseMask|XkbGroupBaseMask;
    if (sli->usesLatched)
	sli->usedComponents|= XkbModifierLatchMask|XkbGroupLatchMask;
    if (sli->usesLocked)
	sli->usedComponents|= XkbModifierLockMask|XkbGroupLockMask;
    if (sli->usesEffective)
	sli->usedComponents|= XkbModifierStateMask|XkbGroupStateMask;
    if (sli->usesCompat)
	sli->usedComponents|= XkbCompatStateMask;
    return;
}

/***====================================================================***/

	/*
	 * XkbSrvLedInfoPtr
	 * XkbAllocSrvLedInfo(dev,kf,lf,needed_parts)
	 *
	 * Allocates an XkbSrvLedInfoPtr for the feedback specified by either
	 * 'kf' or 'lf' on the keyboard specified by 'dev.'
	 *
	 * If 'needed_parts' is non-zero, this function makes sure that any
	 * of the parts speicified therein are allocated.
	 */
XkbSrvLedInfoPtr
XkbAllocSrvLedInfo(	DeviceIntPtr		dev,
			KbdFeedbackPtr		kf,
			LedFeedbackPtr		lf,
			unsigned		needed_parts)
{
XkbSrvLedInfoPtr	sli;
Bool			checkAccel;
Bool			checkNames;

    sli= NULL;
    checkAccel= checkNames= FALSE;
    if ((kf!=NULL)&&(kf->xkb_sli==NULL)) {
	kf->xkb_sli= sli= calloc(1, sizeof(XkbSrvLedInfoRec));
	if (sli==NULL)
	    return NULL; /* ALLOCATION ERROR */
	if (dev->key && dev->key->xkbInfo)
	     sli->flags= XkbSLI_HasOwnState;
	else sli->flags= 0;	
	sli->class=	KbdFeedbackClass;
	sli->id=	kf->ctrl.id;
	sli->fb.kf=	kf;

	sli->autoState=		0;
	sli->explicitState=	kf->ctrl.leds;
	sli->effectiveState=	kf->ctrl.leds;

	if ((kf==dev->kbdfeed) && (dev->key) && (dev->key->xkbInfo)) {
	    XkbDescPtr	xkb;
	    xkb= dev->key->xkbInfo->desc;
	    sli->flags|= 		XkbSLI_IsDefault;
	    sli->physIndicators=	xkb->indicators->phys_indicators;
	    sli->names=			xkb->names->indicators;
	    sli->maps=			xkb->indicators->maps;
	    checkNames= checkAccel=	TRUE;
	}
	else {
	    sli->physIndicators=	XkbAllIndicatorsMask;
	    sli->names=			NULL;
	    sli->maps=			NULL;
	}
    }
    else if ((kf!=NULL)&&((kf->xkb_sli->flags&XkbSLI_IsDefault)!=0)) {
	XkbDescPtr	xkb;
	xkb= dev->key->xkbInfo->desc;
	sli= kf->xkb_sli;
	sli->physIndicators=	xkb->indicators->phys_indicators;
	if (xkb->names->indicators!=sli->names) {
	    checkNames= TRUE;
	    sli->names= xkb->names->indicators;
	}
	if (xkb->indicators->maps!=sli->maps) {
	    checkAccel= TRUE;
	    sli->maps= xkb->indicators->maps;
	}
    }
    else if ((lf!=NULL)&&(lf->xkb_sli==NULL)) {
	lf->xkb_sli= sli= calloc(1, sizeof(XkbSrvLedInfoRec));
	if (sli==NULL)
	    return NULL; /* ALLOCATION ERROR */
	if (dev->key && dev->key->xkbInfo)
	     sli->flags= XkbSLI_HasOwnState;
	else sli->flags= 0;	
	sli->class=	LedFeedbackClass;
	sli->id=	lf->ctrl.id;
	sli->fb.lf=	lf;

	sli->physIndicators=	lf->ctrl.led_mask;
	sli->autoState=		0;
	sli->explicitState=	lf->ctrl.led_values;
	sli->effectiveState=	lf->ctrl.led_values;
	sli->maps=		NULL;
	sli->names=		NULL;
    }
    else
	return NULL;
    if ((sli->names==NULL)&&(needed_parts&XkbXI_IndicatorNamesMask))
	sli->names= calloc(XkbNumIndicators, sizeof(Atom));
    if ((sli->maps==NULL)&&(needed_parts&XkbXI_IndicatorMapsMask))
	sli->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    if (checkNames) {
	register unsigned i,bit;
	sli->namesPresent=	0;
	for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	    if (sli->names[i]!=None)
		sli->namesPresent|= bit;
	}
    }
    if (checkAccel)
	 XkbCheckIndicatorMaps(dev,sli,XkbAllIndicatorsMask);
    return sli;
}

void
XkbFreeSrvLedInfo(XkbSrvLedInfoPtr sli)
{
    if ((sli->flags&XkbSLI_IsDefault)==0) {
	free(sli->maps);
	free(sli->names);
    }
    sli->maps= NULL;
    sli->names= NULL;
    free(sli);
    return;
}

/*
 * XkbSrvLedInfoPtr
 * XkbCopySrvLedInfo(dev,src,kf,lf)
 *
 * Takes the given XkbSrvLedInfoPtr and duplicates it. A deep copy is made,
 * thus the new copy behaves like the original one and can be freed with
 * XkbFreeSrvLedInfo.
 */
XkbSrvLedInfoPtr
XkbCopySrvLedInfo(	DeviceIntPtr		from,
			XkbSrvLedInfoPtr	src,
			KbdFeedbackPtr		kf,
			LedFeedbackPtr		lf)
{
    XkbSrvLedInfoPtr sli_new = NULL;

    if (!src)
	goto finish;

    sli_new = calloc(1, sizeof( XkbSrvLedInfoRec));
    if (!sli_new)
	goto finish;

    memcpy(sli_new, src, sizeof(XkbSrvLedInfoRec));
    if (sli_new->class == KbdFeedbackClass)
	sli_new->fb.kf = kf;
    else
	sli_new->fb.lf = lf;

    if (!(sli_new->flags & XkbSLI_IsDefault)) {
	sli_new->names= calloc(XkbNumIndicators, sizeof(Atom));
	sli_new->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    } /* else sli_new->names/maps is pointing to
	dev->key->xkbInfo->desc->names->indicators;
	dev->key->xkbInfo->desc->names->indicators; */

finish:
    return sli_new;
}

/***====================================================================***/

	/*
	 * XkbSrvLedInfoPtr
	 * XkbFindSrvLedInfo(dev,class,id,needed_parts)
	 *
	 * Finds the XkbSrvLedInfoPtr for the specified 'class' and 'id'
	 * on the device specified by 'dev.'   If the class and id specify
	 * a valid device feedback, this function returns the existing 
	 * feedback or allocates a new one.
	 *
	 */

XkbSrvLedInfoPtr
XkbFindSrvLedInfo(	DeviceIntPtr		dev,
			unsigned		class,
			unsigned		id,
			unsigned		needed_parts)
{
XkbSrvLedInfoPtr	sli;

    /* optimization to check for most common case */
    if (((class==XkbDfltXIClass)&&(id==XkbDfltXIId))&&(dev->kbdfeed)) {
	XkbSrvLedInfoPtr	sli;
	sli= dev->kbdfeed->xkb_sli;
	if (dev->kbdfeed->xkb_sli==NULL) {
	    sli= XkbAllocSrvLedInfo(dev,dev->kbdfeed,NULL,needed_parts);
	    dev->kbdfeed->xkb_sli= sli;
	}
	return dev->kbdfeed->xkb_sli;
    }

    sli= NULL;
    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
	else 			return NULL;
    }
    if (class==KbdFeedbackClass) {
	KbdFeedbackPtr	kf;
	for (kf=dev->kbdfeed;kf!=NULL;kf=kf->next) {
	    if ((id==XkbDfltXIId)||(id==kf->ctrl.id)) {
		if (kf->xkb_sli==NULL)
		    kf->xkb_sli= XkbAllocSrvLedInfo(dev,kf,NULL,needed_parts);
		sli= kf->xkb_sli;
		break;
	    }	
	}
    }
    else if (class==LedFeedbackClass) {
	LedFeedbackPtr	lf;
	for (lf=dev->leds;lf!=NULL;lf=lf->next) {
	    if ((id==XkbDfltXIId)||(id==lf->ctrl.id)) {
		if (lf->xkb_sli==NULL)
		    lf->xkb_sli= XkbAllocSrvLedInfo(dev,NULL,lf,needed_parts);
		sli= lf->xkb_sli;
		break;
	    }	
	}
    }
    if (sli) {
	if ((sli->names==NULL)&&(needed_parts&XkbXI_IndicatorNamesMask))
	    sli->names= calloc(XkbNumIndicators, sizeof(Atom));
	if ((sli->maps==NULL)&&(needed_parts&XkbXI_IndicatorMapsMask))
	    sli->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    }
    return sli;
}

/***====================================================================***/

void
XkbFlushLedEvents(	DeviceIntPtr			dev,
			DeviceIntPtr			kbd,
			XkbSrvLedInfoPtr		sli,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
    if (changes) {
	if (changes->indicators.state_changes)
	    XkbDDXUpdateDeviceIndicators(dev,sli,sli->effectiveState);
	XkbSendNotification(kbd,changes,cause);
	memset((char *)changes, 0, sizeof(XkbChangesRec));

	if (XkbAX_NeedFeedback(kbd->key->xkbInfo->desc->ctrls, XkbAX_IndicatorFBMask)) {
		if (sli->effectiveState)
			/* it appears that the which parameter is not used */
			XkbDDXAccessXBeep(dev, _BEEP_LED_ON, XkbAccessXFeedbackMask);
		else
			XkbDDXAccessXBeep(dev, _BEEP_LED_OFF, XkbAccessXFeedbackMask);
	}
    }
    if (ed) {
	if (ed->reason) {
	    if ((dev!=kbd)&&(ed->reason&XkbXI_IndicatorStateMask))
		XkbDDXUpdateDeviceIndicators(dev,sli,sli->effectiveState);
	    XkbSendExtensionDeviceNotify(dev,cause->client,ed);
	}
	memset((char *)ed, 0, sizeof(XkbExtensionDeviceNotify));
    }
    return;
}

/***====================================================================***/

void
XkbApplyLedNameChanges(	DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_names,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;

    if (changed_names==0)
	return;
    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= inputInfo.keyboard;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) { 
	if (changes==NULL) {
	   changes= &my_changes;
	   memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->names.changed|= XkbIndicatorNamesMask;
	changes->names.changed_indicators|= changed_names;
    }

    ed->reason|=	XkbXI_IndicatorNamesMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    return;
}
/***====================================================================***/

	/*
	 * void
	 * XkbApplyLedMapChanges(dev,sli,changed_maps,changes,cause)
	 *
	 * Handles all of the secondary effects of the changes to the
	 * feedback specified by 'sli' on the device specified by 'dev.'
	 * 
	 * If 'changed_maps' specifies any indicators, this function generates
	 * XkbExtensionDeviceNotify events and possibly IndicatorMapNotify
	 * events to report the changes, and recalculates the effective
	 * state of each indicator with a changed map.  If any indicators
	 * change state, the server generates XkbExtensionDeviceNotify and
	 * XkbIndicatorStateNotify events as appropriate.
	 *
	 * If 'changes' is non-NULL, this function updates it to reflect
	 * any changes to the keyboard state or controls or to the 'core'
	 * indicator names, maps, or state.   If 'changes' is NULL, this
	 * function generates XKB events as needed to report the changes.
	 * If 'dev' is not a keyboard device, any changes are reported
	 * for the core keyboard.
	 *
	 * The 'cause' specifies the reason for the event (key event or
	 * request) for the change, as reported in some XKB events.
	 */

void
XkbApplyLedMapChanges(	DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_maps,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;

    if (changed_maps==0)
	return;
    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= inputInfo.keyboard;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) {
	if (changes==NULL) {
	    changes= &my_changes;
	    memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->indicators.map_changes|= changed_maps;
    }

    XkbCheckIndicatorMaps(dev,sli,changed_maps);

    ed->reason|=	XkbXI_IndicatorMapsMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;

    XkbUpdateLedAutoState(dev,sli,changed_maps,ed,changes,cause);

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    return;
}

/***====================================================================***/

void
XkbApplyLedStateChanges(DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_leds,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
XkbSrvInfoPtr			xkbi;
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
register unsigned		i,bit,affected;
XkbIndicatorMapPtr		map;
unsigned			oldState;
Bool				kb_changed;

    if (changed_leds==0)
	return;
    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= inputInfo.keyboard;
    xkbi= kbd->key->xkbInfo;

    if (changes==NULL) {
	changes= &my_changes;
	memset((char *)changes, 0, sizeof(XkbChangesRec));
    }

    kb_changed= FALSE;
    affected= changed_leds;
    oldState= sli->effectiveState;
    for (i=0,bit=1;(i<XkbNumIndicators)&&(affected);i++,bit<<=1) {
	if ((affected&bit)==0)
	    continue;
	affected&= ~bit;
	map= &sli->maps[i];
	if (map->flags&XkbIM_NoExplicit) {
	    sli->explicitState&= ~bit;
	    continue;
	}
	if (map->flags&XkbIM_LEDDrivesKB) {
	    Bool on= ((sli->explicitState&bit)!=0);
	    if (XkbApplyLEDChangeToKeyboard(xkbi,map,on,changes))
		kb_changed= TRUE;
	}
    }
    sli->effectiveState= (sli->autoState|sli->explicitState);
    affected= sli->effectiveState^oldState;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if (affected&&(ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault))
	changes->indicators.state_changes|= affected;
    if (affected) {
	ed->reason|=		XkbXI_IndicatorStateMask;
	ed->ledClass= 		sli->class;
	ed->ledID=		sli->id;
	ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
	ed->ledState=		sli->effectiveState;
	ed->unsupported=	0;
	ed->supported=		XkbXI_AllFeaturesMask;
    }

    if (kb_changed) {
	XkbComputeDerivedState(kbd->key->xkbInfo);
	XkbUpdateLedAutoState(dev,sli,sli->mapsPresent,ed,changes,cause);
    }

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    if (kb_changed)
	XkbUpdateAllDeviceIndicators(NULL,cause);
    return;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#elif defined(HAVE_CONFIG_H)
#include <config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <X11/keysym.h>
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>

/***====================================================================***/

Status
XkbAllocClientMap(XkbDescPtr xkb,unsigned which,unsigned nTotalTypes)
{
register int	i;
XkbClientMapPtr map;

    if ((xkb==NULL)||((nTotalTypes>0)&&(nTotalTypes<XkbNumRequiredTypes)))
	return BadValue;
    if ((which&XkbKeySymsMask)&&
	((!XkbIsLegalKeycode(xkb->min_key_code))||
	 (!XkbIsLegalKeycode(xkb->max_key_code))||
	 (xkb->max_key_code<xkb->min_key_code))) {
        DebugF("bad keycode (%d,%d) in XkbAllocClientMap\n",
				xkb->min_key_code,xkb->max_key_code);
	return BadValue;
    }

    if (xkb->map==NULL) {
	map= calloc(1, sizeof(XkbClientMapRec));
	if (map==NULL)
	    return BadAlloc;
	xkb->map= map;
    }
    else map= xkb->map;

    if ((which&XkbKeyTypesMask)&&(nTotalTypes>0)) {
	if (map->types==NULL) {
	    map->types= calloc(nTotalTypes, sizeof(XkbKeyTypeRec));
	    if (map->types==NULL)
		return BadAlloc;
	    map->num_types= 0;
	    map->size_types= nTotalTypes;
	}
	else if (map->size_types<nTotalTypes) {
	    XkbKeyTypeRec *prev_types = map->types;

	    map->types= realloc(map->types,nTotalTypes * sizeof(XkbKeyTypeRec));
	    if (map->types==NULL) {
		free(prev_types);
		map->num_types= map->size_types= 0;
		return BadAlloc;
	    }
	    map->size_types= nTotalTypes;
	    memset(&map->types[map->num_types], 0,
		  ((map->size_types-map->num_types)*sizeof(XkbKeyTypeRec)));
	}
    }
    if (which&XkbKeySymsMask) {
	int nKeys= XkbNumKeys(xkb);
	if (map->syms==NULL) {
	    map->size_syms= (nKeys*15)/10;
	    map->syms= calloc(map->size_syms, sizeof(KeySym));
	    if (!map->syms) {
		map->size_syms= 0;
		return BadAlloc;
	    }
	    map->num_syms= 1;
	    map->syms[0]= NoSymbol;
	}
	if (map->key_sym_map==NULL) {
	    i= xkb->max_key_code+1;
	    map->key_sym_map= calloc(i, sizeof(XkbSymMapRec));
	    if (map->key_sym_map==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbModifierMapMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->modmap==NULL) {
	    i= xkb->max_key_code+1;
	    map->modmap= calloc(i, sizeof(unsigned char));
	    if (map->modmap==NULL)
		return BadAlloc;
	}
    }
    return Success;
}

Status
XkbAllocServerMap(XkbDescPtr xkb,unsigned which,unsigned nNewActions)
{
register int	i;
XkbServerMapPtr map;

    if (xkb==NULL)
	return BadMatch;
    if (xkb->server==NULL) {
	map= calloc(1, sizeof(XkbServerMapRec));
	if (map==NULL)
	    return BadAlloc;
	for (i=0;i<XkbNumVirtualMods;i++) {
	    map->vmods[i]= XkbNoModifierMask;
	}
	xkb->server= map;
    }
    else map= xkb->server;
    if (which&XkbExplicitComponentsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->explicit==NULL) {
	    i= xkb->max_key_code+1;
	    map->explicit= calloc(i, sizeof(unsigned char));
	    if (map->explicit==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbKeyActionsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
        if (nNewActions<1)
	    nNewActions= 1;
	if (map->acts==NULL) {
	    map->acts= calloc((nNewActions+1), sizeof(XkbAction));
	    if (map->acts==NULL)
		return BadAlloc;
	    map->num_acts= 1;
	    map->size_acts= nNewActions+1;
	}
	else if ((map->size_acts-map->num_acts)<nNewActions) {
	    unsigned need;
	    XkbAction *prev_acts = map->acts;
	    need= map->num_acts+nNewActions;
	    map->acts= realloc(map->acts,need * sizeof(XkbAction));
	    if (map->acts==NULL) {
		free(prev_acts);
	        map->num_acts= map->size_acts= 0;
	        return BadAlloc;
	    }
	    map->size_acts= need;
	    memset(&map->acts[map->num_acts], 0,
		    ((map->size_acts-map->num_acts)*sizeof(XkbAction)));
	}
	if (map->key_acts==NULL) {
	    i= xkb->max_key_code+1;
	    map->key_acts= calloc(i, sizeof(unsigned short));
	    if (map->key_acts==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbKeyBehaviorsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->behaviors==NULL) {
	    i= xkb->max_key_code+1;
	    map->behaviors= calloc(i, sizeof(XkbBehavior));
	    if (map->behaviors==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbVirtualModMapMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->vmodmap==NULL) {
	    i= xkb->max_key_code+1;
	    map->vmodmap= calloc(i, sizeof(unsigned short));
	    if (map->vmodmap==NULL)
		return BadAlloc;
	}
    }
    return Success;
}

/***====================================================================***/

static Status
XkbCopyKeyType(XkbKeyTypePtr from,XkbKeyTypePtr into)
{
    if ((!from)||(!into))
	return BadMatch;
    free(into->map);
    into->map = NULL;
    free(into->preserve);
    into->preserve = NULL;
    free(into->level_names);
    into->level_names = NULL;
    *into= *from;
    if ((from->map)&&(into->map_count>0)) {
	into->map= calloc(into->map_count, sizeof(XkbKTMapEntryRec));
	if (!into->map)
	    return BadAlloc;
	memcpy(into->map,from->map,into->map_count*sizeof(XkbKTMapEntryRec));
    }
    if ((from->preserve)&&(into->map_count>0)) {
	into->preserve= calloc(into->map_count, sizeof(XkbModsRec));
	if (!into->preserve)
	    return BadAlloc;
	memcpy(into->preserve,from->preserve,
				into->map_count*sizeof(XkbModsRec));
    }
    if ((from->level_names)&&(into->num_levels>0)) {
	into->level_names= calloc(into->num_levels, sizeof(Atom));
	if (!into->level_names)
	    return BadAlloc;
	memcpy(into->level_names,from->level_names,
				 into->num_levels*sizeof(Atom));
    }
    return Success;
}

Status
XkbCopyKeyTypes(XkbKeyTypePtr from,XkbKeyTypePtr into,int num_types)
{
register int i,rtrn;

    if ((!from)||(!into)||(num_types<0))
	return BadMatch;
    for (i=0;i<num_types;i++) {
	if ((rtrn= XkbCopyKeyType(from++,into++))!=Success)
	    return rtrn;
    }
    return Success;
}

Status
XkbResizeKeyType(	XkbDescPtr	xkb,
			int		type_ndx,
			int		map_count,
			Bool		want_preserve,
			int		new_num_lvls)
{
XkbKeyTypePtr	type;
KeyCode		matchingKeys[XkbMaxKeyCount],nMatchingKeys;

    if ((type_ndx<0)||(type_ndx>=xkb->map->num_types)||(map_count<0)||
    							(new_num_lvls<1))
	return BadValue;
    switch (type_ndx) {
	case XkbOneLevelIndex:
	    if (new_num_lvls!=1)
		return BadMatch;
	    break;
	case XkbTwoLevelIndex:
	case XkbAlphabeticIndex:
	case XkbKeypadIndex:
	    if (new_num_lvls!=2)
		return BadMatch;
	    break;
    }
    type= &xkb->map->types[type_ndx];
    if (map_count==0) {
	free(type->map);
	type->map= NULL;
	free(type->preserve);
	type->preserve= NULL;
	type->map_count= 0;
    }
    else {
	XkbKTMapEntryRec *prev_map = type->map;

	if ((map_count>type->map_count)||(type->map==NULL))
	    type->map = realloc(type->map,map_count * sizeof(XkbKTMapEntryRec));
	if (!type->map) {
	    free(prev_map);
	    return BadAlloc;
	}
	if (want_preserve) {
	    XkbModsRec *prev_preserve = type->preserve;

	    if ((map_count>type->map_count)||(type->preserve==NULL)) {
		type->preserve = realloc(type->preserve,
					  map_count * sizeof(XkbModsRec));
	    }
	    if (!type->preserve) {
		free(prev_preserve);
		return BadAlloc;
	    }
	}
	else {
	    free(type->preserve);
	    type->preserve = NULL;
	}
	type->map_count= map_count;
    }

    if ((new_num_lvls>type->num_levels)||(type->level_names==NULL)) {
	Atom * prev_level_names = type->level_names;

	type->level_names = realloc(type->level_names,
				     new_num_lvls * sizeof(Atom));
	if (!type->level_names) {
	    free(prev_level_names);
	    return BadAlloc;
	}
    }
    /*
     * Here's the theory:
     *    If the width of the type changed, we might have to resize the symbol
     * maps for any keys that use the type for one or more groups.  This is
     * expensive, so we'll try to cull out any keys that are obviously okay:
     * In any case:
     *    - keys that have a group width <= the old width are okay (because
     *      they could not possibly have been associated with the old type)
     * If the key type increased in size:
     *    - keys that already have a group width >= to the new width are okay
     *    + keys that have a group width >= the old width but < the new width
     *      might have to be enlarged.
     * If the key type decreased in size:
     *    - keys that have a group width > the old width don't have to be
     *      resized (because they must have some other wider type associated 
     *      with some group).
     *    + keys that have a group width == the old width might have to be
     *      shrunk.
     * The possibilities marked with '+' require us to examine the key types
     * associated with each group for the key.
     */
    memset(matchingKeys, 0, XkbMaxKeyCount*sizeof(KeyCode));
    nMatchingKeys= 0;
    if (new_num_lvls>type->num_levels) {
	int	 		nTotal;
	KeySym	*		newSyms;
	int			width,match,nResize;
	register int		i,g,nSyms;

	nResize= 0;
	for (nTotal=1,i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    width= XkbKeyGroupsWidth(xkb,i);
	    if (width<type->num_levels)
		continue;
	    for (match=0,g=XkbKeyNumGroups(xkb,i)-1;(g>=0)&&(!match);g--) {
		if (XkbKeyKeyTypeIndex(xkb,i,g)==type_ndx) {
		    matchingKeys[nMatchingKeys++]= i;
		    match= 1;
		}
	    }
	    if ((!match)||(width>=new_num_lvls))
		nTotal+= XkbKeyNumSyms(xkb,i);
	    else {
		nTotal+= XkbKeyNumGroups(xkb,i)*new_num_lvls;
		nResize++;
	    }
	}
	if (nResize>0) {
	    int nextMatch;
	    xkb->map->size_syms= (nTotal*15)/10;
	    newSyms = calloc(xkb->map->size_syms, sizeof(KeySym));
	    if (newSyms==NULL)
		return BadAlloc;
	    nextMatch= 0;
	    nSyms= 1;
	    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
		if (matchingKeys[nextMatch]==i) {
		    KeySym *pOld;
		    nextMatch++;
		    width= XkbKeyGroupsWidth(xkb,i);
		    pOld= XkbKeySymsPtr(xkb,i);
		    for (g=XkbKeyNumGroups(xkb,i)-1;g>=0;g--) {
			memcpy(&newSyms[nSyms+(new_num_lvls*g)],&pOld[width*g],
							width*sizeof(KeySym));
		    }
		    xkb->map->key_sym_map[i].offset= nSyms;
		    nSyms+= XkbKeyNumGroups(xkb,i)*new_num_lvls;
		}
		else {
		    memcpy(&newSyms[nSyms],XkbKeySymsPtr(xkb,i),
					XkbKeyNumSyms(xkb,i)*sizeof(KeySym));
		    xkb->map->key_sym_map[i].offset= nSyms;
		    nSyms+= XkbKeyNumSyms(xkb,i);
		}
	    }
	    type->num_levels= new_num_lvls;
	    free(xkb->map->syms);
	    xkb->map->syms= newSyms;
	    xkb->map->num_syms= nSyms;
	    return Success;
	}
    }
    else if (new_num_lvls<type->num_levels) {
	int 		width,match;
	register int	g,i;
	for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    width= XkbKeyGroupsWidth(xkb,i);
	    if (width<type->num_levels)
		continue;
	    for (match=0,g=XkbKeyNumGroups(xkb,i)-1;(g>=0)&&(!match);g--) {
		if (XkbKeyKeyTypeIndex(xkb,i,g)==type_ndx) {
		    matchingKeys[nMatchingKeys++]= i;
		    match= 1;
		}
	    }
	}
    }
    if (nMatchingKeys>0) {
	int 		key,firstClear;
	register int	i,g;
	if (new_num_lvls>type->num_levels)
	     firstClear= type->num_levels;
	else firstClear= new_num_lvls;
	for (i=0;i<nMatchingKeys;i++) {
	    KeySym *	pSyms;
	    int		width,nClear;

	    key= matchingKeys[i];
	    width= XkbKeyGroupsWidth(xkb,key);
	    nClear= width-firstClear;
	    pSyms= XkbKeySymsPtr(xkb,key);
	    for (g=XkbKeyNumGroups(xkb,key)-1;g>=0;g--) {
		if (XkbKeyKeyTypeIndex(xkb,key,g)==type_ndx) {
		    if (nClear>0)
			memset(&pSyms[g*width+firstClear], 0, nClear*sizeof(KeySym));
		}
	    }
	}
    }
    type->num_levels= new_num_lvls;
    return Success;
}

KeySym *
XkbResizeKeySyms(XkbDescPtr xkb,int key,int needed)
{
register int i,nSyms,nKeySyms;
unsigned nOldSyms;
KeySym	*newSyms;

    if (needed==0) {
	xkb->map->key_sym_map[key].offset= 0;
	return xkb->map->syms;
    }
    nOldSyms= XkbKeyNumSyms(xkb,key);
    if (nOldSyms>=(unsigned)needed) {
	return XkbKeySymsPtr(xkb,key);
    }
    if (xkb->map->size_syms-xkb->map->num_syms>=(unsigned)needed) {
	if (nOldSyms>0) {
	    memcpy(&xkb->map->syms[xkb->map->num_syms],XkbKeySymsPtr(xkb,key),
						nOldSyms*sizeof(KeySym));
	}
	if ((needed-nOldSyms)>0) {
	    memset(&xkb->map->syms[xkb->map->num_syms+XkbKeyNumSyms(xkb, key)],
                   0, (needed-nOldSyms)*sizeof(KeySym));
	}
	xkb->map->key_sym_map[key].offset = xkb->map->num_syms;
	xkb->map->num_syms+= needed;
	return &xkb->map->syms[xkb->map->key_sym_map[key].offset];
    }
    xkb->map->size_syms+= (needed>32?needed:32);
    newSyms = calloc(xkb->map->size_syms, sizeof(KeySym));
    if (newSyms==NULL)
	return NULL;
    newSyms[0]= NoSymbol;
    nSyms = 1;
    for (i=xkb->min_key_code;i<=(int)xkb->max_key_code;i++) {
	int nCopy;

	nCopy= nKeySyms= XkbKeyNumSyms(xkb,i);
	if ((nKeySyms==0)&&(i!=key))
	    continue;
	if (i==key)
	    nKeySyms= needed;
	if (nCopy!=0)
	   memcpy(&newSyms[nSyms],XkbKeySymsPtr(xkb,i),nCopy*sizeof(KeySym));
	if (nKeySyms>nCopy)
	    memset(&newSyms[nSyms+nCopy], 0, (nKeySyms-nCopy)*sizeof(KeySym));
	xkb->map->key_sym_map[i].offset = nSyms;
	nSyms+= nKeySyms;
    }
    free(xkb->map->syms);
    xkb->map->syms = newSyms;
    xkb->map->num_syms = nSyms;
    return &xkb->map->syms[xkb->map->key_sym_map[key].offset];
}

static unsigned
_ExtendRange(	unsigned int 	old_flags,
		unsigned int	flag,
		KeyCode		newKC,
		KeyCode *	old_min,
		unsigned char *	old_num)
{
    if ((old_flags&flag)==0) {
	old_flags|= flag;
	*old_min= newKC;
	*old_num= 1;
    }
    else {
	int	last= (*old_min)+(*old_num)-1;
	if (newKC<*old_min) {
	    *old_min= newKC;
	    *old_num= (last-newKC)+1;
	}
	else if (newKC>last) {
	    *old_num= (newKC-(*old_min))+1;
	}
    }
    return old_flags;
}

Status
XkbChangeKeycodeRange(	XkbDescPtr	xkb,
			int 		minKC,
			int 		maxKC,
			XkbChangesPtr	changes)
{
int	tmp;

    if ((!xkb)||(minKC<XkbMinLegalKeyCode)||(maxKC>XkbMaxLegalKeyCode))
	return BadValue;
    if (minKC>maxKC)
	return BadMatch;
    if (minKC<xkb->min_key_code) {
	if (changes)
	    changes->map.min_key_code= minKC;
	tmp= xkb->min_key_code-minKC;
	if (xkb->map)  {
	    if (xkb->map->key_sym_map) {
		memset((char *)&xkb->map->key_sym_map[minKC], 0,
					tmp*sizeof(XkbSymMapRec));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbKeySymsMask,minKC,
	    					&changes->map.first_key_sym,
	    					&changes->map.num_key_syms);
		}
	    }
	    if (xkb->map->modmap) {
		memset((char *)&xkb->map->modmap[minKC], 0, tmp);
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbModifierMapMask,minKC,
	    					&changes->map.first_modmap_key,
	    					&changes->map.num_modmap_keys);
		}
	    }
	}
	if (xkb->server) {
	    if (xkb->server->behaviors) {
		memset((char *)&xkb->server->behaviors[minKC], 0,
						tmp*sizeof(XkbBehavior));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyBehaviorsMask,minKC,
    					&changes->map.first_key_behavior,
    					&changes->map.num_key_behaviors);
		}
	    }
	    if (xkb->server->key_acts) {
		memset((char *)&xkb->server->key_acts[minKC], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyActionsMask,minKC,
    					&changes->map.first_key_act,
    					&changes->map.num_key_acts);
		}
	    }
	    if (xkb->server->vmodmap) {
		memset((char *)&xkb->server->vmodmap[minKC], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbVirtualModMapMask,minKC,
		    			&changes->map.first_modmap_key,
    					&changes->map.num_vmodmap_keys);
		}
	    }
	}
	if ((xkb->names)&&(xkb->names->keys)) {
	    memset((char *)&xkb->names->keys[minKC], 0, tmp*sizeof(XkbKeyNameRec));
	    if (changes) {
		changes->names.changed= _ExtendRange(changes->names.changed,
					XkbKeyNamesMask,minKC,
					&changes->names.first_key,
    					&changes->names.num_keys);
	    }
	}
	xkb->min_key_code= minKC;
    }
    if (maxKC>xkb->max_key_code) {
	if (changes)
	    changes->map.max_key_code= maxKC;
	tmp= maxKC-xkb->max_key_code;
	if (xkb->map)  {
	    if (xkb->map->key_sym_map) {
		XkbSymMapRec *prev_key_sym_map = xkb->map->key_sym_map;

		xkb->map->key_sym_map = realloc(xkb->map->key_sym_map,
						(maxKC+1) * sizeof(XkbSymMapRec));
		if (!xkb->map->key_sym_map) {
		    free(prev_key_sym_map);
		    return BadAlloc;
		}
		memset((char *)&xkb->map->key_sym_map[xkb->max_key_code], 0,
					tmp*sizeof(XkbSymMapRec));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbKeySymsMask,maxKC,
	    					&changes->map.first_key_sym,
	    					&changes->map.num_key_syms);
		}
	    }
	    if (xkb->map->modmap) {
		unsigned char *prev_modmap = xkb->map->modmap;

		xkb->map->modmap = realloc(xkb->map->modmap,
					    (maxKC+1) * sizeof(unsigned char));
		if (!xkb->map->modmap) {
		    free(prev_modmap);
		    return BadAlloc;
		}
		memset((char *)&xkb->map->modmap[xkb->max_key_code], 0, tmp);
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbModifierMapMask,maxKC,
	    					&changes->map.first_modmap_key,
	    					&changes->map.num_modmap_keys);
		}
	    }
	}
	if (xkb->server) {
	    if (xkb->server->behaviors) {
		XkbBehavior *prev_behaviors = xkb->server->behaviors;

		xkb->server->behaviors = realloc(xkb->server->behaviors,
						(maxKC+1) * sizeof(XkbBehavior));
		if (!xkb->server->behaviors) {
		    free(prev_behaviors);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->behaviors[xkb->max_key_code], 0,
						tmp*sizeof(XkbBehavior));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyBehaviorsMask,maxKC,
    					&changes->map.first_key_behavior,
    					&changes->map.num_key_behaviors);
		}
	    }
	    if (xkb->server->key_acts) {
		unsigned short *prev_key_acts = xkb->server->key_acts;

		xkb->server->key_acts= realloc(xkb->server->key_acts,
						(maxKC+1) * sizeof(unsigned short));
		if (!xkb->server->key_acts) {
		    free(prev_key_acts);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->key_acts[xkb->max_key_code], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyActionsMask,maxKC,
    					&changes->map.first_key_act,
    					&changes->map.num_key_acts);
		}
	    }
	    if (xkb->server->vmodmap) {
		unsigned short *prev_vmodmap = xkb->server->vmodmap;

		xkb->server->vmodmap= realloc(xkb->server->vmodmap,
						(maxKC+1) * sizeof(unsigned short));
		if (!xkb->server->vmodmap) {
		    free(prev_vmodmap);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->vmodmap[xkb->max_key_code], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbVirtualModMapMask,maxKC,
		    			&changes->map.first_modmap_key,
    					&changes->map.num_vmodmap_keys);
		}
	    }
	}
	if ((xkb->names)&&(xkb->names->keys)) {
	    XkbKeyNameRec *prev_keys = xkb->names->keys;

	    xkb->names->keys = realloc(xkb->names->keys,
					(maxKC+1) * sizeof(XkbKeyNameRec));
	    if (!xkb->names->keys) {
		free(prev_keys);
		return BadAlloc;
	    }
	    memset((char *)&xkb->names->keys[xkb->max_key_code], 0,
	    					tmp*sizeof(XkbKeyNameRec));
	    if (changes) {
		changes->names.changed= _ExtendRange(changes->names.changed,
					XkbKeyNamesMask,maxKC,
					&changes->names.first_key,
    					&changes->names.num_keys);
	    }
	}
	xkb->max_key_code= maxKC;
    }
    return Success;
}

XkbAction *
XkbResizeKeyActions(XkbDescPtr xkb,int key,int needed)
{
register int i,nActs;
XkbAction *newActs;

    if (needed==0) {
	xkb->server->key_acts[key]= 0;
	return NULL;
    }
    if (XkbKeyHasActions(xkb,key)&&(XkbKeyNumSyms(xkb,key)>=(unsigned)needed))
	return XkbKeyActionsPtr(xkb,key);
    if (xkb->server->size_acts-xkb->server->num_acts>=(unsigned)needed) {
	xkb->server->key_acts[key]= xkb->server->num_acts;
	xkb->server->num_acts+= needed;
	return &xkb->server->acts[xkb->server->key_acts[key]];
    }
    xkb->server->size_acts= xkb->server->num_acts+needed+8;
    newActs = calloc(xkb->server->size_acts, sizeof(XkbAction));
    if (newActs==NULL)
	return NULL;
    newActs[0].type = XkbSA_NoAction;
    nActs = 1;
    for (i=xkb->min_key_code;i<=(int)xkb->max_key_code;i++) {
	int nKeyActs,nCopy;

	if ((xkb->server->key_acts[i]==0)&&(i!=key))
	    continue;

	nCopy= nKeyActs= XkbKeyNumActions(xkb,i);
	if (i==key) {
	    nKeyActs= needed;
	    if (needed<nCopy)
		nCopy= needed;
	}

	if (nCopy>0)
	    memcpy(&newActs[nActs],XkbKeyActionsPtr(xkb,i),
						nCopy*sizeof(XkbAction));
	if (nCopy<nKeyActs)
	    memset(&newActs[nActs+nCopy], 0, (nKeyActs-nCopy)*sizeof(XkbAction));
	xkb->server->key_acts[i]= nActs;
	nActs+= nKeyActs;
    }
    free(xkb->server->acts);
    xkb->server->acts = newActs;
    xkb->server->num_acts= nActs;
    return &xkb->server->acts[xkb->server->key_acts[key]];
}

void
XkbFreeClientMap(XkbDescPtr xkb,unsigned what,Bool freeMap)
{
XkbClientMapPtr	map;

    if ((xkb==NULL)||(xkb->map==NULL))
	return;
    if (freeMap)
	what= XkbAllClientInfoMask;
    map= xkb->map;
    if (what&XkbKeyTypesMask) {
	if (map->types!=NULL) {
	    if (map->num_types>0) {
		register int 	i;
		XkbKeyTypePtr	type;
		for (i=0,type=map->types;i<map->num_types;i++,type++) {
		    free(type->map);
		    type->map = NULL;
		    free(type->preserve);
		    type->preserve = NULL;
		    type->map_count= 0;
		    free(type->level_names);
		    type->level_names = NULL;
		}
	    }
	    free(map->types);
	    map->num_types= map->size_types= 0;
	    map->types= NULL;
	}
    }
    if (what&XkbKeySymsMask) {
	free(map->key_sym_map);
	map->key_sym_map = NULL;
	if (map->syms!=NULL) {
	    free(map->syms);
	    map->size_syms= map->num_syms= 0;
	    map->syms= NULL;
	}
    }
    if ((what&XkbModifierMapMask)&&(map->modmap!=NULL)) {
	free(map->modmap);
	map->modmap= NULL;
    }
    if (freeMap) {
	free(xkb->map);
	xkb->map= NULL;
    }
    return;
}

void
XkbFreeServerMap(XkbDescPtr xkb,unsigned what,Bool freeMap)
{
XkbServerMapPtr	map;

    if ((xkb==NULL)||(xkb->server==NULL))
	return;
    if (freeMap)
	what= XkbAllServerInfoMask;
    map= xkb->server;
    if ((what&XkbExplicitComponentsMask)&&(map->explicit!=NULL)) {
	free(map->explicit);
	map->explicit= NULL;
    }
    if (what&XkbKeyActionsMask) {
	free(map->key_acts);
	map->key_acts = NULL;
	if (map->acts!=NULL) {
	    free(map->acts);
	    map->num_acts= map->size_acts= 0;
	    map->acts= NULL;
	}
    }
    if ((what&XkbKeyBehaviorsMask)&&(map->behaviors!=NULL)) {
	free(map->behaviors);
	map->behaviors= NULL;
    }
    if ((what&XkbVirtualModMapMask)&&(map->vmodmap!=NULL)) {
	free(map->vmodmap);
	map->vmodmap= NULL;
    }

    if (freeMap) {
	free(xkb->server);
	xkb->server= NULL;
    }
    return;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#elif defined(HAVE_CONFIG_H)
#include <config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <X11/keysym.h>
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>

/***====================================================================***/

#define	CORE_SYM(i)	(i<map_width?core_syms[i]:NoSymbol)
#define	XKB_OFFSET(g,l)	(((g)*groupsWidth)+(l))

int
XkbKeyTypesForCoreSymbols(	XkbDescPtr	xkb,
				int		map_width,
				KeySym *	core_syms,
				unsigned int 	protected,
    				int *		types_inout,
				KeySym *	xkb_syms_rtrn)
{
register int	i;
unsigned int	empty;
int		nSyms[XkbNumKbdGroups];
int		nGroups,tmp,groupsWidth;
BOOL		replicated = FALSE;

    /* Section 12.2 of the protocol describes this process in more detail */
    /* Step 1:  find the # of symbols in the core mapping per group */
    groupsWidth= 2;
    for (i=0;i<XkbNumKbdGroups;i++) {
	if ((protected&(1<<i))&&(types_inout[i]<xkb->map->num_types)) {
	    nSyms[i]= xkb->map->types[types_inout[i]].num_levels;
	    if (nSyms[i]>groupsWidth)
		groupsWidth= nSyms[i];
	}
	else {
	    types_inout[i]= XkbTwoLevelIndex;	/* don't really know, yet */
	    nSyms[i]= 2;
	}
    }
    if (nSyms[XkbGroup1Index]<2)
	nSyms[XkbGroup1Index]= 2;
    if (nSyms[XkbGroup2Index]<2)
	nSyms[XkbGroup2Index]= 2;
    /* Step 2:	Copy the symbols from the core ordering to XKB ordering	*/
    /*		symbols in the core are in the order:			*/
    /*		G1L1 G1L2 G2L1 G2L2 [G1L[3-n]] [G2L[3-n]] [G3L*] [G3L*]	*/
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,0)]= CORE_SYM(0);
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,1)]= CORE_SYM(1);
    for (i=2;i<nSyms[XkbGroup1Index];i++) {
	xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,i)]= CORE_SYM(2+i);
    }
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,0)]= CORE_SYM(2);
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,1)]= CORE_SYM(3);
    tmp= 2+(nSyms[XkbGroup1Index]-2); /* offset to extra group2 syms */
    for (i=2;i<nSyms[XkbGroup2Index];i++) {
	xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,i)]= CORE_SYM(tmp+i);
    }

    /* Special case: if only the first group is explicit, and the symbols
     * replicate across all groups, then we have a Section 12.4 replication */
    if ((protected & ~XkbExplicitKeyType1Mask) == 0)
    {
        int j, width = nSyms[XkbGroup1Index];

        replicated = TRUE;

        /* Check ABAB in ABABCDECDEABCDE */
        if ((width > 0 && CORE_SYM(0) != CORE_SYM(2)) ||
            (width > 1 && CORE_SYM(1) != CORE_SYM(3)))
            replicated = FALSE;

        /* Check CDECDE in ABABCDECDEABCDE */
        for (i = 2; i < width && replicated; i++)
        {
            if (CORE_SYM(2 + i) != CORE_SYM(i + width))
                replicated = FALSE;
        }

        /* Check ABCDE in ABABCDECDEABCDE */
        for (j = 2; replicated &&
                    j < XkbNumKbdGroups &&
                    map_width >= width * (j + 1); j++)
        {
            for (i = 0; i < width && replicated; i++)
            {
                if (CORE_SYM(((i < 2) ? i : 2 + i)) != CORE_SYM(i + width * j))
                    replicated = FALSE;
            }
        }
    }

    if (replicated)
    {
	nSyms[XkbGroup2Index]= 0;
	nSyms[XkbGroup3Index]= 0;
	nSyms[XkbGroup4Index]= 0;
	nGroups= 1;
    } else
    {
        tmp= nSyms[XkbGroup1Index]+nSyms[XkbGroup2Index];
        if ((tmp>=map_width)&&
                ((protected&(XkbExplicitKeyType3Mask|XkbExplicitKeyType4Mask))==0)) {
            nSyms[XkbGroup3Index]= 0;
            nSyms[XkbGroup4Index]= 0;
            nGroups= 2;
        } else
        {
            nGroups= 3;
            for (i=0;i<nSyms[XkbGroup3Index];i++,tmp++) {
                xkb_syms_rtrn[XKB_OFFSET(XkbGroup3Index,i)]= CORE_SYM(tmp);
            }
            if ((tmp<map_width)||(protected&XkbExplicitKeyType4Mask)) {
                nGroups= 4;
                for (i=0;i<nSyms[XkbGroup4Index];i++,tmp++) {
                    xkb_syms_rtrn[XKB_OFFSET(XkbGroup4Index,i)]= CORE_SYM(tmp);
                }
            }
            else {
                nSyms[XkbGroup4Index]= 0;
            }
        }
    }
    /* steps 3&4: alphanumeric expansion,  assign canonical types */
    empty= 0;
    for (i=0;i<nGroups;i++) {
	KeySym *syms;
	syms= &xkb_syms_rtrn[XKB_OFFSET(i,0)];
	if ((nSyms[i]>1)&&(syms[1]==NoSymbol)&&(syms[0]!=NoSymbol)) {
	    KeySym upper,lower;
	    XkbConvertCase(syms[0],&lower,&upper);
	    if (upper!=lower) {
		xkb_syms_rtrn[XKB_OFFSET(i,0)]= lower;
		xkb_syms_rtrn[XKB_OFFSET(i,1)]= upper;
		if ((protected&(1<<i))==0)
		    types_inout[i]= XkbAlphabeticIndex;
	    }
	    else if ((protected&(1<<i))==0) {
		types_inout[i]= XkbOneLevelIndex;
	/*	nSyms[i]=	1;*/
	    }
	}
	if (((protected&(1<<i))==0)&&(types_inout[i]==XkbTwoLevelIndex)) {
	    if (XkbKSIsKeypad(syms[0])||XkbKSIsKeypad(syms[1]))
		types_inout[i]= XkbKeypadIndex;
	    else {
		KeySym upper,lower;
		XkbConvertCase(syms[0],&lower,&upper);
		if ((syms[0]==lower)&&(syms[1]==upper))
		    types_inout[i]= XkbAlphabeticIndex;
	    }
	}
	if (syms[0]==NoSymbol) {
	    register int n;
	    Bool	found;
	    for (n=1,found=FALSE;(!found)&&(n<nSyms[i]);n++) {
		found= (syms[n]!=NoSymbol);
	    }
	    if (!found)
		empty|= (1<<i);
	}
    }
    /* step 5: squoosh out empty groups */
    if (empty) {
	for (i=nGroups-1;i>=0;i--) {
	    if (((empty&(1<<i))==0)||(protected&(1<<i)))
		break;
	    nGroups--;
	}
    }
    if (nGroups<1)
	return 0;

    /* step 6: replicate group 1 into group two, if necessary */
    if ((nGroups>1)&&((empty&(XkbGroup1Mask|XkbGroup2Mask))==XkbGroup2Mask)) {
	if ((protected&(XkbExplicitKeyType1Mask|XkbExplicitKeyType2Mask))==0) {
	    nSyms[XkbGroup2Index]= nSyms[XkbGroup1Index];
	    types_inout[XkbGroup2Index]= types_inout[XkbGroup1Index];
	    memcpy((char *)&xkb_syms_rtrn[2],(char *)xkb_syms_rtrn,
							2*sizeof(KeySym));
	}
	else if (types_inout[XkbGroup1Index]==types_inout[XkbGroup2Index]) {
	    memcpy((char *)&xkb_syms_rtrn[nSyms[XkbGroup1Index]],
	    				(char *)xkb_syms_rtrn,
					nSyms[XkbGroup1Index]*sizeof(KeySym));
	}
    }

    /* step 7: check for all groups identical or all width 1
     *
     * Special feature: if group 1 has an explicit type and all other groups
     * have canonical types with same symbols, we assume it's info lost from
     * the core replication.
     */
    if (nGroups>1) {
	Bool sameType,allOneLevel, canonical = TRUE;
	allOneLevel= (xkb->map->types[types_inout[0]].num_levels==1);
	for (i=1,sameType=TRUE;(allOneLevel||sameType)&&(i<nGroups);i++) {
	    sameType=(sameType&&(types_inout[i]==types_inout[XkbGroup1Index]));
	    if (allOneLevel)
		allOneLevel= (xkb->map->types[types_inout[i]].num_levels==1);
	    if (types_inout[i] > XkbLastRequiredType)
		canonical = FALSE;
	}
	if (((sameType) || canonical)&&
	    (!(protected&(XkbExplicitKeyTypesMask&~XkbExplicitKeyType1Mask)))){
	    register int s;
	    Bool	identical;
	    for (i=1,identical=TRUE;identical&&(i<nGroups);i++) {
		KeySym *syms;
                if (nSyms[i] != nSyms[XkbGroup1Index])
                    identical = FALSE;
		syms= &xkb_syms_rtrn[XKB_OFFSET(i,0)];
		for (s=0;identical&&(s<nSyms[i]);s++) {
		    if (syms[s]!=xkb_syms_rtrn[s])
			identical= FALSE;
		}
	    }
	    if (identical)
		nGroups= 1;
	}
	if (allOneLevel && (nGroups>1)) {
	    KeySym *syms;
	    syms= &xkb_syms_rtrn[nSyms[XkbGroup1Index]];
	    nSyms[XkbGroup1Index]= 1;
	    for (i=1;i<nGroups;i++) {
		xkb_syms_rtrn[i]= syms[0];
		syms+= nSyms[i];
		nSyms[i]= 1;
	    }
	}
    }
    return nGroups;
}

static XkbSymInterpretPtr
_XkbFindMatchingInterp(	XkbDescPtr	xkb,
			KeySym 		sym,
			unsigned int	real_mods,
			unsigned int	level)
{
register unsigned	 i;
XkbSymInterpretPtr	 interp,rtrn;
CARD8			 mods;

    rtrn= NULL;
    interp= xkb->compat->sym_interpret;
    for (i=0;i<xkb->compat->num_si;i++,interp++) {
	if ((interp->sym==NoSymbol)||(sym==interp->sym)) {
	    int match;
	    if ((level==0)||((interp->match&XkbSI_LevelOneOnly)==0))
		 mods= real_mods;
	    else mods= 0;
	    switch (interp->match&XkbSI_OpMask) {
		case XkbSI_NoneOf:
		    match= ((interp->mods&mods)==0);
		    break;
		case XkbSI_AnyOfOrNone:
		    match= ((mods==0)||((interp->mods&mods)!=0));
		    break;
		case XkbSI_AnyOf:
		    match= ((interp->mods&mods)!=0);
		    break;
		case XkbSI_AllOf:
		    match= ((interp->mods&mods)==interp->mods);
		    break;
		case XkbSI_Exactly:
		    match= (interp->mods==mods);
		    break;
		default:
		    match= 0;
		    break;
	    }
	    if (match) {
		if (interp->sym!=NoSymbol) {
		    return interp;
		}
		else if (rtrn==NULL) {
		    rtrn= interp;
		}
	    }
	}
    }
    return rtrn;
}

static void
_XkbAddKeyChange(KeyCode *pFirst,unsigned char *pNum,KeyCode newKey)
{
KeyCode	last;

    last= (*pFirst)+(*pNum);
    if (newKey<*pFirst) {
	*pFirst= newKey;
	*pNum= (last-newKey)+1;
    }
    else if (newKey>last) {
	*pNum= (last-*pFirst)+1;
    }
    return;
}

static void
_XkbSetActionKeyMods(XkbDescPtr xkb,XkbAction *act,unsigned mods)
{
unsigned	tmp;

    switch (act->type) {
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (act->mods.flags&XkbSA_UseModMapMods)
		act->mods.real_mods= act->mods.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->mods))!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->mods.mask|= tmp;
	    }
	    break;
	case XkbSA_ISOLock:
	    if (act->iso.flags&XkbSA_UseModMapMods)
		act->iso.real_mods= act->iso.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->iso))!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->iso.mask|= tmp;
	    }
	    break;
    }
    return;
}

#define	IBUF_SIZE	8

Bool
XkbApplyCompatMapToKey(XkbDescPtr xkb,KeyCode key,XkbChangesPtr changes)
{
KeySym *		syms;
unsigned char 		explicit,mods;
XkbSymInterpretPtr	*interps,ibuf[IBUF_SIZE]; 
int			n,nSyms,found;
unsigned		changed,tmp;

    if ((!xkb)||(!xkb->map)||(!xkb->map->key_sym_map)||
    			(!xkb->compat)||(!xkb->compat->sym_interpret)||
			(key<xkb->min_key_code)||(key>xkb->max_key_code)) {
	return FALSE;
    }
    if (((!xkb->server)||(!xkb->server->key_acts))&&
		(XkbAllocServerMap(xkb,XkbAllServerInfoMask,0)!=Success)) {
	return FALSE;
    }
    changed= 0;	/* keeps track of what has changed in _this_ call */
    explicit= xkb->server->explicit[key];
    if (explicit&XkbExplicitInterpretMask) /* nothing to do */
	return TRUE;
    mods= (xkb->map->modmap?xkb->map->modmap[key]:0);
    nSyms= XkbKeyNumSyms(xkb,key);
    syms= XkbKeySymsPtr(xkb,key);
    if (nSyms>IBUF_SIZE) {
	interps= calloc(nSyms, sizeof(XkbSymInterpretPtr));
	if (interps==NULL) {
	    interps= ibuf;
	    nSyms= IBUF_SIZE;
	}
    }
    else {
	interps= ibuf;
    }
    found= 0;
    for (n=0;n<nSyms;n++) {
	unsigned level= (n%XkbKeyGroupsWidth(xkb,key));
	interps[n]= NULL;
	if (syms[n]!=NoSymbol) {
	    interps[n]= _XkbFindMatchingInterp(xkb,syms[n],mods,level);
	    if (interps[n]&&interps[n]->act.type!=XkbSA_NoAction)
		found++;
	    else interps[n]= NULL;
	}
    }
    /* 1/28/96 (ef) -- XXX! WORKING HERE */
    if (!found) {
	if (xkb->server->key_acts[key]!=0) {
	    xkb->server->key_acts[key]= 0;
	    changed|= XkbKeyActionsMask;
	}
    }
    else {
	XkbAction *pActs;
	unsigned int	new_vmodmask;
	changed|= XkbKeyActionsMask;
	pActs= XkbResizeKeyActions(xkb,key,nSyms);
	if (!pActs) {
            if (nSyms > IBUF_SIZE)
                free(interps);
	    return FALSE;
        }
	new_vmodmask= 0;
	for (n=0;n<nSyms;n++) {
	    if (interps[n]) {
		unsigned effMods;

		pActs[n]= *((XkbAction *)&interps[n]->act);
		if ((n==0)||((interps[n]->match&XkbSI_LevelOneOnly)==0)) {
		     effMods= mods;
		     if (interps[n]->virtual_mod!=XkbNoModifier)
			new_vmodmask|= (1<<interps[n]->virtual_mod);
		}
		else effMods= 0;
		_XkbSetActionKeyMods(xkb,&pActs[n],effMods);
	    }
	    else pActs[n].type= XkbSA_NoAction;
	}
	if (((explicit&XkbExplicitVModMapMask)==0)&&
				(xkb->server->vmodmap[key]!=new_vmodmask)) {
	    changed|= XkbVirtualModMapMask;
	    xkb->server->vmodmap[key]= new_vmodmask;
	}
	if (interps[0]) {
	    if ((interps[0]->flags&XkbSI_LockingKey)&&
				((explicit&XkbExplicitBehaviorMask)==0)) {
		xkb->server->behaviors[key].type= XkbKB_Lock;
		changed|= XkbKeyBehaviorsMask;
	    }
	    if (((explicit&XkbExplicitAutoRepeatMask)==0)&&(xkb->ctrls)) {
		CARD8 old;
		old= BitIsOn(xkb->ctrls->per_key_repeat, key);
		if (interps[0]->flags&XkbSI_AutoRepeat)
		    SetBit(xkb->ctrls->per_key_repeat, key);
		else
		    ClearBit(xkb->ctrls->per_key_repeat, key);
		if (changes && old != BitIsOn(xkb->ctrls->per_key_repeat, key))
		    changes->ctrls.changed_ctrls|= XkbPerKeyRepeatMask;
	    }
	}
    }
    if ((!found)||(interps[0]==NULL)) {
	if (((explicit&XkbExplicitAutoRepeatMask)==0)&&(xkb->ctrls)) {
	    CARD8 old;
	    old = BitIsOn(xkb->ctrls->per_key_repeat, key);
	    SetBit(xkb->ctrls->per_key_repeat, key);
	    if (changes && (old != BitIsOn(xkb->ctrls->per_key_repeat, key)))
		changes->ctrls.changed_ctrls|= XkbPerKeyRepeatMask;
	}
	if (((explicit&XkbExplicitBehaviorMask)==0)&&
		(xkb->server->behaviors[key].type==XkbKB_Lock)) {
		xkb->server->behaviors[key].type= XkbKB_Default;
		changed|= XkbKeyBehaviorsMask;
	}
    }
    if (changes) {
	XkbMapChangesPtr	mc;
	mc= &changes->map;
	tmp= (changed&mc->changed);
	if (tmp&XkbKeyActionsMask)
	    _XkbAddKeyChange(&mc->first_key_act,&mc->num_key_acts,key);
	else if (changed&XkbKeyActionsMask) {
	    mc->changed|= XkbKeyActionsMask;
	    mc->first_key_act= key;
	    mc->num_key_acts= 1;
	}
	if (tmp&XkbKeyBehaviorsMask) {
	    _XkbAddKeyChange(&mc->first_key_behavior,&mc->num_key_behaviors,
	    								key);
	}
	else if (changed&XkbKeyBehaviorsMask) {
	    mc->changed|= XkbKeyBehaviorsMask;
	    mc->first_key_behavior= key;
	    mc->num_key_behaviors= 1;
	}
	if (tmp&XkbVirtualModMapMask)
	    _XkbAddKeyChange(&mc->first_vmodmap_key,&mc->num_vmodmap_keys,key);
	else if (changed&XkbVirtualModMapMask) {
	    mc->changed|= XkbVirtualModMapMask;
	    mc->first_vmodmap_key= key;
	    mc->num_vmodmap_keys= 1;
	}
	mc->changed|= changed;
    }
    if (interps!=ibuf)
	free(interps);
    return TRUE;
}

Status
XkbChangeTypesOfKey(	XkbDescPtr		 xkb,
			int		 	 key,
			int			 nGroups,
			unsigned	 	 groups,
			int	* 	 	 newTypesIn,
			XkbMapChangesPtr	 changes)
{
XkbKeyTypePtr	pOldType,pNewType;
register int	i;
int		width,nOldGroups,oldWidth,newTypes[XkbNumKbdGroups];

    if ((!xkb) || (!XkbKeycodeInRange(xkb,key)) || (!xkb->map) ||
	(!xkb->map->types)||(!newTypesIn)||((groups&XkbAllGroupsMask)==0)||
	(nGroups>XkbNumKbdGroups)) {
	return BadMatch;
    }
    if (nGroups==0) {
	for (i=0;i<XkbNumKbdGroups;i++) {
	    xkb->map->key_sym_map[key].kt_index[i]= XkbOneLevelIndex;
	}
	i= xkb->map->key_sym_map[key].group_info;
	i= XkbSetNumGroups(i,0);
	xkb->map->key_sym_map[key].group_info= i;
	XkbResizeKeySyms(xkb,key,0);
	return Success;
    }

    nOldGroups= XkbKeyNumGroups(xkb,key);
    oldWidth= XkbKeyGroupsWidth(xkb,key);
    for (width=i=0;i<nGroups;i++) {
	if (groups&(1<<i))
	     newTypes[i]=  newTypesIn[i];
	else if (i<nOldGroups)
	     newTypes[i]= XkbKeyKeyTypeIndex(xkb,key,i);
	else if (nOldGroups>0)
	     newTypes[i]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup1Index);
	else newTypes[i]= XkbTwoLevelIndex;
	if (newTypes[i]>xkb->map->num_types)
	    return BadMatch;
	pNewType= &xkb->map->types[newTypes[i]];
	if (pNewType->num_levels>width)
	    width= pNewType->num_levels;
    }
    if ((xkb->ctrls)&&(nGroups>xkb->ctrls->num_groups))
	xkb->ctrls->num_groups= nGroups;
    if ((width!=oldWidth)||(nGroups!=nOldGroups)) {
	KeySym		oldSyms[XkbMaxSymsPerKey],*pSyms;
	int		nCopy;

	if (nOldGroups==0) {
	    pSyms= XkbResizeKeySyms(xkb,key,width*nGroups);
	    if (pSyms!=NULL) {
		i= xkb->map->key_sym_map[key].group_info;
		i= XkbSetNumGroups(i,nGroups);
		xkb->map->key_sym_map[key].group_info= i;
		xkb->map->key_sym_map[key].width= width;
		for (i=0;i<nGroups;i++) {
		    xkb->map->key_sym_map[key].kt_index[i]= newTypes[i];
		}
		return Success;
	    }
	    return BadAlloc;
	}
	pSyms= XkbKeySymsPtr(xkb,key);
	memcpy(oldSyms,pSyms,XkbKeyNumSyms(xkb,key)*sizeof(KeySym));
	pSyms= XkbResizeKeySyms(xkb,key,width*nGroups);
	if (pSyms==NULL)
	    return BadAlloc;
	memset(pSyms, 0, width*nGroups*sizeof(KeySym));
	for (i=0;(i<nGroups)&&(i<nOldGroups);i++) {
	    pOldType= XkbKeyKeyType(xkb,key,i);
	    pNewType= &xkb->map->types[newTypes[i]];
	    if (pNewType->num_levels>pOldType->num_levels)
		 nCopy= pOldType->num_levels;
	    else nCopy= pNewType->num_levels;
	    memcpy(&pSyms[i*width],&oldSyms[i*oldWidth],nCopy*sizeof(KeySym));
	}
	if (XkbKeyHasActions(xkb,key)) {
	    XkbAction	oldActs[XkbMaxSymsPerKey],*pActs;
	    pActs= XkbKeyActionsPtr(xkb,key);
	    memcpy(oldActs,pActs,XkbKeyNumSyms(xkb,key)*sizeof(XkbAction));
	    pActs= XkbResizeKeyActions(xkb,key,width*nGroups);
	    if (pActs==NULL)
		return BadAlloc;
	    memset(pActs, 0, width*nGroups*sizeof(XkbAction));
	    for (i=0;(i<nGroups)&&(i<nOldGroups);i++) {
		pOldType= XkbKeyKeyType(xkb,key,i);
		pNewType= &xkb->map->types[newTypes[i]];
		if (pNewType->num_levels>pOldType->num_levels)
		     nCopy= pOldType->num_levels;
		else nCopy= pNewType->num_levels;
		memcpy(&pActs[i*width],&oldActs[i*oldWidth],
						nCopy*sizeof(XkbAction));
	    }
	}
	i= xkb->map->key_sym_map[key].group_info;
	i= XkbSetNumGroups(i,nGroups);
	xkb->map->key_sym_map[key].group_info= i;
	xkb->map->key_sym_map[key].width= width;
    }
    width= 0;
    for (i=0;i<nGroups;i++) {
	xkb->map->key_sym_map[key].kt_index[i]= newTypes[i];
	if (xkb->map->types[newTypes[i]].num_levels>width)
	    width= xkb->map->types[newTypes[i]].num_levels;
    }
    xkb->map->key_sym_map[key].width= width;
    if (changes!=NULL) {
	if (changes->changed&XkbKeySymsMask) {
	    _XkbAddKeyChange(&changes->first_key_sym,&changes->num_key_syms,
	    								key);
	}
	else {
	    changes->changed|= XkbKeySymsMask;
	    changes->first_key_sym= key;
	    changes->num_key_syms= 1;
	}
    }
    return Success;
}

/***====================================================================***/

Bool
XkbVirtualModsToReal(XkbDescPtr xkb,unsigned virtual_mask,unsigned *mask_rtrn)
{
register int i,bit;
register unsigned mask;

    if (xkb==NULL)
	return FALSE;
    if (virtual_mask==0) {
	*mask_rtrn= 0;
	return TRUE;
    }
    if (xkb->server==NULL)
	return FALSE;
    for (i=mask=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (virtual_mask&bit)
	    mask|= xkb->server->vmods[i];
    }
    *mask_rtrn= mask;
    return TRUE;
}

/***====================================================================***/

static Bool
XkbUpdateActionVirtualMods(XkbDescPtr xkb,XkbAction *act,unsigned changed)
{
unsigned int	tmp;

    switch (act->type) {
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (((tmp= XkbModActionVMods(&act->mods))&changed)!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->mods.mask= act->mods.real_mods;
		act->mods.mask|= tmp;
		return TRUE;
	    }
	    break;
	case XkbSA_ISOLock:
	    if ((((tmp= XkbModActionVMods(&act->iso))!=0)&changed)!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->iso.mask= act->iso.real_mods;
		act->iso.mask|= tmp;
		return TRUE;
	    }
	    break;
    }
    return FALSE;
}

static void
XkbUpdateKeyTypeVirtualMods(	XkbDescPtr	xkb,
				XkbKeyTypePtr	type,
				unsigned int	changed,
				XkbChangesPtr 	changes)
{
register unsigned int	i;
unsigned int		mask;

    XkbVirtualModsToReal(xkb,type->mods.vmods,&mask);
    type->mods.mask= type->mods.real_mods|mask;
    if ((type->map_count>0)&&(type->mods.vmods!=0)) {
	XkbKTMapEntryPtr entry;
	for (i=0,entry=type->map;i<type->map_count;i++,entry++) {
	    if (entry->mods.vmods!=0) {
		XkbVirtualModsToReal(xkb,entry->mods.vmods,&mask);
		entry->mods.mask=entry->mods.real_mods|mask;
		/* entry is active if vmods are bound*/
	    	entry->active= (mask!=0);
	    }
	    else entry->active= 1;
	}
    }
    if (changes) {
	int	type_ndx;
	type_ndx= type-xkb->map->types;
	if ((type_ndx<0)||(type_ndx>xkb->map->num_types))
	    return;
	if (changes->map.changed&XkbKeyTypesMask) {
	    int last;
	    last= changes->map.first_type+changes->map.num_types-1;
	    if (type_ndx<changes->map.first_type) {
		changes->map.first_type= type_ndx;
		changes->map.num_types= (last-type_ndx)+1;
	    }
	    else if (type_ndx>last) {
		changes->map.num_types= (type_ndx-changes->map.first_type)+1;
	    }
	}
	else {
	    changes->map.changed|= XkbKeyTypesMask;
	    changes->map.first_type= type_ndx;
	    changes->map.num_types= 1;
	}
    }
    return;
}

Bool
XkbApplyVirtualModChanges(XkbDescPtr xkb,unsigned changed,XkbChangesPtr changes)
{
register int	i;
unsigned int	checkState = 0;

    if ((!xkb) || (!xkb->map) || (changed==0))
	return FALSE;
    for (i=0;i<xkb->map->num_types;i++) {
	if (xkb->map->types[i].mods.vmods & changed)
	XkbUpdateKeyTypeVirtualMods(xkb,&xkb->map->types[i],changed,changes);
    }
    if (changed&xkb->ctrls->internal.vmods) {
	unsigned int	newMask;
	XkbVirtualModsToReal(xkb,xkb->ctrls->internal.vmods,&newMask);
	newMask|= xkb->ctrls->internal.real_mods;
	if (xkb->ctrls->internal.mask!=newMask) {
	    xkb->ctrls->internal.mask= newMask;
	    if (changes) {
		changes->ctrls.changed_ctrls|= XkbInternalModsMask;
		checkState= TRUE;
	    }
	}
    }
    if (changed&xkb->ctrls->ignore_lock.vmods) {
	unsigned int	newMask;
	XkbVirtualModsToReal(xkb,xkb->ctrls->ignore_lock.vmods,&newMask);
	newMask|= xkb->ctrls->ignore_lock.real_mods;
	if (xkb->ctrls->ignore_lock.mask!=newMask) {
	    xkb->ctrls->ignore_lock.mask= newMask;
	    if (changes) {
		changes->ctrls.changed_ctrls|= XkbIgnoreLockModsMask;
		checkState= TRUE;
	    }
	}
    }
    if (xkb->indicators!=NULL) {
	XkbIndicatorMapPtr map;
	map= &xkb->indicators->maps[0];
	for (i=0;i<XkbNumIndicators;i++,map++) {
	    if (map->mods.vmods&changed) {
		unsigned int newMask;
		XkbVirtualModsToReal(xkb,map->mods.vmods,&newMask);
		newMask|= map->mods.real_mods;
		if (newMask!=map->mods.mask) {
		    map->mods.mask= newMask;
		    if (changes) {
			changes->indicators.map_changes|= (1<<i);
			checkState= TRUE;
		    }
		}
	    }
	}
    }
    if (xkb->compat!=NULL) {
	XkbCompatMapPtr	compat;
	compat= xkb->compat;
	for (i=0;i<XkbNumKbdGroups;i++) {
	    unsigned int newMask;
	    XkbVirtualModsToReal(xkb,compat->groups[i].vmods,&newMask);
	    newMask|= compat->groups[i].real_mods;
	    if (compat->groups[i].mask!=newMask) {
		compat->groups[i].mask= newMask;
		if (changes) {
		    changes->compat.changed_groups|= (1<<i);
		    checkState= TRUE;
		}
	    }
	}
    }
    if (xkb->map && xkb->server) {
	int highChange = 0, lowChange = -1;
	for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    if (XkbKeyHasActions(xkb,i)) {
		register XkbAction *pAct;
		register int n;

		pAct= XkbKeyActionsPtr(xkb,i);
		for (n=XkbKeyNumActions(xkb,i);n>0;n--,pAct++) {
		    if ((pAct->type!=XkbSA_NoAction)&&
			XkbUpdateActionVirtualMods(xkb,pAct,changed)) {
			if (lowChange<0)
			    lowChange= i;
			highChange= i;
		    }
		}
	    }
	}
	if (changes && (lowChange>0)) { /* something changed */
	    if (changes->map.changed&XkbKeyActionsMask) {
		int last;
		if (changes->map.first_key_act<lowChange)
		    lowChange= changes->map.first_key_act;
		last= changes->map.first_key_act+changes->map.num_key_acts-1;
		if (last>highChange)
		    highChange= last;
	    }
	    changes->map.changed|= 	XkbKeyActionsMask;
	    changes->map.first_key_act=	lowChange;
	    changes->map.num_key_acts=	(highChange-lowChange)+1;
	}
    }
    return checkState;
}
/************************************************************
 Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <X11/Xfuncs.h>

#include <X11/X.h>
#include <X11/keysym.h>
#include <X11/Xproto.h>
#include <X11/extensions/XKMformat.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS	1
#include <xkbsrv.h>

#include "xkbgeom.h"
#include "xkbfile.h"

#define	VMOD_HIDE_VALUE	0
#define	VMOD_SHOW_VALUE	1
#define	VMOD_COMMENT_VALUE 2

static Bool
WriteXKBVModDecl(FILE *file,XkbDescPtr xkb,int showValue)
{
register int 	i,nMods;
Atom *		vmodNames;

    if (xkb==NULL)
	return FALSE;
    if (xkb->names!=NULL)
	 vmodNames= xkb->names->vmods;
    else vmodNames= NULL;

    for (i=nMods=0;i<XkbNumVirtualMods;i++) {
	if ((vmodNames!=NULL)&&(vmodNames[i]!=None)) {
	    if (nMods==0)	fprintf(file,"    virtual_modifiers ");
	    else		fprintf(file,",");
	    fprintf(file,"%s",XkbAtomText(vmodNames[i],XkbXKBFile));
	    if ((showValue!=VMOD_HIDE_VALUE)&&
		(xkb->server)&&(xkb->server->vmods[i]!=XkbNoModifierMask)) {
		if (showValue==VMOD_COMMENT_VALUE) {
		    fprintf(file,"/* = %s */",
			XkbModMaskText(xkb->server->vmods[i],XkbXKBFile));
		}
		else  {
		    fprintf(file,"= %s",
			XkbModMaskText(xkb->server->vmods[i],XkbXKBFile));
		}
	    }
	    nMods++;
	}
    }
    if (nMods>0)
	fprintf(file,";\n\n");
    return TRUE;
}

/***====================================================================***/

static Bool
WriteXKBAction(FILE *file,XkbDescPtr xkb,XkbAnyAction *action)
{
    fprintf(file,"%s",XkbActionText(xkb,(XkbAction *)action,XkbXKBFile));
    return TRUE;
}

/***====================================================================***/

Bool
XkbWriteXKBKeycodes(	FILE *			file,
			XkbDescPtr		xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
Atom			kcName;
register unsigned 	i;
char *			alternate;

    if ((!xkb)||(!xkb->names)||(!xkb->names->keys)) {
	_XkbLibError(_XkbErrMissingNames,"XkbWriteXKBKeycodes",0);
	return FALSE;
    }
    kcName= xkb->names->keycodes;
    if (kcName!=None)
	 fprintf(file,"xkb_keycodes \"%s\" {\n",
					XkbAtomText(kcName,XkbXKBFile));
    else fprintf(file,"xkb_keycodes {\n");
    fprintf(file,"    minimum = %d;\n",xkb->min_key_code);
    fprintf(file,"    maximum = %d;\n",xkb->max_key_code);
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	if (xkb->names->keys[i].name[0]!='\0') {
	    if (XkbFindKeycodeByName(xkb,xkb->names->keys[i].name,TRUE)!=i)
		 alternate= "alternate ";
	    else alternate= "";
	    fprintf(file,"    %s%6s = %d;\n",alternate,
			XkbKeyNameText(xkb->names->keys[i].name,XkbXKBFile),
			i);
	}
    }
    if (xkb->indicators!=NULL) {
	for (i=0;i<XkbNumIndicators;i++) {
	    char *type;
	    if (xkb->indicators->phys_indicators&(1<<i))
			type= "    ";
	    else	type= "    virtual ";
	    if (xkb->names->indicators[i]!=None) {
		fprintf(file,"%sindicator %d = \"%s\";\n",type,i+1,
			XkbAtomText(xkb->names->indicators[i],XkbXKBFile));
	    }
	}
    }
    if (xkb->names->key_aliases!=NULL) {
	XkbKeyAliasPtr	pAl;
	pAl= xkb->names->key_aliases;
	for (i=0;i<xkb->names->num_key_aliases;i++,pAl++) {
	    fprintf(file,"    alias %6s = %6s;\n",
			XkbKeyNameText(pAl->alias,XkbXKBFile),
			XkbKeyNameText(pAl->real,XkbXKBFile));
	}
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmKeyNamesIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}

Bool
XkbWriteXKBKeyTypes(	FILE *			file,
			XkbDescPtr              xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
register unsigned	i,n;
XkbKeyTypePtr		type;
XkbKTMapEntryPtr	entry;

    if ((!xkb)||(!xkb->map)||(!xkb->map->types)) {
	_XkbLibError(_XkbErrMissingTypes,"XkbWriteXKBKeyTypes",0);
	return FALSE;
    }
    if (xkb->map->num_types<XkbNumRequiredTypes) {
	_XkbLibError(_XkbErrMissingReqTypes,"XkbWriteXKBKeyTypes",0);
	return 0;
    }
    if ((xkb->names==NULL)||(xkb->names->types==None))
	 fprintf(file,"xkb_types {\n\n");
    else fprintf(file,"xkb_types \"%s\" {\n\n",
			XkbAtomText(xkb->names->types,XkbXKBFile));
    WriteXKBVModDecl(file,xkb,
			(showImplicit?VMOD_COMMENT_VALUE:VMOD_HIDE_VALUE));

    type= xkb->map->types;
    for (i=0;i<xkb->map->num_types;i++,type++) {
	fprintf(file,"    type \"%s\" {\n",
		XkbAtomText(type->name,XkbXKBFile));
	fprintf(file,"        modifiers= %s;\n",
	       XkbVModMaskText(xkb,type->mods.real_mods,type->mods.vmods,
								XkbXKBFile));
	entry= type->map;
	for (n=0;n<type->map_count;n++,entry++) {
	    char *str;	
	    str=XkbVModMaskText(xkb,entry->mods.real_mods,entry->mods.vmods,
								XkbXKBFile);
	    fprintf(file,"        map[%s]= Level%d;\n",str,entry->level+1);
	    if ((type->preserve)&&((type->preserve[n].real_mods)||
				   (type->preserve[n].vmods))) {
		fprintf(file,"        preserve[%s]= ",str);
		fprintf(file,"%s;\n",XkbVModMaskText(xkb,
					type->preserve[n].real_mods,
					type->preserve[n].vmods,
					XkbXKBFile));
	    }
	}
	if (type->level_names!=NULL) {
	    Atom *name= type->level_names;
	    for (n=0;n<type->num_levels;n++,name++) {
		if ((*name)==None)
		    continue;
		fprintf(file,"        level_name[Level%d]= \"%s\";\n",n+1,
					XkbAtomText(*name,XkbXKBFile));
	    }
	}
	fprintf(file,"    };\n");
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmTypesIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}

static Bool
WriteXKBIndicatorMap(	FILE *			file,
			XkbDescPtr              xkb,
			Atom			name,
			XkbIndicatorMapPtr	led,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{

    fprintf(file,"    indicator \"%s\" {\n",NameForAtom(name));
    if (led->flags&XkbIM_NoExplicit)
	fprintf(file,"        !allowExplicit;\n");
    if (led->flags&XkbIM_LEDDrivesKB)
	fprintf(file,"        indicatorDrivesKeyboard;\n");
    if (led->which_groups!=0) {
	if (led->which_groups!=XkbIM_UseEffective) {
	    fprintf(file,"        whichGroupState= %s;\n",
			XkbIMWhichStateMaskText(led->which_groups,XkbXKBFile));
	}
	fprintf(file,"        groups= 0x%02x;\n",led->groups);
    }
    if (led->which_mods!=0) {
	if (led->which_mods!=XkbIM_UseEffective) {
	    fprintf(file,"        whichModState= %s;\n",
			XkbIMWhichStateMaskText(led->which_mods,XkbXKBFile));
	}
	fprintf(file,"        modifiers= %s;\n",
			XkbVModMaskText(xkb,
					led->mods.real_mods,led->mods.vmods,
					XkbXKBFile));
    }
    if (led->ctrls!=0) {
	fprintf(file,"        controls= %s;\n",
			XkbControlsMaskText(led->ctrls,XkbXKBFile));
    }
    if (addOn)
	(*addOn)(file,xkb,FALSE,TRUE,XkmIndicatorsIndex,priv);
    fprintf(file,"    };\n");
    return TRUE;
}

Bool
XkbWriteXKBCompatMap(	FILE *			file,
			XkbDescPtr              xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
register unsigned	i;
XkbSymInterpretPtr	interp;

    if ((!xkb)||(!xkb->compat)||(!xkb->compat->sym_interpret)) {
	_XkbLibError(_XkbErrMissingCompatMap,"XkbWriteXKBCompatMap",0);
	return FALSE;
    }
    if ((xkb->names==NULL)||(xkb->names->compat==None))
	 fprintf(file,"xkb_compatibility {\n\n");
    else fprintf(file,"xkb_compatibility \"%s\" {\n\n",
			XkbAtomText(xkb->names->compat,XkbXKBFile));
    WriteXKBVModDecl(file,xkb,
			(showImplicit?VMOD_COMMENT_VALUE:VMOD_HIDE_VALUE));

    fprintf(file,"    interpret.useModMapMods= AnyLevel;\n");
    fprintf(file,"    interpret.repeat= FALSE;\n");
    fprintf(file,"    interpret.locking= FALSE;\n");
    interp= xkb->compat->sym_interpret;
    for (i=0;i<xkb->compat->num_si;i++,interp++) {
	fprintf(file,"    interpret %s+%s(%s) {\n",	
				((interp->sym==NoSymbol)?"Any":
					XkbKeysymText(interp->sym,XkbXKBFile)),
				XkbSIMatchText(interp->match,XkbXKBFile),
				XkbModMaskText(interp->mods,XkbXKBFile));
	if (interp->virtual_mod!=XkbNoModifier) {
	    fprintf(file,"        virtualModifier= %s;\n",
		XkbVModIndexText(xkb,interp->virtual_mod,XkbXKBFile));
	}
	if (interp->match&XkbSI_LevelOneOnly)
	    fprintf(file,"        useModMapMods=level1;\n");
	if (interp->flags&XkbSI_LockingKey)
	    fprintf(file,"        locking= TRUE;\n");
	if (interp->flags&XkbSI_AutoRepeat)
	    fprintf(file,"        repeat= TRUE;\n");
	fprintf(file,"        action= ");
	WriteXKBAction(file,xkb,&interp->act);
	fprintf(file,";\n");
	fprintf(file,"    };\n");
    }
    for (i=0;i<XkbNumKbdGroups;i++) {
	XkbModsPtr	gc;

	gc= &xkb->compat->groups[i];
	if ((gc->real_mods==0)&&(gc->vmods==0))
	    continue;
	fprintf(file,"    group %d = %s;\n",i+1,XkbVModMaskText(xkb,
							gc->real_mods,gc->vmods,
							XkbXKBFile));
    }
    if (xkb->indicators) {
	for (i=0;i<XkbNumIndicators;i++) {
	    XkbIndicatorMapPtr map= &xkb->indicators->maps[i];
	    if ((map->flags!=0)||(map->which_groups!=0)||(map->groups!=0)||
		(map->which_mods!=0)||
		(map->mods.real_mods!=0)||(map->mods.vmods!=0)||
		(map->ctrls!=0)) {
		WriteXKBIndicatorMap(file,xkb,xkb->names->indicators[i],map,
								addOn,priv);
	    }
	}
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmCompatMapIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}

Bool
XkbWriteXKBSymbols(	FILE *			file,
			XkbDescPtr              xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
register unsigned	i,tmp;
XkbClientMapPtr		map;
XkbServerMapPtr		srv;
Bool			showActions;

    if (!xkb) {
	_XkbLibError(_XkbErrMissingSymbols,"XkbWriteXKBSymbols",0);
	return FALSE;
    }

    map= xkb->map;
    if ((!map)||(!map->syms)||(!map->key_sym_map)) {
	_XkbLibError(_XkbErrMissingSymbols,"XkbWriteXKBSymbols",0);
	return FALSE;
    }
    if ((!xkb->names)||(!xkb->names->keys)) {
	_XkbLibError(_XkbErrMissingNames,"XkbWriteXKBSymbols",0);
	return FALSE;
    }
    if ((xkb->names==NULL)||(xkb->names->symbols==None))
	 fprintf(file,"xkb_symbols {\n\n");
    else fprintf(file,"xkb_symbols \"%s\" {\n\n",
			XkbAtomText(xkb->names->symbols,XkbXKBFile));
    for (tmp=i=0;i<XkbNumKbdGroups;i++) {
	if (xkb->names->groups[i]!=None) {
	    fprintf(file,"    name[group%d]=\"%s\";\n",i+1,
			XkbAtomText(xkb->names->groups[i],XkbXKBFile));
	    tmp++;
	}
    }
    if (tmp>0)
	fprintf(file,"\n");
    srv= xkb->server;
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	Bool	simple;
	if ((int)XkbKeyNumSyms(xkb,i)<1)
	    continue;
	if (XkbFindKeycodeByName(xkb,xkb->names->keys[i].name,TRUE)!=i)
	    continue;
	simple= TRUE;
	fprintf(file,"    key %6s {",
			XkbKeyNameText(xkb->names->keys[i].name,XkbXKBFile));
	if (srv->explicit) {
	    if (((srv->explicit[i]&XkbExplicitKeyTypesMask)!=0)||
	   						(showImplicit)) {
		int 	typeNdx,g;
		Bool	multi;
		char *	comment="  ";

		if ((srv->explicit[i]&XkbExplicitKeyTypesMask)==0)
		    comment= "//";
		multi= FALSE;
		typeNdx= XkbKeyKeyTypeIndex(xkb,i,0);
		for (g=1;(g<XkbKeyNumGroups(xkb,i))&&(!multi);g++) {
		    if (XkbKeyKeyTypeIndex(xkb,i,g)!=typeNdx)
			multi= TRUE;
		}
		if (multi) {
		    for (g=0;g<XkbKeyNumGroups(xkb,i);g++) {
			typeNdx= XkbKeyKeyTypeIndex(xkb,i,g);
			if (srv->explicit[i]&(1<<g)) {
			    fprintf(file,"\n%s      type[group%d]= \"%s\",",
			    	comment,g+1,
				XkbAtomText(map->types[typeNdx].name,
			    	XkbXKBFile));
			}
			else if (showImplicit) {
			    fprintf(file,"\n//      type[group%d]= \"%s\",",g+1,
				XkbAtomText(map->types[typeNdx].name,
			    	XkbXKBFile));
			}
		    }
		}
		else {
		    fprintf(file,"\n%s      type= \"%s\",",comment,
				XkbAtomText(map->types[typeNdx].name,
			    	XkbXKBFile));
		}
		simple= FALSE;
	    }
	    if (((srv->explicit[i]&XkbExplicitAutoRepeatMask)!=0)&&
		    					  (xkb->ctrls!=NULL)) {
		if (xkb->ctrls->per_key_repeat[i/8]&(1<<(i%8)))
		     fprintf(file,"\n        repeat= Yes,");
		else fprintf(file,"\n        repeat= No,");
		simple= FALSE;
	    }
	    if ((xkb->server!=NULL)&&(xkb->server->vmodmap!=NULL)&&
					(xkb->server->vmodmap[i]!=0)) {
		if ((srv->explicit[i]&XkbExplicitVModMapMask)!=0) {
		    fprintf(file,"\n        virtualMods= %s,",
				XkbVModMaskText(xkb,0,
						xkb->server->vmodmap[i],
						XkbXKBFile));
		}
		else if (showImplicit) {
		    fprintf(file,"\n//      virtualMods= %s,",
				XkbVModMaskText(xkb,0,
						xkb->server->vmodmap[i],
						XkbXKBFile));
		}
	    }
	}
	switch (XkbOutOfRangeGroupAction(XkbKeyGroupInfo(xkb,i))) {
	    case XkbClampIntoRange:
		fprintf(file,"\n        groupsClamp,");
		break;
	    case XkbRedirectIntoRange:
		fprintf(file,"\n        groupsRedirect= Group%d,",
			XkbOutOfRangeGroupNumber(XkbKeyGroupInfo(xkb,i))+1);
		break;
	}
	if (srv->behaviors!=NULL) {
	    unsigned type;
	    type= srv->behaviors[i].type&XkbKB_OpMask;

	    if (type!=XkbKB_Default) {
		simple= FALSE;
		fprintf(file,"\n        %s,",
			XkbBehaviorText(xkb,&srv->behaviors[i],XkbXKBFile));
	    }
	}
	if ((srv->explicit==NULL) || showImplicit ||
	    ((srv->explicit[i]&XkbExplicitInterpretMask)!=0))
	     showActions= XkbKeyHasActions(xkb,i);
	else showActions= FALSE;
	
	if (((unsigned)XkbKeyNumGroups(xkb,i)>1)||showActions)
	    simple= FALSE;
	if (simple) {
	    KeySym *syms;
	    unsigned s;

	    syms= XkbKeySymsPtr(xkb,i);
	    fprintf(file,"         [ ");
	    for (s=0;s<XkbKeyGroupWidth(xkb,i,XkbGroup1Index);s++) {
		if (s!=0)
		    fprintf(file,", ");
		fprintf(file,"%15s",XkbKeysymText(*syms++,XkbXKBFile));
	    }
	    fprintf(file," ] };\n");
	}
	else {
	    unsigned g,s;
	    KeySym *syms;
	    XkbAction *acts;
	    syms= XkbKeySymsPtr(xkb,i);
	    acts= XkbKeyActionsPtr(xkb,i);
	    for (g=0;g<XkbKeyNumGroups(xkb,i);g++) {
		if (g!=0)
		    fprintf(file,",");
		fprintf(file,"\n        symbols[Group%d]= [ ",g+1);
		for (s=0;s<XkbKeyGroupWidth(xkb,i,g);s++) {
		    if (s!=0)
			fprintf(file,", ");
		    fprintf(file,"%15s",XkbKeysymText(syms[s],XkbXKBFile));
		}
		fprintf(file," ]");
		syms+= XkbKeyGroupsWidth(xkb,i);
		if (showActions) {
		    fprintf(file,",\n        actions[Group%d]= [ ",g+1);
		    for (s=0;s<XkbKeyGroupWidth(xkb,i,g);s++) {
			if (s!=0)
			    fprintf(file,", ");
			WriteXKBAction(file,xkb,(XkbAnyAction *)&acts[s]);
		    }
		    fprintf(file," ]");
		    acts+= XkbKeyGroupsWidth(xkb,i);
		}
	    }
	    fprintf(file,"\n    };\n");
	}
    }
    if (map && map->modmap) {
	for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    if (map->modmap[i]!=0) {
		register int n,bit;
		for (bit=1,n=0;n<XkbNumModifiers;n++,bit<<=1) {
		    if (map->modmap[i]&bit) {
			char buf[5];
			memcpy(buf,xkb->names->keys[i].name,4);
			buf[4]= '\0';
			fprintf(file,"    modifier_map %s { <%s> };\n",
					XkbModIndexText(n,XkbXKBFile),buf);
		    }
		}
	    }
	}
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmSymbolsIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}

static Bool
WriteXKBOutline(	FILE *		file,
			XkbShapePtr	shape,
			XkbOutlinePtr	outline,
			int		lastRadius,
			int		first,
			int		indent)
{
register int	i;
XkbPointPtr	pt;
char *		iStr;

    fprintf(file,"%s",iStr= XkbIndentText(first));
    if (first!=indent)
	iStr= XkbIndentText(indent);
    if (outline->corner_radius!=lastRadius) {
	fprintf(file,"corner= %s,",
			XkbGeomFPText(outline->corner_radius,XkbMessage));
	if (shape!=NULL) {
	    fprintf(file,"\n%s",iStr);
	}
    }
    if (shape) {
	if (outline==shape->approx)
	    fprintf(file,"approx= ");
	else if (outline==shape->primary)
	    fprintf(file,"primary= ");
    }
    fprintf(file,"{");
    for (pt=outline->points,i=0;i<outline->num_points;i++,pt++) {
	if (i==0)		fprintf(file," ");
	else if ((i%4)==0)	fprintf(file,",\n%s  ",iStr);
	else			fprintf(file,", ");
	fprintf(file,"[ %3s, %3s ]",XkbGeomFPText(pt->x,XkbXKBFile),
				  XkbGeomFPText(pt->y,XkbXKBFile));
    }
    fprintf(file," }");
    return TRUE;
}

static Bool
WriteXKBDoodad(	FILE *		file,
		unsigned	indent,
		XkbGeometryPtr	geom,
		XkbDoodadPtr	doodad)
{
register char *	i_str;
XkbShapePtr	shape;
XkbColorPtr	color;

    i_str= XkbIndentText(indent);
    fprintf(file,"%s%s \"%s\" {\n",i_str,
				XkbDoodadTypeText(doodad->any.type,XkbMessage),
				XkbAtomText(doodad->any.name,XkbMessage));
    fprintf(file,"%s    top=      %s;\n",i_str,
				 XkbGeomFPText(doodad->any.top,XkbXKBFile));
    fprintf(file,"%s    left=     %s;\n",i_str,
				XkbGeomFPText(doodad->any.left,XkbXKBFile));
    fprintf(file,"%s    priority= %d;\n",i_str,doodad->any.priority);
    switch (doodad->any.type) {
	case XkbOutlineDoodad:
	case XkbSolidDoodad:
	    if (doodad->shape.angle!=0) {
		fprintf(file,"%s    angle=  %s;\n",i_str,
			     XkbGeomFPText(doodad->shape.angle,XkbXKBFile));
	    }
	    if (doodad->shape.color_ndx!=0) {
		fprintf(file,"%s    color= \"%s\";\n",i_str,
			     XkbShapeDoodadColor(geom,&doodad->shape)->spec);
	    }
	    shape= XkbShapeDoodadShape(geom,&doodad->shape);
	    fprintf(file,"%s    shape= \"%s\";\n",i_str,
			    XkbAtomText(shape->name,XkbXKBFile));
	    break;
	case XkbTextDoodad:
	    if (doodad->text.angle!=0) {
		fprintf(file,"%s    angle=  %s;\n",i_str,
			     XkbGeomFPText(doodad->text.angle,XkbXKBFile));
	    }
	    if (doodad->text.width!=0) {
		fprintf(file,"%s    width=  %s;\n",i_str,
			     XkbGeomFPText(doodad->text.width,XkbXKBFile));

	    }
	    if (doodad->text.height!=0) {
		fprintf(file,"%s    height=  %s;\n",i_str,
			     XkbGeomFPText(doodad->text.height,XkbXKBFile));

	    }
	    if (doodad->text.color_ndx!=0) {
		color= XkbTextDoodadColor(geom,&doodad->text);
		fprintf(file,"%s    color= \"%s\";\n",i_str,
			     XkbStringText(color->spec,XkbXKBFile));
	    }
	    fprintf(file,"%s    XFont= \"%s\";\n",i_str,
	    		     XkbStringText(doodad->text.font,XkbXKBFile));
	    fprintf(file,"%s    text=  \"%s\";\n",i_str,
	    		    XkbStringText(doodad->text.text,XkbXKBFile));
	    break;
	case XkbIndicatorDoodad:
	    shape= XkbIndicatorDoodadShape(geom,&doodad->indicator);
	    color= XkbIndicatorDoodadOnColor(geom,&doodad->indicator);
	    fprintf(file,"%s    onColor= \"%s\";\n",i_str,
	    		    XkbStringText(color->spec,XkbXKBFile));
	    color= XkbIndicatorDoodadOffColor(geom,&doodad->indicator);
	    fprintf(file,"%s    offColor= \"%s\";\n",i_str,
	    		    XkbStringText(color->spec,XkbXKBFile));
	    fprintf(file,"%s    shape= \"%s\";\n",i_str,
			     XkbAtomText(shape->name,XkbXKBFile));
	    break;
	case XkbLogoDoodad:
	    fprintf(file,"%s    logoName= \"%s\";\n",i_str,
			     XkbStringText(doodad->logo.logo_name,XkbXKBFile));
	    if (doodad->shape.angle!=0) {
		fprintf(file,"%s    angle=  %s;\n",i_str,
			     XkbGeomFPText(doodad->logo.angle,XkbXKBFile));
	    }
	    if (doodad->shape.color_ndx!=0) {
		fprintf(file,"%s    color= \"%s\";\n",i_str,
			     XkbLogoDoodadColor(geom,&doodad->logo)->spec);
	    }
	    shape= XkbLogoDoodadShape(geom,&doodad->logo);
	    fprintf(file,"%s    shape= \"%s\";\n",i_str,
			    XkbAtomText(shape->name,XkbXKBFile));
	    break;
    }
    fprintf(file,"%s};\n",i_str);
    return TRUE;
}

/*ARGSUSED*/
static Bool
WriteXKBOverlay(	FILE *		file,
			unsigned	indent,
			XkbGeometryPtr	geom,
			XkbOverlayPtr	ol)
{
register char *		i_str;
int			r,k,nOut;
XkbOverlayRowPtr	row;
XkbOverlayKeyPtr	key;

    i_str= XkbIndentText(indent);
    if (ol->name!=None) {
	 fprintf(file,"%soverlay \"%s\" {\n",i_str,
    					XkbAtomText(ol->name,XkbMessage));
    }
    else fprintf(file,"%soverlay {\n",i_str);
    for (nOut=r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
	for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
	    char *over,*under;
	    over= XkbKeyNameText(key->over.name,XkbXKBFile);
	    under= XkbKeyNameText(key->under.name,XkbXKBFile);
	    if (nOut==0)
		 fprintf(file,"%s    %6s=%6s",i_str,under,over);
	    else if ((nOut%4)==0)
		 fprintf(file,",\n%s    %6s=%6s",i_str,under,over);
	    else fprintf(file,", %6s=%6s",under,over);
	    nOut++;
	}
    }
    fprintf(file,"\n%s};\n",i_str);
    return TRUE;
}

static Bool
WriteXKBSection(	FILE *		file,
			XkbSectionPtr 	s,
			XkbGeometryPtr	geom)
{
register int	i;
XkbRowPtr	row;
int		dfltKeyColor = 0;

    fprintf(file,"    section \"%s\" {\n",
				XkbAtomText(s->name,XkbXKBFile));
    if (s->rows&&(s->rows->num_keys>0)) {
	dfltKeyColor= s->rows->keys[0].color_ndx;
	fprintf(file,"        key.color= \"%s\";\n",
		XkbStringText(geom->colors[dfltKeyColor].spec,XkbXKBFile));
    }
    fprintf(file,"        priority=  %d;\n",s->priority);
    fprintf(file,"        top=       %s;\n",XkbGeomFPText(s->top,XkbXKBFile));
    fprintf(file,"        left=      %s;\n",XkbGeomFPText(s->left,XkbXKBFile));
    fprintf(file,"        width=     %s;\n",XkbGeomFPText(s->width,XkbXKBFile));
    fprintf(file,"        height=    %s;\n",
					XkbGeomFPText(s->height,XkbXKBFile));
    if (s->angle!=0) {
	fprintf(file,"        angle=  %s;\n",
					XkbGeomFPText(s->angle,XkbXKBFile));
    }
    for (i=0,row=s->rows;i<s->num_rows;i++,row++) {
	fprintf(file,"        row {\n");
	fprintf(file,"            top=  %s;\n",
					XkbGeomFPText(row->top,XkbXKBFile));
	fprintf(file,"            left= %s;\n",
					XkbGeomFPText(row->left,XkbXKBFile));
	if (row->vertical)
	    fprintf(file,"            vertical;\n");
	if (row->num_keys>0) {
	    register int 	k;
	    register XkbKeyPtr	key;
	    int			forceNL=0;
	    int			nThisLine= 0;
	    fprintf(file,"            keys {\n");
	    for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
		XkbShapePtr	shape;
		if (key->color_ndx!=dfltKeyColor)
		    forceNL= 1;
		if (k==0) {
		     fprintf(file,"                ");
		     nThisLine= 0;
		}
		else if (((nThisLine%2)==1)||(forceNL)) {
		     fprintf(file,",\n                ");
		     forceNL= nThisLine= 0;
		}
		else {
		     fprintf(file,", ");
		     nThisLine++;
		}
		shape= XkbKeyShape(geom,key);
		fprintf(file,"{ %6s, \"%s\", %3s",
		      XkbKeyNameText(key->name.name,XkbXKBFile),
		      XkbAtomText(shape->name,XkbXKBFile),
		      XkbGeomFPText(key->gap,XkbXKBFile));
		if (key->color_ndx!=dfltKeyColor) {
		    fprintf(file,", color=\"%s\"",XkbKeyColor(geom,key)->spec);
		    forceNL= 1;
		}
		fprintf(file," }");
	    }
	    fprintf(file,"\n            };\n");
	}
	fprintf(file,"        };\n");
    }
    if (s->doodads!=NULL) {
	XkbDoodadPtr	doodad;
	for (i=0,doodad=s->doodads;i<s->num_doodads;i++,doodad++) {
	    WriteXKBDoodad(file,8,geom,doodad);
	}
    }
    if (s->overlays!=NULL) {
	XkbOverlayPtr	ol;
	for (i=0,ol=s->overlays;i<s->num_overlays;i++,ol++) {
	    WriteXKBOverlay(file,8,geom,ol);
	}
    }
    fprintf(file,"    }; // End of \"%s\" section\n\n",
				XkbAtomText(s->name,XkbXKBFile));
    return TRUE;
}

Bool
XkbWriteXKBGeometry(	FILE *			file,
			XkbDescPtr              xkb,
			Bool			topLevel,
			Bool			showImplicit,
			XkbFileAddOnFunc	addOn,
			void *			priv)
{
register unsigned	i,n;
XkbGeometryPtr		geom;

    if ((!xkb)||(!xkb->geom)) {
	_XkbLibError(_XkbErrMissingGeometry,"XkbWriteXKBGeometry",0);
	return FALSE;
    }
    geom= xkb->geom;
    if (geom->name==None)
	 fprintf(file,"xkb_geometry {\n\n");
    else fprintf(file,"xkb_geometry \"%s\" {\n\n",
				XkbAtomText(geom->name,XkbXKBFile));
    fprintf(file,"    width=       %s;\n",
				XkbGeomFPText(geom->width_mm,XkbXKBFile));
    fprintf(file,"    height=      %s;\n\n",
				XkbGeomFPText(geom->height_mm,XkbXKBFile));

    if (geom->key_aliases!=NULL) {
	XkbKeyAliasPtr	pAl;
	pAl= geom->key_aliases;
	for (i=0;i<geom->num_key_aliases;i++,pAl++) {
	    fprintf(file,"    alias %6s = %6s;\n",
				XkbKeyNameText(pAl->alias,XkbXKBFile),
				XkbKeyNameText(pAl->real,XkbXKBFile));
	}
	fprintf(file,"\n");
    }

    if (geom->base_color!=NULL)
	fprintf(file,"    baseColor=   \"%s\";\n",
			XkbStringText(geom->base_color->spec,XkbXKBFile));
    if (geom->label_color!=NULL)
	fprintf(file,"    labelColor=  \"%s\";\n",
			XkbStringText(geom->label_color->spec,XkbXKBFile));
    if (geom->label_font!=NULL)
	fprintf(file,"    xfont=       \"%s\";\n",
			XkbStringText(geom->label_font,XkbXKBFile));
    if ((geom->num_colors>0)&&(showImplicit)) {
	XkbColorPtr	color;
	for (color=geom->colors,i=0;i<geom->num_colors;i++,color++) {
		fprintf(file,"//     color[%d]= \"%s\"\n",i,
				XkbStringText(color->spec,XkbXKBFile));
	}
	fprintf(file,"\n");
    }
    if (geom->num_properties>0) {
	XkbPropertyPtr	prop;
	for (prop=geom->properties,i=0;i<geom->num_properties;i++,prop++) {
	    fprintf(file,"    %s= \"%s\";\n",prop->name,
    				XkbStringText(prop->value,XkbXKBFile));
	}
	fprintf(file,"\n");
    }
    if (geom->num_shapes>0) {
	XkbShapePtr	shape;
	XkbOutlinePtr	outline;
	int		lastR;
	for (shape=geom->shapes,i=0;i<geom->num_shapes;i++,shape++) {
	    lastR=0;
	    fprintf(file,"    shape \"%s\" {",
				   XkbAtomText(shape->name,XkbXKBFile));
	    outline= shape->outlines;
	    if (shape->num_outlines>1) {
		for (n=0;n<shape->num_outlines;n++,outline++) {
		    if (n==0)	fprintf(file,"\n");
		    else	fprintf(file,",\n");
		    WriteXKBOutline(file,shape,outline,lastR,8,8);
		    lastR= outline->corner_radius;
		}
		fprintf(file,"\n    };\n");
	    }
	    else {
		WriteXKBOutline(file,NULL,outline,lastR,1,8);
		fprintf(file," };\n");
	    }
	}
    }
    if (geom->num_sections>0) {
	XkbSectionPtr	section;
	for (section=geom->sections,i=0;i<geom->num_sections;i++,section++){
	    WriteXKBSection(file,section,geom);
	}
    }
    if (geom->num_doodads>0) {
	XkbDoodadPtr	doodad;
	for (i=0,doodad=geom->doodads;i<geom->num_doodads;i++,doodad++) {
	    WriteXKBDoodad(file,4,geom,doodad);
	}
    }
    if (addOn)
	(*addOn)(file,xkb,topLevel,showImplicit,XkmGeometryIndex,priv);
    fprintf(file,"};\n\n");
    return TRUE;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "exevents.h"
#include "eventstr.h"
#include <xkbsrv.h>
#include <ctype.h>
#include "events.h"

/***====================================================================***/

void
XkbProcessKeyboardEvent(DeviceEvent *event, DeviceIntPtr keybd)
{
KeyClassPtr	keyc = keybd->key;
XkbSrvInfoPtr	xkbi;
int		key;
XkbBehavior	behavior;
unsigned        ndx;

    xkbi = keyc->xkbInfo;
    key = event->detail.key;
    if (xkbDebugFlags & 0x8)
	DebugF("[xkb] XkbPKE: Key %d %s\n",key,(event->type == ET_KeyPress?"down":"up"));

    if (xkbi->repeatKey == key && event->type== ET_KeyRelease &&
        !(xkbi->desc->ctrls->enabled_ctrls & XkbRepeatKeysMask))
	AccessXCancelRepeatKey(xkbi, key);

    behavior = xkbi->desc->server->behaviors[key];
    /* The "permanent" flag indicates a hard-wired behavior that occurs */
    /* below XKB, such as a key that physically locks.   XKB does not   */
    /* do anything to implement the behavior, but it *does* report that */
    /* key is hardwired */

    if (!(behavior.type & XkbKB_Permanent)) {
	switch (behavior.type) {
	    case XkbKB_Default:
                /* Neither of these should happen in practice, but ignore them
                   anyway. */
		if (event->type == ET_KeyPress && !event->key_repeat &&
                    key_is_down(keybd, key, KEY_PROCESSED))
                    return;
		else if (event->type == ET_KeyRelease &&
                         !key_is_down(keybd, key, KEY_PROCESSED))
                    return;
		break;
	    case XkbKB_Lock:
		if (event->type == ET_KeyRelease)
		    return;
		else if (key_is_down(keybd, key, KEY_PROCESSED))
                    event->type = ET_KeyRelease;
		break;
	    case XkbKB_RadioGroup:
		ndx= (behavior.data&(~XkbKB_RGAllowNone));
		if ( ndx<xkbi->nRadioGroups ) {
		    XkbRadioGroupPtr	rg;

		    if (event->type == ET_KeyRelease)
		        return;

		    rg = &xkbi->radioGroups[ndx];
		    if ( rg->currentDown == event->detail.key) {
		        if (behavior.data&XkbKB_RGAllowNone) {
		            event->type = ET_KeyRelease;
			    XkbHandleActions(keybd, keybd, event);
			    rg->currentDown= 0;
		        }
		        return;
		    }
		    if ( rg->currentDown!=0 ) {
			int key = event->detail.key;
			event->type = ET_KeyRelease;
			event->detail.key = rg->currentDown;
			XkbHandleActions(keybd, keybd, event);
			event->type = ET_KeyPress;
			event->detail.key = key;
		    }
		    rg->currentDown= key;
		}
		else ErrorF("[xkb] InternalError! Illegal radio group %d\n",ndx);
		break;
	    case XkbKB_Overlay1: case XkbKB_Overlay2:
		{
		    unsigned	which;
		    if (behavior.type==XkbKB_Overlay1)	which= XkbOverlay1Mask;
		    else				which= XkbOverlay2Mask;
		    if ( (xkbi->desc->ctrls->enabled_ctrls&which)==0 )
			break;
		    if ((behavior.data>=xkbi->desc->min_key_code)&&
			(behavior.data<=xkbi->desc->max_key_code)) {
                        event->detail.key = behavior.data;
			/* 9/11/94 (ef) -- XXX! need to match release with */
			/*                 press even if the state of the  */
			/*                 corresponding overlay control   */
			/*                 changes while the key is down   */
		    }
		}
		break;
	    default:
		ErrorF("[xkb] unknown key behavior 0x%04x\n",behavior.type);
		break;
	}
    }
    XkbHandleActions(keybd, keybd, event);
    return;
}

void
ProcessKeyboardEvent(InternalEvent *ev, DeviceIntPtr keybd)
{

    KeyClassPtr keyc = keybd->key;
    XkbSrvInfoPtr xkbi = NULL;
    ProcessInputProc backup_proc;
    xkbDeviceInfoPtr xkb_priv = XKBDEVICEINFO(keybd);
    DeviceEvent *event = &ev->device_event;
    int is_press = (event->type == ET_KeyPress);
    int is_release = (event->type == ET_KeyRelease);

    /* We're only interested in key events. */
    if (!is_press && !is_release) {
        UNWRAP_PROCESS_INPUT_PROC(keybd, xkb_priv, backup_proc);
        keybd->public.processInputProc(ev, keybd);
        COND_WRAP_PROCESS_INPUT_PROC(keybd, xkb_priv, backup_proc,
                                     xkbUnwrapProc);
        return;
    }

    xkbi = keyc->xkbInfo;

    /* If AccessX filters are active, then pass it through to
     * AccessXFilter{Press,Release}Event; else, punt to
     * XkbProcessKeyboardEvent.
     *
     * If AXF[PK]E don't intercept anything (which they probably won't),
     * they'll punt through XPKE anyway. */
    if ((xkbi->desc->ctrls->enabled_ctrls & XkbAllFilteredEventsMask)) {
        if (is_press)
            AccessXFilterPressEvent(event, keybd);
        else if (is_release)
            AccessXFilterReleaseEvent(event, keybd);
        return;
    }
    else {
        XkbProcessKeyboardEvent(event, keybd);
    }

    return;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "stdio.h"
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <xkbsrv.h>
#include "xkbstr.h"
#include "extnsionst.h"
#include "xkb.h"

	/*
	 * REQUEST SWAPPING
	 */
static int
SProcXkbUseExtension(ClientPtr client)
{
register int n;

    REQUEST(xkbUseExtensionReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbUseExtensionReq);
    swaps(&stuff->wantedMajor,n);
    swaps(&stuff->wantedMinor,n);
    return ProcXkbUseExtension(client);
}

static int
SProcXkbSelectEvents(ClientPtr client)
{
register int n;

    REQUEST(xkbSelectEventsReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->affectWhich,n);
    swaps(&stuff->clear,n);
    swaps(&stuff->selectAll,n);
    swaps(&stuff->affectMap,n);
    swaps(&stuff->map,n);
    if ((stuff->affectWhich&(~XkbMapNotifyMask))!=0)  {
	union {
	    BOOL	*b;
	    CARD8	*c8;
	    CARD16	*c16;
	    CARD32	*c32;
	} from;
	register unsigned bit,ndx,maskLeft,dataLeft,size;

	from.c8= (CARD8 *)&stuff[1];
	dataLeft= (stuff->length*4)-SIZEOF(xkbSelectEventsReq);
	maskLeft= (stuff->affectWhich&(~XkbMapNotifyMask));
	for (ndx=0,bit=1; (maskLeft!=0); ndx++, bit<<=1) {
	    if (((bit&maskLeft)==0)||(ndx==XkbMapNotify))
		continue;
	    maskLeft&= ~bit;
	    if ((stuff->selectAll&bit)||(stuff->clear&bit))
		continue;
	    switch (ndx) {
		case XkbNewKeyboardNotify:
		case XkbStateNotify:
		case XkbNamesNotify:
		case XkbAccessXNotify:
		case XkbExtensionDeviceNotify:
		    size= 2;
		    break;
		case XkbControlsNotify:
		case XkbIndicatorStateNotify:
		case XkbIndicatorMapNotify:
		    size= 4;
		    break;
		case XkbBellNotify:
		case XkbActionMessage:
		case XkbCompatMapNotify:
		    size= 1;
		    break;
		default:
		    client->errorValue = _XkbErrCode2(0x1,bit);
		    return BadValue;
	    }
	    if (dataLeft<(size*2))
		return BadLength;
	    if (size==2) {
		swaps(&from.c16[0],n);
		swaps(&from.c16[1],n);
	    }
	    else if (size==4) {
		swapl(&from.c32[0],n);
		swapl(&from.c32[1],n);
	    }
	    else {
		size= 2;
	    }
	    from.c8+= (size*2);
	    dataLeft-= (size*2);
	}
	if (dataLeft>2) {
	    ErrorF("[xkb] Extra data (%d bytes) after SelectEvents\n",dataLeft);
	    return BadLength;
	}
    }
    return ProcXkbSelectEvents(client);
}

static int
SProcXkbBell(ClientPtr client)
{
register int	n;

    REQUEST(xkbBellReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbBellReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->bellClass,n);
    swaps(&stuff->bellID,n);
    swapl(&stuff->name,n);
    swapl(&stuff->window,n);
    swaps(&stuff->pitch,n);
    swaps(&stuff->duration,n);
    return ProcXkbBell(client);
}

static int
SProcXkbGetState(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetStateReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetStateReq);
    swaps(&stuff->deviceSpec,n);
    return ProcXkbGetState(client);
}

static int
SProcXkbLatchLockState(ClientPtr client)
{
register int 	n;

    REQUEST(xkbLatchLockStateReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbLatchLockStateReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->groupLatch,n);
    return ProcXkbLatchLockState(client);
}

static int
SProcXkbGetControls(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetControlsReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetControlsReq);
    swaps(&stuff->deviceSpec,n);
    return ProcXkbGetControls(client);
}

static int
SProcXkbSetControls(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetControlsReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbSetControlsReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->affectInternalVMods,n);
    swaps(&stuff->internalVMods,n);
    swaps(&stuff->affectIgnoreLockVMods,n);
    swaps(&stuff->ignoreLockVMods,n);
    swaps(&stuff->axOptions,n);
    swapl(&stuff->affectEnabledCtrls,n);
    swapl(&stuff->enabledCtrls,n);
    swapl(&stuff->changeCtrls,n);
    swaps(&stuff->repeatDelay,n);
    swaps(&stuff->repeatInterval,n);
    swaps(&stuff->slowKeysDelay,n);
    swaps(&stuff->debounceDelay,n);
    swaps(&stuff->mkDelay,n);
    swaps(&stuff->mkInterval,n);
    swaps(&stuff->mkTimeToMax,n);
    swaps(&stuff->mkMaxSpeed,n);
    swaps(&stuff->mkCurve,n);
    swaps(&stuff->axTimeout,n);
    swapl(&stuff->axtCtrlsMask,n);
    swapl(&stuff->axtCtrlsValues,n);
    swaps(&stuff->axtOptsMask,n);
    swaps(&stuff->axtOptsValues,n);
    return ProcXkbSetControls(client);
}

static int
SProcXkbGetMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetMapReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetMapReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->full,n);
    swaps(&stuff->partial,n);
    swaps(&stuff->virtualMods,n);
    return ProcXkbGetMap(client);
}

static int
SProcXkbSetMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetMapReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetMapReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->present,n);
    swaps(&stuff->flags,n);
    swaps(&stuff->totalSyms,n);
    swaps(&stuff->totalActs,n);
    swaps(&stuff->virtualMods,n);
    return ProcXkbSetMap(client);
}


static int
SProcXkbGetCompatMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetCompatMapReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetCompatMapReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->firstSI,n);
    swaps(&stuff->nSI,n);
    return ProcXkbGetCompatMap(client);
}

static int
SProcXkbSetCompatMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetCompatMapReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetCompatMapReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->firstSI,n);
    swaps(&stuff->nSI,n);
    return ProcXkbSetCompatMap(client);
}

static int
SProcXkbGetIndicatorState(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetIndicatorStateReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetIndicatorStateReq);
    swaps(&stuff->deviceSpec,n);
    return ProcXkbGetIndicatorState(client);
}

static int
SProcXkbGetIndicatorMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetIndicatorMapReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetIndicatorMapReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->which,n);
    return ProcXkbGetIndicatorMap(client);
}

static int
SProcXkbSetIndicatorMap(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetIndicatorMapReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetIndicatorMapReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->which,n);
    return ProcXkbSetIndicatorMap(client);
}

static int
SProcXkbGetNamedIndicator(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetNamedIndicatorReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetNamedIndicatorReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->ledClass,n);
    swaps(&stuff->ledID,n);
    swapl(&stuff->indicator,n);
    return ProcXkbGetNamedIndicator(client);
}

static int
SProcXkbSetNamedIndicator(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetNamedIndicatorReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbSetNamedIndicatorReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->ledClass,n);
    swaps(&stuff->ledID,n);
    swapl(&stuff->indicator,n);
    swaps(&stuff->virtualMods,n);
    swapl(&stuff->ctrls,n);
    return ProcXkbSetNamedIndicator(client);
}


static int
SProcXkbGetNames(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetNamesReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetNamesReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->which,n);
    return ProcXkbGetNames(client);
}

static int
SProcXkbSetNames(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetNamesReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetNamesReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->virtualMods,n);
    swapl(&stuff->which,n);
    swapl(&stuff->indicators,n);
    swaps(&stuff->totalKTLevelNames,n);
    return ProcXkbSetNames(client);
}

static int
SProcXkbGetGeometry(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetGeometryReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetGeometryReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->name,n);
    return ProcXkbGetGeometry(client);
}

static int
SProcXkbSetGeometry(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetGeometryReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetGeometryReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->name,n);
    swaps(&stuff->widthMM,n);
    swaps(&stuff->heightMM,n);
    swaps(&stuff->nProperties,n);
    swaps(&stuff->nColors,n);
    swaps(&stuff->nDoodads,n);
    swaps(&stuff->nKeyAliases,n);
    return ProcXkbSetGeometry(client);
}

static int
SProcXkbPerClientFlags(ClientPtr client)
{
register int	n;

    REQUEST(xkbPerClientFlagsReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbPerClientFlagsReq);
    swaps(&stuff->deviceSpec,n);
    swapl(&stuff->change,n);
    swapl(&stuff->value,n);
    swapl(&stuff->ctrlsToChange,n);
    swapl(&stuff->autoCtrls,n);
    swapl(&stuff->autoCtrlValues,n);
    return ProcXkbPerClientFlags(client);
}

static int
SProcXkbListComponents(ClientPtr client)
{
register int	n;

    REQUEST(xkbListComponentsReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbListComponentsReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->maxNames,n);
    return ProcXkbListComponents(client);
}

static int
SProcXkbGetKbdByName(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetKbdByNameReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->want,n);
    swaps(&stuff->need,n);
    return ProcXkbGetKbdByName(client);
}

static int
SProcXkbGetDeviceInfo(ClientPtr client)
{
register int	n;

    REQUEST(xkbGetDeviceInfoReq);

    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH(xkbGetDeviceInfoReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->wanted,n);
    swaps(&stuff->ledClass,n);
    swaps(&stuff->ledID,n);
    return ProcXkbGetDeviceInfo(client);
}

static int
SProcXkbSetDeviceInfo(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetDeviceInfoReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetDeviceInfoReq);
    swaps(&stuff->deviceSpec,n);
    swaps(&stuff->change,n);
    swaps(&stuff->nDeviceLedFBs,n);
    return ProcXkbSetDeviceInfo(client);
}

static int
SProcXkbSetDebuggingFlags(ClientPtr client)
{
register int	n;

    REQUEST(xkbSetDebuggingFlagsReq);

    swaps(&stuff->length,n);
    REQUEST_AT_LEAST_SIZE(xkbSetDebuggingFlagsReq);
    swapl(&stuff->affectFlags,n);
    swapl(&stuff->flags,n);
    swapl(&stuff->affectCtrls,n);
    swapl(&stuff->ctrls,n);
    swaps(&stuff->msgLength,n);
    return ProcXkbSetDebuggingFlags(client);
}

int
SProcXkbDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_kbUseExtension:
	return SProcXkbUseExtension(client);
    case X_kbSelectEvents:
	return SProcXkbSelectEvents(client);
    case X_kbBell:
	return SProcXkbBell(client);
    case X_kbGetState:
	return SProcXkbGetState(client);
    case X_kbLatchLockState:
	return SProcXkbLatchLockState(client);
    case X_kbGetControls:
	return SProcXkbGetControls(client);
    case X_kbSetControls:
	return SProcXkbSetControls(client);
    case X_kbGetMap:
	return SProcXkbGetMap(client);
    case X_kbSetMap:
	return SProcXkbSetMap(client);
    case X_kbGetCompatMap:
	return SProcXkbGetCompatMap(client);
    case X_kbSetCompatMap:
	return SProcXkbSetCompatMap(client);
    case X_kbGetIndicatorState:
	return SProcXkbGetIndicatorState(client);
    case X_kbGetIndicatorMap:
	return SProcXkbGetIndicatorMap(client);
    case X_kbSetIndicatorMap:
	return SProcXkbSetIndicatorMap(client);
    case X_kbGetNamedIndicator:
	return SProcXkbGetNamedIndicator(client);
    case X_kbSetNamedIndicator:
	return SProcXkbSetNamedIndicator(client);
    case X_kbGetNames:
	return SProcXkbGetNames(client);
    case X_kbSetNames:
	return SProcXkbSetNames(client);
    case X_kbGetGeometry:
	return SProcXkbGetGeometry(client);
    case X_kbSetGeometry:
	return SProcXkbSetGeometry(client);
    case X_kbPerClientFlags:
	return SProcXkbPerClientFlags(client);
    case X_kbListComponents:
	return SProcXkbListComponents(client);
    case X_kbGetKbdByName:
	return SProcXkbGetKbdByName(client);
    case X_kbGetDeviceInfo:
	return SProcXkbGetDeviceInfo(client);
    case X_kbSetDeviceInfo:
	return SProcXkbSetDeviceInfo(client);
    case X_kbSetDebuggingFlags:
	return SProcXkbSetDebuggingFlags(client);
    default:
	return BadRequest;
    }
}
/************************************************************
 Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include <X11/Xos.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XKMformat.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS	1
#include <xkbsrv.h>
#include "xkbgeom.h"

/***====================================================================***/

#define	BUFFER_SIZE	512

static char textBuffer[BUFFER_SIZE];
static int  tbNext= 0;

static char *
tbGetBuffer(unsigned size)
{
char *rtrn;

    if (size>=BUFFER_SIZE)
	return NULL;
    if ((BUFFER_SIZE-tbNext)<=size)
	tbNext= 0;
    rtrn= &textBuffer[tbNext];
    tbNext+= size;
    return rtrn;
}

/***====================================================================***/

char *
XkbAtomText(Atom atm,unsigned format)
{
const char	*atmstr;
char	*rtrn,*tmp;

    atmstr = NameForAtom(atm);
    if (atmstr != NULL) {
	int	len;
	len= strlen(atmstr)+1;
	if (len>BUFFER_SIZE)
	    len= BUFFER_SIZE-2;
	rtrn= tbGetBuffer(len);
	strncpy(rtrn,atmstr,len);
	rtrn[len]= '\0';
    }
    else {
	rtrn= tbGetBuffer(1);
	rtrn[0]= '\0';
    }
    if (format==XkbCFile) {
	for (tmp=rtrn;*tmp!='\0';tmp++) {
	    if ((tmp==rtrn)&&(!isalpha(*tmp)))
		*tmp= '_';
	    else if (!isalnum(*tmp))
		*tmp= '_';
	}
    }
    return XkbStringText(rtrn,format);
}

/***====================================================================***/

char *
XkbVModIndexText(XkbDescPtr xkb,unsigned ndx,unsigned format)
{
register int len;
register Atom *vmodNames;
char *rtrn;
const char *tmp;
char  numBuf[20];

    if (xkb && xkb->names)
	 vmodNames= xkb->names->vmods;
    else vmodNames= NULL;

    tmp= NULL;
    if (ndx>=XkbNumVirtualMods)
	 tmp= "illegal";
    else if (vmodNames&&(vmodNames[ndx]!=None))
	 tmp= NameForAtom(vmodNames[ndx]);
    if (tmp==NULL) {
	sprintf(numBuf,"%d",ndx);
	tmp = numBuf;
    }

    len= strlen(tmp)+1;
    if (format==XkbCFile)
	len+= 4;
    if (len>=BUFFER_SIZE)
	len= BUFFER_SIZE-1;
    rtrn= tbGetBuffer(len);
    if (format==XkbCFile) {
	 strcpy(rtrn,"vmod_");
	 strncpy(&rtrn[5],tmp,len-4);
    }
    else strncpy(rtrn,tmp,len);
    return rtrn;
}

char *
XkbVModMaskText(        XkbDescPtr	xkb,
			unsigned	modMask,
			unsigned	mask,
			unsigned	format)
{
register int i,bit;
int	 len;
char *mm,*rtrn;
char *str,buf[BUFFER_SIZE];

    if ((modMask==0)&&(mask==0)) {
	rtrn= tbGetBuffer(5);
	if (format==XkbCFile)
	     sprintf(rtrn,"0");
	else sprintf(rtrn,"none");
	return rtrn;
    }
    if (modMask!=0)
	 mm= XkbModMaskText(modMask,format);
    else mm= NULL;

    str= buf;
    buf[0]= '\0';
    if (mask) {
	char *tmp;
	for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	    if (mask&bit) {
		tmp= XkbVModIndexText(xkb,i,format);
		len= strlen(tmp)+1+(str==buf?0:1);
		if (format==XkbCFile)
		    len+= 4;
		if ((str-(buf+len))<=BUFFER_SIZE) {
		    if (str!=buf) {
			if (format==XkbCFile)	*str++= '|';
			else			*str++= '+';
			len--;
		    }
		}
		if (format==XkbCFile)
		     sprintf(str,"%sMask",tmp);
		else strcpy(str,tmp);
		str= &str[len-1];
	    }
	}
	str= buf;
    }
    else str= NULL;
    if (mm)	
	len= strlen(mm);
    else	len= 0;
    if (str)
	len+= strlen(str)+(mm==NULL?0:1);
    if (len>=BUFFER_SIZE)
	len= BUFFER_SIZE-1;
    rtrn= tbGetBuffer(len+1);
    rtrn[0]= '\0';

    if (mm!=NULL) {
	i= strlen(mm);
	if (i>len)
	    i= len;
	strcpy(rtrn,mm);
    }
    else {
	i=0;
    }
    if (str!=NULL) {
	if (mm!=NULL) {
	    if (format==XkbCFile)	strcat(rtrn,"|");
	    else			strcat(rtrn,"+");
	}
	strncat(rtrn,str,len-i);
    }
    rtrn[len]= '\0';
    return rtrn;
}

static char *modNames[XkbNumModifiers] = {
    "Shift", "Lock", "Control", "Mod1", "Mod2", "Mod3", "Mod4", "Mod5"
};

char *
XkbModIndexText(unsigned ndx,unsigned format)
{
char *	rtrn;
char	buf[100];

    if (format==XkbCFile) {
	if (ndx<XkbNumModifiers)
	     sprintf(buf,"%sMapIndex",modNames[ndx]);
	else if (ndx==XkbNoModifier)
	     sprintf(buf,"XkbNoModifier");
	else sprintf(buf,"0x%02x",ndx);
    }
    else {
	if (ndx<XkbNumModifiers)
	     strcpy(buf,modNames[ndx]);
	else if (ndx==XkbNoModifier)
	     strcpy(buf,"none");
	else sprintf(buf,"ILLEGAL_%02x",ndx);
    }
    rtrn= tbGetBuffer(strlen(buf)+1);
    strcpy(rtrn,buf);
    return rtrn;
}

char *
XkbModMaskText(unsigned mask,unsigned format)
{
register int i,bit;
char buf[64],*rtrn;

    if ((mask&0xff)==0xff) {
	if (format==XkbCFile) 		strcpy(buf,"0xff");
	else				strcpy(buf,"all");
    }
    else if ((mask&0xff)==0) {
	if (format==XkbCFile)		strcpy(buf,"0");
	else				strcpy(buf,"none");
    }
    else {
	char *str= buf;
	buf[0]= '\0';
	for (i=0,bit=1;i<XkbNumModifiers;i++,bit<<=1) {
	    if (mask&bit) {
		if (str!=buf) {
		    if (format==XkbCFile)	*str++= '|';
		    else			*str++= '+';
		}
		strcpy(str,modNames[i]);
		str= &str[strlen(str)];
		if (format==XkbCFile) {
		    strcpy(str,"Mask");
		    str+= 4;
		}
	    }
	}
    }
    rtrn= tbGetBuffer(strlen(buf)+1);
    strcpy(rtrn,buf);
    return rtrn;
}

/***====================================================================***/

/*ARGSUSED*/
char *
XkbConfigText(unsigned config,unsigned format)
{
static char *buf;

    buf= tbGetBuffer(32);
    switch (config) {
	case XkmSemanticsFile:
	    strcpy(buf,"Semantics");
	    break;
	case XkmLayoutFile:
	    strcpy(buf,"Layout");
	    break;
	case XkmKeymapFile:
	    strcpy(buf,"Keymap");
	    break;
	case XkmGeometryFile:
	case XkmGeometryIndex:
	    strcpy(buf,"Geometry");
	    break;
	case XkmTypesIndex:
	    strcpy(buf,"Types");
	    break;
	case XkmCompatMapIndex:
	    strcpy(buf,"CompatMap");
	    break;
	case XkmSymbolsIndex:
	    strcpy(buf,"Symbols");
	    break;
	case XkmIndicatorsIndex:
	    strcpy(buf,"Indicators");
	    break;
	case XkmKeyNamesIndex:
	    strcpy(buf,"KeyNames");
	    break;
	case XkmVirtualModsIndex:
	    strcpy(buf,"VirtualMods");
	    break;
	default:
	    sprintf(buf,"unknown(%d)",config);
	    break;
    }
    return buf;
}

/***====================================================================***/

char *
XkbKeysymText(KeySym sym,unsigned format)
{
static char buf[32],*rtrn;

    if (sym==NoSymbol)
	 strcpy(rtrn=buf,"NoSymbol");
    else sprintf(rtrn=buf, "0x%lx", (long)sym);
    return rtrn;
}

char *
XkbKeyNameText(char *name,unsigned format)
{
char *buf;

    if (format==XkbCFile) {
	buf= tbGetBuffer(5);
	memcpy(buf,name,4);
	buf[4]= '\0';
    }
    else {
	int len;
	buf= tbGetBuffer(7);
	buf[0]= '<';
	memcpy(&buf[1],name,4);
	buf[5]= '\0';
	len= strlen(buf);
	buf[len++]= '>';
	buf[len]= '\0';
    }
    return buf;
}

/***====================================================================***/

static char *siMatchText[5] = {
	"NoneOf", "AnyOfOrNone", "AnyOf", "AllOf", "Exactly"
};

char *
XkbSIMatchText(unsigned type,unsigned format)
{
static char buf[40];
char *rtrn;

    switch (type&XkbSI_OpMask) {
	case XkbSI_NoneOf:	rtrn= siMatchText[0]; break;
	case XkbSI_AnyOfOrNone:	rtrn= siMatchText[1]; break;
	case XkbSI_AnyOf:	rtrn= siMatchText[2]; break;
	case XkbSI_AllOf:	rtrn= siMatchText[3]; break;
	case XkbSI_Exactly:	rtrn= siMatchText[4]; break;
	default:		sprintf(buf,"0x%x",type&XkbSI_OpMask);
				return buf;
    }
    if (format==XkbCFile) {
	if (type&XkbSI_LevelOneOnly)
	     sprintf(buf,"XkbSI_LevelOneOnly|XkbSI_%s",rtrn);
	else sprintf(buf,"XkbSI_%s",rtrn);
	rtrn= buf;
    }
    return rtrn;
}

/***====================================================================***/

static char *imWhichNames[]= {
	"base",
	"latched",
	"locked",
	"effective",
	"compat"
};

char *
XkbIMWhichStateMaskText(unsigned use_which,unsigned format)
{
int		len;
unsigned	i,bit,tmp;
char *		buf;

    if (use_which==0) {
	buf= tbGetBuffer(2);
	strcpy(buf,"0");
	return buf;
    }
    tmp= use_which&XkbIM_UseAnyMods;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    len+= strlen(imWhichNames[i])+1;
	    if (format==XkbCFile)
		len+= 9;
	}
    }
    buf= tbGetBuffer(len+1);
    tmp= use_which&XkbIM_UseAnyMods;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    if (format==XkbCFile) {
		if (len!=0)
		    buf[len++]= '|';
		sprintf(&buf[len],"XkbIM_Use%s",imWhichNames[i]);
		buf[len+9]= toupper(buf[len+9]);
	    }
	    else {
		if (len!=0)
		    buf[len++]= '+';
		sprintf(&buf[len],"%s",imWhichNames[i]);
	    }
	    len+= strlen(&buf[len]);
	}
    }
    return buf;
}

static char *ctrlNames[] = {
	"repeatKeys",
	"slowKeys",
	"bounceKeys",
	"stickyKeys",
	"mouseKeys",
	"mouseKeysAccel",
	"accessXKeys",
	"accessXTimeout",
	"accessXFeedback",
	"audibleBell",
	"overlay1",
	"overlay2",
	"ignoreGroupLock"
};

char *
XkbControlsMaskText(unsigned ctrls,unsigned format)
{
int		len;
unsigned	i,bit,tmp;
char *		buf;

    if (ctrls==0) {
	buf= tbGetBuffer(5);
	if (format==XkbCFile)
	     strcpy(buf,"0");
	else strcpy(buf,"none");
	return buf;
    }
    tmp= ctrls&XkbAllBooleanCtrlsMask;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    len+= strlen(ctrlNames[i])+1;
	    if (format==XkbCFile)
		len+= 7;
	}
    }
    buf= tbGetBuffer(len+1);
    tmp= ctrls&XkbAllBooleanCtrlsMask;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    if (format==XkbCFile) {
		if (len!=0)
		    buf[len++]= '|';
		sprintf(&buf[len],"Xkb%sMask",ctrlNames[i]);
		buf[len+3]= toupper(buf[len+3]);
	    }
	    else {
		if (len!=0)
		    buf[len++]= '+';
		sprintf(&buf[len],"%s",ctrlNames[i]);
	    }
	    len+= strlen(&buf[len]);
	}
    }
    return buf;
}

/***====================================================================***/

char *
XkbStringText(char *str,unsigned format)
{
char *	buf;
register char *in,*out;
int	len;
Bool	ok;

    if (str==NULL) {
	buf= tbGetBuffer(2);
	buf[0]='\0';
	return buf;
    }
    else if (format==XkbXKMFile)
	return str;
    for (ok= TRUE,len=0,in=str;*in!='\0';in++,len++) {
	if (!isprint(*in)) {
	    ok= FALSE;
	    switch (*in) {
		case '\n': case '\t': case '\v':
		case '\b': case '\r': case '\f':
		    len++;
		    break;
		default:
		    len+= 4;
		    break;
	    }
	}
    }
    if (ok)
	return str;
    buf= tbGetBuffer(len+1);
    for (in=str,out=buf;*in!='\0';in++) {
	if (isprint(*in))
	    *out++= *in;
	else {
	    *out++= '\\';
	    if (*in=='\n')	*out++= 'n';
	    else if (*in=='\t')	*out++= 't';
	    else if (*in=='\v')	*out++= 'v';
	    else if (*in=='\b')	*out++= 'b';
	    else if (*in=='\r')	*out++= 'r';
	    else if (*in=='\f')	*out++= 'f';
	    else if ((*in=='\033')&&(format==XkbXKMFile)) {
		*out++= 'e';
	    }
	    else {
		*out++= '0';
		sprintf(out,"%o",*in);
		while (*out!='\0')
		    out++;
	    }
	}
    }
    *out++= '\0';
    return buf;
}

/***====================================================================***/

char *
XkbGeomFPText(int val,unsigned format)
{
int	whole,frac;
char *	buf;

    buf= tbGetBuffer(12);
    if (format==XkbCFile) {
	sprintf(buf,"%d",val);
    }
    else {
	whole= val/XkbGeomPtsPerMM;
	frac= val%XkbGeomPtsPerMM;
	if (frac!=0)
	     sprintf(buf,"%d.%d",whole,frac);
	else sprintf(buf,"%d",whole);
    }
    return buf;
}

char *
XkbDoodadTypeText(unsigned type,unsigned format)
{
char *	buf;
    if (format==XkbCFile) {
	buf= tbGetBuffer(24);
	if (type==XkbOutlineDoodad)	   strcpy(buf,"XkbOutlineDoodad");
	else if (type==XkbSolidDoodad)	   strcpy(buf,"XkbSolidDoodad");
	else if (type==XkbTextDoodad)	   strcpy(buf,"XkbTextDoodad");
	else if (type==XkbIndicatorDoodad) strcpy(buf,"XkbIndicatorDoodad");
	else if (type==XkbLogoDoodad)	   strcpy(buf,"XkbLogoDoodad");
	else				   sprintf(buf,"UnknownDoodad%d",type);
    }
    else {
	buf= tbGetBuffer(12);
	if (type==XkbOutlineDoodad)	   strcpy(buf,"outline");
	else if (type==XkbSolidDoodad)	   strcpy(buf,"solid");
	else if (type==XkbTextDoodad)	   strcpy(buf,"text");
	else if (type==XkbIndicatorDoodad) strcpy(buf,"indicator");
	else if (type==XkbLogoDoodad)	   strcpy(buf,"logo");
	else				   sprintf(buf,"unknown%d",type);
    }
    return buf;
}

static char *actionTypeNames[XkbSA_NumActions]= {
    "NoAction", 
    "SetMods",      "LatchMods",    "LockMods", 
    "SetGroup",     "LatchGroup",   "LockGroup",
    "MovePtr",
    "PtrBtn",       "LockPtrBtn",
    "SetPtrDflt",
    "ISOLock",
    "Terminate",    "SwitchScreen", 
    "SetControls",  "LockControls",
    "ActionMessage",
    "RedirectKey",
    "DeviceBtn",    "LockDeviceBtn"
};

char *
XkbActionTypeText(unsigned type,unsigned format)
{
static char buf[32];
char *rtrn;

    if (type<=XkbSA_LastAction) {
	rtrn= actionTypeNames[type];
	if (format==XkbCFile) {
	    sprintf(buf,"XkbSA_%s",rtrn);
	    return buf;
	}
	return rtrn;
    }
    sprintf(buf,"Private");
    return buf;
}

/***====================================================================***/

static int
TryCopyStr(char *to,char *from,int *pLeft)
{
register int len;
    if (*pLeft>0) {
	len= strlen(from);
	if (len<((*pLeft)-3)) {
	    strcat(to,from);
	    *pLeft-= len;
	    return TRUE;
	}
    }
    *pLeft= -1;
    return FALSE;
}

/*ARGSUSED*/
static Bool
CopyNoActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int*sz)
{
    return TRUE;
}

static Bool
CopyModActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int* sz)
{
XkbModAction *	act;
unsigned	tmp;

    act= &action->mods;
    tmp= XkbModActionVMods(act);
    TryCopyStr(buf,"modifiers=",sz);
    if (act->flags&XkbSA_UseModMapMods)
	  TryCopyStr(buf,"modMapMods",sz);
    else if (act->real_mods || tmp) {
	 TryCopyStr(buf,
		     XkbVModMaskText(xkb,act->real_mods,tmp,XkbXKBFile),
		     sz);
    }
    else TryCopyStr(buf,"none",sz);
    if (act->type==XkbSA_LockMods)
	return TRUE;
    if (act->flags&XkbSA_ClearLocks)
	TryCopyStr(buf,",clearLocks",sz);
    if (act->flags&XkbSA_LatchToLock)
	TryCopyStr(buf,",latchToLock",sz);
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyGroupActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbGroupAction *	act;
char			tbuf[32];

    act= &action->group;
    TryCopyStr(buf,"group=",sz);
    if (act->flags&XkbSA_GroupAbsolute)
	 sprintf(tbuf,"%d",XkbSAGroup(act)+1);
    else if (XkbSAGroup(act)<0)
	 sprintf(tbuf,"%d",XkbSAGroup(act));
    else sprintf(tbuf,"+%d",XkbSAGroup(act));
    TryCopyStr(buf,tbuf,sz);
    if (act->type==XkbSA_LockGroup)
	return TRUE;
    if (act->flags&XkbSA_ClearLocks)
	TryCopyStr(buf,",clearLocks",sz);
    if (act->flags&XkbSA_LatchToLock)
	TryCopyStr(buf,",latchToLock",sz);
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyMovePtrArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
{
XkbPtrAction *	act;
int		x,y;
char		tbuf[32];

    act= &action->ptr;
    x= XkbPtrActionX(act);
    y= XkbPtrActionY(act);
    if ((act->flags&XkbSA_MoveAbsoluteX)||(x<0))
	 sprintf(tbuf,"x=%d",x);
    else sprintf(tbuf,"x=+%d",x);
    TryCopyStr(buf,tbuf,sz);

    if ((act->flags&XkbSA_MoveAbsoluteY)||(y<0))
	 sprintf(tbuf,",y=%d",y);
    else sprintf(tbuf,",y=+%d",y);
    TryCopyStr(buf,tbuf,sz);
    if (act->flags&XkbSA_NoAcceleration)
	TryCopyStr(buf,",!accel",sz);
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyPtrBtnArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
{
XkbPtrBtnAction *	act;
char			tbuf[32];

    act= &action->btn;
    TryCopyStr(buf,"button=",sz);
    if ((act->button>0)&&(act->button<6)) {
	 sprintf(tbuf,"%d",act->button);
	 TryCopyStr(buf,tbuf,sz);
    }
    else TryCopyStr(buf,"default",sz);
    if (act->count>0) {
	sprintf(tbuf,",count=%d",act->count);
	TryCopyStr(buf,tbuf,sz);
    }
    if (action->type==XkbSA_LockPtrBtn) {
	switch (act->flags&(XkbSA_LockNoUnlock|XkbSA_LockNoLock)) {
	    case XkbSA_LockNoLock:
		sprintf(tbuf,",affect=unlock"); break;
	    case XkbSA_LockNoUnlock:
		sprintf(tbuf,",affect=lock"); break;
	    case XkbSA_LockNoUnlock|XkbSA_LockNoLock:
		sprintf(tbuf,",affect=neither"); break;
	    default:
		sprintf(tbuf,",affect=both"); break;
	}
	TryCopyStr(buf,tbuf,sz);
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopySetPtrDfltArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbPtrDfltAction *	act;
char			tbuf[32];

    act= &action->dflt;
    if (act->affect==XkbSA_AffectDfltBtn) {
	TryCopyStr(buf,"affect=button,button=",sz);
	if ((act->flags&XkbSA_DfltBtnAbsolute)||(XkbSAPtrDfltValue(act)<0))
	     sprintf(tbuf,"%d",XkbSAPtrDfltValue(act));
	else sprintf(tbuf,"+%d",XkbSAPtrDfltValue(act));
	TryCopyStr(buf,tbuf,sz);
    }
    return TRUE;
}

static Bool
CopyISOLockArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
{
XkbISOAction *	act;
char		tbuf[64];

    act= &action->iso;
    if (act->flags&XkbSA_ISODfltIsGroup) {
	TryCopyStr(tbuf,"group=",sz);
	if (act->flags&XkbSA_GroupAbsolute)
	     sprintf(tbuf,"%d",XkbSAGroup(act)+1);
	else if (XkbSAGroup(act)<0)
	     sprintf(tbuf,"%d",XkbSAGroup(act));
	else sprintf(tbuf,"+%d",XkbSAGroup(act));
	TryCopyStr(buf,tbuf,sz);
    }
    else {
	unsigned tmp;
	tmp= XkbModActionVMods(act);
	TryCopyStr(buf,"modifiers=",sz);
	if (act->flags&XkbSA_UseModMapMods)
	     TryCopyStr(buf,"modMapMods",sz);
	else if (act->real_mods || tmp) {
	    if (act->real_mods) {
		TryCopyStr(buf,XkbModMaskText(act->real_mods,XkbXKBFile),sz);
		if (tmp)
		    TryCopyStr(buf,"+",sz);
	    }
	    if (tmp)
		TryCopyStr(buf,XkbVModMaskText(xkb,0,tmp,XkbXKBFile),sz);
	}
	else TryCopyStr(buf,"none",sz);
    }
    TryCopyStr(buf,",affect=",sz);
    if ((act->affect&XkbSA_ISOAffectMask)==0)
	TryCopyStr(buf,"all",sz);
    else {
	int nOut= 0;
	if ((act->affect&XkbSA_ISONoAffectMods)==0) {
	    TryCopyStr(buf,"mods",sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectGroup)==0) {
	    sprintf(tbuf,"%sgroups",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectPtr)==0) {
	    sprintf(tbuf,"%spointer",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectCtrls)==0) {
	    sprintf(tbuf,"%scontrols",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopySwitchScreenArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbSwitchScreenAction *	act;
char			tbuf[32];

    act= &action->screen;
    if ((act->flags&XkbSA_SwitchAbsolute)||(XkbSAScreen(act)<0))
	 sprintf(tbuf,"screen=%d",XkbSAScreen(act));
    else sprintf(tbuf,"screen=+%d",XkbSAScreen(act));
    TryCopyStr(buf,tbuf,sz);
    if (act->flags&XkbSA_SwitchApplication)
	 TryCopyStr(buf,",!same",sz);
    else TryCopyStr(buf,",same",sz);
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopySetLockControlsArgs(XkbDescPtr xkb,XkbAction *action,
							char *buf,int *sz)
{
XkbCtrlsAction *	act;
unsigned		tmp;
char			tbuf[32];

    act= &action->ctrls;
    tmp= XkbActionCtrls(act);
    TryCopyStr(buf,"controls=",sz);
    if (tmp==0)
	TryCopyStr(buf,"none",sz);
    else if ((tmp&XkbAllBooleanCtrlsMask)==XkbAllBooleanCtrlsMask)
	TryCopyStr(buf,"all",sz);
    else {
	int nOut= 0;
	if (tmp&XkbRepeatKeysMask) {
	    sprintf(tbuf,"%sRepeatKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbSlowKeysMask) {
	    sprintf(tbuf,"%sSlowKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbBounceKeysMask) {
	    sprintf(tbuf,"%sBounceKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbStickyKeysMask) {
	    sprintf(tbuf,"%sStickyKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbMouseKeysMask) {
	    sprintf(tbuf,"%sMouseKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbMouseKeysAccelMask) {
	    sprintf(tbuf,"%sMouseKeysAccel",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXKeysMask) {
	    sprintf(tbuf,"%sAccessXKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXTimeoutMask) {
	    sprintf(tbuf,"%sAccessXTimeout",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXFeedbackMask) {
	    sprintf(tbuf,"%sAccessXFeedback",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAudibleBellMask) {
	    sprintf(tbuf,"%sAudibleBell",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbOverlay1Mask) {
	    sprintf(tbuf,"%sOverlay1",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbOverlay2Mask) {
	    sprintf(tbuf,"%sOverlay2",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbIgnoreGroupLockMask) {
	    sprintf(tbuf,"%sIgnoreGroupLock",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyActionMessageArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbMessageAction *	act;
unsigned		all;
char			tbuf[32];

    act= &action->msg;
    all= XkbSA_MessageOnPress|XkbSA_MessageOnRelease;
    TryCopyStr(buf,"report=",sz);
    if ((act->flags&all)==0)
	TryCopyStr(buf,"none",sz);
    else if ((act->flags&all)==all)
	TryCopyStr(buf,"all",sz);
    else if (act->flags&XkbSA_MessageOnPress)
	 TryCopyStr(buf,"KeyPress",sz);
    else TryCopyStr(buf,"KeyRelease",sz);
    sprintf(tbuf,",data[0]=0x%02x",act->message[0]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[1]=0x%02x",act->message[1]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[2]=0x%02x",act->message[2]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[3]=0x%02x",act->message[3]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[4]=0x%02x",act->message[4]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[5]=0x%02x",act->message[5]); TryCopyStr(buf,tbuf,sz);
    return TRUE;
}

static Bool
CopyRedirectKeyArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbRedirectKeyAction *	act;
char			tbuf[32],*tmp;
unsigned		kc;
unsigned		vmods,vmods_mask;

    act= &action->redirect;
    kc= act->new_key;
    vmods= XkbSARedirectVMods(act);
    vmods_mask= XkbSARedirectVModsMask(act);
    if (xkb && xkb->names && xkb->names->keys && (kc<=xkb->max_key_code) &&
				(xkb->names->keys[kc].name[0]!='\0')) {
	char *kn;
	kn= XkbKeyNameText(xkb->names->keys[kc].name,XkbXKBFile);
	sprintf(tbuf,"key=%s",kn);
    }
    else sprintf(tbuf,"key=%d",kc);
    TryCopyStr(buf,tbuf,sz);
    if ((act->mods_mask==0)&&(vmods_mask==0))
	return TRUE;
    if ((act->mods_mask==XkbAllModifiersMask)&&
	(vmods_mask==XkbAllVirtualModsMask)) {
	tmp= XkbVModMaskText(xkb,act->mods,vmods,XkbXKBFile);
	TryCopyStr(buf,",mods=",sz);
	TryCopyStr(buf,tmp,sz);
    }
    else {
	if ((act->mods_mask&act->mods)||(vmods_mask&vmods)) {
	    tmp= XkbVModMaskText(xkb,act->mods_mask&act->mods,
					 vmods_mask&vmods,XkbXKBFile);
	    TryCopyStr(buf,",mods= ",sz);
	    TryCopyStr(buf,tmp,sz);
	}
	if ((act->mods_mask&(~act->mods))||(vmods_mask&(~vmods))) {
	    tmp= XkbVModMaskText(xkb,act->mods_mask&(~act->mods),
					 vmods_mask&(~vmods),XkbXKBFile);
	    TryCopyStr(buf,",clearMods= ",sz);
	    TryCopyStr(buf,tmp,sz);
	}
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyDeviceBtnArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
{
XkbDeviceBtnAction *	act;
char			tbuf[32];

    act= &action->devbtn;
    sprintf(tbuf,"device= %d",act->device); TryCopyStr(buf,tbuf,sz);
    TryCopyStr(buf,",button=",sz);
    sprintf(tbuf,"%d",act->button);
    TryCopyStr(buf,tbuf,sz);
    if (act->count>0) {
	sprintf(tbuf,",count=%d",act->count);
	TryCopyStr(buf,tbuf,sz);
    }
    if (action->type==XkbSA_LockDeviceBtn) {
	switch (act->flags&(XkbSA_LockNoUnlock|XkbSA_LockNoLock)) {
	    case XkbSA_LockNoLock:
		sprintf(tbuf,",affect=unlock"); break;
	    case XkbSA_LockNoUnlock:
		sprintf(tbuf,",affect=lock"); break;
	    case XkbSA_LockNoUnlock|XkbSA_LockNoLock:
		sprintf(tbuf,",affect=neither"); break;
	    default:
		sprintf(tbuf,",affect=both"); break;
	}
	TryCopyStr(buf,tbuf,sz);
    }
    return TRUE;
}

/*ARGSUSED*/
static Bool
CopyOtherArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
{
XkbAnyAction *	act;
char		tbuf[32];

    act= &action->any;
    sprintf(tbuf,"type=0x%02x",act->type); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[0]=0x%02x",act->data[0]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[1]=0x%02x",act->data[1]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[2]=0x%02x",act->data[2]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[3]=0x%02x",act->data[3]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[4]=0x%02x",act->data[4]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[5]=0x%02x",act->data[5]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[6]=0x%02x",act->data[6]); TryCopyStr(buf,tbuf,sz);
    return TRUE;
}

typedef	Bool	(*actionCopy)(
	XkbDescPtr 	/* xkb */,
	XkbAction *	/* action */,
	char *		/* buf */,
	int*		/* sz */
);
static actionCopy	copyActionArgs[XkbSA_NumActions] = {
	CopyNoActionArgs		/* NoAction	*/,
	CopyModActionArgs		/* SetMods	*/,
	CopyModActionArgs		/* LatchMods	*/,
	CopyModActionArgs		/* LockMods	*/,
	CopyGroupActionArgs		/* SetGroup	*/,
	CopyGroupActionArgs		/* LatchGroup	*/,
	CopyGroupActionArgs		/* LockGroup	*/,
	CopyMovePtrArgs			/* MovePtr	*/,
	CopyPtrBtnArgs			/* PtrBtn	*/,
	CopyPtrBtnArgs			/* LockPtrBtn	*/,
	CopySetPtrDfltArgs		/* SetPtrDflt	*/,
	CopyISOLockArgs			/* ISOLock	*/,
	CopyNoActionArgs		/* Terminate	*/,
	CopySwitchScreenArgs		/* SwitchScreen	*/,
	CopySetLockControlsArgs		/* SetControls	*/,
	CopySetLockControlsArgs		/* LockControls	*/,
	CopyActionMessageArgs		/* ActionMessage*/,
	CopyRedirectKeyArgs		/* RedirectKey	*/,
	CopyDeviceBtnArgs		/* DeviceBtn	*/,
	CopyDeviceBtnArgs		/* LockDeviceBtn*/
};

#define	ACTION_SZ	256

char *
XkbActionText(XkbDescPtr xkb,XkbAction *action,unsigned format)
{
char	buf[ACTION_SZ],*tmp;
int	sz;

    if (format==XkbCFile) {
	sprintf(buf,
	    "{ %20s, { 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x } }",
	    XkbActionTypeText(action->type,XkbCFile),
	    action->any.data[0],action->any.data[1],action->any.data[2],
	    action->any.data[3],action->any.data[4],action->any.data[5],
	    action->any.data[6]);
    }
    else {
	sprintf(buf,"%s(",XkbActionTypeText(action->type,XkbXKBFile));
	sz= ACTION_SZ-strlen(buf)+2; /* room for close paren and NULL */
	if (action->type<(unsigned)XkbSA_NumActions)
	     (*copyActionArgs[action->type])(xkb,action,buf,&sz);
	else CopyOtherArgs(xkb,action,buf,&sz);
	TryCopyStr(buf,")",&sz);
    }
    tmp= tbGetBuffer(strlen(buf)+1);
    if (tmp!=NULL)
	strcpy(tmp,buf);
    return tmp;
}

char *
XkbBehaviorText(XkbDescPtr xkb,XkbBehavior *behavior,unsigned format)
{
char	buf[256],*tmp;

    if (format==XkbCFile) {
	if (behavior->type==XkbKB_Default)
	     sprintf(buf,"{   0,    0 }");
	else sprintf(buf,"{ %3d, 0x%02x }",behavior->type,behavior->data);
    }
    else {
	unsigned 	type,permanent;
	type= behavior->type&XkbKB_OpMask;
	permanent=((behavior->type&XkbKB_Permanent)!=0);

	if (type==XkbKB_Lock) {
	    sprintf(buf,"lock= %s",(permanent?"Permanent":"TRUE"));
	}
	else if (type==XkbKB_RadioGroup) {
	    int 	g;
	    char	*tmp;
	    g= ((behavior->data)&(~XkbKB_RGAllowNone))+1;
	    if (XkbKB_RGAllowNone&behavior->data) {
		sprintf(buf,"allowNone,");
		tmp= &buf[strlen(buf)];
	    }
	    else tmp= buf;
	    if (permanent)
		 sprintf(tmp,"permanentRadioGroup= %d",g);
	    else sprintf(tmp,"radioGroup= %d",g);
	}
	else if ((type==XkbKB_Overlay1)||(type==XkbKB_Overlay2)) {
	    int ndx,kc;
	    char *kn;

	    ndx= ((type==XkbKB_Overlay1)?1:2);
	    kc= behavior->data;
	    if ((xkb)&&(xkb->names)&&(xkb->names->keys))
		kn= XkbKeyNameText(xkb->names->keys[kc].name,XkbXKBFile);
	    else {
		static char tbuf[8];
		sprintf(tbuf,"%d",kc);
		kn= tbuf;
	    }
	    if (permanent)
		 sprintf(buf,"permanentOverlay%d= %s",ndx,kn);
	    else sprintf(buf,"overlay%d= %s",ndx,kn);
	}
    }
    tmp= tbGetBuffer(strlen(buf)+1);
    if (tmp!=NULL)
	strcpy(tmp,buf);
    return tmp;
}

/***====================================================================***/

char *
XkbIndentText(unsigned size)
{
static char buf[32];
register int i;

    if (size>31)
	size= 31;

    for (i=0;i<size;i++) {
	buf[i]= ' ';
    }
    buf[size]= '\0';
    return buf;
}
/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability 
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/
/*

Copyright © 2008 Red Hat Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "os.h"
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#define	XK_CYRILLIC
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "eventstr.h"

#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "xkbgeom.h"
#include "xkb.h"

/***====================================================================***/

int
_XkbLookupAnyDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
		    Mask access_mode, int *xkb_err)
{
    int rc = XkbKeyboardErrorCode;

    if (id == XkbUseCoreKbd)
        id = PickKeyboard(client)->id;
    else if (id == XkbUseCorePtr)
        id = PickPointer(client)->id;

    rc = dixLookupDevice(pDev, id, client, access_mode);
    if (rc != Success)
	*xkb_err = XkbErr_BadDevice;

    return rc;
}

int
_XkbLookupKeyboard(DeviceIntPtr *pDev, int id, ClientPtr client,
		   Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    if (id == XkbDfltXIId)
        id = XkbUseCoreKbd;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
	return rc;

    dev = *pDev;
    if (!dev->key || !dev->key->xkbInfo) {
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupBellDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
		     Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
	return rc;

    dev = *pDev;
    if (!dev->kbdfeed && !dev->bell) {
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupLedDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
		    Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    if (id == XkbDfltXIId)
        id = XkbUseCorePtr;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
	return rc;

    dev = *pDev;
    if (!dev->kbdfeed && !dev->leds) {
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupButtonDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
		       Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
	return rc;

    dev = *pDev;
    if (!dev->button) {
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
    }
    return Success;
}

void
XkbSetActionKeyMods(XkbDescPtr xkb,XkbAction *act,unsigned mods)
{
register unsigned	tmp;

    switch (act->type) {
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (act->mods.flags&XkbSA_UseModMapMods)
		act->mods.real_mods= act->mods.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->mods))!=0)
		act->mods.mask|= XkbMaskForVMask(xkb,tmp);
	    break;
	case XkbSA_ISOLock:
	    if (act->iso.flags&XkbSA_UseModMapMods)
		act->iso.real_mods= act->iso.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->iso))!=0)
		act->iso.mask|= XkbMaskForVMask(xkb,tmp);
	    break;
    }
    return;
}

unsigned
XkbMaskForVMask(XkbDescPtr xkb,unsigned vmask)
{
register int i,bit;
register unsigned mask;
    
    for (mask=i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (vmask&bit)
	    mask|= xkb->server->vmods[i];
    }
    return mask;
}

/***====================================================================***/

void
XkbUpdateKeyTypesFromCore(	DeviceIntPtr	pXDev,
                                KeySymsPtr      pCore,
				KeyCode	 	first,
				CARD8	 	num,
				XkbChangesPtr	changes)
{
XkbDescPtr		xkb;
unsigned		key,nG,explicit;
int			types[XkbNumKbdGroups];
KeySym			tsyms[XkbMaxSymsPerKey],*syms;
XkbMapChangesPtr	mc;

    xkb= pXDev->key->xkbInfo->desc;
    if (first+num-1>xkb->max_key_code) {
	/* 1/12/95 (ef) -- XXX! should allow XKB structures to grow */
	num= xkb->max_key_code-first+1;
    }

    mc= (changes?(&changes->map):NULL);

    syms= &pCore->map[(first - pCore->minKeyCode) * pCore->mapWidth];
    for (key=first; key<(first+num); key++,syms+= pCore->mapWidth) {
        explicit= xkb->server->explicit[key]&XkbExplicitKeyTypesMask;
        types[XkbGroup1Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup1Index);
        types[XkbGroup2Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup2Index);
        types[XkbGroup3Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup3Index);
        types[XkbGroup4Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup4Index);
        nG= XkbKeyTypesForCoreSymbols(xkb,pCore->mapWidth,syms,explicit,types,
									tsyms);
	XkbChangeTypesOfKey(xkb,key,nG,XkbAllGroupsMask,types,mc);
	memcpy((char *)XkbKeySymsPtr(xkb,key),(char *)tsyms,
					XkbKeyNumSyms(xkb,key)*sizeof(KeySym));
    }
    if (changes->map.changed&XkbKeySymsMask) {
	CARD8 oldLast,newLast;
	oldLast = changes->map.first_key_sym+changes->map.num_key_syms-1;
	newLast = first+num-1;

	if (first<changes->map.first_key_sym)
	    changes->map.first_key_sym = first;
	if (oldLast>newLast)
	    newLast= oldLast;
	changes->map.num_key_syms = newLast-changes->map.first_key_sym+1;
    }
    else {
	changes->map.changed|= XkbKeySymsMask;
	changes->map.first_key_sym = first;
	changes->map.num_key_syms = num;
    }
    return;
}

void
XkbUpdateDescActions(	XkbDescPtr		xkb,
			KeyCode		 	first,
			CARD8		 	num,
			XkbChangesPtr	 	changes)
{
register unsigned	key;

    for (key=first;key<(first+num);key++) {
	XkbApplyCompatMapToKey(xkb,key,changes);
    }

    if (changes->map.changed&(XkbVirtualModMapMask|XkbModifierMapMask)) {
        unsigned char           newVMods[XkbNumVirtualMods];
        register  unsigned      bit,i;
        unsigned                present;

        memset(newVMods, 0, XkbNumVirtualMods);
        present= 0;
        for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
            if (xkb->server->vmodmap[key]==0)
                continue;
            for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
                if (bit&xkb->server->vmodmap[key]) {
                    present|= bit;
                    newVMods[i]|= xkb->map->modmap[key];
                }
            }
        }
        for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
            if ((bit&present)&&(newVMods[i]!=xkb->server->vmods[i])) {
                changes->map.changed|= XkbVirtualModsMask;
                changes->map.vmods|= bit;
                xkb->server->vmods[i]= newVMods[i];
            }
        }
    }
    if (changes->map.changed&XkbVirtualModsMask)
        XkbApplyVirtualModChanges(xkb,changes->map.vmods,changes);

    if (changes->map.changed&XkbKeyActionsMask) {
	CARD8 oldLast,newLast;
	oldLast= changes->map.first_key_act+changes->map.num_key_acts-1;
	newLast = first+num-1;

	if (first<changes->map.first_key_act)
	    changes->map.first_key_act = first;
	if (newLast>oldLast)
	    newLast= oldLast;
	changes->map.num_key_acts= newLast-changes->map.first_key_act+1;
    }
    else {
	changes->map.changed|= XkbKeyActionsMask;
	changes->map.first_key_act = first;
	changes->map.num_key_acts = num;
    }
    return;
}

void
XkbUpdateActions(	DeviceIntPtr	 	pXDev,
			KeyCode		 	first,
			CARD8		 	num,
			XkbChangesPtr	 	changes,
			unsigned *	 	needChecksRtrn,
			XkbEventCausePtr	cause)
{
XkbSrvInfoPtr		xkbi;
XkbDescPtr		xkb;
CARD8 *			repeat;

    if (needChecksRtrn)
	*needChecksRtrn= 0;
    xkbi= pXDev->key->xkbInfo;
    xkb= xkbi->desc;
    repeat= xkb->ctrls->per_key_repeat;

    /* before letting XKB do any changes, copy the current core values */
    if (pXDev->kbdfeed)
	memcpy(repeat,pXDev->kbdfeed->ctrl.autoRepeats,XkbPerKeyBitArraySize);

    XkbUpdateDescActions(xkb,first,num,changes);

    if ((pXDev->kbdfeed)&&
	(changes->ctrls.changed_ctrls&XkbPerKeyRepeatMask)) {
	/* now copy the modified changes back to core */
	memcpy(pXDev->kbdfeed->ctrl.autoRepeats,repeat, XkbPerKeyBitArraySize);
	if (pXDev->kbdfeed->CtrlProc)
	    (*pXDev->kbdfeed->CtrlProc)(pXDev, &pXDev->kbdfeed->ctrl);
    }
    return;
}

KeySymsPtr
XkbGetCoreMap(DeviceIntPtr keybd)
{
register int		key,tmp;
int			maxSymsPerKey, maxGroup1Width;
XkbDescPtr		xkb;
KeySymsPtr              syms;
int			maxNumberOfGroups;

    if (!keybd || !keybd->key || !keybd->key->xkbInfo)
	return NULL;

    xkb= keybd->key->xkbInfo->desc;
    maxSymsPerKey= maxGroup1Width= 0;
    maxNumberOfGroups = 0;

    /* determine sizes */
    for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
	if (XkbKeycodeInRange(xkb,key)) {
	    int	nGroups;
	    int	w;
	    nGroups= XkbKeyNumGroups(xkb,key);
	    tmp= 0;
	    if (nGroups>0) {
		if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup1Index))<=2)
		     tmp+= 2;
		else tmp+= w + 2;
                /* remember highest G1 width */
                if (w > maxGroup1Width)
                    maxGroup1Width = w;
	    }
	    if (nGroups>1) {
                if (tmp <= 2) {
		     if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup2Index))<2)
		          tmp+= 2;
		     else tmp+= w;
                } else {
                     if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup2Index))>2)
                          tmp+= w - 2;
                }
	    }
	    if (nGroups>2)
		tmp+= XkbKeyGroupWidth(xkb,key,XkbGroup3Index);
	    if (nGroups>3)
		tmp+= XkbKeyGroupWidth(xkb,key,XkbGroup4Index);
	    if (tmp>maxSymsPerKey)
		maxSymsPerKey= tmp;
            if (nGroups > maxNumberOfGroups)
		maxNumberOfGroups = nGroups;
	}
    }

    if (maxSymsPerKey <= 0)
        return NULL;

    syms = calloc(1, sizeof(*syms));
    if (!syms)
        return NULL;

    /* See Section 12.4 of the XKB Protocol spec. Because of the
     * single-group distribution for multi-group keyboards, we have to
     * have enough symbols for the largest group 1 to replicate across the
     * number of groups on the keyboard. e.g. a single-group key with 4
     * symbols on a keyboard that has 3 groups -> 12 syms per key */
    if (maxSymsPerKey < maxNumberOfGroups * maxGroup1Width)
        maxSymsPerKey = maxNumberOfGroups * maxGroup1Width;

    syms->mapWidth = maxSymsPerKey;
    syms->minKeyCode = xkb->min_key_code;
    syms->maxKeyCode = xkb->max_key_code;

    tmp = syms->mapWidth * (xkb->max_key_code - xkb->min_key_code + 1);
    syms->map = calloc(tmp, sizeof(*syms->map));
    if (!syms->map) {
        free(syms);
        return NULL;
    }

    for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
        KeySym *pCore,*pXKB;
        unsigned nGroups,groupWidth,n,nOut;

        nGroups= XkbKeyNumGroups(xkb,key);
        n= (key-xkb->min_key_code)*syms->mapWidth;
        pCore= &syms->map[n];
        pXKB= XkbKeySymsPtr(xkb,key);
        nOut= 2;
        if (nGroups>0) {
            groupWidth= XkbKeyGroupWidth(xkb,key,XkbGroup1Index);
            if (groupWidth>0)   pCore[0]= pXKB[0];
            if (groupWidth>1)   pCore[1]= pXKB[1];
            for (n=2;n<groupWidth;n++)
                pCore[2+n]= pXKB[n];
            if (groupWidth>2)
                nOut= groupWidth;
        }

	/* See XKB Protocol Sec, Section 12.4.
           A 1-group key with ABCDE on a 2 group keyboard must be
	   duplicated across all groups as ABABCDECDE.
	 */
	if (nGroups == 1)
	{
	    int idx, j;

	    groupWidth = XkbKeyGroupWidth(xkb, key, XkbGroup1Index);

	    /* AB..CDE... -> ABABCDE... */
	    if (groupWidth > 0 && syms->mapWidth >= 3)
	        pCore[2] = pCore[0];
	    if (groupWidth > 1 && syms->mapWidth >= 4)
	        pCore[3] = pCore[1];

	    /* ABABCDE... -> ABABCDECDE */
	    idx = 2 + groupWidth;
	    while (groupWidth > 2 && idx < syms->mapWidth &&
		   idx < groupWidth * 2)
	    {
		pCore[idx] = pCore[idx - groupWidth + 2];
		idx++;
	    }
	    idx = 2 * groupWidth;
	    if (idx < 4)
		idx = 4;
	    /* 3 or more groups: ABABCDECDEABCDEABCDE */
	    for (j = 3; j <= maxNumberOfGroups; j++)
		for (n = 0; n < groupWidth && idx < maxSymsPerKey; n++)
		    pCore[idx++] = pXKB[n];
	}

	pXKB+= XkbKeyGroupsWidth(xkb,key);
	nOut+= 2;
	if (nGroups>1) {
	    groupWidth= XkbKeyGroupWidth(xkb,key,XkbGroup2Index);
	    if (groupWidth>0)	pCore[2]= pXKB[0];
	    if (groupWidth>1)	pCore[3]= pXKB[1];
	    for (n=2;n<groupWidth;n++) {
		pCore[nOut+(n-2)]= pXKB[n];
	    }
	    if (groupWidth>2)
		nOut+= (groupWidth-2);
	}
	pXKB+= XkbKeyGroupsWidth(xkb,key);
	for (n=XkbGroup3Index;n<nGroups;n++) {
	    register int s;
	    groupWidth= XkbKeyGroupWidth(xkb,key,n);
	    for (s=0;s<groupWidth;s++) {
		pCore[nOut++]= pXKB[s];
	    }
	    pXKB+= XkbKeyGroupsWidth(xkb,key);
	}
    }

    return syms;
}

void
XkbSetRepeatKeys(DeviceIntPtr pXDev,int key,int onoff)
{
    if (pXDev && pXDev->key && pXDev->key->xkbInfo) {
	xkbControlsNotify	cn;
	XkbControlsPtr		ctrls = pXDev->key->xkbInfo->desc->ctrls;
	XkbControlsRec 		old;
	old = *ctrls;

	if (key== -1) {	/* global autorepeat setting changed */
	    if (onoff)	ctrls->enabled_ctrls |= XkbRepeatKeysMask;
	    else	ctrls->enabled_ctrls &= ~XkbRepeatKeysMask;
	}
	else if (pXDev->kbdfeed) {
	    ctrls->per_key_repeat[key/8] = 
		pXDev->kbdfeed->ctrl.autoRepeats[key/8];
	}
	
	if (XkbComputeControlsNotify(pXDev,&old,ctrls,&cn,TRUE))
	    XkbSendControlsNotify(pXDev,&cn);
    }
    return;
}

/* Applies a change to a single device, does not traverse the device tree. */
void
XkbApplyMappingChange(DeviceIntPtr kbd, KeySymsPtr map, KeyCode first_key,
                      CARD8 num_keys, CARD8 *modmap, ClientPtr client)
{
    XkbDescPtr xkb = kbd->key->xkbInfo->desc;
    XkbEventCauseRec cause;
    XkbChangesRec changes;
    unsigned int check;

    memset(&changes, 0, sizeof(changes));
    memset(&cause, 0, sizeof(cause));

    if (map && first_key && num_keys) {
        check = 0;
        XkbSetCauseCoreReq(&cause, X_ChangeKeyboardMapping, client);

        XkbUpdateKeyTypesFromCore(kbd, map, first_key, num_keys, &changes);
        XkbUpdateActions(kbd, first_key, num_keys, &changes, &check, &cause);

        if (check)
            XkbCheckSecondaryEffects(kbd->key->xkbInfo, 1, &changes, &cause);
    }

    if (modmap) {
        /* A keymap change can imply a modmap change, se we prefer the
         * former. */
        if (!cause.mjr)
            XkbSetCauseCoreReq(&cause,X_SetModifierMapping,client);

        check = 0;
        num_keys = xkb->max_key_code - xkb->min_key_code + 1;
        changes.map.changed |= XkbModifierMapMask;
        changes.map.first_modmap_key = xkb->min_key_code;
        changes.map.num_modmap_keys = num_keys;
        memcpy(kbd->key->xkbInfo->desc->map->modmap, modmap, MAP_LENGTH);
        XkbUpdateActions(kbd, xkb->min_key_code, num_keys, &changes, &check,
                         &cause);

        if (check)
            XkbCheckSecondaryEffects(kbd->key->xkbInfo, 1, &changes, &cause);
    }

    XkbSendNotification(kbd, &changes, &cause);
}

void
XkbDisableComputedAutoRepeats(DeviceIntPtr dev,unsigned key)
{
XkbSrvInfoPtr	xkbi = dev->key->xkbInfo;
xkbMapNotify	mn;

    xkbi->desc->server->explicit[key]|= XkbExplicitAutoRepeatMask;
    memset(&mn, 0, sizeof(mn));
    mn.changed= XkbExplicitComponentsMask;
    mn.firstKeyExplicit= key;
    mn.nKeyExplicit= 1;
    XkbSendMapNotify(dev,&mn);
    return;
}

unsigned
XkbStateChangedFlags(XkbStatePtr old,XkbStatePtr new)
{
int		changed;

    changed=(old->group!=new->group?XkbGroupStateMask:0);
    changed|=(old->base_group!=new->base_group?XkbGroupBaseMask:0);
    changed|=(old->latched_group!=new->latched_group?XkbGroupLatchMask:0);
    changed|=(old->locked_group!=new->locked_group?XkbGroupLockMask:0);
    changed|=(old->mods!=new->mods?XkbModifierStateMask:0);
    changed|=(old->base_mods!=new->base_mods?XkbModifierBaseMask:0);
    changed|=(old->latched_mods!=new->latched_mods?XkbModifierLatchMask:0);
    changed|=(old->locked_mods!=new->locked_mods?XkbModifierLockMask:0);
    changed|=(old->compat_state!=new->compat_state?XkbCompatStateMask:0);
    changed|=(old->grab_mods!=new->grab_mods?XkbGrabModsMask:0);
    if (old->compat_grab_mods!=new->compat_grab_mods)
	changed|= XkbCompatGrabModsMask;
    changed|=(old->lookup_mods!=new->lookup_mods?XkbLookupModsMask:0);
    if (old->compat_lookup_mods!=new->compat_lookup_mods)
	changed|= XkbCompatLookupModsMask;
    changed|=(old->ptr_buttons!=new->ptr_buttons?XkbPointerButtonMask:0);
    return changed;
}

static void
XkbComputeCompatState(XkbSrvInfoPtr xkbi)
{
CARD16 		grp_mask;
XkbStatePtr	state= &xkbi->state;
XkbCompatMapPtr	map;

    if (!state || !xkbi->desc || !xkbi->desc->ctrls || !xkbi->desc->compat)
        return;

    map= xkbi->desc->compat;
    grp_mask= map->groups[state->group].mask;
    state->compat_state = state->mods|grp_mask;
    state->compat_lookup_mods= state->lookup_mods|grp_mask;

    if (xkbi->desc->ctrls->enabled_ctrls&XkbIgnoreGroupLockMask)
	 grp_mask= map->groups[state->base_group].mask;
    state->compat_grab_mods= state->grab_mods|grp_mask;
    return;
}

unsigned
XkbAdjustGroup(int group,XkbControlsPtr ctrls)
{
unsigned	act;

    act= XkbOutOfRangeGroupAction(ctrls->groups_wrap);
    if (group<0) {
	while ( group < 0 )  {
	    if (act==XkbClampIntoRange) {
		group= XkbGroup1Index;
	    }
	    else if (act==XkbRedirectIntoRange) {
		int newGroup;
		newGroup= XkbOutOfRangeGroupNumber(ctrls->groups_wrap);
		if (newGroup>=ctrls->num_groups)
		     group= XkbGroup1Index;
		else group= newGroup;
	    }
	    else {
		group+= ctrls->num_groups;
	    }
	}
    }
    else if (group>=ctrls->num_groups) {
	if (act==XkbClampIntoRange) {
	    group= ctrls->num_groups-1;
	}
	else if (act==XkbRedirectIntoRange) {
	    int newGroup;
	    newGroup= XkbOutOfRangeGroupNumber(ctrls->groups_wrap);
	    if (newGroup>=ctrls->num_groups)
		 group= XkbGroup1Index;
	    else group= newGroup;
	}
	else {
	    group%= ctrls->num_groups;
	}
    }
    return group;
}

void
XkbComputeDerivedState(XkbSrvInfoPtr xkbi)
{
XkbStatePtr	state= &xkbi->state;
XkbControlsPtr	ctrls= xkbi->desc->ctrls;
unsigned char	grp;

    if (!state || !ctrls)
        return;

    state->mods= (state->base_mods|state->latched_mods|state->locked_mods);
    state->lookup_mods= state->mods&(~ctrls->internal.mask);
    state->grab_mods= state->lookup_mods&(~ctrls->ignore_lock.mask);
    state->grab_mods|= 
	((state->base_mods|state->latched_mods)&ctrls->ignore_lock.mask);


    grp= state->locked_group;
    if (grp>=ctrls->num_groups)
	state->locked_group= XkbAdjustGroup(XkbCharToInt(grp),ctrls);

    grp= state->locked_group+state->base_group+state->latched_group;
    if (grp>=ctrls->num_groups)
	 state->group= XkbAdjustGroup(XkbCharToInt(grp),ctrls);
    else state->group= grp;
    XkbComputeCompatState(xkbi);
    return;
}

/***====================================================================***/

void
XkbCheckSecondaryEffects(	XkbSrvInfoPtr		xkbi,
				unsigned		which,
				XkbChangesPtr 		changes,
				XkbEventCausePtr	cause)
{
    if (which&XkbStateNotifyMask) {
	XkbStateRec old;
	old= xkbi->state;
	changes->state_changes|= XkbStateChangedFlags(&old,&xkbi->state);
	XkbComputeDerivedState(xkbi);
    }
    if (which&XkbIndicatorStateNotifyMask)
	XkbUpdateIndicators(xkbi->device,XkbAllIndicatorsMask,TRUE,changes,
									cause);
    return;
}

/***====================================================================***/

Bool
XkbEnableDisableControls(	XkbSrvInfoPtr		xkbi,
				unsigned long		change,
				unsigned long		newValues,
				XkbChangesPtr		changes,
				XkbEventCausePtr	cause)
{
XkbControlsPtr		ctrls;
unsigned 		old;
XkbSrvLedInfoPtr	sli;

    ctrls= xkbi->desc->ctrls;
    old= ctrls->enabled_ctrls;
    ctrls->enabled_ctrls&= ~change;
    ctrls->enabled_ctrls|= (change&newValues);
    if (old==ctrls->enabled_ctrls)
	return FALSE;
    if (cause!=NULL) {
	xkbControlsNotify cn;
	cn.numGroups= ctrls->num_groups;
	cn.changedControls= XkbControlsEnabledMask;
	cn.enabledControls= ctrls->enabled_ctrls;
	cn.enabledControlChanges= (ctrls->enabled_ctrls^old);
	cn.keycode= cause->kc;
	cn.eventType= cause->event;
	cn.requestMajor= cause->mjr;
	cn.requestMinor= cause->mnr;
	XkbSendControlsNotify(xkbi->device,&cn);
    }
    else {
	/* Yes, this really should be an XOR.  If ctrls->enabled_ctrls_changes*/
	/* is non-zero, the controls in question changed already in "this" */
	/* request and this change merely undoes the previous one.  By the */
	/* same token, we have to figure out whether or not ControlsEnabled */
	/* should be set or not in the changes structure */
	changes->ctrls.enabled_ctrls_changes^= (ctrls->enabled_ctrls^old);
	if (changes->ctrls.enabled_ctrls_changes)
	     changes->ctrls.changed_ctrls|= XkbControlsEnabledMask;
	else changes->ctrls.changed_ctrls&= ~XkbControlsEnabledMask;
    }
    sli= XkbFindSrvLedInfo(xkbi->device,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(xkbi->device,sli->usesControls,TRUE,changes,cause);
    return TRUE;
}

/***====================================================================***/

#define	MAX_TOC	16

XkbGeometryPtr
XkbLookupNamedGeometry(DeviceIntPtr dev,Atom name,Bool *shouldFree)
{
XkbSrvInfoPtr	xkbi=	dev->key->xkbInfo;
XkbDescPtr	xkb=	xkbi->desc;

    *shouldFree= 0;
    if (name==None) {
	if (xkb->geom!=NULL)
	    return xkb->geom;
	name= xkb->names->geometry;
    }
    if ((xkb->geom!=NULL)&&(xkb->geom->name==name))
	return xkb->geom;
    *shouldFree= 1;
    return NULL;
}

void
XkbConvertCase(register KeySym sym, KeySym *lower, KeySym *upper)
{
    *lower = sym;
    *upper = sym;
    switch(sym >> 8) {
    case 0: /* Latin 1 */
	if ((sym >= XK_A) && (sym <= XK_Z))
	    *lower += (XK_a - XK_A);
	else if ((sym >= XK_a) && (sym <= XK_z))
	    *upper -= (XK_a - XK_A);
	else if ((sym >= XK_Agrave) && (sym <= XK_Odiaeresis))
	    *lower += (XK_agrave - XK_Agrave);
	else if ((sym >= XK_agrave) && (sym <= XK_odiaeresis))
	    *upper -= (XK_agrave - XK_Agrave);
	else if ((sym >= XK_Ooblique) && (sym <= XK_Thorn))
	    *lower += (XK_oslash - XK_Ooblique);
	else if ((sym >= XK_oslash) && (sym <= XK_thorn))
	    *upper -= (XK_oslash - XK_Ooblique);
	break;
    case 1: /* Latin 2 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym == XK_Aogonek)
	    *lower = XK_aogonek;
	else if (sym >= XK_Lstroke && sym <= XK_Sacute)
	    *lower += (XK_lstroke - XK_Lstroke);
	else if (sym >= XK_Scaron && sym <= XK_Zacute)
	    *lower += (XK_scaron - XK_Scaron);
	else if (sym >= XK_Zcaron && sym <= XK_Zabovedot)
	    *lower += (XK_zcaron - XK_Zcaron);
	else if (sym == XK_aogonek)
	    *upper = XK_Aogonek;
	else if (sym >= XK_lstroke && sym <= XK_sacute)
	    *upper -= (XK_lstroke - XK_Lstroke);
	else if (sym >= XK_scaron && sym <= XK_zacute)
	    *upper -= (XK_scaron - XK_Scaron);
	else if (sym >= XK_zcaron && sym <= XK_zabovedot)
	    *upper -= (XK_zcaron - XK_Zcaron);
	else if (sym >= XK_Racute && sym <= XK_Tcedilla)
	    *lower += (XK_racute - XK_Racute);
	else if (sym >= XK_racute && sym <= XK_tcedilla)
	    *upper -= (XK_racute - XK_Racute);
	break;
    case 2: /* Latin 3 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Hstroke && sym <= XK_Hcircumflex)
	    *lower += (XK_hstroke - XK_Hstroke);
	else if (sym >= XK_Gbreve && sym <= XK_Jcircumflex)
	    *lower += (XK_gbreve - XK_Gbreve);
	else if (sym >= XK_hstroke && sym <= XK_hcircumflex)
	    *upper -= (XK_hstroke - XK_Hstroke);
	else if (sym >= XK_gbreve && sym <= XK_jcircumflex)
	    *upper -= (XK_gbreve - XK_Gbreve);
	else if (sym >= XK_Cabovedot && sym <= XK_Scircumflex)
	    *lower += (XK_cabovedot - XK_Cabovedot);
	else if (sym >= XK_cabovedot && sym <= XK_scircumflex)
	    *upper -= (XK_cabovedot - XK_Cabovedot);
	break;
    case 3: /* Latin 4 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Rcedilla && sym <= XK_Tslash)
	    *lower += (XK_rcedilla - XK_Rcedilla);
	else if (sym >= XK_rcedilla && sym <= XK_tslash)
	    *upper -= (XK_rcedilla - XK_Rcedilla);
	else if (sym == XK_ENG)
	    *lower = XK_eng;
	else if (sym == XK_eng)
	    *upper = XK_ENG;
	else if (sym >= XK_Amacron && sym <= XK_Umacron)
	    *lower += (XK_amacron - XK_Amacron);
	else if (sym >= XK_amacron && sym <= XK_umacron)
	    *upper -= (XK_amacron - XK_Amacron);
	break;
    case 6: /* Cyrillic */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Serbian_DJE && sym <= XK_Serbian_DZE)
	    *lower -= (XK_Serbian_DJE - XK_Serbian_dje);
	else if (sym >= XK_Serbian_dje && sym <= XK_Serbian_dze)
	    *upper += (XK_Serbian_DJE - XK_Serbian_dje);
	else if (sym >= XK_Cyrillic_YU && sym <= XK_Cyrillic_HARDSIGN)
	    *lower -= (XK_Cyrillic_YU - XK_Cyrillic_yu);
	else if (sym >= XK_Cyrillic_yu && sym <= XK_Cyrillic_hardsign)
	    *upper += (XK_Cyrillic_YU - XK_Cyrillic_yu);
        break;
    case 7: /* Greek */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Greek_ALPHAaccent && sym <= XK_Greek_OMEGAaccent)
	    *lower += (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
	else if (sym >= XK_Greek_alphaaccent && sym <= XK_Greek_omegaaccent &&
		 sym != XK_Greek_iotaaccentdieresis &&
		 sym != XK_Greek_upsilonaccentdieresis)
	    *upper -= (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
	else if (sym >= XK_Greek_ALPHA && sym <= XK_Greek_OMEGA)
	    *lower += (XK_Greek_alpha - XK_Greek_ALPHA);
	else if (sym >= XK_Greek_alpha && sym <= XK_Greek_omega &&
		 sym != XK_Greek_finalsmallsigma)
	    *upper -= (XK_Greek_alpha - XK_Greek_ALPHA);
        break;
    }
}

static Bool
_XkbCopyClientMap(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;
    int i;
    XkbKeyTypePtr stype = NULL, dtype = NULL;

    /* client map */
    if (src->map) {
        if (!dst->map) {
            tmp = calloc(1, sizeof(XkbClientMapRec));
            if (!tmp)
                return FALSE;
            dst->map = tmp;
        }

        if (src->map->syms) {
            if (src->map->size_syms != dst->map->size_syms) {
                tmp = realloc(dst->map->syms,
                              src->map->size_syms * sizeof(KeySym));
                if (!tmp)
                    return FALSE;
                dst->map->syms = tmp;

            }
            memcpy(dst->map->syms, src->map->syms,
                   src->map->size_syms * sizeof(KeySym));
        }
        else {
            free(dst->map->syms);
            dst->map->syms = NULL;
        }
        dst->map->num_syms = src->map->num_syms;
        dst->map->size_syms = src->map->size_syms;

        if (src->map->key_sym_map) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->map->key_sym_map,
                              (src->max_key_code + 1) * sizeof(XkbSymMapRec));
                if (!tmp)
                    return FALSE;
                dst->map->key_sym_map = tmp;
            }
            memcpy(dst->map->key_sym_map, src->map->key_sym_map,
                   (src->max_key_code + 1) * sizeof(XkbSymMapRec));
        }
        else {
            free(dst->map->key_sym_map);
            dst->map->key_sym_map = NULL;
        }

        if (src->map->types && src->map->num_types) {
            if (src->map->num_types > dst->map->size_types ||
                !dst->map->types || !dst->map->size_types) {
                if (dst->map->types && dst->map->size_types) {
                    tmp = realloc(dst->map->types,
                                   src->map->num_types * sizeof(XkbKeyTypeRec));
                    if (!tmp)
                        return FALSE;
                    dst->map->types = tmp;
                    memset(dst->map->types + dst->map->num_types, 0,
                          (src->map->num_types - dst->map->num_types) *
                            sizeof(XkbKeyTypeRec));
                }
                else {
                    tmp = calloc(src->map->num_types, sizeof(XkbKeyTypeRec));
                    if (!tmp)
                        return FALSE;
                    dst->map->types = tmp;
                }
            }
            else if (src->map->num_types < dst->map->num_types &&
                     dst->map->types) {
                for (i = src->map->num_types, dtype = (dst->map->types + i);
                     i < dst->map->num_types; i++, dtype++) {
                    free(dtype->level_names);
                    dtype->level_names = NULL;
                    dtype->num_levels = 0;
                    if (dtype->map_count) {
                        free(dtype->map);
                        free(dtype->preserve);
                    }
                }
            }

            stype = src->map->types;
            dtype = dst->map->types;
            for (i = 0; i < src->map->num_types; i++, dtype++, stype++) {
                if (stype->num_levels && stype->level_names) {
                    if (stype->num_levels != dtype->num_levels &&
                        dtype->num_levels && dtype->level_names &&
                        i < dst->map->num_types) {
                        tmp = realloc(dtype->level_names,
                                       stype->num_levels * sizeof(Atom));
                        if (!tmp)
                            continue;
                        dtype->level_names = tmp;
                    }
                    else if (!dtype->num_levels || !dtype->level_names ||
                             i >= dst->map->num_types) {
                        tmp = malloc(stype->num_levels * sizeof(Atom));
                        if (!tmp)
                            continue;
                        dtype->level_names = tmp;
                    }
                    dtype->num_levels = stype->num_levels;
                    memcpy(dtype->level_names, stype->level_names,
                           stype->num_levels * sizeof(Atom));
                }
                else {
                    if (dtype->num_levels && dtype->level_names &&
                        i < dst->map->num_types)
                        free(dtype->level_names);
                    dtype->num_levels = 0;
                    dtype->level_names = NULL;
                }

                dtype->name = stype->name;
                memcpy(&dtype->mods, &stype->mods, sizeof(XkbModsRec));

                if (stype->map_count) {
                    if (stype->map) {
                        if (stype->map_count != dtype->map_count &&
                            dtype->map_count && dtype->map &&
                            i < dst->map->num_types) {
                            tmp = realloc(dtype->map,
                                           stype->map_count *
                                             sizeof(XkbKTMapEntryRec));
                            if (!tmp)
                                return FALSE;
                            dtype->map = tmp;
                        }
                        else if (!dtype->map_count || !dtype->map ||
                                 i >= dst->map->num_types) {
                            tmp = malloc(stype->map_count *
                                           sizeof(XkbKTMapEntryRec));
                            if (!tmp)
                                return FALSE;
                            dtype->map = tmp;
                        }

                        memcpy(dtype->map, stype->map,
                               stype->map_count * sizeof(XkbKTMapEntryRec));
                    }
                    else {
                        if (dtype->map && i < dst->map->num_types)
                            free(dtype->map);
                        dtype->map = NULL;
                    }

                    if (stype->preserve) {
                        if (stype->map_count != dtype->map_count &&
                            dtype->map_count && dtype->preserve &&
                            i < dst->map->num_types) {
                            tmp = realloc(dtype->preserve,
                                           stype->map_count *
                                             sizeof(XkbModsRec));
                            if (!tmp)
                                return FALSE;
                            dtype->preserve = tmp;
                        }
                        else if (!dtype->preserve || !dtype->map_count ||
                                 i >= dst->map->num_types) {
                            tmp = malloc(stype->map_count *
                                         sizeof(XkbModsRec));
                            if (!tmp)
                                return FALSE;
                            dtype->preserve = tmp;
                        }

                        memcpy(dtype->preserve, stype->preserve,
                               stype->map_count * sizeof(XkbModsRec));
                    }
                    else {
                        if (dtype->preserve && i < dst->map->num_types)
                            free(dtype->preserve);
                        dtype->preserve = NULL;
                    }

                    dtype->map_count = stype->map_count;
                }
                else {
                    if (dtype->map_count && i < dst->map->num_types) {
                        free(dtype->map);
                        free(dtype->preserve);
                    }
                    dtype->map_count = 0;
                    dtype->map = NULL;
                    dtype->preserve = NULL;
                }
            }

            dst->map->size_types = src->map->num_types;
            dst->map->num_types = src->map->num_types;
        }
        else {
            if (dst->map->types) {
                for (i = 0, dtype = dst->map->types; i < dst->map->num_types;
                     i++, dtype++) {
                    free(dtype->level_names);
                    if (dtype->map && dtype->map_count)
                        free(dtype->map);
                    if (dtype->preserve && dtype->map_count)
                        free(dtype->preserve);
                }
            }
            free(dst->map->types);
            dst->map->types = NULL;
            dst->map->num_types = 0;
            dst->map->size_types = 0;
        }

        if (src->map->modmap) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->map->modmap, src->max_key_code + 1);
                if (!tmp)
                    return FALSE;
                dst->map->modmap = tmp;
            }
            memcpy(dst->map->modmap, src->map->modmap, src->max_key_code + 1);
        }
        else {
            free(dst->map->modmap);
            dst->map->modmap = NULL;
        }
    }
    else {
        if (dst->map)
            XkbFreeClientMap(dst, XkbAllClientInfoMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyServerMap(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* server map */
    if (src->server) {
        if (!dst->server) {
            tmp = calloc(1, sizeof(XkbServerMapRec));
            if (!tmp)
                return FALSE;
            dst->server = tmp;
        }

        if (src->server->explicit) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->explicit, src->max_key_code + 1);
                if (!tmp)
                    return FALSE;
                dst->server->explicit = tmp;
            }
            memcpy(dst->server->explicit, src->server->explicit,
                   src->max_key_code + 1);
        }
        else {
            free(dst->server->explicit);
            dst->server->explicit = NULL;
        }

        if (src->server->acts) {
            if (src->server->size_acts != dst->server->size_acts) {
                tmp = realloc(dst->server->acts,
                              src->server->size_acts * sizeof(XkbAction));
                if (!tmp)
                    return FALSE;
                dst->server->acts = tmp;
            }
            memcpy(dst->server->acts, src->server->acts,
                   src->server->size_acts * sizeof(XkbAction));
        }
        else {
            free(dst->server->acts);
            dst->server->acts = NULL;
        }
       dst->server->size_acts = src->server->size_acts;
       dst->server->num_acts = src->server->num_acts;

        if (src->server->key_acts) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->key_acts,
                              (src->max_key_code + 1) * sizeof(unsigned short));
                if (!tmp)
                    return FALSE;
                dst->server->key_acts = tmp;
            }
            memcpy(dst->server->key_acts, src->server->key_acts,
                   (src->max_key_code + 1) * sizeof(unsigned short));
        }
        else {
            free(dst->server->key_acts);
            dst->server->key_acts = NULL;
        }

        if (src->server->behaviors) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->behaviors,
                              (src->max_key_code + 1) * sizeof(XkbBehavior));
                if (!tmp)
                    return FALSE;
                dst->server->behaviors = tmp;
            }
            memcpy(dst->server->behaviors, src->server->behaviors,
                   (src->max_key_code + 1) * sizeof(XkbBehavior));
        }
        else {
            free(dst->server->behaviors);
            dst->server->behaviors = NULL;
        }

        memcpy(dst->server->vmods, src->server->vmods, XkbNumVirtualMods);

        if (src->server->vmodmap) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->vmodmap,
                              (src->max_key_code + 1) * sizeof(unsigned short));
                if (!tmp)
                    return FALSE;
                dst->server->vmodmap = tmp;
            }
            memcpy(dst->server->vmodmap, src->server->vmodmap,
                   (src->max_key_code + 1) * sizeof(unsigned short));
        }
        else {
            free(dst->server->vmodmap);
            dst->server->vmodmap = NULL;
        }
    }
    else {
        if (dst->server)
            XkbFreeServerMap(dst, XkbAllServerInfoMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyNames(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* names */
    if (src->names) {
        if (!dst->names) {
            dst->names = calloc(1, sizeof(XkbNamesRec));
            if (!dst->names)
                return FALSE;
        }

        if (src->names->keys) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->names->keys,
                              (src->max_key_code + 1) * sizeof(XkbKeyNameRec));
                if (!tmp)
                    return FALSE;
                dst->names->keys = tmp;
            }
            memcpy(dst->names->keys, src->names->keys,
                   (src->max_key_code + 1) * sizeof(XkbKeyNameRec));
        }
        else {
            free(dst->names->keys);
            dst->names->keys = NULL;
        }

        if (src->names->num_key_aliases) {
            if (src->names->num_key_aliases != dst->names->num_key_aliases) {
                tmp = realloc(dst->names->key_aliases,
                              src->names->num_key_aliases *
                              sizeof(XkbKeyAliasRec));
                if (!tmp)
                    return FALSE;
                dst->names->key_aliases = tmp;
            }
            memcpy(dst->names->key_aliases, src->names->key_aliases,
                   src->names->num_key_aliases * sizeof(XkbKeyAliasRec));
        }
        else {
            free(dst->names->key_aliases);
            dst->names->key_aliases = NULL;
        }
        dst->names->num_key_aliases = src->names->num_key_aliases;

        if (src->names->num_rg) {
            if (src->names->num_rg != dst->names->num_rg) {
                tmp = realloc(dst->names->radio_groups,
                              src->names->num_rg * sizeof(Atom));
                if (!tmp)
                    return FALSE;
                dst->names->radio_groups = tmp;
            }
            memcpy(dst->names->radio_groups, src->names->radio_groups,
                   src->names->num_rg * sizeof(Atom));
        }
        else {
            free(dst->names->radio_groups);
        }
        dst->names->num_rg = src->names->num_rg;

        dst->names->keycodes = src->names->keycodes;
        dst->names->geometry = src->names->geometry;
        dst->names->symbols = src->names->symbols;
        dst->names->types = src->names->types;
        dst->names->compat = src->names->compat;
        dst->names->phys_symbols = src->names->phys_symbols;

        memcpy(dst->names->vmods, src->names->vmods,
               XkbNumVirtualMods * sizeof(Atom));
        memcpy(dst->names->indicators, src->names->indicators,
               XkbNumIndicators * sizeof(Atom));
        memcpy(dst->names->groups, src->names->groups,
               XkbNumKbdGroups * sizeof(Atom));
    }
    else {
        if (dst->names)
            XkbFreeNames(dst, XkbAllNamesMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyCompat(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* compat */
    if (src->compat) {
        if (!dst->compat) {
            dst->compat = calloc(1, sizeof(XkbCompatMapRec));
            if (!dst->compat)
                return FALSE;
        }

        if (src->compat->sym_interpret && src->compat->num_si) {
            if (src->compat->num_si != dst->compat->size_si) {
                tmp = realloc(dst->compat->sym_interpret,
                              src->compat->num_si * sizeof(XkbSymInterpretRec));
                if (!tmp)
                    return FALSE;
                dst->compat->sym_interpret = tmp;
            }
            memcpy(dst->compat->sym_interpret, src->compat->sym_interpret,
                   src->compat->num_si * sizeof(XkbSymInterpretRec));

            dst->compat->num_si = src->compat->num_si;
            dst->compat->size_si = src->compat->num_si;
        }
        else {
            if (dst->compat->sym_interpret && dst->compat->size_si)
                free(dst->compat->sym_interpret);

            dst->compat->sym_interpret = NULL;
            dst->compat->num_si = 0;
            dst->compat->size_si = 0;
        }

        memcpy(dst->compat->groups, src->compat->groups,
               XkbNumKbdGroups * sizeof(XkbModsRec));
    }
    else {
        if (dst->compat)
            XkbFreeCompatMap(dst, XkbAllCompatMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyGeom(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;
    int i = 0, j = 0, k = 0;
    XkbColorPtr scolor = NULL, dcolor = NULL;
    XkbDoodadPtr sdoodad = NULL, ddoodad = NULL;
    XkbOutlinePtr soutline = NULL, doutline = NULL;
    XkbPropertyPtr sprop = NULL, dprop = NULL;
    XkbRowPtr srow = NULL, drow = NULL;
    XkbSectionPtr ssection = NULL, dsection = NULL;
    XkbShapePtr sshape = NULL, dshape = NULL;

    /* geometry */
    if (src->geom) {
        if (!dst->geom) {
            dst->geom = calloc(sizeof(XkbGeometryRec), 1);
            if (!dst->geom)
                return FALSE;
        }

        /* properties */
        if (src->geom->num_properties) {
            /* If we've got more properties in the destination than
             * the source, run through and free all the excess ones
             * first. */
            if (src->geom->num_properties < dst->geom->sz_properties) {
                for (i = src->geom->num_properties, dprop = dst->geom->properties + i;
                     i < dst->geom->num_properties;
                     i++, dprop++) {
                    free(dprop->name);
                    free(dprop->value);
                }
            }

            /* Reallocate and clear all new items if the buffer grows. */
            if (!XkbGeomRealloc((void **)&dst->geom->properties, dst->geom->sz_properties, src->geom->num_properties,
                                sizeof(XkbPropertyRec), XKB_GEOM_CLEAR_EXCESS))
                return FALSE;
            /* We don't set num_properties as we need it to try and avoid
             * too much reallocing. */
            dst->geom->sz_properties = src->geom->num_properties;

            for (i = 0,
                  sprop = src->geom->properties,
                  dprop = dst->geom->properties;
                 i < src->geom->num_properties;
                 i++, sprop++, dprop++) {
                if (i < dst->geom->num_properties) {
                    if (strlen(sprop->name) != strlen(dprop->name)) {
                        tmp = realloc(dprop->name, strlen(sprop->name) + 1);
                        if (!tmp)
                            return FALSE;
                        dprop->name = tmp;
                    }
                    if (strlen(sprop->value) != strlen(dprop->value)) {
                        tmp = realloc(dprop->value, strlen(sprop->value) + 1);
                        if (!tmp)
                            return FALSE;
                        dprop->value = tmp;
                    }
                    strcpy(dprop->name, sprop->name);
                    strcpy(dprop->value, sprop->value);
                }
                else {
                    dprop->name = xstrdup(sprop->name);
                    dprop->value = xstrdup(sprop->value);
                }
            }

            /* ... which is already src->geom->num_properties. */
            dst->geom->num_properties = dst->geom->sz_properties;
        }
        else {
            if (dst->geom->sz_properties) {
                for (i = 0, dprop = dst->geom->properties;
                     i < dst->geom->num_properties;
                     i++, dprop++) {
                    free(dprop->name);
                    free(dprop->value);
                }
                free(dst->geom->properties);
                dst->geom->properties = NULL;
            }

            dst->geom->num_properties = 0;
            dst->geom->sz_properties = 0;
        }

        /* colors */
        if (src->geom->num_colors) {
            if (src->geom->num_colors < dst->geom->sz_colors) {
                for (i = src->geom->num_colors, dcolor = dst->geom->colors + i;
                     i < dst->geom->num_colors;
                     i++, dcolor++) {
                    free(dcolor->spec);
                }
            }

            /* Reallocate and clear all new items if the buffer grows. */
            if (!XkbGeomRealloc((void **)&dst->geom->colors, dst->geom->sz_colors, src->geom->num_colors,
                                sizeof(XkbColorRec), XKB_GEOM_CLEAR_EXCESS))
                return FALSE;
            dst->geom->sz_colors = src->geom->num_colors;

            for (i = 0,
                  scolor = src->geom->colors,
                  dcolor = dst->geom->colors;
                 i < src->geom->num_colors;
                 i++, scolor++, dcolor++) {
                if (i < dst->geom->num_colors) {
                    if (strlen(scolor->spec) != strlen(dcolor->spec)) {
                        tmp = realloc(dcolor->spec, strlen(scolor->spec) + 1);
                        if (!tmp)
                            return FALSE;
                        dcolor->spec = tmp;
                    }
                    strcpy(dcolor->spec, scolor->spec);
                }
                else {
                    dcolor->spec = xstrdup(scolor->spec);
                }
                dcolor->pixel = scolor->pixel;
            }

            dst->geom->num_colors = dst->geom->sz_colors;
        }
        else {
            if (dst->geom->sz_colors) {
                for (i = 0, dcolor = dst->geom->colors;
                     i < dst->geom->num_colors;
                     i++, dcolor++) {
                    free(dcolor->spec);
                }
                free(dst->geom->colors);
                dst->geom->colors = NULL;
            }

            dst->geom->num_colors = 0;
            dst->geom->sz_colors = 0;
        }

        /* shapes */
        /* shapes break down into outlines, which break down into points. */
        if (dst->geom->num_shapes) {
            for (i = 0, dshape = dst->geom->shapes;
                 i < dst->geom->num_shapes;
                 i++, dshape++) {
                for (j = 0, doutline = dshape->outlines;
                     j < dshape->num_outlines;
                     j++, doutline++) {
                    if (doutline->sz_points)
                        free(doutline->points);
                }

                if (dshape->sz_outlines) {
                    free(dshape->outlines);
                    dshape->outlines = NULL;
                }

                dshape->num_outlines = 0;
                dshape->sz_outlines = 0;
            }
        }

        if (src->geom->num_shapes) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc((void **)&dst->geom->shapes, dst->geom->sz_shapes, src->geom->num_shapes,
                                sizeof(XkbShapeRec), XKB_GEOM_CLEAR_ALL))
                return FALSE;

            for (i = 0, sshape = src->geom->shapes, dshape = dst->geom->shapes;
                 i < src->geom->num_shapes;
                 i++, sshape++, dshape++) {
                if (sshape->num_outlines) {
                    tmp = calloc(sshape->num_outlines, sizeof(XkbOutlineRec));
                    if (!tmp)
                        return FALSE;
                    dshape->outlines = tmp;
                    
                    for (j = 0,
                          soutline = sshape->outlines,
                          doutline = dshape->outlines;
                         j < sshape->num_outlines;
                         j++, soutline++, doutline++) {
                        if (soutline->num_points) {
                            tmp = malloc(soutline->num_points *
                                          sizeof(XkbPointRec));
                            if (!tmp)
                                return FALSE;
                            doutline->points = tmp;

                            memcpy(doutline->points, soutline->points,
                                   soutline->num_points * sizeof(XkbPointRec));

                            doutline->corner_radius = soutline->corner_radius;
                        }

                        doutline->num_points = soutline->num_points;
                        doutline->sz_points = soutline->num_points;
                    }
                }

                dshape->num_outlines = sshape->num_outlines;
                dshape->sz_outlines = sshape->num_outlines;
                dshape->name = sshape->name;
                dshape->bounds = sshape->bounds;

                dshape->approx = NULL;
                if (sshape->approx && sshape->num_outlines > 0) {

                    const ptrdiff_t approx_idx =
                            sshape->approx - sshape->outlines;

                    if (approx_idx < dshape->num_outlines) {
                            dshape->approx = dshape->outlines + approx_idx;
                    } else {
                            LogMessage(X_WARNING, "XKB: approx outline "
                                            "index is out of range\n");
                    }
                }

                dshape->primary = NULL;
                if (sshape->primary && sshape->num_outlines > 0) {

                    const ptrdiff_t primary_idx =
                            sshape->primary - sshape->outlines;

                    if (primary_idx < dshape->num_outlines) {
                            dshape->primary = dshape->outlines + primary_idx;
                    } else {
                            LogMessage(X_WARNING, "XKB: primary outline "
                                            "index is out of range\n");
                    }
                }
            }

            dst->geom->num_shapes = src->geom->num_shapes;
            dst->geom->sz_shapes = src->geom->num_shapes;
        }
        else {
            if (dst->geom->sz_shapes) {
                free(dst->geom->shapes);
            }
            dst->geom->shapes = NULL;
            dst->geom->num_shapes = 0;
            dst->geom->sz_shapes = 0;
        }

        /* sections */
        /* sections break down into doodads, and also into rows, which break
         * down into keys. */
        if (dst->geom->num_sections) {
            for (i = 0, dsection = dst->geom->sections;
                 i < dst->geom->num_sections;
                 i++, dsection++) {
                for (j = 0, drow = dsection->rows;
                     j < dsection->num_rows;
                     j++, drow++) {
                    if (drow->num_keys)
                        free(drow->keys);
                }

                if (dsection->num_rows)
                    free(dsection->rows);

                /* cut and waste from geom/doodad below. */
                for (j = 0, ddoodad = dsection->doodads;
                     j < dsection->num_doodads;
                     j++, ddoodad++) {
                    if (ddoodad->any.type == XkbTextDoodad) {
                        free(ddoodad->text.text);
                        ddoodad->text.text = NULL;
                        free(ddoodad->text.font);
                        ddoodad->text.font = NULL;
                     }
                     else if (ddoodad->any.type == XkbLogoDoodad) {
                         free(ddoodad->logo.logo_name);
                         ddoodad->logo.logo_name = NULL;
                    }
                }

                free(dsection->doodads);
            }

            dst->geom->num_sections = 0;
        }

        if (src->geom->num_sections) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc((void **)&dst->geom->sections, dst->geom->sz_sections, src->geom->num_sections,
                                sizeof(XkbSectionRec), XKB_GEOM_CLEAR_ALL))
                return FALSE;
            dst->geom->num_sections = src->geom->num_sections;
            dst->geom->sz_sections = src->geom->num_sections;

            for (i = 0,
                  ssection = src->geom->sections,
                  dsection = dst->geom->sections;
                 i < src->geom->num_sections;
                 i++, ssection++, dsection++) {
                *dsection = *ssection;
                if (ssection->num_rows) {
                    tmp = calloc(ssection->num_rows, sizeof(XkbRowRec));
                    if (!tmp)
                        return FALSE;
                    dsection->rows = tmp;
                }
                dsection->num_rows = ssection->num_rows;
                dsection->sz_rows = ssection->num_rows;

                for (j = 0, srow = ssection->rows, drow = dsection->rows;
                     j < ssection->num_rows;
                     j++, srow++, drow++) {
                    if (srow->num_keys) {
                        tmp = malloc(srow->num_keys * sizeof(XkbKeyRec));
                        if (!tmp)
                            return FALSE;
                        drow->keys = tmp;
                        memcpy(drow->keys, srow->keys,
                               srow->num_keys * sizeof(XkbKeyRec));
                    }
                    drow->num_keys = srow->num_keys;
                    drow->sz_keys = srow->num_keys;
                    drow->top = srow->top;
                    drow->left = srow->left;
                    drow->vertical = srow->vertical;
                    drow->bounds = srow->bounds;
                }

                if (ssection->num_doodads) {
                    tmp = calloc(ssection->num_doodads, sizeof(XkbDoodadRec));
                    if (!tmp)
                        return FALSE;
                    dsection->doodads = tmp;
                }
                else {
                    dsection->doodads = NULL;
                }

                dsection->sz_doodads = ssection->num_doodads;
                for (k = 0,
                      sdoodad = ssection->doodads,
                      ddoodad = dsection->doodads;
                     k < ssection->num_doodads;
                     k++, sdoodad++, ddoodad++) {
                    memcpy(ddoodad , sdoodad, sizeof(XkbDoodadRec));
                    if (sdoodad->any.type == XkbTextDoodad) {
                        if (sdoodad->text.text)
                            ddoodad->text.text =
                             strdup(sdoodad->text.text);
                        if (sdoodad->text.font)
                            ddoodad->text.font =
                             strdup(sdoodad->text.font);
                    }
                    else if (sdoodad->any.type == XkbLogoDoodad) {
                        if (sdoodad->logo.logo_name)
                            ddoodad->logo.logo_name =
                             strdup(sdoodad->logo.logo_name);
                    }
                }
                dsection->overlays = NULL;
                dsection->sz_overlays = 0;
                dsection->num_overlays = 0;
            }
        }
        else {
            if (dst->geom->sz_sections) {
                free(dst->geom->sections);
            }

            dst->geom->sections = NULL;
            dst->geom->num_sections = 0;
            dst->geom->sz_sections = 0;
        }

        /* doodads */
        if (dst->geom->num_doodads) {
            for (i = src->geom->num_doodads,
                  ddoodad = dst->geom->doodads +
                             src->geom->num_doodads;
                 i < dst->geom->num_doodads;
                 i++, ddoodad++) {
                 if (ddoodad->any.type == XkbTextDoodad) {
                     free(ddoodad->text.text);
                     ddoodad->text.text = NULL;
                     free(ddoodad->text.font);
                     ddoodad->text.font = NULL;
                 }
                 else if (ddoodad->any.type == XkbLogoDoodad) {
                     free(ddoodad->logo.logo_name);
                     ddoodad->logo.logo_name = NULL;
                }
            }
            dst->geom->num_doodads = 0;
        }

        if (src->geom->num_doodads) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc((void **)&dst->geom->doodads, dst->geom->sz_doodads, src->geom->num_doodads,
                                sizeof(XkbDoodadRec), XKB_GEOM_CLEAR_ALL))
                return FALSE;

            dst->geom->sz_doodads = src->geom->num_doodads;

            for (i = 0,
                  sdoodad = src->geom->doodads,
                  ddoodad = dst->geom->doodads;
                 i < src->geom->num_doodads;
                 i++, sdoodad++, ddoodad++) {
                memcpy(ddoodad , sdoodad, sizeof(XkbDoodadRec));
                if (sdoodad->any.type == XkbTextDoodad) {
                    if (sdoodad->text.text)
                        ddoodad->text.text = strdup(sdoodad->text.text);
                    if (sdoodad->text.font)
                        ddoodad->text.font = strdup(sdoodad->text.font);
                }
                else if (sdoodad->any.type == XkbLogoDoodad) {
                    if (sdoodad->logo.logo_name)
                        ddoodad->logo.logo_name =
                          strdup(sdoodad->logo.logo_name);
                }
            }

            dst->geom->num_doodads = dst->geom->sz_doodads;
        }
        else {
            if (dst->geom->sz_doodads) {
                free(dst->geom->doodads);
            }

            dst->geom->doodads = NULL;
            dst->geom->num_doodads = 0;
            dst->geom->sz_doodads = 0;
        }

        /* key aliases */
        if (src->geom->num_key_aliases) {
            /* Reallocate but don't clear any items. There is no need
             * to clear anything because data is immediately copied
             * over the whole memory area with memcpy. */
            if (!XkbGeomRealloc((void **)&dst->geom->key_aliases, dst->geom->sz_key_aliases, src->geom->num_key_aliases,
                                2 * XkbKeyNameLength, XKB_GEOM_CLEAR_NONE))
                return FALSE;

            dst->geom->sz_key_aliases = src->geom->num_key_aliases;

            memcpy(dst->geom->key_aliases, src->geom->key_aliases,
                   src->geom->num_key_aliases * 2 * XkbKeyNameLength);

            dst->geom->num_key_aliases = dst->geom->sz_key_aliases;
        }
        else {
            free(dst->geom->key_aliases);
            dst->geom->key_aliases = NULL;
            dst->geom->num_key_aliases = 0;
            dst->geom->sz_key_aliases = 0;
        }
        
        /* font */
        if (src->geom->label_font) {
            if (!dst->geom->label_font) {
                tmp = malloc(strlen(src->geom->label_font) + 1);
                if (!tmp)
                    return FALSE;
                dst->geom->label_font = tmp;
            }
            else if (strlen(src->geom->label_font) !=
                strlen(dst->geom->label_font)) {
                tmp = realloc(dst->geom->label_font,
                               strlen(src->geom->label_font) + 1);
                if (!tmp)
                    return FALSE;
                dst->geom->label_font = tmp;
            }

            strcpy(dst->geom->label_font, src->geom->label_font);
            i = XkbGeomColorIndex(src->geom, src->geom->label_color);
            dst->geom->label_color = &(dst->geom->colors[i]);
            i = XkbGeomColorIndex(src->geom, src->geom->base_color);
            dst->geom->base_color = &(dst->geom->colors[i]);
        }
        else {
            free(dst->geom->label_font);
            dst->geom->label_font = NULL;
            dst->geom->label_color = NULL;
            dst->geom->base_color = NULL;
        }

        dst->geom->name = src->geom->name;
        dst->geom->width_mm = src->geom->width_mm;
        dst->geom->height_mm = src->geom->height_mm;
    }
    else
    {
        if (dst->geom) {
            /* I LOVE THE DIFFERENT CALL SIGNATURE.  REALLY, I DO. */
            XkbFreeGeometry(dst->geom, XkbGeomAllMask, TRUE);
            dst->geom = NULL;
        }
    }

    return TRUE;
}

static Bool
_XkbCopyIndicators(XkbDescPtr src, XkbDescPtr dst)
{
    /* indicators */
    if (src->indicators) {
        if (!dst->indicators) {
            dst->indicators = malloc(sizeof(XkbIndicatorRec));
            if (!dst->indicators)
                return FALSE;
        }
        memcpy(dst->indicators, src->indicators, sizeof(XkbIndicatorRec));
    }
    else {
        free(dst->indicators);
        dst->indicators = NULL;
    }
    return TRUE;
}

static Bool
_XkbCopyControls(XkbDescPtr src, XkbDescPtr dst)
{
    /* controls */
    if (src->ctrls) {
        if (!dst->ctrls) {
            dst->ctrls = malloc(sizeof(XkbControlsRec));
            if (!dst->ctrls)
                return FALSE;
        }
        memcpy(dst->ctrls, src->ctrls, sizeof(XkbControlsRec));
    }
    else {
        free(dst->ctrls);
        dst->ctrls = NULL;
    }
    return TRUE;
}

/**
 * Copy an XKB map from src to dst, reallocating when necessary: if some
 * map components are present in one, but not in the other, the destination
 * components will be allocated or freed as necessary.
 *
 * Basic map consistency is assumed on both sides, so maps with random
 * uninitialised data (e.g. names->radio_grous == NULL, names->num_rg == 19)
 * _will_ cause failures.  You've been warned.
 *
 * Returns TRUE on success, or FALSE on failure.  If this function fails,
 * dst may be in an inconsistent state: all its pointers are guaranteed
 * to remain valid, but part of the map may be from src and part from dst.
 *
 */

Bool
XkbCopyKeymap(XkbDescPtr dst, XkbDescPtr src)
{

    if (!src || !dst) {
        DebugF("XkbCopyKeymap: src (%p) or dst (%p) is NULL\n", src, dst);
        return FALSE;
    }

    if (src == dst)
        return TRUE;

    if (!_XkbCopyClientMap(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy client map\n");
        return FALSE;
    }
    if (!_XkbCopyServerMap(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy server map\n");
        return FALSE;
    }
    if (!_XkbCopyIndicators(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy indicators\n");
        return FALSE;
    }
    if (!_XkbCopyControls(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy controls\n");
        return FALSE;
    }
    if (!_XkbCopyNames(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy names\n");
        return FALSE;
    }
    if (!_XkbCopyCompat(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy compat map\n");
        return FALSE;
    }
    if (!_XkbCopyGeom(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy geometry\n");
        return FALSE;
    }

    dst->min_key_code = src->min_key_code;
    dst->max_key_code = src->max_key_code;

    return TRUE;
}

Bool
XkbCopyDeviceKeymap(DeviceIntPtr dst, DeviceIntPtr src)
{
    xkbNewKeyboardNotify nkn;
    Bool ret;

    if (!dst->key || !src->key)
        return FALSE;

    memset(&nkn, 0, sizeof(xkbNewKeyboardNotify));
    nkn.oldMinKeyCode = dst->key->xkbInfo->desc->min_key_code;
    nkn.oldMaxKeyCode = dst->key->xkbInfo->desc->max_key_code;
    nkn.deviceID = dst->id;
    nkn.oldDeviceID = dst->id; /* maybe src->id? */
    nkn.minKeyCode = src->key->xkbInfo->desc->min_key_code;
    nkn.maxKeyCode = src->key->xkbInfo->desc->max_key_code;
    nkn.requestMajor = XkbReqCode;
    nkn.requestMinor = X_kbSetMap; /* Near enough's good enough. */
    nkn.changed = XkbNKN_KeycodesMask;
    if (src->key->xkbInfo->desc->geom)
        nkn.changed |= XkbNKN_GeometryMask;

    ret = XkbCopyKeymap(dst->key->xkbInfo->desc, src->key->xkbInfo->desc);
    if (ret)
        XkbSendNewKeyboardNotify(dst, &nkn);

    return ret;
}

int
XkbGetEffectiveGroup(XkbSrvInfoPtr xkbi, XkbStatePtr xkbState, CARD8 keycode)
{
    XkbDescPtr xkb = xkbi->desc;
    int effectiveGroup = xkbState->group;

    if (!XkbKeycodeInRange(xkb, keycode))
        return -1;

    if (effectiveGroup == XkbGroup1Index)
        return effectiveGroup;

    if (XkbKeyNumGroups(xkb,keycode) > 1U) {
        if (effectiveGroup >= XkbKeyNumGroups(xkb,keycode)) {
            unsigned int gi = XkbKeyGroupInfo(xkb,keycode);
            switch (XkbOutOfRangeGroupAction(gi)) {
                default:
                case XkbWrapIntoRange:
                    effectiveGroup %= XkbKeyNumGroups(xkb, keycode);
                    break;
                case XkbClampIntoRange:
                    effectiveGroup = XkbKeyNumGroups(xkb, keycode) - 1;
                    break;
                case XkbRedirectIntoRange:
                    effectiveGroup = XkbOutOfRangeGroupInfo(gi);
                    if (effectiveGroup >= XkbKeyNumGroups(xkb, keycode))
                        effectiveGroup = 0;
                    break;
            }
        }
    }
    else effectiveGroup = XkbGroup1Index;

    return effectiveGroup;
}

/* Merge the lockedPtrButtons from all attached SDs for the given master
 * device into the MD's state.
 */
void
XkbMergeLockedPtrBtns(DeviceIntPtr master)
{
    DeviceIntPtr d = inputInfo.devices;
    XkbSrvInfoPtr xkbi = NULL;

    if (!IsMaster(master))
        return;

    if (!master->key)
        return;

    xkbi = master->key->xkbInfo;
    xkbi->lockedPtrButtons = 0;

    for (; d; d = d->next) {
        if (IsMaster(d) || GetMaster(d, MASTER_KEYBOARD) != master || !d->key)
            continue;

        xkbi->lockedPtrButtons |= d->key->xkbInfo->lockedPtrButtons;
    }
}
/************************************************************
 Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability 
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>

#include <X11/Xos.h>
#include <X11/Xfuncs.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XKMformat.h>
#include "misc.h"
#include "inputstr.h"
#include "xkbstr.h"
#include "xkbsrv.h"
#include "xkbgeom.h"

Atom
XkbInternAtom(char *str,Bool only_if_exists)
{
    if (str==NULL)
	return None;
    return MakeAtom(str,strlen(str),!only_if_exists);
}

/***====================================================================***/

static void *
XkmInsureSize(void *oldPtr,int oldCount,int *newCountRtrn,int elemSize)
{
int	newCount= *newCountRtrn;

    if (oldPtr==NULL) {
	if (newCount==0)
	    return NULL;
	oldPtr= calloc(newCount,elemSize);
    }
    else if (oldCount<newCount) {
	oldPtr= realloc(oldPtr,newCount*elemSize);
	if (oldPtr!=NULL) {
	    char *tmp= (char *)oldPtr;
	    memset(&tmp[oldCount*elemSize], 0, (newCount-oldCount)*elemSize);
	}
    }
    else if (newCount<oldCount) {
	*newCountRtrn= oldCount;
    }
    return oldPtr;
}

#define	XkmInsureTypedSize(p,o,n,t) ((p)=((t *)XkmInsureSize((char *)(p),(o),(n),sizeof(t))))

static CARD8
XkmGetCARD8(FILE *file,int *pNRead)
{
int	tmp;
    tmp= getc(file);
    if (pNRead&&(tmp!=EOF))
	(*pNRead)+= 1;
    return tmp;
}

static CARD16
XkmGetCARD16(FILE *file,int *pNRead)
{
CARD16		val;

    if ((fread(&val,2,1,file)==1)&&(pNRead))
	(*pNRead)+= 2;
    return val;
}

static CARD32
XkmGetCARD32(FILE *file,int *pNRead)
{
CARD32	val;

    if ((fread(&val,4,1,file)==1)&&(pNRead))
	(*pNRead)+= 4;
    return val;
}

static int
XkmSkipPadding(FILE *file,unsigned pad)
{
register int	i,nRead=0;

    for (i=0;i<pad;i++) {
	if (getc(file)!=EOF)
	    nRead++;
    }
    return nRead;
}

static int
XkmGetCountedString(FILE *file,char *str,int max_len)
{
int	count,nRead=0;

    count= XkmGetCARD16(file,&nRead);
    if (count>0) {
	int tmp;
	if (count>max_len) {
	    tmp= fread(str,1,max_len,file);
	    while (tmp<count) {
		if ((getc(file))!=EOF)
		     tmp++;
		else break;
	    }
	}
	else {
	    tmp= fread(str,1,count,file);
	}
	nRead+= tmp;
    }
    if (count>=max_len)	str[max_len-1]= '\0';
    else		str[count]= '\0';
    count= XkbPaddedSize(nRead)-nRead;
    if (count>0)
	nRead+= XkmSkipPadding(file,count);
    return nRead;
}

/***====================================================================***/

static int
ReadXkmVirtualMods(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register unsigned int i,bit;
unsigned int	bound,named,tmp;
int		nRead=0;

    if (XkbAllocServerMap(xkb,XkbVirtualModsMask,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmVirtualMods",0);
	return -1;
    }
    bound= XkmGetCARD16(file,&nRead);
    named= XkmGetCARD16(file,&nRead);
    for (i=tmp=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (bound&bit) {
	    xkb->server->vmods[i]= XkmGetCARD8(file,&nRead);
	    if (changes)
		changes->map.vmods|= bit;
	    tmp++;
	}
    }
    if ((i= XkbPaddedSize(tmp)-tmp)>0)
	nRead+= XkmSkipPadding(file,i);
    if (XkbAllocNames(xkb,XkbVirtualModNamesMask,0,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmVirtualMods",0);
	return -1;
    }
    for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	char name[100];
	if (named&bit) {
	    if (nRead+=XkmGetCountedString(file,name,100)) {
		xkb->names->vmods[i]= XkbInternAtom(name,FALSE);
		if (changes)
		    changes->names.changed_vmods|= bit;
	    }
	}
    }
    return nRead;
}

/***====================================================================***/

static int
ReadXkmKeycodes(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register int	i;
unsigned	minKC,maxKC,nAl;
int		nRead=0;
char 		name[100];
XkbKeyNamePtr	pN;

    name[0]= '\0';
    nRead+= XkmGetCountedString(file,name,100);
    minKC= XkmGetCARD8(file,&nRead);
    maxKC= XkmGetCARD8(file,&nRead);
    if (xkb->min_key_code==0) {
	xkb->min_key_code= minKC;
	xkb->max_key_code= maxKC;
    }
    else {
	if (minKC<xkb->min_key_code)
	    xkb->min_key_code= minKC;
	if (maxKC>xkb->max_key_code) {
	    _XkbLibError(_XkbErrBadValue,"ReadXkmKeycodes",maxKC);
	    return -1;
	}
    }
    nAl= XkmGetCARD8(file,&nRead);
    nRead+= XkmSkipPadding(file,1);

#define WANTED (XkbKeycodesNameMask|XkbKeyNamesMask|XkbKeyAliasesMask)
    if (XkbAllocNames(xkb,WANTED,0,nAl)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmKeycodes",0);
	return -1;
    }
    if (name[0]!='\0') {
	xkb->names->keycodes= XkbInternAtom(name,FALSE);
    }

    for (pN=&xkb->names->keys[minKC],i=minKC;i<=(int)maxKC;i++,pN++) {
	if (fread(pN,1,XkbKeyNameLength,file)!=XkbKeyNameLength) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmKeycodes",0);
	    return -1;
	}
	nRead+= XkbKeyNameLength;
    }
    if (nAl>0) {
	XkbKeyAliasPtr	pAl;
	for (pAl= xkb->names->key_aliases,i=0;i<nAl;i++,pAl++) {
	    int tmp;
	    tmp= fread(pAl,1,2*XkbKeyNameLength,file);
	    if (tmp!=2*XkbKeyNameLength) {
		_XkbLibError(_XkbErrBadLength,"ReadXkmKeycodes",0);
		return -1;
	    }
	    nRead+= 2*XkbKeyNameLength;
	}
	if (changes)
	    changes->names.changed|= XkbKeyAliasesMask;
    }
    if (changes)
	changes->names.changed|= XkbKeyNamesMask;
    return nRead;
}

/***====================================================================***/

static int
ReadXkmKeyTypes(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register unsigned	i,n;
unsigned		num_types;
int			nRead=0;
int			tmp;
XkbKeyTypePtr		type;
xkmKeyTypeDesc		wire;
XkbKTMapEntryPtr	entry;
xkmKTMapEntryDesc	wire_entry;
char 			buf[100];

    if ((tmp= XkmGetCountedString(file,buf,100))<1) {
	_XkbLibError(_XkbErrBadLength,"ReadXkmKeyTypes",0);
	return -1;
    }	
    nRead+= tmp;
    if (buf[0]!='\0') {
	if (XkbAllocNames(xkb,XkbTypesNameMask,0,0)!=Success) {
	    _XkbLibError(_XkbErrBadAlloc,"ReadXkmKeyTypes",0);
	    return -1;
        }
	xkb->names->types= XkbInternAtom(buf,FALSE);
    }
    num_types= XkmGetCARD16(file,&nRead);
    nRead+= XkmSkipPadding(file,2);
    if (num_types<1)
	return nRead;
    if (XkbAllocClientMap(xkb,XkbKeyTypesMask,num_types)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmKeyTypes",0);
	return nRead;
    }
    xkb->map->num_types= num_types;
    if (num_types<XkbNumRequiredTypes) {
	_XkbLibError(_XkbErrMissingReqTypes,"ReadXkmKeyTypes",0);
	return -1;
    }
    type= xkb->map->types;
    for (i=0;i<num_types;i++,type++) {
	if ((int)fread(&wire,SIZEOF(xkmKeyTypeDesc),1,file)<1) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmKeyTypes",0);
	    return -1;
	}
	nRead+= SIZEOF(xkmKeyTypeDesc);
	if (((i==XkbOneLevelIndex)&&(wire.numLevels!=1))||
	    (((i==XkbTwoLevelIndex)||(i==XkbAlphabeticIndex)||
	     ((i)==XkbKeypadIndex))&&(wire.numLevels!=2))) {
	    _XkbLibError(_XkbErrBadTypeWidth,"ReadXkmKeyTypes",i);
	    return -1;
	}
	tmp= wire.nMapEntries;
	XkmInsureTypedSize(type->map,type->map_count,&tmp,XkbKTMapEntryRec);
	if ((wire.nMapEntries>0)&&(type->map==NULL)) {
	    _XkbLibError(_XkbErrBadValue,"ReadXkmKeyTypes",wire.nMapEntries);
	    return -1;
	}
	for (n=0,entry= type->map;n<wire.nMapEntries;n++,entry++) {
	    if (fread(&wire_entry,SIZEOF(xkmKTMapEntryDesc),1,file)<(int)1) {
		_XkbLibError(_XkbErrBadLength,"ReadXkmKeyTypes",0);
		return -1;
	    }
	    nRead+= SIZEOF(xkmKTMapEntryDesc);
	    entry->active= (wire_entry.virtualMods==0);
	    entry->level= wire_entry.level;
	    entry->mods.mask= wire_entry.realMods;
	    entry->mods.real_mods= wire_entry.realMods;
	    entry->mods.vmods= wire_entry.virtualMods;
	}
	nRead+= XkmGetCountedString(file,buf,100);
	if (((i==XkbOneLevelIndex)&&(strcmp(buf,"ONE_LEVEL")!=0))||
	    ((i==XkbTwoLevelIndex)&&(strcmp(buf,"TWO_LEVEL")!=0))||
	    ((i==XkbAlphabeticIndex)&&(strcmp(buf,"ALPHABETIC")!=0))||
	    ((i==XkbKeypadIndex)&&(strcmp(buf,"KEYPAD")!=0))) {
	   _XkbLibError(_XkbErrBadTypeName,"ReadXkmKeyTypes",0);
	   return -1;
	}
	if (buf[0]!='\0') {
	     type->name= XkbInternAtom(buf,FALSE);
	}
	else type->name= None;

	if (wire.preserve) {
	    xkmModsDesc	p_entry;
	    XkbModsPtr	pre;
	    XkmInsureTypedSize(type->preserve,type->map_count,&tmp,
						XkbModsRec);
	    if (type->preserve==NULL) {
		_XkbLibError(_XkbErrBadMatch,"ReadXkmKeycodes",0);
		return -1;
	    }
	    for (n=0,pre=type->preserve;n<wire.nMapEntries;n++,pre++) {
		if (fread(&p_entry,SIZEOF(xkmModsDesc),1,file)<1) {
		    _XkbLibError(_XkbErrBadLength,"ReadXkmKeycodes",0);
		    return -1;
		}
		nRead+= SIZEOF(xkmModsDesc);
		pre->mask= p_entry.realMods;
		pre->real_mods= p_entry.realMods;
		pre->vmods= p_entry.virtualMods;
	    }
	}
	if (wire.nLevelNames>0) {
	    int width= wire.numLevels;
	    if (wire.nLevelNames>(unsigned)width) {
		_XkbLibError(_XkbErrBadMatch,"ReadXkmKeycodes",0);
		return -1;
	    }
	    XkmInsureTypedSize(type->level_names,type->num_levels,&width,Atom);
	    if (type->level_names!=NULL) {
		for (n=0;n<wire.nLevelNames;n++) {
		    if ((tmp=XkmGetCountedString(file,buf,100))<1)
			return -1;
		    nRead+= tmp;
		    if (strlen(buf)==0)
			 type->level_names[n]= None;
		    else type->level_names[n]= XkbInternAtom(buf,0);
		}
	    }
	}
	type->mods.mask= wire.realMods;
	type->mods.real_mods= wire.realMods;
	type->mods.vmods= wire.virtualMods;
	type->num_levels= wire.numLevels;
	type->map_count= wire.nMapEntries;
    }
    if (changes) {
	changes->map.changed|= XkbKeyTypesMask;
	changes->map.first_type= 0;
	changes->map.num_types= xkb->map->num_types;
    }
    return nRead;
}

/***====================================================================***/

static int
ReadXkmCompatMap(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register int		i;
unsigned		num_si,groups;
char 			name[100];
XkbSymInterpretPtr	interp;
xkmSymInterpretDesc	wire;
unsigned		tmp;
int			nRead=0;
XkbCompatMapPtr		compat;
XkbAction               *act;

    if ((tmp= XkmGetCountedString(file,name,100))<1) {
	_XkbLibError(_XkbErrBadLength,"ReadXkmCompatMap",0);
	return -1;
    }
    nRead+= tmp;
    if (name[0]!='\0') {
	if (XkbAllocNames(xkb,XkbCompatNameMask,0,0)!=Success) {
	    _XkbLibError(_XkbErrBadAlloc,"ReadXkmCompatMap",0);
	    return -1;
	}
	xkb->names->compat= XkbInternAtom(name,FALSE);
    }
    num_si= XkmGetCARD16(file,&nRead);
    groups= XkmGetCARD8(file,&nRead);
    nRead+= XkmSkipPadding(file,1);
    if (XkbAllocCompatMap(xkb,XkbAllCompatMask,num_si)!=Success)
	return -1;
    compat= xkb->compat;
    compat->num_si= 0;
    interp= compat->sym_interpret;
    for (i=0;i<num_si;i++) {
	tmp= fread(&wire,SIZEOF(xkmSymInterpretDesc),1,file);
	nRead+= tmp*SIZEOF(xkmSymInterpretDesc);
	interp->sym= wire.sym;
	interp->mods= wire.mods;
	interp->match= wire.match;
	interp->virtual_mod= wire.virtualMod;
	interp->flags= wire.flags;
	interp->act.type= wire.actionType;
        act = (XkbAction *) &interp->act;

        switch (interp->act.type) {
        case XkbSA_SetMods:
        case XkbSA_LatchMods:
        case XkbSA_LockMods:
            act->mods.flags = wire.actionData[0];
            act->mods.mask = wire.actionData[1];
            act->mods.real_mods = wire.actionData[2];
            act->mods.vmods1 = wire.actionData[3];
            act->mods.vmods2 = wire.actionData[4];
            break;
        case XkbSA_SetGroup:
        case XkbSA_LatchGroup:
        case XkbSA_LockGroup:
            act->group.flags = wire.actionData[0];
            act->group.group_XXX = wire.actionData[1];
            break;
        case XkbSA_MovePtr:
            act->ptr.flags = wire.actionData[0];
            act->ptr.high_XXX = wire.actionData[1];
            act->ptr.low_XXX = wire.actionData[2];
            act->ptr.high_YYY = wire.actionData[3];
            act->ptr.low_YYY = wire.actionData[4];
            break;
        case XkbSA_PtrBtn:
        case XkbSA_LockPtrBtn:
            act->btn.flags = wire.actionData[0];
            act->btn.count = wire.actionData[1];
            act->btn.button = wire.actionData[2];
            break;
        case XkbSA_DeviceBtn:
        case XkbSA_LockDeviceBtn:
            act->devbtn.flags = wire.actionData[0];
            act->devbtn.count = wire.actionData[1];
            act->devbtn.button = wire.actionData[2];
            act->devbtn.device = wire.actionData[3];
            break;
        case XkbSA_SetPtrDflt:
            act->dflt.flags = wire.actionData[0];
            act->dflt.affect = wire.actionData[1];
            act->dflt.valueXXX = wire.actionData[2];
            break;
        case XkbSA_ISOLock:
            act->iso.flags = wire.actionData[0];
            act->iso.mask = wire.actionData[1];
            act->iso.real_mods = wire.actionData[2];
            act->iso.group_XXX = wire.actionData[3];
            act->iso.affect = wire.actionData[4];
            act->iso.vmods1 = wire.actionData[5];
            act->iso.vmods2 = wire.actionData[6];
            break;
        case XkbSA_SwitchScreen:
            act->screen.flags = wire.actionData[0];
            act->screen.screenXXX = wire.actionData[1];
            break;
        case XkbSA_SetControls:
        case XkbSA_LockControls:
            act->ctrls.flags = wire.actionData[0];
            act->ctrls.ctrls3 = wire.actionData[1];
            act->ctrls.ctrls2 = wire.actionData[2];
            act->ctrls.ctrls1 = wire.actionData[3];
            act->ctrls.ctrls0 = wire.actionData[4];
            break;
        case XkbSA_RedirectKey:
            act->redirect.new_key = wire.actionData[0];
            act->redirect.mods_mask = wire.actionData[1];
            act->redirect.mods = wire.actionData[2];
            act->redirect.vmods_mask0 = wire.actionData[3];
            act->redirect.vmods_mask1 = wire.actionData[4];
            act->redirect.vmods0 = wire.actionData[4];
            act->redirect.vmods1 = wire.actionData[5];
            break;
        case XkbSA_DeviceValuator:
            act->devval.device = wire.actionData[0];
            act->devval.v1_what = wire.actionData[1];
            act->devval.v1_ndx = wire.actionData[2];
            act->devval.v1_value = wire.actionData[3];
            act->devval.v2_what = wire.actionData[4];
            act->devval.v2_ndx = wire.actionData[5];
            act->devval.v2_what = wire.actionData[6];
            break;

        case XkbSA_XFree86Private:
            /*
             * Bugfix for broken xkbcomp: if we encounter an XFree86Private
             * action with Any+AnyOfOrNone(All), then we skip the interp as
             * broken.  Versions of xkbcomp below 1.2.2 had a bug where they
             * would interpret a symbol that couldn't be found in an interpret
             * as Any.  So, an XF86LogWindowTree+AnyOfOrNone(All) interp that
             * triggered the PrWins action would make every key without an
             * action trigger PrWins if libX11 didn't yet know about the
             * XF86LogWindowTree keysym.  None too useful.
             *
             * We only do this for XFree86 actions, as the current XKB
             * dataset relies on Any+AnyOfOrNone(All) -> SetMods for Ctrl in
             * particular.
             *
             * See xkbcomp commits 2a473b906943ffd807ad81960c47530ee7ae9a60 and
             * 3caab5aa37decb7b5dc1642a0452efc3e1f5100e for more details.
             */
            if (interp->sym == NoSymbol && interp->match == XkbSI_AnyOfOrNone &&
                (interp->mods & 0xff) == 0xff) {
                ErrorF("XKB: Skipping broken Any+AnyOfOrNone(All) -> Private "
                       "action from compiled keymap\n");
                continue;
            }
            /* copy the kind of action */
            memcpy(act->any.data, wire.actionData, XkbAnyActionDataSize);
            break ;

        case XkbSA_Terminate:
            /* no args, kinda (note: untrue for xfree86). */
            break;
        case XkbSA_ActionMessage:
            /* unsupported. */
            break;
        }
        interp++;
        compat->num_si++;
    }
    if ((num_si>0)&&(changes)) {
	changes->compat.first_si= 0;
	changes->compat.num_si= compat->num_si;
    }
    if (groups) {
	register unsigned bit;
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    xkmModsDesc	md;
	    if (groups&bit) {
		tmp= fread(&md,SIZEOF(xkmModsDesc),1,file);
		nRead+= tmp*SIZEOF(xkmModsDesc);
		xkb->compat->groups[i].real_mods= md.realMods;
		xkb->compat->groups[i].vmods= md.virtualMods;
		if (md.virtualMods != 0) {
		    unsigned mask;
		    if (XkbVirtualModsToReal(xkb,md.virtualMods,&mask))
			xkb->compat->groups[i].mask= md.realMods|mask;
		}
		else xkb->compat->groups[i].mask= md.realMods;
	    }
	}
	if (changes)
	    changes->compat.changed_groups|= groups;
    }
    return nRead;
}

static int
ReadXkmIndicators(FILE *file,XkbDescPtr xkb,XkbChangesPtr changes)
{
register unsigned	nLEDs;
xkmIndicatorMapDesc	wire;
char			buf[100];
unsigned		tmp;
int			nRead=0;

    if ((xkb->indicators==NULL)&&(XkbAllocIndicatorMaps(xkb)!=Success)) {
	_XkbLibError(_XkbErrBadAlloc,"indicator rec",0);
	return -1;
    }
    if (XkbAllocNames(xkb,XkbIndicatorNamesMask,0,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"indicator names",0);
	return -1;
    }
    nLEDs= XkmGetCARD8(file,&nRead);
    nRead+= XkmSkipPadding(file,3);
    xkb->indicators->phys_indicators= XkmGetCARD32(file,&nRead);
    while (nLEDs-->0) {
	Atom 			name;
	XkbIndicatorMapPtr	map;

	if ((tmp=XkmGetCountedString(file,buf,100))<1) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmIndicators",0);
	    return -1;
	}
	nRead+= tmp;
	if (buf[0]!='\0')
	     name= XkbInternAtom(buf,FALSE);
	else name= None;
	if ((tmp=fread(&wire,SIZEOF(xkmIndicatorMapDesc),1,file))<1) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmIndicators",0);
	    return -1;
	}
	nRead+= tmp*SIZEOF(xkmIndicatorMapDesc);
	if (xkb->names) {
	    xkb->names->indicators[wire.indicator-1]= name;
	    if (changes)
		changes->names.changed_indicators|= (1<<(wire.indicator-1));
	}
	map= &xkb->indicators->maps[wire.indicator-1];
	map->flags= wire.flags;
	map->which_groups= wire.which_groups;
	map->groups= wire.groups;
	map->which_mods= wire.which_mods;
	map->mods.mask= wire.real_mods;
	map->mods.real_mods= wire.real_mods;
	map->mods.vmods= wire.vmods;
	map->ctrls= wire.ctrls;
    }
    return nRead;
}

static XkbKeyTypePtr
FindTypeForKey(XkbDescPtr xkb,Atom name,unsigned width,KeySym *syms)
{
    if ((!xkb)||(!xkb->map))
	return NULL;
    if (name!=None) {
	register unsigned i;
	for (i=0;i<xkb->map->num_types;i++) {
	    if (xkb->map->types[i].name==name) {
		if (xkb->map->types[i].num_levels!=width)
		    DebugF("Group width mismatch between key and type\n");
		return &xkb->map->types[i];
	    }
	}
    }
    if ((width<2)||((syms!=NULL)&&(syms[1]==NoSymbol)))
	return &xkb->map->types[XkbOneLevelIndex];
    if (syms!=NULL) {
	if (XkbKSIsLower(syms[0])&&XkbKSIsUpper(syms[1]))
	    return &xkb->map->types[XkbAlphabeticIndex];
	else if (XkbKSIsKeypad(syms[0])||XkbKSIsKeypad(syms[1]))
	    return &xkb->map->types[XkbKeypadIndex];
    }
    return &xkb->map->types[XkbTwoLevelIndex];
}

static int
ReadXkmSymbols(FILE *file,XkbDescPtr xkb)
{
register int		i,g,s,totalVModMaps;
xkmKeySymMapDesc 	wireMap;
char 			buf[100];
unsigned		minKC,maxKC,groupNames,tmp;
int			nRead=0;

    if ((tmp=XkmGetCountedString(file,buf,100))<1)
	return -1;
    nRead+= tmp;
    minKC= XkmGetCARD8(file,&nRead);
    maxKC= XkmGetCARD8(file,&nRead);
    groupNames= XkmGetCARD8(file,&nRead);
    totalVModMaps= XkmGetCARD8(file,&nRead);
    if (XkbAllocNames(xkb,
	      XkbSymbolsNameMask|XkbPhysSymbolsNameMask|XkbGroupNamesMask,
	      0,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"physical names",0);
	return -1;
    }
    if ((buf[0]!='\0')&&(xkb->names)) {
	Atom name;
	name= XkbInternAtom(buf,0);
	xkb->names->symbols= name;
	xkb->names->phys_symbols= name;
    }
    for (i=0,g=1;i<XkbNumKbdGroups;i++,g<<=1) {
	if (groupNames&g) {
	    if ((tmp=XkmGetCountedString(file,buf,100))<1)
		return -1;
	    nRead+= tmp;

	    if (!xkb->names)
		    continue;

	    if (buf[0]!='\0') {
		Atom name;
		name= XkbInternAtom(buf,0);
		xkb->names->groups[i]= name;
	    }	
	    else xkb->names->groups[i]= None;
	}
    }
    if (XkbAllocServerMap(xkb,XkbAllServerInfoMask,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"server map",0);
	return -1;
    }
    if (XkbAllocClientMap(xkb,XkbAllClientInfoMask,0)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"client map",0);
	return -1;
    }
    if (XkbAllocControls(xkb,XkbAllControlsMask)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"controls",0);
	return -1;
    }
    if ((xkb->map==NULL)||(xkb->server==NULL))
	return -1;
    if (xkb->min_key_code<8)	xkb->min_key_code= minKC;
    if (xkb->max_key_code<8)	xkb->max_key_code= maxKC;
    if ((minKC>=8)&&(minKC<xkb->min_key_code))
	xkb->min_key_code= minKC;
    if ((maxKC>=8)&&(maxKC>xkb->max_key_code)) {
	_XkbLibError(_XkbErrBadValue,"keys in symbol map",maxKC);
	return -1;
    }
    for (i=minKC;i<=(int)maxKC;i++)  {
	Atom 		typeName[XkbNumKbdGroups];
	XkbKeyTypePtr	type[XkbNumKbdGroups];
	if ((tmp=fread(&wireMap,SIZEOF(xkmKeySymMapDesc),1,file))<1) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmSymbols",0);
	    return -1;
	}
	nRead+= tmp*SIZEOF(xkmKeySymMapDesc);
	memset((char *)typeName, 0, XkbNumKbdGroups*sizeof(Atom));
	memset((char *)type, 0, XkbNumKbdGroups*sizeof(XkbKeyTypePtr));
	if (wireMap.flags&XkmKeyHasTypes) {
	    register int g;
	    for (g=0;g<XkbNumKbdGroups;g++) {
		if ((wireMap.flags&(1<<g))&&
			((tmp=XkmGetCountedString(file,buf,100))>0)) {
		    typeName[g]= XkbInternAtom(buf,1);
		    nRead+= tmp;
		}
		type[g]=FindTypeForKey(xkb,typeName[g],wireMap.width,NULL);
		if (type[g]==NULL) {
		    _XkbLibError(_XkbErrMissingTypes,"ReadXkmSymbols",0);
		    return -1;
		}
		if (typeName[g]==type[g]->name)
		    xkb->server->explicit[i]|= (1<<g);
	    }
	}
	if (wireMap.flags&XkmRepeatingKey) {
	    xkb->ctrls->per_key_repeat[i/8]|= (1<<(i%8));
	    xkb->server->explicit[i]|= XkbExplicitAutoRepeatMask;
	}
	else if (wireMap.flags&XkmNonRepeatingKey) {
	    xkb->ctrls->per_key_repeat[i/8]&= ~(1<<(i%8));
	    xkb->server->explicit[i]|= XkbExplicitAutoRepeatMask;
	}
	xkb->map->modmap[i]= wireMap.modifier_map;
	if (XkbNumGroups(wireMap.num_groups)>0) {
	    KeySym	*sym;
	    int		 nSyms;
	
	    if (XkbNumGroups(wireMap.num_groups)>xkb->ctrls->num_groups)
		xkb->ctrls->num_groups= wireMap.num_groups;
	    nSyms= XkbNumGroups(wireMap.num_groups)*wireMap.width;
	    sym= XkbResizeKeySyms(xkb,i,nSyms);
	    if (!sym)
		return -1;
	    for (s=0;s<nSyms;s++) {
		*sym++= XkmGetCARD32(file,&nRead);
	    }
	    if (wireMap.flags&XkmKeyHasActions) {
		XkbAction *	act;
		act= XkbResizeKeyActions(xkb,i,nSyms);
		for (s=0;s<nSyms;s++,act++) {
		    tmp=fread(act,SIZEOF(xkmActionDesc),1,file);
		    nRead+= tmp*SIZEOF(xkmActionDesc);
		}
		xkb->server->explicit[i]|= XkbExplicitInterpretMask;
	    }
	}
	for (g=0;g<XkbNumGroups(wireMap.num_groups);g++) {
	    if (((xkb->server->explicit[i]&(1<<g))==0)||(type[g]==NULL)) {
		KeySym *tmpSyms;
		tmpSyms= XkbKeySymsPtr(xkb,i)+(wireMap.width*g);
		type[g]= FindTypeForKey(xkb,None,wireMap.width,tmpSyms);
	    }
	    xkb->map->key_sym_map[i].kt_index[g]= type[g]-(&xkb->map->types[0]);
	}
	xkb->map->key_sym_map[i].group_info= wireMap.num_groups;
	xkb->map->key_sym_map[i].width= wireMap.width;
	if (wireMap.flags&XkmKeyHasBehavior) {
	    xkmBehaviorDesc	b;
	    tmp= fread(&b,SIZEOF(xkmBehaviorDesc),1,file);
	    nRead+= tmp*SIZEOF(xkmBehaviorDesc);
	    xkb->server->behaviors[i].type= b.type;
	    xkb->server->behaviors[i].data= b.data;
	    xkb->server->explicit[i]|= XkbExplicitBehaviorMask;
	}
    }
    if (totalVModMaps>0) {
	xkmVModMapDesc	v;
	for (i=0;i<totalVModMaps;i++) {
	    tmp= fread(&v,SIZEOF(xkmVModMapDesc),1,file);
	    nRead+= tmp*SIZEOF(xkmVModMapDesc);
	    if (tmp>0)
		xkb->server->vmodmap[v.key]= v.vmods;
	}
    }
    return nRead;
}

static int
ReadXkmGeomDoodad(
    FILE *		file,
    XkbGeometryPtr	geom,
    XkbSectionPtr	section)
{
XkbDoodadPtr	doodad;
xkmDoodadDesc	doodadWire;
char		buf[100];
unsigned	tmp;
int		nRead=0;

    nRead+= XkmGetCountedString(file,buf,100);
    tmp= fread(&doodadWire,SIZEOF(xkmDoodadDesc),1,file);
    nRead+= SIZEOF(xkmDoodadDesc)*tmp;
    doodad= XkbAddGeomDoodad(geom,section,XkbInternAtom(buf,FALSE));
    if (!doodad)
	return nRead;
    doodad->any.type= doodadWire.any.type;
    doodad->any.priority= doodadWire.any.priority;
    doodad->any.top= doodadWire.any.top;
    doodad->any.left= doodadWire.any.left;
    switch (doodadWire.any.type) {
	case XkbOutlineDoodad:
	case XkbSolidDoodad:
	    doodad->shape.angle= doodadWire.shape.angle;
	    doodad->shape.color_ndx= doodadWire.shape.color_ndx;
	    doodad->shape.shape_ndx= doodadWire.shape.shape_ndx;
	    break;
	case XkbTextDoodad:
	    doodad->text.angle= doodadWire.text.angle;
	    doodad->text.width= doodadWire.text.width;
	    doodad->text.height= doodadWire.text.height;
	    doodad->text.color_ndx= doodadWire.text.color_ndx;
	    nRead+= XkmGetCountedString(file,buf,100);
	    doodad->text.text= Xstrdup(buf);
	    nRead+= XkmGetCountedString(file,buf,100);
	    doodad->text.font= Xstrdup(buf);
	    break;
	case XkbIndicatorDoodad:
	    doodad->indicator.shape_ndx= doodadWire.indicator.shape_ndx;
	    doodad->indicator.on_color_ndx= doodadWire.indicator.on_color_ndx;
	    doodad->indicator.off_color_ndx= doodadWire.indicator.off_color_ndx;
	    break;
	case XkbLogoDoodad:
	    doodad->logo.angle= doodadWire.logo.angle;
	    doodad->logo.color_ndx= doodadWire.logo.color_ndx;
	    doodad->logo.shape_ndx= doodadWire.logo.shape_ndx;
	    nRead+= XkmGetCountedString(file,buf,100);
	    doodad->logo.logo_name= Xstrdup(buf);
	    break;
	default:
	    /* report error? */
	    return nRead;
    }
    return nRead;
}

static int
ReadXkmGeomOverlay(	FILE *		file,
			XkbGeometryPtr	geom,
			XkbSectionPtr	section)
{
char 			buf[100];
unsigned		tmp;
int			nRead=0;
XkbOverlayPtr		ol;
XkbOverlayRowPtr	row;
xkmOverlayDesc 		olWire;
xkmOverlayRowDesc	rowWire;
register int		r;

    nRead+= XkmGetCountedString(file,buf,100);
    tmp= fread(&olWire,SIZEOF(xkmOverlayDesc),1,file);
    nRead+= tmp*SIZEOF(xkmOverlayDesc);
    ol= XkbAddGeomOverlay(section,XkbInternAtom(buf,FALSE),
    							olWire.num_rows);
    if (!ol)
	return nRead;
    for (r=0;r<olWire.num_rows;r++)  {
    	int			k;
	xkmOverlayKeyDesc	keyWire;
	tmp= fread(&rowWire,SIZEOF(xkmOverlayRowDesc),1,file);
	nRead+= tmp*SIZEOF(xkmOverlayRowDesc);
	row= XkbAddGeomOverlayRow(ol,rowWire.row_under,rowWire.num_keys);
	if (!row) {
	    _XkbLibError(_XkbErrBadAlloc,"ReadXkmGeomOverlay",0);
	   return nRead;
	}
	for (k=0;k<rowWire.num_keys;k++) {
	    tmp= fread(&keyWire,SIZEOF(xkmOverlayKeyDesc),1,file);
	    nRead+= tmp*SIZEOF(xkmOverlayKeyDesc);
	    memcpy(row->keys[k].over.name,keyWire.over,XkbKeyNameLength);
	    memcpy(row->keys[k].under.name,keyWire.under,XkbKeyNameLength);
	}
	row->num_keys= rowWire.num_keys;
    }
    return nRead;
}

static int
ReadXkmGeomSection(	FILE *		file,
			XkbGeometryPtr	geom)
{
register int	i;
XkbSectionPtr	section;
xkmSectionDesc	sectionWire;
unsigned	tmp;
int		nRead= 0;
char		buf[100];
Atom		nameAtom;

    nRead+= XkmGetCountedString(file,buf,100);
    nameAtom= XkbInternAtom(buf,FALSE);
    tmp= fread(&sectionWire,SIZEOF(xkmSectionDesc),1,file);
    nRead+= SIZEOF(xkmSectionDesc)*tmp;
    section= XkbAddGeomSection(geom,nameAtom,sectionWire.num_rows,
			 			sectionWire.num_doodads,
			 			sectionWire.num_overlays);
    if (!section) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeomSection",0);
	return nRead;
    }
    section->top= sectionWire.top;
    section->left= sectionWire.left;
    section->width= sectionWire.width;
    section->height= sectionWire.height;
    section->angle= sectionWire.angle;
    section->priority= sectionWire.priority;
    if (sectionWire.num_rows>0) {
	register int	k;
	XkbRowPtr	row;
	xkmRowDesc	rowWire;
	XkbKeyPtr	key;
	xkmKeyDesc	keyWire;

	for (i=0;i<sectionWire.num_rows;i++) {
	    tmp= fread(&rowWire,SIZEOF(xkmRowDesc),1,file);
	    nRead+= SIZEOF(xkmRowDesc)*tmp;
	    row= XkbAddGeomRow(section,rowWire.num_keys);
	    if (!row) {
		_XkbLibError(_XkbErrBadAlloc,"ReadXkmKeycodes",0);
		return nRead;
	    }
	    row->top= rowWire.top;
	    row->left= rowWire.left;
	    row->vertical= rowWire.vertical;
	    for (k=0;k<rowWire.num_keys;k++) {
		tmp= fread(&keyWire,SIZEOF(xkmKeyDesc),1,file);
		nRead+= SIZEOF(xkmKeyDesc)*tmp;
		key= XkbAddGeomKey(row);
		if (!key) {
		    _XkbLibError(_XkbErrBadAlloc,"ReadXkmGeomSection",0);
		    return nRead;
		}
		memcpy(key->name.name,keyWire.name,XkbKeyNameLength);
		key->gap= keyWire.gap;
		key->shape_ndx= keyWire.shape_ndx;
		key->color_ndx= keyWire.color_ndx;
	    }
	}
    }
    if (sectionWire.num_doodads>0) {
	for (i=0;i<sectionWire.num_doodads;i++) {
	    tmp= ReadXkmGeomDoodad(file,geom,section);
	    nRead+= tmp;
	    if (tmp<1)
		return nRead;
	}
    }
    if (sectionWire.num_overlays>0) {
	for (i=0;i<sectionWire.num_overlays;i++) {
	    tmp= ReadXkmGeomOverlay(file,geom,section);
	    nRead+= tmp;
	    if (tmp<1)
		return nRead;
	}
    }
    return nRead;
}

static int
ReadXkmGeometry(FILE *file,XkbDescPtr xkb)
{
register int		i;
char 			buf[100];
unsigned		tmp;
int			nRead= 0;
xkmGeometryDesc		wireGeom;
XkbGeometryPtr		geom;
XkbGeometrySizesRec	sizes;

    nRead+= XkmGetCountedString(file,buf,100);
    tmp= fread(&wireGeom,SIZEOF(xkmGeometryDesc),1,file);
    nRead+= tmp*SIZEOF(xkmGeometryDesc);
    sizes.which= XkbGeomAllMask;
    sizes.num_properties= wireGeom.num_properties;
    sizes.num_colors= wireGeom.num_colors;
    sizes.num_shapes= wireGeom.num_shapes;
    sizes.num_sections= wireGeom.num_sections;
    sizes.num_doodads= wireGeom.num_doodads;
    sizes.num_key_aliases= wireGeom.num_key_aliases;
    if (XkbAllocGeometry(xkb,&sizes)!=Success) {
	_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
	return nRead;
    }
    geom= xkb->geom;
    geom->name= XkbInternAtom(buf,FALSE);
    geom->width_mm= wireGeom.width_mm;
    geom->height_mm= wireGeom.height_mm;
    nRead+= XkmGetCountedString(file,buf,100);
    geom->label_font= Xstrdup(buf);
    if (wireGeom.num_properties>0) {
	char val[1024];
	for (i=0;i<wireGeom.num_properties;i++) {
	    nRead+= XkmGetCountedString(file,buf,100);
	    nRead+= XkmGetCountedString(file,val,1024);
	    if (XkbAddGeomProperty(geom,buf,val)==NULL) {
		_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
		return nRead;
	    }
	}
    }
    if (wireGeom.num_colors>0) {
	for (i=0;i<wireGeom.num_colors;i++) {
	    nRead+= XkmGetCountedString(file,buf,100);
	    if (XkbAddGeomColor(geom,buf,i)==NULL) {
		_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
		return nRead;
	    }
	}
    }
    geom->base_color= &geom->colors[wireGeom.base_color_ndx];
    geom->label_color= &geom->colors[wireGeom.label_color_ndx];
    if (wireGeom.num_shapes>0) {
	XkbShapePtr	shape;
	xkmShapeDesc	shapeWire;
	Atom		nameAtom;
	for (i=0;i<wireGeom.num_shapes;i++) {
	    register int 	n;
	    XkbOutlinePtr	ol;
	    xkmOutlineDesc	olWire;
	    nRead+= XkmGetCountedString(file,buf,100);
	    nameAtom= XkbInternAtom(buf,FALSE);
	    tmp= fread(&shapeWire,SIZEOF(xkmShapeDesc),1,file);
	    nRead+= tmp*SIZEOF(xkmShapeDesc);
	    shape= XkbAddGeomShape(geom,nameAtom,shapeWire.num_outlines);
	    if (!shape) {
		_XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
		return nRead;
	    }
	    for (n=0;n<shapeWire.num_outlines;n++) {
		register int	p;
		xkmPointDesc	ptWire;
		tmp= fread(&olWire,SIZEOF(xkmOutlineDesc),1,file);
		nRead+= tmp*SIZEOF(xkmOutlineDesc);
		ol= XkbAddGeomOutline(shape,olWire.num_points);
		if (!ol) {
		    _XkbLibError(_XkbErrBadAlloc,"ReadXkmGeometry",0);
		    return nRead;
		}
		ol->num_points= olWire.num_points;
		ol->corner_radius= olWire.corner_radius;
		for (p=0;p<olWire.num_points;p++) {
		    tmp= fread(&ptWire,SIZEOF(xkmPointDesc),1,file);
		    nRead+= tmp*SIZEOF(xkmPointDesc);
		    ol->points[p].x= ptWire.x;
		    ol->points[p].y= ptWire.y;
		    if (ptWire.x<shape->bounds.x1) shape->bounds.x1= ptWire.x;
		    if (ptWire.x>shape->bounds.x2) shape->bounds.x2= ptWire.x;
		    if (ptWire.y<shape->bounds.y1) shape->bounds.y1= ptWire.y;
		    if (ptWire.y>shape->bounds.y2) shape->bounds.y2= ptWire.y;
		}
	    }
	    if (shapeWire.primary_ndx!=XkbNoShape)
		shape->primary= &shape->outlines[shapeWire.primary_ndx];
	    if (shapeWire.approx_ndx!=XkbNoShape)
		shape->approx= &shape->outlines[shapeWire.approx_ndx];
	}
    }
    if (wireGeom.num_sections>0) {
	for (i=0;i<wireGeom.num_sections;i++) {
	    tmp= ReadXkmGeomSection(file,geom);
	    nRead+= tmp;
	    if (tmp==0)
		return nRead;
	}
    }
    if (wireGeom.num_doodads>0) {
	for (i=0;i<wireGeom.num_doodads;i++) {
	    tmp= ReadXkmGeomDoodad(file,geom,NULL);
	    nRead+= tmp;
	    if (tmp==0)
		return nRead;
	}
    }
    if ((wireGeom.num_key_aliases>0)&&(geom->key_aliases)) {
	int sz= XkbKeyNameLength*2;
	int num= wireGeom.num_key_aliases;
	if (fread(geom->key_aliases,sz,num,file)!=num) {
	    _XkbLibError(_XkbErrBadLength,"ReadXkmGeometry",0);
	    return -1;
	}
	nRead+= (num*sz);
	geom->num_key_aliases= num;
    }
    return nRead;
}

Bool
XkmProbe(FILE *file)
{
unsigned hdr,tmp;
int	 nRead=0;

    hdr= (('x'<<24)|('k'<<16)|('m'<<8)|XkmFileVersion);
    tmp= XkmGetCARD32(file,&nRead);
    if (tmp!=hdr) {
	if ((tmp&(~0xff))==(hdr&(~0xff))) {
	    _XkbLibError(_XkbErrBadFileVersion,"XkmProbe",tmp&0xff);
	}
	return 0;
    }
    return 1;
}

static Bool
XkmReadTOC(FILE *file,xkmFileInfo* file_info,int max_toc,xkmSectionInfo *toc)
{
unsigned hdr,tmp;
int	nRead=0;
unsigned i,size_toc;

    hdr= (('x'<<24)|('k'<<16)|('m'<<8)|XkmFileVersion);
    tmp= XkmGetCARD32(file,&nRead);
    if (tmp!=hdr) {
	if ((tmp&(~0xff))==(hdr&(~0xff))) {
	    _XkbLibError(_XkbErrBadFileVersion,"XkmReadTOC",tmp&0xff);
	}
	else {
	    _XkbLibError(_XkbErrBadFileType,"XkmReadTOC",tmp);
	}
	return 0;
    }
    fread(file_info,SIZEOF(xkmFileInfo),1,file);
    size_toc= file_info->num_toc;
    if (size_toc>max_toc) {
	DebugF("Warning! Too many TOC entries; last %d ignored\n",
							size_toc-max_toc);
	size_toc= max_toc;
    }
    for (i=0;i<size_toc;i++) {
	fread(&toc[i],SIZEOF(xkmSectionInfo),1,file);
    }
    return 1;
}

/***====================================================================***/

#define	MAX_TOC	16
unsigned
XkmReadFile(FILE *file,unsigned need,unsigned want,XkbDescPtr *xkb)
{
register unsigned	i;
xkmSectionInfo		toc[MAX_TOC],tmpTOC;
xkmFileInfo		fileInfo;
unsigned		tmp,nRead=0;
unsigned		which= need|want;

    if (!XkmReadTOC(file,&fileInfo,MAX_TOC,toc))
	return which;
    if ((fileInfo.present&need)!=need) {
       _XkbLibError(_XkbErrIllegalContents,"XkmReadFile",
       						need&(~fileInfo.present));
       return which;
    }
    if (*xkb==NULL)
	*xkb= XkbAllocKeyboard();
    for (i=0;i<fileInfo.num_toc;i++) {
	fseek(file,toc[i].offset,SEEK_SET);
	tmp= fread(&tmpTOC,SIZEOF(xkmSectionInfo),1,file);
	nRead= tmp*SIZEOF(xkmSectionInfo);
	if ((tmpTOC.type!=toc[i].type)||(tmpTOC.format!=toc[i].format)||
	    (tmpTOC.size!=toc[i].size)||(tmpTOC.offset!=toc[i].offset)) {
	    return which;
	}
	if ((which&(1<<tmpTOC.type))==0) {
	    continue;
	}
	switch (tmpTOC.type) {
	    case XkmVirtualModsIndex:
		tmp= ReadXkmVirtualMods(file,*xkb,NULL);
		break;
	    case XkmTypesIndex:
		tmp= ReadXkmKeyTypes(file,*xkb,NULL);
		break;
	    case XkmCompatMapIndex:
		tmp= ReadXkmCompatMap(file,*xkb,NULL);
		break;
	    case XkmKeyNamesIndex:
		tmp= ReadXkmKeycodes(file,*xkb,NULL);
		break;
	    case XkmIndicatorsIndex:
		tmp= ReadXkmIndicators(file,*xkb,NULL);
		break;
	    case XkmSymbolsIndex:
		tmp= ReadXkmSymbols(file,*xkb);
		break;
	    case XkmGeometryIndex:
		tmp= ReadXkmGeometry(file,*xkb);
		break;
	    default:
		_XkbLibError(_XkbErrBadImplementation,
				XkbConfigText(tmpTOC.type,XkbMessage),0);
		tmp= 0;
		break;
	}
	if (tmp>0) {
	    nRead+= tmp;
	    which&= ~(1<<toc[i].type);
	    (*xkb)->defined|= (1<<toc[i].type);
	}
	if (nRead!=tmpTOC.size) {
	    _XkbLibError(_XkbErrBadLength,XkbConfigText(tmpTOC.type,XkbMessage),
	    						nRead-tmpTOC.size);
	}
    }
    return which;
}
                        XKM File Format Description
                                Version 15

1. Introduction

The XKM file format is the exchange format for XKB keyboard descriptions
between the server and xkbcomp. Usually, the server forks off xkbcomp,
xkbcomp compiles the XKM format from the given parameters.
The resulting XKM file is put into a directory readable by the server and
then parsed.

The XKM format is little more than a binary dump of various XKB-specific
structures and hence tied to the ABI of the server.

                              ❧❧❧❧❧❧❧❧❧❧❧

1.1 About this file format description

This description was produced by analyzing the XKM parsing code. Parts of
the file description present in the original format specification may be
missing. This description thus cannot be a reference document for XKM
implementations.

No description of the meaning of the various fields is given here. Refer to
the XKB protocol specification for more details.
                              ❧❧❧❧❧❧❧❧❧❧❧

2. Notations used in this document

Notation for structures:

┌───
  Name of struct
	name of field:		type or fixed value of field
	name of field:		type or fixed value of field
└───

Data types are identical to those used in the X Protocol specification
except where noted otherwise. Structs specific to XKM are prefixed with XKM,
defines specific to the XKB protocol specification are prefixed with Xkb and
their value is equivalent to that in the protocol specification.

Multiple instances of a given type are denoted in the following form:
	name of field:		LISTofFIELDTYPE

Length specifiers for such fields are usually prefixed with num_. For
example, a struct containing a num_foo of 8 and a 'foo' field contains 8
structures of type 'foo'.

Variable length padding is specified as pad(x), where x is the length of the
data to be padded out to a multiple of 4 bytes. For example, given an x of
10, pad(x) would be the remaining 2 bytes to pad the whole struct to 12
bytes.

A special notation is a variable content struct. In this case, the contents
of the struct depend on the value of one or more specific fields.
┌───
  Name of struct
	field:			type or fixed value of field
	field:			type or fixed value of field
	───
	field ⇒ value 1
	⇒
		specific field:		type
		specific field:		type
	───
        field ⇒ value 2
	⇒
		specific field:		type
		specific field:		type
└───
This notation denotes that if field is of value 1, this struct contains the
specific fields listed underneath value 1.

                              ❧❧❧❧❧❧❧❧❧❧❧

3. XKM Format

The XKM format is a binary format with structs usually being padded to a
multiple of 4 bytes. No provisions for endianess are provided, the parser is
left to guess the endianess of the XKM file.

                              ❧❧❧❧❧❧❧❧❧❧❧
3.1 Common data types

┌───
  XKMCountedString
	count:			CARD16
	string:			count * CHAR
	pad:			pad(count + 2)
└───

XKMCountedString is used for user-readable identifiers. Prime example are
the level names and the section names ("complete", "evdev(inet)", etc.)

┌───
  XKMGroupBits:		CARD8
	group1			0x1
	group2			0x2
	group3			0x4
	group4			0x8
└───

                              ❧❧❧❧❧❧❧❧❧❧❧

3.2 Header and Table of Contents

┌───
  XKMHeader
	version:		CARD8
	identifier1:		'm'
	identifier2:		'k'
	idenfifier3:		'x'
└───

The XKM file format has a 4 byte header identifying the file and the XKM
version. The header is followed by the table of contents indicating the
sections present in this file.

┌───
  XKMFileInfo
	type:			CARD8
	min_keycode:		CARD8
	max_keycode:		CARD8
	num_sectioninfo:	CARD8
	present:		CARD16
	pad:			CARD16
	sectioninfo:		LISTofXKMSectionInfo
└───

min_keycode and max_keycode specify the keycode range for this keyboard
descriptions. The core protocol requires min_keycode always be equal to or
greater than 8.

┌───
  XKMSectionInfo
	type:			CARD16
		XkmTypesIndex		0
		XkmCompatMapIndex	1
		XkmSymbolsIndex		2
		XkmIndicatorsIndex	3
		XkmKeyNamesIndex	4
		XkmGeometryIndex	5
		XkmVirtualModsIndex	6
	format:			CARD16
	size:			CARD16
	offset:			CARD16
└───

Describes the section found in a chunk of a file. This struct is found
_twice_ in the file per section, once as part of the XKMFileInfo, once at
the beginning of the actual section (see offset).
The type specifies the type of the section, the section is to be parsed
according to this type.
Size and offset specify the size in bytes and the offset into the file in
bytes, respectively.

3.3 Sections

Each section resides at the offset specified in the XKMFileInfo sectioninfo.

                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.1 XKMTypes

An XKMTypes section describes the key types defined in a layout. Roughly
speaking, a key type defines how many levels a given key has and which
modifiers change to a particular level.

┌───
  XKMTypesSection
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	num_types:		CARD16
	pad:			CARD16
	types:			LISTofXKMKeyType
└───

┌───
  XKMKeyType
	real_mods:		CARD8
	num_levels:		CARD8
	virt_mods:		CARD16
	num_map_entries: 	CARD8
	num_level_names: 	CARD8
	perserve:	 	CARD8
	pad:			CARD8
	map_entries:		LISTofXKMKTMapEntry
	name:			XKMCountedString
	mods:			LISTofXKMModsDesc
	level_names:		LISXTofXKMCountedString
└───

The num_map_entries specifies the number of structs in both map_entries and mods. mods is only present if preserve is TRUE.

┌───
  XKMKTMapEntry
	level:			CARD8
	real_mods:		CARD8
	virt_mods:		CARD16
└───

┌───
  XKMModsDesc
	real_mods:		CARD8
	pad:			CARD8
	virt_mods:		CARD16
└───

                              ❧❧❧❧❧❧❧❧❧❧❧
3.3.2 XKMCompatMap

An XKMCompatMap section describes the actions a keyboard may trigger. This
ranges from the TerminateServer action to simple modifier bits.

┌───
  XKMCompatMap
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	num_si:			CARD16
	group_mask:		XKMGroupBits
	pad:			CARD8
	si:			LISTofXKMSymInterpreterDesc
	groups:			LISTofXKMModsDesc
└───

One XKMModsDesc is present for each bit set in group_mask.

┌───
  XKMSymInterpretDesc
	sym:			CARD32
	mods:			CARD8
	match:			CARD8
	virtual_mod:		CARD8
	flags:			CARD8
	action_type:		CARD8
	action_data:		XKMActionData
└───

Where the action is 7 bytes of CARD8 whose content is determined by
action_type.

┌───
  XKMActionData:
	pad0:			CARD8
	pad1:			CARD16
	pad2:			CARD32
	───
        action_type ⇒ XkbSA_SetMods ||
        action_type ⇒ XkbSA_LatchMods ||
        action_type ⇒ XkbSA_LockMods
	⇒
		flags:			CARD8
		mask:			CARD8
		real_mods:		CARD8
		vmods1:			CARD8
		vmods2:			CARD8
		pad:			CARD16
	───
        action_type ⇒ XkbSA_SetGroup ||
        action_type ⇒ XkbSA_LatchGroup ||
        action_type ⇒ XkbSA_LockGroup
	⇒
		flags:			CARD8
		group_XXX:		CARD8
		pad0:			CARD8
		pad1:			CARD32
	───
        action_type ⇒ XkbSA_MovePtr
	⇒
		flags:			CARD8
		high_XXX:		CARD8
		low_XXX:		CARD8
		high_YYY:		CARD8
		low_YYY:		CARD8
		pad:			CARD16
	───
        action_type ⇒ XkbSA_PtrBtn ||
        action_type ⇒ XkbSA_LockPtrBtn
	⇒
		flags:			CARD8
		count:			CARD8
		button:			CARD8
		pad:			CARD32
	───
        action_type ⇒ XkbSA_DeviceBtn ||
        action_type ⇒ XkbSA_LockLockPtrBtn
	⇒
		flags:			CARD8
		count:			CARD8
		button:			CARD8
		device:			CARD8
		pad0:			CARD8
		pad1:			CARD16
	───
        action_type ⇒ XkbSA_SetPtrDflt
	⇒
		flags:			CARD8
		affect:			CARD8
		valueXXX:		CARD8
		pad0:			CARD32
	───
        action_type ⇒ XkbSA_ISOLock
	⇒
		flags:			CARD8
		mask:			CARD8
		real_mods:		CARD8
		group_XXX:		CARD8
		affect:			CARD8
		vmods1:			CARD8
		vmods1:			CARD8
	───
        action_type ⇒ XkbSA_SwitchScreen
	⇒
		flags:			CARD8
		screenXXX:		CARD8
		pad0:			CARD8
		pad1:			CARD32
	───
        action_type ⇒ XkbSA_SetControls ||
        action_type ⇒ XkbSA_LockControls
	⇒
		flags:			CARD8
		ctrls3:			CARD8
		ctrls2:			CARD8
		ctrls1:			CARD8
		ctrls0:			CARD8
		pad:			CARD16
	───
        action_type ⇒ XkbSA_RedirectKey
	⇒
		new_key:		CARD8
		mods_mask:		CARD8
		mods:			CARD8
		vmods_mask0:		CARD8
		vmods_mask1:		CARD8
		vmods0:			CARD8
		vmods1:			CARD8
	───
        action_type ⇒ XkbSA_DeviceValuator
	⇒
		device:		CARD8
		v1_what:		CARD8
		v1_idx:			CARD8
		v1_value:		CARD8
		v2_what:		CARD8
		v2_idx:			CARD8
		v2_value:		CARD8
		pad:			CARD8
	───
        action_type ⇒ XkbSA_XFree86Private ||
        action_type ⇒ XkbSA_Terminate
	⇒
		pad0:			CARD8
		pad1:			CARD16
		pad2:			CARD32
	───
        action_type ⇒ XkbSA_ActionMessage
	⇒
		press_msg:		BOOL
		release_msg:		BOOL
		gen_event:		BOOL
		message:		4 * CHAR
└───

Note: XkbSA_ActionMessage is currently unsupported and the contents are
ignored.

                              ❧❧❧❧❧❧❧❧❧❧❧
3.3.3 XkmSymbols

The symbols in a keymap define the actual keysyms each key may produce.

┌───
  XKMSymbols
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	min_keycode:		CARD8
	max_keycode:		CARD8
	group_names_mask:	XKMGroupBits
	num_vmod_maps:		CARD8
	group_names:		LISTofXKMCountedString
	keysyms:		XKMKeysymMapDesc
	vmod_maps:		XKMVModMapDesc
└───
One group_name is present for each bit set in group_names_mask.
The number of keysyms present is max_keycode - min_keycode + 1.

┌───
  XKMKeysymMapDesc
	width:			CARD8
	num_groups:		CARD8
	modifier_map:		CARD8
	flags:			CARD8
	names:			LISTofXKMCountedString
	syms:			LISTofCARD32
	behavior:		XKMBehaviorDesc
└───

Presence of names is conditional on the XkmKeyHasTypes flag. The number of
strings is equal to the number of group bits in group_names_mask in the
preceeding XKMSymbols section.
The number of elements in syms is equal to width * num_groups.
Presence of behavior is conditional on the XkmKeyHasBehavior flag.

┌───
  XKMKeyBehaviorDesc
	type:			CARD8
	data:			CARD8
	pad:			CARD16
└───

┌───
  XKMVModMapDesc
	key:			CARD8
	pad:			CARD8
	vmods:			CARD16
└───

                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.4 XKMIndicators

┌───
  XKMIndicators
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	num_indicators:		CARD8
	pad0:			CARD8
	pad1:			CARD16
	indicators:		LISTofXKMIndicatorMapDesc
└───

┌───
  XKMIndicatorMapDesc
	name:			XKMCountedString
	indicator:		CARD8
	flags:			CARD8
	which_mods:		CARD8
	real_mods:		CARD8
	vmods:			CARD16
	which_groups:		CARD8
	groups:			CARD8
	ctrls:			CARD32
└───
                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.5 XKMKeyNames

┌───
  XKMKeyNames
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	min_keycode:		CARD8
	max_keycode:		CARD8
	num_aliases:		CARD8
	pad:			CARD8
	keynames:		LISTofXKMKeyname
	aliases:		LISTofXKMKeyAlias
└───

keynames contains max_keycode - min_keycode + 1 entries.

┌───
  XkmKeyname
	name:			4 * CHAR8
└───

┌───
  XkmKeyAlias
	real:			XkmKeyname
	alias:			XkmKeyname
└───

                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.5 XKMGeometry

┌───
  XKMGeometry
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	width_mm:		CARD16
	height_mm:		CARD16
	base_color_ndx:		CARD8
	label_color_ndx:	CARD8
	num_properties:		CARD16
	num_colors:		CARD16
	num_shapes:		CARD16
	num_sections:		CARD16
	num_doodads:		CARD16
	num_key_aliases:	CARD16
	pad:			CARD16
	label_font:		XKMCountedString
	properties:		LISTofXKMGeomProperty
	colors:			LISTofXKMCountedString
	shapes:			LISTofXKMGeomShape
	sections:		LISTofXKMGeomSection
	doodads:		LISTofXKMGeomDoodad
	key_aliases:		LISTofXKMKeyAlias
└───

┌───
  XKMGeomProperty
	name:			XKMCountedString
	value:			XKMCountedString

└───

┌───
  XKMGeomShape
	name:			XKMCountedString
	num_outlines:		CARD8
	primary_idx:		CARD8
	approx_idx:		CARD8
	pad:			CARD8
	outlines:		LISTofXKMOutlineDesc
└───

┌───
  XKMOutlineDesc
	num_points:		CARD8
	corner_radius:		CARD8
	pad:			CARD16
	points:			LISTofXKMPointDesc
└───

┌───
  XKMPointDesc
	x:			INT16
	y:			INT16
└───

┌───
  XKMGeomSection
	name:			XKMCountedString
	top:			INT16
	left:			INT16
	width:			CARD16
	height:			CARD16
	angle:			INT16
	priority:		CARD8
	num_rows:		CARD8
	num_doodads:		CARD8
	num_overlays:		CARD8
	pad:			CARD16
	rows:			LISTofXKMRowDesc
	doodads:		LISTofXKMGeomDoodad
	overlays:		LISTofXKMGeomOverlay
└───

┌───
  XKMRowDesc
	top:			INT16
	left:			INT16
	num_keys:		CARD8
	vertical:		BOOL
	pad:			CARD16
	keys:			XKMKeyDesc
└───

┌───
  XKMKeyDesc
	name:			XKMKeyname
	gap:			INT16
	shape_idx:		CARD8
	color_idx:		CARD8
└───

┌───
  XKMGeomDoodad
	name:			XKMCountedString
	type:			CARD8
	priority:		CARD8
	top:			INT16
	left:			INT16
	pad1:			CARD16
	pad2:			CARD32
	pad3:			CARD32
	───
        type ⇒ XkbOutlineDoodad ||
        type ⇒ XkbSolideDoodad
	⇒
		type:			CARD8
		priority:		CARD8
		top:			INT16
		left:			INT16
		angle:			INT16
		color_idx:		CARD8
		shape_idx:		CARD8
		pad0:			CARD16
		pad1:			CARD32
	───
        type ⇒ XkbTextDoodad
	⇒
		type:			CARD8
		priority:		CARD8
		top:			INT16
		left:			INT16
		angle:			INT16
		width:			CARD16
		height:			CARD16
		color_idx:		CARD8
		pad0:			CARD8
		pad1:			CARD16
		text:			XKMCountedString
		font:			XKMCountedString
	───
        type ⇒ XkbIndicatorDoodad
	⇒
		type:			CARD8
		priority:		CARD8
		top:			INT16
		left:			INT16
		shape_idx:		CARD8
		on_color_idx:		CARD8
		off_color_idx:		CARD8
		pad0:			CARD8
		pad1:			CARD16
		pad2:			CARD32
	───
        type ⇒ XkbLogoDoodad
	⇒
		type:			CARD8
		priority:		CARD8
		top:			INT16
		left:			INT16
		angle:			INT16
		color_idx:		CARD8
		shape_idx:		CARD8
		pad0:			CARD16
		pad1:			CARD32
		logo_name:		XKMCountedString
└───

WARNING: XKMGeomDoodad has variable length depending on the type.
NOTE: The current server implementation does not use all fields of all
structures.

┌───
  XKMOverlayDesc
	name:			XKMCountedString
	num_rows:		CARD8
	pad0:			CARD8
	pad1:			CARD16
	rows:			LISTofXKMOverlayRowDesc
└───

┌───
  XKMOverlayRowDesc
	name:			XKMCountedString
	row_under:		CARD8
	num_keys:		CARD8
	pad:			CARD16
	keys:			LISTofXKMOverlayKeyDesc
└───

┌───
  XKMOverlayKeyDesc
	over:			XKMKeyname
	under:			XKMKeyname
└───

                              ❧❧❧❧❧❧❧❧❧❧❧

3.3.6 XKMVirtualMods

┌───
  XKMOverlayRowDesc
	section_info:		XKMSectionInfo
	name:			XKMCountedString
	bound_mask:		SETofVMODBITS
	named_mask:		SETofVMODBITS
	vmods:			LISTofCARD8
	pad:			pad(vmods)
	names:			LISTofXKMCountedString
└───

	VMODBITS:		CARD16

Number of elements in vmods is equal to the number of bits set in
bound_mask. The padding completes vmods to a multiple of 4 byte units.
Number of elements in names is equal to the number of bits set in
named_mask.
dnl Copyright 2005 Red Hat, Inc
dnl 
dnl Permission to use, copy, modify, distribute, and sell this software and its
dnl documentation for any purpose is hereby granted without fee, provided that
dnl the above copyright notice appear in all copies and that both that
dnl copyright notice and this permission notice appear in supporting
dnl documentation.
dnl 
dnl The above copyright notice and this permission notice shall be included
dnl in all copies or substantial portions of the Software.
dnl 
dnl THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
dnl OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
dnl MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
dnl IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
dnl OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
dnl ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
dnl OTHER DEALINGS IN THE SOFTWARE.
dnl 
dnl Except as contained in this notice, the name of the copyright holders shall
dnl not be used in advertising or otherwise to promote the sale, use or
dnl other dealings in this Software without prior written authorization
dnl from the copyright holders.
dnl 

# XORG_DRIVER_CHECK_EXT()
# --------------------------
# Checks for the $1 define in xorg-server.h (from the sdk).  If it
# is defined, then add $1 to $REQUIRED_MODULES.

AC_DEFUN([XORG_DRIVER_CHECK_EXT],[
	AC_REQUIRE([PKG_PROG_PKG_CONFIG])
	SAVE_CFLAGS="$CFLAGS"
	CFLAGS="$CFLAGS -I`$PKG_CONFIG --variable=sdkdir xorg-server`"
	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
#include "xorg-server.h"
#if !defined $1
#error $1 not defined
#endif
		]])],
		[_EXT_CHECK=yes],
		[_EXT_CHECK=no])
	CFLAGS="$SAVE_CFLAGS"
	AC_MSG_CHECKING([if $1 is defined])
	AC_MSG_RESULT([$_EXT_CHECK])
	if test "$_EXT_CHECK" != no; then
		REQUIRED_MODULES="$REQUIRED_MODULES $2"
	fi
])
prefix=@prefix@
exec_prefix=@exec_prefix@
libdir=@libdir@
includedir=@includedir@
datarootdir=@datarootdir@
moduledir=@moduledir@
sdkdir=@sdkdir@
sysconfigdir=@sysconfigdir@

abi_ansic=@abi_ansic@
abi_videodrv=@abi_videodrv@
abi_xinput=@abi_xinput@
abi_extension=@abi_extension@

Name: xorg-server
Description: Modular X.Org X Server
Version: @PACKAGE_VERSION@
Requires: pixman-1 pciaccess
Requires.private: @SDK_REQUIRED_MODULES@
Cflags: -I${sdkdir} @symbol_visibility@
Libs: -L${libdir}
<!-- shared -*-xml-*- entity definitions for the X server documentation -->
<!ENTITY xserver.version "@PACKAGE_VERSION@">
<!ENTITY xserver.reldate "@RELEASE_DATE@">
export TERM=xterm-256color

# user
# /c/msys64/msys2_shell.cmd -defterm -here -no-start -msys2 -shell bash -c "pacman -S --noconfirm --needed cmake ninja gcc ; ./make.sh"

# we must build with gcc as msys2 libs require __data and __bss segments which clang does not provide
#

export c_compiler="clang"
export cxx_compiler="clang++"

export ACLOCAL_PATH="/usr/share/aclocal-1.16:../../ROOTFS/share/aclocal"

cmake -G "Ninja" $1 -DCMAKE_INSTALL_PREFIX="$(pwd)/BUILD_DEBUG/BUILD_ROOT/ROOTFS" -DLLVM_BUILD_ROOT__ROOTFS="$(pwd)/BUILD_DEBUG/BUILD_ROOT/ROOTFS" -DCMAKE_C_COMPILER="$c_compiler" -DCMAKE_CXX_COMPILER="$cxx_compiler" -DCMAKE_BUILD_TYPE=Debug -DCMAKE_COLOR_DIAGNOSTICS=ON -DCMAKE_COLOR_MAKEFILE=ON -S . -B BUILD_DEBUG &&
cmake --build BUILD_DEBUG &&
cmake --install BUILD_DEBUG
rm -rf BUILD_DEBUG ; ./make.sh
https://xorg.freedesktop.org/releases/individual/
